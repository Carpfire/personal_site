// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Command__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Command = [0],
    Command$0 = [0, Command];
   runtime.caml_register_global(0, Command$0, "Command__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Command__Import
//# unitInfo: Requires: Base__Printf, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Stdio
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Command_Import = "Command__Import",
    cst_command = "command";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Stdio = global_data.Stdio,
    Base_Printf = global_data.Base__Printf;
   caml_call1(Ppx_module_timer_runtime[4], cst_Command_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_command);
   caml_call1(Ppx_expect_runtime[1][1], "command/src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_command, "import.ml");
   var
    eprintf = Stdio[7],
    printf = Stdio[4],
    print_s = Stdio[5],
    print_string = Stdio[8],
    print_endline = Stdio[9],
    prerr_endline = Stdio[10],
    sprintf = Base_Printf[2],
    failwithf = Base_Printf[6],
    ksprintf = Base_Printf[4];
   caml_call1(Ppx_inline_test_lib[7], cst_command);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Command_Import);
   var
    Command_Import =
      [0,
       eprintf,
       printf,
       print_s,
       print_string,
       print_endline,
       prerr_endline,
       sprintf,
       failwithf,
       ksprintf];
   runtime.caml_register_global(13, Command_Import, cst_Command_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Command__Env_var
//# unitInfo: Requires: Base, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Command_Env_var$0 = "Command__Env_var",
    cst_command$0 = "command";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    Base = global_data.Base,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Command_Env_var$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_command$0);
   caml_call1(Ppx_expect_runtime[1][1], "command/src/env_var.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_command$0, "env_var.ml");
   var
    compare = runtime.caml_int_compare,
    _a_ = [0, "COMMAND_OUTPUT_INSTALLATION_BASH"],
    _b_ = [0, "COMMAND_OUTPUT_HELP_SEXP"],
    _c_ = [0, "COMP_CWORD"],
    cst_command = cst_command$0,
    cst_Command_Env_var = cst_Command_Env_var$0;
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   function to_string(t){
    var _d_ = sexp_of_t(t);
    return caml_call1(Base[85][16], _d_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_command);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Command_Env_var);
   var Command_Env_var = [0, compare, all, sexp_of_t, to_string];
   runtime.caml_register_global(16, Command_Env_var, cst_Command_Env_var$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Command__Shape
//# unitInfo: Requires: Base, Base__Char, Base__Error, Base__Fn, Base__Int, Base__Invariant, Base__Lazy, Base__List, Base__Option, Base__Or_error, Base__Result, Base__Set, Base__String, Bin_prot__Common, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Write, Bin_shape, CamlinternalLazy, Command__Env_var, Command__Import, Expect_test_config, Filename_base, Inline_test_config, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_expect_runtime, Ppx_expect_runtime__Test_block, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Types, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib0__Sexp_conv_record, Stable_witness, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$7 = "",
    cst$8 = " ",
    cst$6 = ", ",
    cst$5 = "-",
    cst_Ad_hoc = "Ad_hoc",
    cst_Base = "Base",
    cst_Basic = "Basic",
    cst_Command_Shape$0 = "Command__Shape",
    cst_Concat = "Concat",
    cst_Exec = "Exec",
    cst_Grammar = "Grammar",
    cst_Group = "Group",
    cst_Lazy = "Lazy",
    cst_Many = "Many",
    cst_Maybe = "Maybe",
    cst_One = "One",
    cst_Usage = "Usage",
    cst_V1$0 = "V1",
    cst_V2$0 = "V2",
    cst_V3$0 = "V3",
    cst_Zero = "Zero",
    cst_build_info = "[-build-info]",
    cst_help = "[-help]",
    cst_version = "[-version]",
    cst_a$1 = "a",
    cst_ad_hoc = "ad_hoc",
    cst_aliases$1 = "aliases",
    cst_anons$1 = "anons",
    cst_base = "base",
    cst_basic = "basic",
    cst_bug_in_command_ml$1 = "bug in command.ml",
    cst_child_subcommand$1 = "child_subcommand",
    cst_command$0 = "command",
    cst_command_src_shape_ml$0 = "command/src/shape.ml",
    cst_concat = "concat",
    cst_doc$1 = "doc",
    cst_exec = "exec",
    cst_flags$2 = "flags",
    cst_grammar = "grammar",
    cst_group = "group",
    cst_help$0 = "help",
    cst_lazy = "lazy",
    cst_many = "many",
    cst_maybe = "maybe",
    cst_name$1 = "name",
    cst_one = "one",
    cst_path_to_exe$3 = "path_to_exe",
    cst_readme$9 = "readme",
    cst_subcommands$2 = "subcommands",
    cst_summary$9 = "summary",
    cst_usage$0 = "usage",
    cst_v1 = "v1",
    cst_v2 = "v2",
    cst_v3 = "v3",
    cst_version$0 = "version",
    cst_working_dir$2 = "working_dir",
    cst_zero = "zero",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$4 = cst$5,
    cst$3 = cst$5,
    cst$2 = cst$7,
    cst$1 = cst$8,
    flag_name$0 = cst_name$1,
    cst$0 = "/",
    cst = cst$7,
    error_source_022 = "command/src/shape.ml.Stable.Anons.Grammar.V1.t",
    error_source_067 = "command/src/shape.ml.Stable.Anons.V2.t",
    error_source_088 = "command/src/shape.ml.Stable.Flag_info.V1.t",
    error_source_104 = "command/src/shape.ml.Stable.Base_info.V2.t",
    error_source_118 = "command/src/shape.ml.Stable.Base_info.V1.t",
    error_source_145 = "command/src/shape.ml.Stable.Group_info.V2.t",
    error_source_178 = "command/src/shape.ml.Stable.Group_info.V1.t",
    error_source_206 = "command/src/shape.ml.Stable.Exec_info.V3.t",
    error_source_222 = "command/src/shape.ml.Stable.Exec_info.V2.t",
    error_source_236 = "command/src/shape.ml.Stable.Exec_info.V1.t",
    error_source_261 = "command/src/shape.ml.Stable.Fully_forced.V1.t",
    error_source_290 = "command/src/shape.ml.Stable.Sexpable.V3.t",
    error_source_322 = "command/src/shape.ml.Stable.Sexpable.V2.t",
    error_source_347 = "command/src/shape.ml.Stable.Sexpable.V1.t",
    error_source_372 = "command/src/shape.ml.Stable.Sexpable.Versioned.t",
    error_source_411 = "command/src/shape.ml.Anons.Grammar.t",
    error_source_456 = "command/src/shape.ml.Anons.t",
    enumerate_474 = [0, 0, [0, 1, 0]],
    enumerate_475 = [0, 0, [0, 1, 0]],
    maybe_missing_prefix = "[",
    maybe_missing_suffix = "]",
    maybe_more_suffix = " ...",
    error_source_499 = "command/src/shape.ml.Flag_info.t",
    indentation = "  ",
    spacing_dot = ". ",
    error_source_517 = "command/src/shape.ml.Base_info.t",
    error_source_546 = "command/src/shape.ml.Group_info.t",
    error_source_574 = "command/src/shape.ml.Exec_info.t",
    error_source_603 = "command/src/shape.ml.Fully_forced.t",
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Set = global_data.Base__Set,
    Base_Lazy = global_data.Base__Lazy,
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base = global_data.Base,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_String = global_data.Base__String,
    Base_Error = global_data.Base__Error,
    Base_Result = global_data.Base__Result,
    Base_Or_error = global_data.Base__Or_error,
    Base_Char = global_data.Base__Char,
    Command_Import = global_data.Command__Import,
    Assert_failure = global_data.Assert_failure,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Option = global_data.Base__Option,
    Stdlib_List = global_data.Stdlib__List,
    Stable_witness = global_data.Stable_witness,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Filename_base = global_data.Filename_base;
   global_data.Bin_prot__Read;
   global_data.Bin_prot__Common;
   global_data.Bin_prot__Write;
   var
    Stdlib = global_data.Stdlib,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Bin_shape = global_data.Bin_shape,
    Base_Fn = global_data.Base__Fn,
    Expect_test_config = global_data.Expect_test_config,
    Ppx_expect_runtime_Test_block = global_data.Ppx_expect_runtime__Test_block,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Inline_test_config = global_data.Inline_test_config,
    Command_Env_var = global_data.Command__Env_var,
    Base_Int = global_data.Base__Int;
   caml_call1(Ppx_module_timer_runtime[4], cst_Command_Shape$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_command$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_command_src_shape_ml$0);
   caml_call2(Ppx_inline_test_lib[6], cst_command$0, "shape.ml");
   var
    t_of_sexp = Sexplib0_Sexp_conv[40],
    sexp_of_t = Sexplib0_Sexp_conv[16],
    compare = Base_Lazy[1],
    _aW_ = [0, cst_Base],
    _aX_ = [0, cst_Group],
    _aY_ = [0, cst_Exec],
    _aZ_ = [0, cst_Lazy],
    _aV_ = [0, 0, 0],
    _aS_ = [0, cst_Basic],
    _aT_ = [0, cst_Group],
    _aU_ = [0, cst_Exec],
    _aN_ = [0, cst_child_subcommand$1],
    _aO_ = [0, cst_path_to_exe$3],
    _aP_ = [0, cst_working_dir$2],
    _aQ_ = [0, cst_readme$9],
    _aR_ = [0, cst_summary$9],
    cst_child_subcommand$0 = cst_child_subcommand$1,
    cst_path_to_exe$2 = cst_path_to_exe$3,
    cst_working_dir$1 = cst_working_dir$2,
    cst_readme$8 = cst_readme$9,
    cst_summary$8 = cst_summary$9,
    cst_Subcommands_must_not_begin = "Subcommands must not begin with '-'",
    _aK_ = [0, cst_subcommands$2],
    _aL_ = [0, cst_readme$9],
    _aM_ = [0, cst_summary$9],
    cst_subcommands$1 = cst_subcommands$2,
    cst_readme$7 = cst_readme$9,
    cst_summary$7 = cst_summary$9,
    cst_Flags_must_begin_with = "Flags must begin with '-'",
    _aG_ = [0, cst_flags$2],
    _aH_ = [0, cst_anons$1],
    _aI_ = [0, cst_readme$9],
    _aJ_ = [0, cst_summary$9],
    cst_flags$1 = cst_flags$2,
    cst_anons$0 = cst_anons$1,
    cst_readme$6 = cst_readme$9,
    cst_summary$6 = cst_summary$9,
    _aB_ = [0, cst$6],
    cst_Key_type_s_is_an_ambiguous =
      "%{Key_type} %s is an ambiguous prefix: %s",
    _aC_ = [12, 32, [2, 0, [11, " is an ambiguous prefix: ", [2, 0, 0]]]],
    _aD_ = [0, 0],
    cst_unknown_Key_type_s = "unknown %{Key_type} %s",
    _aE_ = [12, 32, [2, 0, 0]],
    _aF_ = [0, 0],
    cst_unknown = "unknown ",
    cst_flag = "flag",
    cst_subcommand = "subcommand",
    _aA_ = [0, cst$6],
    _ax_ = [0, [0, "\n", 0], 0],
    cst_Unable_to_parse = "Unable to parse",
    _au_ = [0, cst_aliases$1],
    _av_ = [0, cst_doc$1],
    _aw_ = [0, cst_name$1],
    cst_aliases$0 = cst_aliases$1,
    cst_doc$0 = cst_doc$1,
    cst_name$0 = cst_name$1,
    _a2_ = [0, cst_command_src_shape_ml$0, 414, 6],
    _a1_ = [0, cst_command_src_shape_ml$0, 415, 6],
    _as_ = [0, "at_most_once"],
    _at_ = [0, "at_least_once"],
    _aq_ = [0, cst_Usage],
    _ar_ = [0, cst_Grammar],
    _ak_ = [0, cst_Zero],
    _al_ = [0, cst_One],
    _am_ = [0, cst_Many],
    _an_ = [0, cst_Maybe],
    _ao_ = [0, cst_Concat],
    _ap_ = [0, cst_Ad_hoc],
    cst_unsupported_version_to_use = "unsupported version_to_use",
    _aj_ = [0, [0, cst_command_src_shape_ml$0, 336, 8993, 9011]],
    _ag_ = [0, cst_V1$0],
    _ah_ = [0, cst_V2$0],
    _ai_ = [0, cst_V3$0],
    _ad_ = [0, cst_Base],
    _ae_ = [0, cst_Group],
    _af_ = [0, cst_Exec],
    _aa_ = [0, cst_Base],
    _ab_ = [0, cst_Group],
    _ac_ = [0, cst_Exec],
    _Y_ = [0, cst_Base],
    _Z_ = [0, cst_Group],
    ___ = [0, cst_Exec],
    _$_ = [0, cst_Lazy],
    _V_ = [0, cst_Basic],
    _W_ = [0, cst_Group],
    _X_ = [0, cst_Exec],
    _S_ = [0, cst_path_to_exe$3],
    _T_ = [0, cst_readme$9],
    _U_ = [0, cst_summary$9],
    cst_path_to_exe$1 = cst_path_to_exe$3,
    cst_readme$5 = cst_readme$9,
    cst_summary$5 = cst_summary$9,
    _O_ = [0, cst_path_to_exe$3],
    _P_ = [0, cst_working_dir$2],
    _Q_ = [0, cst_readme$9],
    _R_ = [0, cst_summary$9],
    cst_path_to_exe$0 = cst_path_to_exe$3,
    cst_working_dir$0 = cst_working_dir$2,
    cst_readme$4 = cst_readme$9,
    cst_summary$4 = cst_summary$9,
    _J_ = [0, cst_child_subcommand$1],
    _K_ = [0, cst_path_to_exe$3],
    _L_ = [0, cst_working_dir$2],
    _M_ = [0, cst_readme$9],
    _N_ = [0, cst_summary$9],
    cst_child_subcommand = cst_child_subcommand$1,
    cst_path_to_exe = cst_path_to_exe$3,
    cst_working_dir = cst_working_dir$2,
    cst_readme$3 = cst_readme$9,
    cst_summary$3 = cst_summary$9,
    _G_ = [0, cst_subcommands$2],
    _H_ = [0, cst_readme$9],
    _I_ = [0, cst_summary$9],
    cst_subcommands$0 = cst_subcommands$2,
    cst_readme$2 = cst_readme$9,
    cst_summary$2 = cst_summary$9,
    _D_ = [0, cst_subcommands$2],
    _E_ = [0, cst_readme$9],
    _F_ = [0, cst_summary$9],
    cst_subcommands = cst_subcommands$2,
    cst_readme$1 = cst_readme$9,
    cst_summary$1 = cst_summary$9,
    _u_ = [0, cst_flags$2],
    _v_ = [0, cst_usage$0],
    _w_ = [0, cst_readme$9],
    _x_ = [0, cst_summary$9],
    cst_flags$0 = cst_flags$2,
    cst_usage = cst_usage$0,
    cst_readme$0 = cst_readme$9,
    cst_summary$0 = cst_summary$9,
    _q_ = [0, cst_flags$2],
    _r_ = [0, cst_anons$1],
    _s_ = [0, cst_readme$9],
    _t_ = [0, cst_summary$9],
    cst_flags = cst_flags$2,
    cst_anons = cst_anons$1,
    cst_readme = cst_readme$9,
    cst_summary = cst_summary$9,
    _n_ = [0, cst_aliases$1],
    _o_ = [0, cst_doc$1],
    _p_ = [0, cst_name$1],
    cst_aliases = cst_aliases$1,
    cst_doc = cst_doc$1,
    cst_name = cst_name$1,
    _l_ = [0, cst_Usage],
    _m_ = [0, cst_Grammar],
    cst_Many_Zero_should_be_just_Z = "Many Zero should be just Zero",
    cst_Maybe_Zero_should_be_just_ = "Maybe Zero should be just Zero",
    cst_Flatten_zero_and_one_eleme = "Flatten zero and one-element Concat",
    _g_ = [0, cst_command_src_shape_ml$0, 25, 586, 621],
    _i_ = [0, [11, "[(", [2, 0, [11, ") ...]", 0]]], "[(%s) ...]"],
    cst_bug_in_command_ml = cst_bug_in_command_ml$1,
    _h_ = [0, [12, 91, [2, 0, [11, " ...]", 0]]], "[%s ...]"],
    cst_bug_in_command_ml$0 = cst_bug_in_command_ml$1,
    _j_ = [0, [12, 91, [2, 0, [12, 93, 0]]], "[%s]"],
    _k_ = [0, cst$8],
    _a_ = [0, cst_Zero],
    _b_ = [0, cst_One],
    _c_ = [0, cst_Many],
    _d_ = [0, cst_Maybe],
    _e_ = [0, cst_Concat],
    _f_ = [0, cst_Ad_hoc],
    _y_ =
      [0,
       [0,
        "Dummy_type_because_we_cannot_digest_type_constructors_only_concrete_types",
        0],
       0],
    cst_a = cst_a$1,
    cst_command_src_shape_ml_125_4 = "command/src/shape.ml:125:4",
    cst_a$0 = cst_a$1,
    cst_V1 = cst_V1$0,
    cst_V2 = cst_V2$0,
    cst_V3 = cst_V3$0,
    _a3_ =
      [0,
       [0,
        [0,
         '\n      (((at_least_once false) (at_most_once false)) "[name] ...")\n      (((at_least_once true) (at_most_once false)) "name ...")\n      (((at_least_once false) (at_most_once true)) [name])\n      (((at_least_once true) (at_most_once true)) name)\n      ',
         [0, cst$7]],
        [0, 11098, 11104, 11359]]],
    _a4_ = [0, 11085, 11089, 11360],
    _a7_ = [0, "to_help_string"],
    _a__ = [0, 10743, 10745, 11360],
    _a$_ = [0, 11351, 11360, 11360],
    _ba_ = [0, 10743, 10745, 11360],
    cst_command_src_shape_ml = cst_command_src_shape_ml$0,
    cst_command = cst_command$0,
    cst_Command_Shape = cst_Command_Shape$0;
   function compare$0(a_006, b_007){
    var a_006$0 = a_006, b_007$0 = b_007;
    for(;;){
     if(a_006$0 === b_007$0) return 0;
     if(typeof a_006$0 === "number")
      return typeof b_007$0 === "number" ? 0 : -1;
     a:
     {
      b:
      {
       c:
       {
        switch(a_006$0[0]){
          case 0:
           var a_008 = a_006$0[1];
           if(typeof b_007$0 === "number") break a;
           if(0 !== b_007$0[0]) return -1;
           var b_009 = b_007$0[1];
           return caml_call2(Ppx_compare_lib[5][8], a_008, b_009);
          case 1:
           var a_010 = a_006$0[1];
           if(typeof b_007$0 === "number") break a;
           switch(b_007$0[0]){
             case 0:
              break b;
             case 1:
              var b_011 = b_007$0[1], a_006$0 = a_010, b_007$0 = b_011;
              continue;
             default: return -1;
           }
          case 2:
           var a_012 = a_006$0[1];
           if(typeof b_007$0 === "number") break a;
           switch(b_007$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2:
              var b_013 = b_007$0[1], a_006$0 = a_012, b_007$0 = b_013;
              continue;
             default: return -1;
           }
          case 3:
           var a_014 = a_006$0[1];
           if(typeof b_007$0 === "number") break a;
           switch(b_007$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2: break;
             case 3:
              var
               b_015 = b_007$0[1],
               _fv_ = function(a_016, b_017){return compare$0(a_016, b_017);};
              return caml_call3(Ppx_compare_lib[5][12], _fv_, a_014, b_015);
             default: return -1;
           }
           break;
          default:
           var a_018 = a_006$0[1];
           if(typeof b_007$0 === "number") break a;
           switch(b_007$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2: break;
             case 3:
              return 1;
             default:
              var b_019 = b_007$0[1];
              return caml_call2(Ppx_compare_lib[5][8], a_018, b_019);
           }
        }
        return 1;
       }
       return 1;
      }
      return 1;
     }
     return 1;
    }
   }
   var t_of_sexp$0 = function _fu_(_ft_){return _fu_.fun(_ft_);};
   caml_update_dummy
    (t_of_sexp$0,
     function(sexp_024){
      a:
      {
       if(0 === sexp_024[0]){
        var _fo_ = sexp_024[1], _fp_ = caml_string_compare(_fo_, cst_ad_hoc);
        b:
        {
         c:
         {
          d:
          {
           e:
           {
            f:
            {
             if(0 <= _fp_){
              if(0 < _fp_){
               if(! caml_string_notequal(_fo_, cst_concat)) break f;
               if(! caml_string_notequal(_fo_, cst_many)) break e;
               if(! caml_string_notequal(_fo_, cst_maybe)) break d;
               if(! caml_string_notequal(_fo_, cst_one)) break c;
               if(caml_string_notequal(_fo_, cst_zero)) break a;
               break b;
              }
             }
             else if(caml_string_notequal(_fo_, cst_Ad_hoc)){
              if(! caml_string_notequal(_fo_, cst_Concat)) break f;
              if(! caml_string_notequal(_fo_, cst_Many)) break e;
              if(! caml_string_notequal(_fo_, cst_Maybe)) break d;
              if(! caml_string_notequal(_fo_, cst_One)) break c;
              if(caml_string_notequal(_fo_, cst_Zero)) break a;
              break b;
             }
             return caml_call2
                     (Sexplib0_Sexp_conv_error[9], error_source_022, sexp_024);
            }
            return caml_call2
                    (Sexplib0_Sexp_conv_error[9], error_source_022, sexp_024);
           }
           return caml_call2
                   (Sexplib0_Sexp_conv_error[9], error_source_022, sexp_024);
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_022, sexp_024);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_022, sexp_024);
        }
        return 0;
       }
       var _fq_ = sexp_024[1];
       if(! _fq_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_022, sexp_024);
       var _fr_ = _fq_[1];
       if(0 !== _fr_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_022, sexp_024);
       var tag_025 = _fr_[1], _fs_ = caml_string_compare(tag_025, cst_ad_hoc);
       b:
       {
        c:
        {
         d:
         {
          e:
          {
           f:
           {
            if(0 <= _fs_){
             if(0 < _fs_){
              if(! caml_string_notequal(tag_025, cst_concat)) break f;
              if(! caml_string_notequal(tag_025, cst_many)) break e;
              if(! caml_string_notequal(tag_025, cst_maybe)) break d;
              if(! caml_string_notequal(tag_025, cst_one)) break c;
              if(caml_string_notequal(tag_025, cst_zero)) break a;
              break b;
             }
            }
            else if(caml_string_notequal(tag_025, cst_Ad_hoc)){
             if(! caml_string_notequal(tag_025, cst_Concat)) break f;
             if(! caml_string_notequal(tag_025, cst_Many)) break e;
             if(! caml_string_notequal(tag_025, cst_Maybe)) break d;
             if(! caml_string_notequal(tag_025, cst_One)) break c;
             if(caml_string_notequal(tag_025, cst_Zero)) break a;
             break b;
            }
            var sexp_args_046 = _fq_[2];
            if(sexp_args_046 && ! sexp_args_046[2]){
             var
              arg0_047 = sexp_args_046[1],
              res0_048 = caml_call1(Sexplib0_Sexp_conv[31], arg0_047);
             return [4, res0_048];
            }
            return caml_call3
                    (Sexplib0_Sexp_conv_error[8],
                     error_source_022,
                     tag_025,
                     sexp_024);
           }
           var sexp_args_041 = _fq_[2];
           if(sexp_args_041 && ! sexp_args_041[2]){
            var
             arg0_042 = sexp_args_041[1],
             res0_043 =
               caml_call2(Sexplib0_Sexp_conv[44], t_of_sexp$0, arg0_042);
            return [3, res0_043];
           }
           return caml_call3
                   (Sexplib0_Sexp_conv_error[8],
                    error_source_022,
                    tag_025,
                    sexp_024);
          }
          var sexp_args_031 = _fq_[2];
          if(sexp_args_031 && ! sexp_args_031[2]){
           var
            arg0_032 = sexp_args_031[1],
            res0_033 = caml_call1(t_of_sexp$0, arg0_032);
           return [1, res0_033];
          }
          return caml_call3
                  (Sexplib0_Sexp_conv_error[8],
                   error_source_022,
                   tag_025,
                   sexp_024);
         }
         var sexp_args_036 = _fq_[2];
         if(sexp_args_036 && ! sexp_args_036[2]){
          var
           arg0_037 = sexp_args_036[1],
           res0_038 = caml_call1(t_of_sexp$0, arg0_037);
          return [2, res0_038];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_022,
                  tag_025,
                  sexp_024);
        }
        var sexp_args_026 = _fq_[2];
        if(sexp_args_026 && ! sexp_args_026[2]){
         var
          arg0_027 = sexp_args_026[1],
          res0_028 = caml_call1(Sexplib0_Sexp_conv[31], arg0_027);
         return [0, res0_028];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_022,
                 tag_025,
                 sexp_024);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_022, sexp_024);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_022, sexp_024);
     });
   function sexp_of_t$0(param){
    if(typeof param === "number") return _a_;
    switch(param[0]){
      case 0:
       var
        arg0_049 = param[1],
        res0_050 = caml_call1(Sexplib0_Sexp_conv[7], arg0_049);
       return [1, [0, _b_, [0, res0_050, 0]]];
      case 1:
       var arg0_051 = param[1], res0_052 = sexp_of_t$0(arg0_051);
       return [1, [0, _c_, [0, res0_052, 0]]];
      case 2:
       var arg0_053 = param[1], res0_054 = sexp_of_t$0(arg0_053);
       return [1, [0, _d_, [0, res0_054, 0]]];
      case 3:
       var
        arg0_055 = param[1],
        res0_056 = caml_call2(Sexplib0_Sexp_conv[20], sexp_of_t$0, arg0_055);
       return [1, [0, _e_, [0, res0_056, 0]]];
      default:
       var
        arg0_057 = param[1],
        res0_058 = caml_call1(Sexplib0_Sexp_conv[7], arg0_057);
       return [1, [0, _f_, [0, res0_058, 0]]];
    }
   }
   var
    stable_witness_checks_for_t = function _fn_(_fm_){return _fn_.fun(_fm_);},
    stable_witness = Stable_witness[6];
   caml_update_dummy(stable_witness_checks_for_t, function(param){return 0;});
   function invariant(t){
    function _fl_(param){
     if(typeof t === "number") return 0;
     switch(t[0]){
       case 0:
        return 0;
       case 1:
        var t$0 = t[1];
        return typeof t$0 === "number"
                ? caml_call1(Stdlib[2], cst_Many_Zero_should_be_just_Z)
                : invariant(t$0);
       case 2:
        var t$1 = t[1];
        return typeof t$1 === "number"
                ? caml_call1(Stdlib[2], cst_Maybe_Zero_should_be_just_)
                : invariant(t$1);
       case 3:
        var ts = t[1];
        if(ts && ts[2]) return caml_call2(Base_List[19], ts, invariant);
        return caml_call1(Stdlib[2], cst_Flatten_zero_and_one_eleme);
       default: return 0;
     }
    }
    return caml_call4(Base_Invariant[1], _g_, t, sexp_of_t$0, _fl_);
   }
   function t_of_sexp$1(sexp){
    var t = caml_call1(t_of_sexp$0, sexp);
    invariant(t);
    return t;
   }
   function usage(param){
    if(typeof param === "number") return cst;
    switch(param[0]){
      case 0:
       var usage$0 = param[1]; return usage$0;
      case 1:
       var t = param[1];
       if(typeof t === "number")
        return caml_call1(Stdlib[2], cst_bug_in_command_ml);
       if(0 === t[0]){
        var _fh_ = usage(t);
        return caml_call2(Command_Import[7], _h_, _fh_);
       }
       var _fi_ = usage(t);
       return caml_call2(Command_Import[7], _i_, _fi_);
      case 2:
       var t$0 = param[1];
       if(typeof t$0 === "number")
        return caml_call1(Stdlib[2], cst_bug_in_command_ml$0);
       var _fj_ = usage(t$0);
       return caml_call2(Command_Import[7], _j_, _fj_);
      case 3:
       var ts = param[1], _fk_ = caml_call2(Base_List[53], ts, usage);
       return caml_call2(Base_String[68], _k_, _fk_);
      default: var usage$1 = param[1]; return usage$1;
    }
   }
   function compare$1(a_059, b_060){
    if(a_059 === b_060) return 0;
    if(0 === a_059[0]){
     var a_061 = a_059[1];
     if(0 !== b_060[0]) return -1;
     var b_062 = b_060[1];
     return caml_call2(Ppx_compare_lib[5][8], a_061, b_062);
    }
    var a_063 = a_059[1];
    if(0 === b_060[0]) return 1;
    var b_064 = b_060[1];
    return compare$0(a_063, b_064);
   }
   function t_of_sexp$2(sexp_069){
    a:
    {
     if(0 === sexp_069[0]){
      var _fe_ = sexp_069[1];
      b:
      if(caml_string_notequal(_fe_, cst_Grammar)){
       if(caml_string_notequal(_fe_, cst_Usage)){
        if(! caml_string_notequal(_fe_, cst_grammar)) break b;
        if(caml_string_notequal(_fe_, cst_usage$0)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_067, sexp_069);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_067, sexp_069);
     }
     var _ff_ = sexp_069[1];
     if(! _ff_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_067, sexp_069);
     var _fg_ = _ff_[1];
     if(0 !== _fg_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_067, sexp_069);
     var tag_070 = _fg_[1];
     b:
     if(caml_string_notequal(tag_070, cst_Grammar)){
      if(caml_string_notequal(tag_070, cst_Usage)){
       if(! caml_string_notequal(tag_070, cst_grammar)) break b;
       if(caml_string_notequal(tag_070, cst_usage$0)) break a;
      }
      var sexp_args_071 = _ff_[2];
      if(sexp_args_071 && ! sexp_args_071[2]){
       var
        arg0_072 = sexp_args_071[1],
        res0_073 = caml_call1(Sexplib0_Sexp_conv[31], arg0_072);
       return [0, res0_073];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_067,
               tag_070,
               sexp_069);
     }
     var sexp_args_076 = _ff_[2];
     if(sexp_args_076 && ! sexp_args_076[2]){
      var arg0_077 = sexp_args_076[1], res0_078 = t_of_sexp$1(arg0_077);
      return [1, res0_078];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_067,
              tag_070,
              sexp_069);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_067, sexp_069);
   }
   function sexp_of_t$1(param){
    if(0 === param[0]){
     var
      arg0_079 = param[1],
      res0_080 = caml_call1(Sexplib0_Sexp_conv[7], arg0_079);
     return [1, [0, _l_, [0, res0_080, 0]]];
    }
    var arg0_081 = param[1], res0_082 = sexp_of_t$0(arg0_081);
    return [1, [0, _m_, [0, res0_082, 0]]];
   }
   var stable_witness$0 = Stable_witness[6];
   function compare$2(a_083, b_084){
    if(a_083 === b_084) return 0;
    var n = caml_call2(Ppx_compare_lib[5][8], a_083[1], b_084[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Ppx_compare_lib[5][8], a_083[2], b_084[2]);
    if(0 !== n$0) return n$0;
    var _fb_ = b_084[3], _fc_ = a_083[3];
    function _fd_(a_085, b_086){
     return caml_call2(Ppx_compare_lib[5][8], a_085, b_086);
    }
    return caml_call3(Ppx_compare_lib[5][12], _fd_, _fc_, _fb_);
   }
   function t_of_sexp$3(x_089){
    function _e8_(param){
     var
      _fa_ = param[2],
      aliases = _fa_[2][1],
      doc = _fa_[1],
      name = param[1];
     return [0, name, doc, aliases];
    }
    var _e9_ = 0;
    function _e__(param){
     return caml_string_notequal(param, cst_aliases$1)
             ? caml_string_notequal
                (param, cst_doc$1)
               ? caml_string_notequal(param, cst_name$1) ? -1 : 0
               : 1
             : 2;
    }
    var
     _e$_ =
       [0,
        cst_aliases,
        1,
        caml_call1(Sexplib0_Sexp_conv[44], Sexplib0_Sexp_conv[31]),
        0];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_088,
             [0,
              cst_name,
              1,
              Sexplib0_Sexp_conv[31],
              [0, cst_doc, 1, Sexplib0_Sexp_conv[31], _e$_]],
             _e__,
             _e9_,
             _e8_,
             x_089);
   }
   function sexp_of_t$2(param){
    var
     aliases_095 = param[3],
     doc_093 = param[2],
     name_091 = param[1],
     arg_096 =
       caml_call2(Sexplib0_Sexp_conv[20], Sexplib0_Sexp_conv[7], aliases_095),
     bnds_090 = [0, [1, [0, _n_, [0, arg_096, 0]]], 0],
     arg_094 = caml_call1(Sexplib0_Sexp_conv[7], doc_093),
     bnds_090$0 = [0, [1, [0, _o_, [0, arg_094, 0]]], bnds_090],
     arg_092 = caml_call1(Sexplib0_Sexp_conv[7], name_091),
     bnds_090$1 = [0, [1, [0, _p_, [0, arg_092, 0]]], bnds_090$0];
    return [1, bnds_090$1];
   }
   var stable_witness$1 = Stable_witness[6];
   function compare$3(a_097, b_098){
    if(a_097 === b_098) return 0;
    var n = caml_call2(Ppx_compare_lib[5][8], a_097[1], b_098[1]);
    if(0 !== n) return n;
    var _e2_ = b_098[2], _e3_ = a_097[2];
    function _e4_(a_099, b_100){
     return caml_call2(Ppx_compare_lib[5][8], a_099, b_100);
    }
    var n$0 = caml_call3(Ppx_compare_lib[5][13], _e4_, _e3_, _e2_);
    if(0 !== n$0) return n$0;
    var n$1 = compare$1(a_097[3], b_098[3]);
    if(0 !== n$1) return n$1;
    var _e5_ = b_098[4], _e6_ = a_097[4];
    function _e7_(a_101, b_102){return compare$2(a_101, b_102);}
    return caml_call3(Ppx_compare_lib[5][12], _e7_, _e6_, _e5_);
   }
   function t_of_sexp$4(x_105){
    function _eW_(param){
     var
      _e0_ = param[2],
      _e1_ = _e0_[2],
      flags = _e1_[2][1],
      anons = _e1_[1],
      readme = _e0_[1],
      summary = param[1];
     return [0, summary, readme, anons, flags];
    }
    var _eX_ = 0;
    function _eY_(param){
     return caml_string_notequal(param, cst_anons$1)
             ? caml_string_notequal
                (param, cst_flags$2)
               ? caml_string_notequal
                  (param, cst_readme$9)
                 ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
                 : 1
               : 3
             : 2;
    }
    var
     _eZ_ =
       [0,
        cst_anons,
        1,
        t_of_sexp$2,
        [0, cst_flags, 1, caml_call1(Sexplib0_Sexp_conv[44], t_of_sexp$3), 0]];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_104,
             [0,
              cst_summary,
              1,
              Sexplib0_Sexp_conv[31],
              [0, cst_readme, 5, Sexplib0_Sexp_conv[31], _eZ_]],
             _eY_,
             _eX_,
             _eW_,
             x_105);
   }
   function sexp_of_t$3(param){
    var
     flags_115 = param[4],
     anons_113 = param[3],
     readme_109 = param[2],
     summary_107 = param[1],
     arg_116 = caml_call2(Sexplib0_Sexp_conv[20], sexp_of_t$2, flags_115),
     bnds_106 = [0, [1, [0, _q_, [0, arg_116, 0]]], 0],
     arg_114 = sexp_of_t$1(anons_113),
     bnds_106$0 = [0, [1, [0, _r_, [0, arg_114, 0]]], bnds_106];
    if(readme_109)
     var
      v_110 = readme_109[1],
      arg_112 = caml_call1(Sexplib0_Sexp_conv[7], v_110),
      bnd_111 = [1, [0, _s_, [0, arg_112, 0]]],
      bnds_106$1 = [0, bnd_111, bnds_106$0];
    else
     var bnds_106$1 = bnds_106$0;
    var
     arg_108 = caml_call1(Sexplib0_Sexp_conv[7], summary_107),
     bnds_106$2 = [0, [1, [0, _t_, [0, arg_108, 0]]], bnds_106$1];
    return [1, bnds_106$2];
   }
   var stable_witness$2 = Stable_witness[6];
   function t_of_sexp$5(x_119){
    function _eQ_(param){
     var
      _eU_ = param[2],
      _eV_ = _eU_[2],
      flags = _eV_[2][1],
      usage = _eV_[1],
      readme = _eU_[1],
      summary = param[1];
     return [0, summary, readme, usage, flags];
    }
    var _eR_ = 0;
    function _eS_(param){
     return caml_string_notequal(param, cst_flags$2)
             ? caml_string_notequal
                (param, cst_readme$9)
               ? caml_string_notequal
                  (param, cst_summary$9)
                 ? caml_string_notequal(param, cst_usage$0) ? -1 : 2
                 : 0
               : 1
             : 3;
    }
    var
     _eT_ =
       [0, cst_flags$0, 1, caml_call1(Sexplib0_Sexp_conv[44], t_of_sexp$3), 0];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_118,
             [0,
              cst_summary$0,
              1,
              Sexplib0_Sexp_conv[31],
              [0,
               cst_readme$0,
               5,
               Sexplib0_Sexp_conv[31],
               [0, cst_usage, 1, Sexplib0_Sexp_conv[31], _eT_]]],
             _eS_,
             _eR_,
             _eQ_,
             x_119);
   }
   function sexp_of_t$4(param){
    var
     flags_129 = param[4],
     usage_127 = param[3],
     readme_123 = param[2],
     summary_121 = param[1],
     arg_130 = caml_call2(Sexplib0_Sexp_conv[20], sexp_of_t$2, flags_129),
     bnds_120 = [0, [1, [0, _u_, [0, arg_130, 0]]], 0],
     arg_128 = caml_call1(Sexplib0_Sexp_conv[7], usage_127),
     bnds_120$0 = [0, [1, [0, _v_, [0, arg_128, 0]]], bnds_120];
    if(readme_123)
     var
      v_124 = readme_123[1],
      arg_126 = caml_call1(Sexplib0_Sexp_conv[7], v_124),
      bnd_125 = [1, [0, _w_, [0, arg_126, 0]]],
      bnds_120$1 = [0, bnd_125, bnds_120$0];
    else
     var bnds_120$1 = bnds_120$0;
    var
     arg_122 = caml_call1(Sexplib0_Sexp_conv[7], summary_121),
     bnds_120$2 = [0, [1, [0, _x_, [0, arg_122, 0]]], bnds_120$1];
    return [1, bnds_120$2];
   }
   var stable_witness$3 = Stable_witness[6];
   function to_latest(param){
    var
     flags = param[4],
     usage = param[3],
     readme = param[2],
     summary = param[1];
    return [0, summary, readme, [0, usage], flags];
   }
   function of_latest(param){
    var
     flags = param[4],
     anons = param[3],
     readme = param[2],
     summary = param[1];
    if(0 === anons[0])
     var usage$0 = anons[1], usage$1 = usage$0;
    else
     var grammar = anons[1], usage$1 = usage(grammar);
    return [0, summary, readme, usage$1, flags];
   }
   var
    _z_ = caml_call1(Bin_prot_Shape[5], _y_),
    _A_ = [0, [0, caml_call1(Bin_shape[2][1], cst_a), 0, _z_], 0],
    _B_ = caml_call1(Bin_shape[4][1], cst_command_src_shape_ml_125_4),
    group = caml_call2(Bin_prot_Shape[2], _B_, _A_),
    _C_ = caml_call1(Bin_shape[2][1], cst_a$0);
   caml_call1(caml_call2(Bin_prot_Shape[10], group, _C_), 0);
   function compare$4(cmp_a, a_131, b_132){
    if(a_131 === b_132) return 0;
    var n = caml_call2(Ppx_compare_lib[5][8], a_131[1], b_132[1]);
    if(0 !== n) return n;
    var _eK_ = b_132[2], _eL_ = a_131[2];
    function _eM_(a_133, b_134){
     return caml_call2(Ppx_compare_lib[5][8], a_133, b_134);
    }
    var n$0 = caml_call3(Ppx_compare_lib[5][13], _eM_, _eL_, _eK_);
    if(0 !== n$0) return n$0;
    var _eN_ = b_132[3], _eO_ = a_131[3];
    return caml_call3
            (compare,
             function(a_135, b_136){
              function _eP_(a_137, b_138){
               var
                t_140 = a_137[2],
                t_139 = a_137[1],
                t_142 = b_138[2],
                t_141 = b_138[1],
                n = caml_call2(Ppx_compare_lib[5][8], t_139, t_141);
               return 0 === n ? caml_call2(cmp_a, t_140, t_142) : n;
              }
              return caml_call3(Ppx_compare_lib[5][12], _eP_, a_135, b_136);
             },
             _eO_,
             _eN_);
   }
   function t_of_sexp$6(of_a_143, x_151){
    function _eB_(param){
     var
      _eJ_ = param[2],
      subcommands = _eJ_[2][1],
      readme = _eJ_[1],
      summary = param[1];
     return [0, summary, readme, subcommands];
    }
    var _eC_ = 0;
    function _eD_(param){
     return caml_string_notequal(param, cst_readme$9)
             ? caml_string_notequal
                (param, cst_subcommands$2)
               ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
               : 2
             : 1;
    }
    var _eE_ = 0;
    function _eF_(sexp_150){
     if(1 === sexp_150[0]){
      var _eH_ = sexp_150[1];
      if(_eH_){
       var _eI_ = _eH_[2];
       if(_eI_ && ! _eI_[2]){
        var
         arg1_147 = _eI_[1],
         arg0_146 = _eH_[1],
         res0_148 = caml_call1(Sexplib0_Sexp_conv[31], arg0_146),
         res1_149 = caml_call1(of_a_143, arg1_147);
        return [0, res0_148, res1_149];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4], error_source_145, 2, sexp_150);
    }
    var
     _eG_ =
       [0,
        cst_subcommands,
        1,
        caml_call1(t_of_sexp, caml_call1(Sexplib0_Sexp_conv[44], _eF_)),
        _eE_];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_145,
             [0,
              cst_summary$1,
              1,
              Sexplib0_Sexp_conv[31],
              [0, cst_readme$1, 5, Sexplib0_Sexp_conv[31], _eG_]],
             _eD_,
             _eC_,
             _eB_,
             x_151);
   }
   function sexp_of_t$5(of_a_152, param){
    var
     subcommands_160 = param[3],
     readme_156 = param[2],
     summary_154 = param[1],
     bnds_153 = 0;
    function _eA_(param){
     var
      arg1_163 = param[2],
      arg0_162 = param[1],
      res0_164 = caml_call1(Sexplib0_Sexp_conv[7], arg0_162),
      res1_165 = caml_call1(of_a_152, arg1_163);
     return [1, [0, res0_164, [0, res1_165, 0]]];
    }
    var
     arg_161 =
       caml_call2
        (sexp_of_t, caml_call1(Sexplib0_Sexp_conv[20], _eA_), subcommands_160),
     bnds_153$0 = [0, [1, [0, _D_, [0, arg_161, 0]]], bnds_153];
    if(readme_156)
     var
      v_157 = readme_156[1],
      arg_159 = caml_call1(Sexplib0_Sexp_conv[7], v_157),
      bnd_158 = [1, [0, _E_, [0, arg_159, 0]]],
      bnds_153$1 = [0, bnd_158, bnds_153$0];
    else
     var bnds_153$1 = bnds_153$0;
    var
     arg_155 = caml_call1(Sexplib0_Sexp_conv[7], summary_154),
     bnds_153$2 = [0, [1, [0, _F_, [0, arg_155, 0]]], bnds_153$1];
    return [1, bnds_153$2];
   }
   function stable_witness$4(a_stable_witness){return Stable_witness[6];}
   function map(t, f){
    var _ew_ = Base_List[137][9];
    function _ex_(_ez_){return caml_call2(_ew_, _ez_, f);}
    var _ey_ = caml_call2(Base_Lazy[15], t[3], _ex_);
    return [0, t[1], t[2], _ey_];
   }
   function t_of_sexp$7(of_a_176, x_184){
    function _en_(param){
     var
      _ev_ = param[2],
      subcommands = _ev_[2][1],
      readme = _ev_[1],
      summary = param[1];
     return [0, summary, readme, subcommands];
    }
    var _eo_ = 0;
    function _ep_(param){
     return caml_string_notequal(param, cst_readme$9)
             ? caml_string_notequal
                (param, cst_subcommands$2)
               ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
               : 2
             : 1;
    }
    var _eq_ = 0;
    function _er_(sexp_183){
     if(1 === sexp_183[0]){
      var _et_ = sexp_183[1];
      if(_et_){
       var _eu_ = _et_[2];
       if(_eu_ && ! _eu_[2]){
        var
         arg1_180 = _eu_[1],
         arg0_179 = _et_[1],
         res0_181 = caml_call1(Sexplib0_Sexp_conv[31], arg0_179),
         res1_182 = caml_call1(of_a_176, arg1_180);
        return [0, res0_181, res1_182];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4], error_source_178, 2, sexp_183);
    }
    var
     _es_ =
       [0,
        cst_subcommands$0,
        1,
        caml_call1(Sexplib0_Sexp_conv[44], _er_),
        _eq_];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_178,
             [0,
              cst_summary$2,
              1,
              Sexplib0_Sexp_conv[31],
              [0, cst_readme$2, 5, Sexplib0_Sexp_conv[31], _es_]],
             _ep_,
             _eo_,
             _en_,
             x_184);
   }
   function sexp_of_t$6(of_a_185, param){
    var
     subcommands_193 = param[3],
     readme_189 = param[2],
     summary_187 = param[1],
     bnds_186 = 0;
    function _em_(param){
     var
      arg1_196 = param[2],
      arg0_195 = param[1],
      res0_197 = caml_call1(Sexplib0_Sexp_conv[7], arg0_195),
      res1_198 = caml_call1(of_a_185, arg1_196);
     return [1, [0, res0_197, [0, res1_198, 0]]];
    }
    var
     arg_194 = caml_call2(Sexplib0_Sexp_conv[20], _em_, subcommands_193),
     bnds_186$0 = [0, [1, [0, _G_, [0, arg_194, 0]]], bnds_186];
    if(readme_189)
     var
      v_190 = readme_189[1],
      arg_192 = caml_call1(Sexplib0_Sexp_conv[7], v_190),
      bnd_191 = [1, [0, _H_, [0, arg_192, 0]]],
      bnds_186$1 = [0, bnd_191, bnds_186$0];
    else
     var bnds_186$1 = bnds_186$0;
    var
     arg_188 = caml_call1(Sexplib0_Sexp_conv[7], summary_187),
     bnds_186$2 = [0, [1, [0, _I_, [0, arg_188, 0]]], bnds_186$1];
    return [1, bnds_186$2];
   }
   function map$0(t, f){
    var _el_ = caml_call2(Base_List[137][9], t[3], f);
    return [0, t[1], t[2], _el_];
   }
   function to_latest$0(param){
    var subcommands = param[3], readme = param[2], summary = param[1];
    return [0, summary, readme, caml_call1(Base_Lazy[24], subcommands)];
   }
   function of_latest$0(param){
    var
     subcommands = param[3],
     readme = param[2],
     summary = param[1],
     _ej_ = caml_obj_tag(subcommands);
    a:
    if(250 === _ej_)
     var _ek_ = subcommands[1];
    else{
     if(246 !== _ej_ && 244 !== _ej_){var _ek_ = subcommands; break a;}
     var _ek_ = caml_call1(CamlinternalLazy[2], subcommands);
    }
    return [0, summary, readme, _ek_];
   }
   function abs_path(dir, path){
    return caml_call1(Filename_base[30], path)
            ? path
            : caml_call2(Filename_base[28], dir, path);
   }
   function compare$5(a_199, b_200){
    if(a_199 === b_200) return 0;
    var n = caml_call2(Ppx_compare_lib[5][8], a_199[1], b_200[1]);
    if(0 !== n) return n;
    var _ed_ = b_200[2], _ee_ = a_199[2];
    function _ef_(a_201, b_202){
     return caml_call2(Ppx_compare_lib[5][8], a_201, b_202);
    }
    var n$0 = caml_call3(Ppx_compare_lib[5][13], _ef_, _ee_, _ed_);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Ppx_compare_lib[5][8], a_199[3], b_200[3]);
    if(0 !== n$1) return n$1;
    var n$2 = caml_call2(Ppx_compare_lib[5][8], a_199[4], b_200[4]);
    if(0 !== n$2) return n$2;
    var _eg_ = b_200[5], _eh_ = a_199[5];
    function _ei_(a_203, b_204){
     return caml_call2(Ppx_compare_lib[5][8], a_203, b_204);
    }
    return caml_call3(Ppx_compare_lib[5][12], _ei_, _eh_, _eg_);
   }
   function t_of_sexp$8(x_207){
    function _d8_(param){
     var
      _ea_ = param[2],
      _eb_ = _ea_[2],
      _ec_ = _eb_[2],
      child_subcommand = _ec_[2][1],
      path_to_exe = _ec_[1],
      working_dir = _eb_[1],
      readme = _ea_[1],
      summary = param[1];
     return [0, summary, readme, working_dir, path_to_exe, child_subcommand];
    }
    var _d9_ = 0;
    function _d__(param){
     return caml_string_notequal(param, cst_child_subcommand$1)
             ? caml_string_notequal
                (param, cst_path_to_exe$3)
               ? caml_string_notequal
                  (param, cst_readme$9)
                 ? caml_string_notequal
                    (param, cst_summary$9)
                   ? caml_string_notequal(param, cst_working_dir$2) ? -1 : 2
                   : 0
                 : 1
               : 3
             : 4;
    }
    var
     _d$_ =
       [0,
        cst_child_subcommand,
        1,
        caml_call1(Sexplib0_Sexp_conv[44], Sexplib0_Sexp_conv[31]),
        0];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_206,
             [0,
              cst_summary$3,
              1,
              Sexplib0_Sexp_conv[31],
              [0,
               cst_readme$3,
               5,
               Sexplib0_Sexp_conv[31],
               [0,
                cst_working_dir,
                1,
                Sexplib0_Sexp_conv[31],
                [0, cst_path_to_exe, 1, Sexplib0_Sexp_conv[31], _d$_]]]],
             _d__,
             _d9_,
             _d8_,
             x_207);
   }
   function sexp_of_t$7(param){
    var
     child_subcommand_219 = param[5],
     path_to_exe_217 = param[4],
     working_dir_215 = param[3],
     readme_211 = param[2],
     summary_209 = param[1],
     arg_220 =
       caml_call2
        (Sexplib0_Sexp_conv[20], Sexplib0_Sexp_conv[7], child_subcommand_219),
     bnds_208 = [0, [1, [0, _J_, [0, arg_220, 0]]], 0],
     arg_218 = caml_call1(Sexplib0_Sexp_conv[7], path_to_exe_217),
     bnds_208$0 = [0, [1, [0, _K_, [0, arg_218, 0]]], bnds_208],
     arg_216 = caml_call1(Sexplib0_Sexp_conv[7], working_dir_215),
     bnds_208$1 = [0, [1, [0, _L_, [0, arg_216, 0]]], bnds_208$0];
    if(readme_211)
     var
      v_212 = readme_211[1],
      arg_214 = caml_call1(Sexplib0_Sexp_conv[7], v_212),
      bnd_213 = [1, [0, _M_, [0, arg_214, 0]]],
      bnds_208$2 = [0, bnd_213, bnds_208$1];
    else
     var bnds_208$2 = bnds_208$1;
    var
     arg_210 = caml_call1(Sexplib0_Sexp_conv[7], summary_209),
     bnds_208$3 = [0, [1, [0, _N_, [0, arg_210, 0]]], bnds_208$2];
    return [1, bnds_208$3];
   }
   var stable_witness$5 = Stable_witness[6];
   function to_latest$1(_d7_){return _d7_;}
   function of_latest$1(_d6_){return _d6_;}
   function t_of_sexp$9(x_223){
    function _d1_(param){
     var
      _d4_ = param[2],
      _d5_ = _d4_[2],
      path_to_exe = _d5_[2][1],
      working_dir = _d5_[1],
      readme = _d4_[1],
      summary = param[1];
     return [0, summary, readme, working_dir, path_to_exe];
    }
    var _d2_ = 0;
    function _d3_(param){
     return caml_string_notequal(param, cst_path_to_exe$3)
             ? caml_string_notequal
                (param, cst_readme$9)
               ? caml_string_notequal
                  (param, cst_summary$9)
                 ? caml_string_notequal(param, cst_working_dir$2) ? -1 : 2
                 : 0
               : 1
             : 3;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_222,
             [0,
              cst_summary$4,
              1,
              Sexplib0_Sexp_conv[31],
              [0,
               cst_readme$4,
               5,
               Sexplib0_Sexp_conv[31],
               [0,
                cst_working_dir$0,
                1,
                Sexplib0_Sexp_conv[31],
                [0, cst_path_to_exe$0, 1, Sexplib0_Sexp_conv[31], 0]]]],
             _d3_,
             _d2_,
             _d1_,
             x_223);
   }
   function sexp_of_t$8(param){
    var
     path_to_exe_233 = param[4],
     working_dir_231 = param[3],
     readme_227 = param[2],
     summary_225 = param[1],
     arg_234 = caml_call1(Sexplib0_Sexp_conv[7], path_to_exe_233),
     bnds_224 = [0, [1, [0, _O_, [0, arg_234, 0]]], 0],
     arg_232 = caml_call1(Sexplib0_Sexp_conv[7], working_dir_231),
     bnds_224$0 = [0, [1, [0, _P_, [0, arg_232, 0]]], bnds_224];
    if(readme_227)
     var
      v_228 = readme_227[1],
      arg_230 = caml_call1(Sexplib0_Sexp_conv[7], v_228),
      bnd_229 = [1, [0, _Q_, [0, arg_230, 0]]],
      bnds_224$1 = [0, bnd_229, bnds_224$0];
    else
     var bnds_224$1 = bnds_224$0;
    var
     arg_226 = caml_call1(Sexplib0_Sexp_conv[7], summary_225),
     bnds_224$2 = [0, [1, [0, _R_, [0, arg_226, 0]]], bnds_224$1];
    return [1, bnds_224$2];
   }
   var stable_witness$6 = Stable_witness[6];
   function to_v3(t){return [0, t[1], t[2], t[3], t[4], 0];}
   function of_v3(t){
    var _d0_ = abs_path(t[3], t[4]);
    return [0, t[1], t[2], t[3], _d0_];
   }
   var
    to_latest$2 = caml_call2(Base_Fn[5], to_latest$1, to_v3),
    of_latest$2 = caml_call2(Base_Fn[5], of_v3, of_latest$1);
   function t_of_sexp$10(x_237){
    function _dW_(param){
     var
      _dZ_ = param[2],
      path_to_exe = _dZ_[2][1],
      readme = _dZ_[1],
      summary = param[1];
     return [0, summary, readme, path_to_exe];
    }
    var _dX_ = 0;
    function _dY_(param){
     return caml_string_notequal(param, cst_path_to_exe$3)
             ? caml_string_notequal
                (param, cst_readme$9)
               ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
               : 1
             : 2;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_236,
             [0,
              cst_summary$5,
              1,
              Sexplib0_Sexp_conv[31],
              [0,
               cst_readme$5,
               5,
               Sexplib0_Sexp_conv[31],
               [0, cst_path_to_exe$1, 1, Sexplib0_Sexp_conv[31], 0]]],
             _dY_,
             _dX_,
             _dW_,
             x_237);
   }
   function sexp_of_t$9(param){
    var
     path_to_exe_245 = param[3],
     readme_241 = param[2],
     summary_239 = param[1],
     arg_246 = caml_call1(Sexplib0_Sexp_conv[7], path_to_exe_245),
     bnds_238 = [0, [1, [0, _S_, [0, arg_246, 0]]], 0];
    if(readme_241)
     var
      v_242 = readme_241[1],
      arg_244 = caml_call1(Sexplib0_Sexp_conv[7], v_242),
      bnd_243 = [1, [0, _T_, [0, arg_244, 0]]],
      bnds_238$0 = [0, bnd_243, bnds_238];
    else
     var bnds_238$0 = bnds_238;
    var
     arg_240 = caml_call1(Sexplib0_Sexp_conv[7], summary_239),
     bnds_238$1 = [0, [1, [0, _U_, [0, arg_240, 0]]], bnds_238$0];
    return [1, bnds_238$1];
   }
   var stable_witness$7 = Stable_witness[6];
   function to_v2(t){return [0, t[1], t[2], cst$0, t[3]];}
   function of_v2(t){
    var _dV_ = abs_path(t[3], t[4]);
    return [0, t[1], t[2], _dV_];
   }
   var
    to_latest$3 = caml_call2(Base_Fn[5], to_latest$2, to_v2),
    of_latest$3 = caml_call2(Base_Fn[5], of_v2, of_latest$2);
   function compare$6(a_247, b_248){
    var a_247$0 = a_247, b_248$0 = b_248;
    for(;;){
     if(a_247$0 === b_248$0) return 0;
     switch(a_247$0[0]){
       case 0:
        var a_249 = a_247$0[1];
        if(0 !== b_248$0[0]) return -1;
        var b_250 = b_248$0[1];
        return compare$3(a_249, b_250);
       case 1:
        var a_251 = a_247$0[1];
        switch(b_248$0[0]){
          case 0: break;
          case 1:
           var b_252 = b_248$0[1];
           return compare$4
                   (function(a_253, b_254){return compare$6(a_253, b_254);},
                    a_251,
                    b_252);
          default: return -1;
        }
        break;
       default:
        var a_257 = a_247$0[2], a_255 = a_247$0[1];
        switch(b_248$0[0]){
          case 0: break;
          case 1:
           return 1;
          default:
           var
            b_258 = b_248$0[2],
            b_256 = b_248$0[1],
            n = compare$5(a_255, b_256);
           if(0 !== n) return n;
           var a_247$0 = a_257, b_248$0 = b_258;
           continue;
        }
     }
     return 1;
    }
   }
   var t_of_sexp$11 = function _dU_(_dT_){return _dU_.fun(_dT_);};
   caml_update_dummy
    (t_of_sexp$11,
     function(sexp_263){
      a:
      {
       if(0 === sexp_263[0]){
        var _dP_ = sexp_263[1];
        b:
        if(caml_string_notequal(_dP_, cst_Basic)){
         c:
         if(caml_string_notequal(_dP_, cst_Exec)){
          if(caml_string_notequal(_dP_, cst_Group)){
           if(! caml_string_notequal(_dP_, cst_basic)) break b;
           if(! caml_string_notequal(_dP_, cst_exec)) break c;
           if(caml_string_notequal(_dP_, cst_group)) break a;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_261, sexp_263);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_261, sexp_263);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_261, sexp_263);
       }
       var _dQ_ = sexp_263[1];
       if(! _dQ_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_261, sexp_263);
       var _dR_ = _dQ_[1];
       if(0 !== _dR_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_261, sexp_263);
       var tag_264 = _dR_[1];
       b:
       if(caml_string_notequal(tag_264, cst_Basic)){
        c:
        if(caml_string_notequal(tag_264, cst_Exec)){
         if(caml_string_notequal(tag_264, cst_Group)){
          if(! caml_string_notequal(tag_264, cst_basic)) break b;
          if(! caml_string_notequal(tag_264, cst_exec)) break c;
          if(caml_string_notequal(tag_264, cst_group)) break a;
         }
         var sexp_args_270 = _dQ_[2];
         if(sexp_args_270 && ! sexp_args_270[2]){
          var
           arg0_271 = sexp_args_270[1],
           res0_272 = t_of_sexp$6(t_of_sexp$11, arg0_271);
          return [1, res0_272];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_261,
                  tag_264,
                  sexp_263);
        }
        var sexp_args_275 = _dQ_[2];
        if(sexp_args_275){
         var _dS_ = sexp_args_275[2];
         if(_dS_ && ! _dS_[2]){
          var
           arg1_277 = _dS_[1],
           arg0_276 = sexp_args_275[1],
           res0_278 = t_of_sexp$8(arg0_276),
           res1_279 = caml_call1(t_of_sexp$11, arg1_277);
          return [2, res0_278, res1_279];
         }
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_261,
                 tag_264,
                 sexp_263);
       }
       var sexp_args_265 = _dQ_[2];
       if(sexp_args_265 && ! sexp_args_265[2]){
        var arg0_266 = sexp_args_265[1], res0_267 = t_of_sexp$4(arg0_266);
        return [0, res0_267];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_261,
                tag_264,
                sexp_263);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_261, sexp_263);
     });
   function sexp_of_t$10(param){
    switch(param[0]){
      case 0:
       var arg0_280 = param[1], res0_281 = sexp_of_t$3(arg0_280);
       return [1, [0, _V_, [0, res0_281, 0]]];
      case 1:
       var
        arg0_282 = param[1],
        res0_283 = sexp_of_t$5(sexp_of_t$10, arg0_282);
       return [1, [0, _W_, [0, res0_283, 0]]];
      default:
       var
        arg1_285 = param[2],
        arg0_284 = param[1],
        res0_286 = sexp_of_t$7(arg0_284),
        res1_287 = sexp_of_t$10(arg1_285);
       return [1, [0, _X_, [0, res0_286, [0, res1_287, 0]]]];
    }
   }
   var
    stable_witness_checks_for_t$0 =
      function _dO_(_dN_){return _dO_.fun(_dN_);},
    stable_witness$8 = Stable_witness[6];
   caml_update_dummy
    (stable_witness_checks_for_t$0, function(param){return 0;});
   var t_of_sexp$12 = function _dM_(_dL_){return _dM_.fun(_dL_);};
   caml_update_dummy
    (t_of_sexp$12,
     function(sexp_292){
      a:
      {
       if(0 === sexp_292[0]){
        var _dI_ = sexp_292[1];
        b:
        if(caml_string_notequal(_dI_, cst_Base)){
         c:
         if(caml_string_notequal(_dI_, cst_Exec)){
          d:
          if(caml_string_notequal(_dI_, cst_Group)){
           if(caml_string_notequal(_dI_, cst_Lazy)){
            if(! caml_string_notequal(_dI_, cst_base)) break b;
            if(! caml_string_notequal(_dI_, cst_exec)) break c;
            if(! caml_string_notequal(_dI_, cst_group)) break d;
            if(caml_string_notequal(_dI_, cst_lazy)) break a;
           }
           return caml_call2
                   (Sexplib0_Sexp_conv_error[9], error_source_290, sexp_292);
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_290, sexp_292);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_290, sexp_292);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_290, sexp_292);
       }
       var _dJ_ = sexp_292[1];
       if(! _dJ_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_290, sexp_292);
       var _dK_ = _dJ_[1];
       if(0 !== _dK_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_290, sexp_292);
       var tag_293 = _dK_[1];
       b:
       if(caml_string_notequal(tag_293, cst_Base)){
        c:
        if(caml_string_notequal(tag_293, cst_Exec)){
         d:
         if(caml_string_notequal(tag_293, cst_Group)){
          if(caml_string_notequal(tag_293, cst_Lazy)){
           if(! caml_string_notequal(tag_293, cst_base)) break b;
           if(! caml_string_notequal(tag_293, cst_exec)) break c;
           if(! caml_string_notequal(tag_293, cst_group)) break d;
           if(caml_string_notequal(tag_293, cst_lazy)) break a;
          }
          var sexp_args_309 = _dJ_[2];
          if(sexp_args_309 && ! sexp_args_309[2]){
           var
            arg0_310 = sexp_args_309[1],
            res0_311 = caml_call2(t_of_sexp, t_of_sexp$12, arg0_310);
           return [3, res0_311];
          }
          return caml_call3
                  (Sexplib0_Sexp_conv_error[8],
                   error_source_290,
                   tag_293,
                   sexp_292);
         }
         var sexp_args_299 = _dJ_[2];
         if(sexp_args_299 && ! sexp_args_299[2]){
          var
           arg0_300 = sexp_args_299[1],
           res0_301 = t_of_sexp$6(t_of_sexp$12, arg0_300);
          return [1, res0_301];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_290,
                  tag_293,
                  sexp_292);
        }
        var sexp_args_304 = _dJ_[2];
        if(sexp_args_304 && ! sexp_args_304[2]){
         var arg0_305 = sexp_args_304[1], res0_306 = t_of_sexp$8(arg0_305);
         return [2, res0_306];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_290,
                 tag_293,
                 sexp_292);
       }
       var sexp_args_294 = _dJ_[2];
       if(sexp_args_294 && ! sexp_args_294[2]){
        var arg0_295 = sexp_args_294[1], res0_296 = t_of_sexp$4(arg0_295);
        return [0, res0_296];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_290,
                tag_293,
                sexp_292);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_290, sexp_292);
     });
   function sexp_of_t$11(param){
    switch(param[0]){
      case 0:
       var arg0_312 = param[1], res0_313 = sexp_of_t$3(arg0_312);
       return [1, [0, _Y_, [0, res0_313, 0]]];
      case 1:
       var
        arg0_314 = param[1],
        res0_315 = sexp_of_t$5(sexp_of_t$11, arg0_314);
       return [1, [0, _Z_, [0, res0_315, 0]]];
      case 2:
       var arg0_316 = param[1], res0_317 = sexp_of_t$7(arg0_316);
       return [1, [0, ___, [0, res0_317, 0]]];
      default:
       var
        arg0_318 = param[1],
        res0_319 = caml_call2(sexp_of_t, sexp_of_t$11, arg0_318);
       return [1, [0, _$_, [0, res0_319, 0]]];
    }
   }
   var
    stable_witness_checks_for_t$1 =
      function _dH_(_dG_){return _dH_.fun(_dG_);};
   caml_update_dummy
    (stable_witness_checks_for_t$1, function(param){return 0;});
   var t_of_sexp$13 = function _dF_(_dE_){return _dF_.fun(_dE_);};
   caml_update_dummy
    (t_of_sexp$13,
     function(sexp_324){
      a:
      {
       if(0 === sexp_324[0]){
        var _dB_ = sexp_324[1];
        b:
        if(caml_string_notequal(_dB_, cst_Base)){
         c:
         if(caml_string_notequal(_dB_, cst_Exec)){
          if(caml_string_notequal(_dB_, cst_Group)){
           if(! caml_string_notequal(_dB_, cst_base)) break b;
           if(! caml_string_notequal(_dB_, cst_exec)) break c;
           if(caml_string_notequal(_dB_, cst_group)) break a;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_322, sexp_324);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_322, sexp_324);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_322, sexp_324);
       }
       var _dC_ = sexp_324[1];
       if(! _dC_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_322, sexp_324);
       var _dD_ = _dC_[1];
       if(0 !== _dD_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_322, sexp_324);
       var tag_325 = _dD_[1];
       b:
       if(caml_string_notequal(tag_325, cst_Base)){
        c:
        if(caml_string_notequal(tag_325, cst_Exec)){
         if(caml_string_notequal(tag_325, cst_Group)){
          if(! caml_string_notequal(tag_325, cst_base)) break b;
          if(! caml_string_notequal(tag_325, cst_exec)) break c;
          if(caml_string_notequal(tag_325, cst_group)) break a;
         }
         var sexp_args_331 = _dC_[2];
         if(sexp_args_331 && ! sexp_args_331[2]){
          var
           arg0_332 = sexp_args_331[1],
           res0_333 = t_of_sexp$7(t_of_sexp$13, arg0_332);
          return [1, res0_333];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_322,
                  tag_325,
                  sexp_324);
        }
        var sexp_args_336 = _dC_[2];
        if(sexp_args_336 && ! sexp_args_336[2]){
         var arg0_337 = sexp_args_336[1], res0_338 = t_of_sexp$9(arg0_337);
         return [2, res0_338];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_322,
                 tag_325,
                 sexp_324);
       }
       var sexp_args_326 = _dC_[2];
       if(sexp_args_326 && ! sexp_args_326[2]){
        var arg0_327 = sexp_args_326[1], res0_328 = t_of_sexp$4(arg0_327);
        return [0, res0_328];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_322,
                tag_325,
                sexp_324);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_322, sexp_324);
     });
   function sexp_of_t$12(param){
    switch(param[0]){
      case 0:
       var arg0_339 = param[1], res0_340 = sexp_of_t$3(arg0_339);
       return [1, [0, _aa_, [0, res0_340, 0]]];
      case 1:
       var
        arg0_341 = param[1],
        res0_342 = sexp_of_t$6(sexp_of_t$12, arg0_341);
       return [1, [0, _ab_, [0, res0_342, 0]]];
      default:
       var arg0_343 = param[1], res0_344 = sexp_of_t$8(arg0_343);
       return [1, [0, _ac_, [0, res0_344, 0]]];
    }
   }
   var
    stable_witness_checks_for_t$2 =
      function _dA_(_dz_){return _dA_.fun(_dz_);};
   caml_update_dummy
    (stable_witness_checks_for_t$2, function(param){return 0;});
   function to_latest$4(param){
    switch(param[0]){
      case 0:
       var b = param[1]; return [0, b];
      case 1:
       var g = param[1]; return [1, to_latest$0(map$0(g, to_latest$4))];
      default: var e = param[1]; return [2, caml_call1(to_latest$2, e)];
    }
   }
   function of_latest$4(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var b = param$0[1]; return [0, b];
       case 1:
        var g = param$0[1]; return [1, map$0(of_latest$0(g), of_latest$4)];
       case 2:
        var e = param$0[1]; return [2, caml_call1(of_latest$2, e)];
       default:
        var thunk = param$0[1], _dy_ = caml_obj_tag(thunk);
        a:
        if(250 === _dy_)
         var param$1 = thunk[1];
        else{
         if(246 !== _dy_ && 244 !== _dy_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
     }
   }
   var t_of_sexp$14 = function _dx_(_dw_){return _dx_.fun(_dw_);};
   caml_update_dummy
    (t_of_sexp$14,
     function(sexp_349){
      a:
      {
       if(0 === sexp_349[0]){
        var _dt_ = sexp_349[1];
        b:
        if(caml_string_notequal(_dt_, cst_Base)){
         c:
         if(caml_string_notequal(_dt_, cst_Exec)){
          if(caml_string_notequal(_dt_, cst_Group)){
           if(! caml_string_notequal(_dt_, cst_base)) break b;
           if(! caml_string_notequal(_dt_, cst_exec)) break c;
           if(caml_string_notequal(_dt_, cst_group)) break a;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_347, sexp_349);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_347, sexp_349);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_347, sexp_349);
       }
       var _du_ = sexp_349[1];
       if(! _du_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_347, sexp_349);
       var _dv_ = _du_[1];
       if(0 !== _dv_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_347, sexp_349);
       var tag_350 = _dv_[1];
       b:
       if(caml_string_notequal(tag_350, cst_Base)){
        c:
        if(caml_string_notequal(tag_350, cst_Exec)){
         if(caml_string_notequal(tag_350, cst_Group)){
          if(! caml_string_notequal(tag_350, cst_base)) break b;
          if(! caml_string_notequal(tag_350, cst_exec)) break c;
          if(caml_string_notequal(tag_350, cst_group)) break a;
         }
         var sexp_args_356 = _du_[2];
         if(sexp_args_356 && ! sexp_args_356[2]){
          var
           arg0_357 = sexp_args_356[1],
           res0_358 = t_of_sexp$7(t_of_sexp$14, arg0_357);
          return [1, res0_358];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_347,
                  tag_350,
                  sexp_349);
        }
        var sexp_args_361 = _du_[2];
        if(sexp_args_361 && ! sexp_args_361[2]){
         var arg0_362 = sexp_args_361[1], res0_363 = t_of_sexp$10(arg0_362);
         return [2, res0_363];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_347,
                 tag_350,
                 sexp_349);
       }
       var sexp_args_351 = _du_[2];
       if(sexp_args_351 && ! sexp_args_351[2]){
        var arg0_352 = sexp_args_351[1], res0_353 = t_of_sexp$5(arg0_352);
        return [0, res0_353];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_347,
                tag_350,
                sexp_349);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_347, sexp_349);
     });
   function sexp_of_t$13(param){
    switch(param[0]){
      case 0:
       var arg0_364 = param[1], res0_365 = sexp_of_t$4(arg0_364);
       return [1, [0, _ad_, [0, res0_365, 0]]];
      case 1:
       var
        arg0_366 = param[1],
        res0_367 = sexp_of_t$6(sexp_of_t$13, arg0_366);
       return [1, [0, _ae_, [0, res0_367, 0]]];
      default:
       var arg0_368 = param[1], res0_369 = sexp_of_t$9(arg0_368);
       return [1, [0, _af_, [0, res0_369, 0]]];
    }
   }
   var
    stable_witness_checks_for_t$3 =
      function _ds_(_dr_){return _ds_.fun(_dr_);};
   caml_update_dummy
    (stable_witness_checks_for_t$3, function(param){return 0;});
   function to_latest$5(param){
    switch(param[0]){
      case 0:
       var b = param[1]; return [0, to_latest(b)];
      case 1:
       var g = param[1]; return [1, to_latest$0(map$0(g, to_latest$5))];
      default: var e = param[1]; return [2, caml_call1(to_latest$3, e)];
    }
   }
   function of_latest$5(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var b = param$0[1]; return [0, of_latest(b)];
       case 1:
        var g = param$0[1]; return [1, map$0(of_latest$0(g), of_latest$5)];
       case 2:
        var e = param$0[1]; return [2, caml_call1(of_latest$3, e)];
       default:
        var thunk = param$0[1], _dq_ = caml_obj_tag(thunk);
        a:
        if(250 === _dq_)
         var param$1 = thunk[1];
        else{
         if(246 !== _dq_ && 244 !== _dq_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
     }
   }
   function t_of_sexp$15(sexp_374){
    a:
    {
     if(0 === sexp_374[0]){
      var _dn_ = sexp_374[1];
      b:
      if(caml_string_notequal(_dn_, cst_V1$0)){
       c:
       if(caml_string_notequal(_dn_, cst_V2$0)){
        if(caml_string_notequal(_dn_, cst_V3$0)){
         if(! caml_string_notequal(_dn_, cst_v1)) break b;
         if(! caml_string_notequal(_dn_, cst_v2)) break c;
         if(caml_string_notequal(_dn_, cst_v3)) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_372, sexp_374);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_372, sexp_374);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_372, sexp_374);
     }
     var _do_ = sexp_374[1];
     if(! _do_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_372, sexp_374);
     var _dp_ = _do_[1];
     if(0 !== _dp_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_372, sexp_374);
     var tag_375 = _dp_[1];
     b:
     if(caml_string_notequal(tag_375, cst_V1$0)){
      c:
      if(caml_string_notequal(tag_375, cst_V2$0)){
       if(caml_string_notequal(tag_375, cst_V3$0)){
        if(! caml_string_notequal(tag_375, cst_v1)) break b;
        if(! caml_string_notequal(tag_375, cst_v2)) break c;
        if(caml_string_notequal(tag_375, cst_v3)) break a;
       }
       var sexp_args_386 = _do_[2];
       if(sexp_args_386 && ! sexp_args_386[2]){
        var
         arg0_387 = sexp_args_386[1],
         res0_388 = caml_call1(t_of_sexp$12, arg0_387);
        return [2, res0_388];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_372,
                tag_375,
                sexp_374);
      }
      var sexp_args_381 = _do_[2];
      if(sexp_args_381 && ! sexp_args_381[2]){
       var
        arg0_382 = sexp_args_381[1],
        res0_383 = caml_call1(t_of_sexp$13, arg0_382);
       return [1, res0_383];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_372,
               tag_375,
               sexp_374);
     }
     var sexp_args_376 = _do_[2];
     if(sexp_args_376 && ! sexp_args_376[2]){
      var
       arg0_377 = sexp_args_376[1],
       res0_378 = caml_call1(t_of_sexp$14, arg0_377);
      return [0, res0_378];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_372,
              tag_375,
              sexp_374);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_372, sexp_374);
   }
   function sexp_of_t$14(param){
    switch(param[0]){
      case 0:
       var arg0_389 = param[1], res0_390 = sexp_of_t$13(arg0_389);
       return [1, [0, _ag_, [0, res0_390, 0]]];
      case 1:
       var arg0_391 = param[1], res0_392 = sexp_of_t$12(arg0_391);
       return [1, [0, _ah_, [0, res0_392, 0]]];
      default:
       var arg0_393 = param[1], res0_394 = sexp_of_t$11(arg0_393);
       return [1, [0, _ai_, [0, res0_394, 0]]];
    }
   }
   function v1(v0){return [0, v0];}
   function v2(v0){return [1, v0];}
   function v3(v0){return [2, v0];}
   var
    v1$0 = [0, cst_V1, 0, v1],
    v2$0 = [0, cst_V2, 1, v2],
    v3$0 = [0, cst_V3, 2, v3];
   function of_versioned(param){
    switch(param[0]){
      case 0:
       var t = param[1]; return to_latest$5(t);
      case 1:
       var t$0 = param[1]; return to_latest$4(t$0);
      default: var t$1 = param[1]; return t$1;
    }
   }
   function compare$7(a_395, b_396){
    var a_395$0 = a_395, b_396$0 = b_396;
    for(;;){
     if(a_395$0 === b_396$0) return 0;
     if(typeof a_395$0 === "number")
      return typeof b_396$0 === "number" ? 0 : -1;
     a:
     {
      b:
      {
       c:
       {
        switch(a_395$0[0]){
          case 0:
           var a_397 = a_395$0[1];
           if(typeof b_396$0 === "number") break a;
           if(0 !== b_396$0[0]) return -1;
           var b_398 = b_396$0[1];
           return caml_call2(Base[195], a_397, b_398);
          case 1:
           var a_399 = a_395$0[1];
           if(typeof b_396$0 === "number") break a;
           switch(b_396$0[0]){
             case 0:
              break b;
             case 1:
              var b_400 = b_396$0[1], a_395$0 = a_399, b_396$0 = b_400;
              continue;
             default: return -1;
           }
          case 2:
           var a_401 = a_395$0[1];
           if(typeof b_396$0 === "number") break a;
           switch(b_396$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2:
              var b_402 = b_396$0[1], a_395$0 = a_401, b_396$0 = b_402;
              continue;
             default: return -1;
           }
          case 3:
           var a_403 = a_395$0[1];
           if(typeof b_396$0 === "number") break a;
           switch(b_396$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2: break;
             case 3:
              var
               b_404 = b_396$0[1],
               _dm_ = function(a_405, b_406){return compare$7(a_405, b_406);};
              return caml_call3(Base[159], _dm_, a_403, b_404);
             default: return -1;
           }
           break;
          default:
           var a_407 = a_395$0[1];
           if(typeof b_396$0 === "number") break a;
           switch(b_396$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2: break;
             case 3:
              return 1;
             default:
              var b_408 = b_396$0[1];
              return caml_call2(Base[195], a_407, b_408);
           }
        }
        return 1;
       }
       return 1;
      }
      return 1;
     }
     return 1;
    }
   }
   var t_of_sexp$16 = function _dl_(_dk_){return _dl_.fun(_dk_);};
   caml_update_dummy
    (t_of_sexp$16,
     function(sexp_413){
      a:
      {
       if(0 === sexp_413[0]){
        var _df_ = sexp_413[1], _dg_ = caml_string_compare(_df_, cst_ad_hoc);
        b:
        {
         c:
         {
          d:
          {
           e:
           {
            f:
            {
             if(0 <= _dg_){
              if(0 < _dg_){
               if(! caml_string_notequal(_df_, cst_concat)) break f;
               if(! caml_string_notequal(_df_, cst_many)) break e;
               if(! caml_string_notequal(_df_, cst_maybe)) break d;
               if(! caml_string_notequal(_df_, cst_one)) break c;
               if(caml_string_notequal(_df_, cst_zero)) break a;
               break b;
              }
             }
             else if(caml_string_notequal(_df_, cst_Ad_hoc)){
              if(! caml_string_notequal(_df_, cst_Concat)) break f;
              if(! caml_string_notequal(_df_, cst_Many)) break e;
              if(! caml_string_notequal(_df_, cst_Maybe)) break d;
              if(! caml_string_notequal(_df_, cst_One)) break c;
              if(caml_string_notequal(_df_, cst_Zero)) break a;
              break b;
             }
             return caml_call2
                     (Sexplib0_Sexp_conv_error[9], error_source_411, sexp_413);
            }
            return caml_call2
                    (Sexplib0_Sexp_conv_error[9], error_source_411, sexp_413);
           }
           return caml_call2
                   (Sexplib0_Sexp_conv_error[9], error_source_411, sexp_413);
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_411, sexp_413);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_411, sexp_413);
        }
        return 0;
       }
       var _dh_ = sexp_413[1];
       if(! _dh_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_411, sexp_413);
       var _di_ = _dh_[1];
       if(0 !== _di_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_411, sexp_413);
       var tag_414 = _di_[1], _dj_ = caml_string_compare(tag_414, cst_ad_hoc);
       b:
       {
        c:
        {
         d:
         {
          e:
          {
           f:
           {
            if(0 <= _dj_){
             if(0 < _dj_){
              if(! caml_string_notequal(tag_414, cst_concat)) break f;
              if(! caml_string_notequal(tag_414, cst_many)) break e;
              if(! caml_string_notequal(tag_414, cst_maybe)) break d;
              if(! caml_string_notequal(tag_414, cst_one)) break c;
              if(caml_string_notequal(tag_414, cst_zero)) break a;
              break b;
             }
            }
            else if(caml_string_notequal(tag_414, cst_Ad_hoc)){
             if(! caml_string_notequal(tag_414, cst_Concat)) break f;
             if(! caml_string_notequal(tag_414, cst_Many)) break e;
             if(! caml_string_notequal(tag_414, cst_Maybe)) break d;
             if(! caml_string_notequal(tag_414, cst_One)) break c;
             if(caml_string_notequal(tag_414, cst_Zero)) break a;
             break b;
            }
            var sexp_args_435 = _dh_[2];
            if(sexp_args_435 && ! sexp_args_435[2]){
             var
              arg0_436 = sexp_args_435[1],
              res0_437 = caml_call1(Base[201], arg0_436);
             return [4, res0_437];
            }
            return caml_call3
                    (Sexplib0_Sexp_conv_error[8],
                     error_source_411,
                     tag_414,
                     sexp_413);
           }
           var sexp_args_430 = _dh_[2];
           if(sexp_args_430 && ! sexp_args_430[2]){
            var
             arg0_431 = sexp_args_430[1],
             res0_432 = caml_call2(Base[164], t_of_sexp$16, arg0_431);
            return [3, res0_432];
           }
           return caml_call3
                   (Sexplib0_Sexp_conv_error[8],
                    error_source_411,
                    tag_414,
                    sexp_413);
          }
          var sexp_args_420 = _dh_[2];
          if(sexp_args_420 && ! sexp_args_420[2]){
           var
            arg0_421 = sexp_args_420[1],
            res0_422 = caml_call1(t_of_sexp$16, arg0_421);
           return [1, res0_422];
          }
          return caml_call3
                  (Sexplib0_Sexp_conv_error[8],
                   error_source_411,
                   tag_414,
                   sexp_413);
         }
         var sexp_args_425 = _dh_[2];
         if(sexp_args_425 && ! sexp_args_425[2]){
          var
           arg0_426 = sexp_args_425[1],
           res0_427 = caml_call1(t_of_sexp$16, arg0_426);
          return [2, res0_427];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_411,
                  tag_414,
                  sexp_413);
        }
        var sexp_args_415 = _dh_[2];
        if(sexp_args_415 && ! sexp_args_415[2]){
         var
          arg0_416 = sexp_args_415[1],
          res0_417 = caml_call1(Base[201], arg0_416);
         return [0, res0_417];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_411,
                 tag_414,
                 sexp_413);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_411, sexp_413);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_411, sexp_413);
     });
   function sexp_of_t$15(param){
    if(typeof param === "number") return _ak_;
    switch(param[0]){
      case 0:
       var arg0_438 = param[1], res0_439 = caml_call1(Base[202], arg0_438);
       return [1, [0, _al_, [0, res0_439, 0]]];
      case 1:
       var arg0_440 = param[1], res0_441 = sexp_of_t$15(arg0_440);
       return [1, [0, _am_, [0, res0_441, 0]]];
      case 2:
       var arg0_442 = param[1], res0_443 = sexp_of_t$15(arg0_442);
       return [1, [0, _an_, [0, res0_443, 0]]];
      case 3:
       var
        arg0_444 = param[1],
        res0_445 = caml_call2(Base[165], sexp_of_t$15, arg0_444);
       return [1, [0, _ao_, [0, res0_445, 0]]];
      default:
       var arg0_446 = param[1], res0_447 = caml_call1(Base[202], arg0_446);
       return [1, [0, _ap_, [0, res0_447, 0]]];
    }
   }
   function compare$8(a_448, b_449){
    if(a_448 === b_449) return 0;
    if(0 === a_448[0]){
     var a_450 = a_448[1];
     if(0 !== b_449[0]) return -1;
     var b_451 = b_449[1];
     return caml_call2(Base[195], a_450, b_451);
    }
    var a_452 = a_448[1];
    if(0 === b_449[0]) return 1;
    var b_453 = b_449[1];
    return compare$7(a_452, b_453);
   }
   function t_of_sexp$17(sexp_458){
    a:
    {
     if(0 === sexp_458[0]){
      var _dc_ = sexp_458[1];
      b:
      if(caml_string_notequal(_dc_, cst_Grammar)){
       if(caml_string_notequal(_dc_, cst_Usage)){
        if(! caml_string_notequal(_dc_, cst_grammar)) break b;
        if(caml_string_notequal(_dc_, cst_usage$0)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_456, sexp_458);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_456, sexp_458);
     }
     var _dd_ = sexp_458[1];
     if(! _dd_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_456, sexp_458);
     var _de_ = _dd_[1];
     if(0 !== _de_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_456, sexp_458);
     var tag_459 = _de_[1];
     b:
     if(caml_string_notequal(tag_459, cst_Grammar)){
      if(caml_string_notequal(tag_459, cst_Usage)){
       if(! caml_string_notequal(tag_459, cst_grammar)) break b;
       if(caml_string_notequal(tag_459, cst_usage$0)) break a;
      }
      var sexp_args_460 = _dd_[2];
      if(sexp_args_460 && ! sexp_args_460[2]){
       var
        arg0_461 = sexp_args_460[1],
        res0_462 = caml_call1(Base[201], arg0_461);
       return [0, res0_462];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_456,
               tag_459,
               sexp_458);
     }
     var sexp_args_465 = _dd_[2];
     if(sexp_args_465 && ! sexp_args_465[2]){
      var
       arg0_466 = sexp_args_465[1],
       res0_467 = caml_call1(t_of_sexp$16, arg0_466);
      return [1, res0_467];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_456,
              tag_459,
              sexp_458);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_456, sexp_458);
   }
   function sexp_of_t$16(param){
    if(0 === param[0]){
     var arg0_468 = param[1], res0_469 = caml_call1(Base[202], arg0_468);
     return [1, [0, _aq_, [0, res0_469, 0]]];
    }
    var arg0_470 = param[1], res0_471 = sexp_of_t$15(arg0_470);
    return [1, [0, _ar_, [0, res0_471, 0]]];
   }
   function compare$9(a_472, b_473){
    if(a_472 === b_473) return 0;
    var n = caml_call2(Base[98], a_472[1], b_473[1]);
    return 0 === n ? caml_call2(Base[98], a_472[2], b_473[2]) : n;
   }
   var acc = 0, enumerate_478 = enumerate_474, enumerate_479 = enumerate_475;
   for(;;){
    if(! enumerate_479) break;
    if(enumerate_478)
     var
      enumerate_477 = enumerate_479[1],
      enumerate_480 = enumerate_478[2],
      enumerate_476 = enumerate_478[1],
      acc$0 = [0, [0, enumerate_476, enumerate_477], acc],
      acc = acc$0,
      enumerate_478 = enumerate_480;
    else
     var
      enumerate_480$0 = enumerate_479[2],
      enumerate_478 = enumerate_474,
      enumerate_479 = enumerate_480$0;
   }
   var all = caml_call1(Stdlib_List[10], acc);
   function sexp_of_t$17(param){
    var
     at_most_once_484 = param[2],
     at_least_once_482 = param[1],
     arg_485 = caml_call1(Base[105], at_most_once_484),
     bnds_481 = [0, [1, [0, _as_, [0, arg_485, 0]]], 0],
     arg_483 = caml_call1(Base[105], at_least_once_482),
     bnds_481$0 = [0, [1, [0, _at_, [0, arg_483, 0]]], bnds_481];
    return [1, bnds_481$0];
   }
   function to_help_string(t, flag_name){
    var
     at_most_once = t[2],
     at_least_once = t[1],
     description =
       at_least_once
        ? flag_name
        : caml_call2
          (Base_String[68],
           0,
           [0,
            maybe_missing_prefix,
            [0, flag_name, [0, maybe_missing_suffix, 0]]]);
    return at_most_once
            ? description
            : caml_call2
              (Base_String[68],
               0,
               [0, description, [0, maybe_more_suffix, 0]]);
   }
   function of_help_string(name){
    var match = caml_call2(Base_String[116], name, maybe_more_suffix);
    if(match)
     var name$0 = match[1], name$1 = name$0, at_most_once = 0;
    else
     var name$1 = name, at_most_once = 1;
    var _c__ = Base_String[116];
    function _c$_(_db_){return caml_call2(_c__, _db_, maybe_missing_suffix);}
    var
     _da_ = caml_call2(Base_String[117], name$1, maybe_missing_prefix),
     match$0 = caml_call2(Base_Option[22], _da_, _c$_);
    if(match$0)
     var name$2 = match$0[1], name$3 = name$2, at_least_once = 0;
    else
     var name$3 = name$1, at_least_once = 1;
    return [0, [0, at_least_once, at_most_once], name$3];
   }
   if(typeof Ppx_inline_test_lib[3] !== "number"){
    var
     Ppx_expect_test_block =
       caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
     _a0_ =
       function(param){
        function _c4_(x_486){
         var
          s = to_help_string(x_486, flag_name$0),
          _c6_ = [0, caml_call1(Sexplib0_Sexp_conv[7], s), 0],
          _c7_ = [1, [0, sexp_of_t$17(x_486), _c6_]];
         caml_call2(Command_Import[3], 0, _c7_);
         var
          match = of_help_string(s),
          flag_name = match[2],
          x_487 = match[1],
          _c8_ = 0 === compare$9(x_486, x_487) ? 1 : 0;
         if(! _c8_)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a2_], 1);
         var
          _c9_ = 0 === caml_call2(Base[195], flag_name$0, flag_name) ? 1 : 0;
         if(_c9_) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a1_], 1);
        }
        caml_call2(Base_List[19], all, _c4_);
        var _c5_ = caml_call1(Ppx_expect_runtime_Types[4][1], 0);
        return caml_call1(Ppx_expect_test_block[2], _c5_);
       },
     _a5_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _a4_,
         _a3_),
     _a6_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 0), _a5_], 0],
     _a8_ = caml_call1(Ppx_expect_runtime_Types[4][1], 2),
     _a9_ = caml_call1(Ppx_expect_runtime_Types[4][1], 1);
    caml_call14
     (Ppx_expect_test_block[3],
      cst_command_src_shape_ml,
      408,
      _ba_,
      _a$_,
      _a__,
      [0, Ppx_expect_runtime_Types[1][1]],
      0,
      _a9_,
      _a8_,
      _a7_,
      0,
      Inline_test_config,
      _a6_,
      _a0_);
   }
   function compare$10(a_494, b_495){
    if(a_494 === b_495) return 0;
    var n = caml_call2(Base[195], a_494[1], b_495[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Base[195], a_494[2], b_495[2]);
    if(0 !== n$0) return n$0;
    var _c1_ = b_495[3], _c2_ = a_494[3];
    function _c3_(a_496, b_497){return caml_call2(Base[195], a_496, b_497);}
    return caml_call3(Base[159], _c3_, _c2_, _c1_);
   }
   function aliases(r){return r[3];}
   function doc(r){return r[2];}
   function name(r){return r[1];}
   function t_of_sexp$18(x_500){
    function _cW_(param){
     var
      _c0_ = param[2],
      aliases = _c0_[2][1],
      doc = _c0_[1],
      name = param[1];
     return [0, name, doc, aliases];
    }
    var _cX_ = 0;
    function _cY_(param){
     return caml_string_notequal(param, cst_aliases$1)
             ? caml_string_notequal
                (param, cst_doc$1)
               ? caml_string_notequal(param, cst_name$1) ? -1 : 0
               : 1
             : 2;
    }
    var _cZ_ = [0, cst_aliases$0, 1, caml_call1(Base[164], Base[201]), 0];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_499,
             [0, cst_name$0, 1, Base[201], [0, cst_doc$0, 1, Base[201], _cZ_]],
             _cY_,
             _cX_,
             _cW_,
             x_500);
   }
   function sexp_of_t$18(param){
    var
     aliases_506 = param[3],
     doc_504 = param[2],
     name_502 = param[1],
     arg_507 = caml_call2(Base[165], Base[202], aliases_506),
     bnds_501 = [0, [1, [0, _au_, [0, arg_507, 0]]], 0],
     arg_505 = caml_call1(Base[202], doc_504),
     bnds_501$0 = [0, [1, [0, _av_, [0, arg_505, 0]]], bnds_501],
     arg_503 = caml_call1(Base[202], name_502),
     bnds_501$1 = [0, [1, [0, _aw_, [0, arg_503, 0]]], bnds_501$0];
    return [1, bnds_501$1];
   }
   function parse_name(t){
    var
     match = of_help_string(t[1]),
     flag_name = match[2],
     num_occurrences = match[1],
     match$0 = caml_call2(Base_String[102], flag_name, 32);
    if(match$0){
     var _cT_ = match$0[2], flag_name$0 = match$0[1];
     if(! _cT_) return [0, [0, num_occurrences, 0, flag_name$0]];
     if(! _cT_[2]) return [0, [0, num_occurrences, 1, flag_name$0]];
    }
    var
     _cU_ = [0, caml_call1(Sexplib0_Sexp_conv[7], flag_name), 0],
     _cV_ =
       [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Unable_to_parse), _cU_]];
    return [1, caml_call1(Base_Error[20], _cV_)];
   }
   function flag_name(t){
    function _cR_(param){var flag_name = param[3]; return flag_name;}
    var _cS_ = parse_name(t);
    return caml_call2(Base_Or_error[47], _cS_, _cR_);
   }
   function num_occurrences(t){
    function _cP_(param){
     var num_occurrences = param[1];
     return num_occurrences;
    }
    var _cQ_ = parse_name(t);
    return caml_call2(Base_Or_error[47], _cQ_, _cP_);
   }
   function requires_arg(t){
    function _cN_(param){var requires_arg = param[2]; return requires_arg;}
    var _cO_ = parse_name(t);
    return caml_call2(Base_Or_error[47], _cO_, _cN_);
   }
   function help_screen_compare(a, b){
    return caml_string_notequal(b, cst_help)
            ? caml_string_notequal
               (a, cst_help)
              ? caml_string_notequal
                 (b, cst_version)
                ? caml_string_notequal
                   (a, cst_version)
                  ? caml_string_notequal
                     (b, cst_build_info)
                    ? caml_string_notequal
                       (a, cst_build_info)
                      ? caml_string_notequal
                         (b, cst_help$0)
                        ? caml_string_notequal
                           (a, cst_help$0)
                          ? caml_string_notequal
                             (b, cst_version$0)
                            ? caml_string_notequal(a, cst_version$0) ? 0 : 1
                            : -1
                          : 1
                        : -1
                      : 1
                    : -1
                  : 1
                : -1
              : 1
            : -1;
   }
   function sort(t){
    function _cM_(a, b){return help_screen_compare(a[1], b[1]);}
    return caml_call2(Base_List[84], t, _cM_);
   }
   function word_wrap_and_strip(text, width){
    var chunks = caml_call2(Base_String[102], text, 10);
    function _cF_(text){
     function _cG_(word){return 1 - caml_call1(Base_String[14], word);}
     var
      _cH_ = caml_call2(Base_String[102], text, 32),
      words = caml_call2(Base_List[12], _cH_, _cG_);
     function _cI_(acc, word){
      if(acc)
       var
        match = acc[1],
        line = match[2],
        lines = match[1],
        _cJ_ = caml_call2(Base[241], cst$1, word),
        line_and_word = caml_call2(Base[241], line, _cJ_),
        _cK_ =
          caml_ml_string_length(line_and_word) <= width
           ? [0, lines, line_and_word]
           : [0, [0, line, lines], word],
        _cL_ = _cK_;
      else
       var _cL_ = [0, 0, word];
      return [0, _cL_];
     }
     var match = caml_call3(Base_List[20], words, 0, _cI_);
     if(! match) return 0;
     var match$0 = match[1], line = match$0[2], lines = match$0[1];
     return caml_call1(Base_List[63], [0, line, lines]);
    }
    return caml_call2(Base_List[14], chunks, _cF_);
   }
   function spaces_string(width){
    return caml_call2(Base_String[66], width, 32);
   }
   function pad_spaces_to_suffix(x, width){
    var
     slack = width - caml_ml_string_length(x) | 0,
     _cE_ = spaces_string(slack);
    return caml_call2(Base[241], x, _cE_);
   }
   function indent_and_newline(x){
    return caml_call1(Base_List[11], [0, [0, indentation, 0], [0, x, _ax_]]);
   }
   var
    lhs_pad = spaces_string(29),
    dot_indentation_offset = 27,
    _ay_ = Base_List[53];
   function _az_(v){return indent_and_newline([0, lhs_pad, [0, v, 0]]);}
   function to_string(t){
    function _cB_(t){
     var
      flag = t[1],
      flag_name_with_aliases =
        caml_call2(Base_String[68], _aA_, [0, flag, t[3]]),
      documentation = t[2],
      flag_width = 2 + caml_ml_string_length(flag_name_with_aliases) | 0,
      flag_on_its_own_line =
        29 <= flag_width
         ? indent_and_newline([0, flag_name_with_aliases, 0])
         : indent_and_newline
           ([0,
             pad_spaces_to_suffix
              (flag_name_with_aliases, dot_indentation_offset),
             [0, spacing_dot, 0]]),
      wrapped_documentation = word_wrap_and_strip(documentation, 49);
     if(wrapped_documentation)
      var
       doc_wrapped_rest_lines = wrapped_documentation[2],
       doc_wrapped_first_line = wrapped_documentation[1],
       wrapped_doc_lines = caml_call2(_ay_, doc_wrapped_rest_lines, _az_),
       prefix_doc_wrapped_first_line_ =
         function(x){
          return indent_and_newline
                  ([0,
                    pad_spaces_to_suffix(x, dot_indentation_offset),
                    [0, spacing_dot, [0, doc_wrapped_first_line, 0]]]);
         },
       _cD_ =
         27 <= caml_ml_string_length(flag_name_with_aliases)
          ? [0,
            flag_on_its_own_line,
            [0, prefix_doc_wrapped_first_line_(cst$2), wrapped_doc_lines]]
          : [0,
            prefix_doc_wrapped_first_line_(flag_name_with_aliases),
            wrapped_doc_lines];
     else
      var _cD_ = [0, flag_on_its_own_line, 0];
     return caml_call1(Base_List[11], _cD_);
    }
    var _cC_ = caml_call2(Base_List[14], t, _cB_);
    return caml_call2(Base_String[68], 0, _cC_);
   }
   function to_string$0(param){return param ? cst_flag : cst_subcommand;}
   var Key_type = [0, to_string$0];
   function lookup_expand(alist, prefix, key_type){
    var is_dash = caml_call1(Base_Char[16], 45);
    if(caml_call2(Base_String[20], prefix, is_dash))
     var
      _ct_ =
        function(param){
         var data = param[2][1], key = param[1];
         return [0, key, [0, data, -461087063]];
        },
      alist$0 = caml_call2(Base_List[53], alist, _ct_);
    else
     var alist$0 = alist;
    function _cu_(param){
     var key = param[1];
     return -461087063 <= param[2][2]
             ? caml_call2(Base_String[47], key, prefix)
             : caml_call2(Base_String[97], key, prefix);
    }
    var matches = caml_call2(Base_List[12], alist$0, _cu_);
    if(! matches){
     var
      _cA_ =
        [0,
         [11,
          cst_unknown,
          [24,
           _aF_,
           function(param, custom_printf_508){
            return caml_call1(Key_type[1], custom_printf_508);
           },
           _aE_]],
         cst_unknown_Key_type_s];
     return [1, caml_call3(Command_Import[7], _cA_, key_type, prefix)];
    }
    if(! matches[2]){
     var _cz_ = matches[1], data$0 = _cz_[2][1], key$0 = _cz_[1];
     return [0, [0, key$0, data$0]];
    }
    function _cv_(param){
     var key = param[1];
     return caml_call2(Base_String[47], key, prefix);
    }
    var match = caml_call2(Base_List[27], matches, _cv_);
    if(match){
     var _cw_ = match[1], data = _cw_[2][1], key = _cw_[1];
     return [0, [0, key, data]];
    }
    var
     matching_keys = caml_call2(Base_List[53], matches, Base[242]),
     _cx_ = caml_call2(Base_String[68], _aB_, matching_keys),
     _cy_ =
       [0,
        [24,
         _aD_,
         function(param, custom_printf_509){
          return caml_call1(Key_type[1], custom_printf_509);
         },
         _aC_],
        cst_Key_type_s_is_an_ambiguous];
    return [1, caml_call4(Command_Import[7], _cy_, key_type, prefix, _cx_)];
   }
   function compare$11(a_510, b_511){
    if(a_510 === b_511) return 0;
    var n = caml_call2(Base[195], a_510[1], b_511[1]);
    if(0 !== n) return n;
    var _cn_ = b_511[2], _co_ = a_510[2];
    function _cp_(a_512, b_513){return caml_call2(Base[195], a_512, b_513);}
    var n$0 = caml_call3(Base[178], _cp_, _co_, _cn_);
    if(0 !== n$0) return n$0;
    var n$1 = compare$8(a_510[3], b_511[3]);
    if(0 !== n$1) return n$1;
    var _cq_ = b_511[4], _cr_ = a_510[4];
    function _cs_(a_514, b_515){return compare$10(a_514, b_515);}
    return caml_call3(Base[159], _cs_, _cr_, _cq_);
   }
   function flags(r){return r[4];}
   function anons(r){return r[3];}
   function readme(r){return r[2];}
   function summary(r){return r[1];}
   function t_of_sexp$19(x_518){
    function _ch_(param){
     var
      _cl_ = param[2],
      _cm_ = _cl_[2],
      flags = _cm_[2][1],
      anons = _cm_[1],
      readme = _cl_[1],
      summary = param[1];
     return [0, summary, readme, anons, flags];
    }
    var _ci_ = 0;
    function _cj_(param){
     return caml_string_notequal(param, cst_anons$1)
             ? caml_string_notequal
                (param, cst_flags$2)
               ? caml_string_notequal
                  (param, cst_readme$9)
                 ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
                 : 1
               : 3
             : 2;
    }
    var
     _ck_ =
       [0,
        cst_anons$0,
        1,
        t_of_sexp$17,
        [0, cst_flags$1, 1, caml_call1(Base[164], t_of_sexp$18), 0]];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_517,
             [0,
              cst_summary$6,
              1,
              Base[201],
              [0, cst_readme$6, 5, Base[201], _ck_]],
             _cj_,
             _ci_,
             _ch_,
             x_518);
   }
   function sexp_of_t$19(param){
    var
     flags_528 = param[4],
     anons_526 = param[3],
     readme_522 = param[2],
     summary_520 = param[1],
     arg_529 = caml_call2(Base[165], sexp_of_t$18, flags_528),
     bnds_519 = [0, [1, [0, _aG_, [0, arg_529, 0]]], 0],
     arg_527 = sexp_of_t$16(anons_526),
     bnds_519$0 = [0, [1, [0, _aH_, [0, arg_527, 0]]], bnds_519];
    if(readme_522)
     var
      v_523 = readme_522[1],
      arg_525 = caml_call1(Base[202], v_523),
      bnd_524 = [1, [0, _aI_, [0, arg_525, 0]]],
      bnds_519$1 = [0, bnd_524, bnds_519$0];
    else
     var bnds_519$1 = bnds_519$0;
    var
     arg_521 = caml_call1(Base[202], summary_520),
     bnds_519$2 = [0, [1, [0, _aJ_, [0, arg_521, 0]]], bnds_519$1];
    return [1, bnds_519$2];
   }
   function find_flag(t, prefix){
    if(caml_call2(Base_String[97], prefix, cst$3)){
     var
      _b6_ =
        function(choices){
         var
          _cd_ = Base[243],
          _ce_ = Base_Error[14],
          _cf_ = lookup_expand(caml_call1(Base_List[11], choices), prefix, 1),
          _cg_ = caml_call2(Base_Result[34], _cf_, _ce_);
         return caml_call2(Base_Or_error[47], _cg_, _cd_);
        },
      _b7_ =
        function(flag_info){
         function _ca_(flag_name){
          function _cc_(key){return [0, key, [0, flag_info, -481604174]];}
          return [0,
                  caml_call2
                   (Base_List[53], [0, flag_name, flag_info[3]], _cc_)];
         }
         var _cb_ = flag_name(flag_info);
         return caml_call2(Base_Or_error[28][4][2], _cb_, _ca_);
        },
      _b8_ = caml_call2(Base_List[53], t[4], _b7_),
      _b9_ = caml_call1(Base_Or_error[50], _b8_);
     return caml_call2(Base_Or_error[28][4][2], _b9_, _b6_);
    }
    var
     _b__ = [0, caml_call1(Sexplib0_Sexp_conv[7], prefix), 0],
     _b$_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Flags_must_begin_with),
         _b__]];
    return [1, caml_call1(Base_Error[20], _b$_)];
   }
   function get_usage(t){
    var match = t[3];
    if(0 === match[0]){var usage$0 = match[1]; return usage$0;}
    var grammar = match[1];
    return usage(grammar);
   }
   function compare$12(cmp_a, a_532, b_533){
    if(a_532 === b_533) return 0;
    var n = caml_call2(Base[195], a_532[1], b_533[1]);
    if(0 !== n) return n;
    var _bZ_ = b_533[2], _b0_ = a_532[2];
    function _b1_(a_534, b_535){return caml_call2(Base[195], a_534, b_535);}
    var n$0 = caml_call3(Base[178], _b1_, _b0_, _bZ_);
    if(0 !== n$0) return n$0;
    var _b2_ = b_533[3], _b3_ = a_532[3];
    function _b4_(a_536, b_537){
     function _b5_(a_538, b_539){
      var
       t_541 = a_538[2],
       t_540 = a_538[1],
       t_543 = b_539[2],
       t_542 = b_539[1],
       n = caml_call2(Base[195], t_540, t_542);
      return 0 === n ? caml_call2(cmp_a, t_541, t_543) : n;
     }
     return caml_call3(Base_List[1], _b5_, a_536, b_537);
    }
    return caml_call3(Base_Lazy[1], _b4_, _b3_, _b2_);
   }
   function subcommands(r){return r[3];}
   function readme$0(r){return r[2];}
   function summary$0(r){return r[1];}
   function t_of_sexp$20(of_a_544, x_552){
    function _bP_(param){
     var
      _bY_ = param[2],
      subcommands = _bY_[2][1],
      readme = _bY_[1],
      summary = param[1];
     return [0, summary, readme, subcommands];
    }
    var _bQ_ = 0;
    function _bR_(param){
     return caml_string_notequal(param, cst_readme$9)
             ? caml_string_notequal
                (param, cst_subcommands$2)
               ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
               : 2
             : 1;
    }
    var _bS_ = 0;
    function _bT_(sexp_551){
     if(1 === sexp_551[0]){
      var _bW_ = sexp_551[1];
      if(_bW_){
       var _bX_ = _bW_[2];
       if(_bX_ && ! _bX_[2]){
        var
         arg1_548 = _bX_[1],
         arg0_547 = _bW_[1],
         res0_549 = caml_call1(Base[201], arg0_547),
         res1_550 = caml_call1(of_a_544, arg1_548);
        return [0, res0_549, res1_550];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4], error_source_546, 2, sexp_551);
    }
    var
     _bU_ = caml_call1(Base_List[5], _bT_),
     _bV_ = [0, cst_subcommands$1, 1, caml_call1(Base_Lazy[7], _bU_), _bS_];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_546,
             [0,
              cst_summary$7,
              1,
              Base[201],
              [0, cst_readme$7, 5, Base[201], _bV_]],
             _bR_,
             _bQ_,
             _bP_,
             x_552);
   }
   function sexp_of_t$20(of_a_553, param){
    var
     subcommands_561 = param[3],
     readme_557 = param[2],
     summary_555 = param[1],
     bnds_554 = 0;
    function _bN_(param){
     var
      arg1_564 = param[2],
      arg0_563 = param[1],
      res0_565 = caml_call1(Base[202], arg0_563),
      res1_566 = caml_call1(of_a_553, arg1_564);
     return [1, [0, res0_565, [0, res1_566, 0]]];
    }
    var
     _bO_ = caml_call1(Base_List[6], _bN_),
     arg_562 = caml_call2(Base_Lazy[8], _bO_, subcommands_561),
     bnds_554$0 = [0, [1, [0, _aK_, [0, arg_562, 0]]], bnds_554];
    if(readme_557)
     var
      v_558 = readme_557[1],
      arg_560 = caml_call1(Base[202], v_558),
      bnd_559 = [1, [0, _aL_, [0, arg_560, 0]]],
      bnds_554$1 = [0, bnd_559, bnds_554$0];
    else
     var bnds_554$1 = bnds_554$0;
    var
     arg_556 = caml_call1(Base[202], summary_555),
     bnds_554$2 = [0, [1, [0, _aM_, [0, arg_556, 0]]], bnds_554$1];
    return [1, bnds_554$2];
   }
   function find_subcommand(t, prefix){
    if(caml_call2(Base_String[97], prefix, cst$4)){
     var
      _bD_ = [0, caml_call1(Sexplib0_Sexp_conv[7], prefix), 0],
      _bE_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Subcommands_must_not_begin),
          _bD_]];
     return [1, caml_call1(Base_Error[20], _bE_)];
    }
    function _bF_(param){
     var a = param[2], key = param[1];
     return [0, key, [0, a, -481604174]];
    }
    var _bG_ = t[3], _bH_ = caml_obj_tag(_bG_);
    a:
    if(250 === _bH_)
     var _bI_ = _bG_[1];
    else{
     if(246 !== _bH_ && 244 !== _bH_){var _bI_ = _bG_; break a;}
     var _bI_ = caml_call1(CamlinternalLazy[2], _bG_);
    }
    var
     choices = caml_call2(Base_List[53], _bI_, _bF_),
     _bJ_ = Base[243],
     _bK_ = Base_Error[14],
     _bL_ = lookup_expand(choices, prefix, 0),
     _bM_ = caml_call2(Base_Result[34], _bL_, _bK_);
    return caml_call2(Base_Or_error[47], _bM_, _bJ_);
   }
   function compare$13(a_567, b_568){
    if(a_567 === b_568) return 0;
    var n = caml_call2(Base[195], a_567[1], b_568[1]);
    if(0 !== n) return n;
    var _bx_ = b_568[2], _by_ = a_567[2];
    function _bz_(a_569, b_570){return caml_call2(Base[195], a_569, b_570);}
    var n$0 = caml_call3(Base[178], _bz_, _by_, _bx_);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Base[195], a_567[3], b_568[3]);
    if(0 !== n$1) return n$1;
    var n$2 = caml_call2(Base[195], a_567[4], b_568[4]);
    if(0 !== n$2) return n$2;
    var _bA_ = b_568[5], _bB_ = a_567[5];
    function _bC_(a_571, b_572){return caml_call2(Base[195], a_571, b_572);}
    return caml_call3(Base[159], _bC_, _bB_, _bA_);
   }
   function t_of_sexp$21(x_575){
    function _bq_(param){
     var
      _bu_ = param[2],
      _bv_ = _bu_[2],
      _bw_ = _bv_[2],
      child_subcommand = _bw_[2][1],
      path_to_exe = _bw_[1],
      working_dir = _bv_[1],
      readme = _bu_[1],
      summary = param[1];
     return [0, summary, readme, working_dir, path_to_exe, child_subcommand];
    }
    var _br_ = 0;
    function _bs_(param){
     return caml_string_notequal(param, cst_child_subcommand$1)
             ? caml_string_notequal
                (param, cst_path_to_exe$3)
               ? caml_string_notequal
                  (param, cst_readme$9)
                 ? caml_string_notequal
                    (param, cst_summary$9)
                   ? caml_string_notequal(param, cst_working_dir$2) ? -1 : 2
                   : 0
                 : 1
               : 3
             : 4;
    }
    var
     _bt_ =
       [0, cst_child_subcommand$0, 1, caml_call1(Base[164], Base[201]), 0];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_574,
             [0,
              cst_summary$8,
              1,
              Base[201],
              [0,
               cst_readme$8,
               5,
               Base[201],
               [0,
                cst_working_dir$1,
                1,
                Base[201],
                [0, cst_path_to_exe$2, 1, Base[201], _bt_]]]],
             _bs_,
             _br_,
             _bq_,
             x_575);
   }
   function sexp_of_t$21(param){
    var
     child_subcommand_587 = param[5],
     path_to_exe_585 = param[4],
     working_dir_583 = param[3],
     readme_579 = param[2],
     summary_577 = param[1],
     arg_588 = caml_call2(Base[165], Base[202], child_subcommand_587),
     bnds_576 = [0, [1, [0, _aN_, [0, arg_588, 0]]], 0],
     arg_586 = caml_call1(Base[202], path_to_exe_585),
     bnds_576$0 = [0, [1, [0, _aO_, [0, arg_586, 0]]], bnds_576],
     arg_584 = caml_call1(Base[202], working_dir_583),
     bnds_576$1 = [0, [1, [0, _aP_, [0, arg_584, 0]]], bnds_576$0];
    if(readme_579)
     var
      v_580 = readme_579[1],
      arg_582 = caml_call1(Base[202], v_580),
      bnd_581 = [1, [0, _aQ_, [0, arg_582, 0]]],
      bnds_576$2 = [0, bnd_581, bnds_576$1];
    else
     var bnds_576$2 = bnds_576$1;
    var
     arg_578 = caml_call1(Base[202], summary_577),
     bnds_576$3 = [0, [1, [0, _aR_, [0, arg_578, 0]]], bnds_576$2];
    return [1, bnds_576$3];
   }
   function compare$14(a_589, b_590){
    var a_589$0 = a_589, b_590$0 = b_590;
    for(;;){
     if(a_589$0 === b_590$0) return 0;
     switch(a_589$0[0]){
       case 0:
        var a_591 = a_589$0[1];
        if(0 !== b_590$0[0]) return -1;
        var b_592 = b_590$0[1];
        return compare$11(a_591, b_592);
       case 1:
        var a_593 = a_589$0[1];
        switch(b_590$0[0]){
          case 0: break;
          case 1:
           var b_594 = b_590$0[1];
           return compare$12
                   (function(a_595, b_596){return compare$14(a_595, b_596);},
                    a_593,
                    b_594);
          default: return -1;
        }
        break;
       default:
        var a_599 = a_589$0[2], a_597 = a_589$0[1];
        switch(b_590$0[0]){
          case 0: break;
          case 1:
           return 1;
          default:
           var
            b_600 = b_590$0[2],
            b_598 = b_590$0[1],
            n = compare$13(a_597, b_598);
           if(0 !== n) return n;
           var a_589$0 = a_599, b_590$0 = b_600;
           continue;
        }
     }
     return 1;
    }
   }
   var t_of_sexp$22 = function _bp_(_bo_){return _bp_.fun(_bo_);};
   caml_update_dummy
    (t_of_sexp$22,
     function(sexp_605){
      a:
      {
       if(0 === sexp_605[0]){
        var _bk_ = sexp_605[1];
        b:
        if(caml_string_notequal(_bk_, cst_Basic)){
         c:
         if(caml_string_notequal(_bk_, cst_Exec)){
          if(caml_string_notequal(_bk_, cst_Group)){
           if(! caml_string_notequal(_bk_, cst_basic)) break b;
           if(! caml_string_notequal(_bk_, cst_exec)) break c;
           if(caml_string_notequal(_bk_, cst_group)) break a;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_603, sexp_605);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_603, sexp_605);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_603, sexp_605);
       }
       var _bl_ = sexp_605[1];
       if(! _bl_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_603, sexp_605);
       var _bm_ = _bl_[1];
       if(0 !== _bm_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_603, sexp_605);
       var tag_606 = _bm_[1];
       b:
       if(caml_string_notequal(tag_606, cst_Basic)){
        c:
        if(caml_string_notequal(tag_606, cst_Exec)){
         if(caml_string_notequal(tag_606, cst_Group)){
          if(! caml_string_notequal(tag_606, cst_basic)) break b;
          if(! caml_string_notequal(tag_606, cst_exec)) break c;
          if(caml_string_notequal(tag_606, cst_group)) break a;
         }
         var sexp_args_612 = _bl_[2];
         if(sexp_args_612 && ! sexp_args_612[2]){
          var
           arg0_613 = sexp_args_612[1],
           res0_614 = t_of_sexp$20(t_of_sexp$22, arg0_613);
          return [1, res0_614];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_603,
                  tag_606,
                  sexp_605);
        }
        var sexp_args_617 = _bl_[2];
        if(sexp_args_617){
         var _bn_ = sexp_args_617[2];
         if(_bn_ && ! _bn_[2]){
          var
           arg1_619 = _bn_[1],
           arg0_618 = sexp_args_617[1],
           res0_620 = t_of_sexp$21(arg0_618),
           res1_621 = caml_call1(t_of_sexp$22, arg1_619);
          return [2, res0_620, res1_621];
         }
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_603,
                 tag_606,
                 sexp_605);
       }
       var sexp_args_607 = _bl_[2];
       if(sexp_args_607 && ! sexp_args_607[2]){
        var arg0_608 = sexp_args_607[1], res0_609 = t_of_sexp$19(arg0_608);
        return [0, res0_609];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_603,
                tag_606,
                sexp_605);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_603, sexp_605);
     });
   function sexp_of_t$22(param){
    switch(param[0]){
      case 0:
       var arg0_622 = param[1], res0_623 = sexp_of_t$19(arg0_622);
       return [1, [0, _aS_, [0, res0_623, 0]]];
      case 1:
       var
        arg0_624 = param[1],
        res0_625 = sexp_of_t$20(sexp_of_t$22, arg0_624);
       return [1, [0, _aT_, [0, res0_625, 0]]];
      default:
       var
        arg1_627 = param[2],
        arg0_626 = param[1],
        res0_628 = sexp_of_t$21(arg0_626),
        res1_629 = sexp_of_t$22(arg1_627);
       return [1, [0, _aU_, [0, res0_628, [0, res1_629, 0]]]];
    }
   }
   function expanded_subcommands(t){
    function expand(param){
     var param$0 = param;
     for(;;)
      switch(param$0[0]){
        case 0:
         return _aV_;
        case 1:
         var
          subcommands = param$0[1][3],
          _bf_ =
            function(param){
             var t = param[2], name = param[1];
             function _bi_(path){return [0, name, path];}
             var _bj_ = expand(t);
             return caml_call2(Base_List[53], _bj_, _bi_);
            },
          _bg_ = caml_obj_tag(subcommands);
         a:
         if(250 === _bg_)
          var _bh_ = subcommands[1];
         else{
          if(246 !== _bg_ && 244 !== _bg_){var _bh_ = subcommands; break a;}
          var _bh_ = caml_call1(CamlinternalLazy[2], subcommands);
         }
         return caml_call2(Base_List[14], _bh_, _bf_);
        default: var t = param$0[2], param$0 = t;
      }
    }
    var _be_ = expand(t);
    return caml_call1(Base_List[63], _be_);
   }
   function sexp_of_t$23(param){
    switch(param[0]){
      case 0:
       var arg0_630 = param[1], res0_631 = sexp_of_t$19(arg0_630);
       return [1, [0, _aW_, [0, res0_631, 0]]];
      case 1:
       var
        arg0_632 = param[1],
        res0_633 = sexp_of_t$20(sexp_of_t$23, arg0_632);
       return [1, [0, _aX_, [0, res0_633, 0]]];
      case 2:
       var arg0_634 = param[1], res0_635 = sexp_of_t$21(arg0_634);
       return [1, [0, _aY_, [0, res0_635, 0]]];
      default:
       var
        arg0_636 = param[1],
        res0_637 = caml_call2(Base_Lazy[8], sexp_of_t$23, arg0_636);
       return [1, [0, _aZ_, [0, res0_637, 0]]];
    }
   }
   var extraction_var = caml_call1(Command_Env_var[4], 1);
   function f(i, supported, param){
    return caml_call2(Base_Set[10], supported, i);
   }
   var
    init = caml_call1(Base_Set[5], [0, Base_Int[22]]),
    supported_versions = f(3, f(2, f(1, init, v1$0), v2$0), v3$0);
   function to_versioned(latest, version_to_use){
    var switcher = version_to_use - 1 | 0;
    if(2 >= switcher >>> 0)
     switch(switcher){
       case 0:
        return [0, of_latest$5(latest)];
       case 1:
        return [1, of_latest$4(latest)];
       default: return [2, latest];
     }
    var
     _bd_ =
       caml_call5
        (Base_Error[19],
         _aj_,
         0,
         cst_unsupported_version_to_use,
         version_to_use,
         Sexplib0_Sexp_conv[10]);
    return caml_call1(Base_Error[31], _bd_);
   }
   function fully_forced(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var b = param$0[1]; return [0, b];
       case 1:
        var g = param$0[1]; return [1, map(g, fully_forced)];
       case 2:
        var f = param$0[2], e = param$0[1];
        return [2, e, fully_forced(caml_call1(f, 0))];
       default:
        var thunk = param$0[1], _bc_ = caml_obj_tag(thunk);
        a:
        if(250 === _bc_)
         var param$1 = thunk[1];
        else{
         if(246 !== _bc_ && 244 !== _bc_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
     }
   }
   function get_summary(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var b = param$0[1]; return b[1];
       case 1:
        var g = param$0[1]; return g[1];
       case 2:
        var e = param$0[1]; return e[1];
       default:
        var thunk = param$0[1], _bb_ = caml_obj_tag(thunk);
        a:
        if(250 === _bb_)
         var param$1 = thunk[1];
        else{
         if(246 !== _bb_ && 244 !== _bb_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
     }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_command);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Command_Shape);
   var
    Command_Shape =
      [0,
       [0,
        [0, compare$7, sexp_of_t$15, invariant, usage],
        compare$8,
        sexp_of_t$16],
       [0, compare$9, all, sexp_of_t$17, to_help_string],
       [0,
        compare$10,
        aliases,
        doc,
        name,
        sexp_of_t$18,
        flag_name,
        num_occurrences,
        requires_arg,
        t_of_sexp$18],
       [0, sort, to_string],
       [0,
        compare$11,
        flags,
        anons,
        readme,
        summary,
        sexp_of_t$19,
        find_flag,
        get_usage,
        t_of_sexp$19],
       [0,
        compare$12,
        subcommands,
        readme$0,
        summary$0,
        sexp_of_t$20,
        find_subcommand,
        map,
        t_of_sexp$20],
       [0, compare$13, sexp_of_t$21, t_of_sexp$21],
       [0, compare$14, sexp_of_t$22, expanded_subcommands, t_of_sexp$22],
       fully_forced,
       get_summary,
       [0,
        sexp_of_t$23,
        extraction_var,
        supported_versions,
        [0, t_of_sexp$15, sexp_of_t$14],
        of_versioned,
        to_versioned],
       228660148,
       [0,
        [0,
         [0, [0, compare$0, t_of_sexp$1, sexp_of_t$0, stable_witness]],
         [0, compare$1, t_of_sexp$2, sexp_of_t$1, stable_witness$0]],
        [0, [0, compare$2, t_of_sexp$3, sexp_of_t$2, stable_witness$1]],
        [0,
         [0, compare$3, t_of_sexp$4, sexp_of_t$3, stable_witness$2],
         [0, t_of_sexp$5, sexp_of_t$4, stable_witness$3, to_latest, of_latest]],
        [0, [0, compare$4, t_of_sexp$6, sexp_of_t$5, stable_witness$4, map]],
        [0,
         [0, compare$5, t_of_sexp$8, sexp_of_t$7, stable_witness$5],
         [0,
          t_of_sexp$9,
          sexp_of_t$8,
          stable_witness$6,
          to_latest$2,
          of_latest$2],
         [0,
          t_of_sexp$10,
          sexp_of_t$9,
          stable_witness$7,
          to_latest$3,
          of_latest$3]],
        [0, [0, compare$6, t_of_sexp$11, sexp_of_t$10, stable_witness$8]]],
       [0,
        Key_type,
        abs_path,
        help_screen_compare,
        lookup_expand,
        word_wrap_and_strip]];
   runtime.caml_register_global(455, Command_Shape, cst_Command_Shape$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Command__Command_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Command_Command_intf = "Command__Command_intf",
    cst_command = "command";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Command_Command_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_command);
   caml_call1(Ppx_expect_runtime[1][1], "command/src/command_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_command, "command_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_command);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Command_Command_intf);
   var Command_Command_intf = [0];
   runtime.caml_register_global
    (11, Command_Command_intf, cst_Command_Command_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Command
//# unitInfo: Requires: Base, Base__Applicative, Base__Array, Base__Bool, Base__Char, Base__Comparator, Base__Error, Base__Exn, Base__Float, Base__Fn, Base__Info, Base__Int, Base__Lazy, Base__List, Base__Map, Base__Nothing, Base__Option, Base__Or_error, Base__Result, Base__Set, Base__Staged, Base__String, Base__Type_equal, CamlinternalLazy, Command__Command_intf, Command__Env_var, Command__Import, Command__Shape, Expect_test_config, Filename_base, Inline_test_config, Parsexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_expect_runtime__Test_block, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Types, Ppx_inline_test_lib, Ppx_module_timer_runtime, Ppx_string_runtime, Sexplib0__Sexp_conv, Sexplib__Conv, Sexplib__Sexp, Stdio, Stdio__In_channel, Stdlib, Stdlib__List, Stdlib__Sys, Univ_map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$23 = "",
    cst$26 = "\n",
    cst$28 = "\n\n",
    cst$21 = " ",
    cst$22 = "  ",
    cst_passed_more_than_once = " passed more than once",
    cst_value = " value ",
    cst_s = "%s",
    cst$27 = ",",
    cst$24 = "-",
    cst_build_info$1 = "--build-info",
    cst_help$9 = "--help",
    cst_version$2 = "--version",
    cst_build_info$2 = "-build-info",
    cst_expand_dots$1 = "-expand-dots",
    cst_flags$1 = "-flags",
    cst_help$8 = "-help",
    cst_version$3 = "-version",
    cst$25 = ".",
    cst_Command$0 = "Command",
    cst$29 = "_",
    cst_command$0 = "command",
    cst_command_src_command_ml$3 = "command/src/command.ml",
    cst_failed_to_parse = "failed to parse ",
    cst_flag = "flag ",
    cst_flag_s_passed_more_than_on = "flag %s passed more than once",
    cst_help$7 = "help",
    cst_invalid$1 = "invalid ",
    cst_missing_required_flag$0 = "missing required flag: ",
    cst_missing_required_flag_s = "missing required flag: %s",
    cst_multiple_flags_named = "multiple flags named ",
    cst_multiple_flags_named_s = "multiple flags named %s",
    cst_same_as = 'same as "',
    cst_same_as_s = 'same as "%s"',
    cst_stderr$0 = "stderr",
    cst_stdout$0 = "stdout",
    cst_too_many_anonymous_argumen = "too many anonymous arguments",
    cst_unknown_subcommand = "unknown subcommand ",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$19 = cst$21,
    cst$20 = cst$22,
    name = "-validate-parsing",
    cst$18 = cst$22,
    cst$17 = cst$24,
    partial = [12, 32, [2, 0, [12, 10, [10, 0]]]],
    cst$15 = cst$21,
    cst$16 = cst$25,
    opt = [0, 0],
    version_list =
      [0, "hg://some/path_0xdeadbeef", [0, "ssh://a/path_8badf00d", 0]],
    cst$9 = cst$24,
    cst$10 = cst$24,
    cst$14 = cst$23,
    cst$13 = cst$23,
    cst$12 = cst$21,
    cst$11 = cst$22,
    cst$8 = cst$22,
    cst$5 = cst$24,
    cst$6 = cst$24,
    cst$7 = cst$24,
    cst$4 = cst$25,
    cst$3 = cst$21,
    cst$2 = cst$21,
    cst$1 = cst$27,
    cst$0 = cst$23,
    cst = ")",
    enumerate_008 = [0, 0, [0, 1, 0]],
    enumerate_009 = [0, 0, [0, 1, 0]],
    any = [0, 0, 0],
    at_least_once = [0, 1, 0],
    at_most_once = [0, 0, 1],
    exactly_once = [0, 1, 1],
    Base_Lazy = global_data.Base__Lazy,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Option = global_data.Base__Option,
    Base_Error = global_data.Base__Error,
    Stdio = global_data.Stdio,
    Base_String = global_data.Base__String,
    Command_Shape = global_data.Command__Shape,
    Base_Int = global_data.Base__Int,
    Command_Import = global_data.Command__Import,
    Base_Array = global_data.Base__Array,
    Sexplib_Sexp = global_data.Sexplib__Sexp,
    Base_Set = global_data.Base__Set,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Info = global_data.Base__Info,
    Stdio_In_channel = global_data.Stdio__In_channel,
    Base_Result = global_data.Base__Result,
    Base_Staged = global_data.Base__Staged,
    Base_Nothing = global_data.Base__Nothing,
    Command_Env_var = global_data.Command__Env_var,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Map = global_data.Base__Map,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Expect_test_config = global_data.Expect_test_config,
    Ppx_expect_runtime_Test_block = global_data.Ppx_expect_runtime__Test_block,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Inline_test_config = global_data.Inline_test_config,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Filename_base = global_data.Filename_base,
    Univ_map = global_data.Univ_map,
    Ppx_string_runtime = global_data.Ppx_string_runtime,
    Base_Char = global_data.Base__Char,
    Base_Fn = global_data.Base__Fn,
    Base_Type_equal = global_data.Base__Type_equal,
    Stdlib_List = global_data.Stdlib__List,
    Parsexp = global_data.Parsexp,
    Base_Or_error = global_data.Base__Or_error,
    Sexplib_Conv = global_data.Sexplib__Conv,
    Base_Exn = global_data.Base__Exn,
    Stdlib = global_data.Stdlib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Base_Applicative = global_data.Base__Applicative,
    Base_Float = global_data.Base__Float,
    Base_Bool = global_data.Base__Bool,
    Base_Comparator = global_data.Base__Comparator;
   caml_call1(Ppx_module_timer_runtime[4], cst_Command$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_command$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_command_src_command_ml$3);
   caml_call2(Ppx_inline_test_lib[6], cst_command$0, "command.ml");
   var _a_ = Ppx_inline_test_lib[3];
   a:
   {
    var
     _aZ_ = [0, "=== flags ==="],
     cst_help$5 = cst_help$7,
     _a8_ =
       [0,
        [11, "missing subcommand for command ", [2, 0, 0]],
        "missing subcommand for command %s"],
     _a9_ = [0, cst$21],
     _a6_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
     _a7_ = [0, [2, 0, 0], cst_s],
     cst_expand_dots$0 = cst_expand_dots$1,
     cst_flags$0 = cst_flags$1,
     cst_r = "-r",
     cst_help$6 = cst_help$8,
     cst_validate_arguments_are_par =
       " validate arguments are parsed correctly and exit immediately",
     _a5_ = [0, "--validate-parsing", 0],
     _a4_ = [0, cst$23, 0],
     cst_missing_executable_name = "missing executable name",
     cst_Couldn_t_choose_a_supporte =
       "Couldn't choose a supported help output version for Command.exec from the given supported versions.",
     _a3_ = [0, [0, cst_command_src_command_ml$3, 3102, 96602, 96616]],
     _a2_ = [0, [2, 0, 0], cst_s],
     _a1_ = [0, cst_command_src_command_ml$3, 3047, 22],
     _a0_ =
       [0,
        [11,
         cst_unknown_subcommand,
         [2, 0, [11, " for command ", [2, 0, [11, ": ", [2, 0, 0]]]]]],
        "unknown subcommand %s for command %s: %s"],
     cst_SUBCOMMAND = "SUBCOMMAND",
     cst_expand_subcommands_in_recu = " expand subcommands in recursive help",
     cst_expand_dots = cst_expand_dots$1,
     cst_show_flags_as_well_in_recu = " show flags as well in recursive help",
     cst_flags = cst_flags$1,
     cst_show_subcommands_of_subcom = " show subcommands of subcommands, etc.",
     cst_recursive = "-recursive",
     cst_explain_a_given_subcommand =
       "explain a given subcommand (perhaps recursively)",
     cst_subcommands_and_flags = "=== subcommands and flags ===",
     cst_subcommands$0 = "=== subcommands ===",
     _aY_ = [0, " SUBCOMMAND", 0],
     cst_help$4 = "[-help]",
     cst_help$3 = cst_help$7,
     _aW_ =
       [0,
        [11, "unexpected subcommand ", [3, 0, 0]],
        "unexpected subcommand %S"],
     _aX_ =
       [0, [11, cst_unknown_subcommand, [3, 0, 0]], "unknown subcommand %S"],
     _aU_ = [0, cst_stderr$0],
     _aV_ = [0, cst_stdout$0],
     cst_cannot_parse_command_shape = "cannot parse command shape",
     _aT_ = [0, "info"],
     cst_BUG_failed_to_read = "BUG failed to read",
     cst_stdout = cst_stdout$0,
     cst_stderr = cst_stderr$0,
     cst_argv_0 = "<argv_0>",
     _aR_ =
       [0, [11, "_jsautocom_", [4, 0, [0, 2, 10], 0, 0]], "_jsautocom_%010d"],
     _aS_ =
       [0,
        [11,
         "function ",
         [2,
          0,
          [11,
           " {\n  export COMP_CWORD\n  COMP_WORDS[0]=",
           [2,
            0,
            [11,
             '\n  if type readarray > /dev/null\n  then readarray -t COMPREPLY < <("${COMP_WORDS[',
             [17,
              0,
              [11,
               '}")\n  else IFS="\n" read -d "" -A COMPREPLY < <("${COMP_WORDS[',
               [17, 0, [11, '}")\n  fi\n}\ncomplete -F ', [2, 0, partial]]]]]]]]]],
        'function %s {\n  export COMP_CWORD\n  COMP_WORDS[0]=%s\n  if type readarray > /dev/null\n  then readarray -t COMPREPLY < <("${COMP_WORDS[@]}")\n  else IFS="\n" read -d "" -A COMPREPLY < <("${COMP_WORDS[@]}")\n  fi\n}\ncomplete -F %s %s\n%!'],
     _aQ_ = [0, cst_command_src_command_ml$3, 2670, 26],
     cst_some_build_info = "some build info",
     _aK_ =
       [0,
        [0,
         [0,
          "\n        hg://some/path_0xdeadbeef\n        ssh://a/path_8badf00d\n        ",
          [0, cst$23]],
         [0, 79767, 79775, 79852]]],
     _aL_ = [0, 79752, 79758, 79853],
     _aM_ = [0, "print version where multiple repos are used"],
     _aN_ = [0, 79612, 79616, 79853],
     _aO_ = [0, 79842, 79853, 79853],
     _aP_ = [0, 79612, 79616, 79853],
     cst_command_src_command_ml$0 = cst_command_src_command_ml$3,
     _aE_ =
       [0,
        [0, [0, " some build info ", [0, cst$23]], [0, 79977, 79992, 80013]]],
     _aF_ = [0, 79977, 79983, 80014],
     _aG_ = [0, "print build info"],
     _aH_ = [0, 79862, 79866, 80014],
     _aI_ = [0, 79977, 80014, 80014],
     _aJ_ = [0, 79862, 79866, 80014],
     cst_command_src_command_ml = cst_command_src_command_ml$3,
     cst_version$1 = "version",
     cst_the_version_of_this_build = "the version of this build",
     _aA_ = [0, cst_version$2, 0],
     cst_version$0 = cst_version$3,
     cst_info_about_this_build = "info about this build",
     _aB_ = [0, cst_build_info$1, 0],
     cst_build_info$0 = cst_build_info$2,
     _aC_ = [0, cst$26],
     cst_print_build_info_for_this_ = " print build info for this build",
     cst_build_info = cst_build_info$2,
     cst_print_the_version_of_this_ = " print the version of this build",
     cst_version = cst_version$3,
     cst_print_version_information = "print version information",
     cst_Path_passed_to_Absolute_mu =
       "Path passed to `Absolute must be absolute",
     cst_Path_passed_to_Relative_to =
       "Path passed to `Relative_to_me must be relative",
     _az_ =
       [0,
        [11, "multiple subcommands named ", [2, 0, 0]],
        "multiple subcommands named %s"],
     _aw_ = [0, [2, 0, 0], cst_s],
     cst_this_help_text = "this help text",
     _ax_ = [0, cst_help$9, 0],
     _ay_ = [0, "-?", 0],
     cst_help$2 = cst_help$8,
     _av_ =
       [0,
        [11, " print ", [2, 0, [11, " and exit", 0]]],
        " print %s and exit"],
     _au_ =
       [0,
        [11, "there is already a ", [2, 0, [11, " named ", [2, 0, 0]]]],
        "there is already a %s named %s"],
     cst_Arg_Tuple_is_not_supported =
       "Arg.Tuple is not supported by Command.Spec.flags_of_args_exn",
     _at_ = [0, 0],
     cst_Arg_Rest_all_is_not_suppor =
       "Arg.Rest_all is not supported by Command.Spec.flags_of_args_exn",
     cst_Arg_Expand_is_not_supporte =
       "Arg.Expand is not supported by Command.Spec.flags_of_args_exn",
     cst_No_help_for_parsing = "No help for parsing",
     _ar_ = [0, 1],
     _as_ = [0, [0, cst_command_src_command_ml$3, 2155, 65352, 65381]],
     cst_and_arg_name_expects_exact =
       "[and_arg_name] expects exactly one name, got",
     cst_missing_required_flag = "missing required flag",
     _aq_ = [0, 0],
     cst_Cannot_pass_more_than_one_ =
       "Cannot pass more than one of these: \n  %{Choice_name.list_to_string}",
     _al_ = [0, 0],
     cst_Cannot_pass_more_than_one_$0 =
       "Cannot pass more than one of these: \n  ",
     _ao_ =
       [0,
        [11,
         'Not all flags in group "',
         [2, 0, [11, '" are given: ', [2, 0, 0]]]],
        'Not all flags in group "%s" are given: %s'],
     _am_ = [0, 0],
     cst_Must_pass_one_of_these_Cho =
       "Must pass one of these:\n  %{Choice_name.list_to_string}",
     _an_ = [0, 0],
     cst_Must_pass_one_of_these = "Must pass one of these:\n  ",
     _aj_ =
       [0, [11, ' [requires: "', [2, 0, [11, '"]', 0]]], ' [requires: "%s"]'],
     _ak_ = [0, [2, 0, [2, 0, 0]], "%s%s"],
     cst_Command_Spec_choose_one_ca =
       "[Command.Spec.choose_one] called with duplicate name",
     _ap_ = [0, [0, cst_command_src_command_ml$3, 2018, 60195, 60213]],
     _ai_ = [0, "\n  "],
     _ah_ = [0, cst$27],
     _af_ = [0, cst$27],
     _ag_ = [0, cst$27],
     cst_choose_one_expects_choices =
       "[choose_one] expects choices to read command-line arguments.",
     cst_For_simplicity_Command_Spe =
       "For simplicity, [Command.Spec.choose_one] does not support names with commas.",
     _ae_ = [0, [0, cst_command_src_command_ml$3, 1936, 57337, 57357]],
     cst_optional_to_required_got_a =
       "[optional_to_required] got a [None] result",
     cst_s_default_Sexp = "%s (default: %{Sexp})",
     _ac_ = [12, 41, 0],
     _ad_ = [0, 0],
     cst_default = " (default: ",
     cst_ARG = "ARG",
     cst_help$1 = " -help\n",
     cst_For_usage_information_run = "For usage information, run",
     cst_Error_parsing_command_line = "Error parsing command line:",
     _Z_ = [0, cst$28],
     _Y_ =
       [0,
        [11, "missing argument for flag ", [2, 0, 0]],
        "missing argument for flag %s"],
     _X_ = [0, [2, 0, 0], cst_s],
     _W_ = [0, cst$26],
     cst_help = cst_help$8,
     _V_ =
       [0,
        [11, cst_multiple_flags_named, [2, 0, 0]],
        cst_multiple_flags_named_s],
     cst_invalid_Key_type_name_S = "invalid %{Key_type} name: %S",
     _R_ = [11, " name: ", [3, 0, 0]],
     _S_ = [0, 0],
     cst_invalid = cst_invalid$1,
     cst_invalid_Key_type_name_cont =
       "invalid %{Key_type} name (contains whitespace): %S",
     _T_ = [11, " name (contains whitespace): ", [3, 0, 0]],
     _U_ = [0, 0],
     cst_invalid$0 = cst_invalid$1,
     _Q_ =
       [0,
        [2,
         0,
         [12,
          32,
          [2, 0, [11, " contains an underscore. Use a dash instead.", 0]]]],
        "%s %s contains an underscore. Use a dash instead."],
     cst_WILL_NEVER_BE_PRINTED = "WILL NEVER BE PRINTED",
     cst_Empty_anonymous_argument_n = "Empty anonymous argument name provided",
     _O_ =
       [0,
        [11, "argument name ", [3, 0, [11, " has surrounding whitespace", 0]]],
        "argument name %S has surrounding whitespace"],
     _P_ =
       [0,
        60,
        [0, 62, [0, 91, [0, 93, [0, 40, [0, 41, [0, 123, [0, 125, 0]]]]]]]],
     _L_ = [0, cst_command_src_command_ml$3, 1210, 8],
     cst_BUG_asked_for_final_value_ =
       "BUG: asked for final value when doing completion",
     _M_ =
       [0,
        [11, cst_too_many_anonymous_argumen, 0],
        cst_too_many_anonymous_argumen],
     _N_ = [3, 0],
     _K_ =
       [0,
        [11, "missing anonymous argument: ", [2, 0, 0]],
        "missing anonymous argument: %s"],
     _I_ = [3, 0],
     _J_ =
       [0,
        [11,
         cst_failed_to_parse,
         [2, 0, [11, cst_value, [3, 0, [12, 10, [2, 0, 0]]]]]],
        "failed to parse %s value %S\n%s"],
     _F_ = [0, cst_command_src_command_ml$3, 959, 11],
     cst_bug_in_command_ml = "bug in command.ml",
     _H_ =
       [0,
        [11,
         "the grammar ",
         [2,
          0,
          [11,
           " for anonymous arguments is not supported because there is the possibility for arguments (",
           [2,
            0,
            [11,
             ") following a variable number of arguments (",
             [2,
              0,
              [11,
               ").  Supporting such grammars would complicate the implementation significantly.",
               0]]]]]]],
        "the grammar %s for anonymous arguments is not supported because there is the possibility for arguments (%s) following a variable number of arguments (%s).  Supporting such grammars would complicate the implementation significantly."],
     _G_ =
       [0,
        [11,
         "iteration of variable-length grammars such as ",
         [2, 0, [11, " is disallowed", 0]]],
        "iteration of variable-length grammars such as %s is disallowed"],
     _E_ = [0, cst_command_src_command_ml$3, 909, 11],
     _D_ =
       [0,
        [11, cst_missing_required_flag$0, [2, 0, 0]],
        cst_missing_required_flag_s],
     _C_ = [0, cst$29],
     _B_ = [0, cst$29],
     _A_ = [0, cst_command_src_command_ml$3, 764, 19],
     _z_ =
       [0,
        [11, cst_flag, [2, 0, [11, cst_passed_more_than_once, 0]]],
        cst_flag_s_passed_more_than_on],
     _y_ =
       [0,
        [11, cst_missing_required_flag$0, [2, 0, 0]],
        cst_missing_required_flag_s],
     _x_ = [0, cst$29],
     _w_ =
       [0,
        [11, cst_missing_required_flag$0, [2, 0, 0]],
        cst_missing_required_flag_s],
     _v_ = [0, cst$29],
     _u_ =
       [0,
        [11, cst_flag, [2, 0, [11, cst_passed_more_than_once, 0]]],
        cst_flag_s_passed_more_than_on],
     _t_ =
       [0,
        [11,
         cst_failed_to_parse,
         [2, 0, [11, cst_value, [3, 0, [11, ".\n", [2, 0, 0]]]]]],
        "failed to parse %s value %S.\n%s"],
     _r_ =
       [0,
        [11, "multiple flags or aliases named ", [2, 0, 0]],
        "multiple flags or aliases named %s"],
     _s_ =
       [0,
        [11, cst_multiple_flags_named, [2, 0, 0]],
        cst_multiple_flags_named_s],
     _q_ = [0, [11, cst_same_as, [2, 0, [12, 34, 0]]], cst_same_as_s],
     _p_ = [0, [11, cst_same_as, [2, 0, [12, 34, 0]]], cst_same_as_s],
     _o_ = [0, cst$29],
     cst_Command_Spec_Arg_type_comm =
       "Command.Spec.Arg_type.comma_separated: empty list not allowed",
     _n_ = [0, cst$27],
     cst_case_insensitive = " (case insensitive)",
     _k_ = [0, cst$27],
     _l_ =
       [0,
        [11, "valid arguments", [2, 0, [11, ": {", [2, 0, [12, 125, 0]]]]],
        "valid arguments%s: {%s}"],
     _j_ = [0, ", "],
     cst_can_be = "(can be: ",
     _i_ = [0, "duplicate_keys"],
     cst_Command_Spec_Arg_type_of_a = "Command.Spec.Arg_type.of_alist_exn",
     _g_ = [0, cst$28],
     _f_ = [0, cst$21],
     _c_ = [0, "status"],
     _d_ = [0, "command/src/command.ml.Exit_called"],
     _e_ = [0, "_none_", 0, -1],
     cst_Command_Exit_called = "Command.Exit_called",
     cst_Command_Failed_to_parse_co = "Command.Failed_to_parse_command_line",
     cst_internal_validate_parsing = "----internal-validate-parsing",
     _m_ = [0, 0],
     cst_path = "path",
     cst_args = "args",
     cst_help$0 = cst_help$7,
     cst_subcommands = "subcommands",
     cst_command_src_command_ml$1 = cst_command_src_command_ml$3,
     cst_Version_info = "Version_info",
     _a$_ =
       [0,
        [0,
         [0,
          '\n    function _jsautocom_0000012345 {\n      export COMP_CWORD\n      COMP_WORDS[0]=<argv_0>\n      if type readarray > /dev/null\n      then readarray -t COMPREPLY < <("${COMP_WORDS[@]}")\n      else IFS="\n    " read -d "" -A COMPREPLY < <("${COMP_WORDS[@]}")\n      fi\n    }\n    complete -F _jsautocom_0000012345 <argv_0>\n    ',
          [0, cst$23]],
         [0, 83018, 83022, 83348]]],
     _ba_ = [0, 83007, 83009, 83349],
     _bd_ = [0, "Demonstrate [autocomplete_function]"],
     _bg_ = [0, 82879, 82879, 83349],
     _bh_ = [0, 83342, 83349, 83349],
     _bi_ = [0, 82879, 82879, 83349],
     cst_command_src_command_ml$2 = cst_command_src_command_ml$3,
     cst_command = cst_command$0,
     cst_Command = cst_Command$0;
    if(typeof _a_ !== "number" && 545942154 <= _a_[2]){var raise_instead_of_exit = 1; break a;}
    var raise_instead_of_exit = 0;
   }
   var Exit_called = [248, cst_Command_Exit_called, caml_fresh_oo_id(0)];
   function _b_(param){
    if(param[1] !== Exit_called)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    var
     status_002 = param[2],
     arg_003 = caml_call1(Base[136], status_002),
     bnds_001 = [0, [1, [0, _c_, [0, arg_003, 0]]], 0];
    return [1, [0, _d_, bnds_001]];
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Exit_called, _b_);
   function exit(status){
    if(raise_instead_of_exit)
     throw caml_maybe_attach_backtrace([0, Exit_called, status], 1);
    return caml_call1(Stdlib[99], status);
   }
   function unparagraphs(xs){return caml_call2(Base_String[68], _g_, xs);}
   var
    Failed_to_parse_command_line =
      [248, cst_Command_Failed_to_parse_co, caml_fresh_oo_id(0)];
   function die(fmt){
    function _jz_(msg, param){
     throw caml_maybe_attach_backtrace
            ([0, Failed_to_parse_command_line, msg], 1);
    }
    return caml_call2(Command_Import[9], _jz_, fmt);
   }
   var
    help_screen_compare = Command_Shape[14][3],
    empty = Univ_map[4],
    set = Univ_map[7],
    mem = Univ_map[8],
    find = Univ_map[10],
    find_exn = Univ_map[11],
    update = Univ_map[16],
    With_default = Univ_map[30];
   function key_create(name){
    return caml_call2(Base_Type_equal[12][4], name, Sexplib_Conv[23]);
   }
   var
    multi_add = Univ_map[32][4],
    set_with_default = Univ_map[30][2],
    key_internal_validate_parsing =
      caml_call2
       (Base_Type_equal[12][4], cst_internal_validate_parsing, Base[220]);
   function apply(f, x){
    var _ju_ = f[2], _jv_ = _ju_ || x[2];
    function _jw_(param, _jy_){
     var err_1 = param[2];
     return [0, 696341824, err_1];
    }
    function _jx_(f, x){return caml_call1(f, x);}
    return [0, caml_call4(Base_Result[35], f[1], x[1], _jx_, _jw_), _jv_];
   }
   function introduce_missing_required_fla(t){
    var _jt_ = t[2];
    return [0, caml_call1(Base_Result[16], t[1]), _jt_];
   }
   function _h_(param, f){
    var has_arg = param[2], result = param[1];
    return [0, caml_call2(Base_Result[33], result, f), has_arg];
   }
   function return_no_arg(v){return [0, [0, v], 0];}
   function return_with_arg(v){return [0, [0, v], 1];}
   function error(has_arg, err){return [0, [1, err], has_arg];}
   var
    map = [0, -198771759, _h_],
    include = caml_call1(Base_Applicative[7], [0, return_no_arg, apply, map]),
    return$0 = include[1],
    map$0 = include[2],
    symbol = include[4],
    apply$0 = include[8],
    For_escape = [0],
    Auto_complete = [0, For_escape];
   function run_and_exit(t, env, part){
    function _jq_(completions){
     var _jr_ = Command_Import[5], _js_ = caml_call2(completions, env, part);
     return caml_call2(Base_List[19], _js_, _jr_);
    }
    caml_call2(Base_Option[37], t, _jq_);
    return exit(0);
   }
   function extra_doc(r){return r[4];}
   function parse(t, s){
    function _jp_(param){return caml_call1(t[1], s);}
    return caml_call2(Base_Or_error[31], 0, _jp_);
   }
   function create(complete, key, of_string){
    return [0, of_string, complete, key, caml_call1(Base_Lazy[24], 0)];
   }
   function map$1(key, t, f){
    var _jn_ = t[4], _jo_ = t[2];
    return [0,
            function(s){return caml_call1(f, caml_call1(t[1], s));},
            _jo_,
            key,
            _jn_];
   }
   function of_lazy(key, t){
    function parse(str){
     var _jl_ = caml_obj_tag(t);
     a:
     if(250 === _jl_)
      var _jm_ = t[1];
     else{
      if(246 !== _jl_ && 244 !== _jl_){var _jm_ = t; break a;}
      var _jm_ = caml_call1(CamlinternalLazy[2], t);
     }
     return caml_call1(_jm_[1], str);
    }
    function complete(env, part){
     var _jj_ = caml_obj_tag(t);
     a:
     if(250 === _jj_)
      var _jk_ = t[1];
     else{
      if(246 !== _jj_ && 244 !== _jj_){var _jk_ = t; break a;}
      var _jk_ = caml_call1(CamlinternalLazy[2], t);
     }
     var match = _jk_[2];
     if(! match) return 0;
     var complete = match[1];
     return caml_call2(complete, env, part);
    }
    var extra_doc$0 = caml_call2(Base_Lazy[13], t, extra_doc);
    return [0, parse, [0, complete], key, extra_doc$0];
   }
   var
    string = create(0, 0, function(_ji_){return _ji_;}),
    int$0 = create(0, 0, Base_Int[11]),
    char$0 = create(0, 0, Base_Char[8]),
    float$0 = create(0, 0, Base_Float[9]),
    sexp = create(0, 0, Parsexp[3][10]);
   function sexp_conv(complete, of_sexp){
    return create
            (complete,
             0,
             function(s){
              return caml_call1(of_sexp, caml_call1(Parsexp[3][10], s));
             });
   }
   function of_alist_exn
   (accept_unique_prefixes$0,
    opt,
    list_values_in_help$0,
    auto_complete,
    key,
    alist){
    if(opt)
     var sth$1 = opt[1], case_sensitive = sth$1;
    else
     var case_sensitive = 1;
    if(accept_unique_prefixes$0)
     var sth = accept_unique_prefixes$0[1], accept_unique_prefixes = sth;
    else
     var accept_unique_prefixes = 1;
    if(list_values_in_help$0)
     var sth$0 = list_values_in_help$0[1], list_values_in_help = sth$0;
    else
     var list_values_in_help = 1;
    function make(cmp){
     var match = caml_call2(Base_Map[8], [0, cmp[1]], alist);
     if(17724 <= match[1])
      var map = match[2], _jh_ = map;
     else
      var
       _i$_ = function(param){if(param && param[2]) return 1; return 0;},
       _ja_ = function(param){var k = param[1]; return [0, k, k];},
       _jb_ = caml_call2(Base_List[53], alist, _ja_),
       _jc_ = caml_call2(Base_Map[11], [0, cmp[1]], _jb_),
       _jd_ = caml_call2(Base_Map[60], _jc_, _i$_),
       duplicate_keys = caml_call1(Base_Map[74], _jd_),
       _je_ = caml_call1(Base[165], Base[202]),
       _jf_ =
         [0,
          [1, [0, _i_, [0, caml_call2(Base[165], _je_, duplicate_keys), 0]]],
          0],
       _jg_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Command_Spec_Arg_type_of_a),
           _jf_]],
       _jh_ = caml_call1(Base[246], _jg_);
     return [0, cmp, _jh_];
    }
    if(case_sensitive)
     var match = make([0, Base_String[59], Base_String[97]]);
    else
     var _i0_ = Base_String[75], match = make([0, _i0_[21], _i0_[24]]);
    var map = match[2], S = match[1];
    function complete(univ_map, prefix){
     if(auto_complete){
      var complete = auto_complete[1];
      return caml_call2(complete, univ_map, prefix);
     }
     function _i9_(param){
      var name = param[1];
      if(! caml_call2(S[2], name, prefix)) return 0;
      var
       suffix =
         caml_call3
          (Base_String[5], [0, caml_ml_string_length(prefix)], 0, name),
       name$0 = caml_call2(Base[241], prefix, suffix);
      return [0, name$0];
     }
     var _i__ = caml_call2(Base_Map[75], 0, map);
     return caml_call2(Base_List[13], _i__, _i9_);
    }
    var
     _iZ_ =
       [246,
        function(_i5_){
         if(! list_values_in_help) return 0;
         var
          _i6_ = caml_call1(Base_Map[73], map),
          values = caml_call2(Base_String[68], _j_, _i6_),
          _i7_ =
            [0, values, [0, caml_call1(Ppx_string_runtime[1][2], cst), 0]],
          _i8_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_can_be), _i7_];
         return [0, caml_call1(Ppx_string_runtime[1][4], _i8_)];
        }];
    return [0,
            function(arg){
             var s = caml_call2(Base_Map[42], map, arg);
             a:
             if(s)
              var match$0 = s;
             else if(accept_unique_prefixes){
              var
               _i1_ =
                 function(param){
                  var name = param[1];
                  return caml_call2(S[2], name, arg);
                 },
               _i2_ = caml_call2(Base_Map[75], 0, map),
               match = caml_call2(Base_List[12], _i2_, _i1_);
              if(match && ! match[2]){
               var v = match[1][2], match$0 = [0, v];
               break a;
              }
              var match$0 = 0;
             }
             else
              var match$0 = 0;
             if(match$0){var v$0 = match$0[1]; return v$0;}
             var
              valid_arguments_extra =
                case_sensitive ? cst$0 : cst_case_insensitive,
              _i3_ = caml_call1(Base_Map[73], map),
              _i4_ = caml_call2(Base_String[68], _k_, _i3_);
             return caml_call4
                     (Command_Import[8], _l_, valid_arguments_extra, _i4_, 0);
            },
            [0, complete],
            key,
            _iZ_];
   }
   function of_map
   (accept_unique_prefixes,
    case_sensitive,
    list_values_in_help,
    auto_complete,
    key,
    map){
    return of_alist_exn
            (accept_unique_prefixes,
             case_sensitive,
             list_values_in_help,
             auto_complete,
             key,
             caml_call2(Base_Map[75], 0, map));
   }
   function enumerated
   (accept_unique_prefixes,
    case_sensitive,
    list_values_in_help,
    auto_complete,
    key,
    E){
    function _iY_(t){return [0, caml_call1(E[2], t), t];}
    return of_alist_exn
            (accept_unique_prefixes,
             case_sensitive,
             list_values_in_help,
             auto_complete,
             key,
             caml_call2(Base_List[58][4][3], E[1], _iY_));
   }
   function enumerated_sexpable
   (accept_unique_prefixes,
    case_sensitive,
    list_values_in_help,
    auto_complete,
    key,
    E){
    var all = E[1];
    function to_string(t){
     var _iX_ = caml_call1(E[2], t);
     return caml_call1(Base[85][16], _iX_);
    }
    return enumerated
            (accept_unique_prefixes,
             case_sensitive,
             list_values_in_help,
             auto_complete,
             key,
             [0, all, to_string]);
   }
   var bool = enumerated(0, 0, _m_, 0, 0, [0, Base_Bool[1], Base_Bool[9]]);
   function comma_separated(opt, key, _iJ_, _iI_, t){
    if(opt) var sth = opt[1], allow_empty = sth; else var allow_empty = 0;
    if(_iJ_)
     var sth$0 = _iJ_[1], strip_whitespace = sth$0;
    else
     var strip_whitespace = 0;
    if(_iI_)
     var sth$1 = _iI_[1], unique_values = sth$1;
    else
     var unique_values = 0;
    var
     strip =
       strip_whitespace
        ? function(str){return caml_call2(Base_String[109], 0, str);}
        : function(_iW_){return _iW_;};
    function _iK_(complete_elt, env, part){
     var
      _iO_ = caml_call2(Base_String[102], part, 44),
      match = caml_call1(Base_List[63], _iO_);
     if(match)
      var
       tl = match[2],
       hd = match[1],
       suffix = hd,
       prefixes = caml_call1(Base_List[63], tl);
     else
      var suffix = part, prefixes = 0;
     if(unique_values)
      var
       _iP_ = caml_call2(Base_List[53], prefixes, strip),
       seen_already = caml_call2(Base_Set[32], [0, Base_String[59]], _iP_),
       is_allowed =
         function(choice){
          var _iV_ = strip(choice);
          return 1 - caml_call2(Base_Set[9], seen_already, _iV_);
         };
     else
      var is_allowed = function(param){return 1;};
     function _iQ_(choice){
      var _iU_ = 1 - caml_call2(Base_String[65], choice, 44);
      return _iU_ ? is_allowed(choice) : _iU_;
     }
     var
      _iR_ = caml_call2(complete_elt, env, suffix),
      choices = caml_call2(Base_List[12], _iR_, _iQ_);
     a:
     {
      if(choices && ! choices[2]){
       var
        choice = choices[1],
        choices$0 = [0, choice, [0, caml_call2(Base[241], choice, cst$1), 0]];
       break a;
      }
      var choices$0 = choices;
     }
     function _iS_(choice){
      var _iT_ = caml_call2(Base[222], prefixes, [0, choice, 0]);
      return caml_call2(Base_String[68], _n_, _iT_);
     }
     return caml_call2(Base_List[53], choices$0, _iS_);
    }
    var complete = caml_call2(Base_Option[24], t[2], _iK_);
    function of_string(string){
     var string$0 = strip(string);
     if(caml_call1(Base_String[14], string$0))
      return allow_empty
              ? 0
              : caml_call1(Base[244], cst_Command_Spec_Arg_type_comm);
     function _iL_(str){var _iN_ = strip(str); return caml_call1(t[1], _iN_);}
     var _iM_ = caml_call2(Base_String[102], string$0, 44);
     return caml_call2(Base_List[53], _iM_, _iL_);
    }
    return create(complete, key, of_string);
   }
   var include$0 = [0, string, int$0, char$0, float$0, bool, sexp, sexp_conv];
   function auto_complete(t){
    var match = t[2];
    if(! match) return function(param, _iH_){return 0;};
    var f = match[1];
    return f;
   }
   var acc = 0, enumerate_012 = enumerate_008, enumerate_013 = enumerate_009;
   for(;;){
    if(! enumerate_013) break;
    if(enumerate_012)
     var
      enumerate_011 = enumerate_013[1],
      enumerate_014 = enumerate_012[2],
      enumerate_010 = enumerate_012[1],
      acc$0 = [0, [0, enumerate_010, enumerate_011], acc],
      acc = acc$0,
      enumerate_012 = enumerate_014;
    else
     var
      enumerate_014$0 = enumerate_013[2],
      enumerate_012 = enumerate_008,
      enumerate_013 = enumerate_014$0;
   }
   caml_call1(Stdlib_List[10], acc);
   var to_help_string = Command_Shape[2][4];
   function parse$0(action, doc){
    var match = caml_call2(Base_String[100], doc, 32);
    a:
    {
     switch(action[0]){
       case 2:
        if(match && caml_string_notequal(match[1][1], cst$23)) break;
        var doc$0 = doc, arg_doc = _o_;
        break a;
       case 3:
        if(match && caml_string_notequal(match[1][1], cst$23)) break;
        var doc$0 = doc, arg_doc = 0;
        break a;
       default: var doc$0 = doc, arg_doc = 0; break a;
     }
     var
      match$0 = match[1],
      doc$1 = match$0[2],
      arg = match$0[1],
      arg_doc$0 = [0, arg],
      doc$0 = doc$1,
      arg_doc = arg_doc$0;
    }
    return [0, arg_doc, caml_call2(Base_String[109], 0, doc$0)];
   }
   function concat(name, arg_doc){
    if(! arg_doc) return name;
    var
     arg_doc$0 = arg_doc[1],
     _iG_ = caml_call2(Base[241], cst$2, arg_doc$0);
    return caml_call2(Base[241], name, _iG_);
   }
   function wrap_if_optional(t, flag_name){
    var at_least_once = t[6][1];
    return caml_call2(to_help_string, [0, at_least_once, 1], flag_name);
   }
   function help(t){
    var doc = t[5], action = t[4], aliases = t[2], name = t[1];
    if(caml_call2(Base_String[97], doc, cst$3)){
     var
      _iB_ =
        function(x){return [0, x, caml_call2(Command_Import[7], _p_, name)];},
      _iC_ = caml_call2(Base_List[53], aliases, _iB_);
     return [0, [0, name, caml_call2(Base_String[107], 0, doc)], _iC_];
    }
    var match = parse$0(action, doc), doc$0 = match[2], arg_doc = match[1];
    function _iD_(x){
     var _iF_ = caml_call2(Command_Import[7], _q_, name);
     return [0, wrap_if_optional(t, concat(x, arg_doc)), _iF_];
    }
    var _iE_ = caml_call2(Base_List[53], aliases, _iD_);
    return [0, [0, wrap_if_optional(t, concat(name, arg_doc)), doc$0], _iE_];
   }
   function align(t){
    var
     doc = t[5],
     action = t[4],
     aliases = t[2],
     name$0 = t[1],
     match = parse$0(action, doc),
     doc$0 = match[2],
     arg_doc = match[1],
     flag_name = concat(name$0, arg_doc),
     name = caml_call2(to_help_string, t[6], flag_name);
    return [0, name, doc$0, aliases];
   }
   function create$0(flags){
    function _iu_(flag){return [0, flag[1], flag];}
    var
     _iv_ = caml_call2(Base_List[53], flags, _iu_),
     match = caml_call2(Base_Map[8], [0, Base_String[59]], _iv_);
    if(17724 <= match[1]){
     var
      map = match[2],
      _iw_ = function(x){return caml_call3(Command_Import[8], _r_, x, 0);},
      _ix_ =
        function(a_020, b_021){return caml_call2(Base[195], a_020, b_021);},
      _iy_ = function(flag){return [0, flag[1], flag[2]];},
      _iz_ = caml_call2(Base_List[14], flags, _iy_),
      _iA_ = caml_call2(Base_List[128], _iz_, _ix_);
     caml_call2(Base_Option[37], _iA_, _iw_);
     return map;
    }
    var flag = match[2];
    return caml_call3(Command_Import[8], _s_, flag, 0);
   }
   function arg_flag(name, arg_type, read, write, num_occurrences){
    var _is_ = arg_type[4];
    function update(env, arg){
     var match = parse(arg_type, arg);
     if(0 !== match[0]){
      var error = match[1], _it_ = caml_call1(Base_Error[12], error);
      return caml_call4(die(_t_), name, arg, _it_, 0);
     }
     var
      arg$0 = match[1],
      env$0 = caml_call2(write, env, arg$0),
      match$0 = arg_type[3];
     if(! match$0) return env$0;
     var key = match$0[1];
     return caml_call3(multi_add, env$0, key, arg$0);
    }
    return [0, [2, update, arg_type[2]], read, num_occurrences, _is_];
   }
   function map_flag(t, f, input){
    var
     match = caml_call1(t, input),
     extra_doc = match[4],
     num_occurrences = match[3],
     read = match[2],
     action = match[1];
    return [0,
            action,
            function(env){return caml_call2(map$0, caml_call1(read, env), f);},
            num_occurrences,
            extra_doc];
   }
   function write_option(name, key, env, arg){
    return caml_call3
            (update,
             env,
             key,
             function(param){
              return param ? caml_call2(die(_u_), name, 0) : arg;
             });
   }
   function required_value(default$0, arg_type, name, num_occurrences){
    function _iq_(param){return _v_;}
    var key = caml_call2(Base_Type_equal[12][4], name, _iq_);
    function read(env){
     var match = caml_call2(find, env, key);
     if(match){var v = match[1]; return return_with_arg(v);}
     if(default$0){var v$0 = default$0[1]; return return_no_arg(v$0);}
     var _ir_ = caml_call2(Command_Import[7], _w_, name);
     return error(0, [0, 696341824, caml_call1(Base_Error[14], _ir_)]);
    }
    function write(env, arg){return write_option(name, key, env, arg);}
    return arg_flag(name, arg_type, read, write, num_occurrences);
   }
   function required(arg_type, name){
    return required_value(0, arg_type, name, exactly_once);
   }
   function optional_with_default(default$0, arg_type, name){
    return required_value([0, default$0], arg_type, name, at_most_once);
   }
   function optional(arg_type, name){
    function _ip_(param){return _x_;}
    var key = caml_call2(Base_Type_equal[12][4], name, _ip_);
    function read(env){
     var value = caml_call2(find, env, key);
     return value ? return_with_arg(value) : return_no_arg(0);
    }
    function write(env, arg){return write_option(name, key, env, arg);}
    return arg_flag(name, arg_type, read, write, at_most_once);
   }
   function no_arg_general(is_required, key_value, deprecated_hook, name){
    var key = caml_call2(Base_Type_equal[12][4], name, Base[220]);
    function read(env){
     if(caml_call2(mem, env, key)) return return_with_arg(1);
     if(! is_required) return return_no_arg(0);
     var _io_ = caml_call2(Command_Import[7], _y_, name);
     return error(0, [0, 696341824, caml_call1(Base_Error[14], _io_)]);
    }
    function action(env){
     function _in_(env, param){
      var value = param[2], key = param[1];
      return caml_call3(set_with_default, env, key, value);
     }
     var env$0 = caml_call3(Base_Option[34], key_value, env, _in_);
     return caml_call2(mem, env$0, key)
             ? caml_call2(die(_z_), name, 0)
             : caml_call3(set, env$0, key, 0);
    }
    if(deprecated_hook)
     var
      f = deprecated_hook[1],
      action$0 =
        function(env){
         var env$0 = action(env);
         caml_call1(f, 0);
         return env$0;
        };
    else
     var action$0 = action;
    var
     _il_ = caml_call1(Base_Lazy[24], 0),
     _im_ = is_required ? exactly_once : at_most_once;
    return [0, [0, action$0], read, _im_, _il_];
   }
   function no_arg(name){return no_arg_general(0, 0, 0, name);}
   function no_arg_required(v, name){
    function _ig_(param){
     if(param) return v;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
    }
    var _ih_ = 0, _ii_ = 0, _ij_ = 1;
    return map_flag
            (function(_ik_){return no_arg_general(_ij_, _ii_, _ih_, _ik_);},
             _ig_,
             name);
   }
   function no_arg_register(key, value, name){
    return no_arg_general(0, [0, [0, key, value]], 0, name);
   }
   function no_arg_some(value){
    function _ie_(param){return param ? [0, value] : 0;}
    return function(_if_){return map_flag(no_arg, _ie_, _if_);};
   }
   function listed(arg_type, name){
    function _ia_(x_022){
     function _id_(param){return _B_;}
     return caml_call2(Base[165], _id_, x_022);
    }
    var key = caml_call3(With_default[1][1], 0, name, _ia_);
    function read(env){
     var
      _ic_ = caml_call2(With_default[3], env, key),
      value_list = caml_call1(Base_List[63], _ic_);
     return value_list ? return_with_arg(value_list) : return_no_arg(0);
    }
    function write(env, arg){
     function _ib_(list){return [0, arg, list];}
     return caml_call3(With_default[4], env, key, _ib_);
    }
    return arg_flag(name, arg_type, read, write, any);
   }
   function one_or_more_as_pair(arg_type, name){
    function _h7_(x_023){
     function _h$_(param){return _C_;}
     return caml_call2(Base[165], _h$_, x_023);
    }
    var key = caml_call3(With_default[1][1], 0, name, _h7_);
    function read(env){
     var
      _h9_ = caml_call2(With_default[3], env, key),
      match = caml_call1(Base_List[63], _h9_);
     if(match){
      var rest = match[2], first = match[1];
      return return_with_arg([0, first, rest]);
     }
     var _h__ = caml_call2(Command_Import[7], _D_, name);
     return error(0, [0, 696341824, caml_call1(Base_Error[14], _h__)]);
    }
    function write(env, arg){
     function _h8_(q){return [0, arg, q];}
     return caml_call3(With_default[4], env, key, _h8_);
    }
    return arg_flag(name, arg_type, read, write, at_least_once);
   }
   function one_or_more_as_list(arg_type){
    function _h3_(param){var xs = param[2], x = param[1]; return [0, x, xs];}
    function _h4_(_h6_){return one_or_more_as_pair(arg_type, _h6_);}
    return function(_h5_){return map_flag(_h4_, _h3_, _h5_);};
   }
   function escape_general(complete, deprecated_hook, name){
    function _h2_(x_024){return caml_call2(Base[165], Base[202], x_024);}
    var key = caml_call2(Base_Type_equal[12][4], name, _h2_);
    function action(env, cmd_line){
     return caml_call3(set, env, key, cmd_line);
    }
    function read(env){
     var value = caml_call2(find, env, key);
     return value ? return_with_arg(value) : return_no_arg(0);
    }
    if(deprecated_hook)
     var
      f = deprecated_hook[1],
      action$0 = function(env, x){caml_call1(f, x); return action(env, x);};
    else
     var action$0 = action;
    return [0,
            [3, action$0, complete],
            read,
            at_most_once,
            caml_call1(Base_Lazy[24], 0)];
   }
   function no_arg_abort(exit, name){
    var _hZ_ = caml_call1(Base_Lazy[24], 0);
    function _h0_(param){return return_no_arg(0);}
    return [0,
            [0,
             function(param){
              var _h1_ = caml_call1(exit, 0);
              return caml_call1(Base_Nothing[4], _h1_);
             }],
            _h0_,
            at_most_once,
            _hZ_];
   }
   function escape(name){return escape_general(0, 0, name);}
   function escape_with_autocomplete(complete, name){return escape_general([0, complete], 0, name);
   }
   function no_arg$0(hook, name){
    return no_arg_general(0, 0, [0, hook], name);
   }
   function escape$0(hook){
    var _hW_ = [0, hook], _hX_ = 0;
    return function(_hY_){return escape_general(_hX_, _hW_, _hY_);};
   }
   var empty$0 = 0;
   function create$1(path_to_exe){return [0, path_to_exe, 0];}
   function append(t, subcommand){return [0, subcommand, t];}
   var parts = Base_List[63];
   function parts_exe_basename(t){
    var match = caml_call1(Base_List[63], t);
    if(! match) return 0;
    var tl = match[2], hd = match[1];
    return [0, caml_call1(Filename_base[37], hd), tl];
   }
   function to_string(t){
    var xs = parts_exe_basename(t);
    return caml_call2(Base_String[68], _f_, xs);
   }
   var length = Base_List[45];
   function replace_first(t, from, to){
    var parts$2 = caml_call1(parts, t), parts$0 = parts$2, acc = 0;
    for(;;){
     if(! parts$0) return acc;
     var parts$1 = parts$0[2], hd = parts$0[1];
     if(caml_call2(Base_String[47], hd, from))
      return caml_call2(Base_List[64], parts$1, [0, to, acc]);
     var acc$0 = [0, hd, acc], parts$0 = parts$1, acc = acc$0;
    }
   }
   function to_string_dots(t){
    if(t)
     var
      init = t[2],
      last = t[1],
      _hU_ = caml_call1(Base_Fn[1], cst$4),
      _hV_ = [0, last, caml_call2(Base_List[53], init, _hU_)];
    else
     var _hV_ = 0;
    return to_string(_hV_);
   }
   var
    is_empty = Base_List[18],
    invariant = Command_Shape[1][1][3],
    usage = Command_Shape[1][1][4];
   function is_fixed_arity(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 1;
     switch(param$0[0]){
       case 0:
        return 1;
       case 1:
        return 0;
       case 2:
        return 0;
       case 3:
        var ts = param$0[1], match = caml_call1(Base_List[63], ts);
        if(! match) return caml_call1(Base[244], cst_bug_in_command_ml);
        var others = match[2], last = match[1];
        if(! caml_call2(Base_List[24], others, is_fixed_arity))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
        var param$0 = last;
        break;
       default: return 0;
     }
    }
   }
   function names(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     switch(param$0[0]){
       case 0:
        var s = param$0[1]; return [0, s, 0];
       case 1:
        var t = param$0[1], param$0 = t; break;
       case 2:
        var t$0 = param$0[1], param$0 = t$0; break;
       case 3:
        var ts = param$0[1]; return caml_call2(Base_List[14], ts, names);
       default: var s$0 = param$0[1]; return [0, s$0, 0];
     }
    }
   }
   var zero = 0;
   function concat$0(param){
    if(! param) return 0;
    var cdr = param[2], car = param[1];
    function _hQ_(param, t2){
     var acc = param[2], t1 = param[1];
     if(typeof t1 === "number")
      var t = t2;
     else{
      if(typeof t2 !== "number"){
       if(is_fixed_arity(t1)) return [0, t2, [0, t1, acc]];
       var
        _hR_ = caml_call1(usage, t1),
        _hS_ = caml_call1(usage, t2),
        _hT_ =
          caml_call1
           (usage, [3, caml_call1(Base_List[63], [0, t2, [0, t1, acc]])]);
       return caml_call5(Command_Import[8], _H_, _hT_, _hS_, _hR_, 0);
      }
      var t = t1;
     }
     return [0, t, acc];
    }
    var
     match = caml_call3(Base_List[20], cdr, [0, car, 0], _hQ_),
     cdr$0 = match[2],
     car$0 = match[1];
    return cdr$0 ? [3, caml_call1(Base_List[63], [0, car$0, cdr$0])] : car$0;
   }
   function parse_more(param, f){
    var complete = param[3], parse = param[2], name = param[1];
    function parse$0(arg, for_completion){
     var
      match = caml_call2(parse, arg, for_completion),
      update_env = match[2],
      parser = match[1];
     return [0, caml_call1(f, parser), update_env];
    }
    return [1, [0, name, parse$0, complete]];
   }
   function pack_for_completion(x){
    switch(x[0]){
      case 0:
       return 0;
      case 3:
       var ps = x[1]; return ps;
      default: return [0, [0, x], 0];
    }
   }
   function symbol$0(t_left, t_right){
    a:
    {
     switch(t_left[0]){
       case 0:
        var f = t_left[1];
        switch(t_right[0]){
          case 0:
           var x = t_right[1];
           return [0,
                   function(env){
                    var
                     f_outcome = caml_call1(f, env),
                     x_outcome = caml_call1(x, env);
                    return caml_call1(f_outcome, x_outcome);
                   }];
          case 1:
           var more = t_right[1];
           return parse_more(more, function(tr){return symbol$0(t_left, tr);});
          case 2:
           var test = t_right[1];
           return [2,
                   function(more){
                    return symbol$0(t_left, caml_call1(test, more));
                   }];
          case 3:
           break a;
          default: var tr = t_right[1], tl = t_left;
        }
        break;
       case 1:
        var more$0 = t_left[1];
        return parse_more(more$0, function(tl){return symbol$0(tl, t_right);});
       case 2:
        var test$0 = t_left[1];
        return [2,
                function(more){
                 return symbol$0(caml_call1(test$0, more), t_right);
                }];
       case 4:
        var tr = t_right, tl = t_left[1]; break;
       default: break a;
     }
     return [4, symbol$0(tl, tr)];
    }
    var
     _hO_ = pack_for_completion(t_right),
     _hP_ = pack_for_completion(t_left);
    return [3, caml_call2(Base[222], _hP_, _hO_)];
   }
   function return$1(a){return [0, function(param){return a;}];}
   function symbol_map(t, f){return symbol$0(return$1(f), t);}
   function from_env(f){
    return [0, function(env){return caml_call1(f, env);}];
   }
   function symbol_map$0(t, f){
    return symbol_map(t, function(_hN_){return caml_call2(map$0, _hN_, f);});
   }
   function symbol$1(t_left, t_right){
    return symbol$0(symbol$0(return$1(symbol), t_left), t_right);
   }
   function return$2(a){return return$1(caml_call1(return$0, a));}
   function return_with_arg$0(a){
    return [0, function(param){return return_with_arg(a);}];
   }
   function one(name, arg_type){
    return [2,
            function(more){
             if(! more)
              return [0,
                      function(param){
                       var _hM_ = caml_call2(Command_Import[7], _K_, name);
                       return error
                               (0, [0, 696341824, caml_call1(Base_Error[14], _hM_)]);
                      }];
             function parse$0(anon, for_completion){
              var match = parse(arg_type, anon);
              if(0 === match[0]){
               var
                v = match[1],
                _hI_ =
                  function(env){
                   function _hL_(env, key){
                    return caml_call3(multi_add, env, key, v);
                   }
                   return caml_call3(Base_Option[34], arg_type[3], env, _hL_);
                  };
               return [0, return_with_arg$0(v), _hI_];
              }
              var error = match[1];
              if(for_completion)
               return [0, _I_, function(_hK_){return _hK_;}];
              var _hJ_ = caml_call1(Base_Error[12], error);
              return caml_call4(die(_J_), name, anon, _hJ_, 0);
             }
             return [1, [0, name, parse$0, arg_type[2]]];
            }];
   }
   function sequence(t){
    var loop = [];
    runtime.caml_update_dummy
     (loop,
      [2,
       function(more){
        return more
                ? symbol$1
                  (symbol$1
                    (return$2(function(v, acc){return [0, v, acc];}), t),
                   loop)
                : return$2(0);
       }]);
    return loop;
   }
   function consume(t, arg, for_completion){
    var t$0 = t;
    for(;;)
     switch(t$0[0]){
       case 0:
        return caml_call1(die(_M_), 0);
       case 1:
        var
         parse = t$0[1][2],
         match = caml_call2(parse, arg, for_completion),
         update_env = match[2],
         parser = match[1];
        return [0, parser, 1, update_env];
       case 2:
        var f = t$0[1], t$1 = caml_call1(f, 1), t$0 = t$1; break;
       case 3:
        var packed = t$0[1];
        if(! packed) return [0, _N_, 1, function(_hH_){return _hH_;}];
        var
         rest = packed[2],
         t$2 = packed[1][1],
         match$0 = consume(t$2, arg, for_completion),
         update_env$0 = match$0[3],
         parse_flags = match$0[2],
         parser$0 = match$0[1],
         _hF_ = pack_for_completion(parser$0);
        return [0,
                [3, caml_call2(Base[222], _hF_, rest)],
                parse_flags,
                update_env$0];
       default:
        var t$3 = t$0[1], _hG_ = consume(t$3, arg, for_completion);
        return [0, _hG_[1], 0, _hG_[3]];
     }
   }
   function t2(t1, t2){
    var
     _hC_ = concat$0([0, t1[2], [0, t2[2], 0]]),
     _hD_ = t2[1],
     _hE_ = t1[1];
    return [0,
            symbol$1
             (symbol$1(return$2(function(a1, a2){return [0, a1, a2];}), _hE_),
              _hD_),
            _hC_];
   }
   function t3(t1, t2, t3){
    var
     _hy_ = concat$0([0, t1[2], [0, t2[2], [0, t3[2], 0]]]),
     _hz_ = t3[1],
     _hA_ = t2[1],
     _hB_ = t1[1];
    return [0,
            symbol$1
             (symbol$1
               (symbol$1
                 (return$2(function(a1, a2, a3){return [0, a1, a2, a3];}),
                  _hB_),
                _hA_),
              _hz_),
            _hy_];
   }
   function t4(t1, t2, t3, t4){
    var
     _ht_ = concat$0([0, t1[2], [0, t2[2], [0, t3[2], [0, t4[2], 0]]]]),
     _hu_ = t4[1],
     _hv_ = t3[1],
     _hw_ = t2[1],
     _hx_ = t1[1];
    return [0,
            symbol$1
             (symbol$1
               (symbol$1
                 (symbol$1
                   (return$2
                     (function(a1, a2, a3, a4){return [0, a1, a2, a3, a4];}),
                    _hx_),
                  _hw_),
                _hv_),
              _hu_),
            _ht_];
   }
   function normalize(str){
    var strlen = caml_ml_string_length(str);
    if(0 === strlen) caml_call1(Base[244], cst_Empty_anonymous_argument_n);
    var _hr_ = caml_call2(Base_String[109], 0, str);
    if(caml_call2(Base_String[50], _hr_, str))
     caml_call3(Command_Import[8], _O_, str, 0);
    var
     special_chars = caml_call2(Base_Set[32], [0, Base_Char[25]], _P_),
     _hs_ = caml_call1(Base_Set[9], special_chars),
     has_special_chars = caml_call2(Base_String[19], str, _hs_);
    return has_special_chars ? str : caml_call1(Base_String[71], str);
   }
   function symbol$2(name, arg_type){
    var name$0 = normalize(name);
    return [0, one(name$0, arg_type), [0, name$0]];
   }
   function map_anons(t, f){
    var _hq_ = t[2];
    return [0, symbol_map$0(t[1], f), _hq_];
   }
   function maybe(t){
    var t$0 = t[2], _hp_ = typeof t$0 === "number" ? 0 : [2, t$0], t$1 = t[1];
    return [0,
            [2,
             function(more){
              return more
                      ? symbol$1
                        (return_with_arg$0(function(a){return [0, a];}), t$1)
                      : return$2(0);
             }],
            _hp_];
   }
   function maybe_with_default(default$0, t){
    var t$0 = maybe(t), _hn_ = t$0[2];
    function _ho_(v){return caml_call2(Base_Option[30], v, default$0);}
    return [0, symbol_map$0(t$0[1], _ho_), _hn_];
   }
   function sequence$0(t){
    var t$0 = t[2];
    if(typeof t$0 === "number")
     var _hm_ = 0;
    else{
     if(1 - is_fixed_arity(t$0)){
      var _hl_ = caml_call1(usage, t$0);
      caml_call3(Command_Import[8], _G_, _hl_, 0);
     }
     var _hm_ = [1, t$0];
    }
    return [0, sequence(t[1]), _hm_];
   }
   function non_empty_sequence_as_pair(t){return t2(t, sequence$0(t));}
   function non_empty_sequence_as_list(t){
    var t$0 = non_empty_sequence_as_pair(t), _hj_ = t$0[2];
    function _hk_(param){var xs = param[2], x = param[1]; return [0, x, xs];}
    return [0, symbol_map$0(t$0[1], _hk_), _hj_];
   }
   function ad_hoc(usage_arg){
    return [0,
            sequence(one(cst_WILL_NEVER_BE_PRINTED, include$0[1])),
            [4, usage_arg]];
   }
   function compare(a_025, b_026){
    var a_025$0 = a_025, b_026$0 = b_026;
    for(;;){
     if(a_025$0 === b_026$0) return 0;
     if(typeof a_025$0 === "number")
      return typeof b_026$0 === "number" ? 0 : -1;
     if(0 === a_025$0[0]){
      var a_029 = a_025$0[2], a_027 = a_025$0[1];
      if(typeof b_026$0 !== "number"){
       if(0 !== b_026$0[0]) return -1;
       var
        b_030 = b_026$0[2],
        b_028 = b_026$0[1],
        n = caml_call2(Base[195], a_027, b_028);
       if(0 !== n) return n;
       var a_025$0 = a_029, b_026$0 = b_030;
       continue;
      }
     }
     else{
      var a_031 = a_025$0[1];
      if(typeof b_026$0 !== "number"){
       if(0 === b_026$0[0]) return 1;
       var b_032 = b_026$0[1];
       return caml_call2(Base[195], a_031, b_032);
      }
     }
     return 1;
    }
   }
   function of_list(args){
    var _hh_ = 0;
    function _hi_(arg, args){return [0, arg, args];}
    return caml_call3(Base_List[105], args, _hi_, _hh_);
   }
   function to_list(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]){
     var xs = param[2], x = param[1];
     return [0, x, to_list(xs)];
    }
    var x$0 = param[1];
    return [0, x$0, 0];
   }
   function ends_in_complete(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 !== param$0[0]) return 1;
     var args = param$0[2], param$0 = args;
    }
   }
   function extend(t, extend, path){
    if(ends_in_complete(t)) return t;
    var
     _hd_ = caml_call1(parts, path),
     _he_ = caml_call1(Base_List[87], _hd_),
     path_list = caml_call2(Base_Option[30], _he_, 0),
     _hf_ = caml_call1(extend, path_list),
     _hg_ = to_list(t);
    return of_list(caml_call2(Base[222], _hg_, _hf_));
   }
   function normalize$0(key_type, flag_or_subcommand){
    function _g9_(c){return caml_call2(Base_Char[12], c, 95);}
    if(caml_call2(Base_String[19], flag_or_subcommand, _g9_)){
     var _g__ = caml_call1(Command_Shape[14][1][1], key_type);
     caml_call4(Command_Import[8], _Q_, _g__, flag_or_subcommand, 0);
    }
    if(! key_type) return caml_call1(Base_String[72], flag_or_subcommand);
    if(caml_call2(Base_String[134], flag_or_subcommand, cst$5)){
     var
      _g$_ = 0,
      _ha_ =
        [0,
         [11,
          cst_invalid,
          [24,
           _S_,
           function(param, custom_printf_033){
            return caml_call1(Command_Shape[14][1][1], custom_printf_033);
           },
           _R_]],
         cst_invalid_Key_type_name_S];
     caml_call4(Command_Import[8], _ha_, key_type, flag_or_subcommand, _g$_);
    }
    if(caml_call2(Base_String[19], flag_or_subcommand, Base_Char[45])){
     var
      _hb_ = 0,
      _hc_ =
        [0,
         [11,
          cst_invalid$0,
          [24,
           _U_,
           function(param, custom_printf_034){
            return caml_call1(Command_Shape[14][1][1], custom_printf_034);
           },
           _T_]],
         cst_invalid_Key_type_name_cont];
     caml_call4(Command_Import[8], _hc_, key_type, flag_or_subcommand, _hb_);
    }
    return caml_call2(Base_String[97], flag_or_subcommand, cst$6)
            ? flag_or_subcommand
            : caml_call2(Base[241], cst$7, flag_or_subcommand);
   }
   var lookup_expand = Command_Shape[14][4];
   function subcommand_cmp_fst(param, _g8_){
    var c = _g8_[1], a = param[1];
    return caml_call2(help_screen_compare, a, c);
   }
   function shape(t){
    function _g0_(a, b){return caml_call2(Base_String[51], a[1], b[1]);}
    var
     _g1_ = caml_call1(Base_Map[74], t[3]),
     _g2_ = caml_call2(Base_List[53], _g1_, align),
     _g3_ = caml_call2(Base_List[83], _g2_, _g0_),
     _g4_ = caml_call1(Command_Shape[4][1], _g3_),
     _g5_ = [1, t[5]];
    function _g6_(readme){return caml_call1(readme, 0);}
    var _g7_ = caml_call2(Base_Option[24], t[2], _g6_);
    return [0, t[1], _g7_, _g5_, _g4_];
   }
   var
    path_key = key_create(cst_path),
    args_key = key_create(cst_args),
    help_key = key_create(cst_help$0),
    normalized_path = [0, 0],
    normalized_args = [0, 0];
   function get_flag_and_action(t, prefix){
    var map = t[3], key_type = 1;
    function _gV_(flag){
     var
      name_matching = flag[8],
      aliases_excluded_from_help = flag[3],
      aliases = flag[2],
      name = flag[1],
      data = [0, flag, name_matching],
      aliases$0 = caml_call2(Base[222], aliases_excluded_from_help, aliases);
     function _gZ_(alias){return [0, alias, data];}
     return [0, [0, name, data], caml_call2(Base_List[53], aliases$0, _gZ_)];
    }
    var
     _gW_ = caml_call1(Base_Map[74], map),
     alist = caml_call2(Base_List[14], _gW_, _gV_);
    function _gX_(param, _gY_){
     var s2 = _gY_[1], s1 = param[1];
     return caml_call2(Base_String[51], s1, s2);
    }
    var match = caml_call2(Base_List[128], alist, _gX_);
    if(match)
     var
      flag = match[1][1],
      match$0 = caml_call3(Command_Import[8], _V_, flag, 0);
    else
     var match$0 = caml_call3(lookup_expand, alist, prefix, key_type);
    if(0 === match$0[0]){
     var match$1 = match$0[1], flag$0 = match$1[2], flag_name = match$1[1];
     return [0, flag_name, flag$0[4]];
    }
    var msg = match$0[1];
    return caml_call2(die(_X_), msg, 0);
   }
   function run_exn(exn, for_completion, path, verbose_on_parse_error){
    if(exn[1] === Failed_to_parse_command_line && for_completion)
     return exit(0);
    if(exn[1] === Exit_called){var status = exn[2]; return exit(status);}
    if(exn[1] === Failed_to_parse_command_line)
     var msg = exn[2], exn_str = msg;
    else
     var
      _gU_ = caml_call1(Base[117], exn),
      exn_str = caml_call2(Base[85][14], 0, _gU_);
    var verbose = caml_call2(Base_Option[30], verbose_on_parse_error, 1);
    if(verbose)
     var
      _gQ_ = to_string(path),
      _gR_ = caml_call2(Base[241], _gQ_, cst_help$1),
      _gS_ =
        [0,
         cst_For_usage_information_run,
         [0, caml_call2(Base[241], cst$11, _gR_), 0]],
      _gN_ = function(line){return caml_call2(Base[241], cst$8, line);},
      _gO_ = caml_call2(Base_String[102], exn_str, 10),
      _gP_ = caml_call2(Base_List[53], _gO_, _gN_),
      _gT_ =
        [0,
         cst_Error_parsing_command_line,
         [0, caml_call2(Base_String[68], _W_, _gP_), _gS_]],
      error_msg = caml_call2(Base_String[68], _Z_, _gT_);
    else
     var error_msg = exn_str;
    caml_call1(Command_Import[6], error_msg);
    return exit(1);
   }
   function run
   (t,
    env,
    when_parsing_succeeds,
    path,
    cmdline,
    verbose_on_parse_error,
    help_text,
    on_failure){
    var
     for_completion = ends_in_complete(cmdline),
     _gw_ = to_list(cmdline),
     env$0 =
       caml_call3
        (set,
         caml_call3(set, caml_call3(set, env, path_key, path), args_key, _gw_),
         help_key,
         help_text);
    function _gx_(param){
     var parser$1 = caml_call1(t[4], 0);
     a:
     {
      b:
      {
       var
        env$1 = env$0,
        parser = parser$1,
        cmdline$0 = cmdline,
        parse_flags = 1,
        normalized_args$0 = 0;
       for(;;){
        if(typeof cmdline$0 === "number") break b;
        if(0 !== cmdline$0[0]) break;
        var args = cmdline$0[2], arg$1 = cmdline$0[1];
        c:
        if(parse_flags && caml_string_notequal(arg$1, cst$24)){
         if
          (!
           caml_string_notequal(arg$1, "-anon")
           && typeof args !== "number" && 0 === args[0]){
          var
           args$0 = args[2],
           arg$3 = args[1],
           arg_is_flag = 0,
           cmdline$1 = args$0,
           arg$2 = arg$3;
          break c;
         }
         var
          arg_is_flag = caml_call2(Base_String[97], arg$1, cst$9),
          cmdline$1 = args,
          arg$2 = arg$1;
        }
        else
         var arg_is_flag = 0, cmdline$1 = args, arg$2 = arg$1;
        if(arg_is_flag){
         var
          match = get_flag_and_action(t, arg$2),
          action = match[2],
          flag = match[1];
         switch(action[0]){
           case 0:
            var _gI_ = [0, flag, 0]; break;
           case 1:
            var _gI_ = [0, flag, 0]; break;
           case 2:
            if(typeof cmdline$1 !== "number" && 0 === cmdline$1[0]){
             var arg = cmdline$1[1], _gI_ = [0, flag, [0, arg, 0]];
             break;
            }
            var _gI_ = 0;
            break;
           default: var _gI_ = [0, flag, to_list(cmdline$1)];
         }
         var
          normalized_args$1 = [0, _gI_, normalized_args$0],
          match$0 = get_flag_and_action(t, arg$2),
          action$0 = match$0[2],
          flag$0 = match$0[1];
         switch(action$0[0]){
           case 0:
            var
             f$1 = action$0[1],
             match$1 = [0, caml_call1(f$1, env$1), cmdline$1];
            break;
           case 1:
            var info = action$0[1], completing = ends_in_complete(cmdline$1);
            if(completing)
             var match$1 = [0, env$1, cmdline$1];
            else{
             var _gz_ = caml_call1(info, env$1);
             caml_call1(Command_Import[5], _gz_);
             var match$1 = exit(0);
            }
            break;
           case 2:
            var comp = action$0[2], f$2 = action$0[1];
            if(typeof cmdline$1 === "number")
             var match$1 = caml_call2(die(_Y_), flag$0, 0);
            else if(0 === cmdline$1[0]){
             var rest = cmdline$1[2], arg$0 = cmdline$1[1];
             try{var _gA_ = caml_call2(f$2, env$1, arg$0), env = _gA_;}
             catch(e$0){
              var e = caml_wrap_exception(e$0);
              if(e[1] !== Failed_to_parse_command_line)
               throw caml_maybe_attach_backtrace(e, 0);
              if(! ends_in_complete(rest))
               throw caml_maybe_attach_backtrace(e, 0);
              var env = env$1;
             }
             var match$1 = [0, env, rest];
            }
            else
             var
              part = cmdline$1[1],
              _gB_ = run_and_exit(comp, env$1, part),
              match$1 = caml_call1(Base_Nothing[4], _gB_);
            break;
           default:
            var
             comp$0 = action$0[2],
             f$3 = action$0[1],
             arg_list = to_list(cmdline$1);
            if(ends_in_complete(cmdline$1)){
             var _gC_ = run_and_exit(comp$0, env$1, arg_list);
             caml_call1(Base_Nothing[4], _gC_);
            }
            var match$1 = [0, caml_call2(f$3, env$1, arg_list), 0];
         }
         var
          cmdline$2 = match$1[2],
          env$2 = match$1[1],
          env$1 = env$2,
          cmdline$0 = cmdline$2,
          normalized_args$0 = normalized_args$1;
        }
        else
         var
          match$2 = consume(parser, arg$2, for_completion),
          update_env = match$2[3],
          parse_flags2 = match$2[2],
          parser$0 = match$2[1],
          env$3 = caml_call1(update_env, env$1),
          parse_flags$0 = parse_flags ? parse_flags2 : parse_flags,
          normalized_args$2 = [0, [0, arg$2, 0], normalized_args$0],
          env$1 = env$3,
          parser = parser$0,
          cmdline$0 = cmdline$1,
          parse_flags = parse_flags$0,
          normalized_args$0 = normalized_args$2;
       }
       var part$0 = cmdline$0[1];
       if(parse_flags && caml_call2(Base_String[97], part$0, cst$10)){
        var
         _gJ_ =
           function(name){
            var _gM_ = caml_call2(Base_String[97], name, part$0);
            return _gM_ ? caml_call1(Command_Import[5], name) : _gM_;
           },
         _gK_ = caml_call1(Base_Map[73], t[3]);
        caml_call2(Base_List[19], _gK_, _gJ_);
        var match$3 = exit(0);
        break a;
       }
       var t$3 = parser;
       for(;;){
        switch(t$3[0]){
          case 0:
           var _gL_ = exit(0); break;
          case 1:
           var
            complete = t$3[1][3],
            _gL_ = run_and_exit(complete, env$1, part$0);
           break;
          case 2:
           var f$0 = t$3[1], t$4 = caml_call1(f$0, 1), t$3 = t$4; continue;
          case 3:
           var t$5 = t$3[1];
           if(t$5){var t$6 = t$5[1][1], t$3 = t$6; continue;}
           var _gL_ = exit(0);
           break;
          default: var t$7 = t$3[1], t$3 = t$7; continue;
        }
        var match$3 = caml_call1(Base_Nothing[4], _gL_);
        break a;
       }
      }
      var
       _gD_ = function(flag){return caml_call1(flag[7], env$1);},
       _gE_ = caml_call1(Base_Map[74], t[3]);
      caml_call2(Base_List[19], _gE_, _gD_);
      var
       _gF_ = caml_call1(Base_List[63], normalized_args$0),
       t$0 = parser,
       _gG_ = caml_call1(Base_List[11], _gF_);
      for(;;){
       switch(t$0[0]){
         case 0:
          var a = t$0[1], _gH_ = caml_call1(a, env$1); break;
         case 1:
          throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
         case 2:
          var f = t$0[1], t$1 = caml_call1(f, 0), t$0 = t$1; continue;
         case 3:
          var _gH_ = caml_call1(Base[244], cst_BUG_asked_for_final_value_);
          break;
         default: var t$2 = t$0[1], t$0 = t$2; continue;
       }
       var
        match$3 =
          [0,
           [0,
            -1061020774,
            caml_call2(mem, env$1, key_internal_validate_parsing)],
           _gH_,
           _gG_];
       break;
      }
     }
     var
      parsed_normalized_args = match$3[3],
      main = match$3[2],
      is_using_validate_parsing = match$3[1];
     normalized_path[1] = [0, path];
     normalized_args[1] = [0, parsed_normalized_args];
     return [0, is_using_validate_parsing, caml_call1(main, 15369289)];
    }
    var match = caml_call1(Base_Result[41], _gx_);
    if(0 !== match[0]){
     var exn = match[1];
     return caml_call4
             (on_failure, exn, for_completion, path, verbose_on_parse_error);
    }
    var _gy_ = match[1];
    if(_gy_[1][2]){caml_call1(when_parsing_succeeds, 0); return exit(0);}
    var thunk = _gy_[2];
    caml_call1(when_parsing_succeeds, 0);
    return caml_call1(thunk, -903816947);
   }
   function wrap_value(v, param){return return_no_arg(v);}
   function apply$1(f, x){
    function _gp_(param){
     var _gu_ = caml_call1(f[3], 0), _gv_ = caml_call1(x[3], 0);
     return caml_call2(Base[222], _gv_, _gu_);
    }
    function _gq_(param){
     var _gt_ = [0, caml_call1(x[2], 0), 0];
     return concat$0([0, caml_call1(f[2], 0), _gt_]);
    }
    return [0,
            function(param){
             var _gr_ = caml_call1(x[1], 0), _gs_ = caml_call1(f[1], 0);
             return symbol$0
                     (symbol$0
                       (return$1
                         (function(f, x, param){
                           var
                            f_outcome = caml_call1(f, 0),
                            x_outcome = caml_call1(x, 0);
                           return caml_call2(apply$0, f_outcome, x_outcome);
                          }),
                        _gs_),
                      _gr_);
            },
            _gq_,
            _gp_];
   }
   function ___(param){return 0;}
   function _$_(param){return zero;}
   var
    empty_spec =
      [0,
       function(param){
        return return$1
                (function(param){
                  return return_no_arg(function(_go_){return _go_;});
                 });
       },
       _$_,
       ___];
   function map_outcome(x, f){
    var _gl_ = x[3], _gm_ = x[2];
    return [0,
            function(param){
             function _gn_(x, param){
              var x_outcome = caml_call1(x, 0);
              return caml_call1(f, x_outcome);
             }
             return symbol_map(caml_call1(x[1], 0), _gn_);
            },
            _gm_,
            _gl_];
   }
   function map$2(x, f){
    return map_outcome(x, function(_gk_){return caml_call2(map$0, _gk_, f);});
   }
   function lookup(key){
    function _gi_(param){return 0;}
    function _gj_(param){return zero;}
    return [0,
            function(param){
             return symbol_map
                     (from_env
                       (function(env){return caml_call2(find_exn, env, key);}),
                      wrap_value);
            },
            _gj_,
            _gi_];
   }
   var
    path = lookup(path_key),
    args = lookup(args_key),
    help$0 = lookup(help_key);
   function _aa_(param){return 0;}
   function _ab_(param){return zero;}
   var
    env =
      [0,
       function(param){
        return symbol_map(from_env(function(env){return env;}), wrap_value);
       },
       _ab_,
       _aa_],
    string$0 = include$0[1],
    int$1 = include$0[2],
    char$1 = include$0[3],
    float$1 = include$0[4],
    bool$0 = include$0[5],
    sexp$0 = include$0[6],
    sexp_conv$0 = include$0[7];
   function anon(spec){
    caml_call1(invariant, spec[2]);
    function _gf_(param){return 0;}
    function _gg_(param){return spec[2];}
    return [0,
            function(param){
             function _gh_(outcome, param){return outcome;}
             return symbol_map(spec[1], _gh_);
            },
            _gg_,
            _gf_];
   }
   function escape_anon(final_anon){
    var t = t2(final_anon, sequence$0(symbol$2(cst_ARG, string$0)));
    return anon([0, [4, t[1]], t[2]]);
   }
   function flag(opt, full_flag_required, name){
    return function(mode){
     return function(doc){
      var aliases_excluded_from_help = 0;
      if(opt) var sth = opt[1], aliases = sth; else var aliases = 0;
      function normalize(flag){return normalize$0(1, flag);}
      var
       name$0 = normalize(name),
       aliases$0 = caml_call2(Base_List[53], aliases, normalize),
       match = caml_call1(mode, name$0),
       extra_doc = match[4],
       num_occurrences = match[3],
       read = match[2],
       action = match[1],
       check_available =
         num_occurrences[1]
          ? function(env){caml_call1(read, env); return 0;}
          : function(_ge_){return 0;},
       name_matching =
         caml_call1(Base_Option[53], full_flag_required)
          ? -461087063
          : -481604174;
      function _f9_(param){
       var _gb_ = caml_obj_tag(extra_doc);
       a:
       {
        var _ga_ = 0;
        if(250 === _gb_)
         var match = extra_doc[1];
        else{
         if(246 !== _gb_ && 244 !== _gb_){var match = extra_doc; break a;}
         var match = caml_call1(CamlinternalLazy[2], extra_doc);
        }
       }
       if(match)
        var
         extra_doc$0 = match[1],
         _gc_ =
           [0,
            doc,
            [0,
             caml_call1(Ppx_string_runtime[1][2], cst$12),
             [0, extra_doc$0, 0]]],
         _gd_ = caml_call1(Ppx_string_runtime[1][4], _gc_);
       else
        var _gd_ = doc;
       return [0,
               [0,
                name$0,
                aliases$0,
                aliases_excluded_from_help,
                action,
                _gd_,
                num_occurrences,
                check_available,
                name_matching],
               _ga_];
      }
      function _f__(param){return zero;}
      return [0,
              function(param){
               function _f$_(v, param){return v;}
               return symbol_map
                       (from_env(function(env){return caml_call1(read, env);}),
                        _f$_);
              },
              _f__,
              _f9_];};};
   }
   function flag_optional_with_default_doc
   (aliases,
    full_flag_required,
    name,
    arg_type,
    sexp_of_default,
    default$0,
    doc){
    var default_sexp = caml_call1(sexp_of_default, default$0);
    a:
    {
     if
      (0 === default_sexp[0]
       && ! caml_string_notequal(default_sexp[1], cst$29)){var doc$0 = doc; break a;}
     var
      _f6_ =
        [0,
         [2,
          0,
          [11,
           cst_default,
           [24,
            _ad_,
            function(param, custom_printf_035){
             return caml_call1(Base[85][16], custom_printf_035);
            },
            _ac_]]],
         cst_s_default_Sexp],
      doc$0 = caml_call3(Command_Import[7], _f6_, doc, default_sexp);
    }
    function _f7_(_f8_){
     return optional_with_default(default$0, arg_type, _f8_);
    }
    return caml_call1(flag(aliases, full_flag_required, name)(_f7_), doc$0);
   }
   function return$3(v){
    function _f4_(param){return 0;}
    function _f5_(param){return zero;}
    return [0,
            function(param){
             return return$1(function(param){return return_no_arg(v);});
            },
            _f5_,
            _f4_];
   }
   function optional_to_required(t){
    var _f1_ = t[3], _f2_ = t[2];
    return [0,
            function(param){
             function _f3_(f, param){
              var outcome = caml_call1(f, 0);
              return introduce_missing_required_fla
                      (caml_call2
                        (map$0,
                         outcome,
                         function(param){
                          if(! param)
                           return [1,
                                   [0,
                                    696341824,
                                    caml_call1(Base_Error[14], cst_optional_to_required_got_a)]];
                          var v = param[1];
                          return [0, v];
                         }));
             }
             return symbol_map(caml_call1(t[1], 0), _f3_);
            },
            _f2_,
            _f1_];
   }
   var
    map$3 = [0, -198771759, map$2],
    include$1 = caml_call1(Base_Applicative[7], [0, return$3, apply$1, map$3]),
    return$4 = include$1[1],
    map$4 = include$1[2],
    both = include$1[3],
    symbol$3 = include$1[4],
    symbol$4 = include$1[5],
    symbol$5 = include$1[6],
    symbol_map$1 = include$1[7],
    apply$2 = include$1[8],
    map2 = include$1[9],
    map3 = include$1[10],
    all = include$1[11],
    all_unit = include$1[12],
    Applicative_infix = include$1[13];
   function arg_names(t){
    var
     flags = create$0(caml_call1(t[3], 0)),
     flag_names = caml_call1(Base_Map[73], flags),
     anon_names = names(caml_call1(t[2], 0));
    return caml_call1(Base_List[11], [0, flag_names, [0, anon_names, 0]]);
   }
   function compare$0(a_036, b_037){
    if(a_036 === b_037) return 0;
    var _fV_ = b_037[1], _fW_ = a_036[1];
    function _fX_(a_038, b_039){return caml_call2(Base[195], a_038, b_039);}
    var n = caml_call3(Base[159], _fX_, _fW_, _fV_);
    if(0 !== n) return n;
    var _fY_ = b_037[2], _fZ_ = a_036[2];
    function _f0_(a_040, b_041){return caml_call2(Base[195], a_040, b_041);}
    return caml_call3(Base[159], _f0_, _fZ_, _fY_);
   }
   function sexp_of_t(t){
    var x_042 = t[1];
    return caml_call2(Base[165], Base[202], x_042);
   }
   var
    T = [0, compare$0, sexp_of_t],
    sexp_of_t$0 = T[2],
    include$2 = caml_call1(Base_Comparator[7], T),
    comparator = include$2[1];
   function create_exn(t){
    var flags = create$0(caml_call1(t[3], 0));
    function _fP_(param){
     var flag = param[2], name = param[1];
     return flag[6][1] ? [0, name] : 0;
    }
    var
     _fQ_ = caml_call2(Base_Map[75], 0, flags),
     required_args = caml_call2(Base_List[13], _fQ_, _fP_),
     names = arg_names(t);
    function _fR_(s){return caml_call4(Base_String[70], 0, 0, s, 44);}
    var names_with_commas = caml_call2(Base_List[12], names, _fR_);
    if(1 - caml_call1(Base_List[18], names_with_commas)){
     var
      _fS_ = function(x_043){return caml_call2(Base[165], Base[202], x_043);},
      _fT_ =
        caml_call5
         (Base_Error[19],
          _ae_,
          0,
          cst_For_simplicity_Command_Spe,
          names_with_commas,
          _fS_);
     caml_call1(Base_Error[31], _fT_);
    }
    if(names) return [0, names, required_args];
    var
     _fU_ = caml_call1(Sexplib0_Sexp_conv[7], cst_choose_one_expects_choices);
    return caml_call1(Base[246], _fU_);
   }
   function to_string$0(t){
    return t[2]
            ? caml_call2(Base_String[68], _af_, t[2])
            : caml_call2(Base_String[68], _ag_, t[1]);
   }
   function list_to_string(ts){
    var _fO_ = caml_call2(Base_List[53], ts, to_string$0);
    return caml_call2(Base_String[68], _ai_, _fO_);
   }
   var If_nothing_chosen = [0];
   function choose_one_non_optional(opt, ts, if_nothing_chosen){
    if(opt) var sth = opt[1], new_behavior = sth; else var new_behavior = 1;
    function _fb_(t){
     if(new_behavior)
      var
       name_of_the_group = create_exn(t),
       _fA_ =
         function(param){
          function _fD_(flag_internal){
           var
            except = flag_internal[1],
            _fG_ = flag_internal[8],
            _fH_ = flag_internal[7],
            _fI_ = [0, 0, flag_internal[6][2]],
            _fJ_ = flag_internal[5],
            _fK_ = flag_internal[4],
            _fL_ = flag_internal[3],
            _fM_ = flag_internal[2];
           function _fF_(x){
            return 1 - caml_call2(Base_String[134], except, x);
           }
           var
            l = caml_call2(Base_List[12], name_of_the_group[2], _fF_),
            match = l ? [0, caml_call2(Base_String[68], _ah_, l)] : 0;
           if(match)
            var
             group = match[1],
             _fN_ = caml_call2(Command_Import[7], _aj_, group);
           else
            var _fN_ = cst$13;
           return [0,
                   except,
                   _fM_,
                   _fL_,
                   _fK_,
                   caml_call3(Command_Import[7], _ak_, _fJ_, _fN_),
                   _fI_,
                   _fH_,
                   _fG_];
          }
          var _fE_ = caml_call1(t[3], 0);
          return caml_call2(Base_List[53], _fE_, _fD_);
         },
       _fB_ =
         function(param){
          var anon = caml_call1(t[2], 0);
          if(typeof anon === "number") return 0;
          switch(anon[0]){
            case 1:
             var t$0 = anon[1]; return [1, t$0];
            case 2:
             var t$1 = anon[1]; return [2, t$1];
            default: return [2, anon];
          }
         },
       _fC_ = [0, t[1], _fB_, _fA_];
     else
      var _fC_ = t;
     return [0, create_exn(t), _fC_];
    }
    var
     _fc_ = caml_call2(Base_List[53], ts, _fb_),
     match = caml_call2(Base_Map[8], [0, comparator], _fc_);
    if(17724 <= match[1]){
     var
      ts$0 = match[2],
      _fd_ =
        function(value_list){
         var arg_counter = caml_call1(Base_List[45], value_list);
         function more_than_one_error(passed){
          var
           _fx_ = 0,
           _fy_ = caml_call2(Base_List[53], passed, Base[242]),
           _fz_ = 0;
          return caml_call2
                  (die
                    ([0,
                      [11,
                       cst_Cannot_pass_more_than_one_$0,
                       [24,
                        _al_,
                        function(param, custom_printf_044){
                         return list_to_string(custom_printf_044);
                        },
                        _fz_]],
                      cst_Cannot_pass_more_than_one_]),
                   _fy_,
                   _fx_);
         }
         function _fn_(param){
          var match = param[2], name = param[1];
          if(0 === match[0]){
           var value = match[1];
           return [0, [0, name, value]];
          }
          var err = match[1];
          return [1, [0, name, err]];
         }
         var
          match = caml_call2(Base_List[16], value_list, _fn_),
          error_list = match[2],
          success_list = match[1];
         if(success_list){
          var _fo_ = success_list[1];
          if(success_list[2]) return more_than_one_error(success_list);
          var value = _fo_[2];
          if(1 < arg_counter) return more_than_one_error(value_list);
          var
           _fp_ =
             typeof if_nothing_chosen === "number"
              ? if_nothing_chosen ? [0, value] : value
              : value;
          return [0, _fp_];
         }
         if(error_list && ! error_list[2]){
          var
           _ft_ = error_list[1],
           err = _ft_[2][2],
           name = _ft_[1],
           _fu_ = caml_call1(Base_Error[12], err),
           _fv_ = to_string$0(name),
           _fw_ = caml_call3(Command_Import[7], _ao_, _fv_, _fu_);
          return [1, [0, 696341824, caml_call1(Base_Error[14], _fw_)]];
         }
         if(typeof if_nothing_chosen !== "number"){
          var value$0 = if_nothing_chosen[1];
          return [0, value$0];
         }
         if(if_nothing_chosen) return _am_;
         var
          _fq_ = 0,
          _fr_ = caml_call1(Base_Map[73], ts$0),
          _fs_ = 0,
          fmt =
            [0,
             [11,
              cst_Must_pass_one_of_these,
              [24,
               _an_,
               function(param, custom_printf_045){
                return list_to_string(custom_printf_045);
               },
               _fs_]],
             cst_Must_pass_one_of_these_Cho];
         function _fm_(msg, param){
          return [1, [0, 696341824, caml_call1(Base_Error[14], msg)]];
         }
         return caml_call2
                 (caml_call2(Command_Import[9], _fm_, fmt), _fr_, _fq_);
        },
      _fe_ =
        function(name, t, acc){
         function _fk_(acc, param){
          var has_arg = param[2], value = param[1];
          return has_arg ? [0, [0, name, value], acc] : acc;
         }
         var _fi_ = t[3], _fj_ = t[2];
         return caml_call3
                 (map2,
                  acc,
                  [0,
                   function(param){
                    function _fl_(f, param){
                     var outcome = caml_call1(f, 0);
                     return [0, [0, outcome], outcome[2]];
                    }
                    return symbol_map(caml_call1(t[1], 0), _fl_);
                   },
                   _fj_,
                   _fi_],
                  _fk_);
        },
      _ff_ = caml_call1(return$4, 0),
      t = caml_call2(map$4, caml_call3(Base_Map[55], ts$0, _ff_, _fe_), _fd_),
      _e$_ = t[3],
      _fa_ = t[2];
     return [0,
             function(param){
              function _fh_(f, param){
               var outcome = caml_call1(f, 0);
               return introduce_missing_required_fla(outcome);
              }
              return symbol_map(caml_call1(t[1], 0), _fh_);
             },
             _fa_,
             _e$_];
    }
    var
     name = match[2],
     _fg_ =
       caml_call5
        (Base_Error[19],
         _ap_,
         0,
         cst_Command_Spec_choose_one_ca,
         name,
         sexp_of_t$0);
    return caml_call1(Base_Error[31], _fg_);
   }
   function choose_one(ts, if_nothing_chosen){
    function _e__(t){
     return map_outcome
             (t,
              function(param){
               var has_arg = param[2], result = param[1];
               if(0 !== result[0]) return [0, result, has_arg];
               var match = result[1];
               if(! match)
                return [0,
                        [1,
                         [0,
                          696341824,
                          caml_call1(Base_Error[14], cst_missing_required_flag)]],
                        0];
               var value = match[1];
               return [0, [0, value], 1];
              });
    }
    return choose_one_non_optional
            (_aq_, caml_call2(Base_List[53], ts, _e__), if_nothing_chosen);
   }
   function choose_one_non_optional$0(lst, if_nothing_chosen){
    return choose_one_non_optional(0, lst, if_nothing_chosen);
   }
   function and_arg_names(t){
    return caml_call2
            (map$4, t, function(value){return [0, value, arg_names(t)];});
   }
   function and_arg_name(t){
    var names = arg_names(t);
    if(names && ! names[2]){
     var name = names[1];
     return caml_call2(map$4, t, function(value){return [0, value, name];});
    }
    var
     _e8_ = [0, caml_call2(Base[165], Base[202], names), 0],
     _e9_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_and_arg_name_expects_exact),
         _e8_]];
    return caml_call1(Base[246], _e9_);
   }
   function parse$1(param, args){
    var
     flags = param[3],
     f = param[1],
     cmdline = of_list(args),
     result = [0, 0];
    function _eZ_(exn, param, _e7_, _e6_){
     result[1] = [0, [1, caml_call2(Base_Error[27], 0, exn)]];
     return 0;
    }
    function _e0_(_e5_){return _e5_;}
    var _e1_ = Univ_map[4];
    function _e2_(param){
     function _e3_(params, param, _e4_){
      var outcome = caml_call1(params, 0), match = outcome[1];
      if(0 === match[0]){var x = match[1]; result[1] = [0, [0, x]]; return 0;}
      var err = match[1][2];
      result[1] = [0, [1, err]];
      return 0;
     }
     return symbol_map(caml_call1(f, 0), _e3_);
    }
    run
     ([0, cst$14, 0, create$0(caml_call1(flags, 0)), _e2_, zero],
      _e1_,
      _e0_,
      empty$0,
      cmdline,
      _ar_,
      cst_No_help_for_parsing,
      _eZ_);
    return caml_call4(Base_Option[31], _as_, 0, 0, result[1]);
   }
   function symbol$6(t1, t2){
    return caml_call3
            (map2,
             t1,
             t2,
             function(f1, f2, x){return caml_call1(f2, caml_call1(f1, x));});
   }
   function symbol$7(t1, p2){
    return caml_call3
            (map2,
             t1,
             p2,
             function(f1, p2, x){return caml_call1(caml_call1(f1, x), p2);});
   }
   function symbol$8(t1, p2){
    return caml_call3
            (map2,
             p2,
             t1,
             function(p2, f1, x){return caml_call1(f1, caml_call1(x, p2));});
   }
   function step(f){return caml_call1(return$4, f);}
   function const$0(x){return caml_call1(return$4, x);}
   function wrap(f, t){
    return caml_call2
            (map$4, t, function(run, main){return caml_call2(f, run, main);});
   }
   function of_param(p){
    return caml_call2(map$4, p, function(f, k){return caml_call1(k, f);});
   }
   function to_param(t, m){
    return caml_call2(map$4, t, function(f){return caml_call1(f, m);});
   }
   var
    string$1 = include$0[1],
    int$2 = include$0[2],
    char$2 = include$0[3],
    float$2 = include$0[4],
    bool$1 = include$0[5],
    sexp$1 = include$0[6],
    sexp_conv$1 = include$0[7],
    map$5 = [0, -198771759, map$4],
    include$3 = caml_call1(Base_Applicative[7], [0, return$4, apply$2, map$5]),
    return$5 = include$3[1],
    map$6 = include$3[2],
    both$0 = include$3[3],
    symbol$9 = include$3[4],
    symbol$10 = include$3[5],
    symbol$11 = include$3[6],
    symbol_map$2 = include$3[7],
    apply$3 = include$3[8],
    map2$0 = include$3[9],
    map3$0 = include$3[10],
    all$0 = include$3[11],
    all_unit$0 = include$3[12],
    Applicative_infix$0 = include$3[13];
   function flags_of_args_exn(args){
    function _eP_(acc, param){
     var doc = param[3], spec = param[2], name = param[1];
     function gen(f, flag_type){
      var _eY_ = caml_call1(flag(0, 0, name)(flag_type), doc);
      return symbol$7(step(function(m, x){caml_call1(f, x); return m;}), _eY_);
     }
     function call(f, arg_type){
      function _eW_(_eX_){return optional(arg_type, _eX_);}
      return gen(function(x){return caml_call2(Base_Option[37], x, f);}, _eW_);
     }
     function set(r, arg_type){
      return call(function(x){r[1] = x; return 0;}, arg_type);
     }
     function set_bool(r, b){
      return gen
              (function(passed){
                var _eV_ = passed ? (r[1] = b, 0) : passed;
                return _eV_;
               },
               no_arg);
     }
     switch(spec[0]){
       case 0:
        var
         f = spec[1],
         _eQ_ =
           gen
            (function(passed){return passed ? caml_call1(f, 0) : passed;},
             no_arg);
        break;
       case 1:
        var f$0 = spec[1], _eQ_ = call(f$0, bool$1); break;
       case 2:
        var r = spec[1], _eQ_ = set_bool(r, 1); break;
       case 3:
        var r$0 = spec[1], _eQ_ = set_bool(r$0, 0); break;
       case 4:
        var f$1 = spec[1], _eQ_ = call(f$1, string$1); break;
       case 5:
        var r$1 = spec[1], _eQ_ = set(r$1, string$1); break;
       case 6:
        var f$2 = spec[1], _eQ_ = call(f$2, int$2); break;
       case 7:
        var r$2 = spec[1], _eQ_ = set(r$2, int$2); break;
       case 8:
        var f$3 = spec[1], _eQ_ = call(f$3, float$2); break;
       case 9:
        var r$3 = spec[1], _eQ_ = set(r$3, float$2); break;
       case 10:
        var _eQ_ = caml_call1(Base[244], cst_Arg_Tuple_is_not_supported);
        break;
       case 11:
        var
         f$4 = spec[2],
         syms = spec[1],
         _eR_ = function(sym){return [0, sym, sym];},
         arg_type =
           of_alist_exn
            (0, 0, _at_, 0, 0, caml_call2(Base_List[53], syms, _eR_)),
         _eQ_ = call(f$4, arg_type);
        break;
       case 12:
        var
         f$5 = spec[1],
         _eQ_ =
           gen
            (function(x){
              var _eS_ = Base_List[19];
              function _eT_(_eU_){return caml_call2(_eS_, _eU_, f$5);}
              return caml_call2(Base_Option[37], x, _eT_);
             },
             escape);
        break;
       case 13:
        var _eQ_ = caml_call1(Base[244], cst_Arg_Rest_all_is_not_suppor);
        break;
       default:
        var _eQ_ = caml_call1(Base[244], cst_Arg_Expand_is_not_supporte);
     }
     return symbol$6(acc, _eQ_);
    }
    return caml_call3(Base_List[20], args, empty_spec, _eP_);
   }
   var Deprecated = [0, no_arg$0, escape$0, ad_hoc];
   function shape$0(subcommand_to_shape, t){
    var _eJ_ = Base_List[137][9];
    function _eK_(_eO_){return caml_call2(_eJ_, _eO_, subcommand_to_shape);}
    var _eL_ = caml_call2(Base_Lazy[15], t[3], _eK_);
    function _eM_(readme){return caml_call1(readme, 0);}
    var _eN_ = caml_call2(Base_Option[24], t[2], _eM_);
    return [0, t[1], _eN_, _eL_];
   }
   var abs_path = Command_Shape[14][2], comp_cword = 2;
   function shape$1(t){
    var _eE_ = t[5], _eF_ = t[4], _eG_ = t[3];
    function _eH_(readme){return caml_call1(readme, 0);}
    var _eI_ = caml_call2(Base_Option[24], t[2], _eH_);
    return [0, t[1], _eI_, _eG_, _eF_, _eE_];
   }
   function sexpable_shape(param){
    switch(param[0]){
      case 0:
       var base = param[1]; return [0, shape(base)];
      case 1:
       var group = param[1]; return [1, shape$0(sexpable_shape, group)];
      case 2:
       var exec = param[1]; return [2, shape$1(exec)];
      default:
       var thunk = param[1];
       return [3, caml_call2(Base_Lazy[15], thunk, sexpable_shape)];
    }
   }
   function extend_exn(mem, add, map, key_type, key, data){
    if(caml_call2(mem, map, key)){
     var _eD_ = caml_call1(Command_Shape[14][1][1], key_type);
     caml_call4(Command_Import[8], _au_, _eD_, key, 0);
    }
    return caml_call3(add, map, key, data);
   }
   function extend_map_exn(map, key_type, key, data){
    return extend_exn(Base_Map[45], Base_Map[34], map, key_type, key, data);
   }
   function extend_alist_exn(alist, key_type, key, data){
    function _eC_(alist, key, data){
     return caml_call4(Base_List[137][4], alist, Base_String[134], key, data);
    }
    return extend_exn
            (function(alist, key){
              return caml_call3
                      (Base_List[137][7], alist, Base_String[134], key);
             },
             _eC_,
             alist,
             key_type,
             key,
             data);
   }
   function add
   (base, name, aliases, aliases_excluded_from_help, text, text_summary){
    var flags = base[3], _ey_ = -481604174;
    function _ez_(_eB_){return 0;}
    var
     _eA_ = caml_call2(Command_Import[7], _av_, text_summary),
     flags$0 =
       extend_map_exn
        (flags,
         1,
         name,
         [0,
          name,
          aliases,
          aliases_excluded_from_help,
          [1, function(env){return caml_call1(text, env);}],
          _eA_,
          at_most_once,
          _ez_,
          _ey_]);
    return [0, base[1], base[2], flags$0, base[4], base[5]];
   }
   function basic(summary, readme, param){
    var
     flags = param[3],
     usage = param[2],
     f = param[1],
     flags$0 = caml_call1(flags, 0),
     usage$0 = caml_call1(usage, 0);
    function anons(param){
     function _ew_(params, param){
      var outcome = caml_call1(params, 0), match = outcome[1];
      if(0 === match[0]){
       var thunk = match[1];
       return function(param){return caml_call1(thunk, 0);};
      }
      var err = match[1][2], _ex_ = caml_call1(Base_Error[12], err);
      return caml_call2(die(_aw_), _ex_, 0);
     }
     return symbol_map(caml_call1(f, 0), _ew_);
    }
    var
     flags$1 = create$0(flags$0),
     base = [0, summary, readme, flags$1, anons, usage$0],
     base$0 =
       add
        (base,
         cst_help$2,
         _ay_,
         _ax_,
         function(env){
          var
           _eu_ = caml_call2(find_exn, env, help_key),
           _ev_ = caml_obj_tag(_eu_);
          if(250 === _ev_) return _eu_[1];
          if(246 !== _ev_ && 244 !== _ev_) return _eu_;
          return caml_call1(CamlinternalLazy[2], _eu_);
         },
         cst_this_help_text);
    return [0, base$0];
   }
   function basic_spec(summary, readme, spec, main){
    return basic(summary, readme, to_param(spec, main));
   }
   var subs_key = key_create(cst_subcommands);
   function lazy_group
   (summary, readme, preserve_subcommand_order, body, alist){
    function _es_(alist){
     function _et_(param){
      var t = param[2], name = param[1];
      return [0, normalize$0(0, name), t];
     }
     var
      alist$0 = caml_call2(Base_List[53], alist, _et_),
      match = caml_call2(Base_Map[8], [0, Base_String[59]], alist$0);
     if(17724 <= match[1]){
      var map = match[2];
      return preserve_subcommand_order
              ? alist$0
              : caml_call2(Base_Map[75], 0, map);
     }
     var name = match[2];
     return caml_call3(Command_Import[8], _az_, name, 0);
    }
    var subcommands = caml_call2(Base_Lazy[15], alist, _es_);
    return [1, [0, summary, readme, subcommands, body]];
   }
   function group(summary, readme, preserve_subcommand_order, body, alist){
    function _eq_(f, param){
     var _er_ = caml_call1(f, 0);
     return caml_call2(Base_String[109], 0, _er_);
    }
    var readme$0 = caml_call2(Base_Option[24], readme, _eq_);
    return lazy_group
            (summary,
             readme$0,
             preserve_subcommand_order,
             body,
             caml_call1(Base_Lazy[24], alist));
   }
   function exec(summary, readme, opt, env, path_to_exe, param){
    if(opt)
     var sth = opt[1], child_subcommand = sth;
    else
     var child_subcommand = 0;
    var
     _ep_ =
       -310138871 <= path_to_exe[1]
        ? Stdlib_Sys[1]
        : caml_check_bound(caml_sys_argv(0), 0)[1],
     working_dir = caml_call1(Filename_base[38], _ep_);
    if(491227799 <= path_to_exe[1])
     var
      p = path_to_exe[2],
      p$0 =
        caml_call1(Filename_base[30], p)
         ? p
         : caml_call1(Base[244], cst_Path_passed_to_Absolute_mu),
      path_to_exe$0 = p$0;
    else
     var
      p$1 = path_to_exe[2],
      p$2 =
        caml_call1(Filename_base[29], p$1)
         ? p$1
         : caml_call1(Base[244], cst_Path_passed_to_Relative_to),
      path_to_exe$0 = p$2;
    return [2,
            [0,
             summary,
             readme,
             working_dir,
             path_to_exe$0,
             child_subcommand,
             env]];
   }
   function of_lazy$0(thunk){return [3, thunk];}
   function proxy_of_sexpable
   (sexpable, working_dir, path_to_exe, child_subcommand, path_to_subcommand){
    var
     kind =
       kind_of_sexpable
        (sexpable,
         working_dir,
         path_to_exe,
         child_subcommand,
         path_to_subcommand);
    return [0,
            working_dir,
            path_to_exe,
            path_to_subcommand,
            child_subcommand,
            kind];
   }
   function kind_of_sexpable
   (sexpable, working_dir, path_to_exe, child_subcommand, path_to_subcommand){
    switch(sexpable[0]){
      case 0:
       var b = sexpable[1]; return [0, b];
      case 1:
       var
        g = sexpable[1],
        _ej_ = Base_List[53],
        _ek_ =
          function(param){
           var
            sexpable = param[2],
            str = param[1],
            path_to_subcommand$0 =
              caml_call2(Base[222], path_to_subcommand, [0, str, 0]),
            proxy =
              proxy_of_sexpable
               (sexpable,
                working_dir,
                path_to_exe,
                child_subcommand,
                path_to_subcommand$0);
           return [0, str, proxy];
          },
        _el_ = function(_eo_){return caml_call2(_ej_, _eo_, _ek_);},
        _em_ = caml_call2(Base_Lazy[15], g[3], _el_);
       return [1, [0, g[1], g[2], _em_]];
      case 2:
       var e = sexpable[1]; return [2, e];
      default:
       var
        l = sexpable[1],
        _en_ =
          function(sexpable){
           return kind_of_sexpable
                   (sexpable,
                    working_dir,
                    path_to_exe,
                    child_subcommand,
                    path_to_subcommand);
          };
       return [3, caml_call2(Base_Lazy[15], l, _en_)];
    }
   }
   function Version_info(Version_util){
    function print_version(version){
     var _eh_ = caml_obj_tag(version);
     a:
     if(250 === _eh_)
      var _ei_ = version[1];
     else{
      if(246 !== _eh_ && 244 !== _eh_){var _ei_ = version; break a;}
      var _ei_ = caml_call1(CamlinternalLazy[2], version);
     }
     return caml_call1(Command_Import[5], _ei_);
    }
    function print_build_info(build_info){
     var _ef_ = caml_obj_tag(build_info);
     a:
     if(250 === _ef_)
      var _eg_ = build_info[1];
     else{
      if(246 !== _ef_ && 244 !== _ef_){var _eg_ = build_info; break a;}
      var _eg_ = caml_call1(CamlinternalLazy[2], build_info);
     }
     return caml_call1(Command_Import[5], _eg_);
    }
    function command(version, build_info){
     var
      _ed_ =
        caml_call1
         (flag(0, 0, cst_build_info)(no_arg), cst_print_build_info_for_this_),
      _ee_ =
        caml_call1
         (flag(0, 0, cst_version)(no_arg), cst_print_the_version_of_this_);
     return basic
             (cst_print_version_information,
              0,
              caml_call2
               (symbol$3,
                caml_call2
                 (symbol$3,
                  caml_call1
                   (return$4,
                    function(version_flag, build_info_flag){
                     if(build_info_flag)
                      print_build_info(build_info);
                     else if(version_flag)
                      print_version(version);
                     else{print_build_info(build_info); print_version(version);}
                     return exit(0);
                    }),
                  _ee_),
                _ed_));
    }
    function add$0(version, build_info, unversioned){
     switch(unversioned[0]){
       case 0:
        var
         base = unversioned[1],
         base$0 =
           add
            (base,
             cst_version$0,
             0,
             _aA_,
             function(param){
              var _ec_ = caml_obj_tag(version);
              if(250 === _ec_) return version[1];
              if(246 !== _ec_ && 244 !== _ec_) return version;
              return caml_call1(CamlinternalLazy[2], version);
             },
             cst_the_version_of_this_build),
         base$1 =
           add
            (base$0,
             cst_build_info$0,
             0,
             _aB_,
             function(param){
              var _eb_ = caml_obj_tag(build_info);
              if(250 === _eb_) return build_info[1];
              if(246 !== _eb_ && 244 !== _eb_) return build_info;
              return caml_call1(CamlinternalLazy[2], build_info);
             },
             cst_info_about_this_build);
        return [0, base$1];
       case 1:
        var
         group = unversioned[1],
         _d9_ =
           function(subcommands){
            return extend_alist_exn
                    (subcommands,
                     0,
                     cst_version$1,
                     command(version, build_info));
           },
         subcommands = caml_call2(Base_Lazy[15], group[3], _d9_);
        return [1, [0, group[1], group[2], subcommands, group[4]]];
       case 2:
        var exec = unversioned[1]; return [2, exec];
       default:
        var thunk = unversioned[1];
        return [3,
                [246,
                 function(_d__){
                  var _d$_ = caml_obj_tag(thunk);
                  a:
                  if(250 === _d$_)
                   var _ea_ = thunk[1];
                  else{
                   if(246 !== _d$_ && 244 !== _d$_){var _ea_ = thunk; break a;}
                   var _ea_ = caml_call1(CamlinternalLazy[2], thunk);
                  }
                  return add$0(version, build_info, _ea_);
                 }]];
     }
    }
    function normalize_version_lines(lines){
     var _d8_ = caml_call2(Base_List[83], lines, Base_String[51]);
     return caml_call2(Base_String[68], _aC_, _d8_);
    }
    var
     default_version =
       [246, function(_d7_){return normalize_version_lines(Version_util[2]);}],
     default_build_info =
       [246,
        function(_d6_){
         return caml_call1(Version_util[3], Version_util[1][1]);
        }];
    return [0,
            print_version,
            print_build_info,
            ,
            add$0,
            normalize_version_lines,
            default_version,
            default_build_info];
   }
   function _aD_(param){
    function reprint_build_info(to_sexp){
     var _d5_ = caml_call1(to_sexp, 0);
     return caml_call1(Base[85][16], _d5_);
    }
    var
     sexp_of_t = Base[220],
     Time = [0, sexp_of_t],
     Version_info$0 =
       Version_info([0, Time, version_list, reprint_build_info]);
    if(typeof Ppx_inline_test_lib[3] !== "number"){
     var
      Ppx_expect_test_block$0 =
        caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
      _dY_ =
        function(param){
         Version_info$0[1].call(null, Version_info$0[6]);
         var _d4_ = caml_call1(Ppx_expect_runtime_Types[4][1], 0);
         return caml_call1(Ppx_expect_test_block$0[2], _d4_);
        },
      _dZ_ =
        caml_call3
         (Ppx_expect_runtime_Test_node[1][1],
          [0, Ppx_expect_runtime_Types[1][1]],
          _aL_,
          _aK_),
      _d0_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 0), _dZ_], 0],
      _d1_ = caml_call1(Ppx_expect_runtime_Types[4][1], 2),
      _d2_ = caml_call1(Ppx_expect_runtime_Types[4][1], 1);
     caml_call14
      (Ppx_expect_test_block$0[3],
       cst_command_src_command_ml$0,
       2633,
       _aP_,
       _aO_,
       _aN_,
       [0, Ppx_expect_runtime_Types[1][1]],
       0,
       _d2_,
       _d1_,
       _aM_,
       0,
       Inline_test_config,
       _d0_,
       _dY_);
    }
    if(typeof Ppx_inline_test_lib[3] !== "number"){
     var
      Ppx_expect_test_block =
        caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
      _dT_ =
        function(param){
         Version_info$0[2].call(null, cst_some_build_info);
         var _d3_ = caml_call1(Ppx_expect_runtime_Types[4][1], 3);
         return caml_call1(Ppx_expect_test_block[2], _d3_);
        },
      _dU_ =
        caml_call3
         (Ppx_expect_runtime_Test_node[1][1],
          [0, Ppx_expect_runtime_Types[1][1]],
          _aF_,
          _aE_),
      _dV_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 3), _dU_], 0],
      _dW_ = caml_call1(Ppx_expect_runtime_Types[4][1], 5),
      _dX_ = caml_call1(Ppx_expect_runtime_Types[4][1], 4);
     caml_call14
      (Ppx_expect_test_block[3],
       cst_command_src_command_ml,
       2642,
       _aJ_,
       _aI_,
       _aH_,
       [0, Ppx_expect_runtime_Types[1][1]],
       0,
       _dX_,
       _dW_,
       _aG_,
       0,
       Inline_test_config,
       _dV_,
       _dT_);
    }
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib[10],
     Inline_test_config,
     cst_Version_info,
     0,
     cst_command_src_command_ml$1,
     2622,
     0,
     752,
     _aD_);
   function summary(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var x = param$0[1]; return x[1];
       case 1:
        var x$0 = param$0[1]; return x$0[1];
       case 2:
        var x$1 = param$0[1]; return x$1[1];
       default:
        var thunk = param$0[1], _dS_ = caml_obj_tag(thunk);
        a:
        if(250 === _dS_)
         var param$1 = thunk[1];
        else{
         if(246 !== _dS_ && 244 !== _dS_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
     }
   }
   var path$0 = caml_call2(map$6, path, parts_exe_basename);
   function get_flag_names(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var base = param$0[1]; return caml_call1(Base_Map[73], base[3]);
       case 3:
        var thunk = param$0[1], _dR_ = caml_obj_tag(thunk);
        a:
        if(250 === _dR_)
         var param$1 = thunk[1];
        else{
         if(246 !== _dR_ && 244 !== _dR_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
        break;
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
     }
   }
   function help_recursive(cmd, with_flags, expand_dots, t, s){
    function help_recursive_rec(cmd, t, s){
     var t$0 = t;
     for(;;){
      var
       cmd$0 = expand_dots ? cmd : cst$16,
       _dH_ = caml_call2(Base[241], cmd$0, cst$15),
       new_s = caml_call2(Base[241], s, _dH_);
      switch(t$0[0]){
        case 0:
         var
          base = t$0[1],
          _dI_ = summary([0, base]),
          base_help = [0, caml_call2(Base[241], s, cmd), _dI_];
         if(! with_flags) return [0, base_help, 0];
         var
          _dJ_ =
            function(param){
             var h = param[2], flag = param[1];
             return [0, caml_call2(Base[241], new_s, flag), h];
            },
          display_help_flags = opt[1],
          flags = caml_call1(Base_Map[74], base[3]);
         if(display_help_flags)
          var flags$0 = flags;
         else
          var
           _dG_ =
             function(f){return caml_call2(Base_String[50], f[1], cst_help);},
           flags$0 = caml_call2(Base_List[12], flags, _dG_);
         var
          _dF_ = caml_call2(Base_List[14], flags$0, help),
          _dK_ = caml_call2(Base_List[83], _dF_, subcommand_cmp_fst);
         return [0, base_help, caml_call2(Base_List[53], _dK_, _dJ_)];
        case 1:
         var
          match = t$0[1],
          subcommands = match[3],
          summary$0 = match[1],
          _dL_ =
            function(param){
             var t = param[2], cmd = param[1];
             return help_recursive_rec(cmd, t, new_s);
            },
          _dM_ = caml_obj_tag(subcommands);
         a:
         if(250 === _dM_)
          var _dN_ = subcommands[1];
         else{
          if(246 !== _dM_ && 244 !== _dM_){var _dN_ = subcommands; break a;}
          var _dN_ = caml_call1(CamlinternalLazy[2], subcommands);
         }
         var
          _dO_ = caml_call2(Base_List[83], _dN_, subcommand_cmp_fst),
          _dP_ = caml_call2(Base_List[14], _dO_, _dL_);
         return [0, [0, caml_call2(Base[241], s, cmd), summary$0], _dP_];
        case 2:
         return 0;
        default:
         var thunk = t$0[1], _dQ_ = caml_obj_tag(thunk);
         a:
         if(250 === _dQ_)
          var t$1 = thunk[1];
         else{
          if(246 !== _dQ_ && 244 !== _dQ_){var t$1 = thunk; break a;}
          var t$1 = caml_call1(CamlinternalLazy[2], thunk);
         }
         var t$0 = t$1;
      }
     }
    }
    return help_recursive_rec(cmd, t, s);
   }
   function autocomplete_function(argv_0, pid){
    var fname = caml_call2(Command_Import[7], _aR_, pid);
    return caml_call5(Command_Import[7], _aS_, fname, argv_0, fname, argv_0);
   }
   if(typeof Ppx_inline_test_lib[3] !== "number"){
    var
     Ppx_expect_test_block =
       caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
     _a__ =
       function(param){
        var _dD_ = autocomplete_function(cst_argv_0, 12345);
        caml_call1(Command_Import[5], _dD_);
        var _dE_ = caml_call1(Ppx_expect_runtime_Types[4][1], 6);
        return caml_call1(Ppx_expect_test_block[2], _dE_);
       },
     _bb_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _ba_,
         _a$_),
     _bc_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 6), _bb_], 0],
     _be_ = caml_call1(Ppx_expect_runtime_Types[4][1], 8),
     _bf_ = caml_call1(Ppx_expect_runtime_Types[4][1], 7);
    caml_call14
     (Ppx_expect_test_block[3],
      cst_command_src_command_ml$2,
      2736,
      _bi_,
      _bh_,
      _bg_,
      [0, Ppx_expect_runtime_Types[1][1]],
      0,
      _bf_,
      _be_,
      _bd_,
      0,
      Inline_test_config,
      _bc_,
      _a__);
   }
   var path$1 = caml_call2(map$4, path, parts_exe_basename);
   function basic$0(summary, readme, param){
    function _dB_(f, param){
     var _dC_ = caml_call1(f, 0);
     return caml_call2(Base_String[109], 0, _dC_);
    }
    var readme$0 = caml_call2(Base_Option[24], readme, _dB_);
    return basic(summary, readme$0, param);
   }
   function basic_or_error(summary, readme, param){
    return basic$0
            (summary,
             readme,
             caml_call2
              (map$4,
               param,
               function(run, param){
                var match = caml_call1(run, 0);
                if(0 === match[0]) return 0;
                var e = match[1], _dA_ = caml_call1(Base_Error[12], e);
                caml_call1(Stdio[10], _dA_);
                return exit(1);
               }));
   }
   function normalized_path$0(param){
    return caml_call2(Base_Option[24], normalized_path[1], parts);
   }
   function normalized_args$0(param){return normalized_args[1];}
   var
    For_telemetry = [0, normalized_path$0, normalized_args$0],
    word_wrap = Command_Shape[14][5];
   function to_string_for_choose_one(param){return to_string$0(create_exn(param));
   }
   caml_call1(Ppx_inline_test_lib[7], cst_command);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Command);
   var
    run$0 = 228660148,
    shape$2 = 228660148,
    Command =
      [0,
       Auto_complete,
       [0,
        create,
        parse,
        map$1,
        of_lazy,
        of_map,
        of_alist_exn,
        enumerated,
        enumerated_sexpable,
        comma_separated,
        include$0,
        auto_complete],
       [0,
        required,
        optional,
        optional_with_default,
        listed,
        one_or_more_as_pair,
        one_or_more_as_list,
        no_arg,
        no_arg_register,
        no_arg_some,
        no_arg_required,
        no_arg_abort,
        escape,
        escape_with_autocomplete,
        map_flag],
       [0,
        symbol$2,
        sequence$0,
        non_empty_sequence_as_pair,
        non_empty_sequence_as_list,
        maybe,
        maybe_with_default,
        t2,
        t3,
        t4,
        map_anons],
       [0,
        return$4,
        map$4,
        both,
        symbol$3,
        symbol$4,
        symbol$5,
        symbol_map$1,
        apply$2,
        map2,
        map3,
        all,
        all_unit,
        Applicative_infix,
        help$0,
        path$1,
        args,
        flag,
        flag_optional_with_default_doc,
        anon,
        escape_anon,
        If_nothing_chosen,
        choose_one,
        choose_one_non_optional$0,
        and_arg_names,
        and_arg_name,
        arg_names,
        optional_to_required,
        [0,
         create,
         parse,
         map$1,
         of_lazy,
         of_map,
         of_alist_exn,
         enumerated,
         enumerated_sexpable,
         comma_separated,
         include$0,
         auto_complete],
        string$0,
        int$1,
        char$1,
        float$1,
        bool$0,
        sexp$0,
        sexp_conv$0,
        required,
        optional,
        optional_with_default,
        listed,
        one_or_more_as_pair,
        one_or_more_as_list,
        no_arg,
        no_arg_register,
        no_arg_some,
        no_arg_required,
        no_arg_abort,
        escape,
        escape_with_autocomplete,
        map_flag,
        symbol$2,
        sequence$0,
        non_empty_sequence_as_pair,
        non_empty_sequence_as_list,
        maybe,
        maybe_with_default,
        t2,
        t3,
        t4,
        map_anons,
        parse$1],
       [0,
        return$4,
        symbol$3,
        symbol$4,
        symbol$5,
        symbol_map$1,
        [0, return$4, map$4, both]],
       [0,
        return$5,
        map$6,
        both$0,
        symbol$9,
        symbol$10,
        symbol$11,
        symbol_map$2,
        apply$3,
        map2$0,
        map3$0,
        all$0,
        all_unit$0,
        Applicative_infix$0,
        help$0,
        path$0,
        args,
        flag,
        flag_optional_with_default_doc,
        anon,
        escape_anon,
        If_nothing_chosen,
        choose_one,
        choose_one_non_optional$0,
        and_arg_names,
        and_arg_name,
        arg_names,
        const$0,
        both,
        empty_spec,
        symbol$6,
        symbol$7,
        symbol$8,
        step,
        wrap,
        [0,
         create,
         parse,
         map$1,
         of_lazy,
         of_map,
         of_alist_exn,
         enumerated,
         enumerated_sexpable,
         comma_separated,
         include$0,
         auto_complete],
        string$1,
        int$2,
        char$2,
        float$2,
        bool$1,
        sexp$1,
        sexp_conv$1,
        required,
        optional,
        optional_with_default,
        listed,
        one_or_more_as_pair,
        one_or_more_as_list,
        no_arg,
        no_arg_register,
        no_arg_some,
        no_arg_required,
        no_arg_abort,
        escape,
        escape_with_autocomplete,
        map_flag,
        flags_of_args_exn,
        symbol$2,
        sequence$0,
        non_empty_sequence_as_pair,
        non_empty_sequence_as_list,
        maybe,
        maybe_with_default,
        t2,
        t3,
        t4,
        map_anons,
        to_param,
        of_param],
       basic_spec,
       basic$0,
       basic_or_error,
       group,
       lazy_group,
       exec,
       of_lazy$0,
       summary,
       exit,
       For_telemetry,
       [0, Deprecated, summary, help_recursive, get_flag_names],
       run$0,
       [0],
       shape$2,
       [0,
        abs_path,
        word_wrap,
        [0, normalize],
        [0,
         empty$0,
         create$1,
         append,
         parts,
         replace_first,
         to_string,
         to_string_dots],
        [0, compare, of_list, extend],
        [0, flags_of_args_exn, to_string_for_choose_one],
        function(For_unix_with_string_env_var){
         var
          Version_info$0 = Version_info(For_unix_with_string_env_var[1]),
          Pid = For_unix_with_string_env_var[2],
          Thread = For_unix_with_string_env_var[4],
          Unix = For_unix_with_string_env_var[5],
          getpid = Unix[2],
          close = Unix[3],
          in_channel_of_descr = Unix[4],
          wait = Unix[11],
          _bj_ = Unix[5],
          _bk_ = Unix[6],
          _bl_ = Unix[7],
          _bm_ = Unix[10];
         function getenv_and_clear(var$0){
          var value = caml_call1(_bl_, caml_call1(Command_Env_var[4], var$0));
          if(caml_call1(Base_Option[53], value))
           caml_call1(_bk_, caml_call1(Command_Env_var[4], var$0));
          return value;
         }
         var
          include = Command_Shape[11],
          supported_versions = include[3],
          Versioned = include[4],
          of_versioned = include[5],
          to_versioned = include[6];
         function of_external(working_dir, path_to_exe, child_subcommand){
          var
           _dl_ =
             caml_call2(Base_Set[68], [0, Base_Int[10]], supported_versions),
           help_sexp = caml_call1(Base[85][16], _dl_),
           env = [0, -72399366, [0, [0, 1, help_sexp], 0]],
           prog = caml_call2(abs_path, working_dir, path_to_exe),
           argv0 = 0,
           prog_search_path = 0,
           working_dir$0 = 0,
           _dh_ = 0;
          function convert_command_env_var_to_str(list){
           function _dz_(param){
            var str = param[2], env_var = param[1];
            return [0, caml_call1(Command_Env_var[4], env_var), str];
           }
           return caml_call2(Base_List[53], list, _dz_);
          }
          var _dg_ = env[1];
          if(-72399366 <= _dg_)
           if(584703596 <= _dg_)
            var
             list = env[2],
             _di_ = [0, 584703596, convert_command_env_var_to_str(list)];
           else
            var
             list$0 = env[2],
             _di_ = [0, -72399366, convert_command_env_var_to_str(list$0)];
          else if(-126259180 <= _dg_)
           var
            list$1 = env[2],
            _di_ = [0, -126259180, convert_command_env_var_to_str(list$1)];
          else
           var _di_ = env;
          var
           process_info =
             caml_call7
              (_bm_,
               working_dir$0,
               prog_search_path,
               argv0,
               prog,
               child_subcommand,
               _di_,
               _dh_);
          caml_call2(close, 0, process_info[2]);
          function start_reading(descr, info){
           var output = [0, 0], _dr_ = 0;
           function _ds_(param){
            function _dx_(param){
             var _dy_ = caml_call1(in_channel_of_descr, descr);
             return caml_call1(Stdio_In_channel[14], _dy_);
            }
            var result = caml_call1(Base_Result[41], _dx_);
            output[1] = [0, result];
            return 0;
           }
           var thread = caml_call3(Thread[1], 890699316, _ds_, _dr_);
           function _dt_(param){
            caml_call1(Thread[2], thread);
            caml_call2(close, 0, descr);
            var _du_ = output[1];
            if(! _du_){
             var
              _dv_ =
                [0, [1, [0, _aT_, [0, caml_call1(Base_Info[9], info), 0]]], 0],
              _dw_ =
                [1,
                 [0,
                  caml_call1(Sexplib0_Sexp_conv[7], cst_BUG_failed_to_read),
                  _dv_]];
             return caml_call1(Base[246], _dw_);
            }
            var match = _du_[1];
            if(0 === match[0]){var output$0 = match[1]; return output$0;}
            var exn = match[1];
            throw caml_maybe_attach_backtrace(exn, 1);
           }
           return caml_call1(Base_Staged[1], _dt_);
          }
          var
           _dj_ = caml_call1(Base_Info[14], cst_stdout),
           finish_stdout = start_reading(process_info[3], _dj_),
           _dk_ = caml_call1(Base_Info[14], cst_stderr),
           finish_stderr = start_reading(process_info[4], _dk_),
           stderr = caml_call2(Base_Staged[2], finish_stderr, 0),
           stdout = caml_call2(Base_Staged[2], finish_stdout, 0);
          caml_call1(wait, process_info[1]);
          try{
           var
            _dq_ = caml_call1(Sexplib_Sexp[43], stdout),
            t = caml_call1(of_versioned, caml_call1(Versioned[1], _dq_));
           return t;
          }
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _dm_ =
              [0, [1, [0, _aU_, [0, caml_call1(Base[202], stderr), 0]]], 0],
            _dn_ =
              [0, [1, [0, _aV_, [0, caml_call1(Base[202], stdout), 0]]], _dm_],
            _do_ = [0, caml_call1(Base[117], exn), _dn_],
            _dp_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_cannot_parse_command_shape),
                _do_]];
           return caml_call1(Base[246], _dp_);
          }
         }
         function shape_of_proxy(proxy){return shape_of_proxy_kind(proxy[5]);}
         function shape_of_exe
         (param, child_subcommand, path_to_exe, working_dir){
          return shape_of_proxy
                  (proxy_of_sexpable
                    (of_external(working_dir, path_to_exe, child_subcommand),
                     working_dir,
                     path_to_exe,
                     child_subcommand,
                     0));
         }
         function shape_of_proxy_kind(kind){
          switch(kind[0]){
            case 0:
             var b = kind[1]; return [0, b];
            case 1:
             var
              g = kind[1],
              _db_ = Base_List[137][9],
              _dc_ =
                function(_df_){return caml_call2(_db_, _df_, shape_of_proxy);},
              _dd_ = caml_call2(Base_Lazy[15], g[3], _dc_);
             return [1, [0, g[1], g[2], _dd_]];
            case 2:
             var
              e = kind[1],
              child_subcommand = e[5],
              path_to_exe = e[4],
              working_dir = e[3];
             return [2,
                     e,
                     function(_de_){
                      return shape_of_exe
                              (_de_, child_subcommand, path_to_exe, working_dir);
                     }];
            default:
             var l = kind[1];
             return [3, caml_call2(Base_Lazy[15], l, shape_of_proxy_kind)];
          }
         }
         function shape$2(t){
          var t$0 = t;
          for(;;)
           switch(t$0[0]){
             case 0:
              var b = t$0[1]; return [0, shape(b)];
             case 1:
              var g = t$0[1]; return [1, shape$0(shape$2, g)];
             case 2:
              var
               e = t$0[1],
               child_subcommand = e[5],
               path_to_exe = e[4],
               working_dir = e[3],
               _c__ =
                 function(_da_){
                  return shape_of_exe
                          (_da_, child_subcommand, path_to_exe, working_dir);
                 };
              return [2, shape$1(e), _c__];
             default:
              var thunk = t$0[1], _c$_ = caml_obj_tag(thunk);
              a:
              if(250 === _c$_)
               var t$1 = thunk[1];
              else{
               if(246 !== _c$_ && 244 !== _c$_){var t$1 = thunk; break a;}
               var t$1 = caml_call1(CamlinternalLazy[2], thunk);
              }
              var t$0 = t$1;
           }
         }
         function group_or_exec_help_text
         (flags, path, summary, readme, format_list){
          var
           _c6_ = [0, [0, caml_call1(Command_Shape[4][2], format_list)], 0],
           _c7_ = flags ? cst_subcommands_and_flags : cst_subcommands$0,
           _c8_ = [0, cst$18, [0, to_string(path), _aY_]],
           _c9_ =
             [0,
              [0, summary],
              [0,
               [0, caml_call2(Base_String[68], 0, _c8_)],
               [0, readme, [0, [0, _c7_], _c6_]]]];
          return unparagraphs(caml_call1(Base_List[136], _c9_));
         }
         function help_for_shape(shape, path, expand_dots, flags, recursive){
          var shape$0 = shape;
          for(;;){
           var
            loop =
              function(path, acc, shape){
               var shape$0 = shape;
               for(;;){
                var string_of_path = expand_dots ? to_string : to_string_dots;
                switch(shape$0[0]){
                  case 0:
                   var b = shape$0[1];
                   if(! flags) return acc;
                   var
                    _cV_ =
                      function(acc, fmt){
                       var
                        path$0 = [0, fmt[1], path],
                        _c4_ = fmt[3],
                        _c5_ = fmt[2],
                        fmt$0 = [0, string_of_path(path$0), _c5_, _c4_];
                       return [0, fmt$0, acc];
                      },
                    _cW_ =
                      function(fmt){
                       return caml_call2(Base_String[50], fmt[1], cst_help$4);
                      },
                    _cX_ = caml_call2(Base_List[12], b[4], _cW_);
                   return caml_call3(Base_List[20], _cX_, acc, _cV_);
                  case 1:
                   var g = shape$0[1], _cY_ = g[3], _cZ_ = caml_obj_tag(_cY_);
                   a:
                   if(250 === _cZ_)
                    var subcommands = _cY_[1];
                   else{
                    if(246 !== _cZ_ && 244 !== _cZ_){
                     var subcommands = _cY_;
                     break a;
                    }
                    var subcommands = caml_call1(CamlinternalLazy[2], _cY_);
                   }
                   var
                    filtered_subcommands =
                      caml_call1(is_empty, path)
                       ? subcommands
                       : caml_call3
                         (Base_List[137][8],
                          subcommands,
                          Base_String[47],
                          cst_help$3),
                    _cS_ =
                      function(acc, param){
                       var
                        shape = param[2],
                        subcommand = param[1],
                        path$0 = [0, subcommand, path],
                        name = string_of_path(path$0),
                        doc = caml_call1(Command_Shape[10], shape),
                        acc$0 = [0, [0, name, doc, 0], acc];
                       return recursive ? loop(path$0, acc$0, shape) : acc$0;
                      },
                    _cT_ =
                      function(a, b){
                       var _c3_ = caml_call1(Base[242], b);
                       return caml_call2
                               (help_screen_compare, caml_call1(Base[242], a), _c3_);
                      },
                    _cU_ = caml_call2(Base_List[84], filtered_subcommands, _cT_);
                   return caml_call3(Base_List[20], _cU_, acc, _cS_);
                  case 2:
                   var shape$1 = shape$0[2];
                   try{
                    var _c0_ = loop(path, acc, caml_call1(shape$1, 0));
                    return _c0_;
                   }
                   catch(_c2_){return acc;}
                  default:
                   var thunk = shape$0[1], _c1_ = caml_obj_tag(thunk);
                   a:
                   if(250 === _c1_)
                    var shape$2 = thunk[1];
                   else{
                    if(246 !== _c1_ && 244 !== _c1_){var shape$2 = thunk; break a;}
                    var shape$2 = caml_call1(CamlinternalLazy[2], thunk);
                   }
                   var shape$0 = shape$2;
                }
               }
              },
            _cK_ = loop(empty$0, 0, shape$0),
            format_list = caml_call1(Base_List[63], _cK_);
           switch(shape$0[0]){
             case 0:
              var
               b = shape$0[1],
               usage = caml_call1(Command_Shape[5][8], b),
               _cL_ =
                 [0, _aZ_, [0, [0, caml_call1(Command_Shape[4][2], b[4])], 0]],
               _cM_ = [0, b[2], _cL_],
               _cN_ = caml_call2(Base[241], cst$19, usage),
               _cO_ = to_string(path),
               _cP_ = caml_call2(Base[241], _cO_, _cN_),
               _cQ_ = [0, [0, caml_call2(Base[241], cst$20, _cP_)], _cM_];
              return unparagraphs
                      (caml_call1(Base_List[136], [0, [0, b[1]], _cQ_]));
             case 1:
              var g = shape$0[1];
              return group_or_exec_help_text
                      (flags, path, g[1], g[2], format_list);
             case 2:
              var e = shape$0[1];
              return group_or_exec_help_text
                      (flags, path, e[1], e[2], format_list);
             default:
              var thunk = shape$0[1], _cR_ = caml_obj_tag(thunk);
              a:
              if(250 === _cR_)
               var shape$1 = thunk[1];
              else{
               if(246 !== _cR_ && 244 !== _cR_){var shape$1 = thunk; break a;}
               var shape$1 = caml_call1(CamlinternalLazy[2], thunk);
              }
              var shape$0 = shape$1;
           }
          }
         }
         function add(t){
          switch(t[0]){
            case 0:
             var
              base = t[1],
              flags = base[3],
              _cC_ = -481604174,
              _cD_ = function(_cJ_){return 0;},
              flags$0 =
                extend_map_exn
                 (flags,
                  1,
                  name,
                  [0,
                   name,
                   0,
                   _a5_,
                   [0,
                    function(env){
                     return caml_call3
                             (set, env, key_internal_validate_parsing, 0);
                    }],
                   cst_validate_arguments_are_par,
                   at_most_once,
                   _cD_,
                   _cC_]);
             return [0, [0, base[1], base[2], flags$0, base[4], base[5]]];
            case 1:
             var
              match = t[1],
              body = match[4],
              subcommands = match[3],
              readme = match[2],
              summary = match[1],
              _cE_ =
                function(subcommands){
                 function _cI_(param){
                  var command = param[2], name = param[1];
                  return [0, name, add(command)];
                 }
                 return caml_call2(Base_List[53], subcommands, _cI_);
                },
              subcommands$0 = caml_call2(Base_Lazy[15], subcommands, _cE_);
             return [1, [0, summary, readme, subcommands$0, body]];
            case 2:
             return t;
            default:
             var thunk = t[1];
             return [3,
                     [246,
                      function(_cF_){
                       var _cG_ = caml_obj_tag(thunk);
                       a:
                       if(250 === _cG_)
                        var _cH_ = thunk[1];
                       else{
                        if(246 !== _cG_ && 244 !== _cG_){var _cH_ = thunk; break a;}
                        var _cH_ = caml_call1(CamlinternalLazy[2], thunk);
                       }
                       return add(_cH_);
                      }]];
          }
         }
         function add_help_subcommands(t){
          switch(t[0]){
            case 0:
             return t;
            case 1:
             var
              match = t[1],
              body = match[4],
              subcommands = match[3],
              readme = match[2],
              summary = match[1],
              _cl_ =
                function(subcommands){
                 var
                  _cp_ = anon(maybe(symbol$2(cst_SUBCOMMAND, string$0))),
                  _cq_ =
                    caml_call1
                     (flag(0, 0, cst_expand_dots)(no_arg),
                      cst_expand_subcommands_in_recu),
                  _cr_ =
                    caml_call1
                     (flag(0, 0, cst_flags)(no_arg),
                      cst_show_flags_as_well_in_recu),
                  _cs_ =
                    caml_call1
                     (flag(0, 0, cst_recursive)(no_arg),
                      cst_show_subcommands_of_subcom),
                  _ct_ =
                    basic
                     (cst_explain_a_given_subcommand,
                      0,
                      caml_call2
                       (symbol$3,
                        caml_call2
                         (symbol$3,
                          caml_call2
                           (symbol$3,
                            caml_call2
                             (symbol$3,
                              caml_call2
                               (symbol$3,
                                caml_call2
                                 (symbol$3,
                                  caml_call1
                                   (return$4,
                                    function
                                    (recursive, flags, expand_dots, path$0, env, cmd_opt, param){
                                     var match = caml_call2(find, env, subs_key);
                                     if(! match)
                                      throw caml_maybe_attach_backtrace
                                             ([0, Assert_failure, _a1_], 1);
                                     var subs = match[1];
                                     if(path$0 && ! caml_string_notequal(path$0[1], cst_help$7)){
                                      var
                                       path = path$0[2],
                                       _cu_ =
                                         function(path, subcommand){return [0, subcommand, path];},
                                       path$1 = caml_call3(Base_Option[34], cmd_opt, path, _cu_);
                                      if(cmd_opt){
                                       var
                                        cmd = cmd_opt[1],
                                        _cv_ = 0,
                                        _cw_ = function(x){return [0, x, -481604174];},
                                        match$0 =
                                          caml_call3
                                           (lookup_expand,
                                            caml_call2(Base_List[137][9], subs, _cw_),
                                            cmd,
                                            _cv_);
                                       if(0 === match$0[0])
                                        var
                                         match$1 = match$0[1],
                                         t = match$1[2],
                                         possibly_expanded_name = match$1[1],
                                         path$2 = replace_first(path$1, cmd, possibly_expanded_name),
                                         shape = shape$2(t),
                                         path$3 = path$2;
                                       else
                                        var
                                         e = match$0[1],
                                         _cy_ = to_string(path$1),
                                         _cz_ = caml_call4(die(_a0_), cmd, _cy_, e, 0),
                                         shape = _cz_[2],
                                         path$3 = _cz_[1];
                                      }
                                      else
                                       var
                                        _cA_ = caml_call2(Base_List[137][9], subs, shape$2),
                                        subcommands = caml_call1(Base_Lazy[24], _cA_),
                                        _cB_ = function(readme){return caml_call1(readme, 0);},
                                        readme$0 = caml_call2(Base_Option[24], readme, _cB_),
                                        shape$0 = [1, [0, summary, readme$0, subcommands]],
                                        shape = shape$0,
                                        path$3 = path$1;
                                      var
                                       _cx_ =
                                         help_for_shape(shape, path$3, expand_dots, flags, recursive);
                                      return caml_call1(Command_Import[5], _cx_);
                                     }
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _E_], 1);
                                    }),
                                  _cs_),
                                _cr_),
                              _cq_),
                            path),
                          env),
                        _cp_));
                 return extend_alist_exn
                         (caml_call2
                           (Base_List[137][9], subcommands, add_help_subcommands),
                          0,
                          cst_help$5,
                          _ct_);
                },
              subcommands$0 = caml_call2(Base_Lazy[15], subcommands, _cl_);
             return [1, [0, summary, readme, subcommands$0, body]];
            case 2:
             return t;
            default:
             var thunk = t[1];
             return [3,
                     [246,
                      function(_cm_){
                       var _cn_ = caml_obj_tag(thunk);
                       a:
                       if(250 === _cn_)
                        var _co_ = thunk[1];
                       else{
                        if(246 !== _cn_ && 244 !== _cn_){var _co_ = thunk; break a;}
                        var _co_ = caml_call1(CamlinternalLazy[2], thunk);
                       }
                       return add_help_subcommands(_co_);
                      }]];
          }
         }
         function maybe_apply_extend(args, extend$0, path){
          function _ck_(f){return extend(args, f, path);}
          return caml_call3(Base_Option[32], extend$0, args, _ck_);
         }
         function dispatch
         (t,
          env$0,
          extend,
          path,
          args$0,
          maybe_new_comp_cword,
          version,
          build_info,
          verbose_on_parse_error,
          when_parsing_succeeds,
          complete_subcommands){
          var t$0 = t;
          for(;;)
           switch(t$0[0]){
             case 0:
              var
               base = t$0[1],
               args$1 = maybe_apply_extend(args$0, extend, path),
               help_text =
                 [246,
                  function(param){
                   return help_for_shape(shape$2(t$0), path, 0, 1, 0);
                  }];
              return run
                      (base,
                       env$0,
                       when_parsing_succeeds,
                       path,
                       args$1,
                       verbose_on_parse_error,
                       help_text,
                       run_exn);
             case 1:
              var
               group = t$0[1],
               body = group[4],
               subs = group[3],
               readme = group[2],
               summary = group[1],
               completing = ends_in_complete(args$0),
               _b3_ = caml_obj_tag(subs);
              a:
              if(250 === _b3_)
               var _b4_ = subs[1];
              else{
               if(246 !== _b3_ && 244 !== _b3_){var _b4_ = subs; break a;}
               var _b4_ = caml_call1(CamlinternalLazy[2], subs);
              }
              var
               env$1 = caml_call3(set, env$0, subs_key, _b4_),
               die_showing_help =
                 function(msg){
                  if(completing) return exit(0);
                  var
                   _cj_ =
                     help_for_shape
                      (shape$2([1, [0, summary, readme, subs, body]]),
                       path,
                       0,
                       0,
                       0);
                  caml_call2(Command_Import[1], _a6_, _cj_);
                  return caml_call2(die(_a7_), msg, 0);
                 },
               parse_group =
                 function(args, maybe_new_comp_cword){
                  var
                   maybe_new_comp_cword$0 =
                     caml_call2
                      (Base_Option[24], maybe_new_comp_cword, Base_Int[46]);
                  function skip(rest){
                   return parse_group(rest, maybe_new_comp_cword$0);
                  }
                  function resolve(sub, rest){
                   function _cg_(x){return [0, x, -481604174];}
                   var _ch_ = caml_obj_tag(subs);
                   a:
                   if(250 === _ch_)
                    var _ci_ = subs[1];
                   else{
                    if(246 !== _ch_ && 244 !== _ch_){var _ci_ = subs; break a;}
                    var _ci_ = caml_call1(CamlinternalLazy[2], subs);
                   }
                   var
                    subs$0 = caml_call2(Base_List[137][9], _ci_, _cg_),
                    match = caml_call3(lookup_expand, subs$0, sub, 0);
                   if(0 === match[0]){
                    var match$0 = match[1], t = match$0[2], sub$0 = match$0[1];
                    return dispatch
                            (t,
                             env$1,
                             extend,
                             [0, sub$0, path],
                             rest,
                             maybe_new_comp_cword$0,
                             version,
                             build_info,
                             verbose_on_parse_error,
                             when_parsing_succeeds,
                             complete_subcommands);
                   }
                   var msg = match[1];
                   return die_showing_help(msg);
                  }
                  if(typeof args === "number"){
                   if(body){
                    var body$0 = body[1];
                    return caml_call1(body$0, parts_exe_basename(path));
                   }
                   var _b6_ = to_string(path);
                   return die_showing_help
                           (caml_call2(Command_Import[7], _a8_, _b6_));
                  }
                  if(0 !== args[0]){
                   var
                    part = args[1],
                    _b8_ = Base_String[51],
                    _b9_ =
                      function(name){
                       return caml_call2(Base_String[97], name, part);
                      },
                    _b__ = Base[242],
                    _b$_ = caml_obj_tag(subs);
                   a:
                   if(250 === _b$_)
                    var _ca_ = subs[1];
                   else{
                    if(246 !== _b$_ && 244 !== _b$_){var _ca_ = subs; break a;}
                    var _ca_ = caml_call1(CamlinternalLazy[2], subs);
                   }
                   var
                    _cb_ = caml_call2(Base_List[53], _ca_, _b__),
                    _cc_ = caml_call2(Base_List[12], _cb_, _b9_),
                    subs$0 = caml_call2(Base_List[83], _cc_, _b8_);
                   if(! complete_subcommands){
                    caml_call2(Base_List[19], subs$0, Command_Import[5]);
                    return exit(0);
                   }
                   var
                    f = complete_subcommands[1],
                    _cd_ = shape$2(t$0),
                    _ce_ = caml_call1(Command_Shape[9], _cd_),
                    subcommands = caml_call1(Command_Shape[8][3], _ce_),
                    match =
                      caml_call3(f, caml_call1(parts, path), part, subcommands);
                   if(! match) return exit(1);
                   var
                    to_output = match[1],
                    _cf_ = caml_call2(Base_String[68], _a9_, to_output);
                   caml_call1(Command_Import[5], _cf_);
                   return exit(0);
                  }
                  var rest = args[2], sub = args[1];
                  a:
                  {
                   b:
                   if(caml_string_notequal(sub, cst_build_info$1)){
                    c:
                    if(caml_string_notequal(sub, cst_help$9)){
                     if(caml_string_notequal(sub, cst_version$2)){
                      if(! caml_string_notequal(sub, cst_build_info$2)) break b;
                      if(! caml_string_notequal(sub, cst_help$8)) break c;
                      if(caml_string_notequal(sub, cst_version$3)) break a;
                     }
                     if(1 === caml_call1(length, path))
                      return completing
                              ? skip(rest)
                              : (Version_info$0[1].call(null, version), exit(0));
                     break a;
                    }
                    if(completing) return skip(rest);
                    if(typeof rest !== "number" && 0 === rest[0]){
                     var rest_of_rest = rest[2], first_of_rest = rest[1];
                     return resolve(first_of_rest, [0, sub, rest_of_rest]);
                    }
                    var
                     _b7_ =
                       help_for_shape
                        (shape$2([1, [0, group[1], group[2], subs, group[4]]]),
                         path,
                         0,
                         0,
                         0);
                    caml_call1(Command_Import[5], _b7_);
                    return exit(0);
                   }
                   if(1 === caml_call1(length, path))
                    return completing
                            ? skip(rest)
                            : (Version_info$0[2].call(null, build_info), exit(0));
                  }
                  return resolve(sub, rest);
                 };
              return parse_group(args$0, maybe_new_comp_cword);
             case 2:
              var
               exec = t$0[1],
               args$2 = to_list(maybe_apply_extend(args$0, extend, path)),
               prog = caml_call2(abs_path, exec[3], exec[4]),
               args = caml_call2(Base[222], exec[5], args$2),
               env = exec[6],
               _b1_ =
                 function(n){
                  var
                   new_value$0 = n + caml_call1(Base_List[45], exec[5]) | 0,
                   new_value = caml_call1(Base_Int[12], new_value$0);
                  return caml_call2
                          (_bj_,
                           caml_call1(Command_Env_var[4], comp_cword),
                           new_value);
                 };
              caml_call2(Base_Option[37], maybe_new_comp_cword, _b1_);
              var
               _b2_ =
                 caml_call5
                  (For_unix_with_string_env_var[5][8],
                   prog,
                   [0, prog, args],
                   0,
                   env,
                   0);
              return caml_call1(Base_Nothing[4], _b2_);
             default:
              var thunk = t$0[1], _b5_ = caml_obj_tag(thunk);
              a:
              if(250 === _b5_)
               var t$1 = thunk[1];
              else{
               if(246 !== _b5_ && 244 !== _b5_){var t$1 = thunk; break a;}
               var t$1 = caml_call1(CamlinternalLazy[2], thunk);
              }
              var t$0 = t$1;
           }
         }
         function run$0
         (opt,
          verbose_on_parse_error,
          version,
          build_info,
          _bt_,
          extend,
          _bs_,
          complete_subcommands,
          t){
          if(opt)
           var sth = opt[1], add_validate_parsing_flag = sth;
          else
           var add_validate_parsing_flag = 0;
          if(_bt_)
           var sth$0 = _bt_[1], argv = sth$0;
          else
           var
            _bu_ = caml_sys_argv(0),
            argv = caml_call1(Base_Array[30], _bu_);
          if(_bs_)
           var sth$1 = _bs_[1], when_parsing_succeeds = sth$1;
          else
           var when_parsing_succeeds = function(_b0_){return _b0_;};
          if(build_info)
           var v = build_info[1], build_info$0 = v;
          else
           var build_info$0 = Version_info$0[7];
          if(version)
           var
            v$0 = version[1],
            version$0 =
              [246,
               function(param){
                var _bV_ = Base_String[102];
                function _bW_(_bZ_){return caml_call2(_bV_, _bZ_, 10);}
                var
                 _bX_ = caml_call2(Base_String[102], v$0, 32),
                 _bY_ = caml_call2(Base_List[14], _bX_, _bW_);
                return Version_info$0[5].call(null, _bY_);
               }];
          else
           var version$0 = Version_info$0[6];
          function f(param){
           var
            t$0 = Version_info$0[4].call(null, version$0, build_info$0, t),
            t$1 = add_help_subcommands(t$0),
            t$2 = add_validate_parsing_flag ? add(t$1) : t$1;
           if(argv){
            var
             path_to_subcommand = argv[2],
             cmd = argv[1],
             _bx_ =
               function(version){
                var
                 _bU_ = caml_call1(Sexplib_Sexp[43], version),
                 supported_versions$0 =
                   caml_call2
                    (Base_Set[69], [0, Base_Int[9], Base_Int[22]], _bU_),
                 _bN_ =
                   caml_call2
                    (Base_Set[14], supported_versions, supported_versions$0),
                 param = caml_call1(Base_Set[54], _bN_);
                if(param){
                 var
                  version_to_use = param[1],
                  t$4 = sexpable_shape(t$2),
                  t = t$4,
                  path_to_subcommand$0 = path_to_subcommand;
                 for(;;){
                  if(path_to_subcommand$0){
                   var
                    path_to_subcommand$1 = path_to_subcommand$0[2],
                    sub = path_to_subcommand$0[1];
                   if(caml_call2(Base_String[97], sub, cst$17))
                    var _bO_ = t;
                   else
                    switch(t[0]){
                      case 0:
                       var _bO_ = caml_call3(Command_Import[8], _aW_, sub, 0);
                       break;
                      case 1:
                       var
                        g = t[1],
                        _bJ_ = g[3],
                        _bI_ = Base_String[134],
                        _bK_ = caml_obj_tag(_bJ_);
                       a:
                       if(250 === _bK_)
                        var _bL_ = _bJ_[1];
                       else{
                        if(246 !== _bK_ && 244 !== _bK_){var _bL_ = _bJ_; break a;}
                        var _bL_ = caml_call1(CamlinternalLazy[2], _bJ_);
                       }
                       var match = caml_call3(Base_List[137][5], _bL_, _bI_, sub);
                       if(match){
                        var
                         t$0 = match[1],
                         t = t$0,
                         path_to_subcommand$0 = path_to_subcommand$1;
                        continue;
                       }
                       var _bO_ = caml_call3(Command_Import[8], _aX_, sub, 0);
                       break;
                      case 2:
                       var
                        match$0 = t[1],
                        child_subcommand = match$0[5],
                        path_to_exe = match$0[4],
                        working_dir = match$0[3],
                        path_to_subcommand$2 =
                          [0,
                           sub,
                           caml_call2
                            (Base[222], path_to_subcommand$1, child_subcommand)],
                        t$1 =
                          of_external(working_dir, path_to_exe, child_subcommand),
                        t = t$1,
                        path_to_subcommand$0 = path_to_subcommand$2;
                       continue;
                      default:
                       var thunk = t[1], _bM_ = caml_obj_tag(thunk);
                       a:
                       if(250 === _bM_)
                        var t$3 = thunk[1];
                       else{
                        if(246 !== _bM_ && 244 !== _bM_){var t$3 = thunk; break a;}
                        var t$3 = caml_call1(CamlinternalLazy[2], thunk);
                       }
                       var t = t$3;
                       continue;
                    }
                  }
                  else
                   var _bO_ = t;
                  var
                   _bP_ = caml_call2(to_versioned, _bO_, version_to_use),
                   _bQ_ = caml_call1(Versioned[2], _bP_),
                   _bR_ = caml_call1(Base[85][16], _bQ_);
                  caml_call1(Command_Import[4], _bR_);
                  break;
                 }
                }
                else{
                 var
                  _bS_ = caml_call1(Base_Set[68], [0, Base_Int[10]]),
                  _bT_ =
                    caml_call5
                     (Base_Error[19],
                      _a3_,
                      0,
                      cst_Couldn_t_choose_a_supporte,
                      supported_versions,
                      _bS_);
                 caml_call1(Base_Error[31], _bT_);
                }
                return exit(0);
               },
             _by_ = getenv_and_clear(1);
            caml_call2(Base_Option[37], _by_, _bx_);
            var
             _bz_ =
               function(param){
                var
                 _bF_ = caml_call1(getpid, 0),
                 _bG_ = caml_call1(Pid[1], _bF_),
                 _bH_ =
                   autocomplete_function
                    (caml_check_bound(caml_sys_argv(0), 0)[1], _bG_);
                caml_call2(Command_Import[2], _a2_, _bH_);
                return exit(0);
               },
             _bA_ = getenv_and_clear(0);
            caml_call2(Base_Option[37], _bA_, _bz_);
            var match = [0, cmd, path_to_subcommand];
           }
           else
            var match = caml_call1(Base[244], cst_missing_executable_name);
           var
            args$1 = match[2],
            cmd$0 = match[1],
            _bv_ = Base_Int[11],
            _bw_ = getenv_and_clear(comp_cword),
            maybe_new_comp_cword = caml_call2(Base_Option[24], _bw_, _bv_);
           if(maybe_new_comp_cword)
            var
             comp_cword$0 = maybe_new_comp_cword[1],
             _bB_ = caml_call2(Base[222], args$1, _a4_),
             args = caml_call2(Base_List[139], _bB_, comp_cword$0),
             _bC_ = 0,
             _bD_ =
               function(arg, args){
                return typeof args === "number" ? [1, arg] : [0, arg, args];
               },
             args$0 = caml_call3(Base_List[105], args, _bD_, _bC_);
           else
            var args$0 = of_list(args$1);
           var path = create$1(cmd$0);
           try{
            var
             _bE_ =
               dispatch
                (t$2,
                 empty,
                 extend,
                 path,
                 args$0,
                 maybe_new_comp_cword,
                 version$0,
                 build_info$0,
                 verbose_on_parse_error,
                 when_parsing_succeeds,
                 complete_subcommands);
            return _bE_;
           }
           catch(exn$0){
            var exn = caml_wrap_exception(exn$0);
            if(exn[1] !== Failed_to_parse_command_line)
             throw caml_maybe_attach_backtrace(exn, 0);
            var msg = exn[2];
            return ends_in_complete(args$0)
                    ? exit(0)
                    : (caml_call1(Command_Import[6], msg), exit(1));
           }
          }
          if(! raise_instead_of_exit) return caml_call1(Base_Exn[15], f);
          try{var _br_ = f(0); return _br_;}
          catch(exn$0){
           var exn = caml_wrap_exception(exn$0);
           if(exn[1] === Exit_called && 0 === exn[2]){
            var _bq_ = caml_call1(Base[117], exn);
            return caml_call2(Command_Import[3], 0, _bq_);
           }
           throw caml_maybe_attach_backtrace(exn, 0);
          }
         }
         function deprecated_run
         (t,
          cmd,
          args,
          is_help,
          is_help_rec,
          is_help_rec_flags,
          is_expand_dots){
          var
           path_strings = caml_call2(Base_String[102], cmd, 32),
           path = caml_call1(Base_List[63], path_strings),
           args$0 = is_expand_dots ? [0, cst_expand_dots$0, args] : args,
           args$1 = is_help_rec_flags ? [0, cst_flags$0, args$0] : args$0,
           args$2 = is_help_rec ? [0, cst_r, args$1] : args$1,
           args$3 = is_help ? [0, cst_help$6, args$2] : args$2,
           args$4 = of_list(args$3),
           t$0 = add_help_subcommands(t),
           _bn_ = 0;
          function _bo_(_bp_){return _bp_;}
          return dispatch
                  (t$0,
                   empty,
                   0,
                   path,
                   args$4,
                   0,
                   Version_info$0[6],
                   Version_info$0[7],
                   0,
                   _bo_,
                   _bn_);
         }
         return [0, shape$2, help_for_shape, run$0, deprecated_run];
        }]];
   runtime.caml_register_global(300, Command, cst_Command$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJjb21tYW5kLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlcHJpbnRmIiwicHJpbnRmIiwicHJpbnRfcyIsInByaW50X3N0cmluZyIsInByaW50X2VuZGxpbmUiLCJwcmVycl9lbmRsaW5lIiwic3ByaW50ZiIsImZhaWx3aXRoZiIsImtzcHJpbnRmIiwiYWxsIiwiY29tcGFyZSIsInNleHBfb2ZfdCIsInRvX3N0cmluZyIsInQiLCJmbGFnX25hbWUkMCIsImVycm9yX3NvdXJjZV8wMjIiLCJlcnJvcl9zb3VyY2VfMDY3IiwiZXJyb3Jfc291cmNlXzA4OCIsImVycm9yX3NvdXJjZV8xMDQiLCJlcnJvcl9zb3VyY2VfMTE4IiwiZXJyb3Jfc291cmNlXzE0NSIsImVycm9yX3NvdXJjZV8xNzgiLCJlcnJvcl9zb3VyY2VfMjA2IiwiZXJyb3Jfc291cmNlXzIyMiIsImVycm9yX3NvdXJjZV8yMzYiLCJlcnJvcl9zb3VyY2VfMjYxIiwiZXJyb3Jfc291cmNlXzI5MCIsImVycm9yX3NvdXJjZV8zMjIiLCJlcnJvcl9zb3VyY2VfMzQ3IiwiZXJyb3Jfc291cmNlXzM3MiIsImVycm9yX3NvdXJjZV80MTEiLCJlcnJvcl9zb3VyY2VfNDU2IiwiZW51bWVyYXRlXzQ3NCIsImVudW1lcmF0ZV80NzUiLCJtYXliZV9taXNzaW5nX3ByZWZpeCIsIm1heWJlX21pc3Npbmdfc3VmZml4IiwibWF5YmVfbW9yZV9zdWZmaXgiLCJlcnJvcl9zb3VyY2VfNDk5IiwiaW5kZW50YXRpb24iLCJzcGFjaW5nX2RvdCIsImVycm9yX3NvdXJjZV81MTciLCJlcnJvcl9zb3VyY2VfNTQ2IiwiZXJyb3Jfc291cmNlXzU3NCIsImVycm9yX3NvdXJjZV82MDMiLCJ0X29mX3NleHAiLCJjb21wYXJlJDAiLCJhXzAwNiIsImJfMDA3IiwiYV8wMDYkMCIsImJfMDA3JDAiLCJhXzAwOCIsImJfMDA5IiwiYV8wMTAiLCJiXzAxMSIsImFfMDEyIiwiYl8wMTMiLCJhXzAxNCIsImJfMDE1IiwiYV8wMTYiLCJiXzAxNyIsImFfMDE4IiwiYl8wMTkiLCJ0X29mX3NleHAkMCIsInNleHBfMDI0IiwidGFnXzAyNSIsInNleHBfYXJnc18wNDYiLCJhcmcwXzA0NyIsInJlczBfMDQ4Iiwic2V4cF9hcmdzXzA0MSIsImFyZzBfMDQyIiwicmVzMF8wNDMiLCJzZXhwX2FyZ3NfMDMxIiwiYXJnMF8wMzIiLCJyZXMwXzAzMyIsInNleHBfYXJnc18wMzYiLCJhcmcwXzAzNyIsInJlczBfMDM4Iiwic2V4cF9hcmdzXzAyNiIsImFyZzBfMDI3IiwicmVzMF8wMjgiLCJzZXhwX29mX3QkMCIsImFyZzBfMDQ5IiwicmVzMF8wNTAiLCJhcmcwXzA1MSIsInJlczBfMDUyIiwiYXJnMF8wNTMiLCJyZXMwXzA1NCIsImFyZzBfMDU1IiwicmVzMF8wNTYiLCJhcmcwXzA1NyIsInJlczBfMDU4Iiwic3RhYmxlX3dpdG5lc3NfY2hlY2tzX2Zvcl90Iiwic3RhYmxlX3dpdG5lc3MiLCJpbnZhcmlhbnQiLCJ0JDAiLCJ0JDEiLCJ0cyIsInRfb2Zfc2V4cCQxIiwic2V4cCIsInVzYWdlIiwidXNhZ2UkMCIsInVzYWdlJDEiLCJjb21wYXJlJDEiLCJhXzA1OSIsImJfMDYwIiwiYV8wNjEiLCJiXzA2MiIsImFfMDYzIiwiYl8wNjQiLCJ0X29mX3NleHAkMiIsInNleHBfMDY5IiwidGFnXzA3MCIsInNleHBfYXJnc18wNzEiLCJhcmcwXzA3MiIsInJlczBfMDczIiwic2V4cF9hcmdzXzA3NiIsImFyZzBfMDc3IiwicmVzMF8wNzgiLCJzZXhwX29mX3QkMSIsImFyZzBfMDc5IiwicmVzMF8wODAiLCJhcmcwXzA4MSIsInJlczBfMDgyIiwic3RhYmxlX3dpdG5lc3MkMCIsImNvbXBhcmUkMiIsImFfMDgzIiwiYl8wODQiLCJuIiwibiQwIiwiYV8wODUiLCJiXzA4NiIsInRfb2Zfc2V4cCQzIiwieF8wODkiLCJhbGlhc2VzIiwiZG9jIiwibmFtZSIsInNleHBfb2ZfdCQyIiwiYWxpYXNlc18wOTUiLCJkb2NfMDkzIiwibmFtZV8wOTEiLCJhcmdfMDk2IiwiYm5kc18wOTAiLCJhcmdfMDk0IiwiYm5kc18wOTAkMCIsImFyZ18wOTIiLCJibmRzXzA5MCQxIiwic3RhYmxlX3dpdG5lc3MkMSIsImNvbXBhcmUkMyIsImFfMDk3IiwiYl8wOTgiLCJhXzA5OSIsImJfMTAwIiwibiQxIiwiYV8xMDEiLCJiXzEwMiIsInRfb2Zfc2V4cCQ0IiwieF8xMDUiLCJmbGFncyIsImFub25zIiwicmVhZG1lIiwic3VtbWFyeSIsInNleHBfb2ZfdCQzIiwiZmxhZ3NfMTE1IiwiYW5vbnNfMTEzIiwicmVhZG1lXzEwOSIsInN1bW1hcnlfMTA3IiwiYXJnXzExNiIsImJuZHNfMTA2IiwiYXJnXzExNCIsImJuZHNfMTA2JDAiLCJ2XzExMCIsImFyZ18xMTIiLCJibmRfMTExIiwiYm5kc18xMDYkMSIsImFyZ18xMDgiLCJibmRzXzEwNiQyIiwic3RhYmxlX3dpdG5lc3MkMiIsInRfb2Zfc2V4cCQ1IiwieF8xMTkiLCJzZXhwX29mX3QkNCIsImZsYWdzXzEyOSIsInVzYWdlXzEyNyIsInJlYWRtZV8xMjMiLCJzdW1tYXJ5XzEyMSIsImFyZ18xMzAiLCJibmRzXzEyMCIsImFyZ18xMjgiLCJibmRzXzEyMCQwIiwidl8xMjQiLCJhcmdfMTI2IiwiYm5kXzEyNSIsImJuZHNfMTIwJDEiLCJhcmdfMTIyIiwiYm5kc18xMjAkMiIsInN0YWJsZV93aXRuZXNzJDMiLCJ0b19sYXRlc3QiLCJvZl9sYXRlc3QiLCJncmFtbWFyIiwiZ3JvdXAiLCJjb21wYXJlJDQiLCJjbXBfYSIsImFfMTMxIiwiYl8xMzIiLCJhXzEzMyIsImJfMTM0IiwiYV8xMzUiLCJiXzEzNiIsImFfMTM3IiwiYl8xMzgiLCJ0XzE0MCIsInRfMTM5IiwidF8xNDIiLCJ0XzE0MSIsInRfb2Zfc2V4cCQ2Iiwib2ZfYV8xNDMiLCJ4XzE1MSIsInN1YmNvbW1hbmRzIiwic2V4cF8xNTAiLCJhcmcxXzE0NyIsImFyZzBfMTQ2IiwicmVzMF8xNDgiLCJyZXMxXzE0OSIsInNleHBfb2ZfdCQ1Iiwib2ZfYV8xNTIiLCJzdWJjb21tYW5kc18xNjAiLCJyZWFkbWVfMTU2Iiwic3VtbWFyeV8xNTQiLCJibmRzXzE1MyIsImFyZzFfMTYzIiwiYXJnMF8xNjIiLCJyZXMwXzE2NCIsInJlczFfMTY1IiwiYXJnXzE2MSIsImJuZHNfMTUzJDAiLCJ2XzE1NyIsImFyZ18xNTkiLCJibmRfMTU4IiwiYm5kc18xNTMkMSIsImFyZ18xNTUiLCJibmRzXzE1MyQyIiwic3RhYmxlX3dpdG5lc3MkNCIsImFfc3RhYmxlX3dpdG5lc3MiLCJtYXAiLCJmIiwidF9vZl9zZXhwJDciLCJvZl9hXzE3NiIsInhfMTg0Iiwic2V4cF8xODMiLCJhcmcxXzE4MCIsImFyZzBfMTc5IiwicmVzMF8xODEiLCJyZXMxXzE4MiIsInNleHBfb2ZfdCQ2Iiwib2ZfYV8xODUiLCJzdWJjb21tYW5kc18xOTMiLCJyZWFkbWVfMTg5Iiwic3VtbWFyeV8xODciLCJibmRzXzE4NiIsImFyZzFfMTk2IiwiYXJnMF8xOTUiLCJyZXMwXzE5NyIsInJlczFfMTk4IiwiYXJnXzE5NCIsImJuZHNfMTg2JDAiLCJ2XzE5MCIsImFyZ18xOTIiLCJibmRfMTkxIiwiYm5kc18xODYkMSIsImFyZ18xODgiLCJibmRzXzE4NiQyIiwibWFwJDAiLCJ0b19sYXRlc3QkMCIsIm9mX2xhdGVzdCQwIiwiYWJzX3BhdGgiLCJkaXIiLCJwYXRoIiwiY29tcGFyZSQ1IiwiYV8xOTkiLCJiXzIwMCIsImFfMjAxIiwiYl8yMDIiLCJuJDIiLCJhXzIwMyIsImJfMjA0IiwidF9vZl9zZXhwJDgiLCJ4XzIwNyIsImNoaWxkX3N1YmNvbW1hbmQiLCJwYXRoX3RvX2V4ZSIsIndvcmtpbmdfZGlyIiwic2V4cF9vZl90JDciLCJjaGlsZF9zdWJjb21tYW5kXzIxOSIsInBhdGhfdG9fZXhlXzIxNyIsIndvcmtpbmdfZGlyXzIxNSIsInJlYWRtZV8yMTEiLCJzdW1tYXJ5XzIwOSIsImFyZ18yMjAiLCJibmRzXzIwOCIsImFyZ18yMTgiLCJibmRzXzIwOCQwIiwiYXJnXzIxNiIsImJuZHNfMjA4JDEiLCJ2XzIxMiIsImFyZ18yMTQiLCJibmRfMjEzIiwiYm5kc18yMDgkMiIsImFyZ18yMTAiLCJibmRzXzIwOCQzIiwic3RhYmxlX3dpdG5lc3MkNSIsInRvX2xhdGVzdCQxIiwib2ZfbGF0ZXN0JDEiLCJ0X29mX3NleHAkOSIsInhfMjIzIiwic2V4cF9vZl90JDgiLCJwYXRoX3RvX2V4ZV8yMzMiLCJ3b3JraW5nX2Rpcl8yMzEiLCJyZWFkbWVfMjI3Iiwic3VtbWFyeV8yMjUiLCJhcmdfMjM0IiwiYm5kc18yMjQiLCJhcmdfMjMyIiwiYm5kc18yMjQkMCIsInZfMjI4IiwiYXJnXzIzMCIsImJuZF8yMjkiLCJibmRzXzIyNCQxIiwiYXJnXzIyNiIsImJuZHNfMjI0JDIiLCJzdGFibGVfd2l0bmVzcyQ2IiwidG9fdjMiLCJvZl92MyIsInRvX2xhdGVzdCQyIiwib2ZfbGF0ZXN0JDIiLCJ0X29mX3NleHAkMTAiLCJ4XzIzNyIsInNleHBfb2ZfdCQ5IiwicGF0aF90b19leGVfMjQ1IiwicmVhZG1lXzI0MSIsInN1bW1hcnlfMjM5IiwiYXJnXzI0NiIsImJuZHNfMjM4Iiwidl8yNDIiLCJhcmdfMjQ0IiwiYm5kXzI0MyIsImJuZHNfMjM4JDAiLCJhcmdfMjQwIiwiYm5kc18yMzgkMSIsInN0YWJsZV93aXRuZXNzJDciLCJ0b192MiIsIm9mX3YyIiwidG9fbGF0ZXN0JDMiLCJvZl9sYXRlc3QkMyIsImNvbXBhcmUkNiIsImFfMjQ3IiwiYl8yNDgiLCJhXzI0NyQwIiwiYl8yNDgkMCIsImFfMjQ5IiwiYl8yNTAiLCJhXzI1MSIsImJfMjUyIiwiYV8yNTMiLCJiXzI1NCIsImFfMjU3IiwiYV8yNTUiLCJiXzI1OCIsImJfMjU2IiwidF9vZl9zZXhwJDExIiwic2V4cF8yNjMiLCJ0YWdfMjY0Iiwic2V4cF9hcmdzXzI3MCIsImFyZzBfMjcxIiwicmVzMF8yNzIiLCJzZXhwX2FyZ3NfMjc1IiwiYXJnMV8yNzciLCJhcmcwXzI3NiIsInJlczBfMjc4IiwicmVzMV8yNzkiLCJzZXhwX2FyZ3NfMjY1IiwiYXJnMF8yNjYiLCJyZXMwXzI2NyIsInNleHBfb2ZfdCQxMCIsImFyZzBfMjgwIiwicmVzMF8yODEiLCJhcmcwXzI4MiIsInJlczBfMjgzIiwiYXJnMV8yODUiLCJhcmcwXzI4NCIsInJlczBfMjg2IiwicmVzMV8yODciLCJzdGFibGVfd2l0bmVzc19jaGVja3NfZm9yX3QkMCIsInN0YWJsZV93aXRuZXNzJDgiLCJ0X29mX3NleHAkMTIiLCJzZXhwXzI5MiIsInRhZ18yOTMiLCJzZXhwX2FyZ3NfMzA5IiwiYXJnMF8zMTAiLCJyZXMwXzMxMSIsInNleHBfYXJnc18yOTkiLCJhcmcwXzMwMCIsInJlczBfMzAxIiwic2V4cF9hcmdzXzMwNCIsImFyZzBfMzA1IiwicmVzMF8zMDYiLCJzZXhwX2FyZ3NfMjk0IiwiYXJnMF8yOTUiLCJyZXMwXzI5NiIsInNleHBfb2ZfdCQxMSIsImFyZzBfMzEyIiwicmVzMF8zMTMiLCJhcmcwXzMxNCIsInJlczBfMzE1IiwiYXJnMF8zMTYiLCJyZXMwXzMxNyIsImFyZzBfMzE4IiwicmVzMF8zMTkiLCJzdGFibGVfd2l0bmVzc19jaGVja3NfZm9yX3QkMSIsInRfb2Zfc2V4cCQxMyIsInNleHBfMzI0IiwidGFnXzMyNSIsInNleHBfYXJnc18zMzEiLCJhcmcwXzMzMiIsInJlczBfMzMzIiwic2V4cF9hcmdzXzMzNiIsImFyZzBfMzM3IiwicmVzMF8zMzgiLCJzZXhwX2FyZ3NfMzI2IiwiYXJnMF8zMjciLCJyZXMwXzMyOCIsInNleHBfb2ZfdCQxMiIsImFyZzBfMzM5IiwicmVzMF8zNDAiLCJhcmcwXzM0MSIsInJlczBfMzQyIiwiYXJnMF8zNDMiLCJyZXMwXzM0NCIsInN0YWJsZV93aXRuZXNzX2NoZWNrc19mb3JfdCQyIiwidG9fbGF0ZXN0JDQiLCJiIiwiZyIsImUiLCJvZl9sYXRlc3QkNCIsInRodW5rIiwidF9vZl9zZXhwJDE0Iiwic2V4cF8zNDkiLCJ0YWdfMzUwIiwic2V4cF9hcmdzXzM1NiIsImFyZzBfMzU3IiwicmVzMF8zNTgiLCJzZXhwX2FyZ3NfMzYxIiwiYXJnMF8zNjIiLCJyZXMwXzM2MyIsInNleHBfYXJnc18zNTEiLCJhcmcwXzM1MiIsInJlczBfMzUzIiwic2V4cF9vZl90JDEzIiwiYXJnMF8zNjQiLCJyZXMwXzM2NSIsImFyZzBfMzY2IiwicmVzMF8zNjciLCJhcmcwXzM2OCIsInJlczBfMzY5Iiwic3RhYmxlX3dpdG5lc3NfY2hlY2tzX2Zvcl90JDMiLCJ0b19sYXRlc3QkNSIsIm9mX2xhdGVzdCQ1IiwidF9vZl9zZXhwJDE1Iiwic2V4cF8zNzQiLCJ0YWdfMzc1Iiwic2V4cF9hcmdzXzM4NiIsImFyZzBfMzg3IiwicmVzMF8zODgiLCJzZXhwX2FyZ3NfMzgxIiwiYXJnMF8zODIiLCJyZXMwXzM4MyIsInNleHBfYXJnc18zNzYiLCJhcmcwXzM3NyIsInJlczBfMzc4Iiwic2V4cF9vZl90JDE0IiwiYXJnMF8zODkiLCJyZXMwXzM5MCIsImFyZzBfMzkxIiwicmVzMF8zOTIiLCJhcmcwXzM5MyIsInJlczBfMzk0IiwidjEiLCJ2MCIsInYyIiwidjMiLCJ2MSQwIiwidjIkMCIsInYzJDAiLCJvZl92ZXJzaW9uZWQiLCJjb21wYXJlJDciLCJhXzM5NSIsImJfMzk2IiwiYV8zOTUkMCIsImJfMzk2JDAiLCJhXzM5NyIsImJfMzk4IiwiYV8zOTkiLCJiXzQwMCIsImFfNDAxIiwiYl80MDIiLCJhXzQwMyIsImJfNDA0IiwiYV80MDUiLCJiXzQwNiIsImFfNDA3IiwiYl80MDgiLCJ0X29mX3NleHAkMTYiLCJzZXhwXzQxMyIsInRhZ180MTQiLCJzZXhwX2FyZ3NfNDM1IiwiYXJnMF80MzYiLCJyZXMwXzQzNyIsInNleHBfYXJnc180MzAiLCJhcmcwXzQzMSIsInJlczBfNDMyIiwic2V4cF9hcmdzXzQyMCIsImFyZzBfNDIxIiwicmVzMF80MjIiLCJzZXhwX2FyZ3NfNDI1IiwiYXJnMF80MjYiLCJyZXMwXzQyNyIsInNleHBfYXJnc180MTUiLCJhcmcwXzQxNiIsInJlczBfNDE3Iiwic2V4cF9vZl90JDE1IiwiYXJnMF80MzgiLCJyZXMwXzQzOSIsImFyZzBfNDQwIiwicmVzMF80NDEiLCJhcmcwXzQ0MiIsInJlczBfNDQzIiwiYXJnMF80NDQiLCJyZXMwXzQ0NSIsImFyZzBfNDQ2IiwicmVzMF80NDciLCJjb21wYXJlJDgiLCJhXzQ0OCIsImJfNDQ5IiwiYV80NTAiLCJiXzQ1MSIsImFfNDUyIiwiYl80NTMiLCJ0X29mX3NleHAkMTciLCJzZXhwXzQ1OCIsInRhZ180NTkiLCJzZXhwX2FyZ3NfNDYwIiwiYXJnMF80NjEiLCJyZXMwXzQ2MiIsInNleHBfYXJnc180NjUiLCJhcmcwXzQ2NiIsInJlczBfNDY3Iiwic2V4cF9vZl90JDE2IiwiYXJnMF80NjgiLCJyZXMwXzQ2OSIsImFyZzBfNDcwIiwicmVzMF80NzEiLCJjb21wYXJlJDkiLCJhXzQ3MiIsImJfNDczIiwiYWNjIiwiZW51bWVyYXRlXzQ3OCIsImVudW1lcmF0ZV80NzkiLCJlbnVtZXJhdGVfNDc3IiwiZW51bWVyYXRlXzQ4MCIsImVudW1lcmF0ZV80NzYiLCJhY2MkMCIsImVudW1lcmF0ZV80ODAkMCIsInNleHBfb2ZfdCQxNyIsImF0X21vc3Rfb25jZV80ODQiLCJhdF9sZWFzdF9vbmNlXzQ4MiIsImFyZ180ODUiLCJibmRzXzQ4MSIsImFyZ180ODMiLCJibmRzXzQ4MSQwIiwidG9faGVscF9zdHJpbmciLCJmbGFnX25hbWUiLCJhdF9tb3N0X29uY2UiLCJhdF9sZWFzdF9vbmNlIiwiZGVzY3JpcHRpb24iLCJvZl9oZWxwX3N0cmluZyIsIm5hbWUkMCIsIm5hbWUkMSIsIm5hbWUkMiIsIm5hbWUkMyIsInhfNDg2IiwicyIsInhfNDg3IiwiY29tcGFyZSQxMCIsImFfNDk0IiwiYl80OTUiLCJhXzQ5NiIsImJfNDk3IiwiciIsInRfb2Zfc2V4cCQxOCIsInhfNTAwIiwic2V4cF9vZl90JDE4IiwiYWxpYXNlc181MDYiLCJkb2NfNTA0IiwibmFtZV81MDIiLCJhcmdfNTA3IiwiYm5kc181MDEiLCJhcmdfNTA1IiwiYm5kc181MDEkMCIsImFyZ181MDMiLCJibmRzXzUwMSQxIiwicGFyc2VfbmFtZSIsIm51bV9vY2N1cnJlbmNlcyIsInJlcXVpcmVzX2FyZyIsImhlbHBfc2NyZWVuX2NvbXBhcmUiLCJhIiwic29ydCIsIndvcmRfd3JhcF9hbmRfc3RyaXAiLCJ0ZXh0Iiwid2lkdGgiLCJjaHVua3MiLCJ3b3JkIiwid29yZHMiLCJsaW5lIiwibGluZXMiLCJsaW5lX2FuZF93b3JkIiwic3BhY2VzX3N0cmluZyIsInBhZF9zcGFjZXNfdG9fc3VmZml4IiwieCIsInNsYWNrIiwiaW5kZW50X2FuZF9uZXdsaW5lIiwibGhzX3BhZCIsImRvdF9pbmRlbnRhdGlvbl9vZmZzZXQiLCJ2IiwiZmxhZyIsImZsYWdfbmFtZV93aXRoX2FsaWFzZXMiLCJkb2N1bWVudGF0aW9uIiwiZmxhZ193aWR0aCIsImZsYWdfb25faXRzX293bl9saW5lIiwid3JhcHBlZF9kb2N1bWVudGF0aW9uIiwiZG9jX3dyYXBwZWRfcmVzdF9saW5lcyIsImRvY193cmFwcGVkX2ZpcnN0X2xpbmUiLCJ3cmFwcGVkX2RvY19saW5lcyIsInByZWZpeF9kb2Nfd3JhcHBlZF9maXJzdF9saW5lXyIsInRvX3N0cmluZyQwIiwibG9va3VwX2V4cGFuZCIsImFsaXN0IiwicHJlZml4Iiwia2V5X3R5cGUiLCJpc19kYXNoIiwiZGF0YSIsImtleSIsImFsaXN0JDAiLCJtYXRjaGVzIiwiY3VzdG9tX3ByaW50Zl81MDgiLCJkYXRhJDAiLCJrZXkkMCIsIm1hdGNoaW5nX2tleXMiLCJjdXN0b21fcHJpbnRmXzUwOSIsImNvbXBhcmUkMTEiLCJhXzUxMCIsImJfNTExIiwiYV81MTIiLCJiXzUxMyIsImFfNTE0IiwiYl81MTUiLCJ0X29mX3NleHAkMTkiLCJ4XzUxOCIsInNleHBfb2ZfdCQxOSIsImZsYWdzXzUyOCIsImFub25zXzUyNiIsInJlYWRtZV81MjIiLCJzdW1tYXJ5XzUyMCIsImFyZ181MjkiLCJibmRzXzUxOSIsImFyZ181MjciLCJibmRzXzUxOSQwIiwidl81MjMiLCJhcmdfNTI1IiwiYm5kXzUyNCIsImJuZHNfNTE5JDEiLCJhcmdfNTIxIiwiYm5kc181MTkkMiIsImZpbmRfZmxhZyIsImNob2ljZXMiLCJmbGFnX2luZm8iLCJnZXRfdXNhZ2UiLCJjb21wYXJlJDEyIiwiYV81MzIiLCJiXzUzMyIsImFfNTM0IiwiYl81MzUiLCJhXzUzNiIsImJfNTM3IiwiYV81MzgiLCJiXzUzOSIsInRfNTQxIiwidF81NDAiLCJ0XzU0MyIsInRfNTQyIiwicmVhZG1lJDAiLCJzdW1tYXJ5JDAiLCJ0X29mX3NleHAkMjAiLCJvZl9hXzU0NCIsInhfNTUyIiwic2V4cF81NTEiLCJhcmcxXzU0OCIsImFyZzBfNTQ3IiwicmVzMF81NDkiLCJyZXMxXzU1MCIsInNleHBfb2ZfdCQyMCIsIm9mX2FfNTUzIiwic3ViY29tbWFuZHNfNTYxIiwicmVhZG1lXzU1NyIsInN1bW1hcnlfNTU1IiwiYm5kc181NTQiLCJhcmcxXzU2NCIsImFyZzBfNTYzIiwicmVzMF81NjUiLCJyZXMxXzU2NiIsImFyZ181NjIiLCJibmRzXzU1NCQwIiwidl81NTgiLCJhcmdfNTYwIiwiYm5kXzU1OSIsImJuZHNfNTU0JDEiLCJhcmdfNTU2IiwiYm5kc181NTQkMiIsImZpbmRfc3ViY29tbWFuZCIsImNvbXBhcmUkMTMiLCJhXzU2NyIsImJfNTY4IiwiYV81NjkiLCJiXzU3MCIsImFfNTcxIiwiYl81NzIiLCJ0X29mX3NleHAkMjEiLCJ4XzU3NSIsInNleHBfb2ZfdCQyMSIsImNoaWxkX3N1YmNvbW1hbmRfNTg3IiwicGF0aF90b19leGVfNTg1Iiwid29ya2luZ19kaXJfNTgzIiwicmVhZG1lXzU3OSIsInN1bW1hcnlfNTc3IiwiYXJnXzU4OCIsImJuZHNfNTc2IiwiYXJnXzU4NiIsImJuZHNfNTc2JDAiLCJhcmdfNTg0IiwiYm5kc181NzYkMSIsInZfNTgwIiwiYXJnXzU4MiIsImJuZF81ODEiLCJibmRzXzU3NiQyIiwiYXJnXzU3OCIsImJuZHNfNTc2JDMiLCJjb21wYXJlJDE0IiwiYV81ODkiLCJiXzU5MCIsImFfNTg5JDAiLCJiXzU5MCQwIiwiYV81OTEiLCJiXzU5MiIsImFfNTkzIiwiYl81OTQiLCJhXzU5NSIsImJfNTk2IiwiYV81OTkiLCJhXzU5NyIsImJfNjAwIiwiYl81OTgiLCJ0X29mX3NleHAkMjIiLCJzZXhwXzYwNSIsInRhZ182MDYiLCJzZXhwX2FyZ3NfNjEyIiwiYXJnMF82MTMiLCJyZXMwXzYxNCIsInNleHBfYXJnc182MTciLCJhcmcxXzYxOSIsImFyZzBfNjE4IiwicmVzMF82MjAiLCJyZXMxXzYyMSIsInNleHBfYXJnc182MDciLCJhcmcwXzYwOCIsInJlczBfNjA5Iiwic2V4cF9vZl90JDIyIiwiYXJnMF82MjIiLCJyZXMwXzYyMyIsImFyZzBfNjI0IiwicmVzMF82MjUiLCJhcmcxXzYyNyIsImFyZzBfNjI2IiwicmVzMF82MjgiLCJyZXMxXzYyOSIsImV4cGFuZGVkX3N1YmNvbW1hbmRzIiwiZXhwYW5kIiwic2V4cF9vZl90JDIzIiwiYXJnMF82MzAiLCJyZXMwXzYzMSIsImFyZzBfNjMyIiwicmVzMF82MzMiLCJhcmcwXzYzNCIsInJlczBfNjM1IiwiYXJnMF82MzYiLCJyZXMwXzYzNyIsImV4dHJhY3Rpb25fdmFyIiwiaSIsInN1cHBvcnRlZCIsImluaXQiLCJzdXBwb3J0ZWRfdmVyc2lvbnMiLCJ0b192ZXJzaW9uZWQiLCJsYXRlc3QiLCJ2ZXJzaW9uX3RvX3VzZSIsImZ1bGx5X2ZvcmNlZCIsImdldF9zdW1tYXJ5Iiwib3B0IiwidmVyc2lvbl9saXN0IiwiZW51bWVyYXRlXzAwOCIsImVudW1lcmF0ZV8wMDkiLCJhbnkiLCJleGFjdGx5X29uY2UiLCJyYWlzZV9pbnN0ZWFkX29mX2V4aXQiLCJzdGF0dXNfMDAyIiwiYXJnXzAwMyIsImV4aXQiLCJzdGF0dXMiLCJ1bnBhcmFncmFwaHMiLCJ4cyIsImRpZSIsImZtdCIsIm1zZyIsImtleV9jcmVhdGUiLCJtdWx0aV9hZGQiLCJzZXRfd2l0aF9kZWZhdWx0Iiwia2V5X2ludGVybmFsX3ZhbGlkYXRlX3BhcnNpbmciLCJhcHBseSIsImVycl8xIiwiaW50cm9kdWNlX21pc3NpbmdfcmVxdWlyZWRfZmxhIiwiaGFzX2FyZyIsInJlc3VsdCIsInJldHVybl9ub19hcmciLCJyZXR1cm5fd2l0aF9hcmciLCJlcnJvciIsImVyciIsInJ1bl9hbmRfZXhpdCIsImVudiIsInBhcnQiLCJjb21wbGV0aW9ucyIsImV4dHJhX2RvYyIsInBhcnNlIiwiY3JlYXRlIiwiY29tcGxldGUiLCJvZl9zdHJpbmciLCJtYXAkMSIsIm9mX2xhenkiLCJzdHIiLCJleHRyYV9kb2MkMCIsInN0cmluZyIsImludCQwIiwiY2hhciQwIiwiZmxvYXQkMCIsInNleHBfY29udiIsIm9mX3NleHAiLCJvZl9hbGlzdF9leG4iLCJhY2NlcHRfdW5pcXVlX3ByZWZpeGVzJDAiLCJsaXN0X3ZhbHVlc19pbl9oZWxwJDAiLCJhdXRvX2NvbXBsZXRlIiwic3RoJDEiLCJjYXNlX3NlbnNpdGl2ZSIsInN0aCIsImFjY2VwdF91bmlxdWVfcHJlZml4ZXMiLCJzdGgkMCIsImxpc3RfdmFsdWVzX2luX2hlbHAiLCJtYWtlIiwiY21wIiwiayIsImR1cGxpY2F0ZV9rZXlzIiwiUyIsInVuaXZfbWFwIiwic3VmZml4IiwidmFsdWVzIiwiYXJnIiwidiQwIiwidmFsaWRfYXJndW1lbnRzX2V4dHJhIiwib2ZfbWFwIiwiZW51bWVyYXRlZCIsIkUiLCJlbnVtZXJhdGVkX3NleHBhYmxlIiwiYm9vbCIsImNvbW1hX3NlcGFyYXRlZCIsImFsbG93X2VtcHR5Iiwic3RyaXBfd2hpdGVzcGFjZSIsInVuaXF1ZV92YWx1ZXMiLCJzdHJpcCIsImNvbXBsZXRlX2VsdCIsInRsIiwiaGQiLCJwcmVmaXhlcyIsInNlZW5fYWxyZWFkeSIsImlzX2FsbG93ZWQiLCJjaG9pY2UiLCJjaG9pY2VzJDAiLCJzdHJpbmckMCIsImVudW1lcmF0ZV8wMTIiLCJlbnVtZXJhdGVfMDEzIiwiZW51bWVyYXRlXzAxMSIsImVudW1lcmF0ZV8wMTQiLCJlbnVtZXJhdGVfMDEwIiwiZW51bWVyYXRlXzAxNCQwIiwicGFyc2UkMCIsImFjdGlvbiIsImRvYyQwIiwiYXJnX2RvYyIsImRvYyQxIiwiYXJnX2RvYyQwIiwiY29uY2F0Iiwid3JhcF9pZl9vcHRpb25hbCIsImhlbHAiLCJhbGlnbiIsImNyZWF0ZSQwIiwiYV8wMjAiLCJiXzAyMSIsImFyZ19mbGFnIiwiYXJnX3R5cGUiLCJyZWFkIiwid3JpdGUiLCJ1cGRhdGUiLCJhcmckMCIsImVudiQwIiwibWFwX2ZsYWciLCJpbnB1dCIsIndyaXRlX29wdGlvbiIsInJlcXVpcmVkX3ZhbHVlIiwiZGVmYXVsdCQwIiwicmVxdWlyZWQiLCJvcHRpb25hbF93aXRoX2RlZmF1bHQiLCJvcHRpb25hbCIsInZhbHVlIiwibm9fYXJnX2dlbmVyYWwiLCJpc19yZXF1aXJlZCIsImtleV92YWx1ZSIsImRlcHJlY2F0ZWRfaG9vayIsImFjdGlvbiQwIiwibm9fYXJnIiwibm9fYXJnX3JlcXVpcmVkIiwibm9fYXJnX3JlZ2lzdGVyIiwibm9fYXJnX3NvbWUiLCJsaXN0ZWQiLCJ4XzAyMiIsInZhbHVlX2xpc3QiLCJsaXN0Iiwib25lX29yX21vcmVfYXNfcGFpciIsInhfMDIzIiwicmVzdCIsImZpcnN0IiwicSIsIm9uZV9vcl9tb3JlX2FzX2xpc3QiLCJlc2NhcGVfZ2VuZXJhbCIsInhfMDI0IiwiY21kX2xpbmUiLCJub19hcmdfYWJvcnQiLCJlc2NhcGUiLCJlc2NhcGVfd2l0aF9hdXRvY29tcGxldGUiLCJub19hcmckMCIsImhvb2siLCJlc2NhcGUkMCIsImVtcHR5JDAiLCJjcmVhdGUkMSIsImFwcGVuZCIsInN1YmNvbW1hbmQiLCJwYXJ0cyIsInBhcnRzX2V4ZV9iYXNlbmFtZSIsImxlbmd0aCIsInJlcGxhY2VfZmlyc3QiLCJmcm9tIiwidG8iLCJwYXJ0cyQyIiwicGFydHMkMCIsInBhcnRzJDEiLCJ0b19zdHJpbmdfZG90cyIsImxhc3QiLCJpc19lbXB0eSIsImlzX2ZpeGVkX2FyaXR5Iiwib3RoZXJzIiwibmFtZXMiLCJzJDAiLCJ6ZXJvIiwiY29uY2F0JDAiLCJjZHIiLCJjYXIiLCJ0MiIsInQxIiwiY2RyJDAiLCJjYXIkMCIsInBhcnNlX21vcmUiLCJmb3JfY29tcGxldGlvbiIsInVwZGF0ZV9lbnYiLCJwYXJzZXIiLCJwYWNrX2Zvcl9jb21wbGV0aW9uIiwicHMiLCJzeW1ib2wkMCIsInRfbGVmdCIsInRfcmlnaHQiLCJmX291dGNvbWUiLCJ4X291dGNvbWUiLCJtb3JlIiwidHIiLCJ0ZXN0IiwibW9yZSQwIiwidGVzdCQwIiwicmV0dXJuJDEiLCJzeW1ib2xfbWFwIiwiZnJvbV9lbnYiLCJzeW1ib2xfbWFwJDAiLCJzeW1ib2wkMSIsInJldHVybiQyIiwicmV0dXJuX3dpdGhfYXJnJDAiLCJvbmUiLCJhbm9uIiwic2VxdWVuY2UiLCJsb29wIiwiY29uc3VtZSIsInBhY2tlZCIsInQkMiIsInVwZGF0ZV9lbnYkMCIsInBhcnNlX2ZsYWdzIiwicGFyc2VyJDAiLCJ0JDMiLCJhMSIsImEyIiwidDMiLCJhMyIsInQ0IiwiYTQiLCJub3JtYWxpemUiLCJzdHJsZW4iLCJzcGVjaWFsX2NoYXJzIiwiaGFzX3NwZWNpYWxfY2hhcnMiLCJzeW1ib2wkMiIsIm1hcF9hbm9ucyIsIm1heWJlIiwibWF5YmVfd2l0aF9kZWZhdWx0Iiwic2VxdWVuY2UkMCIsIm5vbl9lbXB0eV9zZXF1ZW5jZV9hc19wYWlyIiwibm9uX2VtcHR5X3NlcXVlbmNlX2FzX2xpc3QiLCJhZF9ob2MiLCJ1c2FnZV9hcmciLCJhXzAyNSIsImJfMDI2IiwiYV8wMjUkMCIsImJfMDI2JDAiLCJhXzAyOSIsImFfMDI3IiwiYl8wMzAiLCJiXzAyOCIsImFfMDMxIiwiYl8wMzIiLCJvZl9saXN0IiwiYXJncyIsInRvX2xpc3QiLCJ4JDAiLCJlbmRzX2luX2NvbXBsZXRlIiwiZXh0ZW5kIiwicGF0aF9saXN0Iiwibm9ybWFsaXplJDAiLCJmbGFnX29yX3N1YmNvbW1hbmQiLCJjIiwiY3VzdG9tX3ByaW50Zl8wMzMiLCJjdXN0b21fcHJpbnRmXzAzNCIsInN1YmNvbW1hbmRfY21wX2ZzdCIsInNoYXBlIiwicGF0aF9rZXkiLCJhcmdzX2tleSIsImhlbHBfa2V5Iiwibm9ybWFsaXplZF9wYXRoIiwibm9ybWFsaXplZF9hcmdzIiwiZ2V0X2ZsYWdfYW5kX2FjdGlvbiIsIm5hbWVfbWF0Y2hpbmciLCJhbGlhc2VzX2V4Y2x1ZGVkX2Zyb21faGVscCIsImFsaWFzZXMkMCIsImFsaWFzIiwiczIiLCJzMSIsImZsYWckMCIsInJ1bl9leG4iLCJleG4iLCJ2ZXJib3NlX29uX3BhcnNlX2Vycm9yIiwiZXhuX3N0ciIsInZlcmJvc2UiLCJlcnJvcl9tc2ciLCJydW4iLCJ3aGVuX3BhcnNpbmdfc3VjY2VlZHMiLCJjbWRsaW5lIiwiaGVscF90ZXh0Iiwib25fZmFpbHVyZSIsInBhcnNlciQxIiwiZW52JDEiLCJjbWRsaW5lJDAiLCJub3JtYWxpemVkX2FyZ3MkMCIsImFyZyQxIiwiYXJncyQwIiwiYXJnJDMiLCJhcmdfaXNfZmxhZyIsImNtZGxpbmUkMSIsImFyZyQyIiwibm9ybWFsaXplZF9hcmdzJDEiLCJmJDEiLCJpbmZvIiwiY29tcGxldGluZyIsImNvbXAiLCJmJDIiLCJlJDAiLCJjb21wJDAiLCJmJDMiLCJhcmdfbGlzdCIsImNtZGxpbmUkMiIsImVudiQyIiwicGFyc2VfZmxhZ3MyIiwiZW52JDMiLCJwYXJzZV9mbGFncyQwIiwibm9ybWFsaXplZF9hcmdzJDIiLCJwYXJ0JDAiLCJmJDAiLCJ0JDQiLCJ0JDUiLCJ0JDYiLCJ0JDciLCJwYXJzZWRfbm9ybWFsaXplZF9hcmdzIiwibWFpbiIsImlzX3VzaW5nX3ZhbGlkYXRlX3BhcnNpbmciLCJ3cmFwX3ZhbHVlIiwiYXBwbHkkMSIsImVtcHR5X3NwZWMiLCJtYXBfb3V0Y29tZSIsIm1hcCQyIiwibG9va3VwIiwiaGVscCQwIiwiaW50JDEiLCJjaGFyJDEiLCJmbG9hdCQxIiwiYm9vbCQwIiwic2V4cCQwIiwic2V4cF9jb252JDAiLCJzcGVjIiwib3V0Y29tZSIsImVzY2FwZV9hbm9uIiwiZmluYWxfYW5vbiIsImZ1bGxfZmxhZ19yZXF1aXJlZCIsIm1vZGUiLCJjaGVja19hdmFpbGFibGUiLCJmbGFnX29wdGlvbmFsX3dpdGhfZGVmYXVsdF9kb2MiLCJzZXhwX29mX2RlZmF1bHQiLCJkZWZhdWx0X3NleHAiLCJjdXN0b21fcHJpbnRmXzAzNSIsInJldHVybiQzIiwib3B0aW9uYWxfdG9fcmVxdWlyZWQiLCJtYXAkMyIsImJvdGgiLCJhcmdfbmFtZXMiLCJmbGFnX25hbWVzIiwiYW5vbl9uYW1lcyIsImFfMDM2IiwiYl8wMzciLCJhXzAzOCIsImJfMDM5IiwiYV8wNDAiLCJiXzA0MSIsInhfMDQyIiwiY3JlYXRlX2V4biIsInJlcXVpcmVkX2FyZ3MiLCJuYW1lc193aXRoX2NvbW1hcyIsInhfMDQzIiwibGlzdF90b19zdHJpbmciLCJjaG9vc2Vfb25lX25vbl9vcHRpb25hbCIsImlmX25vdGhpbmdfY2hvc2VuIiwibmV3X2JlaGF2aW9yIiwibmFtZV9vZl90aGVfZ3JvdXAiLCJmbGFnX2ludGVybmFsIiwiZXhjZXB0IiwibCIsInRzJDAiLCJhcmdfY291bnRlciIsIm1vcmVfdGhhbl9vbmVfZXJyb3IiLCJwYXNzZWQiLCJjdXN0b21fcHJpbnRmXzA0NCIsImVycm9yX2xpc3QiLCJzdWNjZXNzX2xpc3QiLCJ2YWx1ZSQwIiwiY3VzdG9tX3ByaW50Zl8wNDUiLCJjaG9vc2Vfb25lIiwiY2hvb3NlX29uZV9ub25fb3B0aW9uYWwkMCIsImxzdCIsImFuZF9hcmdfbmFtZXMiLCJhbmRfYXJnX25hbWUiLCJwYXJzZSQxIiwicGFyYW1zIiwic3ltYm9sJDYiLCJmMSIsImYyIiwic3ltYm9sJDciLCJwMiIsInN5bWJvbCQ4Iiwic3RlcCIsImNvbnN0JDAiLCJ3cmFwIiwib2ZfcGFyYW0iLCJwIiwidG9fcGFyYW0iLCJtIiwic3RyaW5nJDEiLCJpbnQkMiIsImNoYXIkMiIsImZsb2F0JDIiLCJib29sJDEiLCJzZXhwJDEiLCJzZXhwX2NvbnYkMSIsIm1hcCQ1IiwiZmxhZ3Nfb2ZfYXJnc19leG4iLCJnZW4iLCJmbGFnX3R5cGUiLCJjYWxsIiwic2V0Iiwic2V0X2Jvb2wiLCJyJDAiLCJyJDEiLCJyJDIiLCJyJDMiLCJmJDQiLCJzeW1zIiwic3ltIiwiZiQ1Iiwic2hhcGUkMCIsInN1YmNvbW1hbmRfdG9fc2hhcGUiLCJjb21wX2N3b3JkIiwic2hhcGUkMSIsInNleHBhYmxlX3NoYXBlIiwiYmFzZSIsImV4ZWMiLCJleHRlbmRfZXhuIiwibWVtIiwiYWRkIiwiZXh0ZW5kX21hcF9leG4iLCJleHRlbmRfYWxpc3RfZXhuIiwidGV4dF9zdW1tYXJ5IiwiZmxhZ3MkMCIsImJhc2ljIiwiZmxhZ3MkMSIsImJhc2UkMCIsImJhc2ljX3NwZWMiLCJzdWJzX2tleSIsImxhenlfZ3JvdXAiLCJwcmVzZXJ2ZV9zdWJjb21tYW5kX29yZGVyIiwiYm9keSIsInAkMCIsInBhdGhfdG9fZXhlJDAiLCJwJDEiLCJwJDIiLCJvZl9sYXp5JDAiLCJwcm94eV9vZl9zZXhwYWJsZSIsInNleHBhYmxlIiwicGF0aF90b19zdWJjb21tYW5kIiwia2luZCIsImtpbmRfb2Zfc2V4cGFibGUiLCJwYXRoX3RvX3N1YmNvbW1hbmQkMCIsInByb3h5IiwicHJpbnRfdmVyc2lvbiIsInZlcnNpb24iLCJwcmludF9idWlsZF9pbmZvIiwiYnVpbGRfaW5mbyIsImNvbW1hbmQiLCJ2ZXJzaW9uX2ZsYWciLCJidWlsZF9pbmZvX2ZsYWciLCJhZGQkMCIsInVudmVyc2lvbmVkIiwiYmFzZSQxIiwibm9ybWFsaXplX3ZlcnNpb25fbGluZXMiLCJkZWZhdWx0X3ZlcnNpb24iLCJkZWZhdWx0X2J1aWxkX2luZm8iLCJyZXByaW50X2J1aWxkX2luZm8iLCJ0b19zZXhwIiwieCQxIiwicGF0aCQwIiwiZ2V0X2ZsYWdfbmFtZXMiLCJoZWxwX3JlY3Vyc2l2ZSIsImNtZCIsIndpdGhfZmxhZ3MiLCJleHBhbmRfZG90cyIsImhlbHBfcmVjdXJzaXZlX3JlYyIsImNtZCQwIiwibmV3X3MiLCJiYXNlX2hlbHAiLCJoIiwiZGlzcGxheV9oZWxwX2ZsYWdzIiwiYXV0b2NvbXBsZXRlX2Z1bmN0aW9uIiwiYXJndl8wIiwicGlkIiwiZm5hbWUiLCJwYXRoJDEiLCJiYXNpYyQwIiwicGFyYW0iLCJiYXNpY19vcl9lcnJvciIsIm5vcm1hbGl6ZWRfcGF0aCQwIiwid29yZF93cmFwIiwidG9fc3RyaW5nX2Zvcl9jaG9vc2Vfb25lIiwicnVuJDAiLCJzaGFwZSQyIiwiZ2V0cGlkIiwiY2xvc2UiLCJpbl9jaGFubmVsX29mX2Rlc2NyIiwid2FpdCIsImdldGVudl9hbmRfY2xlYXIiLCJ2YXIkMCIsIm9mX2V4dGVybmFsIiwiaGVscF9zZXhwIiwicHJvZyIsImFyZ3YwIiwicHJvZ19zZWFyY2hfcGF0aCIsIndvcmtpbmdfZGlyJDAiLCJjb252ZXJ0X2NvbW1hbmRfZW52X3Zhcl90b19zdHIiLCJlbnZfdmFyIiwibGlzdCQwIiwibGlzdCQxIiwicHJvY2Vzc19pbmZvIiwic3RhcnRfcmVhZGluZyIsImRlc2NyIiwib3V0cHV0IiwidGhyZWFkIiwib3V0cHV0JDAiLCJmaW5pc2hfc3Rkb3V0IiwiZmluaXNoX3N0ZGVyciIsInN0ZGVyciIsInN0ZG91dCIsImV4biQwIiwic2hhcGVfb2ZfcHJveHkiLCJzaGFwZV9vZl9wcm94eV9raW5kIiwic2hhcGVfb2ZfZXhlIiwiZ3JvdXBfb3JfZXhlY19oZWxwX3RleHQiLCJmb3JtYXRfbGlzdCIsImhlbHBfZm9yX3NoYXBlIiwicmVjdXJzaXZlIiwic3RyaW5nX29mX3BhdGgiLCJmbXQkMCIsImZpbHRlcmVkX3N1YmNvbW1hbmRzIiwic3ViY29tbWFuZHMkMCIsImFkZF9oZWxwX3N1YmNvbW1hbmRzIiwiY21kX29wdCIsInN1YnMiLCJwb3NzaWJseV9leHBhbmRlZF9uYW1lIiwicGF0aCQyIiwicGF0aCQzIiwibWF5YmVfYXBwbHlfZXh0ZW5kIiwiZXh0ZW5kJDAiLCJkaXNwYXRjaCIsIm1heWJlX25ld19jb21wX2N3b3JkIiwiY29tcGxldGVfc3ViY29tbWFuZHMiLCJhcmdzJDEiLCJkaWVfc2hvd2luZ19oZWxwIiwicGFyc2VfZ3JvdXAiLCJtYXliZV9uZXdfY29tcF9jd29yZCQwIiwic2tpcCIsInJlc29sdmUiLCJzdWIiLCJzdWJzJDAiLCJzdWIkMCIsImJvZHkkMCIsInRvX291dHB1dCIsInJlc3Rfb2ZfcmVzdCIsImZpcnN0X29mX3Jlc3QiLCJhcmdzJDIiLCJuZXdfdmFsdWUkMCIsIm5ld192YWx1ZSIsImFkZF92YWxpZGF0ZV9wYXJzaW5nX2ZsYWciLCJhcmd2IiwiYnVpbGRfaW5mbyQwIiwidmVyc2lvbiQwIiwic3VwcG9ydGVkX3ZlcnNpb25zJDAiLCJwYXRoX3RvX3N1YmNvbW1hbmQkMSIsInBhdGhfdG9fc3ViY29tbWFuZCQyIiwiY29tcF9jd29yZCQwIiwiZGVwcmVjYXRlZF9ydW4iLCJpc19oZWxwIiwiaXNfaGVscF9yZWMiLCJpc19oZWxwX3JlY19mbGFncyIsImlzX2V4cGFuZF9kb3RzIiwicGF0aF9zdHJpbmdzIiwiYXJncyQzIiwiYXJncyQ0Il0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY29yZS9jb21tYW5kL2NvbW1hbmRfXy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NvcmUvY29tbWFuZC9pbXBvcnQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlL2NvbW1hbmQvZW52X3Zhci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NvcmUvY29tbWFuZC9zaGFwZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NvcmUvY29tbWFuZC9jb21tYW5kLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0dBY21COztJQUFBOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDWGJBO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBUUFDO0lBQ0FDO0lBQ0FDOzs7Ozs7OztPQWZBUjtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQVFBQztPQUNBQztPQUNBQzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7O0lDZk5DOzs7Ozs7Ozs7OztHQUFBO0lBQUFDOzs7Ozs7WUFBQUM7SUFBQSxzQkFDRSxtQkFDQSxvQkFDQTs7R0FDc0M7WUFFcENDLFVBQVVDO0lBQW1CLFVBTmpDRixVQU1jRTtJQUFtQixPQUFBO0dBQWE7Ozs7OzZCQU45Q0gsU0FBQUQsS0FBQUUsV0FNSUM7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7O0lDcVoyQkU7OztJQWhadkJDO0lBZ0RGQztJQVdBQztJQWFBQztJQVVBQztJQWdDQUM7SUFpQkFDO0lBMkJBQztJQWdCQUM7SUE4QkFDO0lBOEJBQztJQVlBQztJQWNBQztJQXFCQUM7SUFxQkFDO0lBa0NGQztJQWFGQztJQU9BQztJQUFBQztJQU1JQztJQUNBQztJQUNBQztJQWdESkM7SUE2Rk1DO0lBRUFDO0lBdUdOQztJQWlDQUM7SUF3QkFDO0lBV0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBOXFCRTtJQUFBQztJQUFBakM7SUFFSUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBTUEsU0FBQW1DLFVBQUFDLE9BQUFDO0lBQUEsSUFBQUMsVUFBQUYsT0FBQUcsVUFBQUY7SUFBQTtRQUFBQyxZQUFBQyxTQUFBO2VBQUFEO29CQUFBQzs7Ozs7OztlQUFBRDs7ZUFFRUUsUUFGRkY7cUJBQUFDO29CQUFBQSxZQUVFO2VBQUFFLFFBRkZGO1dBRVcsT0FBQSxrQ0FBVEMsT0FBQUM7O2VBRkZDLFFBQUFKO3FCQUFBQztrQkFBQUE7Ozs7a0JBQUFJLFFBQUFKLFlBQUFELFVBQUFJLE9BQUFILFVBQUFJOztzQkFHRTs7O2VBSEZDLFFBQUFOO3FCQUFBQztrQkFBQUE7Ozs7OztrQkFBQU0sUUFBQU4sWUFBQUQsVUFBQU0sT0FBQUwsVUFBQU07O3NCQUlFOzs7ZUFDQUMsUUFMRlI7cUJBQUFDO2tCQUFBQTs7Ozs7Ozs7ZUFLRVEsUUFMRlI7K0JBS2NTLE9BQUFDLE9BQUEsT0FMZGQsVUFLY2EsT0FBQUMsT0FBQztjQUFDLE9BQUEseUNBQWRILE9BQUFDO3NCQUFBOzs7O2VBQ0FHLFFBTkZaO3FCQUFBQztrQkFBQUE7Ozs7Ozs7Y0FLRTs7a0JBQ0FZLFFBTkZaO2NBTWMsT0FBQSxrQ0FBWlcsT0FBQUM7OztRQUZBOztPQURBOztNQURBOztLQURBOztHQU13QztPQVAxQ0M7O0tBQUFBO2NBQUFDO01BQUE7O2dCQUFBQTttQkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FBQUEsT0FBQTttREFBQWhELGtCQUFBZ0Q7O1lBQUEsT0FBQTtrREFBQWhELGtCQUFBZ0Q7O1dBQUEsT0FBQTtpREFBQWhELGtCQUFBZ0Q7O1VBQUEsT0FBQTtnREFBQWhELGtCQUFBZ0Q7O1NBQUEsT0FBQTsrQ0FBQWhELGtCQUFBZ0Q7O1FBQ0U7O2tCQURGQTs7UUFBQSxPQUFBOytDQUFBaEQsa0JBQUFnRDs7O1FBQUEsT0FBQTsrQ0FBQWhELGtCQUFBZ0Q7V0FNRUMsOENBQUFBOzs7Ozs7Ozs7Ozs7O3dDQUFBQTt3Q0FBQUE7d0NBQUFBO3dDQUFBQTtzQ0FBQUE7Ozs7eUNBQUFBO3VDQUFBQTt1Q0FBQUE7dUNBQUFBO3VDQUFBQTtxQ0FBQUE7OztnQkFBQUM7ZUFBQUEsbUJBQUFBO2FBQUE7Y0FBQUMsV0FBQUQ7Y0FBQUUsV0FBQSxtQ0FBQUQ7YUFBQSxXQUFBQzs7WUFBQSxPQUFBOztxQkFORnBEO3FCQU1FaUQ7cUJBTkZEOztlQUtFSztjQUFBQSxtQkFBQUE7WUFBQTthQUFBQyxXQUFBRDthQUFBRTtlQUFBLG1DQUxGUixhQUtFTztZQUFBLFdBQUFDOztXQUFBLE9BQUE7O29CQUxGdkQ7b0JBTUVpRDtvQkFORkQ7O2NBR0VRO2FBQUFBLG1CQUFBQTtXQUFBO1lBQUFDLFdBQUFEO1lBQUFFLFdBQUEsV0FIRlgsYUFHRVU7V0FBQSxXQUFBQzs7VUFBQSxPQUFBOzttQkFIRjFEO21CQU1FaUQ7bUJBTkZEOzthQUlFVztZQUFBQSxtQkFBQUE7VUFBQTtXQUFBQyxXQUFBRDtXQUFBRSxXQUFBLFdBSkZkLGFBSUVhO1VBQUEsV0FBQUM7O1NBQUEsT0FBQTs7a0JBSkY3RDtrQkFNRWlEO2tCQU5GRDs7WUFFRWM7V0FBQUEsbUJBQUFBO1NBQUE7VUFBQUMsV0FBQUQ7VUFBQUUsV0FBQSxtQ0FBQUQ7U0FBQSxXQUFBQzs7UUFBQSxPQUFBOztpQkFGRmhFO2lCQU1FaUQ7aUJBTkZEOztPQUFBLE9BQUE7NkNBQUFoRCxrQkFBQWdEOztNQUFBLE9BQUE7NkNBQUFoRCxrQkFBQWdEO0tBTzBDO1lBUDFDaUI7SUFBQSw4QkFDRTs7O09BQ0E7UUFBQUM7UUFBQUMsV0FBQSxrQ0FBQUQ7T0FBQSx3QkFBQUM7O09BQ0EsSUFBQUMscUJBQUFDLFdBSEZKLFlBR0VHO09BQUEsd0JBQUFDOztPQUNBLElBQUFDLHFCQUFBQyxXQUpGTixZQUlFSztPQUFBLHdCQUFBQzs7T0FDQTtRQUFBQztRQUFBQyxXQUFBLG1DQUxGUixhQUtFTztPQUFBLHdCQUFBQzs7T0FDQTtRQUFBQztRQUFBQyxXQUFBLGtDQUFBRDtPQUFBLHdCQUFBQzs7R0FDd0M7O0lBUDFDQztJQUFLQztxQkFBTEQsNkM7WUF5VkFFLFVBaFZrQmhGOztLQUVkLFVBRmNBLGdCQUdKO1lBSElBOztRQUlIOztZQUVKaUYsTUFOT2pGO3NCQU1QaUY7a0JBRFE7a0JBMlVuQkQsVUExVVdDOztZQUVDQyxNQVJNbEY7c0JBUU5rRjtrQkFEUTtrQkF5VXBCRixVQXhVWUU7O1lBRUNDLEtBVktuRjtXQVVMbUYsTUFBQUEsd0NBQUFBLElBc1ViSDtRQXZVa0MsT0FBQTtnQkFFaEI7O0lBQUU7SUFWK0IsT0FBQSxtQ0FEakNoRixHQVRsQm1FO0dBb0JxQjtZQUdqQmlCLFlBQVVDO0lBQ0osSUFBSnJGLElBQUksV0F4QlZpRCxhQXVCY29DO0lBa1VkTCxVQWpVTWhGO0lBQ0osT0FESUE7R0FFSDtZQWdVSHNGO0lBM1RFLDhCQUNVOzs7V0FDSkMsb0JBQVMsT0FBVEE7O1dBR0N2RjtpQkFBQUE7UUFGUSxPQUFBO2dCQUVSQTtRQURtQyxXQXVUNUNzRixNQXRUU3RGO1FBRG1DLE9BQUE7O09BQ1QsV0FzVG5Dc0YsTUF0VFN0RjtPQUEwQixPQUFBOztXQUV6QmlGO2lCQUFBQTtRQURRLE9BQUE7T0FDWSxXQW9UOUJLLE1BcFRVTDtPQUFvQixPQUFBOztPQUNlLElBQWxDRSxlQUFrQyxPQUFBLDBCQUFsQ0EsSUFtVFhHO09BblQ2QyxPQUFBO21CQUNsQ0Usb0JBQVMsT0FBVEE7O0dBQWM7WUFRM0JDLFVBQUFDLE9BQUFDO0lBQUEsR0FBQUQsVUFBQUMsT0FBQTthQUFBRDtTQUNFRSxRQURGRjtjQUFBQyxVQUNFO1NBQUFFLFFBREZGO0tBQ2EsT0FBQSxrQ0FBWEMsT0FBQUM7O1FBQ0FDLFFBRkZKO2FBQUFDLFVBQ0U7UUFDQUksUUFGRko7SUFFZSxPQWxEYjNELFVBa0RBOEQsT0FBQUM7R0FDd0M7WUFIMUNDLFlBQUFDO0lBQUE7O2NBQUFBO2lCQUFBQTs7Ozs7OztPQUFBLE9BQUE7NkNBQUE5RixrQkFBQThGOztNQUFBLE9BQUE7NENBQUE5RixrQkFBQThGOztnQkFBQUE7O01BQUEsT0FBQTs2Q0FBQTlGLGtCQUFBOEY7OztNQUFBLE9BQUE7NkNBQUE5RixrQkFBQThGO1NBRUVDOzs2QkFBQUE7OEJBQUFBO2lDQUFBQTsrQkFBQUE7O1VBREFDO1NBQUFBLG1CQUFBQTtPQUFBO1FBQUFDLFdBQUFEO1FBQUFFLFdBQUEsbUNBQUFEO09BQUEsV0FBQUM7O01BQUEsT0FBQTs7ZUFERmxHO2VBRUUrRjtlQUZGRDs7U0FFRUs7UUFBQUEsbUJBQUFBO01BQUEsSUFBQUMsV0FBQUQsa0JBQUFFLFdBM0JJcEIsWUEyQkptQjtNQUFBLFdBQUFDOztLQUFBLE9BQUE7O2NBRkZyRztjQUVFK0Y7Y0FGRkQ7O0lBQUEsT0FBQTsyQ0FBQTlGLGtCQUFBOEY7R0FHMEM7WUFIMUNRO0lBQUE7S0FDRTtNQUFBQztNQUFBQyxXQUFBLGtDQUFBRDtLQUFBLHdCQUFBQzs7SUFDQSxJQUFBQyxxQkFBQUMsV0FsREExQyxZQWtEQXlDO0lBQUEsd0JBQUFDO0dBQ3dDO09BSHJDQztHQVdMLFNBQUFDLFVBQUFDLE9BQUFDO0lBQ1csR0FEWEQsVUFBQUMsT0FDVztJQUFBLElBQUFDLElBQUEsa0NBRFhGLFVBQUFDO2FBQ1dDLEdBQUEsT0FBQUE7SUFDRCxJQUFBQyxNQUFBLGtDQUZWSCxVQUFBQzthQUVVRSxLQUFBLE9BQUFBO2VBRlZGLGlCQUFBRDtrQkFHY0ksT0FBQUM7S0FBQSxPQUFBLGtDQUFBRCxPQUFBQztJQUFNOztHQUZIO0dBRGpCLFNBQUFDLFlBQUFDOztLQUFBOztNQUdJQztNQURBQztNQURBQztLQURKLFdBQ0lBLE1BQ0FELEtBQ0FEO0lBRXNDO0lBTDFDOztLQUFBOzs7Ozs7SUFLMEM7SUFMMUM7Ozs7O1FBQUE7O0lBQUEsT0FBQTs7YUFBQXBIOzs7Ozs7Ozs7YUFBQW1IO0dBSzBDO1lBTDFDSTtJQUFBO0tBR0lDO0tBREFDO0tBREFDO0tBRUFDO09BQUEsMERBQUFIO0tBSEpJLGdDQUdJRDtLQURBRSxVQUFBLGtDQUFBSjtLQUZKSyxrQ0FFSUQsZUFGSkQ7S0FDSUcsVUFBQSxrQ0FBQUw7S0FESk0sa0NBQ0lELGVBREpEO0lBQUEsV0FBQUU7R0FLMEM7T0FMckNDO1lBYUxDLFVBQUFDLE9BQUFDO0lBQ2MsR0FEZEQsVUFBQUMsT0FDYztJQUFBLElBQUF0QixJQUFBLGtDQURkcUIsVUFBQUM7YUFDY3RCLEdBQUEsT0FBQUE7ZUFEZHNCLGlCQUFBRDtrQkFFYUUsT0FBQUM7S0FBQSxPQUFBLGtDQUFBRCxPQUFBQztJQUFNO0lBQUMsSUFBQXZCLE1BQUE7YUFBQUEsS0FBQSxPQUFBQTtJQUNSLElBQUF3QixNQTNCWmxELFVBd0JBOEMsVUFBQUM7YUFHWUcsS0FBQSxPQUFBQTtlQUhaSCxpQkFBQUQ7a0JBSVlLLE9BQUFDLE9BQUEsT0FqQlo5QixVQWlCWTZCLE9BQUFDLE9BQWM7O0dBSE47WUFEcEJDLFlBQUFDOztLQUFBOzs7TUFJSUM7TUFEQUM7TUFEQUM7TUFEQUM7S0FESixXQUNJQSxTQUNBRCxRQUNBRCxPQUNBRDtJQUVzQztJQU4xQzs7S0FBQTs7Ozs7Ozs7O0lBTTBDO0lBTjFDOzs7OztRQXhCQWhEOzBCQXdCQSxtQ0FiQXNCO0lBYUEsT0FBQTs7YUFBQWpIOzs7Ozs7Ozs7YUFBQTBJO0dBTTBDO1lBTjFDSztJQUFBO0tBSUlDO0tBREFDO0tBREFDO0tBREFDO0tBR0FDLFVBQUEsbUNBakJKOUIsYUFpQkkwQjtLQUpKSyxnQ0FJSUQ7S0FEQUUsVUEzQkpsRCxZQTJCSTZDO0tBSEpNLGtDQUdJRCxlQUhKRDtJQUVJLEdBQUFIO0tBQUE7TUFBQU0sUUFBQU47TUFBQU8sVUFBQSxrQ0FBQUQ7TUFBQUUsMkJBQUFEO01BRkpFLGlCQUVJRCxTQUZKSDs7U0FBQUksYUFBQUo7SUFDSTtLQUFBSyxVQUFBLGtDQUFBVDtLQURKVSxrQ0FDSUQsZUFESkQ7SUFBQSxXQUFBRTtHQU0wQztPQU5yQ0M7WUFVTEMsWUFBQUM7O0tBQUE7OztNQUlJckI7TUFEQTFEO01BREE0RDtNQURBQztLQURKLFdBQ0lBLFNBQ0FELFFBQ0E1RCxPQUNBMEQ7SUFFNkI7SUFOakM7O0tBQUE7Ozs7Ozs7OztJQU1pQztJQU5qQzs7MkJBQUEsbUNBdkJBMUI7SUF1QkEsT0FBQTs7YUFBQWhIOzs7Ozs7Ozs7Ozs7O2FBQUErSjtHQU1pQztZQU5qQ0M7SUFBQTtLQUlJQztLQURBQztLQURBQztLQURBQztLQUdBQyxVQUFBLG1DQTNCSmhELGFBMkJJNEM7S0FKSkssZ0NBSUlEO0tBREFFLFVBQUEsa0NBQUFMO0tBSEpNLGtDQUdJRCxlQUhKRDtJQUVJLEdBQUFIO0tBQUE7TUFBQU0sUUFBQU47TUFBQU8sVUFBQSxrQ0FBQUQ7TUFBQUUsMkJBQUFEO01BRkpFLGlCQUVJRCxTQUZKSDs7U0FBQUksYUFBQUo7SUFDSTtLQUFBSyxVQUFBLGtDQUFBVDtLQURKVSxrQ0FDSUQsZUFESkQ7SUFBQSxXQUFBRTtHQU1pQztPQU41QkM7WUFRREM7O0tBQW9DdEM7S0FBUDFEO0tBQVI0RDtLQUFUQztJQUNkLFdBRGNBLFNBQVNELFlBQVE1RCxRQUFPMEQ7O1lBSXBDdUM7O0tBQXVDdkM7S0FBUEM7S0FBUkM7S0FBWkM7YUFBb0JGO1NBS3JCMUQsVUFMcUIwRCxVQUtyQnpELFVBQUFEOztTQUNFaUcsVUFObUJ2QyxVQUtyQnpELFVBdVBiRixNQXRQZWtHO0lBTGYsV0FEY3JDLFNBQVlELFFBS2IxRCxTQUw0QndEOztHQWdCeEM7SUFBQSxNQUFBO0lBQUwsY0FBSztJQUFMLE1BQUE7SUFBQXlDLFFBQUE7SUFBQSxNQUFBO0dBQUEsV0FBQSwrQkFBQUE7WUFJRUMsVUFBQUMsT0FBQUMsT0FBQUM7SUFDYyxHQURkRCxVQUFBQyxPQUNjO0lBQUEsSUFBQTNFLElBQUEsa0NBRGQwRSxVQUFBQzthQUNjM0UsR0FBQSxPQUFBQTtlQURkMkUsaUJBQUFEO2tCQUVhRSxPQUFBQztLQUFBLE9BQUEsa0NBQUFELE9BQUFDO0lBQU07SUFBQyxJQUFBNUUsTUFBQTthQUFBQSxLQUFBLE9BQUFBO2VBRnBCMEUsaUJBQUFEOzthQXhIRS9MO3NCQTJIZ0JtTSxPQUFBQzs0QkFBQ0MsT0FBQUM7ZUFBQTtnQkFBQUMsUUFBQUY7Z0JBQUFHLFFBQUFIO2dCQUFBSSxRQUFBSDtnQkFBQUksUUFBQUo7Z0JBQUFqRixJQUFBLGtDQUFBbUYsT0FBQUU7NEJBQUFyRixJQUFTLFdBSDVCeUUsT0FHbUJTLE9BQUFFLFNBQUFwRjtjQUFXO2NBQUUsT0FBQSx5Q0FBZDhFLE9BQUFDO2FBQWtCOzs7R0FGaEI7WUFEcEJPLFlBQUtDLFVBQUxDOztLQUFBOztNQUdJQztNQURBekQ7TUFEQUM7S0FESixXQUNJQSxTQUNBRCxRQUNBeUQ7SUFFc0M7SUFMMUM7O0tBQUE7Ozs7OztJQUswQztJQUwxQztrQkFHbUJDO0tBQUQsU0FBQ0E7aUJBQUFBOzs7O1FBQUE7U0FBQUM7U0FBQUM7U0FBQUMsV0FBQSxtQ0FBQUQ7U0FBQUUsV0FBQSxXQUhkUCxVQUdjSTtRQUFBLFdBQUFFLFVBQUFDOzs7O0tBQUEsT0FBQTsyQ0FIbkJ6TSxxQkFHbUJxTTtJQUFpQjtJQUhwQzs7Ozs7UUFBQSxXQTFIRjdLLFdBNkhvQjs7SUFIbEIsT0FBQTs7YUFBQXhCOzs7Ozs7Ozs7YUFBQW1NO0dBSzBDO1lBTDFDTyxZQUFLQztJQUFMO0tBR0lDO0tBREFDO0tBREFDO0tBREpDOzs7TUFHbUJDO01BQUFDO01BQUFDLDZDQUFBRDtNQUFBRSxzQkFIZFIsVUFHY0s7b0JBQUFFLGNBQUFDOztJQUFmO0tBQUFDO09BQUE7U0E3SE43TixxREE2SE1xTjtLQUhKUyxrQ0FHSUQsZUFISkw7SUFFSSxHQUFBRjtLQUFBO01BQUFTLFFBQUFUO01BQUFVLFVBQUEsa0NBQUFEO01BQUFFLDJCQUFBRDtNQUZKRSxpQkFFSUQsU0FGSkg7O1NBQUFJLGFBQUFKO0lBQ0k7S0FBQUssVUFBQSxrQ0FBQVo7S0FESmEsa0NBQ0lELGVBREpEO0lBQUEsV0FBQUU7R0FLMEM7WUFMbENDLGlCQUFIQyxrQjtZQXFpQkxDLElBNWhCUXJPLEdBQUdzTztJQUNUO3dCLDhCQURTQTtJQUNjLFdBQUEsMEJBRGpCdE87SUFDTixXQURNQSxNQUFBQTtHQUNnRTtHQU94RSxTQUFBdU8sWUFBS0MsVUFBTEM7O0tBQUE7O01BR0k5QjtNQURBekQ7TUFEQUM7S0FESixXQUNJQSxTQUNBRCxRQUNBeUQ7SUFFc0M7SUFMMUM7O0tBQUE7Ozs7OztJQUswQztJQUwxQztrQkFHbUIrQjtLQUFELFNBQUNBO2lCQUFBQTs7OztRQUFBO1NBQUFDO1NBQUFDO1NBQUFDLFdBQUEsbUNBQUFEO1NBQUFFLFdBQUEsV0FIZE4sVUFHY0c7UUFBQSxXQUFBRSxVQUFBQzs7OztLQUFBLE9BQUE7MkNBSG5CdE8scUJBR21Ca087SUFBaUI7SUFIcEM7Ozs7O1FBQUE7O0lBQUEsT0FBQTs7YUFBQWxPOzs7Ozs7Ozs7YUFBQWlPO0dBSzBDO1lBTDFDTSxZQUFLQztJQUFMO0tBR0lDO0tBREFDO0tBREFDO0tBREpDOzs7TUFHbUJDO01BQUFDO01BQUFDLDZDQUFBRDtNQUFBRSxzQkFIZFIsVUFHY0s7b0JBQUFFLGNBQUFDOztJQUFmO0tBQUFDLFVBQUEseUNBQUFSO0tBSEpTLGtDQUdJRCxlQUhKTDtJQUVJLEdBQUFGO0tBQUE7TUFBQVMsUUFBQVQ7TUFBQVUsVUFBQSxrQ0FBQUQ7TUFBQUUsMkJBQUFEO01BRkpFLGlCQUVJRCxTQUZKSDs7U0FBQUksYUFBQUo7SUFDSTtLQUFBSyxVQUFBLGtDQUFBWjtLQURKYSxrQ0FDSUQsZUFESkQ7SUFBQSxXQUFBRTtHQUswQztZQUl0Q0MsTUFBSWpRLEdBQUdzTztJQUEyQixXQUFBLDhCQUE5QnRPLE1BQUdzTztJQUFJLFdBQVB0TyxNQUFBQTtHQUErRDtZQUVuRWtRO1FBQTZCdkQsd0JBQVJ6RCxtQkFBVEM7SUFDZCxXQURjQSxTQUFTRCxRQUNVLDBCQURGeUQ7O1lBSTdCd0Q7O0tBQThCeEQ7S0FBUnpEO0tBQVRDO3lCQUFpQndEOzs7Z0JBQUFBOztpREFBQUE7Z0RBQUFBOztJQUNoQyxXQURleEQsU0FBU0Q7O1lBcWxCMUJrSCxTQTlrQllDLEtBQUlDO0lBQ2hCLE9BQUcsOEJBRGFBO2NBQUFBO2NBQ2lDLDhCQURyQ0QsS0FBSUM7R0FDOEQ7R0FJOUUsU0FBQUMsVUFBQUMsT0FBQUM7SUFDYyxHQURkRCxVQUFBQyxPQUNjO0lBQUEsSUFBQXZKLElBQUEsa0NBRGRzSixVQUFBQzthQUNjdkosR0FBQSxPQUFBQTtlQURkdUosaUJBQUFEO2tCQUVhRSxPQUFBQztLQUFBLE9BQUEsa0NBQUFELE9BQUFDO0lBQU07SUFBQyxJQUFBeEosTUFBQTthQUFBQSxLQUFBLE9BQUFBO0lBQ0YsSUFBQXdCLE1BQUEsa0NBSGxCNkgsVUFBQUM7YUFHa0I5SCxLQUFBLE9BQUFBO0lBQ0EsSUFBQWlJLE1BQUEsa0NBSmxCSixVQUFBQzthQUlrQkcsS0FBQSxPQUFBQTtlQUpsQkgsaUJBQUFEO2tCQUt1QkssT0FBQUM7S0FBQSxPQUFBLGtDQUFBRCxPQUFBQztJQUFNOztHQUpUO0dBRHBCLFNBQUFDLFlBQUFDOztLQUFBOzs7O01BS0lDO01BREFDO01BREFDO01BREFqSTtNQURBQztLQURKLFdBQ0lBLFNBQ0FELFFBQ0FpSSxhQUNBRCxhQUNBRDtJQUVzQztJQVAxQzs7S0FBQTs7Ozs7Ozs7Ozs7O0lBTzBDO0lBUDFDOzs7OztRQUFBOztJQUFBLE9BQUE7O2FBQUF4UTs7Ozs7Ozs7Ozs7Ozs7Ozs7YUFBQXVRO0dBTzBDO1lBUDFDSTtJQUFBO0tBS0lDO0tBREFDO0tBREFDO0tBREFDO0tBREFDO0tBSUFDO09BQUE7d0RBQUFMO0tBTEpNLGdDQUtJRDtLQURBRSxVQUFBLGtDQUFBTjtLQUpKTyxrQ0FJSUQsZUFKSkQ7S0FHSUcsVUFBQSxrQ0FBQVA7S0FISlEsa0NBR0lELGVBSEpEO0lBRUksR0FBQUw7S0FBQTtNQUFBUSxRQUFBUjtNQUFBUyxVQUFBLGtDQUFBRDtNQUFBRSwyQkFBQUQ7TUFGSkUsaUJBRUlELFNBRkpIOztTQUFBSSxhQUFBSjtJQUNJO0tBQUFLLFVBQUEsa0NBQUFYO0tBREpZLGtDQUNJRCxlQURKRDtJQUFBLFdBQUFFO0dBTzBDO09BUHJDQztZQVNEQyxrQjtZQUNBQyxrQjtHQU1KLFNBQUFDLFlBQUFDOztLQUFBOzs7TUFJSXhCO01BREFDO01BREFqSTtNQURBQztLQURKLFdBQ0lBLFNBQ0FELFFBQ0FpSSxhQUNBRDtJQUU2QjtJQU5qQzs7S0FBQTs7Ozs7Ozs7O0lBTWlDO0lBTmpDLE9BQUE7O2FBQUF4UTs7Ozs7Ozs7Ozs7Ozs7Ozs7YUFBQWdTO0dBTWlDO1lBTmpDQztJQUFBO0tBSUlDO0tBREFDO0tBREFDO0tBREFDO0tBR0FDLFVBQUEsa0NBQUFKO0tBSkpLLGdDQUlJRDtLQURBRSxVQUFBLGtDQUFBTDtLQUhKTSxrQ0FHSUQsZUFISkQ7SUFFSSxHQUFBSDtLQUFBO01BQUFNLFFBQUFOO01BQUFPLFVBQUEsa0NBQUFEO01BQUFFLDJCQUFBRDtNQUZKRSxpQkFFSUQsU0FGSkg7O1NBQUFJLGFBQUFKO0lBQ0k7S0FBQUssVUFBQSxrQ0FBQVQ7S0FESlUsa0NBQ0lELGVBREpEO0lBQUEsV0FBQUU7R0FNaUM7T0FONUJDO1lBUURDLE1BQU0zVCxHQUNSLFdBRFFBLE1BQUFBLE1BQUFBLE1BQUFBLFNBTVA7WUFHQzRULE1BQU81VDtJQUlPLFdBb2lCbEJvUSxTQXhpQldwUSxNQUFBQTtJQUNULFdBRFNBLE1BQUFBLE1BQUFBO0dBS1I7R0FHYTtJQUFaNlQsY0FBWSx1QkFoQ1p0QixhQWVBb0I7SUFrQkFHLGNBQVksdUJBVFpGLE9BdkJBcEI7R0FvQ0osU0FBQXVCLGFBQUFDOztLQUFBOztNQUlJOUM7TUFGQWhJO01BREFDO0tBREosV0FDSUEsU0FDQUQsUUFFQWdJO0lBRTZCO0lBTmpDOztLQUFBOzs7Ozs7SUFNaUM7SUFOakMsT0FBQTs7YUFBQXZROzs7Ozs7Ozs7Ozs7O2FBQUFxVDtHQU1pQztZQU5qQ0M7SUFBQTtLQUlJQztLQUZBQztLQURBQztLQUdBQyxVQUFBLGtDQUFBSDtLQUpKSSxnQ0FJSUQ7SUFGQSxHQUFBRjtLQUFBO01BQUFJLFFBQUFKO01BQUFLLFVBQUEsa0NBQUFEO01BQUFFLDJCQUFBRDtNQUZKRSxpQkFFSUQsU0FGSkg7O1NBQUFJLGFBQUFKO0lBQ0k7S0FBQUssVUFBQSxrQ0FBQVA7S0FESlEsa0NBQ0lELGVBREpEO0lBQUEsV0FBQUU7R0FNaUM7T0FONUJDO1lBUURDLE1BQU05VSxHQUNSLFdBRFFBLE1BQUFBLGFBQUFBLE1BS1A7WUFHQytVLE1BQU8vVTtJQUdPLFdBd2dCbEJvUSxTQTNnQldwUSxNQUFBQTtJQUNULFdBRFNBLE1BQUFBO0dBSVI7R0FHYTtJQUFaZ1YsY0FBWSx1QkE1QlpuQixhQWFBaUI7SUFnQkFHLGNBQVksdUJBUlpGLE9BcEJBakI7WUFrQ0pvQixVQUFBQyxPQUFBQztJQUFBLElBQUFDLFVBQUFGLE9BQUFHLFVBQUFGO0lBQUE7UUFBQUMsWUFBQUMsU0FBQTtZQUFBRDs7WUFDRUUsUUFERkY7aUJBQUFDLFlBQ0U7WUFBQUUsUUFERkY7UUFDYSxPQW5LYmhOLFVBbUtFaU4sT0FBQUM7O1lBQ0FDLFFBRkZKO2VBQUFDOzs7ZUFFRUksUUFGRko7V0FFZSxPQTFIZjVKOzZCQTBIYWlLLE9BQUFDLE9BQUEsT0FGYlYsVUFFYVMsT0FBQUMsT0FBQztvQkFBWkg7b0JBQUFDO21CQUFBOzs7O1lBRkZHLFFBQUFSLFlBR0VTLFFBSEZUO2VBQUFDOzs7V0FFRTs7V0FDVTtZQUhaUyxRQUFBVDtZQUdFVSxRQUhGVjtZQUdZcE8sSUEvRVpxSixVQStFRXVGLE9BQUFFO29CQUFVOU8sR0FBQSxPQUFBQTtlQUhabU8sVUFBQVEsT0FBQVAsVUFBQVM7Ozs7S0FDRTs7R0FHd0M7T0FKMUNFOztLQUFBQTtjQUFBQztNQUFBOztnQkFBQUE7bUJBQUFBOzs7Ozs7Ozs7O1VBQUEsT0FBQTtnREFBQXRWLGtCQUFBc1Y7O1NBQUEsT0FBQTsrQ0FBQXRWLGtCQUFBc1Y7O1FBQUEsT0FBQTs4Q0FBQXRWLGtCQUFBc1Y7O2tCQUFBQTs7UUFBQSxPQUFBOytDQUFBdFYsa0JBQUFzVjs7O1FBQUEsT0FBQTsrQ0FBQXRWLGtCQUFBc1Y7V0FDRUM7OytCQUFBQTs7Z0NBQUFBO2lDQUFBQTtvQ0FBQUE7b0NBQUFBO2tDQUFBQTs7YUFDQUM7WUFBQUEsbUJBQUFBO1VBQUE7V0FBQUMsV0FBQUQ7V0FBQUUsV0ExSEY5SixZQXdIQXlKLGNBRUVJO1VBQUEsV0FBQUM7O1NBQUEsT0FBQTs7a0JBRkYxVjtrQkFDRXVWO2tCQURGRDs7WUFHRUs7UUFBQSxHQUFBQTtvQkFBQUE7O1VBQUE7V0FBQUM7V0FBQUMsV0FBQUY7V0FBQUcsV0EvRUYzRixZQStFRTBGO1dBQUFFLFdBQUEsV0FIRlYsY0FHRU87VUFBQSxXQUFBRSxVQUFBQzs7O1FBQUEsT0FBQTs7aUJBSEYvVjtpQkFDRXVWO2lCQURGRDs7V0FDRVU7VUFBQUEsbUJBQUFBO1FBQUEsSUFBQUMsV0FBQUQsa0JBQUFFLFdBbktGaE8sWUFtS0UrTjtRQUFBLFdBQUFDOztPQUFBLE9BQUE7O2dCQURGbFc7Z0JBQ0V1VjtnQkFERkQ7O01BQUEsT0FBQTs2Q0FBQXRWLGtCQUFBc1Y7S0FJMEM7WUFKMUNhO0lBQUE7O09BQ0UsSUFBQUMscUJBQUFDLFdBbktGN04sWUFtS0U0TjtPQUFBLHdCQUFBQzs7T0FDQTtRQUFBQztRQUFBQyxXQTFIRmxLLFlBd0hBOEosY0FFRUc7T0FBQSx3QkFBQUM7O09BQ0E7UUFBQUM7UUFBQUM7UUFBQUMsV0EvRUZsRyxZQStFRWlHO1FBQUFFLFdBSEZSLGFBR0VLO09BQUEsd0JBQUFFLGNBQUFDOztHQUN3Qzs7SUFKMUNDOztJQUFLQzs7S0FBTEQsK0M7T0FZQUU7O0tBQUFBO2NBQUFDO01BQUE7O2dCQUFBQTttQkFBQUE7Ozs7Ozs7Ozs7Ozs7V0FBQSxPQUFBO2lEQUFBOVcsa0JBQUE4Vzs7VUFBQSxPQUFBO2dEQUFBOVcsa0JBQUE4Vzs7U0FBQSxPQUFBOytDQUFBOVcsa0JBQUE4Vzs7UUFBQSxPQUFBOzhDQUFBOVcsa0JBQUE4Vzs7a0JBQUFBOztRQUFBLE9BQUE7K0NBQUE5VyxrQkFBQThXOzs7UUFBQSxPQUFBOytDQUFBOVcsa0JBQUE4VztXQUNFQzs7K0JBQUFBOztnQ0FBQUE7O2lDQUFBQTtrQ0FBQUE7cUNBQUFBO3FDQUFBQTtxQ0FBQUE7bUNBQUFBOztjQUdBQzthQUFBQSxtQkFBQUE7V0FBQTtZQUFBQyxXQUFBRDtZQUFBRSxXQUFBLFdBbFFKaFcsV0E4UEUyVixjQUlFSTtXQUFBLFdBQUFDOztVQUFBLE9BQUE7O21CQUpGbFg7bUJBQ0UrVzttQkFERkQ7O2FBRUVLO1lBQUFBLG1CQUFBQTtVQUFBO1dBQUFDLFdBQUFEO1dBQUFFLFdBdElGMUwsWUFvSUFrTCxjQUVFTztVQUFBLFdBQUFDOztTQUFBLE9BQUE7O2tCQUZGclg7a0JBQ0UrVztrQkFERkQ7O1lBR0VRO1dBQUFBLG1CQUFBQTtTQUFBLElBQUFDLFdBQUFELGtCQUFBRSxXQTNGRnRILFlBMkZFcUg7U0FBQSxXQUFBQzs7UUFBQSxPQUFBOztpQkFIRnhYO2lCQUNFK1c7aUJBREZEOztXQUNFVztVQUFBQSxtQkFBQUE7UUFBQSxJQUFBQyxXQUFBRCxrQkFBQUUsV0EvS0YxUCxZQStLRXlQO1FBQUEsV0FBQUM7O09BQUEsT0FBQTs7Z0JBREYzWDtnQkFDRStXO2dCQURGRDs7TUFBQSxPQUFBOzZDQUFBOVcsa0JBQUE4VztLQUtpQztZQUxqQ2M7SUFBQTs7T0FDRSxJQUFBQyxxQkFBQUMsV0EvS0Z2UCxZQStLRXNQO09BQUEsd0JBQUFDOztPQUNBO1FBQUFDO1FBQUFDLFdBdElGNUwsWUFvSUF3TCxjQUVFRztPQUFBLHdCQUFBQzs7T0FDQSxJQUFBQyxxQkFBQUMsV0EzRkYzSCxZQTJGRTBIO09BQUEsd0JBQUFDOztPQUNBO1FBQUFDO1FBQUFDLFdBQUEsV0FsUUpuWixXQThQRTJZLGNBSUVPO09BQUEsd0JBQUFDOztHQUMrQjs7SUFMakNDOzs7S0FBQUEsK0M7T0FjQUM7O0tBQUFBO2NBQUFDO01BQUE7O2dCQUFBQTttQkFBQUE7Ozs7Ozs7Ozs7VUFBQSxPQUFBO2dEQUFBdFksa0JBQUFzWTs7U0FBQSxPQUFBOytDQUFBdFksa0JBQUFzWTs7UUFBQSxPQUFBOzhDQUFBdFksa0JBQUFzWTs7a0JBQUFBOztRQUFBLE9BQUE7K0NBQUF0WSxrQkFBQXNZOzs7UUFBQSxPQUFBOytDQUFBdFksa0JBQUFzWTtXQUNFQzs7K0JBQUFBOztnQ0FBQUE7aUNBQUFBO29DQUFBQTtvQ0FBQUE7a0NBQUFBOzthQUNBQztZQUFBQSxtQkFBQUE7VUFBQTtXQUFBQyxXQUFBRDtXQUFBRSxXQW5JRmpMLFlBaUlBNEssY0FFRUk7VUFBQSxXQUFBQzs7U0FBQSxPQUFBOztrQkFGRjFZO2tCQUNFdVk7a0JBREZEOztZQUdFSztXQUFBQSxtQkFBQUE7U0FBQSxJQUFBQyxXQUFBRCxrQkFBQUUsV0F6RkZsSCxZQXlGRWlIO1NBQUEsV0FBQUM7O1FBQUEsT0FBQTs7aUJBSEY3WTtpQkFDRXVZO2lCQURGRDs7V0FDRVE7VUFBQUEsbUJBQUFBO1FBQUEsSUFBQUMsV0FBQUQsa0JBQUFFLFdBN0xGaFIsWUE2TEUrUTtRQUFBLFdBQUFDOztPQUFBLE9BQUE7O2dCQURGaFo7Z0JBQ0V1WTtnQkFERkQ7O01BQUEsT0FBQTs2Q0FBQXRZLGtCQUFBc1k7S0FJaUM7WUFKakNXO0lBQUE7O09BQ0UsSUFBQUMscUJBQUFDLFdBN0xGN1EsWUE2TEU0UTtPQUFBLHlCQUFBQzs7T0FDQTtRQUFBQztRQUFBQyxXQW5JRnBMLFlBaUlBZ0wsY0FFRUc7T0FBQSx5QkFBQUM7O09BQ0EsSUFBQUMscUJBQUFDLFdBekZGMUgsWUF5RkV5SDtPQUFBLHlCQUFBQzs7R0FDK0I7O0lBSmpDQzs7O0tBQUFBLCtDO1lBTVFDO0lBQTJCOztXQUMxQkMsY0FBSyxXQUFMQTs7V0FFQ0MsY0FBSyxXQS9IWHZLLFlBRkFELE1BaUlNd0ssR0FIRkY7bUJBRUNHLGNBQUssV0FBSyxXQXJFZjdHLGFBcUVLNkc7O0dBQ3dFO1lBR3pFQztJQUEyQjtJQUFBOzs7WUFDMUJILGdCQUFLLFdBQUxBOztZQUdDQyxnQkFBSyxXQXhJWHhLLE1BTUFFLFlBa0lNc0ssSUFKRkU7O1lBRUNELGdCQUFLLFdBQUssV0ExRWY1RyxhQTBFSzRHOztZQUNBRSx3Q0FBQUE7Ozt1QkFBQUE7O3dEQUFBQTt1REFBQUE7Ozs7R0FDd0U7T0FLakZDOztLQUFBQTtjQUFBQztNQUFBOztnQkFBQUE7bUJBQUFBOzs7Ozs7Ozs7O1VBQUEsT0FBQTtnREFBQS9aLGtCQUFBK1o7O1NBQUEsT0FBQTsrQ0FBQS9aLGtCQUFBK1o7O1FBQUEsT0FBQTs4Q0FBQS9aLGtCQUFBK1o7O2tCQUFBQTs7UUFBQSxPQUFBOytDQUFBL1osa0JBQUErWjs7O1FBQUEsT0FBQTsrQ0FBQS9aLGtCQUFBK1o7V0FDRUM7OytCQUFBQTs7Z0NBQUFBO2lDQUFBQTtvQ0FBQUE7b0NBQUFBO2tDQUFBQTs7YUFDQUM7WUFBQUEsbUJBQUFBO1VBQUE7V0FBQUMsV0FBQUQ7V0FBQUUsV0F4SkYzTSxZQXNKQXNNLGNBRUVJO1VBQUEsV0FBQUM7O1NBQUEsT0FBQTs7a0JBRkZuYTtrQkFDRWdhO2tCQURGRDs7WUFHRUs7V0FBQUEsbUJBQUFBO1NBQUEsSUFBQUMsV0FBQUQsa0JBQUFFLFdBaEZGdEgsYUFnRkVxSDtTQUFBLFdBQUFDOztRQUFBLE9BQUE7O2lCQUhGdGE7aUJBQ0VnYTtpQkFERkQ7O1dBQ0VRO1VBQUFBLG1CQUFBQTtRQUFBLElBQUFDLFdBQUFELGtCQUFBRSxXQXhNRnBSLFlBd01FbVI7UUFBQSxXQUFBQzs7T0FBQSxPQUFBOztnQkFERnphO2dCQUNFZ2E7Z0JBREZEOztNQUFBLE9BQUE7NkNBQUEvWixrQkFBQStaO0tBSWlDO1lBSmpDVztJQUFBOztPQUNFLElBQUFDLHFCQUFBQyxXQXhNRnJSLFlBd01Fb1I7T0FBQSx5QkFBQUM7O09BQ0E7UUFBQUM7UUFBQUMsV0F4SkY5TSxZQXNKQTBNLGNBRUVHO09BQUEseUJBQUFDOztPQUNBLElBQUFDLHFCQUFBQyxXQWhGRjlILFlBZ0ZFNkg7T0FBQSx5QkFBQUM7O0dBQytCOztJQUpqQ0M7OztLQUFBQSwrQztZQU1RQztJQUEyQjs7V0FDMUJ6QixjQUFLLFdBdE1WbFAsVUFzTUtrUDs7V0FFQ0MsY0FBSyxXQXBKWHZLLFlBRkFELE1Bc0pNd0ssR0FIRndCO21CQUVDdkIsY0FBSyxXQUFLLFdBOURmMUYsYUE4REswRjs7R0FDd0U7WUFHekV3QjtJQUEyQjtJQUFBOzs7WUFDMUIxQixnQkFBSyxXQXhNVmpQLFVBd01LaVA7O1lBR0NDLGdCQUFLLFdBN0pYeEssTUFNQUUsWUF1Sk1zSyxJQUpGeUI7O1lBRUN4QixnQkFBSyxXQUFLLFdBbkVmekYsYUFtRUt5Rjs7WUFDQUUsd0NBQUFBOzs7dUJBQUFBOzt3REFBQUE7dURBQUFBOzs7O0dBQ3dFO1lBS2pGdUIsYUFBQUM7SUFBQTs7Y0FBQUE7aUJBQUFBOzs7Ozs7Ozs7O1FBQUEsT0FBQTs4Q0FBQXBiLGtCQUFBb2I7O09BQUEsT0FBQTs2Q0FBQXBiLGtCQUFBb2I7O01BQUEsT0FBQTs0Q0FBQXBiLGtCQUFBb2I7O2dCQUFBQTs7TUFBQSxPQUFBOzZDQUFBcGIsa0JBQUFvYjs7O01BQUEsT0FBQTs2Q0FBQXBiLGtCQUFBb2I7U0FDRUM7OzZCQUFBQTs7OEJBQUFBOytCQUFBQTtrQ0FBQUE7a0NBQUFBO2dDQUFBQTs7V0FFQUM7VUFBQUEsbUJBQUFBO1FBQUE7U0FBQUMsV0FBQUQ7U0FBQUUsV0FBQSxXQTNERjlFLGNBMkRFNkU7UUFBQSxXQUFBQzs7T0FBQSxPQUFBOztnQkFIRnhiO2dCQUNFcWI7Z0JBREZEOztVQUVFSztTQUFBQSxtQkFBQUE7T0FBQTtRQUFBQyxXQUFBRDtRQUFBRSxXQUFBLFdBNUNGeEQsY0E0Q0V1RDtPQUFBLFdBQUFDOztNQUFBLE9BQUE7O2VBRkYzYjtlQUNFcWI7ZUFERkQ7O1NBQ0VRO1FBQUFBLG1CQUFBQTtNQUFBO09BQUFDLFdBQUFEO09BQUFFLFdBQUEsV0F0QkZqQyxjQXNCRWdDO01BQUEsV0FBQUM7O0tBQUEsT0FBQTs7Y0FERjliO2NBQ0VxYjtjQURGRDs7SUFBQSxPQUFBOzJDQUFBcGIsa0JBQUFvYjtHQUkyQztZQUozQ1c7SUFBQTs7T0FDRSxJQUFBQyxxQkFBQUMsV0F0QkZ4QixhQXNCRXVCO09BQUEseUJBQUFDOztPQUNBLElBQUFDLHFCQUFBQyxXQTVDRnBELGFBNENFbUQ7T0FBQSx5QkFBQUM7O09BQ0EsSUFBQUMscUJBQUFDLFdBM0RGNUUsYUEyREUyRTtPQUFBLHlCQUFBQzs7R0FDeUM7WUFKM0NDLEdBQUFDLElBQUEsV0FBQUEsSUFJMkM7WUFKM0NDLEdBQUFELElBQUEsV0FBQUEsSUFJMkM7WUFKM0NFLEdBQUFGLElBQUEsV0FBQUEsSUFJMkM7R0FKM0M7SUFBQUcsc0JBQUFKO0lBQUFLLHNCQUFBSDtJQUFBSSxzQkFBQUg7WUE0WkFJO0lBdFpnQjs7V0FDVDdkLGNBQUssT0F0QkppYyxZQXNCRGpjOztXQUNBaUYsZ0JBQUssT0E1Q0pzVixZQTRDRHRWO21CQUNBQyxnQkFBSyxPQUFMQTs7R0FBbUI7R0F5QjVCLFNBQUE0WSxVQUFBQyxPQUFBQztJQUFBLElBQUFDLFVBQUFGLE9BQUFHLFVBQUFGO0lBQUE7UUFBQUMsWUFBQUMsU0FBQTtlQUFBRDtvQkFBQUM7Ozs7Ozs7ZUFBQUQ7O2VBRUVFLFFBRkZGO3FCQUFBQztvQkFBQUEsWUFFRTtlQUFBRSxRQUZGRjtXQUVXLE9BQUEsc0JBQVRDLE9BQUFDOztlQUZGQyxRQUFBSjtxQkFBQUM7a0JBQUFBOzs7O2tCQUFBSSxRQUFBSixZQUFBRCxVQUFBSSxPQUFBSCxVQUFBSTs7c0JBR0U7OztlQUhGQyxRQUFBTjtxQkFBQUM7a0JBQUFBOzs7Ozs7a0JBQUFNLFFBQUFOLFlBQUFELFVBQUFNLE9BQUFMLFVBQUFNOztzQkFJRTs7O2VBQ0FDLFFBTEZSO3FCQUFBQztrQkFBQUE7Ozs7Ozs7O2VBS0VRLFFBTEZSOytCQUtjUyxPQUFBQyxPQUFBLE9BTGRkLFVBS2NhLE9BQUFDLE9BQUM7Y0FBQyxPQUFBLDRCQUFkSCxPQUFBQztzQkFBQTs7OztlQUNBRyxRQU5GWjtxQkFBQUM7a0JBQUFBOzs7Ozs7O2NBS0U7O2tCQUNBWSxRQU5GWjtjQU1jLE9BQUEsc0JBQVpXLE9BQUFDOzs7UUFGQTs7T0FEQTs7TUFEQTs7S0FEQTs7R0FNd0I7T0FQMUJDOztLQUFBQTtjQUFBQztNQUFBOztnQkFBQUE7bUJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQUFBLE9BQUE7bURBQUEvZCxrQkFBQStkOztZQUFBLE9BQUE7a0RBQUEvZCxrQkFBQStkOztXQUFBLE9BQUE7aURBQUEvZCxrQkFBQStkOztVQUFBLE9BQUE7Z0RBQUEvZCxrQkFBQStkOztTQUFBLE9BQUE7K0NBQUEvZCxrQkFBQStkOztRQUNFOztrQkFERkE7O1FBQUEsT0FBQTsrQ0FBQS9kLGtCQUFBK2Q7OztRQUFBLE9BQUE7K0NBQUEvZCxrQkFBQStkO1dBTUVDLDhDQUFBQTs7Ozs7Ozs7Ozs7Ozt3Q0FBQUE7d0NBQUFBO3dDQUFBQTt3Q0FBQUE7c0NBQUFBOzs7O3lDQUFBQTt1Q0FBQUE7dUNBQUFBO3VDQUFBQTt1Q0FBQUE7cUNBQUFBOzs7Z0JBQUFDO2VBQUFBLG1CQUFBQTthQUFBO2NBQUFDLFdBQUFEO2NBQUFFLFdBQUEsc0JBQUFEO2FBQUEsV0FBQUM7O1lBQUEsT0FBQTs7cUJBTkZuZTtxQkFNRWdlO3FCQU5GRDs7ZUFLRUs7Y0FBQUEsbUJBQUFBO1lBQUE7YUFBQUMsV0FBQUQ7YUFBQUUsV0FBQSxzQkFMRlIsY0FLRU87WUFBQSxXQUFBQzs7V0FBQSxPQUFBOztvQkFMRnRlO29CQU1FZ2U7b0JBTkZEOztjQUdFUTthQUFBQSxtQkFBQUE7V0FBQTtZQUFBQyxXQUFBRDtZQUFBRSxXQUFBLFdBSEZYLGNBR0VVO1dBQUEsV0FBQUM7O1VBQUEsT0FBQTs7bUJBSEZ6ZTttQkFNRWdlO21CQU5GRDs7YUFJRVc7WUFBQUEsbUJBQUFBO1VBQUE7V0FBQUMsV0FBQUQ7V0FBQUUsV0FBQSxXQUpGZCxjQUlFYTtVQUFBLFdBQUFDOztTQUFBLE9BQUE7O2tCQUpGNWU7a0JBTUVnZTtrQkFORkQ7O1lBRUVjO1dBQUFBLG1CQUFBQTtTQUFBO1VBQUFDLFdBQUFEO1VBQUFFLFdBQUEsc0JBQUFEO1NBQUEsV0FBQUM7O1FBQUEsT0FBQTs7aUJBRkYvZTtpQkFNRWdlO2lCQU5GRDs7T0FBQSxPQUFBOzZDQUFBL2Qsa0JBQUErZDs7TUFBQSxPQUFBOzZDQUFBL2Qsa0JBQUErZDtLQU8wQjtZQVAxQmlCO0lBQUEsOEJBQ0U7OztPQUNBLElBQUFDLHFCQUFBQyxXQUFBLHNCQUFBRDtPQUFBLHlCQUFBQzs7T0FDQSxJQUFBQyxxQkFBQUMsV0FIRkosYUFHRUc7T0FBQSx5QkFBQUM7O09BQ0EsSUFBQUMscUJBQUFDLFdBSkZOLGFBSUVLO09BQUEseUJBQUFDOztPQUNBO1FBQUFDO1FBQUFDLFdBQUEsc0JBTEZSLGNBS0VPO09BQUEseUJBQUFDOztPQUNBLElBQUFDLHFCQUFBQyxXQUFBLHNCQUFBRDtPQUFBLHlCQUFBQzs7R0FDd0I7WUFNNUJDLFVBQUFDLE9BQUFDO0lBQUEsR0FBQUQsVUFBQUMsT0FBQTthQUFBRDtTQUNFRSxRQURGRjtjQUFBQyxVQUNFO1NBQUFFLFFBREZGO0tBQ2EsT0FBQSxzQkFBWEMsT0FBQUM7O1FBQ0FDLFFBRkZKO2FBQUFDLFVBQ0U7UUFDQUksUUFGRko7SUFFZSxPQWZiaEQsVUFlQW1ELE9BQUFDO0dBQ3dCO1lBSDFCQyxhQUFBQztJQUFBOztjQUFBQTtpQkFBQUE7Ozs7Ozs7T0FBQSxPQUFBOzZDQUFBbGdCLGtCQUFBa2dCOztNQUFBLE9BQUE7NENBQUFsZ0Isa0JBQUFrZ0I7O2dCQUFBQTs7TUFBQSxPQUFBOzZDQUFBbGdCLGtCQUFBa2dCOzs7TUFBQSxPQUFBOzZDQUFBbGdCLGtCQUFBa2dCO1NBRUVDOzs2QkFBQUE7OEJBQUFBO2lDQUFBQTsrQkFBQUE7O1VBREFDO1NBQUFBLG1CQUFBQTtPQUFBO1FBQUFDLFdBQUFEO1FBQUFFLFdBQUEsc0JBQUFEO09BQUEsV0FBQUM7O01BQUEsT0FBQTs7ZUFERnRnQjtlQUVFbWdCO2VBRkZEOztTQUVFSztRQUFBQSxtQkFBQUE7TUFBQTtPQUFBQyxXQUFBRDtPQUFBRSxXQUFBLFdBZkE1QyxjQWVBMkM7TUFBQSxXQUFBQzs7S0FBQSxPQUFBOztjQUZGemdCO2NBRUVtZ0I7Y0FGRkQ7O0lBQUEsT0FBQTsyQ0FBQWxnQixrQkFBQWtnQjtHQUcwQjtZQUgxQlE7SUFBQTtLQUNFLElBQUFDLHFCQUFBQyxXQUFBLHNCQUFBRDtLQUFBLHlCQUFBQzs7SUFDQSxJQUFBQyxxQkFBQUMsV0FmQS9CLGFBZUE4QjtJQUFBLHlCQUFBQztHQUN3QjtHQUkxQixTQUFBQyxVQUFBQyxPQUFBQztJQUNvQixHQURwQkQsVUFBQUMsT0FDb0I7SUFBQSxJQUFBamIsSUFBQSxxQkFEcEJnYixVQUFBQztpQkFDb0JqYix5QkFEcEJnYixVQUFBQyxZQUNvQmpiO0dBQUk7T0FEeEJrYixTQUFBQyxnQkFBQWxoQixlQUFBbWhCLGdCQUFBbGhCO0dBQUE7U0FBQWtoQjtPQUFBRDtLQUFBO01BQUFFLGdCQUFBRDtNQUFBRSxnQkFBQUg7TUFBQUksZ0JBQUFKO01BQUFLLGdCQUFBRCxlQUFBRixnQkFBQUg7TUFBQUEsTUFBQU07TUFBQUwsZ0JBQUFHOzs7TUFBQUcsa0JBQUFMO01BQUFELGdCQUFBbGhCO01BQUFtaEIsZ0JBQUFLOztHQUFBLElBQUEvaUIsTUFBQSw0QkFBQXdpQjtZQUFBUTtJQUFBO0tBRUlDO0tBREFDO0tBQ0FDLFVBQUEsc0JBQUFGO0tBRkpHLGlDQUVJRDtLQURBRSxVQUFBLHNCQUFBSDtLQURKSSxtQ0FDSUQsZUFESkQ7SUFBQSxXQUFBRTtHQUl3QztZQU1wQ0MsZUFBZW5qQixHQUFHb2pCO0lBQ3BCO0tBQXFCQyxlQURKcmpCO0tBQ1hzakIsZ0JBRFd0akI7S0FFYnVqQjtPQURFRDtVQURjRjtVQUtiOzs7O1lBVEwvaEI7Z0JBSWtCK2hCLGVBSGxCOWhCO0lBVUYsT0FOcUIraEI7Y0FDakJFO2NBS2dEOzs7bUJBTGhEQSxpQkFKRmhpQjtHQVNvRjtZQUdwRmlpQixlQUNnQjliO0lBQ1YsWUFBQSw2QkFEVUEsTUFiaEJuRzs7U0FnQk9raUIsbUJBRVVDLFNBRlZELFFBSExKOztTQUtlSyxTQUxEaGMsTUFBZDJiOzt3Qiw4QkFkRi9oQjtJQXFCRTtLQUFBLE9BQUEsNkJBRmVvaUIsUUFwQmpCcmlCO0tBc0JFLFVBQUE7O1NBSUtzaUIscUJBTlVDLFNBTVZELFFBTkxMOztTQUFlTSxTQUFBRixRQUFmSjtJQVFKLGVBUklBLGVBTEFELGVBS2VPO0dBUWtCOztJQVdyQzs7Ozs7c0JBRjJCQztTQUh6QjtVQUFJQyxJQTlCSlgsZUFpQ3lCVSxPQUNBNWpCO3VEQUpyQjZqQjt5QkF4Q1JsQixhQTJDNkJpQjtTQUZ6QjtTQUNxQjtVQUFBLFFBdEJyQkwsZUFvQklNO1VBSXFCVjtVQURBVzt1QkEzQzdCOUIsVUEyQzZCNEIsT0FBQUU7U0FBbEI7VUFBUCxNQUFBOzt1QkFDeUIsc0JBQUE5akIsYUFBQW1qQjtTQUFsQjtTQUFQLE1BQUE7UUFBc0Q7UUFMeEQsMEJBdkNGeGpCO1FBNkNFLFdBQUE7UUFBQSxPQUFBO09BTUs7S0FOTDtPQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBV0YsU0FBQW9rQixXQUFBQyxPQUFBQztJQUNXLEdBRFhELFVBQUFDLE9BQ1c7SUFBQSxJQUFBaGQsSUFBQSxzQkFEWCtjLFVBQUFDO2FBQ1doZCxHQUFBLE9BQUFBO0lBQ0QsSUFBQUMsTUFBQSxzQkFGVjhjLFVBQUFDO2FBRVUvYyxLQUFBLE9BQUFBO2VBRlYrYyxpQkFBQUQ7a0JBR2NFLE9BQUFDLE9BQUEsT0FBQSxzQkFBQUQsT0FBQUMsT0FBTTs7R0FGSDtZQUViNWMsUUFBQTZjLEdBQUEsT0FBQUEsS0FBTztZQURQNWMsSUFBQTRjLEdBQUEsT0FBQUEsS0FBRztZQURIM2MsS0FBQTJjLEdBQUEsT0FBQUEsS0FBSTtHQURSLFNBQUFDLGFBQUFDOztLQUFBOztNQUdJL2M7TUFEQUM7TUFEQUM7S0FESixXQUNJQSxNQUNBRCxLQUNBRDtJQUV1QztJQUwzQzs7S0FBQTs7Ozs7O0lBSzJDO0lBTDNDLGlDQUFBO0lBQUEsT0FBQTs7YUFBQWhHOzs7OzthQUFBK2lCO0dBSzJDO1lBTDNDQztJQUFBO0tBR0lDO0tBREFDO0tBREFDO0tBRUFDLFVBQUEsaUNBQUFIO0tBSEpJLGlDQUdJRDtLQURBRSxVQUFBLHNCQUFBSjtLQUZKSyxtQ0FFSUQsZUFGSkQ7S0FDSUcsVUFBQSxzQkFBQUw7S0FESk0sbUNBQ0lELGVBREpEO0lBQUEsV0FBQUU7R0FLMkM7WUFFdkNDLFdBQVdsbEI7SUFDYjtLQUFpQyxRQTVDL0J3akIsZUEyQ1d4akI7S0FDUW9qQjtLQUFqQitCO0tBQ0UsVUFBQSw2QkFEZS9COzs0QkFFakJuakI7Z0JBQWUsZUFGZmtsQixvQkFFQWxsQjttQkFDeUIsZUFIekJrbEIsb0JBRUFsbEI7OztrREFGaUJtakI7OztJQUlkLFdBQU07R0FBdUQ7WUFNbEVBLFVBQVVwakI7SUFDWixxQkFDbUIsSUFBMkNvakIsc0JBQWMsT0FBZEEsVUFBd0I7SUFEdEYsV0FaRThCLFdBV1VsbEI7SUFFTyxPQUFBO0dBQW1FO1lBR3BGbWxCLGdCQUFnQm5sQjtJQUNsQjtLQUNtQixJQUFNbWxCO0tBQ3BCLE9BRG9CQTtJQUNKO0lBRnJCLFdBakJFRCxXQWdCZ0JsbEI7SUFFQyxPQUFBO0dBQ0U7WUFHbkJvbEIsYUFBYXBsQjtJQUNmLHFCQUNtQixJQUErQm9sQix5QkFDN0MsT0FENkNBLGFBQ2hDO0lBRmxCLFdBdkJFRixXQXNCYWxsQjtJQUVJLE9BQUE7R0FDRDtZQTRTaEJxbEIsb0JBelNvQkMsR0FBRTlLO0lBQ3hCLDRCQUR3QkE7O2dCQUFGOEs7O2tCQUFFOUs7O29CQUFGOEs7O3NCQUFFOUs7O3dCQUFGOEs7OzBCQUFFOUs7OzRCQUFGOEs7OzhCQUFFOUs7bURBQUY4Szs7Ozs7Ozs7OztHQVlkO1lBT05DLEtBQUt2bEI7a0JBQzBCc2xCLEdBQUU5SyxHQUNqQyxPQW9SQTZLLG9CQXJSK0JDLE1BQUU5SyxNQUM4QjtJQURyQyxPQUFBLDBCQURyQnhhO0dBRTJEO1lBcVJoRXdsQixvQkFsUm9CQyxNQUFLQztJQUNkLElBQVRDLFNBQVMsNkJBRFNGO0lBRXRCLGNBQStCQTtLQUM3QixjQUV5QkcsTUFBUSxXQUFJLDRCQUFaQSxNQUFrQztLQUR6RDtNQUFBLE9BQUEsNkJBRjJCSDtNQUN6QkksUUFDRjtLQUdGLGNBQ3FDekQsS0FBSXdEO01BQ3JDLEdBRGlDeEQ7T0FNRDtnQkFOQ0E7UUFJZjBEO1FBQVBDO1FBRXFCLE9BQUEsNkJBTktIO1FBTTVCSSxnQkFBZ0Isc0JBRlBGOztnQ0FFVEUsa0JBZFlOO2lCQVlWSyxPQUVGQztxQkFGU0YsTUFBUEMsUUFKMEJIOzs7eUJBQUFBO01BQ3JDO0tBUThCO0tBVGhDLFlBQUEsMEJBTEVDO2lCQWdCTTs2QkFDS0MsbUJBQVBDO0tBQXlCLE9BQUEsOEJBQWxCRCxNQUFQQztJQUF3QztJQWxCeEIsT0FBQSwwQkFEdEJKO0dBbUIrQztZQU8vQ00sY0FBY1A7SUFBUSxPQUFBLDRCQUFSQTtHQUE2QjtZQUUzQ1EscUJBQXFCQyxHQUFHVDtJQUMxQjtLQUFJVSxRQURzQlYsOEJBQUhTO0tBRW5CLE9BSkZGLGNBR0VHO0lBQ0EsT0FBQSxzQkFGbUJEO0dBRUE7WUFJckJFLG1CQUFtQkY7SUFBSSxPQUFZLGtDQURuQzFrQixxQkFDbUIwa0I7R0FBZ0Q7R0FNekQ7SUFBVkcsVUFkQUw7SUFVQU07SUFJVTtpQkFHS0MsR0FBSyxPQVRwQkgsdUJBTUFDLGFBR2VFLFFBQXNDO1lBb0R2RHptQixVQUFVQztrQkFWZ0JBO0tBQ3hCO01BQ015bUIsT0FGa0J6bUI7TUF2Q25CMG1CO1FBMENILHNDQURJRCxNQUZrQnptQjtNQXZDSTJtQixnQkF1Q0ozbUI7TUFyQ3BCNG1CLHVDQUZDRjtNQUNIRztjQUNFRDtXQWRKUCx1QkFZS0s7V0FaTEw7O2FBTkFIO2VBa0JLUSx3QkFWTEg7aUJBREE3a0I7TUF3QkVvbEIsd0JBc05KdEIsb0JBbk84Qm1CO0tBa0I5QixHQUxJRztNQWhCUTtPQXVCZ0JDLHlCQVB4QkQ7T0FPRkUseUJBUEVGO09BUUVHLG9CQXhCTSxpQkF1QmdCRjtPQUV0Qkc7a0JBQW1DZjtVQUNyQyxPQW5DRkU7O29CQU5BSCxxQkF3Q3VDQyxHQWhDdkNJO3dCQURBN2tCLGlCQStCQXNsQjtTQU9LOztxQ0EzQkFOOztZQUNIRztnQkFxQkVLLHVDQURBRDs7WUFDQUMsK0JBdEJDUjtZQXFCRE87O3FCQXBCRko7S0EyQ0YsT0FBQTtJQUFnRDtJQUxsRCxXQUFBLDBCQVVVN21CO0lBVlYsT0FBQTtHQVVpQztZQVFqQ21uQixtQkFBWSx5Q0FFRTtHQVBGLG1CQUtaQTtZQU1GQyxjQUFjQyxPQUFNQyxRQUFPQztJQUNmLElBQVZDLFVBQVU7SUFHVCxHQUFBLDRCQUppQkYsUUFDbEJFO0tBSUc7TUFBQTs7U0FBa0IsSUFBWUMsb0JBQU5DO1NBQW1CLFdBQW5CQSxTQUFNRDtRQUErQztNQUhoRkUsVUFHRywwQkFMU047O1NBRVpNLFVBRllOO0lBUWhCO0tBQ3VCLElBRWpCSzs7ZUFITiw0QkFHTUEsS0FYZ0JKO2VBV0ssNEJBQXJCSSxLQVhnQko7SUFXa0M7SUFGdEQsSUFNQU0sVUFOQSwwQkFQRUQ7U0FhRkM7Ozs7Ozs7OzJCQURzQkM7WUFBQSxPQUFBLHdCQUFBQTtXQUF3Qjs7O0tBQXhDLFdBQU0sb0NBZGVOLFVBQVBEOztTQWVwQk07Z0JBQUFBLFlBRlNFLHFCQUFOQztLQUFrQyxlQUFsQ0EsT0FBTUQ7OztLQUdtQixJQUFNSjtLQUFXLE9BQUEsNEJBQVhBLEtBaEJkSjtJQWdCaUQ7SUFBOUQsWUFBQSwwQkFEUE07OzBCQUVlSCxtQkFBTkM7S0FBZ0MsZUFBaENBLEtBQU1EOztJQUVRO0tBQWhCTyxnQkFBZ0IsMEJBSnZCSjtLQVVRLE9BQUEsa0NBTkRJOzs7Ozt5QkFHRUM7VUFBQSxPQUFBLHdCQUFBQTtTQUEyQzs7O0lBRmpELFdBQ0Usb0NBckJzQlYsVUFBUEQ7R0F5QjZCO1lBSW5EWSxXQUFBQyxPQUFBQztJQUNjLEdBRGRELFVBQUFDLE9BQ2M7SUFBQSxJQUFBbGhCLElBQUEsc0JBRGRpaEIsVUFBQUM7YUFDY2xoQixHQUFBLE9BQUFBO2VBRGRraEIsaUJBQUFEO2tCQUVhRSxPQUFBQyxPQUFBLE9BQUEsc0JBQUFELE9BQUFDLE9BQU07SUFBQyxJQUFBbmhCLE1BQUE7YUFBQUEsS0FBQSxPQUFBQTtJQUNSLElBQUF3QixNQXhRWmlZLFVBcVFBdUgsVUFBQUM7YUFHWXpmLEtBQUEsT0FBQUE7ZUFIWnlmLGlCQUFBRDtrQkFJWUksT0FBQUMsT0FBQSxPQTFNWnhFLFdBME1ZdUUsT0FBQUMsT0FBVzs7R0FISDtZQUdoQnhmLE1BQUFxYixHQUFBLE9BQUFBLEtBQUs7WUFETHBiLE1BQUFvYixHQUFBLE9BQUFBLEtBQUs7WUFETG5iLE9BQUFtYixHQUFBLE9BQUFBLEtBQU07WUFETmxiLFFBQUFrYixHQUFBLE9BQUFBLEtBQU87WUFEWG9FLGFBQUFDOztLQUFBOzs7TUFJSTFmO01BREFDO01BREFDO01BREFDO0tBREosV0FDSUEsU0FDQUQsUUFDQUQsT0FDQUQ7SUFFdUM7SUFOM0M7O0tBQUE7Ozs7Ozs7OztJQU0yQztJQU4zQzs7Ozs7UUFyUUFtWTs0QkFxUUEsc0JBdE1BbUQ7SUFzTUEsT0FBQTs7YUFBQTNpQjs7Ozs7Ozs7O2FBQUErbUI7R0FNMkM7WUFOM0NDO0lBQUE7S0FJSUM7S0FEQUM7S0FEQUM7S0FEQUM7S0FHQUMsVUFBQSxzQkExTUp4RSxjQTBNSW9FO0tBSkpLLGlDQUlJRDtLQURBRSxVQXhRSnRILGFBd1FJaUg7S0FISk0sbUNBR0lELGVBSEpEO0lBRUksR0FBQUg7S0FBQTtNQUFBTSxRQUFBTjtNQUFBTyxVQUFBLHNCQUFBRDtNQUFBRSw0QkFBQUQ7TUFGSkUsaUJBRUlELFNBRkpIOztTQUFBSSxhQUFBSjtJQUNJO0tBQUFLLFVBQUEsc0JBQUFUO0tBREpVLG1DQUNJRCxlQURKRDtJQUFBLFdBQUFFO0dBTTJDO1lBRXZDQyxVQUFVMXBCLEdBQUVzbkI7SUFDZCxHQUFNLDRCQURRQTtLQUtWOztpQkFEZ0JxQztTQVFsQjtVQUFBOztVQUFBLE9BakRGdkMsY0FpRGdCLDBCQVJJdUMsVUFKTnJDO1VBWVosT0FBQTtTQUFBLE9BQUE7UUFFc0I7O2lCQVRNc0M7dUJBQ054Rzt3QkFFbUNzRSxLQUNoRCxXQURnREEsU0FIN0JrQyx3QkFJTTtVQUY5QjtrQkFDRTt1Q0FGZ0J4RyxXQURNd0c7U0FJUTtTQUhGLFdBbE1sQ3hHLFVBaU00QndHOzs7TUFBMUIsT0FBQSwwQkFMUTVwQjtNQUtSLE9BQUE7Ozs7a0RBTFVzbkI7Ozs7OztJQUVILFdBQU07R0FZTztZQUd0QnVDLFVBQVU3cEI7SUFDWixZQURZQTsyQkFFSnVGLG9CQUFTLE9BQVRBO1FBQ0VpRztJQUFXLE9BcFNqQmxHLE1Bb1NNa0c7R0FBc0M7R0FLbEQsU0FBQXNlLFdBQUFuZSxPQUFBb2UsT0FBQUM7SUFDYyxHQURkRCxVQUFBQyxPQUNjO0lBQUEsSUFBQTlpQixJQUFBLHNCQURkNmlCLFVBQUFDO2FBQ2M5aUIsR0FBQSxPQUFBQTtlQURkOGlCLGlCQUFBRDtrQkFFYUUsT0FBQUMsT0FBQSxPQUFBLHNCQUFBRCxPQUFBQyxPQUFNO0lBQUMsSUFBQS9pQixNQUFBO2FBQUFBLEtBQUEsT0FBQUE7ZUFGcEI2aUIsaUJBQUFEO2tCQUdrQkksT0FBQUM7bUJBQUNDLE9BQUFDO01BQUE7T0FBQUMsUUFBQUY7T0FBQUcsUUFBQUg7T0FBQUksUUFBQUg7T0FBQUksUUFBQUo7T0FBQXBqQixJQUFBLHNCQUFBc2pCLE9BQUFFO21CQUFBeGpCLElBQVMsV0FINUJ5RSxPQUdtQjRlLE9BQUFFLFNBQUF2akI7S0FBVztLQUFFLE9BQUEsK0JBQWRpakIsT0FBQUM7SUFBb0I7O0dBRmxCO1lBRWhCemQsWUFBQTBYLEdBQUEsT0FBQUEsS0FBVztZQURYc0csU0FBQXRHLEdBQUEsT0FBQUEsS0FBTTtZQUROdUcsVUFBQXZHLEdBQUEsT0FBQUEsS0FBTztHQURYLFNBQUF3RyxhQUFLQyxVQUFMQzs7S0FBQTs7TUFHSXBlO01BREF6RDtNQURBQztLQURKLFdBQ0lBLFNBQ0FELFFBQ0F5RDtJQUV1QztJQUwzQzs7S0FBQTs7Ozs7O0lBSzJDO0lBTDNDO2tCQUdtQnFlO0tBQUQsU0FBQ0E7aUJBQUFBOzs7O1FBQUE7U0FBQUM7U0FBQUM7U0FBQUMsV0FBQSxzQkFBQUQ7U0FBQUUsV0FBQSxXQUhkTixVQUdjRztRQUFBLFdBQUFFLFVBQUFDOzs7O0tBQUEsT0FBQTsyQ0FIbkJ4cEIscUJBR21Cb3BCO0lBQW1CO0lBQXBCO0tBQUEsT0FBQTtLQUhsQixpQ0FBQTtJQUFBLE9BQUE7O2FBQUFwcEI7Ozs7Ozs7OzthQUFBbXBCO0dBSzJDO1lBTDNDTSxhQUFLQztJQUFMO0tBR0lDO0tBREFDO0tBREFDO0tBREpDOzs7TUFHbUJDO01BQUFDO01BQUFDLGlDQUFBRDtNQUFBRSxzQkFIZFIsVUFHY0s7b0JBQUFFLGNBQUFDOztJQUFmOztLQUFBQyxVQUFBLCtCQUFBUjtLQUhKUyxtQ0FHSUQsZUFISkw7SUFFSSxHQUFBRjtLQUFBO01BQUFTLFFBQUFUO01BQUFVLFVBQUEsc0JBQUFEO01BQUFFLDRCQUFBRDtNQUZKRSxpQkFFSUQsU0FGSkg7O1NBQUFJLGFBQUFKO0lBQ0k7S0FBQUssVUFBQSxzQkFBQVo7S0FESmEsbUNBQ0lELGVBREpEO0lBQUEsV0FBQUU7R0FLMkM7WUFFdkNDLGdCQUFnQnZzQixHQUFFc25CO0lBQ3BCLEdBQU0sNEJBRGNBOzttREFBQUE7Ozs7OztLQUdsQixXQUFNOztJQUVOO0tBQ29DLElBQVdoQyxjQUFMb0M7S0FBVyxXQUFYQSxTQUFLcEM7SUFBd0I7ZUFOdkR0bEI7Ozs7Ozs7O0lBTWQ7S0FERTJwQixVQUNGO0tBQUE7S0FFRjtLQUFBLE9BN0VGdkMsY0EwRU11QyxTQUxjckM7S0FRbEIsT0FBQTtJQUFBLE9BQUE7R0FFc0I7R0FPMUIsU0FBQWtGLFdBQUFDLE9BQUFDO0lBQ2MsR0FEZEQsVUFBQUMsT0FDYztJQUFBLElBQUF4bEIsSUFBQSxzQkFEZHVsQixVQUFBQzthQUNjeGxCLEdBQUEsT0FBQUE7ZUFEZHdsQixpQkFBQUQ7a0JBRWFFLE9BQUFDLE9BQUEsT0FBQSxzQkFBQUQsT0FBQUMsT0FBTTtJQUFDLElBQUF6bEIsTUFBQTthQUFBQSxLQUFBLE9BQUFBO0lBQ0YsSUFBQXdCLE1BQUEsc0JBSGxCOGpCLFVBQUFDO2FBR2tCL2pCLEtBQUEsT0FBQUE7SUFDQSxJQUFBaUksTUFBQSxzQkFKbEI2YixVQUFBQzthQUlrQjliLEtBQUEsT0FBQUE7ZUFKbEI4YixpQkFBQUQ7a0JBS3VCSSxPQUFBQyxPQUFBLE9BQUEsc0JBQUFELE9BQUFDLE9BQU07O0dBSlQ7R0FEcEIsU0FBQUMsYUFBQUM7O0tBQUE7Ozs7TUFLSS9iO01BREFDO01BREFDO01BREFqSTtNQURBQztLQURKLFdBQ0lBLFNBQ0FELFFBQ0FpSSxhQUNBRCxhQUNBRDtJQUVzQjtJQVAxQjs7S0FBQTs7Ozs7Ozs7Ozs7O0lBTzBCO0lBUDFCOztzQ0FBQTtJQUFBLE9BQUE7O2FBQUFwUDs7Ozs7Ozs7Ozs7Ozs7Ozs7YUFBQW1yQjtHQU8wQjtZQVAxQkM7SUFBQTtLQUtJQztLQURBQztLQURBQztLQURBQztLQURBQztLQUlBQyxVQUFBLGlDQUFBTDtLQUxKTSxpQ0FLSUQ7S0FEQUUsVUFBQSxzQkFBQU47S0FKSk8sbUNBSUlELGVBSkpEO0tBR0lHLFVBQUEsc0JBQUFQO0tBSEpRLG1DQUdJRCxlQUhKRDtJQUVJLEdBQUFMO0tBQUE7TUFBQVEsUUFBQVI7TUFBQVMsVUFBQSxzQkFBQUQ7TUFBQUUsNEJBQUFEO01BRkpFLGlCQUVJRCxTQUZKSDs7U0FBQUksYUFBQUo7SUFDSTtLQUFBSyxVQUFBLHNCQUFBWDtLQURKWSxtQ0FDSUQsZUFESkQ7SUFBQSxXQUFBRTtHQU8wQjtZQUkxQkMsV0FBQUMsT0FBQUM7SUFBQSxJQUFBQyxVQUFBRixPQUFBRyxVQUFBRjtJQUFBO1FBQUFDLFlBQUFDLFNBQUE7WUFBQUQ7O1lBQ0VFLFFBREZGO2lCQUFBQyxZQUNFO1lBQUFFLFFBREZGO1FBQ2EsT0FyRWJyRyxXQXFFRXNHLE9BQUFDOztZQUNBQyxRQUZGSjtlQUFBQzs7O2VBRUVJLFFBRkZKO1dBRWUsT0FyQ2Z6RTs2QkFxQ2E4RSxPQUFBQyxPQUFBLE9BRmJWLFdBRWFTLE9BQUFDLE9BQUM7b0JBQVpIO29CQUFBQzttQkFBQTs7OztZQUZGRyxRQUFBUixZQUdFUyxRQUhGVDtlQUFBQzs7O1dBRUU7O1dBQ1U7WUFIWlMsUUFBQVQ7WUFHRVUsUUFIRlY7WUFHWXJuQixJQWRac2xCLFdBY0V1QyxPQUFBRTtvQkFBVS9uQixHQUFBLE9BQUFBO2VBSFpvbkIsVUFBQVEsT0FBQVAsVUFBQVM7Ozs7S0FDRTs7R0FHd0I7T0FKMUJFOztLQUFBQTtjQUFBQztNQUFBOztnQkFBQUE7bUJBQUFBOzs7Ozs7Ozs7O1VBQUEsT0FBQTtnREFBQXJ0QixrQkFBQXF0Qjs7U0FBQSxPQUFBOytDQUFBcnRCLGtCQUFBcXRCOztRQUFBLE9BQUE7OENBQUFydEIsa0JBQUFxdEI7O2tCQUFBQTs7UUFBQSxPQUFBOytDQUFBcnRCLGtCQUFBcXRCOzs7UUFBQSxPQUFBOytDQUFBcnRCLGtCQUFBcXRCO1dBQ0VDOzsrQkFBQUE7O2dDQUFBQTtpQ0FBQUE7b0NBQUFBO29DQUFBQTtrQ0FBQUE7O2FBQ0FDO1lBQUFBLG1CQUFBQTtVQUFBO1dBQUFDLFdBQUFEO1dBQUFFLFdBckNGMUUsYUFtQ0FxRSxjQUVFSTtVQUFBLFdBQUFDOztTQUFBLE9BQUE7O2tCQUZGenRCO2tCQUNFc3RCO2tCQURGRDs7WUFHRUs7UUFBQSxHQUFBQTtvQkFBQUE7O1VBQUE7V0FBQUM7V0FBQUMsV0FBQUY7V0FBQUcsV0FkRjVDLGFBY0UyQztXQUFBRSxXQUFBLFdBSEZWLGNBR0VPO1VBQUEsV0FBQUUsVUFBQUM7OztRQUFBLE9BQUE7O2lCQUhGOXRCO2lCQUNFc3RCO2lCQURGRDs7V0FDRVU7VUFBQUEsbUJBQUFBO1FBQUEsSUFBQUMsV0FBQUQsa0JBQUFFLFdBckVGdEgsYUFxRUVxSDtRQUFBLFdBQUFDOztPQUFBLE9BQUE7O2dCQURGanVCO2dCQUNFc3RCO2dCQURGRDs7TUFBQSxPQUFBOzZDQUFBcnRCLGtCQUFBcXRCO0tBSTBCO1lBSjFCYTtJQUFBOztPQUNFLElBQUFDLHFCQUFBQyxXQXJFRnZILGFBcUVFc0g7T0FBQSx5QkFBQUM7O09BQ0E7UUFBQUM7UUFBQUMsV0FyQ0YvRSxhQW1DQTJFLGNBRUVHO09BQUEseUJBQUFDOztPQUNBO1FBQUFDO1FBQUFDO1FBQUFDLFdBZEZ0RCxhQWNFcUQ7UUFBQUUsV0FIRlIsYUFHRUs7T0FBQSx5QkFBQUUsY0FBQUM7O0dBQ3dCO1lBRXRCQyxxQkFBcUJ6d0I7SUFDdkIsU0FBUTB3QjtLQUFTO0tBQUE7OztTQUVGOztTQUVYO1VBRFEvakI7VUFDUjs7YUFBNEMsSUFBWTNNLGNBQU4wSDthQUNoRCxjQUFpQjRJLE1BQVEsV0FEdUI1SSxNQUMvQjRJLE1BQW9CO2FBQUUsV0FMckNvZ0IsT0FJb0Qxd0I7YUFDMUMsT0FBQTtZQUFzQzs4QkFGNUMyTTs7O3FCQUFBQTs7c0RBQUFBO3FEQUFBQTs7U0FDb0MsT0FBQTtxQkFIbkMzTSwwQkFBQUE7O0lBSTJDO0lBRy9DLFdBUkQwd0IsT0FEZTF3QjtJQVNkLE9BQUE7R0FBVTtZQUtyQjJ3QjtJQUFBOztPQUNFLElBQUFDLHFCQUFBQyxXQXpGRmxJLGFBeUZFaUk7T0FBQSx5QkFBQUM7O09BQ0E7UUFBQUM7UUFBQUMsV0F6REYxRixhQXVEQXNGLGNBRUVHO09BQUEseUJBQUFDOztPQUNBLElBQUFDLHFCQUFBQyxXQWxDRmhFLGFBa0NFK0Q7T0FBQSx5QkFBQUM7O09BQ0E7UUFBQUM7UUFBQUMsV0FBQSx5QkFKRlIsY0FJRU87T0FBQSx5QkFBQUM7O0dBQ2tCO0dBRUMsSUFBakJDLGlCQUFpQjtZQUtmOWlCLEVBQUUraUIsR0FBRUM7SUFBYyxPQUFBLHlCQUFkQSxXQUFGRDtHQUFtQztHQUNYO0lBelo1QkUsT0F5WjRCO0lBRjVCQyxxQkFDRWxqQixLQUFBQSxLQUFBQSxLQXhaRmlqQixNQUFBN1QsT0FBQUMsT0FBQUM7WUE2WkE2VCxhQUFhQyxRQUFHQztJQWhaZCxlQWdaY0E7Ozs7UUEvWVAsV0F2QkR6VixZQXNhS3dWOztRQTlZSixXQTdDRC9XLFlBMmJLK1c7Z0JBN1lKLFdBNllJQTs7SUEzWVQ7O09BQUE7Ozs7O1NBMllZQzs7SUEzWVosT0FBQTtHQTJZa0U7WUFTcEVDO0lBQXFDO0lBQUE7OztZQUNuQ3BYLGdCQUFLLFdBQUxBOztZQUNBQyxnQkFBSyxXQS9EVHBNLElBK0RJb00sR0FGRm1YOztZQUdLdGpCLGdCQUFIb007UUFBUyxXQUFUQSxHQUhGa1gsYUFHaUMsV0FBNUJ0akI7O1lBQ0pzTSx3Q0FBQUE7Ozt1QkFBQUE7O3dEQUFBQTt1REFBQUE7Ozs7R0FBd0M7WUFHekNpWDtJQUFjO0lBQUE7OztZQUNaclgsZ0JBQUssT0FBTEE7O1lBQ0FDLGdCQUFLLE9BQUxBOztZQUNBQyxnQkFBUyxPQUFUQTs7WUFDREUsd0NBQUFBOzs7dUJBQUFBOzt3REFBQUE7dURBQUFBOzs7O0dBQXVDOzs7Ozs7Ozs7WUEvWTVDa0QsV0FBQW1DLGNBU0lqYixXQUNBTTtRQUdOc2I7UUFBQWdCO1dBT0FLLFdBQUFyaUIsS0FBQWdqQixjQVVJTzs7UUE4Q0phO1FBR0l4YztRQURBQztRQURBQztRQURKOGM7UUFrQklwQjtRQUtBK0I7UUFNQUM7UUE3QkpkO1dBc0RJaUIsTUFxR0F4bEI7O1FBMkNKbW9CO1FBSUlsZjtRQURBQztRQURBQztRQURBQztRQURKd2Y7UUFRSWU7UUFpQkFHO1FBekJKcEI7O1FBaUNBcUI7UUFHSW5kO1FBREFnZTtRQURBQztRQURKUztRQU9Ja0I7UUFhQWxlO1FBcEJKd2M7V0F3QkEyQixZQUFBUyxjQUFBRjtXQVdBb0IsWUFBQTZCLGNBTUlTLHNCQU5KdkI7T0E4Q00wQztPQU9BQzs7UUFqQ05sQjtRQU9JUztRQUlBSTtZQXZaQXJWLGNBQUFZO1FBNFpBYztRQUNBNFQ7Ozs7aUJBM3NCRXp2QixXQXVCSW9ELGFBdkJKakIsYUFBS1k7YUFnRFBVLFdBQUFPLGFBQUFTLGFBQUtLO2dCQVdMQyxXQUFBTyxhQUFBSyxhQUFLVTs7YUFhTEMsV0FBQVEsYUFBQU0sYUFBS2U7YUFVTEMsYUFBQUUsYUFBS2Usa0JBUURDLFdBSUFDO2dCQW9CSkcsV0FBQWMsYUFBQVMsYUFBUWtCLGtCQXFpQlJFOzthQXpmQWtDLFdBQUFRLGFBQUFLLGFBQUtrQjs7VUFnQkxHO1VBQUFFO1VBQUtlO1VBeUJERztVQUNBQzs7VUFJSkM7VUFBQUU7VUFBS1k7VUF1QkRHO1VBQ0FDO2dCQU1KQyxXQUFBZSxjQUFBYyxjQUFLVTs7O1FBNmZMckg7UUFDQWlWO1FBbktGK0I7UUFvS0U1Qjs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7OztJQ3MxRUk5ZDs7Ozs7O0lBcHJEV29xQjtJQXVxQ1hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE3a0VOQztJQUFBQztJQVlJQztJQUNBNU87SUFDQUQ7SUFDQThPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyREEzZkpDO1FBQUFBOztHQU1KOztJOztJQUEyQjtLQUFBQztLQUFBQyxVQUFBLHNCQUFBRDtLQUFBLGdDQUFBQzs7OztZQUlyQkMsS0FBS0M7SUFDUCxHQVhBSjtLQVc4QixNQUFBLDZDQUR2Qkk7SUFDMkQsT0FBQSx1QkFEM0RBO0dBQzZFO1lBZXBGQyxhQUFhQyxJQUFLLE9BQUEsaUNBQUxBLElBQWlDO0dBRWxEOzs7WUFFSUMsSUFBSUM7a0JBQW9CQztLQUFVLE1BQUE7K0NBQVZBO0lBQWtEO0lBQWhFLE9BQUEsb0NBQU5EO0dBQTJFOztJQUMvRXZOOzs7Ozs7OztZQWVFeU4sV0FBV3ByQjtJQUFPLE9BQUEsbUNBQVBBO0dBQTREO0dBTTNFO0lBTElxckI7SUFDQUM7SUFHRkM7TUFDRjs7WUFxRE1DLE1BNUJJNWtCLEdBQUU2WDtJQUNWLFdBRFE3WCxxQkFBRTZYOztLQU1DLElBQThCZ047S0FDakMsc0JBRGlDQTtJQUNIO2tCQUZ2QjdrQixHQUFFNlgsR0FBSyxPQUFBLFdBQVA3WCxHQUFFNlgsR0FBUTtJQUp6QixXQUNJLDRCQUZJN1gsTUFBRTZYO0dBU1Q7WUFLQ2lOLCtCQUFpQ3B6QjtJQUNuQyxXQURtQ0E7SUFDbkMsV0FBVyw0QkFEd0JBO0dBQ21CO3VCQUczQnNPO1FBQVgra0Isb0JBQVJDO0lBQXVCLFdBQVcsNEJBQWxDQSxRQUFtQmhsQixJQUFYK2tCOztZQUNkRSxjQUFjL00sR0FBSSxlQUFKQSxPQUFzQztZQUNwRGdOLGdCQUFnQmhOLEdBQUksZUFBSkEsT0FBcUM7WUFDckRpTixNQUFPSixTQUFRSyxLQUFNLGVBQU5BLE1BQVJMLFNBQTZDO0dBTTVDO0lBQU5obEI7a0RBUkZrbEIsZUFTRUwsT0FEQTdrQjs7Ozs7SUFRYztJQUhDO1lBZWpCc2xCLGFBQWEzekIsR0FBRTR6QixLQUFLQztrQkFDQUM7S0FDcEIsSUFBQSwwQkFBMkIsT0FBQSxXQURQQSxhQURMRixLQUFLQztLQUVwQixPQUFBO0lBQWtEO0lBRHBELDRCQURlN3pCO0lBQ2YsT0FuSEV1eUI7R0FxSEk7R0E2RVIsU0FJSXdCLFVBQUExUCxHQUFBLE9BQUFBLEtBQVM7WUFJVDJQLE1BQU1oMEIsR0FBRThqQjt5QkFBaUMsT0FBN0IsV0FBTjlqQixNQUFFOGpCLEdBQTBDO0lBQXBCLE9BQUE7R0FBcUI7WUFHbkRtUSxPQUFRQyxVQUFVeE0sS0FBSXlNO0lBQ3hCLFdBRHdCQSxXQUFkRCxVQUFVeE0sS0FDd0I7R0FBb0I7WUFHOUQwTSxNQUFLMU0sS0FBSTFuQixHQUFHc087SUFBSSxXQUFQdE8sYUFBQUE7SUFBTztxQkFBMkI4akIsR0FBSyxPQUFFLFdBQXRDeFYsR0FBc0MsV0FBekN0TyxNQUFrQzhqQixJQUFrQjs7WUFBeEQ0RDs7R0FBMkQ7WUFFaEUyTSxRQUFTM00sS0FBSTFuQjthQUNYZzBCLE1BQU1NO0tBQU0sd0JBRER0MEI7OztpQkFBQUE7O2tEQUFBQTtpREFBQUE7O0tBQ0MsT0FBQSxvQkFBTnMwQjtJQUF5QjtJQUNuQyxTQUFJSixTQUFTTixLQUFLQztLQUNoQix3QkFIYTd6Qjs7O2lCQUFBQTs7a0RBQUFBO2lEQUFBQTs7S0FHUDtpQkFJSjtTQUNLazBCO0tBQVksT0FBQSxXQUFaQSxVQU5JTixLQUFLQztJQU1xQjtJQUV2QixJQUFaVSxjQUFZLDBCQVZEdjBCLEdBYmIrekI7SUF3QkYsV0FWSUMsV0FDQUUsV0FGT3hNLEtBVVA2TTtHQUMrQztHQUd4QztJQUFUQyxTQXBCQVAsNEI7SUFxQkFRLFFBckJBUjtJQXNCQVMsU0F0QkFUO0lBdUJBVSxVQXZCQVY7SUF3QkE1dUIsT0F4QkE0dUI7WUEwQkFXLFVBQVdWLFVBQVNXO0lBQ3RCLE9BM0JFWjthQTBCV0M7O3NCQUNTcFE7Y0FBSyxPQUFRLFdBRGIrUSxTQUNhLDJCQUFiL1E7YUFBZ0Q7R0FBQztZQXdHckVnUjtJQUNEQztJQUNDakQ7SUFDRGtEO0lBQ0FDO0lBQ0F2TjtJQUNETDtJQUVBLEdBTkV5SztTQUFpQm9ELFFBQWpCcEQsUUFsR0RxRCxpQkFrR2tCRDs7U0FsR2xCQztPQWlHQUo7U0FyRzBCSyxNQXFHMUJMLDZCQXJHQ00seUJBQXlCRDs7U0FBekJDO0lBT0YsR0FnR0NMO1NBdEd1Qk0sUUFzR3ZCTiwwQkF0R0NPLHNCQUFzQkQ7O1NBQXRCQzthQXlDSUMsS0FBS0M7S0FmRCxZQUFBLDRCQWVDQSxTQWdFWHBPOztVQTlFVWhaLHVCQUFBQTs7TUFFSjtPQUFBLHVCQUdtQixzQkFFSyxVQURELFNBQ007OEJBSlQsSUFBTXFuQixjQUFnQixXQUFoQkEsR0FBQUEsR0FBcUI7T0FBN0MsT0FBQSwwQkEyRVJyTztPQTNFUSxPQUFBLDZCQVdHb087T0FYSCxPQUFBO09BU3lERSxpQkFUekQ7Ozs7dURBU3lEQTs7Ozs7Ozs7S0FFOUMsV0FBUkY7SUFBNkQ7SUFDdEUsR0F2Q0ROO2lCQXNDS0s7O3lDQUFBQTtRQXJCcUJubkIsZ0JBQVp1bkI7YUF3QlgxQixTQUFTMkIsVUFBZXZPO0tBQzFCLEdBMEREMk47VUF6RFFmLFdBeURSZTtNQXpEb0IsT0FBQSxXQUFaZixVQUZJMkIsVUFBZXZPOzs7TUFJYyxJQUFNNWY7V0FDcEMsV0E3QkdrdUIsTUE0QmlDbHVCLE1BSnBCNGYsU0FNWDtNQUlJO09BQVR3TztTQUFTO3FEQVZPeE8sYUFJb0I1ZjtPQU9wQytiLFNBQU8sc0JBWFM2RCxRQVVoQndPO01BRUosV0FESXJTO0tBQ007S0FSRSxXQUFBLDRCQTVCT3BWO0tBNEJlLE9BQUE7SUFReEI7SUFzQlo7Ozs7UyxLQTlFSmtuQixxQkFrRlU7U0FGa0M7VUFBQSxPQUFBLHlCQTVEbkJsbkI7VUE0RGQwbkIsU0FBUztVQUNSO2dCQUREQTtVQUNDO1NBQUwsV0FBSzs7SUFIUjtxQkFPQ0M7YUExQkMsSUFDSmxTLElBREkseUJBdkNtQnpWLEtBaUVwQjJuQjs7Z0JBekJIbFM7NEJBQUFBO3FCQTdERnVSO2NBbUVROzs7a0JBQ2tCLElBQU0zdEI7a0JBQVksT0FBQSxXQS9DL0JrdUIsTUErQ21CbHVCLE1Ba0IzQnN1QjtpQkFsQm9FO2VBRGpFLE9BQUEsNEJBOUNpQjNuQjtlQThDakIsUUFBQTs7bUJBR21CbVksK0JBQUFBOzs7Ozs7OzZCQWtCbEJ5UCxrQkFBSyxPQUFMQTthQVFxQjtjQU50QkM7Z0JBdEZUZjtjQTRGK0IsT0FBQSx5QkEzRUw5bUI7Y0EyRW5CLE9BQUE7YUFIRixPQUFBOzhDQUhJNm5CO1lBT0E7Z0JBcEROaEM7WUE0REh4TTs7R0FTTTtZQUdMeU87SUFDRGQ7SUFDQUY7SUFDQUk7SUFDQU47SUFDQXZOO0lBQ0RyWjtJQUVBLE9BekJFeW1CO2FBa0JETzthQUNBRjthQUNBSTthQUNBTjthQUNBdk47YUFTQyw0QkFSRnJaO0dBUW9CO1lBR2xCK25CO0lBRURmO0lBQ0FGO0lBQ0FJO0lBQ0FOO0lBQ0F2TjtJQUNPMk87a0JBUVFyMkIsR0FDYixXQUFBLFdBVEtxMkIsTUFRUXIyQixJQUFBQSxHQUNHO1dBbERqQjgwQjthQW9DRE87YUFDQUY7YUFDQUk7YUFDQU47YUFDQXZOOzZDQUNPMk87R0FTWTtZQUdsQkM7SUFFRGpCO0lBQ0FGO0lBQ0FJO0lBQ0FOO0lBQ0F2TjtJQUNPMk87SUFFUixVQUZRQTthQVdBdDJCLFVBQVVDO0tBQUksc0JBWGRxMkIsTUFXVXIyQjs7SUFBb0M7SUFINUMsT0FsQ1JvMkI7YUFxQkRmO2FBQ0FGO2FBQ0FJO2FBQ0FOO2FBQ0F2TjtzQkFZTzNuQjtHQUNGO0dBR0csSUFBUHcyQixPQXpDQUg7WUEyQ0FJLGdCQUNBMUUsS0FDRHBLLGlCQUdEMW5CO0lBRUEsR0FORTh4QixTQUFjc0QsTUFBZHRELFFBQUEyRSxjQUFjckIsY0FBZHFCO0lBTUY7U0FKcUJuQixpQkFBbkJvQixtQkFBbUJwQjs7U0FBbkJvQjtJQUlGO1NBSGtCeEIsaUJBQWhCeUIsZ0JBQWdCekI7O1NBQWhCeUI7SUFHRjtLQUFJQztPQUpGRjttQkFJdUNwQyxLQUFPLE9BQUEsZ0NBQVBBLEtBQXVCO3lCQUFNO2tCQUV0Q3VDLGNBQWFqRCxLQUFLQztLQUM5QztNQUNRLE9BQUEsNkJBRnNDQTtNQUV0QyxRQUFBOzs7T0FFRWlEO09BQU5DO09BSFVqQixTQUdWaUI7T0FIQUMsV0FHWSwwQkFBTkY7O1VBSEloQixTQURnQ2pDLE1BQzFDbUQ7S0FGUixHQUpFTDtNQWdCUTtPQUFBLE9BQUEsMEJBVkZLLFVBSEpKO09BWVFLLGVBQ0Y7T0FMRkM7a0JBT0lDO1VBQW9DLFdBZjVDUCxNQWVRTztVQUFjLFdBQUEsd0JBSGRGO1NBR21EOztVQVB2REMsNkJBRXVCLFNBQUk7S0FPL0IsY0FFd0RDO01BQzdDLGVBQUEsNEJBRDZDQTtvQkFYcERELFdBV29EQztLQUNBO0tBRHhDO01BQUEsT0FBQSxXQWpCWU4sY0FBYWpELEtBQzNCa0M7TUF3QlZuTSxVQVJBOzs7U0FRQUEsYUFBQUE7O1FBREV3TixTQUNGeE47UUFWQXlOLGdCQVNFRCxZQUFzQixzQkFBdEJBOzs7VUFURkMsWUFVQXpOOztLQUVKLGNBQXlCd047TUFBaUMsV0FBQSxzQkExQnRESCxjQTBCcUJHO01BQWlDLE9BQUE7S0FBdUI7S0FBN0QsT0FBQSwwQkFaaEJDO0lBWThFO0lBM0JwRixJQURFbEQsV0FDRiw0QkFKRmwwQjthQWlDSW0wQixVQUFVSztLQUNDLElBQVQ2QyxXQWhDRlQsTUErQlVwQztLQUVULEdBQUEsNEJBREM2QzthQXRDSlo7O2dCQTJDTzttQkFDNkNuQyxLQUFlLFdBdENqRXNDLE1Bc0NrRHRDLE1BQWUsT0FBQSxXQXhDckV0MEIsWUF3Q2dGO0tBQWhFLFdBQUEsNkJBTlZxM0I7S0FNMkMsT0FBQTtJQUFnQztJQUVqRixPQS9QRXBELE9Bd05FQyxVQU5IeE0sS0FvQ0d5TTtHQVMyQjtHQUdqQixvQkE5T1pLLFFBQ0FDLE9BQ0FDLFFBQ0FDLFNBdUxBNEIsTUF0TEFseEIsTUFFQXV2QjtZQWtQQUssY0FBY2oxQjtJQUNoQixZQURnQkE7Z0JBR04sNkJBQWlCLFNBQUU7UUFEdEJzTztJQUFLLE9BQUxBO0dBQ3NCO09BTTdCOFQsU0FBQWtWLGdCQUFBdEYsZUFBQXVGLGdCQUFBdEY7R0FBQTtTQUFBc0Y7T0FBQUQ7S0FBQTtNQUFBRSxnQkFBQUQ7TUFBQUUsZ0JBQUFIO01BQUFJLGdCQUFBSjtNQUFBNVUsZ0JBQUFnVixlQUFBRixnQkFBQXBWO01BQUFBLE1BQUFNO01BQUE0VSxnQkFBQUc7OztNQUFBRSxrQkFBQUo7TUFBQUQsZ0JBQUF0RjtNQUFBdUYsZ0JBQUFJOztHQUFBLDRCQUFBdlY7T0FNSWU7WUEyQ0V5VSxRQUFPQyxRQUFRcHdCO0lBRVUsWUFBQSw2QkFGVkE7OztZQUFSb3dCOzs7WUFDSUMsUUFESXJ3QixLQUNic3dCOzs7O1lBQVNELFFBRElyd0IsS0FDYnN3Qjs7b0JBQVNELFFBRElyd0IsS0FDYnN3Qjs7S0FLcUM7O01BTDVCQztNQUtlaEM7TUFMeEJpQyxnQkFLd0JqQztNQUxmOEIsUUFBQUU7TUFBVEQsVUFBQUU7O0lBT0osV0FQSUYsU0FPSSxnQ0FQS0Q7R0FPc0I7WUFHakNJLE9BQVF4d0IsTUFBTXF3QjtJQUNoQixLQURnQkEsU0FFTixPQUZBcndCO0lBR2U7S0FBbEJ1d0IsWUFIU0Y7S0FHUyxPQUFBLDZCQUFsQkU7SUFBa0IsT0FBQSxzQkFIZnZ3QjtHQUc0QjtZQUtwQ3l3QixpQkFBaUJuNEIsR0FBRW9qQjtJQUNyQixJQTdENEJFLGdCQTREVHRqQjtJQTNEckIsT0FBQSxXQUhFbWpCLG9CQUU0QkcsbUJBNERQRjtHQUN3QztZQUkzRGdWLEtBQ0ZwNEI7UUFDR3lILE1BREh6SCxNQUdHNjNCLFNBSEg3M0IsTUFFR3dILFVBRkh4SCxNQUFHMEgsT0FBSDFIO0lBVUcsR0FBQSw0QkFUQXlIO0tBWUU7O2lCQUF5QjBlLEdBQUssV0FBTEEsR0FBUSxtQ0FibkN6ZSxPQWFnRTtNQUE5RCxPQUFBLDBCQVhGRjtLQVVELGVBWkNFLE1BWU0sZ0NBWE5EOztJQWMwQixJQUFBLFFBeEMzQm13QixRQTRCQ0MsUUFGQXB3QixNQWNrQnF3QixrQkFBYkM7a0JBRXNCNVI7S0FFckIsV0FBQSxtQ0FuQk56ZTtLQWtCSSxXQXhCTHl3QixpQkFNRm40QixHQWRFazRCLE9BK0I0Qi9SLEdBRnRCNFI7SUFJZ0M7SUFGbkMsV0FBQSwwQkFmRnZ3QjtJQWNELGVBdEJBMndCLGlCQU1GbjRCLEdBZEVrNEIsT0FjQ3h3QixNQWVLcXdCLFdBQWFEOztZQVFyQk8sTUFDRnI0QjtJQVcyQjtLQVZ4QnlILE1BREh6SDtLQUdHNjNCLFNBSEg3M0I7S0FFR3dILFVBRkh4SDtLQUFHeWpCLFNBQUh6akI7S0FXMkIsUUE1RHZCNDNCLFFBb0REQyxRQUZBcHdCO0tBVWdCcXdCO0tBQWJDO0tBdEVlM1UsWUFxQmpCOFUsT0FzQ0R6VSxRQVdHc1U7S0FDRnJ3QixPQXRFSixXQWxDRXliLGdCQTRGRm5qQixNQTNEcUJvakI7SUF3RXJCLFdBREkxYixNQURlb3dCLE9BVGhCdHdCOztZQWNEOHdCLFNBQU90dkI7SUFDVCxjQUN1RHlkLE1BQVEsV0FBUkEsU0FBQUEsTUFBdUI7SUFBL0M7S0FBQSxPQUFBLDBCQUZ0QnpkO0tBRVAsUUFBQTs7S0FJQTtNQURJcUY7TUFDSixnQkFFdUI4WCxHQUFLLE9BQUEsbUNBQUxBLE1BQXdEOztpQkFEeENvUyxPQUFBQyxPQUFBLE9BQUEsc0JBQUFELE9BQUFDLE9BQU07c0JBRGYvUixNQUFRLFdBQVJBLFNBQUFBLFNBQWlDO01BQS9ELE9BQUEsMEJBTk96ZDtNQU1QLE9BQUE7S0FBQTtLQUFBLE9BRElxRjs7UUFEV29ZO0lBQVEsT0FBQSxtQ0FBUkE7R0FLWjtZQWFMZ1MsU0FBUy93QixNQUFLZ3hCLFVBQVNDLE1BQUtDLE9BQU16VDtJQW9CdEIsV0FwQkV1VDthQUlQRyxPQUFPakYsS0FBSW9DO0tBQ1AsWUFyYVhoQyxNQWdhYzBFLFVBSUkxQzs7TUFPVCxJQUxJdkMsa0JBS0osT0FBQSwyQkFMSUE7TUFDTixPQUFBLFdBN2xCVGQsVUFzbEJXanJCLE1BSVNzdUI7O0tBVUQ7TUFEUDhDO01BQ0NDLFFBQU0sV0FkV0gsT0FJZGhGLEtBU0prRjtNQUVJLFVBZkFKO21CQWdCSSxPQUZQSztTQUdJclI7S0FBTyxPQUFBLFdBdGxCdEJxTCxXQW1sQldnRyxPQUdJclIsS0FKTG9SO0lBSTZDO0lBaEJ6RCxlQUdTRCxRQUpPSCxjQUFTQyxNQUFXeFQ7R0FxQm5DO1lBa2hESzZULFNBL2dETWg1QixHQUFVc08sR0FBRTJxQjtJQUN4QjtLQUFtRCxRQUFBLFdBRHZDajVCLEdBQVlpNUI7S0FDYWxGO0tBQWpCNU87S0FBTndUO0tBQVJkO0lBQ047WUFETUE7cUJBRVFqRSxLQUFPLE9BQW9CLGtCQUFBLFdBRjNCK0UsTUFFQS9FLE1BSFF0bEIsR0FHZ0M7WUFGbEM2VztZQUFpQjRPO0dBS3BDO1lBR0NtRixhQUFheHhCLE1BQUtnZ0IsS0FBSWtNLEtBQUlvQztJQUM1QixPQUFzQjs7YUFERXBDO2FBQUpsTTs7Y0FDRSxlQUVSLFdBMW5CZGlMLFVBdW5CZWpyQixXQUFhc3VCO2FBRzhCO0dBQUE7WUFHeERtRCxlQUFnQkMsV0FBUVYsVUFBU2h4QixNQUFLeWQ7SUFDeEMscUI7SUFBVSxJQUFOdUMsTUFBTSxtQ0FEeUJoZ0I7YUFFL0JpeEIsS0FBSy9FO0tBQ0QsWUFBQSxpQkFEQ0EsS0FETGxNO21CQUdLbEIsY0FBSyxPQTlqQlpnTixnQkE4akJPaE47UUFKUzRTLGVBT05uRCxNQVBNbUQsY0FPRCxPQWxrQmY3RixjQWtrQlUwQztLQUtnQixXQUFBLG1DQVpPdnVCO0tBVzFCLE9BcGtCUCtyQix3QkFxa0JTO0lBQThEO2FBRXJFbUYsTUFBTWhGLEtBQUlvQyxLQUFNLE9BcEJsQmtELGFBTWlDeHhCLE1BQy9CZ2dCLEtBYU1rTSxLQUFJb0MsS0FBbUM7SUFDakQsT0F0REV5QyxTQXVDaUMvd0IsTUFBVGd4QixVQUV0QkMsTUFZQUMsT0Fkb0N6VDtHQWVTO1lBOC9DM0NrVSxTQTMvQ0tYLFVBQVNoeEI7SUFBTyxPQWxCekJ5eEIsa0JBa0JTVCxVQUFTaHhCLE1BbExoQnlxQjtHQWtMZ0Y7WUEwL0M5RW1ILHNCQXgvQ2tCRixXQUFRVixVQUFTaHhCO0lBQ3pDLE9BckJFeXhCLG1CQW9Cc0JDLFlBQVFWLFVBQVNoeEIsTUFyTHJDMmI7R0FzTDhEO1lBcy9DNURrVyxTQW4vQ0tiLFVBQVNoeEI7SUFDcEIscUI7SUFBVSxJQUFOZ2dCLE1BQU0sbUNBRFVoZ0I7YUFFaEJpeEIsS0FBSy9FO0tBQ0QsSUFFSjRGLFFBRkksaUJBREM1RixLQURMbE07WUFJQThSLFFBdmxCRmhHLGdCQXVsQkVnRyxTQXhsQkZqRztJQXdsQjBEO2FBRXhEcUYsTUFBTWhGLEtBQUlvQyxLQUFNLE9BckNsQmtELGFBOEJrQnh4QixNQUNoQmdnQixLQU1Na00sS0FBSW9DLEtBQW1DO0lBQ2pELE9BdkVFeUMsU0ErRGtCL3dCLE1BQVRneEIsVUFFUEMsTUFLQUMsT0FoTUF2VjtHQWlNMEQ7WUFHNURvVyxlQUFnQkMsYUFBYUMsV0FBV0MsaUJBQWdCbHlCO0lBQ2hELElBQU5nZ0IsTUFBTSxtQ0FEZ0RoZ0I7YUFFdERpeEIsS0FBSy9FO0tBQ1AsR0FBTSxnQkFEQ0EsS0FETGxNLE1BR1EsT0FqbUJWOEw7VUE2bEJnQmtHLGFBWVQsT0ExbUJQbkc7S0F5bUJ5QixXQUFBLG1DQVgrQjdyQjtLQVVsRCxPQXRtQk4rckIsd0JBdW1CUTtJQUNrQzthQU94Q29FLE9BQU9qRTttQkFFaUNBO01BQUwsSUFBZTRGLGtCQUFMOVI7TUFDM0MsT0FBQSxXQXBxQkpzTCxrQkFtcUIwQ1ksS0FBS2xNLEtBQUs4UjtLQUNOO0tBRDVDLElBUE1ULFFBT04sNEJBckIyQlksV0FtQnBCL0Y7S0FKTixPQUFBLGdCQURLbUYsT0FiTnJSO2VBZUcsV0FockJQaUwsVUFncUIwRGpyQjtlQWlCbkQsZ0JBSEdxeEIsT0FiTnJSO0lBdUJPO0lBRVgsR0ExQjBDa1M7O01BNkJqQ3RyQixJQTdCaUNzckI7TUEwQnRDQztpQkFJSWpHO1NBQ1EsSUFBTm1GLFFBWk5sQixPQVdJakU7U0FFRixXQUhHdGxCO1NBR0gsT0FESXlxQjtRQUVEOztTQVBMYyxXQVBBaEM7SUFzQlU7S0FBQSxPQUFBO1lBekNJNkIsY0FuTWR2SCxlQURBOU87SUF1T0osZUFUSXdXLFdBeEJBbEI7R0F3Q0g7WUF5N0NLbUIsT0F0N0NHcHlCLE1BQ1QsT0E5Q0UreEIsd0JBNkNPL3hCLE1BQ21FO1lBczdDdEVxeUIsZ0JBbjdDWXZULEdBQUU5ZTs7S0FHZixpQkFIYThlO0tBS0gsTUFBQTtJQUFhO0lBRnZCLElBQUE7SUFGTCxPQTI2Q013Uzs0QixPQTc5Q0pTOzthQWlEa0IveEI7R0FNZDtZQTg2Q0FzeUIsZ0JBMzZDYXRTLEtBQUs4UixPQUFNOXhCO0lBQzlCLE9BM0RFK3hCLDBCQTBEaUIvUixLQUFLOFIsWUFBTTl4QjtHQUtQO1lBdzZDakJ1eUIsWUFyNkNRVDt5QkFDSyxtQkFETEEsV0FHSTtJQUZDLHNCLE9BMDVDYlIsU0FNQWM7R0E5NUNZO1lBMjVDWkksT0F4NUNHeEIsVUFBU2h4QjtJQUNsQixjQUFtRXl5QjswQjt3Q0FBQUE7O0lBQXpELElBQU56UyxNQUFNLGtDQURRaGdCO2FBRWRpeEIsS0FBSy9FO0tBQ1A7TUFBZSxPQUFBLDRCQURSQSxLQURMbE07TUFJQTBTLGFBRkk7WUFFSkEsYUExcUJGNUcsZ0JBMHFCRTRHLGNBM3FCRjdHO0lBMnFCb0U7YUFFbEVxRixNQUFNaEYsS0FBSW9DO21CQUE4Q3FFLE1BQVEsV0FBdERyRSxLQUE4Q3FFLE1BQW1CO0tBQXhCLE9BQUEsNEJBQTdDekcsS0FOTmxNO0lBTTRFO0lBQ2hGLE9BMUpFK1EsU0FrSmdCL3dCLE1BQVRneEIsVUFFTEMsTUFLQUMsT0FyUkExRztHQXNSaUQ7WUFpNUMvQ29JLG9CQTk0Q2dCNUIsVUFBU2h4QjtJQUMvQixjQUFtRTZ5QjswQjt3Q0FBQUE7O0lBQXpELElBQU43UyxNQUFNLGtDQURxQmhnQjthQUUzQml4QixLQUFLL0U7S0FDUDtNQUFlLE9BQUEsNEJBRFJBLEtBRExsTTtNQUVJLFFBQUE7O1VBQ0s4UyxpQkFBVEM7TUFBaUQsT0FwckJuRGpILG9CQW9yQkVpSCxPQUFTRDs7S0FLWSxXQUFBLG1DQVRNOXlCO0tBUXpCLE9BdnJCSityQix3QkF3ckJNO0lBQTZEO2FBRWpFbUYsTUFBTWhGLEtBQUlvQzttQkFBOEMwRSxHQUFLLFdBQW5EMUUsS0FBOEMwRSxHQUFhO0tBQWxCLE9BQUEsNEJBQTdDOUcsS0FWTmxNO0lBVXNFO0lBQzFFLE9BektFK1EsU0E2SjZCL3dCLE1BQVRneEIsVUFFbEJDLE1BU0FDLE9BblNBdFY7R0FvUzJEO1lBbTRDekRxWCxvQkFoNENnQmpDO0lBQ3RCLHFCQUE0QyxJQUFTaEcsZUFBSHZNLGNBQVUsV0FBVkEsR0FBR3VNLElBQWU7SUFBcEUsb0IsT0E4M0NNNEgsb0JBLzNDZ0I1QjtJQUNzQixzQixPQTAzQ3RDTTtHQTEzQzhEO1lBR2xFNEIsZUFBZ0IxRyxVQUFVMEYsaUJBQWdCbHlCO0lBQzVDLGNBQTBDbXpCLE8sd0NBQUFBO0lBQWhDLElBQU5uVCxNQUFNLG1DQURrQ2hnQjthQUV4Q213QixPQUFPakUsS0FBSWtIO0tBQVcsT0FBQSxnQkFBZmxILEtBRFBsTSxLQUNXb1Q7SUFBMEM7YUFDckRuQyxLQUFLL0U7S0FDRCxJQUVKNEYsUUFGSSxpQkFEQzVGLEtBRkxsTTtZQUtBOFIsUUF6c0JGaEcsZ0JBeXNCRWdHLFNBMXNCRmpHO0lBMHNCMEQ7SUFFNUQsR0FSNEJxRzs7TUFXbkJ0ckIsSUFYbUJzckI7TUFReEJDLG9CQUlJakcsS0FBSXpOLEdBQ04sV0FGRzdYLEdBQ0c2WCxJQUNOLE9BWEYwUixPQVVJakUsS0FBSXpOLEdBRU07O1NBTmQwVCxXQU5BaEM7SUFjSjtnQkFSSWdDLFVBUmMzRjtZQUdkeUU7WUE3U0F0VjtZQTZUVTtHQUNiO1lBNDJDSzBYLGFBejJDVXhJLE1BQUs3cUI7SUFRUCxXQUFBO3lCQURSLE9BbHVCSjZyQixpQkFrdUJvQztJQU50Qzs7O2NBQXFELFdBQUEsV0FEckNoQjtjQUNxQyxPQUFBO2FBQVM7O1lBbFUxRGxQOztHQTBVSDtZQXcxQ0syWCxPQXIxQ0d0ekIsTUFBTyxPQW5DZGt6QixxQkFtQ09sekIsTUFBK0Q7WUFzMUNsRXV6Qix5QkFwMUNzQi9HLFVBQVN4c0IsTUFDckMsT0F0Q0VrekIsbUJBcUMwQjFHLGNBQVN4c0I7R0FDOEI7WUFJL0R3ekIsU0FBUUMsTUFBS3p6QjtJQUNmLE9BakpBK3hCLHlCQWdKVTBCLE9BQUt6ekI7R0FDb0U7WUFHakYwekIsU0FBUUQ7SUFBTyxJQUErQyxXQUF0REEsT0FBc0Q7SUFBQSxzQixPQTlDaEVQO0dBOEMyRTtPQXNCM0VTO1lBQ0FDLFNBQVFwcUIsYUFBYyxXQUFkQSxnQkFBNkI7WUFFckNxcUIsT0FBT3Y3QixHQUFHdzdCLFlBQWEsV0FBYkEsWUFBSHg3QixHQUErQjtPQUN0Q3k3QjtZQUVBQyxtQkFBbUIxN0I7SUFDZixZQUFBLDBCQURlQTtnQkFFYjtRQUNBODJCLGVBQU5DO0lBQVksV0FBQSw4QkFBWkEsS0FBTUQ7R0FBcUM7WUFHM0MvMkIsVUFBVUM7SUFBWSxJQTMxQmhCMHlCLEtBcTFCTmdKLG1CQU1VMTdCO0lBMzFCQyxPQUFBLGlDQUFMMHlCO0dBMjFCc0M7T0FDNUNpSjtZQUVBQyxjQUFjNTdCLEdBQ1E2N0IsTUFBTUM7SUFBOUIsSUFBWUMsVUFRUixXQXBCRk4sT0FXY3o3QixJQUNKZzhCLFVBQUFELFNBQU8zWjtJQUNqQjtVQURVNFosU0FFRixPQUZTNVo7U0FBUDZaLFVBQUFELFlBR1JqRixLQUhRaUY7S0FJTCxHQUFBLDRCQURIakYsSUFIb0I4RTtNQUtJLE9BQUEsMEJBTGhCSSxhQUFrQkgsSUFBWDFaO0tBTUUsSUFORk0sWUFHZnFVLElBSGUzVSxNQUFQNFosVUFBQUMsU0FBTzdaLE1BQUFNOztHQVFhO1lBUTlCd1osZUFBZWw4QjtJQUNqQixHQURpQkE7S0FHMkI7TUFBakN1eEIsT0FITXZ4QjtNQUdkbThCLE9BSGNuOEI7TUFHMkIsT0FBQTtpQkFBekNtOEIsTUFBd0IsMEJBQWhCNUs7OztJQUFRLE9BdkJqQnh4QjtHQXdCVTs7SUFHVnE4QjtJQTJCRXAzQjtJQUNBTTtZQUVJKzJCO0lBQWlCO0lBQUE7cUNBQ2I7OztRQUNDOztRQUNDOztRQUNDOztRQUdKLElBREFsM0IsaUJBQ0EsUUFBQSwwQkFEQUE7b0JBRUUsT0FBQTtZQUNFbTNCLG1CQUFSSDtRQUNPLEtBQUEsMEJBRENHLFFBVFBEO1NBVUQsTUFBQTtzQkFEQUY7O2dCQUpTOzs7R0FNVztZQUduQkk7SUFBUTtJQUFBO3FDQUNKOzs7WUFDSnpZLGdCQUFLLFdBQUxBOztZQUNDOWpCLDBCQUFBQTs7WUFDQ2lGLDRCQUFBQTs7WUFFQ0UsaUJBQU0sT0FBQSwwQkFBTkEsSUFOSG8zQjtvQkFLR0Msa0JBQUssV0FBTEE7OztHQUNpQztPQUd4Q0M7WUEyQkFDO0lBQVMsWUFDSDtRQUNDQyxnQkFBUEM7eUJBRWtEQztLQUFmLElBQVV6YSxnQkFBSjBhO2VBQUFBO1VBRTdCOThCLElBRnNDNjhCOztnQkFBQUE7T0FJekMsR0ExRExSLGVBc0RxQ1MsS0FLOUIsV0FMdUNELFFBQVRDLElBQUkxYTtPQWNuQztRQUFBLE9BQUEsV0F0RVY5YyxPQXdEeUN3M0I7UUFhL0IsT0FBQSxXQXJFVngzQixPQXdEa0R1M0I7UUFZeEM7VUFBQTtZQXBFVnYzQixXQW9FeUIsOEJBWnlCdTNCLFFBQVRDLElBQUkxYTtPQU9yQyxPQUFBOztVQUxJcGlCLElBRjZCODhCOztLQUVkLFdBQWY5OEIsR0FGaUNvaUI7SUFlaEM7SUFmWDtLQUFBLFFBQUEsMEJBRkt1YSxTQUFQQztLQUNTRztLQUFMQztJQWtCSixPQWxCU0QsWUFvQlcsOEJBcEJoQkMsT0FBS0QsV0FBTEM7R0FvQndDO1lBdUUxQ0Msa0JBQXNDM3VCO1FBQVo0bEIscUJBQVBGLGtCQUFOdHNCO2FBQ1hrd0IsUUFBTTVCLEtBQUtrSDtLQUNiO01BQTZCLFFBQUEsV0FGVmxKLE9BQ1hnQyxLQUFLa0g7TUFDQ0M7TUFBUkM7S0FDTixXQUFXLFdBSDJCOXVCLEdBRWhDOHVCLFNBQVFEO0lBQ21CO0lBRW5DLGVBTGV6MUIsTUFDWGt3QixTQUR3QjFEOztZQVExQm1KLG9CQUVBbFg7SUFGc0IsT0FFdEJBOztPQURVOztXQUVVbVgsS0FEcEJuWCxNQUMwQixPQUFObVg7ZUFEdUIsZUFBM0NuWDs7R0FDNEI7WUFHeEJvWCxTQUFRQyxRQUFPQztJQUNyQjs7WUFEY0Q7O1lBR1BsdkIsSUFIT2t2QjtlQUFPQzs7ZUFHTnRYLElBSE1zWDtXQUluQjs0QkFDTzdKO29CQUNIO3FCQUFJOEosWUFBWSxXQUhmcHZCLEdBRUVzbEI7cUJBRUMrSixZQUFZLFdBSlB4WCxHQUVOeU47b0JBR0gsT0FBQSxXQUZJOEosV0FDQUM7bUJBQ2U7O2VBR1ZDLE9BWE1IO1dBV3FCLE9BekJ4Q1IsV0F5QmFXLGVBQWdDQyxJQUFNLE9BWC9DTixTQUFRQyxRQVdpQ0ssSUFBbUI7O2VBUW5EQyxPQW5CTUw7V0FtQkU7NEJBQVdHO29CQUFRLE9BbkJwQ0wsU0FBUUMsUUFtQnVDLFdBQXRDTSxNQUFtQkY7bUJBQTZCOzs7dUJBSDVDQyxLQWhCRUosWUFnQk4zRyxLQWhCRDBHOzs7O1lBVVBPLFNBVk9QO1FBVXVCLE9BeEJuQ1AsV0F3QktjLGlCQUFtQ2pILElBQU0sT0FWMUN5RyxTQVVvQ3pHLElBVnJCMkcsU0FVeUM7O1lBUXZETyxTQWxCT1I7UUFrQkk7eUJBQVdJO2lCQUFRLE9BbEIvQkwsU0FrQitCLFdBQTlCUyxRQUFzQkosT0FsQlJIO2dCQWtCc0M7O1lBRnhDSSxLQWhCRUosU0FnQk4zRyxLQWhCRDBHOzs7S0FnQjZDLFdBaEJyREQsU0FnQlN6RyxJQUFJK0c7O0lBRmlDO0tBQUEsT0FwQmxEUixvQkFNbUJJO0tBY0UsT0FwQnJCSixvQkFNWUc7SUFjWixXQUFvQjtHQUswQztZQUc5RFMsU0FBTzNZLEdBQUksMkJBQWUsT0FBbkJBLEVBQW9CLEdBQUM7WUFDNUI0WSxXQUFRbCtCLEdBQUVzTyxHQUFJLE9BdkJWaXZCLFNBc0JKVSxTQUNVM3ZCLElBQUZ0TyxHQUFvQjtZQUM1Qm0rQixTQUFTN3ZCO0lBQUksb0JBQVVzbEIsS0FBTyxPQUFBLFdBQXJCdGxCLEdBQWNzbEIsS0FBWTtHQUFDO1lBYXRDd0ssYUFBUXArQixHQUFFc087SUFBSSxPQWRaNHZCLFdBY01sK0Isa0IsK0JBQUVzTztHQUFnQztZQUMxQyt2QixTQUFRYixRQUFPQztJQUFVLE9BdENuQkYsU0FBQUEsU0FzQkpVLGtCQWdCTVQsU0FBT0M7R0FBK0Q7WUFDOUVhLFNBQU9oWixHQUFJLE9BakJUMlksU0FpQmdCLHFCQUFYM1ksSUFBcUM7WUFDNUNpWixrQkFBZ0JqWjtJQUFJLDJCQUFlLE9BbGhDckNrTyxnQkFraENrQmxPLEdBQW9EO0dBQUM7WUF5QnJFa1osSUFBSzkyQixNQUFLZ3hCO0lBQ1o7cUJBQ1FrRjthQUNKLEtBRElBO2NBSUY7O3VCQUt5QixXQUFBLG1DQVh4QmwyQjt1QkFVSyxPQXBqQ1orckI7a0RBcWpDYztzQkFBa0U7c0JBaEM1RW1FLFFBQU02RyxNQUFNdkI7Y0FDUixZQXA2QlJsSixNQXc3QlkwRSxVQXJCRitGOzs7Z0JBVUhqWTs7MkJBR01vTjtpQ0FDbURBLEtBQUlsTTtvQkFDeEQsT0FKUixXQW5sQ0pxTCxXQXNsQ2dFYSxLQUFJbE0sS0FKN0RsQjttQkFLbUM7bUJBRGlCLE9BQUEsNEJBTy9Da1MsYUFSQzlFO2tCQUU4QjtlQUp2QyxXQWZGMkssa0JBY0svWDs7a0JBUkdpTjtjQUNOLEdBSFl5SjtlQU9WLCtCQUFBO2NBRWdELFdBQUEsMkJBUDVDeko7Y0FPSixPQUFBLFdBbG1DUmQsVUE4bUNTanJCLE1BckJHKzJCO2FBZ0JMO2FBRUwsZUFHTy8yQixNQXJCSGt3QixTQXFCUWM7WUFXcUU7R0FBQztZQVNoRmdHLFNBQVMxK0I7SUFDWCxJQUFRMitCOztNQUFBQTs7Z0JBRUVmO1FBQ0osT0FESUE7a0JBbERSUzttQkFBQUE7cUJBQ0FDLGtCQWtENkI5WCxHQUFFcEUsS0FBTyxXQUFUb0UsR0FBRXBFLEtBQWUsSUFKckNwaUI7bUJBQ0gyK0I7a0JBL0NOTDtPQWtENkU7SUFFL0UsT0FMUUs7R0FLSjtZQXlCRUMsUUFHRjUrQixHQUFFZzJCLEtBQUtrSDtJQUNYLElBRElqNEIsTUFBQWpGO0lBQ0o7WUFESWlGOztRQUVRLE9BQUEsV0F0cUNkMHRCOztRQXlxQ2lDO1NBRHRCcUIsUUFKTC91QjtTQUsyQixRQUFBLFdBRHRCK3VCLE9BSkhnQyxLQUFLa0g7U0FLS0M7U0FBUkM7UUFDTixXQURNQSxXQUFRRDs7UUFGSSxJQUFiN3VCLElBSEhySixRQUFBQyxNQUdnQixXQUFib0osT0FISHJKLE1BQUFDOztZQVFrQjI1QixTQVJsQjU1QjtRQVNGLEtBRG9CNDVCLFFBR2pCLGtDQUFBO1FBR0U7U0FGVXJFLE9BSktxRTtTQUlWQyxNQUpVRDtTQU1mLFVBakJERCxRQWVNRSxLQVpOOUksS0FBS2tIO1NBYUM2QjtTQUFZQztTQUFhQztTQUtBLE9BL0lqQzVCLG9CQTBJaUM0QjtRQUdoQztvQkFFK0IsNEJBTm5CekU7Z0JBQ093RTtnQkFBWkQ7O1FBTlUsSUFBUEcsTUFQWGo2QixRQU9rQixPQVZoQjI1QixRQVVTTSxLQVBUbEosS0FBS2tIO1FBT1M7O0dBWWI7WUF5N0JITCxHQTM1QkRDLElBQUdEO0lBQ1I7S0FDWSxPQXRSUkgsYUFvUkNJLFdBQUdEO1lBQUFBO1lBQUhDO0lBQ0w7WUFuSUl1QjtjQUFBQSxTQUNBQyxrQkFrSWNhLElBQUdDLElBQU0sV0FBVEQsSUFBR0MsSUFBWTs7O0dBRWhDO1lBeTVCS0MsR0F0NUJEdkMsSUFBR0QsSUFBR3dDO0lBQ1g7S0FDWSxPQTVSUjNDLGFBMFJDSSxXQUFHRCxXQUFHd0M7WUFBQUE7WUFBSHhDO1lBQUhDO0lBQ0w7WUF6SUl1QjtjQUFBQTtnQkFBQUE7a0JBQ0FDLGtCQXdJY2EsSUFBR0MsSUFBR0UsSUFBTSxXQUFaSCxJQUFHQyxJQUFHRSxJQUFnQjs7Ozs7R0FFdkM7WUFvNUJLQyxHQWo1QkR6QyxJQUFHRCxJQUFHd0MsSUFBR0U7SUFDZDtLQUNZLE9BbFNSN0MsYUFnU0NJLFdBQUdELFdBQUd3QyxXQUFHRTtZQUFBQTtZQUFIRjtZQUFIeEM7WUFBSEM7SUFDTDtZQS9JSXVCO2NBQUFBO2dCQUFBQTtrQkFBQUE7b0JBQ0FDOytCQThJY2EsSUFBR0MsSUFBR0UsSUFBR0UsSUFBTSxXQUFmTCxJQUFHQyxJQUFHRSxJQUFHRSxJQUFvQjs7Ozs7O0dBRTlDO1lBR0NDLFVBQVVuTDtJQUVaLElBQUlvTCwrQkFGUXBMO2FBRVJvTCxRQUNlO0lBQ0YsV0FBQSxnQ0FKTHBMO0lBSVQsR0FBQSxrQ0FKU0E7S0FLUCxtQ0FMT0E7SUFTUjtLQURFcUwsZ0JBQ0Y7S0FFbUIsT0FBQSx3QkFIakJBO0tBREZDLG9CQUlGLDRCQVhVdEw7SUFhWixPQU5Jc0wsb0JBUFF0TCxNQWF1Qiw0QkFidkJBO0dBYTJDO1lBcTNCakR1TCxTQWwzQkduNEIsTUFBS2d4QjtJQUNILElBQVBqVixTQWpCRmdjLFVBZ0JPLzNCO0lBRVQsV0EzSUk4MkIsSUEwSUEvYSxRQURVaVYsZUFDVmpWO0dBQ3lEO1lBaTNCdkRxYyxVQTkyQk05L0IsR0FBR3NPO0lBQUksV0FBUHRPO0lBQU8sV0ExS2ZvK0IsYUEwS1FwK0IsTUFBR3NPO0dBQTBDO1lBKzJCbkR5eEIsTUE5MkJFLy9CO0lBQUksSUF0VVJpRixNQXNVSWpGLG9CQXRVSmlGLDJCQUFBQSxNQXFNTUMsTUFpSUZsRjtJQUFJOztzQkEvSEY0OUI7Y0FDSixPQURJQTt3QkEzQ05TO3lCQUVBRSwyQkEwQ29DalosR0FBSyxXQUFMQSxHQUFXLElBSHpDcGdCO3dCQXhDTm81QjthQTJDdUU7O0dBOEhKO1lBKzJCakUwQixtQkE3MkJlNUcsV0FBUXA1QjtJQUM3QixJQUFJaUYsTUEyMkJFODZCLE1BNTJCdUIvL0IsV0FDekJpRjtrQkFDc0J1aEIsR0FBSyxtQ0FBTEEsR0FGTDRTLFdBRWlDO0lBQXRELFdBL0tJZ0YsYUE4S0FuNUI7R0FDcUQ7WUE4MkJuRGc3QixXQTMyQktqZ0M7SUFBSSxJQXpWWGlGLE1BeVZPakY7Y0F6VlBpRjs7O1lBNUJJbzNCLGVBNEJKcDNCO01BS0ksV0FBQSxXQW5DSkssT0E4QkFMO01BR0U7O29CQUhGQTs7SUF5VlcsV0FsSVh5NUIsU0FrSU8xK0I7R0FBaUU7WUEwMkJ0RWtnQywyQkF6MkJ1QmxnQyxHQUFJLE9BMjJCM0I2OEIsR0EzMkJ1Qjc4QixHQTAyQnZCaWdDLFdBMTJCdUJqZ0MsSUFBcUI7WUF3MkI1Q21nQywyQkF0MkJ1Qm5nQztJQUM3QixJQUFJaUYsTUFzMkJFaTdCLDJCQXYyQnVCbGdDLFdBQ3pCaUY7eUJBQ2tCLElBQVF5dEIsZUFBSHZNLGNBQVUsV0FBVkEsR0FBR3VNLElBQWM7SUFBNUMsV0F2TEkwTCxhQXNMQW41QjtHQUMyQztZQU0zQ203QixPQUFRQztJQUNWO1lBOUlFM0IsU0FwQkFGO2dCQWlLUTZCO0dBS1Q7R0FNTCxTQUFBeGdDLFFBQUF5Z0MsT0FBQUM7SUFBQSxJQUFBQyxVQUFBRixPQUFBRyxVQUFBRjtJQUFBO1FBQUFDLFlBQUFDLFNBQUE7ZUFBQUQ7b0JBQUFDO2NBQUFEO1VBQUFFLFFBQUFGLFlBRUVHLFFBRkZIO2dCQUFBQztnQkFBQUEsWUFFRTtPQUFVO1FBRlpHLFFBQUFIO1FBRUVJLFFBRkZKO1FBRVl2NUIsSUFBQSxzQkFBVnk1QixPQUFBRTtnQkFBVTM1QixHQUFBLE9BQUFBO1dBRlpzNUIsVUFBQUUsT0FBQUQsVUFBQUc7Ozs7O1VBR0VFLFFBSEZOO2dCQUFBQztnQkFBQUEsWUFFRTtXQUNBTSxRQUhGTjtPQUdnQixPQUFBLHNCQUFkSyxPQUFBQzs7O0tBRkE7O0dBR2tCO1lBRWhCQyxRQUFRQztJQUFPO2tCQUF1Q2pMLEtBQUlpTCxNQUFRLFdBQVpqTCxLQUFJaUwsTUFBd0I7SUFBbkUsT0FBQSwyQkFBUEE7R0FBMkU7WUFFL0VDO0lBQVUsOEJBQ1A7O1NBQ0V4TyxlQUFIdk07S0FBVSxXQUFWQSxHQUZGK2EsUUFFS3hPOztRQUNBeU87SUFBSyxXQUFMQTtHQUFVO1lBR2ZDO0lBQW1CO0lBQUE7cUNBRWhCOzBCQURPO1NBRUxILDZCQUFBQTs7R0FBOEI7WUFHdkNJLE9BQU9yaEMsR0FBR3FoQyxRQUFRL3dCO0lBQ3BCLEdBUE04d0IsaUJBTUdwaEMsSUFFSixPQUZJQTtJQUkyQztLQUFBLE9BQUEsV0FwZWxEeTdCLE9BZ2VrQm5yQjtLQUl1QixPQUFBO0tBQXJDZ3hCLFlBQVk7S0FDSyxPQUFBLFdBTFhELFFBSU5DO0tBQ0ssT0FqQkxKLFFBWUdsaEM7SUFLQyxPQW5CUmdoQyxRQW1CUTtHQUErQjtZQWdCekNPLFlBQVVoYSxVQUFTaWE7SUFUckIsY0FBNENDLEdBQUssT0FBQSwwQkFBTEEsT0FBcUI7SUFBOUQsR0FBQSw0QkFTa0JEO0tBTGpCLFdBQUEsb0NBS1FqYTtLQVBWLHlDQU9tQmlhOztTQUFUamEsVUFRYSxPQUFBLDRCQVJKaWE7SUFJaEIsR0FBQSw2QkFKZ0JBOzs7Ozs7Ozs7MkJBSXFCRTtZQUFBLE9BQUEsb0NBQUFBO1dBQThCOzs7S0FBekMsb0NBSm5CbmEsVUFBU2lhOztJQUtoQixHQUFBLDRCQUxnQkE7Ozs7Ozs7OzsyQkFNSEc7WUFBQSxPQUFBLG9DQUFBQTtXQUFvRDs7O0tBQS9ELG9DQU5LcGEsVUFBU2lhOztJQU9oQixPQUFBLDRCQVBnQkE7Y0FBQUE7Y0FPK0IsNkJBUC9CQTtHQVF3QjtPQUczQ3BhO1lBb0NJd2E7UUFBMkJILGFBQVBuYztJQUFlLE9BQUEsV0FqM0N2Q0QscUJBaTNDd0JDLEdBQU9tYzs7WUFxQjdCSSxNQUFNN2hDO0lBUFIsY0FHMkJzbEIsR0FBRTlLLEdBQUssbUNBQVA4SyxNQUFFOUssTUFBaUM7SUFIOUQ7S0FBQSxPQUFBLHlCQU9ReGE7S0FQUixPQUFBLGdDQWoxQklxNEI7S0FpMUJKLE9BQUE7S0FBQSxPQUFBO0tBVVUsV0FIRnI0QjtrQkFFK0JrSixRQUFVLE9BQUEsV0FBVkEsV0FBbUI7SUFBL0MsV0FBQSw0QkFGSGxKO0lBQ1IsV0FEUUE7R0FLUDtHQUdZO0lBQVg4aEMsV0EvM0NBaFA7SUFnNENBaVAsV0FoNENBalA7SUFpNENBa1AsV0FqNENBbFA7SUFrNENBbVA7SUFDQUM7WUFRQUMsb0JBQW9CbmlDLEdBQUVzbkI7SUFDeEIsSUE1RTJCalosTUEyRUxyTyxNQTNFZ0J1bkI7SUFDeEMsY0FDeUNkO0tBQ3JDO01BT00yYixnQkFSK0IzYjtNQUcvQjRiLDZCQUgrQjViO01BRS9CamYsVUFGK0JpZjtNQUMvQi9lLE9BRCtCK2U7TUFhakNnQixXQWJpQ2hCLE1BUS9CMmI7TUFNRkUsWUFBVSxzQkFYUkQsNEJBREE3NkI7S0FhTixjQUF5Qys2QixPQUFTLFdBQVRBLE9BRnJDOWEsTUFFeUQ7S0FBN0QsZUFkTS9mLE1BWUYrZixPQUVZLDBCQURaNmE7SUFDMEQ7SUFmaEQ7S0FBQSxPQUFBLHlCQUZXajBCO0tBQ3pCZ1osUUFDRjtJQWlCRjtLQUFxQyxJQUFjbWIsY0FBUkM7S0FBa0IsT0FBQSw0QkFBbEJBLElBQVFEO0lBQStCO0lBQTVFLFlBQUEsMkJBbEJGbmI7OztNQW9CSVo7Z0JBQVksbUNBQVpBOzttQkFERSxXQXRCUlcsZUFHRUMsT0EwRXNCQyxRQTNFY0M7OytCQThFckJtYixxQkFBWHRmO0tBQW9CLFdBQXBCQSxXQUFXc2Y7O1FBRFQ3UDtJQUFPLE9BQUEsV0E3NUNmRixVQTY1Q1FFO0dBQ3dDO1lBeUc5QzhQLFFBQVFDLEtBQUsxRixnQkFBZ0I1c0IsTUFBTXV5QjtJQUNyQyxHQURVRCwyQ0FBSzFGO0tBRXlDLE9BN2hEdEQzSztPQTJoRFFxUSw0QkFHTXBRLFNBSE5vUSxRQUdrQixPQTloRDFCclEsS0E4aERjQztPQUhOb1E7U0FPeUIvUCxNQVB6QitQLFFBS0pFLFVBRTZCalE7OzttQ0FQekIrUDtNQUtKRSxVQUdLO0lBRUssSUFBVkMsVUFBVSw0QkFWcUJGO0lBV25DLEdBRElFO0tBU1c7TUFBQSxPQXBzQmZoakMsVUFpckI2QnVRO01BbUJkLE9BQUE7Ozs7YUFBUDtNQXBJVixnQkFDb0J3VixNQUFRLE9BQUEsNkJBQVJBLE1BQW1CO01BRHZDLE9BQUEsNkJBc0hNZ2Q7TUF0SE4sT0FBQTtNQWlJUTs7O2FBaklSO01BNEhNRSxZQUdBOztTQUhBQSxZQU5BRjtJQWtCSiw4QkFaSUU7SUFZSixPQWxqREF6UTtHQW1qRE07WUFHTjBRO0lBQ0ZqakM7SUFDQTR6QjtJQUNDc1A7SUFDQTV5QjtJQUNBNnlCO0lBQ0FOO0lBQ0FPO0lBQ0FDO0lBRUQ7S0EzRkNuRyxpQkF6S0trRSxpQkErUEwrQjtLQVNnQyxPQTlRM0JqQyxRQXFRTGlDO0tBekZEcEs7T0FnR0U7O1NBQUEsZ0JBQUEsZ0JBVkZuRixLQXJKRWtPLFVBdUpEeHhCLE9BdEpDeXhCO1NBQ0FDO1NBd0pEb0I7O0tBZ0JPLElBMUdSRSxXQTBHUSxXQXRCUnRqQzs7Ozs7O1FBckZBdWpDLFFBQUF4SztRQUNBcUUsU0FBQWtHO1FBQ0NFLFlBdUZBTDtRQXJGQW5FO1FBQ0F5RTtPQUVEO2tCQUxDRDtpQkFBQUE7WUFtQlV2QyxPQW5CVnVDLGNBbUJLRSxRQW5CTEY7O1dBRUF4RSxvQ0FpQkswRTs7O2dDQUFBQTtxQkFBS3pDLDJCQUFBQTs7V0FPa0IwQyxTQVBsQjFDO1dBT2EyQyxRQVBiM0M7V0FBTTRDO1dBbkJoQkMsWUEwQjRCSDtXQVB2QkksUUFPa0JIOzs7O1VBUFBDLGNBVVcsNEJBVnRCSDtVQW5CTEksWUFtQlU3QztVQUFMOEMsUUFBQUw7OzthQUFXRyxpQkFuQmhCQyxZQW1CVTdDLE1BQUw4QyxRQUFBTDtXQUFXRztTQWpFRTtVQUFBLFFBUGpCMUIsb0JBd0lGbmlDLEdBaEVNK2pDO1VBakVJbE07VUFBTnBSO1NBQ0osT0FEVW9SOzsyQkFBTnBSOzsyQkFBQUE7O3NCQThDSHFkLGdDQUFBQTtpQkF4Q1U5TixNQXdDVjhOLHlCQTlDR3JkLFVBTU91UDs7Ozs7bUNBTlB2UCxNQWhJRXlhLFFBOEtMNEM7O1NBaUMwQjtVQTlCMUJFLDhCQUFBUDtVQXJDa0IsVUFuQmpCdEIsb0JBd0lGbmlDLEdBaEVNK2pDO1VBckRJbEs7VUFBTjZJO1NBQ0osT0FEVTdJOzs7YUFXRG9LLE1BWENwSzsyQkFXSSxXQUFMb0ssS0FxQlRWLFFBRUNPOzs7WUEvQmtCLElBREdJLE9BRlpySyxhQUdKc0ssYUF6SUEvQyxpQkF3S0wwQztZQTVCQyxHQUhJSzsrQkE2Qk5aLE9BRUNPOzthQXpCaUIsV0FBQSxXQVBJSSxNQThCdEJYO2FBdkJJOzJCQTM4Q0ZoUjs7OztnQkE4OENRNlIsT0FaQXZLLGFBWUh3SyxNQVpHeEs7WUFhUixVQXFCRGlLOzJCQXBCVyxXQTU3Q1puUixVQTg2Q0krUDswQkFrQ0hvQjtpQkFuQmV0SixPQW1CZnNKLGNBbkJVaEwsUUFtQlZnTDthQWxCSSxJQUNNLElBQUEsT0FBQSxXQUxKTyxLQW9CUGQsT0FqQld6SyxRQUNGbEY7bUJBRUEwUTtrQkFBQTVwQix3QkFBQTRwQjtpQkFBQTVwQjtpREFBQUE7Y0FDRyxLQXpKTjBtQixpQkFxSlU1RztlQUl3QyxNQUFBLDRCQUQvQzlmO2tCQUZBa1osTUFnQlQyUDs7K0JBaEJTM1AsS0FETzRHOzs7YUFPK0I7Y0FBakMzRyxPQVliaVE7Y0FaOEMsT0F0MkM3Q25RLGFBNDFDUXlRLE1Bb0JWYixPQVZjMVA7d0JBQWlDOzs7WUFFOUI7YUFETjBRLFNBdkJEMUs7YUF1QkYySyxNQXZCRTNLO2FBd0JKNEssV0FwS0F2RCxRQThLTDRDO1lBVEksR0EvSkMxQyxpQkF3S0wwQzthQVIrQixXQTEyQzlCblEsYUF1MkNTNFEsUUFTWGhCLE9BUk1rQjthQUVDOzs4QkFDTCxXQUpNRCxLQVNSakIsT0FSTWtCOzs7VUFVTEM7VUFGREM7VUFBQXBCLFFBQUFvQjtVQUVDbkIsWUFBQWtCO1VBR0FqQixvQkFBQU87OztTQXNDTTtVQUFBLFVBeFZDcEYsUUE4U1J4QixRQW9CTTJHLE9BbEJMN0c7VUFxQytDQztVQUFkeUg7VUF2Q2xDM0Y7VUFEQTRGLFFBNkNlLFdBTGlDMUgsWUF4Q2hEb0c7VUFJQ3VCLGdCQUFBOUYsY0FvQ2lDNEYsZUFwQ2pDNUY7VUFDQStGLDRCQWdCS2hCLFdBaEJMTjtVQUxERixRQUFBc0I7VUFDQXpILFNBQUE2QjtVQUNDdUUsWUFBQU07VUFFQTlFLGNBQUE4RjtVQUNBckIsb0JBQUFzQjs7V0FRVUMsU0FYVnhCO09BWW1CLEdBVm5CeEUsZUFVbUIsNEJBRFRnRztRQUdHOztvQkFBMkJ0OUI7WUFDaEMsV0FBQSw0QkFEZ0NBLE1BSDlCczlCO1lBSUYsY0FBd0MsOEJBRFJ0OUI7V0FDMEI7U0FEckQsT0FBQSx5QkFxRWQxSDtRQXJFSTtzQkFsL0NGdXlCOzs7V0Erc0NJMk0sTUFvUk45QjtPQW5SRTtlQURJOEI7O3NCQS9zQ0ozTTs7O1lBbXRDUzJCLFdBSkxnTDttQkE3bENKdkwsYUFpbUNTTyxVQStRWHFQLE9BYVd5Qjs7O1dBN1JZLElBQWRDLE1BSEgvRixRQUFBZ0csTUFHaUIsV0FBZEQsU0FISC9GLE1BQUFnRzs7ZUFNa0JDLE1BTmxCakc7V0FPRixHQURvQmlHLFNBTmxCQyxNQU1rQkQsV0FObEJqRyxNQUFBa0c7c0JBL3NDSjdTOzt1QkErc0NJOFMsTUFBQW5HLFFBQUFBLE1BQUFtRzs7c0JBc1MwQjs7OztNQVZwQjt1QkFBMkI1ZSxNQUFRLE9BQTdDLFdBQXFDQSxTQVR2QzhjLE9BU3VFO09BQTNELE9BQUEseUJBNEVadmpDO01BNUVFO01BR2M7T0FBQSxPQUFBLDBCQVBmeWpDO09BeFVtQngrQixNQW9VcEJtNEI7T0FXSSxPQUFBO01BOVVGO2NBRGtCbjRCOztjQUVYcWdCLElBRldyZ0IsZUFFTixXQUFMcWdCLEdBaVVUaWU7O1VBMVRJLE1BQUE7O1VBTHNCLElBQWpCajFCLElBSldySixRQUFBQyxNQUlNLFdBQWpCb0osT0FKV3JKLE1BQUFDOztxQkFXaEI7O3NCQVhnQjQ1QixNQUFBNzVCLFFBQUFBLE1BQUE2NUI7Ozs7Ozs7WUE2VU8sZ0JBVjNCeUUsT0F6N0NBdFE7Ozs7Ozs7TUFnaUR5Q3FTO01BQU5DO01BQTNCQztLQW5LTnZELHlCQW9KRDN4QjtLQW5KQzR4Qix5QkFrS3VDb0Q7S0FZckMsV0FaSUUsMkJBWXVCLFdBWklEO0lBWVk7SUFiN0MsWUFBQTs7U0FxQk0zQztLQUFPLE9BQUE7Y0EvQmRTLFlBK0JPVCxLQXhIUDFGLGdCQXFGQTVzQixNQUVBdXlCOzs7bUJBNEJDLFdBL0JESywyQkErQkMsT0F4bERBM1E7UUEwbERrQzNYO0lBQ2xDLFdBbENEc29CO0lBa0NDLE9BQUEsV0FEa0N0b0I7R0FHdUM7WUFZdkU2cUIsV0FBV2pmLFVBQU8sT0FuaERwQitNLGNBbWhEYS9NLEdBQXNDO1lBbU8vQ2tmLFFBak9JcDNCLEdBQUU2WDs7S0FXVyxJQUFhLE9BQUEsV0FYMUI3WCxVQVdhLE9BQUEsV0FYWDZYO0tBV3dCLE9BQUE7SUFBVTs7S0FDdkIsZUFBbUMsV0FaOUNBO0tBWWdDLE9BbHFCeEN1VyxhQWtxQjBDLFdBWnBDcHVCO0lBWTREO0lBWHBFOzthQUVNLElBT0ksT0FBQSxXQVZBNlgsVUFTQSxPQUFBLFdBVEY3WDthQVVFLE9BcGpCRml2QjtzQkFBQUE7d0JBc0JKVTttQ0F1aEJjM3ZCLEdBQUU2WDsyQkFHWjs0QkFBSXVYLFlBQVksV0FITnB2Qjs0QkFJTnF2QixZQUFZLFdBSkp4WDsyQkFLWixPQUFBLG9CQUZJdVgsV0FDQUM7MEJBQ3FDOzs7WUFFakM7OztHQUdmO3VCQUtvQixTQUFFO3VCQUNGLE9BcHNCbkJsQixLQW9zQnFDO0dBRnZDO0lBNmVFa0o7OztRQTdlZSxPQXJpQmIxSDs7a0JBcWlCK0IsT0F0aURuQzFLLDZCQXNpRG1DO2lCQUFtQztPQUFDOzs7WUFNckVxUyxZQUFZemYsR0FBRzdYO0lBQ2pCLFdBRGM2WCxhQUFBQTtJQUNkOzsyQkFHY0E7Y0FDUSxJQUFad1gsWUFBWSxXQURSeFg7Y0FFUixPQUFBLFdBTlc3WCxHQUtQcXZCO2FBQ087YUFGUCxPQTlpQk5PLFdBNmlCRSxXQUhRL1g7WUFNRzs7O0dBR2hCO1lBR0MwZixNQUFJMWYsR0FBRzdYO0lBQUksT0FaWHMzQixZQVlJemYsa0IsK0JBQUc3WDtHQUE2QztZQUVwRHczQixPQUFPcGU7SUFDVCxxQkFHcUIsU0FBRTt5QkFDRixPQTN0Qm5CK1UsS0EydEJxQztJQUp2Qzs7YUFFTSxPQTNqQkZ5QjtzQkFDQUM7aUNBMGpCbUN2SyxLQUFPLE9BRXBDLHFCQUY2QkEsS0FIOUJsTSxLQUd5RDtzQkExQ2hFK2Q7WUEwQ2dGOzs7R0FHakY7R0FHbUI7SUFBbEJuMUIsT0FUQXcxQixPQTdPRmhFO0lBNnNCRWIsT0FoZUE2RSxPQTVPRi9EO0lBNnNCRWdFLFNBamVBRCxPQTNPRjlEO3dCQTJQcUIsU0FBRTt3QkFDRixPQXZ1Qm5CdkYsS0F1dUJxQztHQUZ2QztJQURFN0k7OztRQUNlLE9BdmtCYnNLLFdBQ0FDLGtCQXNrQjhDdkssS0FBTyxPQUFQQSxJQUFVLElBdEQxRDZSO09Bc0QwRTs7O0lBeCtDOUVwTztJQUNBMk87SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7WUEwOERNNUgsS0EvY0s2SDtJQUNQLFdBenhCQXRoQyxXQXd4Qk9zaEM7SUFDUCxxQkFFcUIsU0FBRTt5QkFDRixPQUpkQSxRQUkwQjtJQUZqQzs7YUFBaUIsY0FBZUMsZ0JBQWMsT0FBZEEsUUFBcUI7YUFBekIsT0FsbUIxQnJJLFdBZ21CS29JO1lBRThDOzs7R0FHcEQ7WUE2Y0RFLFlBemNhQztJQUNGLElBbGFOem1DLElBbzJCSDY4QixHQW5jVzRKLFlBa2NYeEcsV0FOQUosa0JBdDhETnhJO0lBMmdERSxPQXFjSW9ILGFBdjJCR3orQixPQUFBQTtHQWthMEQ7WUE2ZDdEeW1CLEtBdmNBcUwsS0FDRDRVLG9CQUNEaC9CO0lBdUNTLGdCQXRDVGkvQjtLQXNDUyxnQkFyQ1JsL0I7VUFDQTQ2QjtTQUxDdlEsU0FBVXNELE1BQVZ0RCxRQUFBdHFCLFVBQVU0dEIsY0FBVjV0QjtNQU9GLFNBQUlpNEIsVUFBVWhaLE1BQU8sT0F4WXpCOGEsZUF3WWtCOWEsTUFBbUM7TUFDdEM7T0FBUGhELFNBREFnYyxVQUxKLzNCO09BT0k0NkIsWUFBVSwwQkFUWjk2QixTQU9FaTRCO09BRytDLFFBQUEsV0FQbkRrSCxNQUtJbGpCO09BRWlDc1E7T0FBakI1TztPQUFkd1Q7T0FBTWQ7T0FDUitPO1NBRGdCemhCO3FCQUlKeU8sS0FBZSxXQUp6QitFLE1BSVUvRSxNQUFlLFNBQWE7MkI7T0FFeEN3TztTQUNDLDRCQWhCSnNFOzs7O09BdUJLLHdCQWQrQjNTOzs7UUFjL0I7O3FCQWQrQkE7O3NEQUFBQTtxREFBQUE7Ozs7UUFtQko7U0FBYlE7U0FBYTs7WUF6QmhDOXNCOzs7aUJBeUJtQjhzQjtnQkFBYTs7bUJBekJoQzlzQjtPQW9CSzs7Z0JBaEJGZ2M7Z0JBQ0E2ZTtnQkFKSEQ7Z0JBS1d4Szs7Z0JBQVExUztnQkFDaEJ5aEI7Z0JBS0F4RTs7TUFvQkc7MkJBQ2MsT0FuMEJyQjNGLEtBbTBCdUM7TUFsQnZDOztlQUVNLGNBQTBEalcsVUFBUSxPQUFSQSxFQUFTO2VBQWIsT0FycEIxRDBYO3dCQUNBQyxrQkFvcEJxQ3ZLLEtBQU8sT0FBQSxXQVh4QytFLE1BV2lDL0UsS0FBZTs7Y0FBbUI7Ozs7WUFtYnZFaVQ7SUE1WkRyL0I7SUFDQWsvQjtJQUNEaC9CO0lBQ0FneEI7SUFDQW9PO0lBQ0MxTjtJQUNBM3hCO0lBR08sSUFFSnMvQixlQUZJLFdBTFJELGlCQUNDMU47Ozs7YUFNRzJOO2lDQUFBQSw4QkFIQWpQLFFBRkhyd0I7Ozs7Ozs7Ozs7NEJBSzRCdS9CO2FBQUEsT0FBQSx5QkFBQUE7WUFBdUI7OztNQUhoRGxQLFFBR2dCLG9DQUxuQnJ3QixLQUtHcy9COztJQU1GO0ssT0F3WUF6TixzQkFwWkRGLFdBRkRWOztJQVVBLE9BQUEsV0E4WUVqUyxLQTNaRGpmLFNBQ0FrL0Isb0JBQ0RoL0IsYUFNSW93QjtHQVVFO1lBcURKbVAsU0FqREt6Z0I7SUFDVCxxQkFDcUIsU0FBRTt5QkFDRixPQW4yQm5CaVcsS0FtMkJxQztJQUZ2Qzs7YUFBaUIsT0Fwc0Jid0IseUJBb3NCK0IsT0Fyc0RuQzFLLGNBb3NEUy9NLEdBQ3lEO1lBQUM7OztHQUdsRTtZQXlCQzBnQixxQkFBcUJsbkM7SUFDdkIsV0FEdUJBLGFBQUFBO0lBQ3ZCOzsyQkFJY3NPO2NBQ00sSUFBVmk0QixVQUFVLFdBRE5qNEI7Y0FHTixPQTl1RFI4a0I7dUJBOHVEUTs7eUJBRkVtVDs7MEJBRThCOzJCQUU1Qjs7O29DQUVJOzhCQUNDL2Y7MEJBQUssV0FBTEE7eUJBQVU7YUFBQzthQVJsQixPQXB1Qk4wWCxXQW11QkUsV0FKaUJsK0I7WUFhSzs7O0dBQzNCO0dBUVM7SUFBTm1uQyx3QkEvTEZ0QjtvREE2TEVvQixVQUNBdkIsU0FDQXlCOzs7SUE2VkFDOzs7Ozs7Ozs7OztZQWdERkMsVUExWVVybkM7SUFDWjtLQUFJZ0osUUE3dkNGc3ZCLFNBNnZDK0IsV0FEckJ0NEI7S0FFUnNuQyxhQUFhLHlCQURidCtCO0tBRUF1K0IsYUFsNkJFaEwsTUFrNkIrQixXQUh6QnY4QjtJQUlBLE9BQUEsOEJBRlJzbkMsZ0JBQ0FDO0dBQ2tDO0dBdUJsQyxTQUFBdmxDLFVBQUF3bEMsT0FBQUM7SUFDc0IsR0FEdEJELFVBQUFDLE9BQ3NCO2VBRHRCQSxpQkFBQUQ7a0JBQ2VFLE9BQUFDLE9BQUEsT0FBQSxzQkFBQUQsT0FBQUMsT0FBTTtJQUFDLElBQUF6Z0MsSUFBQTthQUFBQSxHQUFBLE9BQUFBO2VBRHRCdWdDLGlCQUFBRDtrQkFFb0JJLE9BQUFDLE9BQUEsT0FBQSxzQkFBQUQsT0FBQUMsT0FBTTs7R0FEQTtZQUt0Qi9uQyxVQUFVRTtRQUF5QjhuQyxRQUF6QjluQzs0Q0FBeUI4bkM7O0dBUDlCO0lBQUEsUUFDVDlsQyxXQU1JbEM7SUFBQXFFOzs7WUFNRjRqQyxXQWhDZS9uQztJQUNULElBQVJnSixRQXB3Q0ZzdkIsU0Fvd0MrQixXQURadDRCO0lBRXJCO0tBQXdDLElBQVl5bUIsaUJBQU4vZTtZQUFNK2UsaUJBQU4vZTtJQUNtQjtJQURqRDtLQUFBLE9BQUEsNEJBRFpzQjtLQWdDSWcvQixnQkEvQmdDO0tBZ0NoQ3pMLFFBaVdOOEssVUFuWW1Ccm5DO0lBbUNqQixjQUFrRDhqQixHQUFLLE9BQUEsa0NBQUxBLE9BQTBCO0lBQXBELElBQXBCbWtCLG9CQUFvQiwwQkFEcEIxTDtXQUVHLDBCQURIMEw7S0FHRjtzQkFLYUMsTyx3Q0FBQUE7TUFMYjtRQUFBOzs7OztVQUhFRDs7S0FHRjs7T0FKRTFMLE9BZVEsV0FmUkEsT0FEQXlMOzs7O0dBZ0IyQztZQUc3QzdnQixZQUFVbm5CO0lBQ1osT0FEWUE7Z0RBQUFBO2dEQUFBQTtHQUdzQztZQVNoRG1vQyxlQUFlaGpDO0lBQUssV0FBQSwwQkFBTEEsSUFaZmdpQjtJQVlvQixPQUFBO0dBQXFEO0dBR3BEO1lBT3ZCaWhCLHdCQUVBdFcsS0FDRDNzQixJQUNDa2pDO0lBRUYsR0FKRXZXLFNBQWVzRCxNQUFmdEQsUUFBQXdXLGVBQWVsVCxjQUFma1Q7a0JBd0NvQnRvQztLQUFLLEdBeEN6QnNvQztNQU8wQjtPQXpCQ0Msb0JBMUJ6QlIsV0FvRmtCL25DOzs7d0JBTmtCd29DO1dBQzVCO1lBckRvQkMsU0FvRFFEO21CQUFBQTttQkFBQUE7WUF2QjlCLGNBdUI4QkE7bUJBQUFBO21CQUFBQTttQkFBQUE7bUJBQUFBO3lCQW5ESXJpQjtZQUFLLFdBQUksNkJBRHJCc2lCLFFBQ1l0aUI7V0FBZ0M7V0FBcEU7WUFFSnVpQixJQUZJLDBCQURxQkg7b0JBR3pCRyxRQUFvQixrQ0FBcEJBOzs7YUF3Q2dCajlCO29CQUFTLG9DQUFUQTs7O1dBWGQ7bUJBaEMwQmc5Qjs7OzttQkFrQ3RCOzs7O1VBbUJpRDtVQUR4QyxXQUFBLFdBTUd6b0M7VUFOYSxPQUFBO1NBQ3lCOzs7VUFKZixJQUpoQnkrQixPQUlnQixXQVN2QnorQjtvQkFiT3krQixtQkEvK0JyQjtpQkErK0JxQkE7O2lCQTcrQnhCeDVCLE1BNitCd0J3NUIsU0E3K0JuQixXQUFMeDVCOztpQkFEQ0MsTUE4K0J1QnU1QixTQTkrQmxCLFdBQUx2NUI7cUJBRUQsV0E0K0J3QnU1Qjs7U0FJNEI7a0JBU25DeitCOztpQkFBQUE7S0FBSyxXQXBGdkIrbkMsV0FvRmtCL25DO0lBQXlDO0lBQTdEO0tBQUEsT0FBQSwwQkF2Q0RtRjtLQXVDQyxRQUFBOztLQVdrQjtNQURkd2pDOztpQkFTV3ZPO1NBQ1EsSUFBZHdPLGNBQWMsMEJBRFJ4TztrQkFPTnlPLG9CQUFvQkM7VUFDdEI7V0FBQTtXQUdFLE9BQUEsMEJBSm9CQTs7VUFDdEIsT0FBQTttQkFsOURiblc7Ozs7Ozt3Q0FtOURnQm9XO3lCQUFBLE9BaEZSWixlQWdGUVk7d0JBQ2lDOzs7OztTQUVoQzs7VUFFNkIsc0JBRTdCcmhDOztlQURTOHhCO1dBQVMsZUFDbEI5eEIsTUFEUzh4Qjs7Y0FDRzlGO1VBQU8sZUFBbkJoc0IsTUFBWWdzQjtTQUEwQjtTQUYxQztVQUFBLFFBQUEsMEJBZFEwRztVQWFRNE87VUFBZEM7U0FLSixHQUxJQTtxQkFBQUE7YUFBQUEsaUJBTXVCLE9BWnZCSixvQkFNQUk7Y0FPS3pQO1VBQ1AsT0FwQkVvUCxhQXFCRyxPQWZIQyxvQkFQTXpPOzs7b0JBekRmaU87Z0JBQUFBLHdCQTZFYzdPLFNBQUFBO2dCQUFBQTtVQUlMOztZQVhjd1AsZ0JBQUFBO1VBeUJIO2tCQXpCR0E7V0FrQm9CdFY7V0FBOUJoc0I7V0FPTyxPQUFBLDJCQVB1QmdzQjtXQU12QixPQXhIbEJ2TSxZQWtIV3pmO1dBSUksT0FBQTtVQUhQLDBCQUVJOzttQkEzRmQyZ0M7Y0FrR3dCYSxVQWxHeEJiO1VBa0dpQyxXQUFUYTs7WUFsR3hCYixtQkFtRzRCO1NBRWY7VUFBQTtVQUVFLE9BQUEseUJBdkRYTTs7VUFXd0IvVjs7Ozs7OytCQTJDWnVXO2dCQUFBLE9BcEhkaEIsZUFvSGNnQjtlQUEwRDs7O3VCQXpDNUR0VztVQUFVLDBCQUErQiwyQkFBekNBO1NBQStEO1NBd0NoRSxPQUFBO2tCQXpDTixvQ0FEcUJEO1FBNkNUOztpQkF2RHdCbHJCLE1BckxUMUgsR0FxTHNCb2lCO3VCQUk1Q0E7VUFBTCxJQUEyQmlSLG9CQUFQbUc7VUFDdkIsT0FEOEJuRyxrQkFKUzNyQixNQUloQjh4QixRQUFmcFgsT0FBQUE7U0FHdUI7b0JBNUxEcGlCLGFBQUFBO1NBeUwzQixPQUFBOztrQkFKaURvaUI7OztrQ0FoTDlDOVQ7cUJBQ00sSUF4dERnQmk0QixVQXd0RGhCLFdBRE5qNEI7cUJBdnREMEIsZUFBSmk0QixVQUFBQTtvQkF5dEQ2QjtvQkFGdkQsT0E5c0JOckksV0E2c0JFLFdBSmdDbCtCO21CQU8yQjs7OztRQXFMMUI7TUFQakIsT0FBQTtNQTFLYUEsSUEwSy9CLGtCQUFBLHlCQURJMm9DO2FBeksyQjNvQzthQUFBQTtLQUNuQzs7NEJBSWNzTztlQUNNLElBQVZpNEIsVUFBVSxXQUROajRCO2VBRVIsT0FsdUROOGtCLCtCQWl1RFVtVDtjQUNvRDtjQUZwRCxPQXp0Qk5ySSxXQXd0QkUsV0FKNkJsK0I7YUFPMkI7Ozs7SUE0SjFEO0tBRGUwSDtLQUNmO09BQUE7Ozs7O1NBRGVBO1NBN0ZYdkQ7SUE4RkosT0FBQTtHQStEbUM7WUFnTnJDaWxDLFdBM01DamtDLElBQ0NrakM7a0JBS3FCcm9DO0tBQ2xCLE9BeFpMNGxDO2NBdVp1QjVsQzs7ZUFDRCxJQUErQnF6QixvQkFTNUNDO2VBUkYsU0FRRUEsV0FBcUIsV0FBckJBLFFBVDRDRDsyQkFTNUNDOztnQkFMQTs7OzswQkFHK0I7O21CQUx0QmtHO2VBQVUsZUFBVkE7Y0FPZ0M7SUFBQTtJQWJsRCxPQXJIRTRPO21CQXdIQSwwQkFORGpqQyxXQUNDa2pDO0dBZWtEO1lBNExwRGdCLDBCQXBMd0JDLEtBQUtqQjtJQUMvQixPQTNJSUQsMkJBMElzQmtCLEtBQUtqQjtHQUMwQjtZQW9MdkRrQixjQWpMY3ZwQztJQUFJLE9BQVM7b0JBQWJBLFlBQWtCdzVCLE9BQVMsV0FBVEEsT0EyS2hDNk4sVUEzS2NybkMsSUFBNkM7R0FBQztZQWtMNUR3cEMsYUFoTGF4cEM7SUFDVCxJQUsyRHU4QixRQW1LL0Q4SyxVQXpLYXJuQztPQU1rRHU4QixXQUFBQTtTQUo3RDcwQixPQUk2RDYwQjtLQUoxQyxPQUFBLGtCQUZSdjhCLFlBRWF3NUIsT0FBUyxXQUFUQSxPQUF4Qjl4QixNQUE0Qzs7O2lEQUlpQjYwQjs7Ozs7OztHQUFhO1lBRzVFa04sZUFBOEJ4STtJQUNsQjtLQURKajRCO0tBQWtCc0Y7S0FDeEI2MEIsVUF2d0JKbkMsUUFzd0JnQ0M7S0FFNUIzTjtrQkF3QkVzUDtLQXhCRnRQLG9CQTRCMkIsOEJBSnpCc1A7O0lBSTRDO3dCO0lBWHpCOzttQkFSVDhHO01BQ1IsSUFBSW5ELFVBQVUsV0FETm1ELFlBRVIsUUFESW5EOzZCQUdDcGdCLGNBYlRtTixvQkFhU25OO1VBRDRCdU47TUFackNKLG9CQVlxQ0k7O0tBQ0Y7S0FKM0IsT0E3K0JSd0ssV0E0K0JJLFdBVm9CNXZCO0lBZVc7SUFuaEJ2QzIwQjtxQkFsK0JFM0ssU0E0K0NVLFdBTkZ0dkIsa0JBaG9DUnl6Qjs7O01BNUZGcEI7TUE2dENJOEg7Ozs7bURBQ0E3UDs7WUFzQ0ZxVyxTQUFPN00sSUFBR0Q7SUFBSyxPQUFvQjs7YUFBNUJDO2FBQUdEO3NCQUE4QitNLElBQUdDLElBQUcxakIsR0FBSyxPQUFHLFdBQVgwakIsSUFBVyxXQUFkRCxJQUFNempCLElBQWM7R0FBQztZQUM3RDJqQixTQUFPaE4sSUFBR2lOO0lBQUssT0FBb0I7O2FBQTVCak47YUFBR2lOO3NCQUE4QkgsSUFBR0csSUFBRzVqQixHQUFLLE9BQUEsV0FBQSxXQUFYeWpCLElBQU16akIsSUFBSDRqQixJQUFpQjtHQUFDO1lBQzdEQyxTQUFPbE4sSUFBR2lOO0lBQUssT0FBb0I7O2FBQXpCQTthQUFIak47c0JBQWlDaU4sSUFBR0gsSUFBR3pqQixHQUFLLE9BQUcsV0FBWHlqQixJQUFXLFdBQVJ6akIsR0FBTjRqQixLQUFvQjtHQUFDO1lBQzdERSxLQUFLMzdCLEdBQUksT0FBQSxxQkFBSkEsR0FBa0I7WUFLdkI0N0IsUUFBTS9qQixHQUFJLE9BQUEscUJBQUpBLEdBQWtCO1lBRXhCZ2tCLEtBQUs3N0IsR0FBRXRPO0lBQUksT0FBZTtvQkFBbkJBLFlBQXdCaWpDLEtBQUlzQyxNQUFRLE9BQUEsV0FBdENqM0IsR0FBMEIyMEIsS0FBSXNDLE1BQW9CO0dBQUM7WUFDeEQ2RSxTQUFTQztJQUFJLE9BQVMsa0JBQWJBLFlBQWtCLzdCLEdBQUVvbkIsR0FBSyxPQUFBLFdBQUxBLEdBQUZwbkIsR0FBVTtHQUFDO1lBQ3RDZzhCLFNBQVN0cUMsR0FBRXVxQztJQUFJLE9BQVMsa0JBQWZ2cUMsWUFBb0JzTyxHQUFLLE9BQW5CLFdBQWNBLEdBQWxCaThCLEdBQTBCO0dBQUM7R0F5RDVCO0lBaC9EZEM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUEwK0RRQzt1RUFBQUE7Ozs7Ozs7Ozs7Ozs7O1lBTUpDLGtCQUFrQi9KO2tCQUNlN2U7S0FBTCxJQUFzQjNhLGdCQUFONitCLGlCQUFONStCO2NBQ2xDdWpDLElBQUkzOEIsR0FBRTQ4QjtNQUlMLFdBQUEsV0FwQkh6a0IsV0Flb0MvZSxNQUM1QndqQyxZQUR3Q3pqQztNQUs3QyxPQWhGTHFpQyxTQUVBRyxjQTJFWU0sR0FBRXBrQixHQUNWLFdBRkk3WCxHQUNNNlgsSUFDVixPQURRb2tCLEVBRVA7S0FDOEI7Y0FFL0JZLEtBQUs3OEIsR0FBRW9xQjtNQUEyQyxvQixPQXpCcERhLFNBeUJTYjtNQUEyQyxPQU5sRHVTLGFBTTJCOWtCLEdBQUssT0FBa0IsNEJBQXZCQSxHQUF0QjdYLEdBQTJDO0tBQTJCO0tBQy9FLFNBQUk4OEIsSUFBSS9tQixHQUFFcVU7TUFBVyxPQURqQnlTLGNBQzJCaGxCLEdBQXZCOUIsT0FBdUI4QixZQUFXLEdBQWhDdVM7S0FBMEM7Y0FDaEQyUyxTQUFTaG5CLEdBQUU3SjtNQUFJLE9BUmZ5d0I7d0JBUXdCbkM7Z0JBQVUsV0FBVkEsVUFBZnprQixPQUFFN0osUUFBYXN1Qjs7ZUFBK0I7ZUFoQ3pEaFA7S0FnQ3VFO0tBQ3pFLE9BVjRDd007OztTQWFyQ2g0QixJQWJxQ2c0Qjs7V0FDeEMyRTtzQkFZaUJuQyxRQUFVLE9BQVZBLFNBQXlCLFdBQXZDeDZCLFFBQWN3NkIsT0FBNkI7YUFwQ2hEaFA7OztZQTZDS21MLE1BdEJxQ3FCLGdCQU94QzZFLEtBZUdsRyxLQXpnRVgyRjs7WUFpZ0VVdm1CLElBZHNDaWlCLGdCQVN4QytFLFNBS0VobkI7O1lBQ0VpbkIsTUFmb0NoRixnQkFTeEMrRSxTQU1JQzs7WUFDQ3JILE1BaEJtQ3FDLGdCQU94QzZFLEtBU0tsSCxLQXZnRWJ1Rzs7WUF3Z0VpQmUsTUFqQitCakYsZ0JBUXhDOEUsSUFTU0csS0F4Z0VqQmY7O1lBeWdFVW5HLE1BbEJzQ2lDLGdCQU94QzZFLEtBV0U5RyxLQXhnRVZvRzs7WUF5Z0VjZSxNQW5Ca0NsRixnQkFReEM4RSxJQVdNSSxLQXpnRWRmOztZQTBnRVlqRyxNQXBCb0M4QixnQkFPeEM2RSxLQWFJM0csS0F4Z0VabUc7O1lBeWdFZ0JjLE1BckJnQ25GLGdCQVF4QzhFLElBYVFLLEtBemdFaEJkOzttQkFvaEVNOzs7UUFQRTtTQUZZZSxNQXZCNEJwRjtTQXVCbENxRixPQXZCa0NyRjt5QkEyQmZzRixLQUFPLFdBQVBBLEtBQUFBLEtBQWU7U0FIdENsVDtXQXQzRFI1RDsrQkF5M0RRLDBCQUpJNlc7Z0JBaEJOUixLQWdCWU8sS0FDVmhUOzs7O1NBTUNtVCxNQTlCcUN2Rjs7V0FDeEMyRTtzQkE2QmlCOWtCO2NBQUs7a0NBQUEsT0FBQSx1QkFBbkIwbEI7Y0FBb0MsT0FBQSw0QkFBdEIxbEI7YUFBb0M7YUExRHZENlU7OzttQkFnRUE7OzttQkFGQTs7S0FyQlUsT0F6RloyTyxTQTRFaUN2bkI7SUFvQzRDO0lBcENqRCxPQUFBLDBCQURWNmUsTUFwRWxCMEU7R0F5RzZFO0dBRzdELHFCQWo1Q2hCekssVUFJQUUsVUEyZEFnRjtZQTA4QkYwTCxRQUFPQyxxQkFBb0IvckM7SUFDN0I7d0IsOEJBRFMrckM7SUFHTyxXQUFBLDBCQUhhL3JDO2tCQUVDa0osUUFBVSxPQUFBLFdBQVZBLFdBQW1CO0lBQXRDLFdBQUEsNEJBRmtCbEo7SUFDN0IsV0FENkJBO0dBSTVCO09BSURvUSxpQ0F1Y2M0N0I7WUF6YlpDLFFBQU1qc0M7SUFDUixXQURRQSxhQUFBQSxhQUFBQTtrQkFFc0JrSixRQUFVLE9BQUEsV0FBVkEsV0FBbUI7SUFBdEMsV0FBQSw0QkFGSGxKO0lBQ1IsV0FEUUE7R0FNUDtZQThCR2tzQztJQUF5Qzs7V0FDeENDLGlCQUFRLFdBNzRCWHRLLE1BNjRCR3NLOztXQUVDMWdDLGtCQUFTLFdBN0RicWdDLFFBMERFSSxnQkFHRXpnQzs7V0FERDJnQyxpQkFBUSxXQXRDWEgsUUFzQ0dHOztXQUVBeHhCO09BQVMsV0FBSywwQkFBZEEsT0FKRHN4Qjs7R0FJaUQ7WUFVckRHLFdBQVlDLEtBQUtDLEtBQUlsK0IsS0FBSWtaLFVBQVVHLEtBQUlEO0lBQ3pDLEdBQUcsV0FEVzZrQixLQUFTaitCLEtBQWNxWjtLQUVXLFdBQUEsb0NBRnJCSDtLQUV0QiwwQ0FGZ0NHOztJQUVoQyxPQUFBLFdBRmM2a0IsS0FBSWwrQixLQUFjcVosS0FBSUQ7R0FHdkI7WUFHaEIra0IsZUFBZW4rQixLQUFJa1osVUFBVUcsS0FBSUQ7SUFDbkMsT0FQRTRrQix1Q0FNZWgrQixLQUFJa1osVUFBVUcsS0FBSUQ7R0FDd0I7WUFHekRnbEIsaUJBQWlCcGxCLE9BQU1FLFVBQVVHLEtBQUlEO2tCQU8zQkosT0FBT0ssS0FBS0Q7S0FBUSxPQUFBLDhCQUFwQkoseUJBQU9LLEtBQUtEO0lBQXlEO0lBTmpGLE9BWEU0a0I7c0JBZ0JVaGxCLE9BQU1LO2NBQU8sT0FBQTswQ0FBYkwseUJBQU1LO2FBQW1EOzthQU5sREw7YUFBTUU7YUFBVUc7YUFBSUQ7R0FPMkM7WUFJOUU4a0I7SUFBSUosTUFBTXprQyxNQUFNRixTQUFTNjZCLDRCQUE0QjVjLE1BQU1pbkI7SUFDN0QsSUFBSTFqQyxRQURFbWpDO3dCO0lBYU07S0FBQSxPQUFBLG9DQWJpRE87S0FFekRDO09BakJKSDtTQWdCSXhqQzs7U0FEUXRCOztVQUFBQTtVQUFNRjtVQUFTNjZCO3VCQVlhek8sS0FBTyxPQUFBLFdBWlFuTyxNQVlmbU8sS0FBZTs7VUF0MkRuRHZROzs7SUEyMkRKLFdBakJNOG9CLFNBQUFBLFNBRUZRLFNBRkVSLFNBQUFBO0dBaUJhO1lBSW5CUyxNQUFPempDLFNBQVNEO0lBQ047S0FEeUNGO0tBQTFCMUQ7S0FBaUNnSjtLQUN4RHErQixVQUFRLFdBRHlDM2pDO0tBRWpEekQsVUFBUSxXQUZlRDthQUd2QjJEO21CQUdNeWdDO01BQ1IsSUFBSW5ELFVBQVUsV0FETm1ELFlBRVIsUUFESW5EOztXQUdDM3JCO09BQVMsdUJBQWlCLE9BQUEsV0FBMUJBLFVBQWtDOztNQURXLElBQWpCOFksbUJBQWlCLE9BQUEsMkJBQWpCQTtNQUFRLE9BQUEsV0FwMUV6Q2Y7S0FxMUV1QztLQUpuQyxPQTd3Q0V1TCxXQTR3Q04sV0FMMEQ1dkI7SUFVbkI7SUFFN0I7S0FBUnUrQixVQXZ4REV2VSxTQTR3REZxVTtLQVlBUixXQWJLaGpDLFNBQVNELFFBWWQyakMsU0FUQTVqQyxPQURBMUQ7S0FZQXVuQztPQW5DQVA7U0FrQ0FKOzs7O2tCQVFXdlk7VUFBTztXQUFXLE9BQUEscUJBQWxCQSxLQS84QlhvTzs7OzJDQSs4QjZCO1VBQUEsT0FBQTtTQUF3Qzs7SUFFekUsV0FUSThLOztZQVlGQyxXQUFZNWpDLFNBQVNELFFBQU9vOUIsTUFBS2Y7SUFDbkMsT0EzQkVxSCxNQTBCWXpqQyxTQUFTRCxRQTNRakJvaEMsU0EyUXdCaEUsTUFBS2Y7R0FDMEI7R0FHbEIsSUFBekN5SCxXQXoxRUVsYTtZQTIxRUZtYTtJQUFZOWpDLFNBQVNELFFBQVFna0MsMkJBQTJCQyxNQUFLOWxCO2tCQUV0Q0E7O01BRUQsSUFBWXJuQixjQUFOMEg7TUFBWSxXQTVpQ3hDNjVCLGVBNGlDNEI3NUIsT0FBTTFIO0tBQTRDO0tBQTFFO01BREUybkIsVUFDRiwwQkFGbUJOO01BSWYsUUFBQSw4Q0FIRk07O1VBS0V0WjtNQUNKLE9BVHlCNitCO2dCQUd2QnZsQjtnQkFRUyw0QkFIUHRaOztTQURXM0c7S0FBUSxPQUFBLG9DQUFSQTtJQUlhO0lBVGhDLElBREVpRixjQUNGLDBCQUY2RDBhO0lBYS9ELGVBYmNsZSxTQUFTRCxRQUNuQnlELGFBRHNEd2dDO0dBYWQ7WUFHMUMxaEMsTUFBT3RDLFNBQVNELFFBQVFna0MsMkJBQTJCQyxNQUFLOWxCO0lBQzFELGNBQXVDL1k7S0FBcUIsV0FBQSxXQUFyQkE7S0FBcUIsT0FBQTtJQUFNO0lBQXJELElBQVRxYyxXQUFTLDRCQURLemhCO0lBRTJDLE9BbEIzRCtqQzthQWdCTzlqQzthQUNMd2hCO2FBRHNCdWlCO2FBQTJCQzthQUVRLDBCQUZIOWxCO0dBRXdCO1lBR2hGK2tCLEtBQU1qakMsU0FBU0QsUUFBUzRvQixLQUF3QjhCLEtBQUsxaUI7SUFDdkQsR0FEMEI0Z0I7U0FBbUJzRCxNQUFuQnRELFFBQUE3Z0IsbUJBQW1CbWtCOztTQUFuQm5rQjtJQUV4Qjs7cUJBRnFEQzs7O0tBQ25EQyxjQUNGO29CQUZxREQ7S0FXNUM7TUFER201QixJQVZ5Q241QjtNQVV6Q2s4QjtRQUNILDhCQURHL0M7V0FBQUE7V0FFTDtNQUpMZ0QsZ0JBRVVEOztLQUtIO01BRFNFLE1BZG1DcDhCO01BY25DcThCO1FBQ1QsOEJBRFNEO1dBQUFBO1dBRVg7TUFSTEQsZ0JBTWdCRTtJQUtwQjs7YUFuQlFwa0M7YUFBU0Q7YUFDYmlJO2FBT0FrOEI7YUFSc0JwOEI7YUFBd0IyaUI7R0FtQnVCO1lBR3ZFNFosVUFBUTV5QixPQUFRLFdBQVJBLE9BQWtCO1lBRXRCNnlCO0lBQ05DLFVBQ0N2OEIsYUFDQUQsYUFDQUQsa0JBQ0EwOEI7SUFJQztLQURFQztPQVVGQztTQWpCRkg7U0FDQ3Y4QjtTQUNBRDtTQUNBRDtTQUNBMDhCO0lBV0Q7WUFkQ3g4QjtZQUNBRDtZQUVBeThCO1lBREExOEI7WUFJRzI4QjtHQVFvRTtZQUV0RUM7SUFDRkgsVUFDQ3Y4QixhQUNBRCxhQUNBRCxrQkFDQTA4QjtJQUVELE9BTkFEOztXQU9PbHpCLElBUFBrekIsYUFPWSxXQUFMbHpCOztPQVlMO1FBRE1DLElBbEJSaXpCO1FBbUJFOzs7V0FNdUI7WUFBV0E7WUFBTHBaO1lBQ1p3WjtjQUFxQixzQkF0QnZDSCx3QkFxQjhCclo7WUFFWnlaO2NBOUNiTjtnQkE0QzhCQztnQkF4Qm5DdjhCO2dCQUNBRDtnQkFDQUQ7Z0JBdUJrQjY4QjtXQVNKLFdBVmdCeFosS0FFWnlaO1VBUU87OEJBVkQsT0FBQTtRQUhqQixPQUFBLDBCQUpBdHpCO09BQ04sZUFETUEsTUFBQUE7O1dBVkRDLElBUlBnekIsYUFRWSxXQUFMaHpCOzs7UUFDQWd1QixJQVRQZ0Y7O21CQVd3QkE7V0FDakIsT0FiTEc7b0JBWXNCSDtvQkFWdkJ2OEI7b0JBQ0FEO29CQUNBRDtvQkFDQTA4QjtVQWEyQjtPQVAxQixXQUNFLDBCQUZHakY7O0dBMkJGOzthQUlEc0YsY0FBZUM7S0FBVSx3QkFBVkE7OztpQkFBQUE7O2tEQUFBQTtpREFBQUE7O0tBQXdCLE9BQUE7SUFBZTthQUN0REMsaUJBQWtCQztLQUFhLHdCQUFiQTs7O2lCQUFBQTs7a0RBQUFBO2lEQUFBQTs7S0FBMkIsT0FBQTtJQUFrQjthQUUvREMsUUFBU0gsU0FBU0U7S0FDcEI7TUFhUTtRQUFBO1VBelZGMW5CLDJCQVJBcVQ7TUFnV0U7UUFBQTtVQXhWRnJULHdCQVJBcVQ7S0F1VkYsT0EvSUo4Uzs7O2NBK0lJOztnQkFBQTs7a0JBQUE7OzZCQUFZeUIsY0FBYUM7cUJBQ3ZCLEdBRHVCQTtzQkFOM0JKLGlCQUVrQkM7NkJBSUpFO3NCQVBkTCxjQUdTQzswQkFGVEMsaUJBRWtCQyxhQUhsQkgsY0FHU0M7cUJBV0gsT0FyL0VOMWI7b0JBcy9FVTs7O0lBRThEO2FBR3BFZ2MsTUFBS04sU0FBU0UsWUFBV0s7S0FDL0IsT0FEK0JBOztRQUkzQjtTQUZHckMsT0FGd0JxQztTQUd6QjFCO1dBcExKUDthQW1MS0o7Ozs7O2NBUWUsd0JBVlg4QjtzQ0FBQUE7c0RBQUFBO3FEQUFBQTthQVV3Qjs7U0FFN0JRO1dBN0xKbEM7YUFvTElPOzs7OztjQWdCZ0Isd0JBbkJGcUI7c0NBQUFBO3NEQUFBQTtxREFBQUE7YUFtQmtCOztRQUVwQyxXQVRJTTs7UUFZRjtTQUZJaGpDLFFBdEJ1QitpQzs7b0JBd0JjN2hDO1lBQ3ZDLE9Bck5OOC9CO3FCQW9ONkM5L0I7OztxQkF6QzNDeWhDLFFBaUJTSCxTQUFTRTtXQTZCa0I7U0FOaEN4aEMsY0FDRiwwQkFGSWxCO1FBU04sZUFUTUEsVUFBQUEsVUFDRmtCLGFBREVsQjs7WUFVRDJnQyxPQWhDd0JvQyxnQkFnQ2hCLFdBQVJwQzs7WUFDQXh4QixRQWpDd0I0ekI7UUFpQ2Y7OzswQ0FBVDV6Qjs7OzhCQUFBQTs7K0RBQUFBOzhEQUFBQTs7a0JBQThDLE9BakMvQzJ6QixNQUFLTixTQUFTRTs7O0lBaUNxRDthQUd2RU8sd0JBQXdCM29CO0tBQ0YsV0FBQSwwQkFERUE7S0FDRixPQUFBO0lBQXlDO0lBR3hDO0tBQXZCNG9COzRCLE9BSkFEO0tBTUFFOzs7Uzs7SUEvRDhDO1lBQzlDWjtZQUNBRTs7WUFtQklLO1lBb0NKRztZQUlBQztZQUVBQzs7O2FBV0lDLG1CQUFtQkM7S0FBeUIsV0FBQSxXQUF6QkE7S0FBeUIsT0FBQTtJQUFZO0lBRzFEO0tBQUFodkM7S0FEWSxXQUNaQTs7OEJBSkVpeUIsY0FDQThjOztLQVNKOzs7OztTQURBO1NBQ0EsV0FBQTtTQUFBLE9BQUE7UUFJSztNQUpMO1FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBU0E7Ozs7O1NBREE7U0FDQSxXQUFBO1NBQUEsT0FBQTtRQUErQjtNQUEvQjtRQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBS0UxbEM7SUFBVTtJQUFBOzs7WUFDVGdkLGdCQUFLLE9BQUxBOztZQUNDZ2Isa0JBQUssT0FBTEE7O1lBQ0Q0TixrQkFBSyxPQUFMQTs7WUFDQW4wQix3Q0FBQUE7Ozt1QkFBQUE7O3dEQUFBQTt1REFBQUE7Ozs7R0FBbUM7R0FNL0IsSUFBUG8wQixTQUFPLGtCQXg3QkwxK0IsTUFyekJGb3JCO1lBcXZESXVUO0lBQWlCO0lBQUE7OztZQUNoQjlDLG1CQUFRLE9BQUEseUJBQVJBOztZQUNBdnhCLHdDQUFBQTs7O3VCQUFBQTs7d0RBQUFBO3VEQUFBQTs7Ozs7UUFDZSxNQUFBOztHQUFZO1lBR2hDczBCLGVBQWdCQyxLQUFLQyxZQUFZQyxhQUFZcnZDLEdBQUU4akI7YUFDekN3ckIsbUJBQW9CSCxLQUFJbnZDLEdBQUU4akI7S0FDaEMsSUFEOEI3ZSxNQUFBakY7S0FDOUI7TUFBZ0I7T0FEVXV2QyxRQURPRixjQUNQRjtPQUNWLE9BQUEsc0JBRFVJO09BQ3RCQyxRQUFRLHNCQURvQjFyQjtNQUVoQyxPQUY4QjdlOztTQU9IO1VBRHBCa25DLE9BTnVCbG5DO1VBT0gsT0FoQ3pCa0UsWUErQktnakM7VUFDRHNELGdCQUFZLHNCQVBjM3JCLEdBQU5xckI7U0FReEIsS0FUbUJDLFlBaUJkLFdBVERLO1NBOXRDTTs7O2FBbXVDQSxJQUFZQyxjQUFOanBCO2FBQVksV0FBQSxzQkFYMUIrb0IsT0FXYy9vQixPQUFNaXBCO1lBQXNCO1VBcHVDL0JDLHFCQUFBN2Q7VUFDWDlvQixRQUFRLHlCQTZ0Q0xtakM7U0E1dENQLEdBRmV3RDtjQUVYaEQsVUFEQTNqQzs7VUFJRztXQUFBO3NCQUEwQnNGLEdBQUssT0FBQSw0QkFBTEEsZ0JBQWlDO1dBSDlEcStCLFVBR0csMEJBSkgzakM7U0FJRztVQUFBLE9BQUEsMEJBSEgyakMsU0EvMUJBdlU7VUFra0VLLE9BQUEsZ0NBdnVDUHdKO1NBb3VDRSxXQUhFNk4sV0FJQzs7O2tCQVh1QnhxQztVQWlCWDBIO1VBQVRpZTs7O2FBSWtCLElBQVk1cUIsY0FBTm12QzthQUFZLE9BckJ4Q0csbUJBcUI0QkgsS0FBTW52QyxHQXBCcEN3dkM7WUFvQitFOzhCQUpoRTdpQzs7O3FCQUFBQTs7c0RBQUFBO3FEQUFBQTs7U0FFYjtVQUFBLE9BQUEsZ0NBN3VDSmkxQjtVQTZ1Q0csT0FBQTtTQURILGVBQUMsc0JBbEI2QjlkLEdBQU5xckIsTUFpQmhCdmtCOztTQVFSOzthQXRCS2hRLFFBSHVCM1YsNEJBR3ZCMlY7OztjQUh1QjFWLE1BR3ZCMFY7OytDQUh1QjFWLE1BR3ZCMFY7Y0FIdUIxVixzQ0FHdkIwVjs7YUFIdUIzVixNQUFBQzs7O0lBeUIxQjtJQUVOLE9BM0JRb3FDLG1CQURVSCxLQUE2Qm52QyxHQUFFOGpCO0dBNEJ0QjtZQU8zQjhyQixzQkFBdUJDLFFBQVFDO0lBUS9CLElBUEVDLFFBT0Ysb0NBUitCRDtJQVVqQyxPQUFBLG9DQVRJQyxPQURxQkYsUUFDckJFLE9BRHFCRjtHQXlCakI7O0lBS1I7Ozs7O1FBREEsV0E3QkVEO1FBNkJGO1FBQ0EsV0FBQTtRQUFBLE9BQUE7T0FZSztLQVpMO09BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErdUJXLElBQVBJLFNBQU8sa0JBdHZETDEvQixNQXJ6QkZvckI7WUEwakZGdVUsUUFBTzltQyxTQUFTRCxRQUFPZ25DO0lBQ3pCLGNBQXVDNWhDO0tBQXFCLFdBQUEsV0FBckJBO0tBQXFCLE9BQUE7SUFBTTtJQUFyRCxJQUFUcWMsV0FBUyw0QkFES3poQjtJQUVsQixPQWprQ0UwakMsTUErakNPempDLFNBQ0x3aEIsVUFEcUJ1bEI7R0FFRztZQUcxQkMsZUFBZ0JobkMsU0FBU0QsUUFBT2duQztJQUNsQyxPQU5FRDthQUtnQjltQzthQUFTRDs7O2VBQU9nbkM7d0JBSXZCak47Z0JBRUEsWUFBQSxXQUZBQTttQ0FHSztnQkFFVyxJQURkdm9CLGNBQ2MsT0FBQSwyQkFEZEE7Z0JBQ047Z0JBQUEsT0E1NkdINlg7ZUE2NkdTO0dBQUM7WUFJVjZkO0lBQXFCLG1DQTNnRXJCbk8sb0JBcGtCQXhHO0dBK2tGMkU7WUFDM0VnSSx5QkFBcUIsT0EzZ0VyQnZCLG1CQTJnRWtEO0dBRmpDO0lBQUEsb0JBQ2pCa08sbUJBQ0EzTTtJQUtBNE07WUFVRUMseUJBQXlCSixPQUMzQixPQXZqRE0vb0IsWUFwQkE0Z0IsV0Ewa0RxQm1JO0dBQzhDOzs7Ozs7SUFLM0VLO0lBQ0FDOzs7OztRQTN2R0V2YztRQUhBRDtRQU9BSTtRQUVBQztRQThJQThCO1FBakJBckI7UUFrQ0FzQjtRQW1CQUU7UUF3QkFFOztRQTREQXZCOztRQXFzRElvRTtRQUZBRTtRQUNBRDtRQVRBWTtRQUNBSTtRQUNBSztRQUNBYjtRQUVBRTtRQUVBQztRQUhBRjtRQUVBZ0I7UUFSQUM7UUFDQUM7UUFGQWpDOztRQXBCQTZHO1FBTUFJO1FBREFDO1FBREFDO1FBRkFKO1FBQ0FDO1FBSUFuRDtRQUNBd0M7UUFDQUU7UUFSQU87Ozs7UUE0Q0FzSDs7Ozs7Ozs7Ozs7UUF6REZyQjtRQTh4Q0ZpSztRQS94Q0UvTztRQStDRXhhO1FBQ0FvZ0I7UUF6QkFwSTtRQUdGK0g7O1FBb0ZBNEM7UUFDQUM7UUFDQUU7UUFDQUM7UUFQQW5DO1FBbmFBSDs7U0ExbURGalQ7U0FIQUQ7U0FPQUk7U0FFQUM7U0E4SUE4QjtTQWpCQXJCO1NBa0NBc0I7U0FtQkFFO1NBd0JBRTs7U0E0REF2QjtRQWxTRm9DO1FBQ0EyTztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQWkrRE1oTjtRQUZBRTtRQUNBRDtRQVRBWTtRQUNBSTtRQUNBSztRQUNBYjtRQUVBRTtRQUVBQztRQUhBRjtRQUVBZ0I7UUFSQUM7UUFDQUM7UUFGQWpDO1FBcEJBNkc7UUFNQUk7UUFEQUM7UUFEQUM7UUFGQUo7UUFDQUM7UUFJQW5EO1FBQ0F3QztRQUNBRTtRQVJBTztRQXBFRjJKOzs7Ozs7OzZCQWdIRXJDOzs7Ozs7Ozs7Ozs7Ozs7UUF6REZyQjtRQWdlRmlKO1FBamVFL047UUErQ0V4YTtRQUNBb2dCO1FBekJBcEk7UUFHRitIOztRQW9GQTRDO1FBQ0FDO1FBQ0FFO1FBQ0FDO1FBUEFuQztRQWhIQTZDO1FBZ0VFOUM7UUFqRUZ6QjtRQVBBZ0U7UUFDQUc7UUFDQUU7UUFDQUM7UUFPQUU7O1NBLzVERmxXO1NBSEFEO1NBT0FJO1NBRUFDO1NBOElBOEI7U0FqQkFyQjtTQWtDQXNCO1NBbUJBRTtTQXdCQUU7O1NBNERBdkI7UUFsU0Z1VjtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQWkrRE16UjtRQUZBRTtRQUNBRDtRQVRBWTtRQUNBSTtRQUNBSztRQUNBYjtRQUVBRTtRQUVBQztRQUhBRjtRQUVBZ0I7UUFSQUM7UUFDQUM7UUFGQWpDO1FBNEJGZ1M7UUFoREVuTDtRQU1BSTtRQURBQztRQURBQztRQUZBSjtRQUNBQztRQUlBbkQ7UUFDQXdDO1FBQ0FFO1FBUkFPO1FBaEJGd0s7UUFEQUY7T0E0UUoyQztPQXFpQ0FrRDtPQUtBRTtPQXBoQ0Exa0M7T0FoQkF3aEM7T0FxQkFiO09Bc0JBb0I7T0E2Sklya0M7T0F2a0ZGb3BCOzt1QkF1a0ZFcHBCLFNBd0JGK2xDLGdCQU5JRDtPQTgyQk5zQjs7T0FDQUM7O1FBbnRDQXBnQztRQWtzQ0VpZ0M7WUE1ckVBNVE7O1NBN1pBcEU7U0FDQUM7U0FFQUM7U0FDQUU7U0FXQUc7U0FIQTc3QjtTQW9CQW04QjtZQWdiSnI4QixTQU1JbWhDLFNBY0FLO1lBMjJCRTJKLG1CQW94Q0FzRjs7Ozs7OztVQWx4QndDRztVQUFBQztVQUFBQztVQUFBQzs7Ozs7a0JBcUQxQ0MsaUJBdENrQkM7VUFBb0IsSUF1Q3BDdFgsUUF2Q29DLGlCQUFBLCtCQUFwQnNYO1VBd0NqQixHQUFBLDRCQURDdFg7V0F4QzBCLGlCQUFBLCtCQUNWc1g7VUF3Q1MsT0FEekJ0WDtTQUVDOzs7Ozs7O2tCQWdFRHVYLFlBQWE1L0IsYUFBYUQsYUF4RndDRDtVQXlGcEU7V0FPUzthQUFBO1dBREUrL0IsWUFDRjtXQWhHaUVwZCxnQ0ErRi9Eb2Q7V0EvRm1EQyxPQTRGcEQsV0F0akJaN2dDLFVBa2pCaUJlLGFBQWFEO1dBeEYyQmdnQztXQUFsQkM7V0FBYkM7V0FDdEI7VUFmQSxTQUFJQywrQkFBa0NoWDtXQUNwQztZQUFpQixJQUFlL0YsZ0JBQVRnZDtZQUFpQixXQUFBLCtCQUFqQkEsVUFBU2hkO1dBQXVDO1dBQXRELE9BQUEsMEJBRG1CK0Y7VUFDbUM7VUFFekUsV0FXd0V6Rzs7OzthQVI1RHlHLE9BUTREekc7bUNBZHBFeWQsK0JBTVFoWDs7O2FBREZrWCxTQVM4RDNkO21DQWRwRXlkLCtCQUtNRTs7O1lBRENDLFNBVTZENWQ7bUNBZHBFeWQsK0JBSU9HOztzQkFVNkQ1ZDtVQUN4RTtXQXdGRTZkO2FBeEZGOztlQURzQkw7ZUFBYUQ7ZUFBa0JEO2VBQU9EO2VBQU1oZ0M7OztVQW9HcEUsV0FwSTBDeS9CLFVBeUh0Q2U7bUJBL0JBQyxjQUFjQyxPQUFNek47V0FDdEIsSUFBSTBOLGlCQUFTOzs7YUFPSCxXQUFBLFdBbEc4QmpCLHFCQTBGeEJnQjthQVFOLE9BQUE7WUFBeUQ7WUFEM0QsSUFERXJlLFNBQ0Y7WUFOSnNlLGdCQUtNdGU7O1dBSWlCO1dBUHpCLElBREV1ZSxTQUNGOztZQVdBLHNCQVpFQTtZQWFGLFdBekdzQ25CLFVBMEZ4QmlCO3VCQUNaQzs7OzsrREFEa0IxTjs7Ozs7Ozs7O21DQWtCVDROLHFCQUFXLE9BQVhBO2dCQUNHbFA7WUFBUSxNQUFBLDRCQUFSQTtXQUFpQjtXQU5wQixPQUFBO1VBTXFCO1VBTWtCO1dBQUEsT0FBQTtXQUFsRG1QLGdCQXpCQUwsY0ErQkFEO1dBTGtELE9BQUE7V0FBbERPLGdCQTFCQU4sY0ErQkFEO1dBWVFRLFNBaEJxQiwyQkFEN0JEO1dBaUJBRSxTQWhCSiwyQkFGSUg7VUFtQkosV0F0STBDbkIsTUF5SHRDYTtVQWFKO1dBRU07WUFBQSxPQUFBLDZCQUhGUztZQVdGbHlDLElBUkkseUJBQUE7V0FRQyxPQUFMQTs7Z0JBUFVteUM7O1lBQUF2UCwwQkFBQXVQOzswREFKQUY7OzBEQUFSQzs2Q0FJUXRQOzs7Ozs7Ozs7U0FPSjtrQkFpQ0p3UCxlQUFlckUsT0FBa0IsT0FLckNzRSxvQkFMbUJ0RSxVQUFzRDtrQkFFekV1RTtpQkFYc0NyaEMsa0JBQVpDLGFBQVpDO1VBWWhCLE9BSE1paEM7bUJBcGJGM0U7cUJBMlhBc0QsWUFnRFk1L0IsYUFBWUQsYUFBWUQ7cUJBQXhCRTtxQkFBWUQ7cUJBQVlEOztTQVkrQjtrQkFFckVvaEMsb0JBQW9CekU7VUFDdEIsT0FEc0JBOztpQkFFZnB6QixJQUZlb3pCLFNBRVYsV0FBTHB6Qjs7YUFLYTtjQUhaQyxJQUpjbXpCOzs7K0IsOEJBTGhCd0U7Y0FZYyxPQUFBLDBCQUhaMzNCO2FBQ04sZUFETUEsTUFBQUE7OztjQUtEQyxJQVRla3pCO2NBU1ozOEIsbUJBQUh5SjtjQUFxQnhKLGNBQXJCd0o7Y0FBa0N2SixjQUFsQ3VKO2FBQ0w7cUJBREtBOztzQixPQVpMNDNCO3FDQVlRcmhDLGtCQUFrQkMsYUFBYUM7OztpQkFObEN1M0IsSUFIZWtGO2FBR1YsV0FBSywwQkFBVmxGLEdBSEwySjs7U0FVa0U7a0JBRzlEN0IsUUFBTXh3QztVQUNaLElBRFlpRixNQUFBakY7VUFDWjtrQkFEWWlGOztrQkFFTHVWLElBRkt2VixRQUVBLFdBejlDVjQ4QixNQXk5Q0tybkI7O2tCQUNDQyxJQUhJeFYsUUFHQyxXQXhvQlg2bUMsUUFxb0JJMEUsU0FHRS8xQjs7O2VBQ0RDLElBSkt6VjtlQUlGZ00sbUJBQUh5SjtlQUEwQnhKLGNBQTFCd0o7ZUFBdUN2SixjQUF2Q3VKOzs7a0IsT0FwQkw0M0I7aUNBb0JRcmhDLGtCQUF1QkMsYUFBYUM7O2NBQzVDLFdBcG5CQTg2QixRQW1uQkt2eEI7O2tCQUVBRSxRQU5LM1YsNEJBTUwyVjs7O21CQU5LMVYsTUFNTDBWOztvREFOSzFWLE1BTUwwVjttQkFOSzFWLHNDQU1MMFY7O2tCQU5LM1YsTUFBQUM7O1NBTTRCO2tCQTRDdENxdEM7VUFBeUJ2cEMsT0FBT3NILE1BQU1uSCxTQUFTRCxRQUFRc3BDO1VBQ3pEOzBCQU1ZLGdDQVA2Q0E7a0JBQTlCeHBDO1dBSUEsdUJBOWpFekJqSixVQTBqRWdDdVE7V0FHN0I7O2tCQUhtQ25IOzttQkFJNUI7bUJBSnFDRDtVQUUvQyxPQXQ1RkZ1cEIsYUFzNUZFO1NBTUs7a0JBR0RnZ0IsZUFBZTVRLE9BQU12eEIsTUFwRE0rK0IsYUFBUHJtQyxPQUFYMHBDO1VBcURmLElBckQ2QzVHLFVBb0R4QmpLO1VBQ3JCO1dBZkE7WUFyQ1FsRDt1QkFBS3J1QixNQUFLOFIsS0FBSXlmO2VBQ3BCLElBRG9CaUssVUFBQWpLO2VBQ3BCO29CQUFJOFEsaUJBRjJCdEQsY0FqaEUvQnR2QyxZQW9CQW04QjtnQkFnaEVBLE9BbEJvQjRQOzt1QkF5Qlp0eEIsSUF6QllzeEI7bUJBMEJsQixLQTNCc0I5aUMsT0FtQ2pCLE9BbENTb1o7bUJBNEJaOzsrQkFFK0JBLEtBQUl3UTt1QkFDOUI7d0JBQUlvYyxhQUQwQnBjLFFBOUI1QnRpQjsrQkE4QjRCc2lCOytCQUFBQTt3QkFFMUJnZ0IsWUEvQlRELGVBOEJTM0Q7dUJBRUosV0FESTRELE9BRnNCeHdCO3NCQUdoQjs7K0JBSlF3UTt1QkFBTyxPQUFBLDRCQUFQQTtzQkFBdUM7b0JBRDlELE9BQUEsMEJBSElwWTttQkFLc0IsT0FBQSxnQ0E5QmQ0SDs7bUJBd0JILElBQUwzSCxJQXhCWXF4QixZQXdCUCxPQUFMcnhCOzs7d0JBdEJrQjlOOzs7eUJBQUFBOzs7d0JBQUFBOzttQkFHbkI7b0JBRkRrbUM7c0JBRUMsV0E1L0RQelcsVUF1L0RXOXJCO3lCQUVlM0Q7eUJBS2pCOzswQkFMaUJBOzs7OytCQVNPeVY7dUJBQUw7d0JBQXNCeWY7d0JBQVpyRzt3QkFDM0J3VCxhQUQyQnhULFlBWDNCbHJCO3dCQWFBNUksT0FaUGlyQyxlQVdPM0Q7d0JBRUF2bkMsTUFBTSw4QkFIaUNvNkI7d0JBSXZDbmYsZ0JBRkFoYixNQUNBRCxTQUhzQjJhO3VCQUsxQixPQWpCTXN3QixZQUNQL1QsS0FZS3FRLFFBR0F0c0IsT0FKdUNtZixTQUl2Q25mO3NCQUMyQzs7K0JBTmxCNEMsR0FBRTlLO3VCQUFpQyxXQUFBLHNCQUFqQ0E7dUJBQWlDLE9BQUE7Z0NBajNGekU2SyxxQkFpM0ZpRSxzQkFBM0JDO3NCQUEwQztvQkFENUUsT0FBQSwwQkFOSXV0QjttQkFRc0IsT0FBQSxnQ0FYWnp3Qjs7dUJBbUJMNnBCLFVBbkJTSDttQkFzQmxCO29CQUFLLFdBdEJEbk4sS0FBS3J1QixNQUFLOFIsS0FzQkssV0FIVjZwQjtvQkFHSjs7K0JBQ0csT0F2Qk03cEI7O3VCQW1DVHhILFFBbkNha3hCLGdDQW1DYmx4Qjs7O3dCQW5DYTQxQixVQW1DYjUxQjs7eURBbkNhNDFCLFVBbUNiNTFCO3dCQW5DYTQxQiwwQ0FtQ2I1MUI7O3VCQW5DYWt4QixVQUFBMEU7OztjQW1DNEI7WUFFbEQsT0FyQ1E3UixLQTloRU50RCxZQTZoRTJDeVE7WUFxRHpDMEcsY0FmSjtXQWdCQSxPQXRENkMxRzs7Y0F3RC9CO2VBRE50eEIsSUF2RHFDc3hCO2VBd0R2Q3htQyxRQUFRLGdDQUROa1Y7O21DQVFNLGdDQVJOQTswQkFBQUE7ZUFLb0MsT0FBQSw4QkFKdENsVjtlQUlnQixPQTdrRXBCdkYsVUFxa0V5QnVRO2VBUUwsT0FBQTs4QkFBUjtjQUZWLE9BcjZGSm1pQjt1QkFxNkZJLG1DQUhJalk7O2tCQVVBQyxJQWpFcUNxeEI7Y0FrRTNDLE9BekJBeUc7dUJBekN3QnZwQyxPQW9EQ3NILE1BYW5CbUssTUFBQUEsTUFaSiszQjs7a0JBbUJJOTNCLElBeEVxQ294QjtjQXlFM0MsT0FoQ0F5Rzt1QkF6Q3dCdnBDLE9Bb0RDc0gsTUFvQm5Cb0ssTUFBQUEsTUFuQko4M0I7O2tCQTBCRzUzQixRQS9Fc0NreEIsZ0NBK0V0Q2x4Qjs7O21CQTNCY3F4QixVQTJCZHJ4Qjs7b0RBM0JjcXhCLFVBMkJkcnhCO21CQTNCY3F4QiwwQ0EyQmRyeEI7O2tCQS9Fc0NreEIsVUFvRHhCRzs7O1NBMkJnRTtrQkF1STdFTSxJQUVKdnNDO1VBRlUsT0FFVkE7O2FBdEJGO2NBRk9tc0MsT0F3Qkxuc0M7Y0F0QkVnSixRQUZHbWpDOztvQztjQUdIUTtnQkFud0JOSDtrQkFrd0JNeGpDOztrQkFEQXRCOzttQkFBQUE7Ozs7NkJBYWdCa3NCO3FCQUFPLE9BQUE7bUNBQVBBLEtBaGlHdEJYO29CQWdpR29GOzttQkF6bEZoRjVQOzs7YUFrbUZhLGVBdkJSOG9CLFNBQUFBLFNBR0hRLFNBSEdSLFNBQUFBOzthQTBCTDtzQkFGQW5zQztjQUNzQ210QztjQUFieGdDO2NBQVJ6RDtjQUFUQztjQUNSO3lCQUMrQndEOztrQkFDSCxJQUFZeWhDLG9CQUFOMW1DO2tCQUFrQixXQUFsQkEsTUFOOUI2a0MsSUFNb0M2QjtpQkFBOEI7aUJBQTFDLE9BQUEsMEJBREd6aEM7Z0JBQ3VDO2NBRmxFbW1DLGdCQUNGLDBCQUZ1Qm5tQzthQUt6QixlQUxReEQsU0FBU0QsUUFDYjRwQyxlQURrQzNGOzthQUR2QixPQUFmbnRDOztpQkFPSzRhLFFBUEw1YTthQU9jOzs7K0NBQVQ0YTs7O21DQUFBQTs7b0VBQUFBO21FQUFBQTs7dUJBQXlCLE9BVDFCMnhCOzs7U0FTOEM7a0JBSWhEd0cscUJBRUoveUM7VUFGMkIsT0FFM0JBOzthQURlLE9BQ2ZBOzthQUdFO3NCQUhGQTtjQUNzQ210QztjQUFieGdDO2NBcEpDekQ7Y0FBVEM7O3lCQXNKY3dEO2lCQUMzQjtrQkF0R0UsT0F2M0JGOHhCLEtBUkFzQixNQUZBRix5QkF0OEROeEk7a0JBbzBGUTtvQkFBQTtzQkE1MUJGNVEsNEJBUkFxVDs7a0JBbTJCRTtvQkFBQTtzQkEzMUJGclQsc0JBUkFxVDs7a0JBazJCRTtvQkFBQTtzQkExMUJGclQsMEJBUkFxVDs7a0JBMHpCRjtvQkFsbkJKOFM7OztzQkFrbkJJOzt3QkFBQTs7MEJBQUE7OzRCQUFBOzs4QkFBQTs7Z0NBQUE7O2tDQUFBOzs7cUNBQVk4RixXQUFVMXBDLE9BQU1xbUMsYUFBWUwsUUFBTXBiLEtBQWFvZjtxQ0FFakQsWUFBQSxpQkFGb0NwZixLQXBsQmxEb1o7O3NDQXdsQmtCLE1BQUE7O3lDQUhSaUc7d0NBRGtDakUsaUNBQUFBO3NDQVNwQzt1Q0FESTErQixPQVJnQzArQjt1Q0FTcEM7a0RBQXVDMStCLE1BQUtrckIsWUFDMUMsV0FEMENBLFlBQUxsckIsTUFDVDt1Q0FFNUIwL0IsU0FIRiw0QkFUdURnRCxTQVFuRDFpQzt5Q0FSbUQwaUM7dUNBb0JsRDt3Q0FGRTdELE1BbEJnRDZEOzt3REFxQm5CN3NCLEdBQUssV0FBTEEsZUFBZTt3Q0FEOUM7MENBQUE7NENBbm9EYmlCOzRDQW9vRGUsOEJBcEJMNnJCOzRDQWlCSzlEOzs7d0NBaUJBOzt5Q0FIMEJudkM7eUNBQXhCa3pDO3lDQUVBQyxTQXRvRWZ2WCxjQWduRVFvVSxRQU1LYixLQWNFK0Q7eUNBcEJEclIsUUEzR1YyTyxRQStIbUN4d0M7eUNBcEIvQm96QyxTQXNCT0Q7O3dDQUxGO3lDQUpJejRCO3lDQUlKLE9BcG9FYjNhLFVBbW5FUWl3QzsyREF6OEZWcmQsV0ErOEZld2MsV0FPSXowQjt5Q0FiSG1uQjt5Q0FBTnVSOzs7dUNBR2tCO3dDQUFBLE9BQUEsOEJBZGxCSCxNQWhHSnpDO3dDQThHUTdqQyxjQUFjO3dDQUNsQixnQkFBdUN6RCxRQUFVLE9BQUEsV0FBVkEsV0FBbUI7d0NBQXREeWhCLFdBQVMsNEJBcEJLemhCO3dDQWdCWjRpQyxrQkFoQkczaUMsU0FvQkx3aEIsVUFEQWhlO3dDQUhFazFCLFFBQUFpSzt3Q0FBTnNILFNBQUFwRDtzQ0EyQlU7O3lDQXpFZHlDLGVBOENVNVEsT0FBTnVSLFFBWnNCL0QsYUFBTnJtQyxPQUFWMHBDO3NDQXVDSSxPQUFBOztxQ0E3bkViLE1BQUE7O29DQTZuRXVFOzs7OzRCQS8xQzFFcGlDOzBCQUtBc2pCOztpQkEwOENJLE9BenlCUjZZOzBCQXN5QlE7K0NBRnlCOS9CLGFBTDNCb21DOzs7O2dCQVVvQztjQU5wQ0QsZ0JBQ0YsMEJBRnVCbm1DO2FBU3pCLGVBN0ppQnhELFNBQVNELFFBcUp0QjRwQyxlQURrQzNGOzthQUR2QixPQUFmbnRDOztpQkFXSzRhLFFBWEw1YTthQVdjOzs7K0NBQVQ0YTs7O21DQUFBQTs7b0VBQUFBO21FQUFBQTs7dUJBQTBDLE9BYjNDbTRCOzs7U0FhK0Q7a0JBR25FTSxtQkFBbUJwUyxNQUFNcVMsVUFBUWhqQzt3QkFDV2hDLEdBQzVDLE9BOXlEQSt5QixPQTR5RG1CSixNQUN5QjN5QixHQURYZ0MsTUFFRTtVQURJLE9BQUEsNEJBRGRnakMsVUFBTnJTO1NBRWlCO2tCQUdoQ3NTO1VBQ052ekM7VUFDQSs0QjtVQUNDc0k7VUFDQS93QjtVQUNBcXpCO1VBcFkyQjZQO1VBc1kzQnZGO1VBQ0FFO1VBQ0F0TDtVQUNBSztVQUNBdVE7Y0FWRHh1QyxNQUFBakY7O2tCQUFBaUY7O2NBNEJhO2VBRE5rbkMsT0EzQlBsbkM7ZUE0Qk15dUMsU0FsQ0pMLG1CQVVEMVAsUUFGQXRDLFFBQ0Evd0I7ZUEwQks4eUI7OzttQixPQWxPQXFQLGVBN0RBakMsUUFrUU52ckMsTUFHQ3FMOztjQThCQyxPQS9sREEyeUI7dUJBeWxES2tKO3VCQTFCUHBUO3VCQVFDbUs7dUJBTkE1eUI7dUJBeUJLb2pDO3VCQXBCTDdRO3VCQXFCS087dUJBdG5ESlQ7O2NBdW9EaUI7ZUFEWGwzQixRQTdDUnhHO2VBNkNnRGtvQyxPQUF4QzFoQztlQUFrQ3duQyxPQUFsQ3huQztlQUFZdkMsU0FBWnVDO2VBQUd0QyxVQUFIc0M7ZUFDRjA0QixhQXQyREEvQyxpQkE0ekRMdUM7bUNBeUN5Q3NQOzs7MEJBQUFBOzsyREFBQUE7MERBQUFBOztjQUU5QjtlQUFOMVAsUUFBTSxnQkE5Q1p4SyxPQXh2QkFpVTtlQXV5Qk0yRzswQkFBaUI5Z0I7a0JBQ25CLEdBSEVzUixZQUlHLE9BdHFHUDVSO2tCQTBxR007O3FCQTNQRmtnQjt1QkE3REFqQyxnQkErU0tybkMsU0FBU0QsUUFBc0IrcEMsTUFBTTlGO3VCQTFDL0M3OEI7Ozs7a0JBaURLO2tCQUFBLE9BQUEsV0FwcEdOcWlCLFdBZ3BHdUJFO2lCQVlEO2VBRVorZ0I7MEJBQVkzUyxNQUFNdVM7a0JBQ0c7bUJBQXZCSztxQkFBdUI7d0NBREhMOzJCQUVwQk0sS0FBS3RaO21CQUFPLE9BRlZvWixZQUVHcFosTUFETHFaO2tCQUNrRDsyQkFDbERFLFFBQVFDLEtBQUl4WjttQkFDZCxjQUFvRHJVLEdBQUssV0FBTEEsZUFBZTsyQ0FyQi9COHNCOzs7K0JBQUFBOztnRUFBQUE7K0RBQUFBOzttQkFxQnpCO29CQUFQZ0IsU0FBTztvQkFDTCxRQUFBLFdBcjFEWjdzQixlQW8xRFU2c0IsUUFETUQ7OzRDQUlDaDBDLGdCQUFMazBDO29CQUNKLE9BdkVGWDs2QkFzRVd2ekM7NkJBdEJYdWpDOzZCQTdDTGxDO2lDQW1FVzZTLE9BbEVYNWpDOzZCQThEbUJrcUI7NkJBRlpxWjs2QkF6RFA1Rjs2QkFDQUU7NkJBQ0F0TDs2QkFDQUs7NkJBQ0F1UTs7dUJBMERhNWdCO21CQUFPLE9BcEJmOGdCLGlCQW9CUTlnQjtrQkFhaUI7a0JBRTNCLFVBckJrQm9PO3NCQWpCMEJrTTt3QkE0Q2xDZ0gsU0E1Q2tDaEg7b0JBNENmLE9BQUEsV0FBbkJnSCxRQXoyRVp6WSxtQkFteEVEcHJCOzttQkFxRnVELFdBbDJFdER2USxVQTZ3RUR1UTttQkFxRlUsT0F4Q0xxakM7NEJBd0NLOztrQkFMUCxTQXJCa0IxUzttQkFrRUk7b0JBSlhwTixPQTlET29OOzs7K0JBa0VTdjVCO3VCQUFRLE9BSGpDLDRCQUd5QkEsTUFKaEJtc0I7c0JBSTBEO29CQUEvQzt3Q0FuRmdCb2Y7OzsrQkFBQUE7O2dFQUFBQTsrREFBQUE7O21CQWlGbEM7b0JBQUEsT0FBQTtvQkFBQSxPQUFBO29CQURFZ0IsU0FDRjttQkFLRixLQXpITFI7b0JBb0lRLDBCQWpCQ1E7b0JBaUJELE9BbHdHUDFoQjs7bUJBMHZHUztvQkFGR2prQixJQTFIYm1sQztvQkE0SFUsT0F4WUxqRCxRQWtRTnZyQztvQkFzSVcsT0FBQTtvQkFERTBILGNBQ0Y7b0JBRUs7c0JBQUEsV0FKRjJCLEdBSVUsV0ExNUV0Qm10QixPQXF4RURuckIsT0F5SGN1akIsTUFTRmxuQjsrQkFJTyxPQTd2R2xCNGxCO21CQSt2R3dCO29CQURUNmhCO29CQUNTLE9BQUEsa0NBRFRBO21CQUNMO21CQUFBLE9BL3ZHVjdoQjs7c0JBOHNHZWlJLE9BNUJLeUcsU0E0QlYrUyxNQTVCVS9TOzs7OzJDQTRCVitTOzs0Q0FBQUE7NkNBQUFBO2dEQUFBQTtnREFBQUE7OENBQUFBOztxQkFJNkIsU0FBQSxXQXYyRXZDclksUUE0d0VEcnJCOzZCQTJDSzZ6QjtnQ0FrQkUyUCxLQTBCU3RaOzhEQXBGaEJ5VCxVQTFuR0MxYjs7O3VCQWtxR0k0UixZQStEUSxPQTdDTjJQLEtBMEJTdFo7OEJBQUFBLDJCQUFBQTt5QkErQnlCNlosZUEvQnpCN1osU0ErQlU4WixnQkEvQlY5WjtxQkFnQ2tCLE9BekQzQnVaLFFBd0RtQk8sbUJBL0JmTixLQStCOEJLOztvQkFQM0I7O3VCQXZUVDVCO3lCQTdEQWpDLGdCQStTRS9rQyxVQUFBQSxVQUFrQ3duQyxNQUFsQ3huQzt5QkExQ1A2RTs7OztvQkE4R1k7b0JBQUEsT0FydUdYaWlCOzttQkF3dEc2QyxTQUFBLFdBNzJFN0NvSixRQTR3RURyckI7MkJBMkNLNnpCOzhCQWtCRTJQLEtBMEJTdFo7NERBbkZoQjJULGFBM25HQzViOztrQkErdUd1QixPQTFEakJ3aEIsUUF5QklDLEtBQUt4WjtpQkFxREQ7Y0FFZCxPQW5GUW9aLFlBMURUalEsUUFwWTJCNlA7O2NBMmFmO2VBM2FNcEgsT0FnWW5Cbm5DO2VBaFlzQnN2QyxTQTk3Q2hCclQsUUF3ekRKbVMsbUJBVUQxUCxRQUZBdEMsUUFDQS93QjtlQWxZSzJnQyxPQUFPLFdBaGdCYjdnQyxVQStmbUJnOEIsU0FBQUE7ZUFFYm5MLE9BQU8sc0JBRk1tTCxTQUFHbUk7ZUFHaEIzZ0IsTUFIYXdZOzswQkFJd0JsbEM7a0JBSXZDO21CQWhCYXN0QyxjQVkwQnR0QyxJQUluQiwwQkFSTGtsQzttQkF4REFxSSxZQWlESCx5QkFEQ0Q7a0JBaERTLE9BQUE7OzJCQUFZLCtCQUF4QnhJOzJCQUFLeUk7aUJBZ0VvQztjQUpyRCw0QkFKMEJqQjtjQVV4Qjs7aUJBQUE7O21CQVRFdkM7dUJBQUFBLE1BQ0FoUTs7bUJBQ0FyTjs7Y0FPRixPQUFBOztrQkFtWUdoWixRQWJQM1YsNEJBYU8yVjs7O21CQWJQMVYsTUFhTzBWOztvREFiUDFWLE1BYU8wVjttQkFiUDFWLHNDQWFPMFY7O2tCQWJQM1YsTUFBQUM7OztrQkFvSkVxckM7VUFDQXplO1VBQ0QrUTtVQUNBb0w7VUFDQUU7O1VBRUE5TTs7VUFFQW9TO1VBQ0R6ekM7VSxHQVJFOHhCO2VBQTRCc0QsTUFBNUJ0RCxRQUFBNGlCLDRCQUE0QnRmOztlQUE1QnNmO1VBVUY7ZUFOU3BmLGlCQWxQZXFmLE9Ba1BmcmY7Ozs7WUFsUGVxZixPQWtQZjtVQU1UO2VBSjBCemYsaUJBQXhCZ08sd0JBQXdCaE87O2VBQXhCZ08sdUNBQXdCO1VBSTFCLEdBUENpTDtlQVNRM25CLElBVFIybkIsZUFPR3lHLGVBRUtwdUI7O2VBRkxvdUI7VUFLSixHQWJDM0c7O1lBZ0JRaFksTUFoQlJnWTtZQWFHNEc7Ozs7b0M7Z0JBU007aUJBQUEsT0FBQSw2QkFORDVlO2lCQU1BLE9BQUE7Z0JBQUE7OztlQVRMNGU7bUJBbnhHeUJ2bUM7V0EreEduQjtZQUFKckosbUNBWkY0dkMsV0FMQUQsY0FGSjUwQztZQW9CTWtGLE1Bdk1BNnRDLHFCQXNNQTl0QztZQXpRZTY1QixNQThPbkI0Viw0QkF4TE1uSSxJQW9ORnJuQyxPQUFBQTtjQTFRa0J5dkM7WUFJVjthQXpCMEJoSCxxQkFxQmhCZ0g7YUFHdEJ4RixNQUhzQndGOzt3QkFJMEMxRztnQkFDOUQ7aUJBQ0UsT0FBQSw2QkFGNERBO2lCQXpCaEQ2RzttQkEyQlo7O2lCQTFCTjttQkFBQTt1REFEa0JBO2lCQUNsQixRQUFBOztpQkFZRTtrQkFES25qQjtrQkFoTk91VCxNQTNoQlZnSCxlQW92QmlCcE47a0JBek5QOStCLElBQUFrbEM7a0JBQVE0SSx1QkFvTWtCSDtpQkFuTXRDO3FCQURvQkc7O29CQUdYaUgsdUJBSFdqSDtvQkFHbEJrRyxNQUhrQmxHO21CQUlmLEdBQUEsNEJBREhrRzsrQkFIVWgwQzs7MkJBQUFBOztrQ0FRSSxvQ0FMZGcwQzs7O3VCQVlJO3dCQURNdjVCLElBZEF6YTsrQkFjQXlhO3dCQUNOOzs7Ozs7Ozs7dUJBQU8sWUFBQSwwQ0FaWHU1Qjs7O3lCQUhVL3VDO3lCQUFBakYsSUFBQWlGO3lCQUFRNm9DLHVCQUdYaUg7OztrQ0FhUSxvQ0FiZmY7Ozt1QkFVMEI7a0NBYmhCaDBDO3dCQVUyQmlSO3dCQUExQkM7d0JBQWFDO3dCQVZONmpDOzsyQkFHbEJoQjsyQkFVa0M7d0NBVjNCZSxzQkFPOEI5akM7d0JBVjNCL0w7MEJBM0JWNnJDLFlBcUN3QjUvQixhQUFiRCxhQUEwQkQ7d0JBVjNCalIsSUFBQWtGO3dCQUFRNG9DLHVCQUFBa0g7OzsyQkFTVHA2QixRQVRDNWEsMEJBU0Q0YTs7OzRCQVRDc2tCLE1BU0R0a0I7OzZEQVRDc2tCLE1BU0R0a0I7NEJBVENza0Isc0NBU0R0a0I7OzJCQVRDNWEsSUFBQWsvQjs7Ozs7OEJBQUFsL0I7a0JBaU5aO21CQUFBLE9BQUEsK0JBREsyeEI7bUJBQ0wsT0FBQTttQkFBQSxPQUFBO2tCQUFBOzs7OztpQkFIRTtrQkFBQSxPQUFBO2tCQUxGO29CQUFBOzs7Ozs7O2lCQUFBOztnQkF3QkUsT0FuaUdGWTtlQW9pR1E7YUFMSSxPQTNUWnNlO1lBMlRBO1lBTVk7OztnQkFDVjtpQkFwQ29ELE9BQUEsV0FuVlpKO2lCQW1WVyxPQUFBO2lCQUF2RDttQkFoWUFiOztnQkFnWUE7Z0JBb0NJLE9BdGlHRnJkO2VBdWlHUTthQUZJLE9BalVac2U7WUFpVUE7NEJBUEExQixLQXhCc0N4Qjs7O3dCQXVCaEM7V0FuVGdCO1lBaVVIK0Y7WUFBTG5FO1lBalVRO1lBQUEsT0FOdEJzQixpQkF4Q1k3RTtZQTRtQkl3SCx1QkE5akJNO1dBbVV4QixHQTJQa0JBO1lBdlBPO2FBRGhCeUIsZUF3UFN6QjthQXZQTyxPQUFBLHNCQU5KRTthQU1ielMsT0FBTyxpQ0FETmdVO2FBQ007O3dCQUNvQ2pmLEtBQUlpTDtnQkFDakQsY0FEaURBLHdCQUFKakwsV0FBQUEsS0FBSWlMO2VBR2xCO2FBbVB6QjBDLFNBdFBSLDJCQURJMUM7O2dCQXVQSTBDLFNBcC9EVjNDLFFBdXZEbUIwUztXQVlyQixJQWlQTXBqQyxPQXo4RUpnckIsU0E0c0VjaVU7V0E4UGQ7WUFDRTs7ZUF2TEVnRTtpQkF4RmV6VTs7aUJBbVBwQnVDO2lCQTBCSy93QjtpQkFBTXF6QjtpQkFBTTZQO2lCQWhCZHFCO2lCQUxBRDtpQkFUSC9SO2lCQUtDSztpQkFDRHVRO1lBMEJHOzs7Ozs7Z0JBYTZCNWdCO1lBQzFCLE9BNS9ERHVPLGlCQTQrRE11QztzQkF4eUdWcFI7dUJBMnpHSSw4QkFKMkJNLE1BdnpHL0JOOzs7ZUFWRkgsdUJBb0JPLE9BQUEseUJBTHNCOWpCO1VBRXRCLElBQ0MsV0FIcUJBLE1BR3JCO2dCQUNGNmpDO2VBQUF2UCwwQkFBQXVQO2NBQUF2UCxnQ0FBQUE7NkNBQUFBOzs7NkNBQUFBOzs7a0JBc3pHSnNTO1VBQWVsMUM7VUFBR212QztVQUFLbE87VUFBTWtVO1VBQVNDO1VBQWFDO1VBQW1CQztVQUV4RTtXQWorRVdDLGVBaStFUSw2QkFGQ3BHO1dBR2hCNytCLE9BbCtFZSwwQkFBUmlsQztXQW0rRVA1UixTQUpvRTJSLHdDQUEvQ3JVLFFBQUFBO1dBS3JCeVMsU0FMaUQyQixxQ0FJakQxUixVQUFBQTtXQUVBNFEsU0FOb0NhLHlCQUtwQzFCLFVBQUFBO1dBRUE4QixTQVAyQkwsMEJBTTNCWixVQUFBQTtXQUVBa0IsU0FuaEVGelUsUUFraEVFd1U7V0FFQXZ3QyxNQTFPRTh0QyxxQkFpT1cveUM7V0FTVDs4QjtVQUNSLE9BdE5NdXpDO21CQXFORnR1Qzs7O21CQU5BcUw7bUJBS0FtbEM7Ozs7Ozs7U0Fhd0I7b0JBbGV0QmpGLFNBNkRBaUMsZ0JBeVZKbEMsT0F1REEyRTs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgQ29tbWFuZC5Db21tYW5kX2ludGYgKilcbm1vZHVsZSBDb21tYW5kX2ludGYgPSBDb21tYW5kX19Db21tYW5kX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQ29tbWFuZC5FbnZfdmFyICopXG5tb2R1bGUgRW52X3ZhciA9IENvbW1hbmRfX0Vudl92YXJcblxuKCoqIEBjYW5vbmljYWwgQ29tbWFuZC5JbXBvcnQgKilcbm1vZHVsZSBJbXBvcnQgPSBDb21tYW5kX19JbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgQ29tbWFuZC5TaGFwZSAqKVxubW9kdWxlIFNoYXBlID0gQ29tbWFuZF9fU2hhcGVcblxubW9kdWxlIENvbW1hbmRfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwiaW5jbHVkZSBzdHJ1Y3RcbiAgb3BlbiBTdGRpb1xuXG4gIGxldCBlcHJpbnRmID0gZXByaW50ZlxuICBsZXQgcHJpbnRmID0gcHJpbnRmXG4gIGxldCBwcmludF9zID0gcHJpbnRfc1xuICBsZXQgcHJpbnRfc3RyaW5nID0gcHJpbnRfc3RyaW5nXG4gIGxldCBwcmludF9lbmRsaW5lID0gcHJpbnRfZW5kbGluZVxuICBsZXQgcHJlcnJfZW5kbGluZSA9IHByZXJyX2VuZGxpbmVcblxuICBtb2R1bGUgSW5fY2hhbm5lbCA9IEluX2NoYW5uZWxcbmVuZFxuXG5pbmNsdWRlIHN0cnVjdFxuICBvcGVuIEJhc2UuUHJpbnRmXG5cbiAgbGV0IHNwcmludGYgPSBzcHJpbnRmXG4gIGxldCBmYWlsd2l0aGYgPSBmYWlsd2l0aGZcbiAgbGV0IGtzcHJpbnRmID0ga3NwcmludGZcbmVuZFxuIiwib3BlbiEgQmFzZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgQ09NTUFORF9PVVRQVVRfSU5TVEFMTEFUSU9OX0JBU0hcbiAgfCBDT01NQU5EX09VVFBVVF9IRUxQX1NFWFBcbiAgfCBDT01QX0NXT1JEXG5bQEBkZXJpdmluZyBjb21wYXJlLCBlbnVtZXJhdGUsIHNleHBfb2ZdXG5cbmxldCB0b19zdHJpbmcgdCA9IFNleHAudG9fc3RyaW5nIChzZXhwX29mX3QgdClcbiIsIm1vZHVsZSBTdGFibGUgPSBzdHJ1Y3RcbiAgb3BlbiBTZXhwbGliMC5TZXhwX2NvbnZcbiAgb3BlbiBQcHhfY29tcGFyZV9saWIuQnVpbHRpblxuICBvcGVuIFBweF9zdGFibGVfd2l0bmVzc19ydW50aW1lLlN0YWJsZV93aXRuZXNzLkV4cG9ydFxuXG4gIG1vZHVsZSBMYXp5ID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgbGF6eV90IFtAQGRlcml2aW5nIHNleHAsIHN0YWJsZV93aXRuZXNzXVxuXG4gICAgbGV0IGNvbXBhcmUgPSBCYXNlLkxhenkuY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgQW5vbnMgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgR3JhbW1hciA9IHN0cnVjdFxuICAgICAgbW9kdWxlIFYxID0gc3RydWN0XG4gICAgICAgIHR5cGUgdCA9XG4gICAgICAgICAgfCBaZXJvXG4gICAgICAgICAgfCBPbmUgb2Ygc3RyaW5nXG4gICAgICAgICAgfCBNYW55IG9mIHRcbiAgICAgICAgICB8IE1heWJlIG9mIHRcbiAgICAgICAgICB8IENvbmNhdCBvZiB0IGxpc3RcbiAgICAgICAgICB8IEFkX2hvYyBvZiBzdHJpbmdcbiAgICAgICAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cCwgc3RhYmxlX3dpdG5lc3NdXG5cbiAgICAgICAgbGV0IHJlYyBpbnZhcmlhbnQgdCA9XG4gICAgICAgICAgQmFzZS5JbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICAgICAgfCBaZXJvIC0+ICgpXG4gICAgICAgICAgICB8IE9uZSBfIC0+ICgpXG4gICAgICAgICAgICB8IE1hbnkgWmVybyAtPiBmYWlsd2l0aCBcIk1hbnkgWmVybyBzaG91bGQgYmUganVzdCBaZXJvXCJcbiAgICAgICAgICAgIHwgTWFueSB0IC0+IGludmFyaWFudCB0XG4gICAgICAgICAgICB8IE1heWJlIFplcm8gLT4gZmFpbHdpdGggXCJNYXliZSBaZXJvIHNob3VsZCBiZSBqdXN0IFplcm9cIlxuICAgICAgICAgICAgfCBNYXliZSB0IC0+IGludmFyaWFudCB0XG4gICAgICAgICAgICB8IENvbmNhdCBbXSB8IENvbmNhdCBbIF8gXSAtPiBmYWlsd2l0aCBcIkZsYXR0ZW4gemVybyBhbmQgb25lLWVsZW1lbnQgQ29uY2F0XCJcbiAgICAgICAgICAgIHwgQ29uY2F0IHRzIC0+IEJhc2UuTGlzdC5pdGVyIHRzIH5mOmludmFyaWFudFxuICAgICAgICAgICAgfCBBZF9ob2MgXyAtPiAoKSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgICAgICAgIGxldCB0ID0gWyVvZl9zZXhwOiB0XSBzZXhwIGluXG4gICAgICAgICAgaW52YXJpYW50IHQ7XG4gICAgICAgICAgdFxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCByZWMgdXNhZ2UgPVxuICAgICAgICAgIGxldCBvcGVuIEltcG9ydCBpblxuICAgICAgICAgIGZ1bmN0aW9uXG4gICAgICAgICAgfCBaZXJvIC0+IFwiXCJcbiAgICAgICAgICB8IE9uZSB1c2FnZSAtPiB1c2FnZVxuICAgICAgICAgIHwgTWFueSBaZXJvIC0+IGZhaWx3aXRoIFwiYnVnIGluIGNvbW1hbmQubWxcIlxuICAgICAgICAgIHwgTWFueSAoT25lIF8gYXMgdCkgLT4gc3ByaW50ZiBcIlslcyAuLi5dXCIgKHVzYWdlIHQpXG4gICAgICAgICAgfCBNYW55IHQgLT4gc3ByaW50ZiBcIlsoJXMpIC4uLl1cIiAodXNhZ2UgdClcbiAgICAgICAgICB8IE1heWJlIFplcm8gLT4gZmFpbHdpdGggXCJidWcgaW4gY29tbWFuZC5tbFwiXG4gICAgICAgICAgfCBNYXliZSB0IC0+IHNwcmludGYgXCJbJXNdXCIgKHVzYWdlIHQpXG4gICAgICAgICAgfCBDb25jYXQgdHMgLT4gQmFzZS5TdHJpbmcuY29uY2F0IH5zZXA6XCIgXCIgKEJhc2UuTGlzdC5tYXAgdHMgfmY6dXNhZ2UpXG4gICAgICAgICAgfCBBZF9ob2MgdXNhZ2UgLT4gdXNhZ2VcbiAgICAgICAgOztcbiAgICAgIGVuZFxuXG4gICAgICBtb2R1bGUgTW9kZWwgPSBWMVxuICAgIGVuZFxuXG4gICAgbW9kdWxlIFYyID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICB8IFVzYWdlIG9mIHN0cmluZ1xuICAgICAgICB8IEdyYW1tYXIgb2YgR3JhbW1hci5WMS50XG4gICAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwLCBzdGFibGVfd2l0bmVzc11cbiAgICBlbmRcblxuICAgIG1vZHVsZSBNb2RlbCA9IFYyXG4gIGVuZFxuXG4gIG1vZHVsZSBGbGFnX2luZm8gPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVjEgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9XG4gICAgICAgIHsgbmFtZSA6IHN0cmluZ1xuICAgICAgICA7IGRvYyA6IHN0cmluZ1xuICAgICAgICA7IGFsaWFzZXMgOiBzdHJpbmcgbGlzdFxuICAgICAgICB9XG4gICAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwLCBzdGFibGVfd2l0bmVzc11cbiAgICBlbmRcblxuICAgIG1vZHVsZSBNb2RlbCA9IFYxXG4gIGVuZFxuXG4gIG1vZHVsZSBCYXNlX2luZm8gPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVjIgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9XG4gICAgICAgIHsgc3VtbWFyeSA6IHN0cmluZ1xuICAgICAgICA7IHJlYWRtZSA6IHN0cmluZyBvcHRpb24gW0BzZXhwLm9wdGlvbl1cbiAgICAgICAgOyBhbm9ucyA6IEFub25zLlYyLnRcbiAgICAgICAgOyBmbGFncyA6IEZsYWdfaW5mby5WMS50IGxpc3RcbiAgICAgICAgfVxuICAgICAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cCwgc3RhYmxlX3dpdG5lc3NdXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgVjEgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9XG4gICAgICAgIHsgc3VtbWFyeSA6IHN0cmluZ1xuICAgICAgICA7IHJlYWRtZSA6IHN0cmluZyBvcHRpb24gW0BzZXhwLm9wdGlvbl1cbiAgICAgICAgOyB1c2FnZSA6IHN0cmluZ1xuICAgICAgICA7IGZsYWdzIDogRmxhZ19pbmZvLlYxLnQgbGlzdFxuICAgICAgICB9XG4gICAgICBbQEBkZXJpdmluZyBzZXhwLCBzdGFibGVfd2l0bmVzc11cblxuICAgICAgbGV0IHRvX2xhdGVzdCB7IHN1bW1hcnk7IHJlYWRtZTsgdXNhZ2U7IGZsYWdzIH0gPVxuICAgICAgICB7IFYyLnN1bW1hcnk7IHJlYWRtZTsgYW5vbnMgPSBVc2FnZSB1c2FnZTsgZmxhZ3MgfVxuICAgICAgOztcblxuICAgICAgbGV0IG9mX2xhdGVzdCB7IFYyLnN1bW1hcnk7IHJlYWRtZTsgYW5vbnM7IGZsYWdzIH0gPVxuICAgICAgICB7IHN1bW1hcnlcbiAgICAgICAgOyByZWFkbWVcbiAgICAgICAgOyB1c2FnZSA9XG4gICAgICAgICAgICAobWF0Y2ggYW5vbnMgd2l0aFxuICAgICAgICAgICAgIHwgVXNhZ2UgdXNhZ2UgLT4gdXNhZ2VcbiAgICAgICAgICAgICB8IEdyYW1tYXIgZ3JhbW1hciAtPiBBbm9ucy5HcmFtbWFyLlYxLnVzYWdlIGdyYW1tYXIpXG4gICAgICAgIDsgZmxhZ3NcbiAgICAgICAgfVxuICAgICAgOztcbiAgICBlbmRcblxuICAgIG1vZHVsZSBNb2RlbCA9IFYyXG4gIGVuZFxuXG4gIG1vZHVsZSBHcm91cF9pbmZvID0gc3RydWN0XG4gICAgdHlwZSBhID0gRHVtbXlfdHlwZV9iZWNhdXNlX3dlX2Nhbm5vdF9kaWdlc3RfdHlwZV9jb25zdHJ1Y3RvcnNfb25seV9jb25jcmV0ZV90eXBlc1xuICAgIFtAQGRlcml2aW5nIGJpbl9pb11cblxuICAgIG1vZHVsZSBWMiA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgeyBzdW1tYXJ5IDogc3RyaW5nXG4gICAgICAgIDsgcmVhZG1lIDogc3RyaW5nIG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICAgICAgICA7IHN1YmNvbW1hbmRzIDogKHN0cmluZyAqICdhKSBsaXN0IExhenkudFxuICAgICAgICB9XG4gICAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwLCBzdGFibGVfd2l0bmVzc11cblxuICAgICAgb3BlbiEgQmFzZVxuXG4gICAgICBsZXQgbWFwIHQgfmYgPVxuICAgICAgICB7IHQgd2l0aCBzdWJjb21tYW5kcyA9IExhenkubWFwIHQuc3ViY29tbWFuZHMgfmY6KExpc3QuQXNzb2MubWFwIH5mKSB9XG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbW9kdWxlIE1vZGVsID0gVjJcblxuICAgIG1vZHVsZSBWMSA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgeyBzdW1tYXJ5IDogc3RyaW5nXG4gICAgICAgIDsgcmVhZG1lIDogc3RyaW5nIG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICAgICAgICA7IHN1YmNvbW1hbmRzIDogKHN0cmluZyAqICdhKSBsaXN0XG4gICAgICAgIH1cbiAgICAgIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHAsIHN0YWJsZV93aXRuZXNzXVxuXG4gICAgICBvcGVuISBCYXNlXG5cbiAgICAgIGxldCBtYXAgdCB+ZiA9IHsgdCB3aXRoIHN1YmNvbW1hbmRzID0gTGlzdC5Bc3NvYy5tYXAgdC5zdWJjb21tYW5kcyB+ZiB9XG5cbiAgICAgIGxldCB0b19sYXRlc3QgeyBzdW1tYXJ5OyByZWFkbWU7IHN1YmNvbW1hbmRzIH0gOiAnYSBNb2RlbC50ID1cbiAgICAgICAgeyBzdW1tYXJ5OyByZWFkbWU7IHN1YmNvbW1hbmRzID0gTGF6eS5mcm9tX3ZhbCBzdWJjb21tYW5kcyB9XG4gICAgICA7O1xuXG4gICAgICBsZXQgb2ZfbGF0ZXN0ICh7IHN1bW1hcnk7IHJlYWRtZTsgc3ViY29tbWFuZHMgfSA6ICdhIE1vZGVsLnQpIDogJ2EgdCA9XG4gICAgICAgIHsgc3VtbWFyeTsgcmVhZG1lOyBzdWJjb21tYW5kcyA9IExhenkuZm9yY2Ugc3ViY29tbWFuZHMgfVxuICAgICAgOztcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIEV4ZWNfaW5mbyA9IHN0cnVjdFxuICAgIGxldCBhYnNfcGF0aCB+ZGlyIHBhdGggPVxuICAgICAgaWYgRmlsZW5hbWVfYmFzZS5pc19hYnNvbHV0ZSBwYXRoIHRoZW4gcGF0aCBlbHNlIEZpbGVuYW1lX2Jhc2UuY29uY2F0IGRpciBwYXRoXG4gICAgOztcblxuICAgIG1vZHVsZSBWMyA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAgeyBzdW1tYXJ5IDogc3RyaW5nXG4gICAgICAgIDsgcmVhZG1lIDogc3RyaW5nIG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICAgICAgICA7IHdvcmtpbmdfZGlyIDogc3RyaW5nXG4gICAgICAgIDsgcGF0aF90b19leGUgOiBzdHJpbmdcbiAgICAgICAgOyBjaGlsZF9zdWJjb21tYW5kIDogc3RyaW5nIGxpc3RcbiAgICAgICAgfVxuICAgICAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cCwgc3RhYmxlX3dpdG5lc3NdXG5cbiAgICAgIGxldCB0b19sYXRlc3QgPSBCYXNlLkZuLmlkXG4gICAgICBsZXQgb2ZfbGF0ZXN0ID0gQmFzZS5Gbi5pZFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIE1vZGVsID0gVjNcblxuICAgIG1vZHVsZSBWMiA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAgeyBzdW1tYXJ5IDogc3RyaW5nXG4gICAgICAgIDsgcmVhZG1lIDogc3RyaW5nIG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICAgICAgICA7IHdvcmtpbmdfZGlyIDogc3RyaW5nXG4gICAgICAgIDsgcGF0aF90b19leGUgOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgW0BAZGVyaXZpbmcgc2V4cCwgc3RhYmxlX3dpdG5lc3NdXG5cbiAgICAgIGxldCB0b192MyB0IDogVjMudCA9XG4gICAgICAgIHsgc3VtbWFyeSA9IHQuc3VtbWFyeVxuICAgICAgICA7IHJlYWRtZSA9IHQucmVhZG1lXG4gICAgICAgIDsgd29ya2luZ19kaXIgPSB0LndvcmtpbmdfZGlyXG4gICAgICAgIDsgcGF0aF90b19leGUgPSB0LnBhdGhfdG9fZXhlXG4gICAgICAgIDsgY2hpbGRfc3ViY29tbWFuZCA9IFtdXG4gICAgICAgIH1cbiAgICAgIDs7XG5cbiAgICAgIGxldCBvZl92MyAodCA6IFYzLnQpID1cbiAgICAgICAgeyBzdW1tYXJ5ID0gdC5zdW1tYXJ5XG4gICAgICAgIDsgcmVhZG1lID0gdC5yZWFkbWVcbiAgICAgICAgOyB3b3JraW5nX2RpciA9IHQud29ya2luZ19kaXJcbiAgICAgICAgOyBwYXRoX3RvX2V4ZSA9IGFic19wYXRoIH5kaXI6dC53b3JraW5nX2RpciB0LnBhdGhfdG9fZXhlXG4gICAgICAgIH1cbiAgICAgIDs7XG5cbiAgICAgIGxldCB0b19sYXRlc3QgPSBCYXNlLkZuLmNvbXBvc2UgVjMudG9fbGF0ZXN0IHRvX3YzXG4gICAgICBsZXQgb2ZfbGF0ZXN0ID0gQmFzZS5Gbi5jb21wb3NlIG9mX3YzIFYzLm9mX2xhdGVzdFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIFYxID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICB7IHN1bW1hcnkgOiBzdHJpbmdcbiAgICAgICAgOyByZWFkbWUgOiBzdHJpbmcgb3B0aW9uIFtAc2V4cC5vcHRpb25dXG4gICAgICAgIDsgKCogW3BhdGhfdG9fZXhlXSBtdXN0IGJlIGFic29sdXRlLiAqKVxuICAgICAgICAgIHBhdGhfdG9fZXhlIDogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIFtAQGRlcml2aW5nIHNleHAsIHN0YWJsZV93aXRuZXNzXVxuXG4gICAgICBsZXQgdG9fdjIgdCA6IFYyLnQgPVxuICAgICAgICB7IHN1bW1hcnkgPSB0LnN1bW1hcnlcbiAgICAgICAgOyByZWFkbWUgPSB0LnJlYWRtZVxuICAgICAgICA7IHdvcmtpbmdfZGlyID0gXCIvXCJcbiAgICAgICAgOyBwYXRoX3RvX2V4ZSA9IHQucGF0aF90b19leGVcbiAgICAgICAgfVxuICAgICAgOztcblxuICAgICAgbGV0IG9mX3YyICh0IDogVjIudCkgPVxuICAgICAgICB7IHN1bW1hcnkgPSB0LnN1bW1hcnlcbiAgICAgICAgOyByZWFkbWUgPSB0LnJlYWRtZVxuICAgICAgICA7IHBhdGhfdG9fZXhlID0gYWJzX3BhdGggfmRpcjp0LndvcmtpbmdfZGlyIHQucGF0aF90b19leGVcbiAgICAgICAgfVxuICAgICAgOztcblxuICAgICAgbGV0IHRvX2xhdGVzdCA9IEJhc2UuRm4uY29tcG9zZSBWMi50b19sYXRlc3QgdG9fdjJcbiAgICAgIGxldCBvZl9sYXRlc3QgPSBCYXNlLkZuLmNvbXBvc2Ugb2ZfdjIgVjIub2ZfbGF0ZXN0XG4gICAgZW5kXG4gIGVuZFxuXG4gIG1vZHVsZSBGdWxseV9mb3JjZWQgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVjEgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9XG4gICAgICAgIHwgQmFzaWMgb2YgQmFzZV9pbmZvLlYyLnRcbiAgICAgICAgfCBHcm91cCBvZiB0IEdyb3VwX2luZm8uVjIudFxuICAgICAgICB8IEV4ZWMgb2YgRXhlY19pbmZvLlYzLnQgKiB0XG4gICAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwLCBzdGFibGVfd2l0bmVzc11cbiAgICBlbmRcblxuICAgIG1vZHVsZSBNb2RlbCA9IFYxXG4gIGVuZFxuXG4gIG1vZHVsZSBTZXhwYWJsZSA9IHN0cnVjdFxuICAgIG1vZHVsZSBWMyA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAgfCBCYXNlIG9mIEJhc2VfaW5mby5WMi50XG4gICAgICAgIHwgR3JvdXAgb2YgdCBHcm91cF9pbmZvLlYyLnRcbiAgICAgICAgfCBFeGVjIG9mIEV4ZWNfaW5mby5WMy50XG4gICAgICAgIHwgTGF6eSBvZiB0IExhenkudFxuICAgICAgW0BAZGVyaXZpbmcgc2V4cCwgc3RhYmxlX3dpdG5lc3NdXG5cbiAgICAgIGxldCB0b19sYXRlc3QgPSBCYXNlLkZuLmlkXG4gICAgICBsZXQgb2ZfbGF0ZXN0ID0gQmFzZS5Gbi5pZFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIE1vZGVsID0gVjNcblxuICAgIG1vZHVsZSBWMiA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAgfCBCYXNlIG9mIEJhc2VfaW5mby5WMi50XG4gICAgICAgIHwgR3JvdXAgb2YgdCBHcm91cF9pbmZvLlYxLnRcbiAgICAgICAgfCBFeGVjIG9mIEV4ZWNfaW5mby5WMi50XG4gICAgICBbQEBkZXJpdmluZyBzZXhwLCBzdGFibGVfd2l0bmVzc11cblxuICAgICAgbGV0IHJlYyB0b19sYXRlc3QgOiB0IC0+IE1vZGVsLnQgPSBmdW5jdGlvblxuICAgICAgICB8IEJhc2UgYiAtPiBCYXNlIGJcbiAgICAgICAgfCBFeGVjIGUgLT4gRXhlYyAoRXhlY19pbmZvLlYyLnRvX2xhdGVzdCBlKVxuICAgICAgICB8IEdyb3VwIGcgLT4gR3JvdXAgKEdyb3VwX2luZm8uVjEudG9fbGF0ZXN0IChHcm91cF9pbmZvLlYxLm1hcCBnIH5mOnRvX2xhdGVzdCkpXG4gICAgICA7O1xuXG4gICAgICBsZXQgcmVjIG9mX2xhdGVzdCA6IE1vZGVsLnQgLT4gdCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgQmFzZSBiIC0+IEJhc2UgYlxuICAgICAgICB8IEV4ZWMgZSAtPiBFeGVjIChFeGVjX2luZm8uVjIub2ZfbGF0ZXN0IGUpXG4gICAgICAgIHwgTGF6eSB0aHVuayAtPiBvZl9sYXRlc3QgKEJhc2UuTGF6eS5mb3JjZSB0aHVuaylcbiAgICAgICAgfCBHcm91cCBnIC0+IEdyb3VwIChHcm91cF9pbmZvLlYxLm1hcCAoR3JvdXBfaW5mby5WMS5vZl9sYXRlc3QgZykgfmY6b2ZfbGF0ZXN0KVxuICAgICAgOztcbiAgICBlbmRcblxuICAgIG1vZHVsZSBWMSA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAgfCBCYXNlIG9mIEJhc2VfaW5mby5WMS50XG4gICAgICAgIHwgR3JvdXAgb2YgdCBHcm91cF9pbmZvLlYxLnRcbiAgICAgICAgfCBFeGVjIG9mIEV4ZWNfaW5mby5WMS50XG4gICAgICBbQEBkZXJpdmluZyBzZXhwLCBzdGFibGVfd2l0bmVzc11cblxuICAgICAgbGV0IHJlYyB0b19sYXRlc3QgOiB0IC0+IE1vZGVsLnQgPSBmdW5jdGlvblxuICAgICAgICB8IEJhc2UgYiAtPiBCYXNlIChCYXNlX2luZm8uVjEudG9fbGF0ZXN0IGIpXG4gICAgICAgIHwgRXhlYyBlIC0+IEV4ZWMgKEV4ZWNfaW5mby5WMS50b19sYXRlc3QgZSlcbiAgICAgICAgfCBHcm91cCBnIC0+IEdyb3VwIChHcm91cF9pbmZvLlYxLnRvX2xhdGVzdCAoR3JvdXBfaW5mby5WMS5tYXAgZyB+Zjp0b19sYXRlc3QpKVxuICAgICAgOztcblxuICAgICAgbGV0IHJlYyBvZl9sYXRlc3QgOiBNb2RlbC50IC0+IHQgPSBmdW5jdGlvblxuICAgICAgICB8IEJhc2UgYiAtPiBCYXNlIChCYXNlX2luZm8uVjEub2ZfbGF0ZXN0IGIpXG4gICAgICAgIHwgRXhlYyBlIC0+IEV4ZWMgKEV4ZWNfaW5mby5WMS5vZl9sYXRlc3QgZSlcbiAgICAgICAgfCBMYXp5IHRodW5rIC0+IG9mX2xhdGVzdCAoQmFzZS5MYXp5LmZvcmNlIHRodW5rKVxuICAgICAgICB8IEdyb3VwIGcgLT4gR3JvdXAgKEdyb3VwX2luZm8uVjEubWFwIChHcm91cF9pbmZvLlYxLm9mX2xhdGVzdCBnKSB+ZjpvZl9sYXRlc3QpXG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbW9kdWxlIFZlcnNpb25lZCA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAgfCBWMSBvZiBWMS50XG4gICAgICAgIHwgVjIgb2YgVjIudFxuICAgICAgICB8IFYzIG9mIFYzLnQgKCogYXZhaWxhYmxlIGF0IGxlYXN0IHNpbmNlIDIwMjAtMDQgKilcbiAgICAgIFtAQGRlcml2aW5nIHNleHAsIHZhcmlhbnRzLCBzdGFibGVfd2l0bmVzc11cblxuICAgICAgbGV0IHRvX2xhdGVzdCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgVjEgdCAtPiBWMS50b19sYXRlc3QgdFxuICAgICAgICB8IFYyIHQgLT4gVjIudG9fbGF0ZXN0IHRcbiAgICAgICAgfCBWMyB0IC0+IFYzLnRvX2xhdGVzdCB0XG4gICAgICA7O1xuXG4gICAgICBsZXQgb2ZfbGF0ZXN0IH52ZXJzaW9uX3RvX3VzZSBsYXRlc3QgPVxuICAgICAgICBtYXRjaCB2ZXJzaW9uX3RvX3VzZSB3aXRoXG4gICAgICAgIHwgMSAtPiBWMSAoVjEub2ZfbGF0ZXN0IGxhdGVzdClcbiAgICAgICAgfCAyIC0+IFYyIChWMi5vZl9sYXRlc3QgbGF0ZXN0KVxuICAgICAgICB8IDMgLT4gVjMgKFYzLm9mX2xhdGVzdCBsYXRlc3QpXG4gICAgICAgIHwgb3RoZXIgLT5cbiAgICAgICAgICBCYXNlLkVycm9yLmNyZWF0ZVxuICAgICAgICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgICAgICAgXCJ1bnN1cHBvcnRlZCB2ZXJzaW9uX3RvX3VzZVwiXG4gICAgICAgICAgICBvdGhlclxuICAgICAgICAgICAgWyVzZXhwX29mOiBpbnRdXG4gICAgICAgICAgfD4gQmFzZS5FcnJvci5yYWlzZVxuICAgICAgOztcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxub3BlbiEgQmFzZVxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBBbm9ucyA9IHN0cnVjdFxuICBtb2R1bGUgR3JhbW1hciA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFN0YWJsZS5Bbm9ucy5HcmFtbWFyLk1vZGVsLnQgPVxuICAgICAgfCBaZXJvXG4gICAgICB8IE9uZSBvZiBzdHJpbmdcbiAgICAgIHwgTWFueSBvZiB0XG4gICAgICB8IE1heWJlIG9mIHRcbiAgICAgIHwgQ29uY2F0IG9mIHQgbGlzdFxuICAgICAgfCBBZF9ob2Mgb2Ygc3RyaW5nXG4gICAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICAgIGxldCBpbnZhcmlhbnQgPSBTdGFibGUuQW5vbnMuR3JhbW1hci5Nb2RlbC5pbnZhcmlhbnRcbiAgICBsZXQgdXNhZ2UgPSBTdGFibGUuQW5vbnMuR3JhbW1hci5Nb2RlbC51c2FnZVxuICBlbmRcblxuICB0eXBlIHQgPSBTdGFibGUuQW5vbnMuTW9kZWwudCA9XG4gICAgfCBVc2FnZSBvZiBzdHJpbmdcbiAgICB8IEdyYW1tYXIgb2YgR3JhbW1hci50XG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5lbmRcblxubW9kdWxlIE51bV9vY2N1cnJlbmNlcyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgYXRfbGVhc3Rfb25jZSA6IGJvb2xcbiAgICA7IGF0X21vc3Rfb25jZSA6IGJvb2xcbiAgICB9XG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIGVudW1lcmF0ZSwgc2V4cF9vZl1cblxuICBsZXQgbWF5YmVfbWlzc2luZ19wcmVmaXggPSBcIltcIlxuICBsZXQgbWF5YmVfbWlzc2luZ19zdWZmaXggPSBcIl1cIlxuICBsZXQgbWF5YmVfbW9yZV9zdWZmaXggPSBcIiAuLi5cIlxuXG4gIGxldCB0b19oZWxwX3N0cmluZyB0IH5mbGFnX25hbWUgPVxuICAgIGxldCB7IGF0X2xlYXN0X29uY2U7IGF0X21vc3Rfb25jZSB9ID0gdCBpblxuICAgIGxldCBkZXNjcmlwdGlvbiA9XG4gICAgICBpZiBhdF9sZWFzdF9vbmNlXG4gICAgICB0aGVuIGZsYWdfbmFtZVxuICAgICAgZWxzZSBTdHJpbmcuY29uY2F0IFsgbWF5YmVfbWlzc2luZ19wcmVmaXg7IGZsYWdfbmFtZTsgbWF5YmVfbWlzc2luZ19zdWZmaXggXVxuICAgIGluXG4gICAgaWYgYXRfbW9zdF9vbmNlIHRoZW4gZGVzY3JpcHRpb24gZWxzZSBTdHJpbmcuY29uY2F0IFsgZGVzY3JpcHRpb247IG1heWJlX21vcmVfc3VmZml4IF1cbiAgOztcblxuICBsZXQgb2ZfaGVscF9zdHJpbmcgbmFtZSA9XG4gICAgbGV0IGF0X21vc3Rfb25jZSwgbmFtZSA9XG4gICAgICBtYXRjaCBTdHJpbmcuY2hvcF9zdWZmaXggbmFtZSB+c3VmZml4Om1heWJlX21vcmVfc3VmZml4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0cnVlLCBuYW1lXG4gICAgICB8IFNvbWUgbmFtZSAtPiBmYWxzZSwgbmFtZVxuICAgIGluXG4gICAgbGV0IGF0X2xlYXN0X29uY2UsIG5hbWUgPVxuICAgICAgbWF0Y2hcbiAgICAgICAgU3RyaW5nLmNob3BfcHJlZml4IG5hbWUgfnByZWZpeDptYXliZV9taXNzaW5nX3ByZWZpeFxuICAgICAgICB8PiBPcHRpb24uYmluZCB+ZjooU3RyaW5nLmNob3Bfc3VmZml4IH5zdWZmaXg6bWF5YmVfbWlzc2luZ19zdWZmaXgpXG4gICAgICB3aXRoXG4gICAgICB8IE5vbmUgLT4gdHJ1ZSwgbmFtZVxuICAgICAgfCBTb21lIG5hbWUgLT4gZmFsc2UsIG5hbWVcbiAgICBpblxuICAgIHsgYXRfbGVhc3Rfb25jZTsgYXRfbW9zdF9vbmNlIH0sIG5hbWVcbiAgOztcblxuICBsZXQlZXhwZWN0X3Rlc3QgXCJ0b19oZWxwX3N0cmluZ1wiID1cbiAgICBsZXQgZmxhZ19uYW1lID0gXCJuYW1lXCIgaW5cbiAgICBMaXN0Lml0ZXIgWyVhbGw6IHRdIH5mOihmdW4gdCAtPlxuICAgICAgbGV0IHMgPSB0b19oZWxwX3N0cmluZyB0IH5mbGFnX25hbWUgaW5cbiAgICAgIHByaW50X3MgWyVtZXNzYWdlIFwiXCIgfl86KHQgOiB0KSBzXTtcbiAgICAgIGxldCB0JywgZmxhZ19uYW1lJyA9IG9mX2hlbHBfc3RyaW5nIHMgaW5cbiAgICAgIGFzc2VydCAoWyVjb21wYXJlLmVxdWFsOiB0XSB0IHQnKTtcbiAgICAgIGFzc2VydCAoWyVjb21wYXJlLmVxdWFsOiBzdHJpbmddIGZsYWdfbmFtZSBmbGFnX25hbWUnKSk7XG4gICAgWyVleHBlY3RcbiAgICAgIHt8XG4gICAgICAoKChhdF9sZWFzdF9vbmNlIGZhbHNlKSAoYXRfbW9zdF9vbmNlIGZhbHNlKSkgXCJbbmFtZV0gLi4uXCIpXG4gICAgICAoKChhdF9sZWFzdF9vbmNlIHRydWUpIChhdF9tb3N0X29uY2UgZmFsc2UpKSBcIm5hbWUgLi4uXCIpXG4gICAgICAoKChhdF9sZWFzdF9vbmNlIGZhbHNlKSAoYXRfbW9zdF9vbmNlIHRydWUpKSBbbmFtZV0pXG4gICAgICAoKChhdF9sZWFzdF9vbmNlIHRydWUpIChhdF9tb3N0X29uY2UgdHJ1ZSkpIG5hbWUpXG4gICAgICB8fV1cbiAgOztcbmVuZFxuXG5tb2R1bGUgRmxhZ19pbmZvID0gc3RydWN0XG4gIHR5cGUgdCA9IFN0YWJsZS5GbGFnX2luZm8uTW9kZWwudCA9XG4gICAgeyBuYW1lIDogc3RyaW5nXG4gICAgOyBkb2MgOiBzdHJpbmdcbiAgICA7IGFsaWFzZXMgOiBzdHJpbmcgbGlzdFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgZmllbGRzIH5nZXR0ZXJzLCBzZXhwXVxuXG4gIGxldCBwYXJzZV9uYW1lIHQgPVxuICAgIGxldCBudW1fb2NjdXJyZW5jZXMsIGZsYWdfbmFtZSA9IE51bV9vY2N1cnJlbmNlcy5vZl9oZWxwX3N0cmluZyB0Lm5hbWUgaW5cbiAgICBtYXRjaCBTdHJpbmcuc3BsaXQgZmxhZ19uYW1lIH5vbjonICcgd2l0aFxuICAgIHwgWyBmbGFnX25hbWUgXSAtPiBPayAobnVtX29jY3VycmVuY2VzLCBmYWxzZSwgZmxhZ19uYW1lKVxuICAgIHwgWyBmbGFnX25hbWU7IF9hcmdfZG9jIF0gLT4gT2sgKG51bV9vY2N1cnJlbmNlcywgdHJ1ZSwgZmxhZ19uYW1lKVxuICAgIHwgXyAtPiBFcnJvciAoRXJyb3IuY3JlYXRlX3MgWyVtZXNzYWdlIFwiVW5hYmxlIHRvIHBhcnNlXCIgZmxhZ19uYW1lXSlcbiAgOztcblxuICAoKiBVc2VycyBhcmUgbGlrZWx5IHRvIGNhbGwgYWxsIHRocmVlIG9mIHRoZXNlIGZ1bmN0aW9ucywgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIHJlLXBhcnNlXG4gICAgIHRoZSBbbmFtZV0gc2V2ZXJhbCB0aW1lcy4gV2UgZG9uJ3QgZXhwZWN0IHVzZXJzIG9mIHRoZXNlIGZ1bmN0aW9ucyB0byBjYXJlIGFib3V0IHRoZVxuICAgICBpbmVmZmljaWVuY3kuICopXG4gIGxldCBmbGFnX25hbWUgdCA9XG4gICAgcGFyc2VfbmFtZSB0XG4gICAgfD4gT3JfZXJyb3IubWFwIH5mOihmdW4gKChfIDogTnVtX29jY3VycmVuY2VzLnQpLCAoXyA6IGJvb2wpLCBmbGFnX25hbWUpIC0+IGZsYWdfbmFtZSlcbiAgOztcblxuICBsZXQgbnVtX29jY3VycmVuY2VzIHQgPVxuICAgIHBhcnNlX25hbWUgdFxuICAgIHw+IE9yX2Vycm9yLm1hcCB+ZjooZnVuIChudW1fb2NjdXJyZW5jZXMsIChfIDogYm9vbCksIChfIDogc3RyaW5nKSkgLT5cbiAgICAgICAgIG51bV9vY2N1cnJlbmNlcylcbiAgOztcblxuICBsZXQgcmVxdWlyZXNfYXJnIHQgPVxuICAgIHBhcnNlX25hbWUgdFxuICAgIHw+IE9yX2Vycm9yLm1hcCB+ZjooZnVuICgoXyA6IE51bV9vY2N1cnJlbmNlcy50KSwgcmVxdWlyZXNfYXJnLCAoXyA6IHN0cmluZykpIC0+XG4gICAgICAgICByZXF1aXJlc19hcmcpXG4gIDs7XG5cbiAgbGV0IGhlbHBfc2NyZWVuX2NvbXBhcmUgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IF8sIFwiWy1oZWxwXVwiIC0+IC0xXG4gICAgfCBcIlstaGVscF1cIiwgXyAtPiAxXG4gICAgfCBfLCBcIlstdmVyc2lvbl1cIiAtPiAtMVxuICAgIHwgXCJbLXZlcnNpb25dXCIsIF8gLT4gMVxuICAgIHwgXywgXCJbLWJ1aWxkLWluZm9dXCIgLT4gLTFcbiAgICB8IFwiWy1idWlsZC1pbmZvXVwiLCBfIC0+IDFcbiAgICB8IF8sIFwiaGVscFwiIC0+IC0xXG4gICAgfCBcImhlbHBcIiwgXyAtPiAxXG4gICAgfCBfLCBcInZlcnNpb25cIiAtPiAtMVxuICAgIHwgXCJ2ZXJzaW9uXCIsIF8gLT4gMVxuICAgIHwgXyAtPiAwXG4gIDs7XG5lbmRcblxubW9kdWxlIEZsYWdfaGVscF9kaXNwbGF5ID0gc3RydWN0XG4gIHR5cGUgdCA9IEZsYWdfaW5mby50IGxpc3RcblxuICBsZXQgc29ydCB0ID1cbiAgICBMaXN0LnN0YWJsZV9zb3J0IHQgfmNvbXBhcmU6KGZ1biBhIGIgLT5cbiAgICAgIEZsYWdfaW5mby5oZWxwX3NjcmVlbl9jb21wYXJlIGEuRmxhZ19pbmZvLm5hbWUgYi5GbGFnX2luZm8ubmFtZSlcbiAgOztcblxuICBsZXQgd29yZF93cmFwX2FuZF9zdHJpcCB0ZXh0IHdpZHRoID1cbiAgICBsZXQgY2h1bmtzID0gU3RyaW5nLnNwbGl0IHRleHQgfm9uOidcXG4nIGluXG4gICAgTGlzdC5jb25jYXRfbWFwIGNodW5rcyB+ZjooZnVuIHRleHQgLT5cbiAgICAgIGxldCB3b3JkcyA9XG4gICAgICAgIFN0cmluZy5zcGxpdCB0ZXh0IH5vbjonICdcbiAgICAgICAgfD4gTGlzdC5maWx0ZXIgfmY6KGZ1biB3b3JkIC0+IG5vdCAoU3RyaW5nLmlzX2VtcHR5IHdvcmQpKVxuICAgICAgaW5cbiAgICAgIG1hdGNoXG4gICAgICAgIExpc3QuZm9sZCB3b3JkcyB+aW5pdDpOb25lIH5mOihmdW4gYWNjIHdvcmQgLT5cbiAgICAgICAgICBTb21lXG4gICAgICAgICAgICAobWF0Y2ggYWNjIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gW10sIHdvcmRcbiAgICAgICAgICAgICB8IFNvbWUgKGxpbmVzLCBsaW5lKSAtPlxuICAgICAgICAgICAgICAgKCogZWZmaWNpZW5jeSBpcyBub3QgYSBjb25jZXJuIGZvciB0aGUgc3RyaW5nIGxlbmd0aHMgd2UgZXhwZWN0ICopXG4gICAgICAgICAgICAgICBsZXQgbGluZV9hbmRfd29yZCA9IGxpbmUgXiBcIiBcIiBeIHdvcmQgaW5cbiAgICAgICAgICAgICAgIGlmIFN0cmluZy5sZW5ndGggbGluZV9hbmRfd29yZCA8PSB3aWR0aFxuICAgICAgICAgICAgICAgdGhlbiBsaW5lcywgbGluZV9hbmRfd29yZFxuICAgICAgICAgICAgICAgZWxzZSBsaW5lIDo6IGxpbmVzLCB3b3JkKSlcbiAgICAgIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBbXVxuICAgICAgfCBTb21lIChsaW5lcywgbGluZSkgLT4gTGlzdC5yZXYgKGxpbmUgOjogbGluZXMpKVxuICA7O1xuXG4gIG1vZHVsZSBEaXNwbGF5IDogc2lnXG4gICAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG4gIGVuZCA9IHN0cnVjdFxuICAgIGxldCBudW1fY29scyA9IDgwXG4gICAgbGV0IHNwYWNlc19zdHJpbmcgd2lkdGggPSBTdHJpbmcubWFrZSB3aWR0aCAnICdcblxuICAgIGxldCBwYWRfc3BhY2VzX3RvX3N1ZmZpeCB4IH53aWR0aCA9XG4gICAgICBsZXQgc2xhY2sgPSB3aWR0aCAtIFN0cmluZy5sZW5ndGggeCBpblxuICAgICAgeCBeIHNwYWNlc19zdHJpbmcgc2xhY2tcbiAgICA7O1xuXG4gICAgbGV0IGluZGVudGF0aW9uID0gXCIgIFwiXG4gICAgbGV0IGluZGVudF9hbmRfbmV3bGluZSB4ID0gTGlzdC5jb25jYXQgWyBbIGluZGVudGF0aW9uIF07IHg7IFsgXCJcXG5cIiBdIF1cbiAgICBsZXQgc3BhY2luZ19kb3QgPSBcIi4gXCJcbiAgICBsZXQgZG90X2luZGVudGF0aW9uX29mZnNldCA9IDI3XG4gICAgbGV0IGRvY3VtZW50YXRpb25fc3RhcnRfY29sdW1uID0gZG90X2luZGVudGF0aW9uX29mZnNldCArIFN0cmluZy5sZW5ndGggaW5kZW50YXRpb25cbiAgICBsZXQgbGhzX3dpZHRoID0gZG9jdW1lbnRhdGlvbl9zdGFydF9jb2x1bW5cbiAgICBsZXQgbGhzX3BhZF93aWR0aCA9IGRvdF9pbmRlbnRhdGlvbl9vZmZzZXQgKyBTdHJpbmcubGVuZ3RoIGluZGVudGF0aW9uXG4gICAgbGV0IGxoc19wYWQgPSBzcGFjZXNfc3RyaW5nIGxoc19wYWRfd2lkdGhcblxuICAgIGxldCBsaHNfcGFkX2FuZF9uZXdsaW5lX3Rlcm1pbmF0ZSA9XG4gICAgICBMaXN0Lm1hcCB+ZjooZnVuIHYgLT4gaW5kZW50X2FuZF9uZXdsaW5lIFsgbGhzX3BhZDsgdiBdKVxuICAgIDs7XG5cbiAgICBsZXQgcm93cyBmbGFnX25hbWVfd2l0aF9hbGlhc2VzIGRvY3VtZW50YXRpb24gPVxuICAgICAgbGV0IGZsYWdfb25faXRzX293bl9saW5lID1cbiAgICAgICAgbGV0IGZsYWdfd2lkdGggPVxuICAgICAgICAgIFN0cmluZy5sZW5ndGggaW5kZW50YXRpb24gKyBTdHJpbmcubGVuZ3RoIGZsYWdfbmFtZV93aXRoX2FsaWFzZXNcbiAgICAgICAgaW5cbiAgICAgICAgaWYgZmxhZ193aWR0aCA+PSBkb3RfaW5kZW50YXRpb25fb2Zmc2V0ICsgU3RyaW5nLmxlbmd0aCBzcGFjaW5nX2RvdFxuICAgICAgICB0aGVuIGluZGVudF9hbmRfbmV3bGluZSBbIGZsYWdfbmFtZV93aXRoX2FsaWFzZXMgXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgaW5kZW50X2FuZF9uZXdsaW5lXG4gICAgICAgICAgICBbIHBhZF9zcGFjZXNfdG9fc3VmZml4IH53aWR0aDpkb3RfaW5kZW50YXRpb25fb2Zmc2V0IGZsYWdfbmFtZV93aXRoX2FsaWFzZXNcbiAgICAgICAgICAgIDsgc3BhY2luZ19kb3RcbiAgICAgICAgICAgIF1cbiAgICAgIGluXG4gICAgICBsZXQgd3JhcHBlZF9kb2N1bWVudGF0aW9uID1cbiAgICAgICAgd29yZF93cmFwX2FuZF9zdHJpcFxuICAgICAgICAgIGRvY3VtZW50YXRpb25cbiAgICAgICAgICAobnVtX2NvbHMgLSBsaHNfd2lkdGggLSBTdHJpbmcubGVuZ3RoIGluZGVudGF0aW9uKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIHdyYXBwZWRfZG9jdW1lbnRhdGlvbiB3aXRoXG4gICAgICB8IFtdIC0+IFsgZmxhZ19vbl9pdHNfb3duX2xpbmUgXVxuICAgICAgfCBkb2Nfd3JhcHBlZF9maXJzdF9saW5lIDo6IGRvY193cmFwcGVkX3Jlc3RfbGluZXMgLT5cbiAgICAgICAgbGV0IHdyYXBwZWRfZG9jX2xpbmVzID0gbGhzX3BhZF9hbmRfbmV3bGluZV90ZXJtaW5hdGUgZG9jX3dyYXBwZWRfcmVzdF9saW5lcyBpblxuICAgICAgICBsZXQgcHJlZml4X2RvY193cmFwcGVkX2ZpcnN0X2xpbmVfd2l0aCB4ID1cbiAgICAgICAgICBpbmRlbnRfYW5kX25ld2xpbmVcbiAgICAgICAgICAgIFsgcGFkX3NwYWNlc190b19zdWZmaXggfndpZHRoOmRvdF9pbmRlbnRhdGlvbl9vZmZzZXQgeFxuICAgICAgICAgICAgOyBzcGFjaW5nX2RvdFxuICAgICAgICAgICAgOyBkb2Nfd3JhcHBlZF9maXJzdF9saW5lXG4gICAgICAgICAgICBdXG4gICAgICAgIGluXG4gICAgICAgIGlmIFN0cmluZy5sZW5ndGggZmxhZ19uYW1lX3dpdGhfYWxpYXNlcyA+PSBkb3RfaW5kZW50YXRpb25fb2Zmc2V0XG4gICAgICAgIHRoZW5cbiAgICAgICAgICBmbGFnX29uX2l0c19vd25fbGluZVxuICAgICAgICAgIDo6IHByZWZpeF9kb2Nfd3JhcHBlZF9maXJzdF9saW5lX3dpdGggXCJcIlxuICAgICAgICAgIDo6IHdyYXBwZWRfZG9jX2xpbmVzXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwcmVmaXhfZG9jX3dyYXBwZWRfZmlyc3RfbGluZV93aXRoIGZsYWdfbmFtZV93aXRoX2FsaWFzZXMgOjogd3JhcHBlZF9kb2NfbGluZXNcbiAgICA7O1xuXG4gICAgbGV0IHRvX3N0cmluZyB0ID1cbiAgICAgIExpc3QuY29uY2F0X21hcCB0IH5mOihmdW4gdCAtPlxuICAgICAgICBsZXQgZmxhZ19uYW1lX3dpdGhfYWxpYXNlcyA9XG4gICAgICAgICAgbGV0IGZsYWcgPSB0LkZsYWdfaW5mby5uYW1lIGluXG4gICAgICAgICAgU3RyaW5nLmNvbmNhdCB+c2VwOlwiLCBcIiAoZmxhZyA6OiB0LmFsaWFzZXMpXG4gICAgICAgIGluXG4gICAgICAgIHJvd3MgZmxhZ19uYW1lX3dpdGhfYWxpYXNlcyB0LmRvYyB8PiBMaXN0LmNvbmNhdClcbiAgICAgIHw+IFN0cmluZy5jb25jYXRcbiAgICA7O1xuICBlbmRcblxuICBsZXQgdG9fc3RyaW5nIHQgPSBEaXNwbGF5LnRvX3N0cmluZyB0XG5lbmRcblxubW9kdWxlIEtleV90eXBlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBTdWJjb21tYW5kXG4gICAgfCBGbGFnXG5cbiAgbGV0IHRvX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBTdWJjb21tYW5kIC0+IFwic3ViY29tbWFuZFwiXG4gICAgfCBGbGFnIC0+IFwiZmxhZ1wiXG4gIDs7XG5lbmRcblxubGV0IGxvb2t1cF9leHBhbmQgYWxpc3QgcHJlZml4IGtleV90eXBlID1cbiAgbGV0IGlzX2Rhc2ggPSBDaGFyLmVxdWFsICctJyBpblxuICBsZXQgYWxpc3QgPVxuICAgICgqIG5vIHBhcnRpYWwgbWF0Y2hlcyB1bmxlc3Mgc29tZSBub24tZGFzaCBjaGFyIGlzIHByZXNlbnQgKilcbiAgICBpZiBTdHJpbmcuZm9yX2FsbCBwcmVmaXggfmY6aXNfZGFzaFxuICAgIHRoZW4gTGlzdC5tYXAgYWxpc3QgfmY6KGZ1biAoa2V5LCAoZGF0YSwgXykpIC0+IGtleSwgKGRhdGEsIGBGdWxsX21hdGNoX3JlcXVpcmVkKSlcbiAgICBlbHNlIGFsaXN0XG4gIGluXG4gIG1hdGNoXG4gICAgTGlzdC5maWx0ZXIgYWxpc3QgfmY6KGZ1bmN0aW9uXG4gICAgICB8IGtleSwgKF8sIGBGdWxsX21hdGNoX3JlcXVpcmVkKSAtPiBTdHJpbmcuKCA9ICkga2V5IHByZWZpeFxuICAgICAgfCBrZXksIChfLCBgUHJlZml4KSAtPiBTdHJpbmcuaXNfcHJlZml4IGtleSB+cHJlZml4KVxuICB3aXRoXG4gIHwgWyAoa2V5LCAoZGF0YSwgX25hbWVfbWF0Y2hpbmcpKSBdIC0+IE9rIChrZXksIGRhdGEpXG4gIHwgW10gLT4gRXJyb3IgKHNwcmludGYgIVwidW5rbm93biAle0tleV90eXBlfSAlc1wiIGtleV90eXBlIHByZWZpeClcbiAgfCBtYXRjaGVzIC0+XG4gICAgKG1hdGNoIExpc3QuZmluZCBtYXRjaGVzIH5mOihmdW4gKGtleSwgXykgLT4gU3RyaW5nLiggPSApIGtleSBwcmVmaXgpIHdpdGhcbiAgICAgfCBTb21lIChrZXksIChkYXRhLCBfbmFtZV9tYXRjaGluZykpIC0+IE9rIChrZXksIGRhdGEpXG4gICAgIHwgTm9uZSAtPlxuICAgICAgIGxldCBtYXRjaGluZ19rZXlzID0gTGlzdC5tYXAgfmY6ZnN0IG1hdGNoZXMgaW5cbiAgICAgICBFcnJvclxuICAgICAgICAgKHNwcmludGZcbiAgICAgICAgICAgICFcIiV7S2V5X3R5cGV9ICVzIGlzIGFuIGFtYmlndW91cyBwcmVmaXg6ICVzXCJcbiAgICAgICAgICAgIGtleV90eXBlXG4gICAgICAgICAgICBwcmVmaXhcbiAgICAgICAgICAgIChTdHJpbmcuY29uY2F0IH5zZXA6XCIsIFwiIG1hdGNoaW5nX2tleXMpKSlcbjs7XG5cbm1vZHVsZSBCYXNlX2luZm8gPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gU3RhYmxlLkJhc2VfaW5mby5Nb2RlbC50ID1cbiAgICB7IHN1bW1hcnkgOiBzdHJpbmdcbiAgICA7IHJlYWRtZSA6IHN0cmluZyBvcHRpb24gW0BzZXhwLm9wdGlvbl1cbiAgICA7IGFub25zIDogQW5vbnMudFxuICAgIDsgZmxhZ3MgOiBGbGFnX2luZm8udCBsaXN0XG4gICAgfVxuICBbQEBkZXJpdmluZyBjb21wYXJlLCBmaWVsZHMgfmdldHRlcnMsIHNleHBdXG5cbiAgbGV0IGZpbmRfZmxhZyB0IHByZWZpeCA9XG4gICAgbWF0Y2ggU3RyaW5nLmlzX3ByZWZpeCBwcmVmaXggfnByZWZpeDpcIi1cIiB3aXRoXG4gICAgfCBmYWxzZSAtPiBFcnJvciAoRXJyb3IuY3JlYXRlX3MgWyVtZXNzYWdlIFwiRmxhZ3MgbXVzdCBiZWdpbiB3aXRoICctJ1wiIHByZWZpeF0pXG4gICAgfCB0cnVlIC0+XG4gICAgICBsZXQlYmluZC5Pcl9lcnJvciBjaG9pY2VzID1cbiAgICAgICAgTGlzdC5tYXAgdC5mbGFncyB+ZjooZnVuIChmbGFnX2luZm8gOiBGbGFnX2luZm8udCkgLT5cbiAgICAgICAgICBsZXQlYmluZC5Pcl9lcnJvciBmbGFnX25hbWUgPSBGbGFnX2luZm8uZmxhZ19uYW1lIGZsYWdfaW5mbyBpblxuICAgICAgICAgIE9rXG4gICAgICAgICAgICAoTGlzdC5tYXAgKGZsYWdfbmFtZSA6OiBmbGFnX2luZm8uYWxpYXNlcykgfmY6KGZ1biBrZXkgLT5cbiAgICAgICAgICAgICAgIGtleSwgKGZsYWdfaW5mbywgYFByZWZpeCkpKSlcbiAgICAgICAgfD4gT3JfZXJyb3IuY29tYmluZV9lcnJvcnNcbiAgICAgIGluXG4gICAgICBsb29rdXBfZXhwYW5kIChMaXN0LmNvbmNhdCBjaG9pY2VzKSBwcmVmaXggRmxhZ1xuICAgICAgfD4gUmVzdWx0Lm1hcF9lcnJvciB+ZjpFcnJvci5vZl9zdHJpbmdcbiAgICAgIHw+IE9yX2Vycm9yLm1hcCB+ZjpzbmRcbiAgOztcblxuICBsZXQgZ2V0X3VzYWdlIHQgPVxuICAgIG1hdGNoIHQuYW5vbnMgd2l0aFxuICAgIHwgVXNhZ2UgdXNhZ2UgLT4gdXNhZ2VcbiAgICB8IEdyYW1tYXIgZ3JhbW1hciAtPiBBbm9ucy5HcmFtbWFyLnVzYWdlIGdyYW1tYXJcbiAgOztcbmVuZFxuXG5tb2R1bGUgR3JvdXBfaW5mbyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBTdGFibGUuR3JvdXBfaW5mby5Nb2RlbC50ID1cbiAgICB7IHN1bW1hcnkgOiBzdHJpbmdcbiAgICA7IHJlYWRtZSA6IHN0cmluZyBvcHRpb24gW0BzZXhwLm9wdGlvbl1cbiAgICA7IHN1YmNvbW1hbmRzIDogKHN0cmluZyAqICdhKSBMaXN0LnQgTGF6eS50XG4gICAgfVxuICBbQEBkZXJpdmluZyBjb21wYXJlLCBmaWVsZHMgfmdldHRlcnMsIHNleHBdXG5cbiAgbGV0IGZpbmRfc3ViY29tbWFuZCB0IHByZWZpeCA9XG4gICAgbWF0Y2ggU3RyaW5nLmlzX3ByZWZpeCBwcmVmaXggfnByZWZpeDpcIi1cIiB3aXRoXG4gICAgfCB0cnVlIC0+XG4gICAgICBFcnJvciAoRXJyb3IuY3JlYXRlX3MgWyVtZXNzYWdlIFwiU3ViY29tbWFuZHMgbXVzdCBub3QgYmVnaW4gd2l0aCAnLSdcIiBwcmVmaXhdKVxuICAgIHwgZmFsc2UgLT5cbiAgICAgIGxldCBjaG9pY2VzID1cbiAgICAgICAgTGlzdC5tYXAgKGZvcmNlIHQuc3ViY29tbWFuZHMpIH5mOihmdW4gKGtleSwgYSkgLT4ga2V5LCAoYSwgYFByZWZpeCkpXG4gICAgICBpblxuICAgICAgbG9va3VwX2V4cGFuZCBjaG9pY2VzIHByZWZpeCBTdWJjb21tYW5kXG4gICAgICB8PiBSZXN1bHQubWFwX2Vycm9yIH5mOkVycm9yLm9mX3N0cmluZ1xuICAgICAgfD4gT3JfZXJyb3IubWFwIH5mOnNuZFxuICA7O1xuXG4gIGxldCBtYXAgPSBTdGFibGUuR3JvdXBfaW5mby5Nb2RlbC5tYXBcbmVuZFxuXG5tb2R1bGUgRXhlY19pbmZvID0gc3RydWN0XG4gIHR5cGUgdCA9IFN0YWJsZS5FeGVjX2luZm8uTW9kZWwudCA9XG4gICAgeyBzdW1tYXJ5IDogc3RyaW5nXG4gICAgOyByZWFkbWUgOiBzdHJpbmcgb3B0aW9uIFtAc2V4cC5vcHRpb25dXG4gICAgOyB3b3JraW5nX2RpciA6IHN0cmluZ1xuICAgIDsgcGF0aF90b19leGUgOiBzdHJpbmdcbiAgICA7IGNoaWxkX3N1YmNvbW1hbmQgOiBzdHJpbmcgbGlzdFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cbmVuZFxuXG5tb2R1bGUgRnVsbHlfZm9yY2VkID0gc3RydWN0XG4gIHR5cGUgdCA9IFN0YWJsZS5GdWxseV9mb3JjZWQuTW9kZWwudCA9XG4gICAgfCBCYXNpYyBvZiBCYXNlX2luZm8udFxuICAgIHwgR3JvdXAgb2YgdCBHcm91cF9pbmZvLnRcbiAgICB8IEV4ZWMgb2YgRXhlY19pbmZvLnQgKiB0XG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgbGV0IGV4cGFuZGVkX3N1YmNvbW1hbmRzIHQgPVxuICAgIGxldCByZWMgZXhwYW5kID0gZnVuY3Rpb25cbiAgICAgIHwgRXhlYyAoXywgdCkgLT4gZXhwYW5kIHRcbiAgICAgIHwgQmFzaWMgXyAtPiBbIFtdIF1cbiAgICAgIHwgR3JvdXAgeyBzdWJjb21tYW5kczsgXyB9IC0+XG4gICAgICAgIExpc3QuY29uY2F0X21hcCAoTGF6eS5mb3JjZSBzdWJjb21tYW5kcykgfmY6KGZ1biAobmFtZSwgdCkgLT5cbiAgICAgICAgICBMaXN0Lm1hcCB+ZjooZnVuIHBhdGggLT4gbmFtZSA6OiBwYXRoKSAoZXhwYW5kIHQpKVxuICAgIGluXG4gICAgKCogUmV2ZXJzaW5nIHNvIHRoYXQgdGhlIGNvbW1hbmRzIHNob3cgdXAgaW4gdGhlIHNhbWUgb3JkZXIgYXMgaGVscCBpcyBvdXRwdXQgKilcbiAgICBMaXN0LnJldiAoZXhwYW5kIHQpXG4gIDs7XG5lbmRcblxubW9kdWxlIFNleHBhYmxlID0gc3RydWN0XG4gIHR5cGUgdCA9IFN0YWJsZS5TZXhwYWJsZS5Nb2RlbC50ID1cbiAgICB8IEJhc2Ugb2YgQmFzZV9pbmZvLnRcbiAgICB8IEdyb3VwIG9mIHQgR3JvdXBfaW5mby50XG4gICAgfCBFeGVjIG9mIEV4ZWNfaW5mby50XG4gICAgfCBMYXp5IG9mIHQgTGF6eS50XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGV4dHJhY3Rpb25fdmFyID0gRW52X3Zhci50b19zdHJpbmcgQ09NTUFORF9PVVRQVVRfSEVMUF9TRVhQXG5cbiAgbW9kdWxlIFZlcnNpb25lZCA9IFN0YWJsZS5TZXhwYWJsZS5WZXJzaW9uZWRcblxuICBsZXQgc3VwcG9ydGVkX3ZlcnNpb25zID1cbiAgICBsZXQgZiBpIHN1cHBvcnRlZCBfID0gU2V0LmFkZCBzdXBwb3J0ZWQgaSBpblxuICAgIFZlcnNpb25lZC5WYXJpYW50cy5mb2xkIH5pbml0OihTZXQuZW1wdHkgKG1vZHVsZSBJbnQpKSB+djE6KGYgMSkgfnYyOihmIDIpIH52MzooZiAzKVxuICA7O1xuXG4gIGxldCBvZl92ZXJzaW9uZWQgPSBWZXJzaW9uZWQudG9fbGF0ZXN0XG4gIGxldCB0b192ZXJzaW9uZWQgdCB+dmVyc2lvbl90b191c2UgPSBWZXJzaW9uZWQub2ZfbGF0ZXN0IHQgfnZlcnNpb25fdG9fdXNlXG5lbmRcblxudHlwZSB0ID1cbiAgfCBCYXNpYyBvZiBCYXNlX2luZm8udFxuICB8IEdyb3VwIG9mIHQgR3JvdXBfaW5mby50XG4gIHwgRXhlYyBvZiBFeGVjX2luZm8udCAqICh1bml0IC0+IHQpXG4gIHwgTGF6eSBvZiB0IExhenkudFxuXG5sZXQgcmVjIGZ1bGx5X2ZvcmNlZCA6IHQgLT4gRnVsbHlfZm9yY2VkLnQgPSBmdW5jdGlvblxuICB8IEJhc2ljIGIgLT4gQmFzaWMgYlxuICB8IEdyb3VwIGcgLT4gR3JvdXAgKEdyb3VwX2luZm8ubWFwIGcgfmY6ZnVsbHlfZm9yY2VkKVxuICB8IEV4ZWMgKGUsIGYpIC0+IEV4ZWMgKGUsIGZ1bGx5X2ZvcmNlZCAoZiAoKSkpXG4gIHwgTGF6eSB0aHVuayAtPiBmdWxseV9mb3JjZWQgKExhenkuZm9yY2UgdGh1bmspXG47O1xuXG5sZXQgcmVjIGdldF9zdW1tYXJ5ID0gZnVuY3Rpb25cbiAgfCBCYXNpYyBiIC0+IGIuc3VtbWFyeVxuICB8IEdyb3VwIGcgLT4gZy5zdW1tYXJ5XG4gIHwgRXhlYyAoZSwgXykgLT4gZS5zdW1tYXJ5XG4gIHwgTGF6eSB0aHVuayAtPiBnZXRfc3VtbWFyeSAoTGF6eS5mb3JjZSB0aHVuaylcbjs7XG5cbmxldCBoZWxwX3RleHQgPSBgVXNlX0NvbW1hbmRfdW5peFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgS2V5X3R5cGUgPSBLZXlfdHlwZVxuXG4gIGxldCBhYnNfcGF0aCA9IFN0YWJsZS5FeGVjX2luZm8uYWJzX3BhdGhcbiAgbGV0IGhlbHBfc2NyZWVuX2NvbXBhcmUgPSBGbGFnX2luZm8uaGVscF9zY3JlZW5fY29tcGFyZVxuICBsZXQgd29yZF93cmFwID0gRmxhZ19oZWxwX2Rpc3BsYXkud29yZF93cmFwX2FuZF9zdHJpcFxuICBsZXQgbG9va3VwX2V4cGFuZCA9IGxvb2t1cF9leHBhbmRcbmVuZFxuIiwib3BlbiEgQmFzZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIENvbW1hbmRfaW50ZlxubW9kdWxlIFNoYXBlID0gU2hhcGVcblxuKCogaW4gb3JkZXIgdG8gZGVmaW5lIGV4cGVjdCB0ZXN0cywgd2Ugd2FudCB0byByYWlzZSByYXRoZXIgdGhhbiBleGl0IGlmIHRoZSBjb2RlIGlzXG4gICBydW5uaW5nIGluIHRoZSB0ZXN0IHJ1bm5lciBwcm9jZXNzICopXG5sZXQgcmFpc2VfaW5zdGVhZF9vZl9leGl0ID1cbiAgbWF0Y2ggUHB4X2lubGluZV90ZXN0X2xpYi50ZXN0aW5nIHdpdGhcbiAgfCBgVGVzdGluZyBgQW1fdGVzdF9ydW5uZXIgLT4gdHJ1ZVxuICB8IGBUZXN0aW5nIGBBbV9jaGlsZF9vZl90ZXN0X3J1bm5lciB8IGBOb3RfdGVzdGluZyAtPiBmYWxzZVxuOztcblxuZXhjZXB0aW9uIEV4aXRfY2FsbGVkIG9mIHsgc3RhdHVzIDogaW50IH0gW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuKCogW3JhaXNlX2luc3RlYWRfb2ZfZXhpdF0tcmVzcGVjdGluZyB3cmFwcGVycyBmb3IgW2V4aXRdIGFuZCBmdW5jdGlvbnMgdGhhdCBjYWxsIGl0ICopXG5pbmNsdWRlIHN0cnVjdFxuICBsZXQgZXhpdCBzdGF0dXMgPVxuICAgIGlmIHJhaXNlX2luc3RlYWRfb2ZfZXhpdCB0aGVuIHJhaXNlIChFeGl0X2NhbGxlZCB7IHN0YXR1cyB9KSBlbHNlIFN0ZGxpYi5leGl0IHN0YXR1c1xuICA7O1xuXG4gIG1vZHVsZSBFeG4gPSBzdHJ1Y3RcbiAgICBsZXQgaGFuZGxlX3VuY2F1Z2h0X2FuZF9leGl0IGYgPVxuICAgICAgaWYgcmFpc2VfaW5zdGVhZF9vZl9leGl0XG4gICAgICB0aGVuIChcbiAgICAgICAgdHJ5IGYgKCkgd2l0aFxuICAgICAgICB8IEV4aXRfY2FsbGVkIHsgc3RhdHVzID0gMCB9IGFzIGV4biAtPiBwcmludF9zIFslc2V4cCAoZXhuIDogZXhuKV0pXG4gICAgICBlbHNlIEV4bi5oYW5kbGVfdW5jYXVnaHRfYW5kX2V4aXQgZlxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbmxldCB1bndvcmRzIHhzID0gU3RyaW5nLmNvbmNhdCB+c2VwOlwiIFwiIHhzXG5sZXQgdW5wYXJhZ3JhcGhzIHhzID0gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuXFxuXCIgeHNcblxuZXhjZXB0aW9uIEZhaWxlZF90b19wYXJzZV9jb21tYW5kX2xpbmUgb2Ygc3RyaW5nXG5cbmxldCBkaWUgZm10ID0ga3NwcmludGYgKGZ1biBtc2cgKCkgLT4gcmFpc2UgKEZhaWxlZF90b19wYXJzZV9jb21tYW5kX2xpbmUgbXNnKSkgZm10XG5sZXQgaGVscF9zY3JlZW5fY29tcGFyZSA9IFNoYXBlLlByaXZhdGUuaGVscF9zY3JlZW5fY29tcGFyZVxuXG4oKiB1bml2ZXJzYWwgbWFwcyBhcmUgdXNlZCB0byBwYXNzIGFyb3VuZCB2YWx1ZXMgYmV0d2VlbiBkaWZmZXJlbnQgYml0c1xuICAgb2YgY29tbWFuZCBsaW5lIHBhcnNpbmcgY29kZSB3aXRob3V0IGhhdmluZyBhIGh1Z2UgaW1wYWN0IG9uIHRoZVxuICAgdHlwZXMgaW52b2x2ZWRcblxuICAgMS4gcGFzc2luZyB2YWx1ZXMgZnJvbSBwYXJzZWQgYXJncyB0byBjb21tYW5kLWxpbmUgYXV0b2NvbXBsZXRlIGZ1bmN0aW9uc1xuICAgMi4gcGFzc2luZyBzcGVjaWFsIHZhbHVlcyB0byBhIGJhc2UgY29tbWFuZHMgdGhhdCByZXF1ZXN0IHRoZW0gaW4gdGhlaXIgc3BlY1xuICogZXhwYW5kZWQgc3ViY29tbWFuZCBwYXRoXG4gKiBhcmdzIHBhc3NlZCB0byB0aGUgYmFzZSBjb21tYW5kXG4gKiBoZWxwIHRleHQgZm9yIHRoZSBiYXNlIGNvbW1hbmRcbiAqKVxubW9kdWxlIEVudiA9IHN0cnVjdFxuICBpbmNsdWRlIFVuaXZfbWFwXG5cbiAgbGV0IGtleV9jcmVhdGUgbmFtZSA9IFVuaXZfbWFwLktleS5jcmVhdGUgfm5hbWUgU2V4cGxpYi5Db252LnNleHBfb2Zfb3BhcXVlXG4gIGxldCBtdWx0aV9hZGQgPSBVbml2X21hcC5NdWx0aS5hZGRcbiAgbGV0IHNldF93aXRoX2RlZmF1bHQgPSBVbml2X21hcC5XaXRoX2RlZmF1bHQuc2V0XG5lbmRcblxubGV0IGtleV9pbnRlcm5hbF92YWxpZGF0ZV9wYXJzaW5nID1cbiAgRW52LktleS5jcmVhdGUgfm5hbWU6XCItLS0taW50ZXJuYWwtdmFsaWRhdGUtcGFyc2luZ1wiIFslc2V4cF9vZjogdW5pdF1cbjs7XG5cbm1vZHVsZSBQYXJzaW5nX291dGNvbWUgOiBzaWdcbiAgdHlwZSAnYSB0ID1cbiAgICB7IHJlc3VsdCA6ICgnYSwgWyBgTWlzc2luZ19yZXF1aXJlZF9mbGFncyBvZiBFcnJvci50IF0pIFJlc3VsdC50XG4gICAgOyBoYXNfYXJnIDogYm9vbFxuICAgIH1cblxuICB2YWwgcmV0dXJuX25vX2FyZyA6ICdhIC0+ICdhIHRcbiAgdmFsIHJldHVybl93aXRoX2FyZyA6ICdhIC0+ICdhIHRcbiAgdmFsIGVycm9yIDogaGFzX2FyZzpib29sIC0+IFsgYE1pc3NpbmdfcmVxdWlyZWRfZmxhZ3Mgb2YgRXJyb3IudCBdIC0+ICdhIHRcbiAgdmFsIHJlY292ZXJfZnJvbV9taXNzaW5nX3JlcXVpcmVkX2ZsYWdzIDogJ2EgdCAtPiAnYSB0IHRcblxuICB2YWwgaW50cm9kdWNlX21pc3NpbmdfcmVxdWlyZWRfZmxhZ3NcbiAgICA6ICAoJ2EsIFsgYE1pc3NpbmdfcmVxdWlyZWRfZmxhZ3Mgb2YgRXJyb3IudCBdKSBSZXN1bHQudCB0XG4gICAgLT4gJ2EgdFxuXG4gIGluY2x1ZGUgQXBwbGljYXRpdmUuUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IHJlc3VsdCA6ICgnYSwgWyBgTWlzc2luZ19yZXF1aXJlZF9mbGFncyBvZiBFcnJvci50IF0pIFJlc3VsdC50XG4gICAgOyBoYXNfYXJnIDogYm9vbFxuICAgIH1cblxuICBsZXQgYXBwbHkgZiB4ID1cbiAgICB7IHJlc3VsdCA9XG4gICAgICAgIFJlc3VsdC5jb21iaW5lXG4gICAgICAgICAgZi5yZXN1bHRcbiAgICAgICAgICB4LnJlc3VsdFxuICAgICAgICAgIH5vazooZnVuIGYgeCAtPiBmIHgpXG4gICAgICAgICAgfmVycjooZnVuIChgTWlzc2luZ19yZXF1aXJlZF9mbGFncyBlcnJfMSkgKGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzIF9lcnJfMikgLT5cbiAgICAgICAgICAgIGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzIGVycl8xKVxuICAgIDsgaGFzX2FyZyA9IGYuaGFzX2FyZyB8fCB4Lmhhc19hcmdcbiAgICB9XG4gIDs7XG5cbiAgbGV0IHJlY292ZXJfZnJvbV9taXNzaW5nX3JlcXVpcmVkX2ZsYWdzIHQgPSB7IHJlc3VsdCA9IE9rIHQ7IGhhc19hcmcgPSB0Lmhhc19hcmcgfVxuXG4gIGxldCBpbnRyb2R1Y2VfbWlzc2luZ19yZXF1aXJlZF9mbGFncyB0ID1cbiAgICB7IHJlc3VsdCA9IFJlc3VsdC5qb2luIHQucmVzdWx0OyBoYXNfYXJnID0gdC5oYXNfYXJnIH1cbiAgOztcblxuICBsZXQgbWFwIHsgcmVzdWx0OyBoYXNfYXJnIH0gfmYgPSB7IHJlc3VsdCA9IFJlc3VsdC5tYXAgcmVzdWx0IH5mOyBoYXNfYXJnIH1cbiAgbGV0IHJldHVybl9ub19hcmcgdiA9IHsgcmVzdWx0ID0gT2sgdjsgaGFzX2FyZyA9IGZhbHNlIH1cbiAgbGV0IHJldHVybl93aXRoX2FyZyB2ID0geyByZXN1bHQgPSBPayB2OyBoYXNfYXJnID0gdHJ1ZSB9XG4gIGxldCBlcnJvciB+aGFzX2FyZyBlcnIgPSB7IHJlc3VsdCA9IEVycm9yIGVycjsgaGFzX2FyZyB9XG5cbiAgaW5jbHVkZSBBcHBsaWNhdGl2ZS5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVybl9ub19hcmdcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICBsZXQgYXBwbHkgPSBhcHBseVxuICBlbmQpXG5lbmRcblxubW9kdWxlIEF1dG9fY29tcGxldGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gRW52LnQgLT4gcGFydDpzdHJpbmcgLT4gc3RyaW5nIGxpc3RcblxuICBtb2R1bGUgRm9yX2VzY2FwZSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IEVudi50IC0+IHBhcnQ6c3RyaW5nIGxpc3QgLT4gc3RyaW5nIGxpc3RcbiAgZW5kXG5lbmRcblxubW9kdWxlIENvbXBsZXRlciA9IHN0cnVjdFxuICB0eXBlIHQgPSBBdXRvX2NvbXBsZXRlLnQgb3B0aW9uXG5cbiAgbW9kdWxlIEZvcl9lc2NhcGUgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBBdXRvX2NvbXBsZXRlLkZvcl9lc2NhcGUudCBvcHRpb25cbiAgZW5kXG5cbiAgbGV0IHJ1bl9hbmRfZXhpdCB0IGVudiB+cGFydCA6IE5vdGhpbmcudCA9XG4gICAgT3B0aW9uLml0ZXIgdCB+ZjooZnVuIGNvbXBsZXRpb25zIC0+XG4gICAgICBMaXN0Lml0ZXIgfmY6cHJpbnRfZW5kbGluZSAoY29tcGxldGlvbnMgZW52IH5wYXJ0KSk7XG4gICAgZXhpdCAwXG4gIDs7XG5lbmRcblxubW9kdWxlIEFyZ190eXBlIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBleHRyYV9kb2MgOiAnYSB0IC0+IHN0cmluZyBvcHRpb24gbGF6eV90XG4gIHZhbCBrZXkgOiAnYSB0IC0+ICdhIEVudi5NdWx0aS5LZXkudCBvcHRpb25cbiAgdmFsIGNvbXBsZXRlIDogJ2EgdCAtPiBDb21wbGV0ZXIudFxuICB2YWwgcGFyc2UgOiAnYSB0IC0+IHN0cmluZyAtPiAnYSBPcl9lcnJvci50XG5cbiAgdmFsIGNyZWF0ZVxuICAgIDogID9jb21wbGV0ZTpBdXRvX2NvbXBsZXRlLnRcbiAgICAtPiA/a2V5OidhIEVudi5NdWx0aS5LZXkudFxuICAgIC0+IChzdHJpbmcgLT4gJ2EpXG4gICAgLT4gJ2EgdFxuXG4gIHZhbCBtYXAgOiA/a2V5OidhIEVudi5NdWx0aS5LZXkudCAtPiAnYiB0IC0+IGY6KCdiIC0+ICdhKSAtPiAnYSB0XG4gIHZhbCBvZl9sYXp5IDogP2tleTonYSBFbnYuTXVsdGkuS2V5LnQgLT4gJ2EgdCBsYXp5X3QgLT4gJ2EgdFxuXG4gIHZhbCBvZl9tYXBcbiAgICA6ICA/YWNjZXB0X3VuaXF1ZV9wcmVmaXhlczpib29sXG4gICAgLT4gP2Nhc2Vfc2Vuc2l0aXZlOmJvb2xcbiAgICAtPiA/bGlzdF92YWx1ZXNfaW5faGVscDpib29sXG4gICAgLT4gP2F1dG9fY29tcGxldGU6QXV0b19jb21wbGV0ZS50XG4gICAgLT4gP2tleTonYSBFbnYuTXVsdGkuS2V5LnRcbiAgICAtPiAnYSBNYXAuTShTdHJpbmcpLnRcbiAgICAtPiAnYSB0XG5cbiAgdmFsIG9mX2FsaXN0X2V4blxuICAgIDogID9hY2NlcHRfdW5pcXVlX3ByZWZpeGVzOmJvb2xcbiAgICAtPiA/Y2FzZV9zZW5zaXRpdmU6Ym9vbFxuICAgIC0+ID9saXN0X3ZhbHVlc19pbl9oZWxwOmJvb2xcbiAgICAtPiA/YXV0b19jb21wbGV0ZTpBdXRvX2NvbXBsZXRlLnRcbiAgICAtPiA/a2V5OidhIEVudi5NdWx0aS5LZXkudFxuICAgIC0+IChzdHJpbmcgKiAnYSkgbGlzdFxuICAgIC0+ICdhIHRcblxuICB2YWwgZW51bWVyYXRlZFxuICAgIDogID9hY2NlcHRfdW5pcXVlX3ByZWZpeGVzOmJvb2xcbiAgICAtPiA/Y2FzZV9zZW5zaXRpdmU6Ym9vbFxuICAgIC0+ID9saXN0X3ZhbHVlc19pbl9oZWxwOmJvb2xcbiAgICAtPiA/YXV0b19jb21wbGV0ZTpBdXRvX2NvbXBsZXRlLnRcbiAgICAtPiA/a2V5OidhIEVudi5NdWx0aS5LZXkudFxuICAgIC0+IChtb2R1bGUgRW51bWVyYWJsZV9zdHJpbmdhYmxlIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgLT4gJ2EgdFxuXG4gIHZhbCBlbnVtZXJhdGVkX3NleHBhYmxlXG4gICAgOiAgP2FjY2VwdF91bmlxdWVfcHJlZml4ZXM6Ym9vbFxuICAgIC0+ID9jYXNlX3NlbnNpdGl2ZTpib29sXG4gICAgLT4gP2xpc3RfdmFsdWVzX2luX2hlbHA6Ym9vbFxuICAgIC0+ID9hdXRvX2NvbXBsZXRlOkF1dG9fY29tcGxldGUudFxuICAgIC0+ID9rZXk6J2EgRW52Lk11bHRpLktleS50XG4gICAgLT4gKG1vZHVsZSBFbnVtZXJhYmxlX3NleHBhYmxlIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgLT4gJ2EgdFxuXG4gIHZhbCBjb21tYV9zZXBhcmF0ZWRcbiAgICA6ICA/YWxsb3dfZW1wdHk6Ym9vbFxuICAgIC0+ID9rZXk6J2EgbGlzdCBFbnYuTXVsdGkuS2V5LnRcbiAgICAtPiA/c3RyaXBfd2hpdGVzcGFjZTpib29sXG4gICAgLT4gP3VuaXF1ZV92YWx1ZXM6Ym9vbFxuICAgIC0+ICdhIHRcbiAgICAtPiAnYSBsaXN0IHRcblxuICBtb2R1bGUgRXhwb3J0IDogc2lnXG4gICAgdmFsIHN0cmluZyA6IHN0cmluZyB0XG4gICAgdmFsIGludCA6IGludCB0XG4gICAgdmFsIGNoYXIgOiBjaGFyIHRcbiAgICB2YWwgZmxvYXQgOiBmbG9hdCB0XG4gICAgdmFsIGJvb2wgOiBib29sIHRcbiAgICB2YWwgc2V4cCA6IFNleHAudCB0XG4gICAgdmFsIHNleHBfY29udiA6ID9jb21wbGV0ZTpBdXRvX2NvbXBsZXRlLnQgLT4gKFNleHAudCAtPiAnYSkgLT4gJ2EgdFxuICBlbmRcblxuICB2YWwgYXV0b19jb21wbGV0ZSA6IF8gdCAtPiBBdXRvX2NvbXBsZXRlLnRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgcGFyc2UgOiBzdHJpbmcgLT4gJ2FcbiAgICA7IGNvbXBsZXRlIDogQ29tcGxldGVyLnRcbiAgICA7IGtleSA6ICdhIFVuaXZfbWFwLk11bHRpLktleS50IG9wdGlvblxuICAgIDsgZXh0cmFfZG9jIDogc3RyaW5nIG9wdGlvbiBMYXp5LnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVyc11cblxuICBsZXQgcGFyc2UgdCBzID0gT3JfZXJyb3IudHJ5X3dpdGggKGZ1biAoKSAtPiB0LnBhcnNlIHMpXG4gIGxldCBjcmVhdGUnID9jb21wbGV0ZSA/a2V5IHBhcnNlIH5leHRyYV9kb2MgPSB7IHBhcnNlOyBrZXk7IGNvbXBsZXRlOyBleHRyYV9kb2MgfVxuXG4gIGxldCBjcmVhdGUgP2NvbXBsZXRlID9rZXkgb2Zfc3RyaW5nID1cbiAgICBjcmVhdGUnID9jb21wbGV0ZSA/a2V5IG9mX3N0cmluZyB+ZXh0cmFfZG9jOihMYXp5LmZyb21fdmFsIE5vbmUpXG4gIDs7XG5cbiAgbGV0IG1hcCA/a2V5IHQgfmYgPSB7IHQgd2l0aCBrZXk7IHBhcnNlID0gKGZ1biBzIC0+IGYgKHQucGFyc2UgcykpIH1cblxuICBsZXQgb2ZfbGF6eSA/a2V5IHQgPVxuICAgIGxldCBwYXJzZSBzdHIgPSAoZm9yY2UgdCkucGFyc2Ugc3RyIGluXG4gICAgbGV0IGNvbXBsZXRlIGVudiB+cGFydCA9XG4gICAgICBtYXRjaCAoZm9yY2UgdCkuY29tcGxldGUgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICgqIFNlZSBbcnVuX2FuZF9leGl0XSAtIG5vIGNvbXBsZXRpb25zIGlzIGVxdWl2YWxlbnQgdG8gbm90IGhhdmluZyBhXG4gICAgICAgICAgIFtDb21wbGV0ZV0uICopXG4gICAgICAgIFtdXG4gICAgICB8IFNvbWUgY29tcGxldGUgLT4gY29tcGxldGUgZW52IH5wYXJ0XG4gICAgaW5cbiAgICBsZXQgZXh0cmFfZG9jID0gTGF6eS5iaW5kIHQgfmY6ZXh0cmFfZG9jIGluXG4gICAgeyBwYXJzZTsgY29tcGxldGUgPSBTb21lIGNvbXBsZXRlOyBrZXk7IGV4dHJhX2RvYyB9XG4gIDs7XG5cbiAgbGV0IHN0cmluZyA9IGNyZWF0ZSBGbi5pZFxuICBsZXQgaW50ID0gY3JlYXRlIEludC5vZl9zdHJpbmdcbiAgbGV0IGNoYXIgPSBjcmVhdGUgQ2hhci5vZl9zdHJpbmdcbiAgbGV0IGZsb2F0ID0gY3JlYXRlIEZsb2F0Lm9mX3N0cmluZ1xuICBsZXQgc2V4cCA9IGNyZWF0ZSBQYXJzZXhwLlNpbmdsZS5wYXJzZV9zdHJpbmdfZXhuXG5cbiAgbGV0IHNleHBfY29udiA/Y29tcGxldGUgb2Zfc2V4cCA9XG4gICAgY3JlYXRlID9jb21wbGV0ZSAoZnVuIHMgLT4gb2Zfc2V4cCAoUGFyc2V4cC5TaW5nbGUucGFyc2Vfc3RyaW5nX2V4biBzKSlcbiAgOztcblxuICBsZXQgYXNzb2NpYXRpdmVcbiAgICA/KGFjY2VwdF91bmlxdWVfcHJlZml4ZXMgPSB0cnVlKVxuICAgID8obGlzdF92YWx1ZXNfaW5faGVscCA9IHRydWUpXG4gICAgP2F1dG9fY29tcGxldGVcbiAgICA/a2V5XG4gICAgfmNhc2Vfc2Vuc2l0aXZlXG4gICAgYWxpc3RcbiAgICA9XG4gICAgbGV0IG9wZW4gc3RydWN0XG4gICAgICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgICAgIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gc3RyaW5nXG5cbiAgICAgICAgdmFsIGlzX3ByZWZpeCA6IHN0cmluZyAtPiBwcmVmaXg6c3RyaW5nIC0+IGJvb2xcbiAgICAgIGVuZFxuXG4gICAgICB0eXBlICdhIHQgPVxuICAgICAgICB8IFQgOlxuICAgICAgICAgICAgeyBjbXAgOiAobW9kdWxlIFMgd2l0aCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdjbXApXG4gICAgICAgICAgICA7IG1hcCA6IChzdHJpbmcsICdhLCAnY21wKSBNYXAudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLT4gJ2EgdFxuICAgIGVuZCBpblxuICAgIGxldCAoVCB7IGNtcCA9IChtb2R1bGUgUyk7IG1hcCB9KSA9XG4gICAgICBsZXQgbWFrZV9tYXBfcmFpc2VfZHVwbGljYXRlX2tleVxuICAgICAgICAodHlwZSBjbXApXG4gICAgICAgIChtb2R1bGUgUyA6IFMgd2l0aCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcClcbiAgICAgICAgYWxpc3RcbiAgICAgICAgPVxuICAgICAgICBtYXRjaCBNYXAub2ZfYWxpc3QgKG1vZHVsZSBTKSBhbGlzdCB3aXRoXG4gICAgICAgIHwgYE9rIG1hcCAtPiBtYXBcbiAgICAgICAgfCBgRHVwbGljYXRlX2tleSAoXyA6IFMudCkgLT5cbiAgICAgICAgICBsZXQgZHVwbGljYXRlX2tleXMgPVxuICAgICAgICAgICAgTGlzdC5tYXAgYWxpc3QgfmY6KGZ1biAoaywgKF8gOiAnYSkpIC0+IGssIGspXG4gICAgICAgICAgICB8PiBNYXAub2ZfYWxpc3RfbXVsdGkgKG1vZHVsZSBTKVxuICAgICAgICAgICAgfD4gTWFwLmZpbHRlciB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgfCBbXSB8IFsgXyBdIC0+IGZhbHNlXG4gICAgICAgICAgICAgICAgIHwgXyA6OiBfIDo6IF8gLT4gdHJ1ZSlcbiAgICAgICAgICAgIHw+IE1hcC5kYXRhXG4gICAgICAgICAgaW5cbiAgICAgICAgICByYWlzZV9zXG4gICAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgICAgXCJDb21tYW5kLlNwZWMuQXJnX3R5cGUub2ZfYWxpc3RfZXhuXCIgKGR1cGxpY2F0ZV9rZXlzIDogc3RyaW5nIGxpc3QgbGlzdCldXG4gICAgICBpblxuICAgICAgbGV0IG1ha2UgY21wID0gVCB7IGNtcDsgbWFwID0gbWFrZV9tYXBfcmFpc2VfZHVwbGljYXRlX2tleSBjbXAgYWxpc3QgfSBpblxuICAgICAgaWYgY2FzZV9zZW5zaXRpdmUgdGhlbiBtYWtlIChtb2R1bGUgU3RyaW5nKSBlbHNlIG1ha2UgKG1vZHVsZSBTdHJpbmcuQ2FzZWxlc3MpXG4gICAgaW5cbiAgICBsZXQgY29tcGxldGUgdW5pdl9tYXAgfnBhcnQ6cHJlZml4ID1cbiAgICAgIG1hdGNoIGF1dG9fY29tcGxldGUgd2l0aFxuICAgICAgfCBTb21lIGNvbXBsZXRlIC0+IGNvbXBsZXRlIHVuaXZfbWFwIH5wYXJ0OnByZWZpeFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIExpc3QuZmlsdGVyX21hcCAoTWFwLnRvX2FsaXN0IG1hcCkgfmY6KGZ1biAobmFtZSwgXykgLT5cbiAgICAgICAgICBtYXRjaCBTLmlzX3ByZWZpeCBuYW1lIH5wcmVmaXggd2l0aFxuICAgICAgICAgIHwgZmFsc2UgLT4gTm9uZVxuICAgICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgICAgKCogQmFzaCBjb21wbGV0aW9uIHdpbGwgbm90IGFjY2VwdCBbRm9vXSBhcyBhIGNvbXBsZXRpb24gZm9yIFtmXS4gU28gd2UgbmVlZFxuICAgICAgICAgICAgICAgdG8gbWF0Y2ggdGhlIGNhcGl0YWxpemF0aW9uIGdpdmVuLiAqKVxuICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IFN0cmluZy5zdWJvIG5hbWUgfnBvczooU3RyaW5nLmxlbmd0aCBwcmVmaXgpIGluXG4gICAgICAgICAgICBsZXQgbmFtZSA9IHByZWZpeCBeIHN1ZmZpeCBpblxuICAgICAgICAgICAgU29tZSBuYW1lKVxuICAgIGluXG4gICAgbGV0IGZpbmQgYXJnID1cbiAgICAgIG1hdGNoIE1hcC5maW5kIG1hcCBhcmcgd2l0aFxuICAgICAgfCBTb21lIF8gYXMgcyAtPiBzXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgKG1hdGNoIGFjY2VwdF91bmlxdWVfcHJlZml4ZXMgd2l0aFxuICAgICAgICAgfCBmYWxzZSAtPiBOb25lXG4gICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgIE1hcC50b19hbGlzdCBtYXBcbiAgICAgICAgICAgICAgfD4gTGlzdC5maWx0ZXIgfmY6KGZ1biAobmFtZSwgXykgLT4gUy5pc19wcmVmaXggbmFtZSB+cHJlZml4OmFyZylcbiAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgIHwgWyAoX3NpbmdsZXRvbl9rZXksIHYpIF0gLT4gU29tZSB2XG4gICAgICAgICAgICB8IFtdIHwgXyA6OiBfIDo6IF8gLT5cbiAgICAgICAgICAgICAgKCogSW4gdGhlIHR3by1vci1tb3JlIGNhc2Ugd2UgY291bGQgcHJvdmlkZSBmaWx0ZXJlZCBoZWxwIHRleHQsIGJ1dCBpdCdzXG4gICAgICAgICAgICAgICAgIG1vcmUgZ2VuZXJhbGx5IHVzZWZ1bCB0byBsaXN0IGFsbCB0aGUgb3B0aW9ucywgd2hpY2ggd2UgZG8gYmVsb3cuICopXG4gICAgICAgICAgICAgIE5vbmUpKVxuICAgIGluXG4gICAgY3JlYXRlJ1xuICAgICAgfmV4dHJhX2RvYzpcbiAgICAgICAgKGxhenlcbiAgICAgICAgICAoaWYgbGlzdF92YWx1ZXNfaW5faGVscFxuICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICBsZXQgdmFsdWVzID0gU3RyaW5nLmNvbmNhdCB+c2VwOlwiLCBcIiAoTWFwLmtleXMgbWFwKSBpblxuICAgICAgICAgICAgIFNvbWUgWyVzdHJpbmcgXCIoY2FuIGJlOiAle3ZhbHVlc30pXCJdKVxuICAgICAgICAgICBlbHNlIE5vbmUpKVxuICAgICAgP2tleVxuICAgICAgfmNvbXBsZXRlXG4gICAgICAoZnVuIGFyZyAtPlxuICAgICAgICBtYXRjaCBmaW5kIGFyZyB3aXRoXG4gICAgICAgIHwgU29tZSB2IC0+IHZcbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgbGV0IHZhbGlkX2FyZ3VtZW50c19leHRyYSA9XG4gICAgICAgICAgICBpZiBjYXNlX3NlbnNpdGl2ZSB0aGVuIFwiXCIgZWxzZSBcIiAoY2FzZSBpbnNlbnNpdGl2ZSlcIlxuICAgICAgICAgIGluXG4gICAgICAgICAgZmFpbHdpdGhmXG4gICAgICAgICAgICBcInZhbGlkIGFyZ3VtZW50cyVzOiB7JXN9XCJcbiAgICAgICAgICAgIHZhbGlkX2FyZ3VtZW50c19leHRyYVxuICAgICAgICAgICAgKFN0cmluZy5jb25jYXQgfnNlcDpcIixcIiAoTWFwLmtleXMgbWFwKSlcbiAgICAgICAgICAgICgpKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9leG5cbiAgICA/YWNjZXB0X3VuaXF1ZV9wcmVmaXhlc1xuICAgID8oY2FzZV9zZW5zaXRpdmUgPSB0cnVlKVxuICAgID9saXN0X3ZhbHVlc19pbl9oZWxwXG4gICAgP2F1dG9fY29tcGxldGVcbiAgICA/a2V5XG4gICAgYWxpc3RcbiAgICA9XG4gICAgYXNzb2NpYXRpdmVcbiAgICAgID9hY2NlcHRfdW5pcXVlX3ByZWZpeGVzXG4gICAgICA/bGlzdF92YWx1ZXNfaW5faGVscFxuICAgICAgP2F1dG9fY29tcGxldGVcbiAgICAgID9rZXlcbiAgICAgIH5jYXNlX3NlbnNpdGl2ZVxuICAgICAgYWxpc3RcbiAgOztcblxuICBsZXQgb2ZfbWFwXG4gICAgP2FjY2VwdF91bmlxdWVfcHJlZml4ZXNcbiAgICA/Y2FzZV9zZW5zaXRpdmVcbiAgICA/bGlzdF92YWx1ZXNfaW5faGVscFxuICAgID9hdXRvX2NvbXBsZXRlXG4gICAgP2tleVxuICAgIG1hcFxuICAgID1cbiAgICBvZl9hbGlzdF9leG5cbiAgICAgID9hY2NlcHRfdW5pcXVlX3ByZWZpeGVzXG4gICAgICA/Y2FzZV9zZW5zaXRpdmVcbiAgICAgID9saXN0X3ZhbHVlc19pbl9oZWxwXG4gICAgICA/YXV0b19jb21wbGV0ZVxuICAgICAgP2tleVxuICAgICAgKE1hcC50b19hbGlzdCBtYXApXG4gIDs7XG5cbiAgbGV0IGVudW1lcmF0ZWRcbiAgICAodHlwZSB0KVxuICAgID9hY2NlcHRfdW5pcXVlX3ByZWZpeGVzXG4gICAgP2Nhc2Vfc2Vuc2l0aXZlXG4gICAgP2xpc3RfdmFsdWVzX2luX2hlbHBcbiAgICA/YXV0b19jb21wbGV0ZVxuICAgID9rZXlcbiAgICAobW9kdWxlIEUgOiBFbnVtZXJhYmxlX3N0cmluZ2FibGUgd2l0aCB0eXBlIHQgPSB0KVxuICAgID1cbiAgICBvZl9hbGlzdF9leG5cbiAgICAgID9hY2NlcHRfdW5pcXVlX3ByZWZpeGVzXG4gICAgICA/Y2FzZV9zZW5zaXRpdmVcbiAgICAgID9saXN0X3ZhbHVlc19pbl9oZWxwXG4gICAgICA/YXV0b19jb21wbGV0ZVxuICAgICAgP2tleVxuICAgICAgKGxldCVtYXAuTGlzdCB0ID0gRS5hbGwgaW5cbiAgICAgICBFLnRvX3N0cmluZyB0LCB0KVxuICA7O1xuXG4gIGxldCBlbnVtZXJhdGVkX3NleHBhYmxlXG4gICAgKHR5cGUgdClcbiAgICA/YWNjZXB0X3VuaXF1ZV9wcmVmaXhlc1xuICAgID9jYXNlX3NlbnNpdGl2ZVxuICAgID9saXN0X3ZhbHVlc19pbl9oZWxwXG4gICAgP2F1dG9fY29tcGxldGVcbiAgICA/a2V5XG4gICAgKG1vZHVsZSBFIDogRW51bWVyYWJsZV9zZXhwYWJsZSB3aXRoIHR5cGUgdCA9IHQpXG4gICAgPVxuICAgIGVudW1lcmF0ZWRcbiAgICAgID9hY2NlcHRfdW5pcXVlX3ByZWZpeGVzXG4gICAgICA/Y2FzZV9zZW5zaXRpdmVcbiAgICAgID9saXN0X3ZhbHVlc19pbl9oZWxwXG4gICAgICA/YXV0b19jb21wbGV0ZVxuICAgICAgP2tleVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgaW5jbHVkZSBFXG5cbiAgICAgICAgbGV0IHRvX3N0cmluZyB0ID0gU2V4cC50b19zdHJpbmcgWyVzZXhwICh0IDogRS50KV1cbiAgICAgIGVuZClcbiAgOztcblxuICBsZXQgYm9vbCA9IGVudW1lcmF0ZWQgfmxpc3RfdmFsdWVzX2luX2hlbHA6ZmFsc2UgKG1vZHVsZSBCb29sKVxuXG4gIGxldCBjb21tYV9zZXBhcmF0ZWRcbiAgICA/KGFsbG93X2VtcHR5ID0gZmFsc2UpXG4gICAgP2tleVxuICAgID8oc3RyaXBfd2hpdGVzcGFjZSA9IGZhbHNlKVxuICAgID8odW5pcXVlX3ZhbHVlcyA9IGZhbHNlKVxuICAgIHRcbiAgICA9XG4gICAgbGV0IHN0cmlwID0gaWYgc3RyaXBfd2hpdGVzcGFjZSB0aGVuIGZ1biBzdHIgLT4gU3RyaW5nLnN0cmlwIHN0ciBlbHNlIEZuLmlkIGluXG4gICAgbGV0IGNvbXBsZXRlID1cbiAgICAgIE9wdGlvbi5tYXAgdC5jb21wbGV0ZSB+ZjooZnVuIGNvbXBsZXRlX2VsdCBlbnYgfnBhcnQgLT5cbiAgICAgICAgbGV0IHByZWZpeGVzLCBzdWZmaXggPVxuICAgICAgICAgIG1hdGNoIFN0cmluZy5zcGxpdCBwYXJ0IH5vbjonLCcgfD4gTGlzdC5yZXYgd2l0aFxuICAgICAgICAgIHwgW10gLT4gW10sIHBhcnRcbiAgICAgICAgICB8IGhkIDo6IHRsIC0+IExpc3QucmV2IHRsLCBoZFxuICAgICAgICBpblxuICAgICAgICBsZXQgaXNfYWxsb3dlZCA9XG4gICAgICAgICAgaWYgbm90IHVuaXF1ZV92YWx1ZXNcbiAgICAgICAgICB0aGVuIGZ1biAoXyA6IHN0cmluZykgLT4gdHJ1ZVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IHNlZW5fYWxyZWFkeSA9XG4gICAgICAgICAgICAgIHByZWZpeGVzIHw+IExpc3QubWFwIH5mOnN0cmlwIHw+IFNldC5vZl9saXN0IChtb2R1bGUgU3RyaW5nKVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGZ1biBjaG9pY2UgLT4gbm90IChTZXQubWVtIHNlZW5fYWxyZWFkeSAoc3RyaXAgY2hvaWNlKSkpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBjaG9pY2VzID1cbiAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgTGlzdC5maWx0ZXIgKGNvbXBsZXRlX2VsdCBlbnYgfnBhcnQ6c3VmZml4KSB+ZjooZnVuIGNob2ljZSAtPlxuICAgICAgICAgICAgICAobm90IChTdHJpbmcubWVtIGNob2ljZSAnLCcpKSAmJiBpc19hbGxvd2VkIGNob2ljZSlcbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgKCogSWYgdGhlcmUgaXMgZXhhY3RseSBvbmUgY2hvaWNlIHRvIGF1dG8tY29tcGxldGUsIGFkZCBhIHNlY29uZCBjaG9pY2Ugd2l0aFxuICAgICAgICAgICAgIGEgdHJhaWxpbmcgY29tbWEgc28gdGhhdCBhdXRvLWNvbXBsZXRpb24gd2lsbCBnbyB0byB0aGUgZW5kIGJ1dCBiYXNoXG4gICAgICAgICAgICAgd29uJ3QgYWRkIGEgc3BhY2UuICBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2hvaWNlcywgb3IgYSBzaW5nbGUgY2hvaWNlXG4gICAgICAgICAgICAgdGhhdCBtdXN0IGJlIGZpbmFsLCB0aGVyZSBpcyBubyBuZWVkIHRvIGFkZCBhIGR1bW15IG9wdGlvbi4gKilcbiAgICAgICAgICB8IFsgY2hvaWNlIF0gLT4gWyBjaG9pY2U7IGNob2ljZSBeIFwiLFwiIF1cbiAgICAgICAgICB8IGNob2ljZXMgLT4gY2hvaWNlc1xuICAgICAgICBpblxuICAgICAgICBMaXN0Lm1hcCBjaG9pY2VzIH5mOihmdW4gY2hvaWNlIC0+IFN0cmluZy5jb25jYXQgfnNlcDpcIixcIiAocHJlZml4ZXMgQCBbIGNob2ljZSBdKSkpXG4gICAgaW5cbiAgICBsZXQgb2Zfc3RyaW5nIHN0cmluZyA9XG4gICAgICBsZXQgc3RyaW5nID0gc3RyaXAgc3RyaW5nIGluXG4gICAgICBpZiBTdHJpbmcuaXNfZW1wdHkgc3RyaW5nXG4gICAgICB0aGVuXG4gICAgICAgIGlmIGFsbG93X2VtcHR5XG4gICAgICAgIHRoZW4gW11cbiAgICAgICAgZWxzZSBmYWlsd2l0aCBcIkNvbW1hbmQuU3BlYy5BcmdfdHlwZS5jb21tYV9zZXBhcmF0ZWQ6IGVtcHR5IGxpc3Qgbm90IGFsbG93ZWRcIlxuICAgICAgZWxzZSBMaXN0Lm1hcCAoU3RyaW5nLnNwbGl0IHN0cmluZyB+b246JywnKSB+ZjooZnVuIHN0ciAtPiB0LnBhcnNlIChzdHJpcCBzdHIpKVxuICAgIGluXG4gICAgY3JlYXRlID9rZXkgP2NvbXBsZXRlIG9mX3N0cmluZ1xuICA7O1xuXG4gIG1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgICBsZXQgc3RyaW5nID0gc3RyaW5nXG4gICAgbGV0IGludCA9IGludFxuICAgIGxldCBjaGFyID0gY2hhclxuICAgIGxldCBmbG9hdCA9IGZsb2F0XG4gICAgbGV0IGJvb2wgPSBib29sXG4gICAgbGV0IHNleHAgPSBzZXhwXG4gICAgbGV0IHNleHBfY29udiA9IHNleHBfY29udlxuICBlbmRcblxuICBsZXQgYXV0b19jb21wbGV0ZSB0ID1cbiAgICBtYXRjaCB0LmNvbXBsZXRlIHdpdGhcbiAgICB8IFNvbWUgZiAtPiBmXG4gICAgfCBOb25lIC0+IGZ1biBfIH5wYXJ0Ol8gLT4gW11cbiAgOztcbmVuZFxuXG5tb2R1bGUgRmxhZyA9IHN0cnVjdFxuICBtb2R1bGUgTnVtX29jY3VycmVuY2VzID0gc3RydWN0XG4gICAgdHlwZSB0ID0gU2hhcGUuTnVtX29jY3VycmVuY2VzLnQgPVxuICAgICAgeyBhdF9sZWFzdF9vbmNlIDogYm9vbFxuICAgICAgOyBhdF9tb3N0X29uY2UgOiBib29sXG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgY29tcGFyZSwgZW51bWVyYXRlLCBzZXhwX29mXVxuXG4gICAgbGV0IHRvX2hlbHBfc3RyaW5nID0gU2hhcGUuTnVtX29jY3VycmVuY2VzLnRvX2hlbHBfc3RyaW5nXG5cbiAgICBsZXQgdG9faGVscF9zdHJpbmdfZGVwcmVjYXRlZCB7IGF0X2xlYXN0X29uY2U7IGF0X21vc3Rfb25jZSA9IF8gfSBmbGFnX25hbWUgPVxuICAgICAgdG9faGVscF9zdHJpbmcgeyBhdF9sZWFzdF9vbmNlOyBhdF9tb3N0X29uY2UgPSB0cnVlIH0gfmZsYWdfbmFtZVxuICAgIDs7XG5cbiAgICBsZXQgYW55ID0geyBhdF9sZWFzdF9vbmNlID0gZmFsc2U7IGF0X21vc3Rfb25jZSA9IGZhbHNlIH1cbiAgICBsZXQgYXRfbGVhc3Rfb25jZSA9IHsgYXRfbGVhc3Rfb25jZSA9IHRydWU7IGF0X21vc3Rfb25jZSA9IGZhbHNlIH1cbiAgICBsZXQgYXRfbW9zdF9vbmNlID0geyBhdF9sZWFzdF9vbmNlID0gZmFsc2U7IGF0X21vc3Rfb25jZSA9IHRydWUgfVxuICAgIGxldCBleGFjdGx5X29uY2UgPSB7IGF0X2xlYXN0X29uY2UgPSB0cnVlOyBhdF9tb3N0X29uY2UgPSB0cnVlIH1cbiAgZW5kXG5cbiAgdHlwZSBhY3Rpb24gPVxuICAgIHwgTm9fYXJnIG9mIChFbnYudCAtPiBFbnYudClcbiAgICB8IFByaW50X2luZm9fYW5kX3F1aXQgb2YgKEVudi50IC0+IHN0cmluZylcbiAgICB8IEFyZyBvZiAoRW52LnQgLT4gc3RyaW5nIC0+IEVudi50KSAqIENvbXBsZXRlci50XG4gICAgfCBSZXN0IG9mIChFbnYudCAtPiBzdHJpbmcgbGlzdCAtPiBFbnYudCkgKiBDb21wbGV0ZXIuRm9yX2VzY2FwZS50XG5cbiAgbW9kdWxlIEludGVybmFsID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHsgbmFtZSA6IHN0cmluZ1xuICAgICAgOyBhbGlhc2VzIDogc3RyaW5nIGxpc3RcbiAgICAgIDsgYWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHAgOiBzdHJpbmcgbGlzdFxuICAgICAgICAgICgqIFthbGlhc2VzX2V4Y2x1ZGVkX2Zyb21faGVscF0gYXJlIGFsaWFzZXMgdGhhdCBkb24ndCBzaG93IHVwIGluIC1oZWxwIG91dHB1dC5cbiAgICAgICAgIEN1cnJlbnRseSB0aGV5J3JlIG9ubHkgdXNlZCBmb3IgZG91YmxlLWRhc2ggYnVpbHQtaW4gZmxhZ3MgbGlrZSAtLWhlbHAgYW5kXG4gICAgICAgICAtLXZlcnNpb24uICopXG4gICAgICA7IGFjdGlvbiA6IGFjdGlvblxuICAgICAgOyBkb2MgOiBzdHJpbmdcbiAgICAgIDsgbnVtX29jY3VycmVuY2VzIDogTnVtX29jY3VycmVuY2VzLnRcbiAgICAgIDsgY2hlY2tfYXZhaWxhYmxlIDogRW52LnQgLT4gdW5pdFxuICAgICAgOyBuYW1lX21hdGNoaW5nIDogWyBgUHJlZml4IHwgYEZ1bGxfbWF0Y2hfcmVxdWlyZWQgXVxuICAgICAgfVxuXG4gICAgbGV0IHdyYXBfaWZfb3B0aW9uYWwgdCBmbGFnX25hbWUgPVxuICAgICAgTnVtX29jY3VycmVuY2VzLnRvX2hlbHBfc3RyaW5nIHQubnVtX29jY3VycmVuY2VzIH5mbGFnX25hbWVcbiAgICA7O1xuXG4gICAgbW9kdWxlIERvYyA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAgeyBhcmdfZG9jIDogc3RyaW5nIG9wdGlvblxuICAgICAgICA7IGRvYyA6IHN0cmluZ1xuICAgICAgICB9XG5cbiAgICAgIGxldCBwYXJzZSB+YWN0aW9uIH5kb2MgPVxuICAgICAgICBsZXQgYXJnX2RvYywgZG9jID1cbiAgICAgICAgICBtYXRjaCAoYWN0aW9uIDogYWN0aW9uKSwgU3RyaW5nLmxzcGxpdDIgZG9jIH5vbjonICcgd2l0aFxuICAgICAgICAgIHwgKE5vX2FyZyBfIHwgUHJpbnRfaW5mb19hbmRfcXVpdCBfKSwgXyAtPiBOb25lLCBkb2NcbiAgICAgICAgICB8IEFyZyBfLCAoTm9uZSB8IFNvbWUgKFwiXCIsIF8pKSAtPiBTb21lIFwiX1wiLCBkb2NcbiAgICAgICAgICB8IFJlc3QgXywgKE5vbmUgfCBTb21lIChcIlwiLCBfKSkgLT4gTm9uZSwgZG9jXG4gICAgICAgICAgfCAoQXJnIF8gfCBSZXN0IF8pLCBTb21lIChhcmcsIGRvYykgLT4gU29tZSBhcmcsIGRvY1xuICAgICAgICBpblxuICAgICAgICB7IGRvYyA9IFN0cmluZy5zdHJpcCBkb2M7IGFyZ19kb2MgfVxuICAgICAgOztcblxuICAgICAgbGV0IGNvbmNhdCB+bmFtZSB+YXJnX2RvYyA9XG4gICAgICAgIG1hdGNoIGFyZ19kb2Mgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gbmFtZVxuICAgICAgICB8IFNvbWUgYXJnX2RvYyAtPiBuYW1lIF4gXCIgXCIgXiBhcmdfZG9jXG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbW9kdWxlIERlcHJlY2F0ZWQgPSBzdHJ1Y3RcbiAgICAgIGxldCB3cmFwX2lmX29wdGlvbmFsIHQgeCA9XG4gICAgICAgIE51bV9vY2N1cnJlbmNlcy50b19oZWxwX3N0cmluZ19kZXByZWNhdGVkIHQubnVtX29jY3VycmVuY2VzIHhcbiAgICAgIDs7XG5cbiAgICAgICgqIGZsYWcgaGVscCBpbiB0aGUgZm9ybWF0IG9mIHRoZSBvbGQgY29tbWFuZC4gdXNlZCBmb3IgaW5qZWN0aW9uICopXG4gICAgICBsZXQgaGVscFxuICAgICAgICAoeyBuYW1lXG4gICAgICAgICA7IGRvY1xuICAgICAgICAgOyBhbGlhc2VzXG4gICAgICAgICA7IGFjdGlvblxuICAgICAgICAgOyBudW1fb2NjdXJyZW5jZXMgPSBfXG4gICAgICAgICA7IGNoZWNrX2F2YWlsYWJsZSA9IF9cbiAgICAgICAgIDsgbmFtZV9tYXRjaGluZyA9IF9cbiAgICAgICAgIDsgYWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHAgPSBfXG4gICAgICAgICB9IGFzIHQpXG4gICAgICAgID1cbiAgICAgICAgaWYgU3RyaW5nLmlzX3ByZWZpeCBkb2MgfnByZWZpeDpcIiBcIlxuICAgICAgICB0aGVuXG4gICAgICAgICAgKG5hbWUsIFN0cmluZy5sc3RyaXAgZG9jKVxuICAgICAgICAgIDo6IExpc3QubWFwIGFsaWFzZXMgfmY6KGZ1biB4IC0+IHgsIHNwcmludGYgXCJzYW1lIGFzIFxcXCIlc1xcXCJcIiBuYW1lKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgeyBEb2MuYXJnX2RvYzsgZG9jIH0gPSBEb2MucGFyc2UgfmFjdGlvbiB+ZG9jIGluXG4gICAgICAgICAgKHdyYXBfaWZfb3B0aW9uYWwgdCAoRG9jLmNvbmNhdCB+bmFtZSB+YXJnX2RvYyksIGRvYylcbiAgICAgICAgICA6OiBMaXN0Lm1hcCBhbGlhc2VzIH5mOihmdW4geCAtPlxuICAgICAgICAgICAgICAgKCB3cmFwX2lmX29wdGlvbmFsIHQgKERvYy5jb25jYXQgfm5hbWU6eCB+YXJnX2RvYylcbiAgICAgICAgICAgICAgICwgc3ByaW50ZiBcInNhbWUgYXMgXFxcIiVzXFxcIlwiIG5hbWUgKSkpXG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbGV0IGFsaWduXG4gICAgICAoeyBuYW1lXG4gICAgICAgOyBkb2NcbiAgICAgICA7IGFsaWFzZXNcbiAgICAgICA7IGFjdGlvblxuICAgICAgIDsgbnVtX29jY3VycmVuY2VzID0gX1xuICAgICAgIDsgY2hlY2tfYXZhaWxhYmxlID0gX1xuICAgICAgIDsgbmFtZV9tYXRjaGluZyA9IF9cbiAgICAgICA7IGFsaWFzZXNfZXhjbHVkZWRfZnJvbV9oZWxwID0gX1xuICAgICAgIH0gYXMgdClcbiAgICAgIDogU2hhcGUuRmxhZ19pbmZvLnRcbiAgICAgID1cbiAgICAgIGxldCB7IERvYy5hcmdfZG9jOyBkb2MgfSA9IERvYy5wYXJzZSB+YWN0aW9uIH5kb2MgaW5cbiAgICAgIGxldCBuYW1lID0gd3JhcF9pZl9vcHRpb25hbCB0IChEb2MuY29uY2F0IH5uYW1lIH5hcmdfZG9jKSBpblxuICAgICAgeyBuYW1lOyBkb2M7IGFsaWFzZXMgfVxuICAgIDs7XG5cbiAgICBsZXQgY3JlYXRlIGZsYWdzID1cbiAgICAgIG1hdGNoXG4gICAgICAgIE1hcC5vZl9hbGlzdCAobW9kdWxlIFN0cmluZykgKExpc3QubWFwIGZsYWdzIH5mOihmdW4gZmxhZyAtPiBmbGFnLm5hbWUsIGZsYWcpKVxuICAgICAgd2l0aFxuICAgICAgfCBgRHVwbGljYXRlX2tleSBmbGFnIC0+IGZhaWx3aXRoZiBcIm11bHRpcGxlIGZsYWdzIG5hbWVkICVzXCIgZmxhZyAoKVxuICAgICAgfCBgT2sgbWFwIC0+XG4gICAgICAgIExpc3QuY29uY2F0X21hcCBmbGFncyB+ZjooZnVuIGZsYWcgLT4gZmxhZy5uYW1lIDo6IGZsYWcuYWxpYXNlcylcbiAgICAgICAgfD4gTGlzdC5maW5kX2FfZHVwIH5jb21wYXJlOlslY29tcGFyZTogc3RyaW5nXVxuICAgICAgICB8PiBPcHRpb24uaXRlciB+ZjooZnVuIHggLT4gZmFpbHdpdGhmIFwibXVsdGlwbGUgZmxhZ3Mgb3IgYWxpYXNlcyBuYW1lZCAlc1wiIHggKCkpO1xuICAgICAgICBtYXBcbiAgICA7O1xuICBlbmRcblxuICB0eXBlICdhIHN0YXRlID1cbiAgICB7IGFjdGlvbiA6IGFjdGlvblxuICAgIDsgcmVhZCA6IEVudi50IC0+ICdhIFBhcnNpbmdfb3V0Y29tZS50XG4gICAgOyBudW1fb2NjdXJyZW5jZXMgOiBOdW1fb2NjdXJyZW5jZXMudFxuICAgIDsgZXh0cmFfZG9jIDogc3RyaW5nIG9wdGlvbiBMYXp5LnRcbiAgICB9XG5cbiAgdHlwZSAnYSB0ID0gc3RyaW5nIC0+ICdhIHN0YXRlXG5cbiAgbGV0IGFyZ19mbGFnIG5hbWUgYXJnX3R5cGUgcmVhZCB3cml0ZSBudW1fb2NjdXJyZW5jZXMgPVxuICAgIHsgcmVhZFxuICAgIDsgbnVtX29jY3VycmVuY2VzXG4gICAgOyBhY3Rpb24gPVxuICAgICAgICAobGV0IHVwZGF0ZSBlbnYgYXJnID1cbiAgICAgICAgICAgbWF0Y2ggQXJnX3R5cGUucGFyc2UgYXJnX3R5cGUgYXJnIHdpdGhcbiAgICAgICAgICAgfCBFcnJvciBlcnJvciAtPlxuICAgICAgICAgICAgIGRpZVxuICAgICAgICAgICAgICAgXCJmYWlsZWQgdG8gcGFyc2UgJXMgdmFsdWUgJVMuXFxuJXNcIlxuICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgYXJnXG4gICAgICAgICAgICAgICAoRXJyb3IudG9fc3RyaW5nX2h1bSBlcnJvcilcbiAgICAgICAgICAgICAgICgpXG4gICAgICAgICAgIHwgT2sgYXJnIC0+XG4gICAgICAgICAgICAgbGV0IGVudiA9IHdyaXRlIGVudiBhcmcgaW5cbiAgICAgICAgICAgICAobWF0Y2ggQXJnX3R5cGUua2V5IGFyZ190eXBlIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGVudlxuICAgICAgICAgICAgICB8IFNvbWUga2V5IC0+IEVudi5tdWx0aV9hZGQgZW52IH5rZXkgfmRhdGE6YXJnKVxuICAgICAgICAgaW5cbiAgICAgICAgIEFyZyAodXBkYXRlLCBBcmdfdHlwZS5jb21wbGV0ZSBhcmdfdHlwZSkpXG4gICAgOyBleHRyYV9kb2MgPSBBcmdfdHlwZS5leHRyYV9kb2MgYXJnX3R5cGVcbiAgICB9XG4gIDs7XG5cbiAgbGV0IG1hcF9mbGFnICh0IDogXyB0KSB+ZiBpbnB1dCA9XG4gICAgbGV0IHsgYWN0aW9uOyByZWFkOyBudW1fb2NjdXJyZW5jZXM7IGV4dHJhX2RvYyB9ID0gdCBpbnB1dCBpblxuICAgIHsgYWN0aW9uXG4gICAgOyByZWFkID0gKGZ1biBlbnYgLT4gUGFyc2luZ19vdXRjb21lLm1hcCAocmVhZCBlbnYpIH5mKVxuICAgIDsgbnVtX29jY3VycmVuY2VzXG4gICAgOyBleHRyYV9kb2NcbiAgICB9XG4gIDs7XG5cbiAgbGV0IHdyaXRlX29wdGlvbiBuYW1lIGtleSBlbnYgYXJnID1cbiAgICBFbnYudXBkYXRlIGVudiBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gYXJnXG4gICAgICB8IFNvbWUgXyAtPiBkaWUgXCJmbGFnICVzIHBhc3NlZCBtb3JlIHRoYW4gb25jZVwiIG5hbWUgKCkpXG4gIDs7XG5cbiAgbGV0IHJlcXVpcmVkX3ZhbHVlID9kZWZhdWx0IGFyZ190eXBlIG5hbWUgbnVtX29jY3VycmVuY2VzID1cbiAgICBsZXQga2V5ID0gRW52LktleS5jcmVhdGUgfm5hbWUgWyVzZXhwX29mOiBfXSBpblxuICAgIGxldCByZWFkIGVudiA9XG4gICAgICBtYXRjaCBFbnYuZmluZCBlbnYga2V5IHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IFBhcnNpbmdfb3V0Y29tZS5yZXR1cm5fd2l0aF9hcmcgdlxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIChtYXRjaCBkZWZhdWx0IHdpdGhcbiAgICAgICAgIHwgU29tZSB2IC0+IFBhcnNpbmdfb3V0Y29tZS5yZXR1cm5fbm9fYXJnIHZcbiAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICBQYXJzaW5nX291dGNvbWUuZXJyb3JcbiAgICAgICAgICAgICB+aGFzX2FyZzpmYWxzZVxuICAgICAgICAgICAgIChgTWlzc2luZ19yZXF1aXJlZF9mbGFnc1xuICAgICAgICAgICAgICAgKEVycm9yLm9mX3N0cmluZyAoc3ByaW50ZiBcIm1pc3NpbmcgcmVxdWlyZWQgZmxhZzogJXNcIiBuYW1lKSkpKVxuICAgIGluXG4gICAgbGV0IHdyaXRlIGVudiBhcmcgPSB3cml0ZV9vcHRpb24gbmFtZSBrZXkgZW52IGFyZyBpblxuICAgIGFyZ19mbGFnIG5hbWUgYXJnX3R5cGUgcmVhZCB3cml0ZSBudW1fb2NjdXJyZW5jZXNcbiAgOztcblxuICBsZXQgcmVxdWlyZWQgYXJnX3R5cGUgbmFtZSA9IHJlcXVpcmVkX3ZhbHVlIGFyZ190eXBlIG5hbWUgTnVtX29jY3VycmVuY2VzLmV4YWN0bHlfb25jZVxuXG4gIGxldCBvcHRpb25hbF93aXRoX2RlZmF1bHQgZGVmYXVsdCBhcmdfdHlwZSBuYW1lID1cbiAgICByZXF1aXJlZF92YWx1ZSB+ZGVmYXVsdCBhcmdfdHlwZSBuYW1lIE51bV9vY2N1cnJlbmNlcy5hdF9tb3N0X29uY2VcbiAgOztcblxuICBsZXQgb3B0aW9uYWwgYXJnX3R5cGUgbmFtZSA9XG4gICAgbGV0IGtleSA9IEVudi5LZXkuY3JlYXRlIH5uYW1lIFslc2V4cF9vZjogX10gaW5cbiAgICBsZXQgcmVhZCBlbnYgPVxuICAgICAgbWF0Y2ggRW52LmZpbmQgZW52IGtleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gUGFyc2luZ19vdXRjb21lLnJldHVybl9ub19hcmcgTm9uZVxuICAgICAgfCBTb21lIF8gYXMgdmFsdWUgLT4gUGFyc2luZ19vdXRjb21lLnJldHVybl93aXRoX2FyZyB2YWx1ZVxuICAgIGluXG4gICAgbGV0IHdyaXRlIGVudiBhcmcgPSB3cml0ZV9vcHRpb24gbmFtZSBrZXkgZW52IGFyZyBpblxuICAgIGFyZ19mbGFnIG5hbWUgYXJnX3R5cGUgcmVhZCB3cml0ZSBOdW1fb2NjdXJyZW5jZXMuYXRfbW9zdF9vbmNlXG4gIDs7XG5cbiAgbGV0IG5vX2FyZ19nZW5lcmFsIH5pc19yZXF1aXJlZCB+a2V5X3ZhbHVlIH5kZXByZWNhdGVkX2hvb2sgbmFtZSA9XG4gICAgbGV0IGtleSA9IEVudi5LZXkuY3JlYXRlIH5uYW1lIFslc2V4cF9vZjogdW5pdF0gaW5cbiAgICBsZXQgcmVhZCBlbnYgPVxuICAgICAgbWF0Y2ggRW52Lm1lbSBlbnYga2V5IHdpdGhcbiAgICAgIHwgdHJ1ZSAtPiBQYXJzaW5nX291dGNvbWUucmV0dXJuX3dpdGhfYXJnIHRydWVcbiAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgaWYgaXNfcmVxdWlyZWRcbiAgICAgICAgdGhlblxuICAgICAgICAgIFBhcnNpbmdfb3V0Y29tZS5lcnJvclxuICAgICAgICAgICAgfmhhc19hcmc6ZmFsc2VcbiAgICAgICAgICAgIChgTWlzc2luZ19yZXF1aXJlZF9mbGFnc1xuICAgICAgICAgICAgICAoRXJyb3Iub2Zfc3RyaW5nIChzcHJpbnRmIFwibWlzc2luZyByZXF1aXJlZCBmbGFnOiAlc1wiIG5hbWUpKSlcbiAgICAgICAgZWxzZSBQYXJzaW5nX291dGNvbWUucmV0dXJuX25vX2FyZyBmYWxzZVxuICAgIGluXG4gICAgbGV0IHdyaXRlIGVudiA9XG4gICAgICBpZiBFbnYubWVtIGVudiBrZXlcbiAgICAgIHRoZW4gZGllIFwiZmxhZyAlcyBwYXNzZWQgbW9yZSB0aGFuIG9uY2VcIiBuYW1lICgpXG4gICAgICBlbHNlIEVudi5zZXQgZW52IH5rZXkgfmRhdGE6KClcbiAgICBpblxuICAgIGxldCBhY3Rpb24gZW52ID1cbiAgICAgIGxldCBlbnYgPVxuICAgICAgICBPcHRpb24uZm9sZCBrZXlfdmFsdWUgfmluaXQ6ZW52IH5mOihmdW4gZW52IChrZXksIHZhbHVlKSAtPlxuICAgICAgICAgIEVudi5zZXRfd2l0aF9kZWZhdWx0IGVudiB+a2V5IH5kYXRhOnZhbHVlKVxuICAgICAgaW5cbiAgICAgIHdyaXRlIGVudlxuICAgIGluXG4gICAgbGV0IGFjdGlvbiA9XG4gICAgICBtYXRjaCBkZXByZWNhdGVkX2hvb2sgd2l0aFxuICAgICAgfCBOb25lIC0+IGFjdGlvblxuICAgICAgfCBTb21lIGYgLT5cbiAgICAgICAgZnVuIGVudiAtPlxuICAgICAgICAgIGxldCBlbnYgPSBhY3Rpb24gZW52IGluXG4gICAgICAgICAgZiAoKTtcbiAgICAgICAgICBlbnZcbiAgICBpblxuICAgIHsgcmVhZFxuICAgIDsgYWN0aW9uID0gTm9fYXJnIGFjdGlvblxuICAgIDsgbnVtX29jY3VycmVuY2VzID1cbiAgICAgICAgKGlmIGlzX3JlcXVpcmVkXG4gICAgICAgICB0aGVuIE51bV9vY2N1cnJlbmNlcy5leGFjdGx5X29uY2VcbiAgICAgICAgIGVsc2UgTnVtX29jY3VycmVuY2VzLmF0X21vc3Rfb25jZSlcbiAgICA7IGV4dHJhX2RvYyA9IExhenkuZnJvbV92YWwgTm9uZVxuICAgIH1cbiAgOztcblxuICBsZXQgbm9fYXJnIG5hbWUgPVxuICAgIG5vX2FyZ19nZW5lcmFsIG5hbWUgfmlzX3JlcXVpcmVkOmZhbHNlIH5rZXlfdmFsdWU6Tm9uZSB+ZGVwcmVjYXRlZF9ob29rOk5vbmVcbiAgOztcblxuICBsZXQgbm9fYXJnX3JlcXVpcmVkIHYgbmFtZSA9XG4gICAgbWFwX2ZsYWdcbiAgICAgIChub19hcmdfZ2VuZXJhbCB+aXNfcmVxdWlyZWQ6dHJ1ZSB+a2V5X3ZhbHVlOk5vbmUgfmRlcHJlY2F0ZWRfaG9vazpOb25lKVxuICAgICAgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAtPiB2XG4gICAgICAgIHwgZmFsc2UgLT4gYXNzZXJ0IGZhbHNlKVxuICAgICAgbmFtZVxuICA7O1xuXG4gIGxldCBub19hcmdfcmVnaXN0ZXIgfmtleSB+dmFsdWUgbmFtZSA9XG4gICAgbm9fYXJnX2dlbmVyYWxcbiAgICAgIG5hbWVcbiAgICAgIH5pc19yZXF1aXJlZDpmYWxzZVxuICAgICAgfmtleV92YWx1ZTooU29tZSAoa2V5LCB2YWx1ZSkpXG4gICAgICB+ZGVwcmVjYXRlZF9ob29rOk5vbmVcbiAgOztcblxuICBsZXQgbm9fYXJnX3NvbWUgdmFsdWUgPVxuICAgIG1hcF9mbGFnIG5vX2FyZyB+ZjooZnVuY3Rpb25cbiAgICAgIHwgdHJ1ZSAtPiBTb21lIHZhbHVlXG4gICAgICB8IGZhbHNlIC0+IE5vbmUpXG4gIDs7XG5cbiAgbGV0IGxpc3RlZCBhcmdfdHlwZSBuYW1lID1cbiAgICBsZXQga2V5ID0gRW52LldpdGhfZGVmYXVsdC5LZXkuY3JlYXRlIH5kZWZhdWx0OltdIH5uYW1lIFslc2V4cF9vZjogXyBsaXN0XSBpblxuICAgIGxldCByZWFkIGVudiA9XG4gICAgICBtYXRjaCBMaXN0LnJldiAoRW52LldpdGhfZGVmYXVsdC5maW5kIGVudiBrZXkpIHdpdGhcbiAgICAgIHwgW10gLT4gUGFyc2luZ19vdXRjb21lLnJldHVybl9ub19hcmcgW11cbiAgICAgIHwgXyA6OiBfIGFzIHZhbHVlX2xpc3QgLT4gUGFyc2luZ19vdXRjb21lLnJldHVybl93aXRoX2FyZyB2YWx1ZV9saXN0XG4gICAgaW5cbiAgICBsZXQgd3JpdGUgZW52IGFyZyA9IEVudi5XaXRoX2RlZmF1bHQuY2hhbmdlIGVudiBrZXkgfmY6KGZ1biBsaXN0IC0+IGFyZyA6OiBsaXN0KSBpblxuICAgIGFyZ19mbGFnIG5hbWUgYXJnX3R5cGUgcmVhZCB3cml0ZSBOdW1fb2NjdXJyZW5jZXMuYW55XG4gIDs7XG5cbiAgbGV0IG9uZV9vcl9tb3JlX2FzX3BhaXIgYXJnX3R5cGUgbmFtZSA9XG4gICAgbGV0IGtleSA9IEVudi5XaXRoX2RlZmF1bHQuS2V5LmNyZWF0ZSB+ZGVmYXVsdDpbXSB+bmFtZSBbJXNleHBfb2Y6IF8gbGlzdF0gaW5cbiAgICBsZXQgcmVhZCBlbnYgPVxuICAgICAgbWF0Y2ggTGlzdC5yZXYgKEVudi5XaXRoX2RlZmF1bHQuZmluZCBlbnYga2V5KSB3aXRoXG4gICAgICB8IGZpcnN0IDo6IHJlc3QgLT4gUGFyc2luZ19vdXRjb21lLnJldHVybl93aXRoX2FyZyAoZmlyc3QsIHJlc3QpXG4gICAgICB8IFtdIC0+XG4gICAgICAgIFBhcnNpbmdfb3V0Y29tZS5lcnJvclxuICAgICAgICAgIH5oYXNfYXJnOmZhbHNlXG4gICAgICAgICAgKGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzXG4gICAgICAgICAgICAoRXJyb3Iub2Zfc3RyaW5nIChzcHJpbnRmIFwibWlzc2luZyByZXF1aXJlZCBmbGFnOiAlc1wiIG5hbWUpKSlcbiAgICBpblxuICAgIGxldCB3cml0ZSBlbnYgYXJnID0gRW52LldpdGhfZGVmYXVsdC5jaGFuZ2UgZW52IGtleSB+ZjooZnVuIHEgLT4gYXJnIDo6IHEpIGluXG4gICAgYXJnX2ZsYWcgbmFtZSBhcmdfdHlwZSByZWFkIHdyaXRlIE51bV9vY2N1cnJlbmNlcy5hdF9sZWFzdF9vbmNlXG4gIDs7XG5cbiAgbGV0IG9uZV9vcl9tb3JlX2FzX2xpc3QgYXJnX3R5cGUgPVxuICAgIG9uZV9vcl9tb3JlX2FzX3BhaXIgYXJnX3R5cGUgfD4gbWFwX2ZsYWcgfmY6KGZ1biAoeCwgeHMpIC0+IHggOjogeHMpXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9nZW5lcmFsIH5jb21wbGV0ZSB+ZGVwcmVjYXRlZF9ob29rIG5hbWUgPVxuICAgIGxldCBrZXkgPSBFbnYuS2V5LmNyZWF0ZSB+bmFtZSBbJXNleHBfb2Y6IHN0cmluZyBsaXN0XSBpblxuICAgIGxldCBhY3Rpb24gZW52IGNtZF9saW5lID0gRW52LnNldCBlbnYgfmtleSB+ZGF0YTpjbWRfbGluZSBpblxuICAgIGxldCByZWFkIGVudiA9XG4gICAgICBtYXRjaCBFbnYuZmluZCBlbnYga2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBQYXJzaW5nX291dGNvbWUucmV0dXJuX25vX2FyZyBOb25lXG4gICAgICB8IFNvbWUgXyBhcyB2YWx1ZSAtPiBQYXJzaW5nX291dGNvbWUucmV0dXJuX3dpdGhfYXJnIHZhbHVlXG4gICAgaW5cbiAgICBsZXQgYWN0aW9uID1cbiAgICAgIG1hdGNoIGRlcHJlY2F0ZWRfaG9vayB3aXRoXG4gICAgICB8IE5vbmUgLT4gYWN0aW9uXG4gICAgICB8IFNvbWUgZiAtPlxuICAgICAgICBmdW4gZW52IHggLT5cbiAgICAgICAgICBmIHg7XG4gICAgICAgICAgYWN0aW9uIGVudiB4XG4gICAgaW5cbiAgICB7IGFjdGlvbiA9IFJlc3QgKGFjdGlvbiwgY29tcGxldGUpXG4gICAgOyByZWFkXG4gICAgOyBudW1fb2NjdXJyZW5jZXMgPSBOdW1fb2NjdXJyZW5jZXMuYXRfbW9zdF9vbmNlXG4gICAgOyBleHRyYV9kb2MgPSBMYXp5LmZyb21fdmFsIE5vbmVcbiAgICB9XG4gIDs7XG5cbiAgbGV0IG5vX2FyZ19hYm9ydCB+ZXhpdCBfbmFtZSA9XG4gICAgeyBhY3Rpb24gPSBOb19hcmcgKGZ1biBfIC0+IE5vdGhpbmcudW5yZWFjaGFibGVfY29kZSAoZXhpdCAoKSkpXG4gICAgOyBudW1fb2NjdXJyZW5jZXMgPSBOdW1fb2NjdXJyZW5jZXMuYXRfbW9zdF9vbmNlXG4gICAgOyByZWFkID1cbiAgICAgICAgKGZ1biBfIC0+XG4gICAgICAgICAgKCogV2Uga25vdyB0aGF0IHRoZSBmbGFnIHdhc24ndCBwYXNzZWQgaGVyZSBiZWNhdXNlIGlmIGl0IHdhcyBwYXNzZWRcbiAgICAgICAgICAgICAgdGhlbiB0aGUgW2FjdGlvbl0gd291bGQgaGF2ZSBjYWxsZWQgW2V4aXRdLiAqKVxuICAgICAgICAgIFBhcnNpbmdfb3V0Y29tZS5yZXR1cm5fbm9fYXJnICgpKVxuICAgIDsgZXh0cmFfZG9jID0gTGF6eS5mcm9tX3ZhbCBOb25lXG4gICAgfVxuICA7O1xuXG4gIGxldCBlc2NhcGUgbmFtZSA9IGVzY2FwZV9nZW5lcmFsIH5jb21wbGV0ZTpOb25lIH5kZXByZWNhdGVkX2hvb2s6Tm9uZSBuYW1lXG5cbiAgbGV0IGVzY2FwZV93aXRoX2F1dG9jb21wbGV0ZSB+Y29tcGxldGUgbmFtZSA9XG4gICAgZXNjYXBlX2dlbmVyYWwgfmNvbXBsZXRlOihTb21lIGNvbXBsZXRlKSB+ZGVwcmVjYXRlZF9ob29rOk5vbmUgbmFtZVxuICA7O1xuXG4gIG1vZHVsZSBEZXByZWNhdGVkID0gc3RydWN0XG4gICAgbGV0IG5vX2FyZyB+aG9vayBuYW1lID1cbiAgICAgIG5vX2FyZ19nZW5lcmFsIH5pc19yZXF1aXJlZDpmYWxzZSB+ZGVwcmVjYXRlZF9ob29rOihTb21lIGhvb2spIH5rZXlfdmFsdWU6Tm9uZSBuYW1lXG4gICAgOztcblxuICAgIGxldCBlc2NhcGUgfmhvb2sgPSBlc2NhcGVfZ2VuZXJhbCB+Y29tcGxldGU6Tm9uZSB+ZGVwcmVjYXRlZF9ob29rOihTb21lIGhvb2spXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBQYXRoIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBlbXB0eSA6IHRcbiAgdmFsIGNyZWF0ZSA6IHBhdGhfdG9fZXhlOnN0cmluZyAtPiB0XG4gIHZhbCBvZl9wYXJ0cyA6IHN0cmluZyBsaXN0IC0+IHRcbiAgdmFsIGFwcGVuZCA6IHQgLT4gc3ViY29tbWFuZDpzdHJpbmcgLT4gdFxuICB2YWwgcmVwbGFjZV9maXJzdCA6IHQgLT4gZnJvbTpzdHJpbmcgLT4gdG9fOnN0cmluZyAtPiB0XG4gIHZhbCBwYXJ0cyA6IHQgLT4gc3RyaW5nIGxpc3RcbiAgdmFsIHBhcnRzX2V4ZV9iYXNlbmFtZSA6IHQgLT4gc3RyaW5nIGxpc3RcbiAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG4gIHZhbCB0b19zdHJpbmdfZG90cyA6IHQgLT4gc3RyaW5nXG4gIHZhbCBwb3BfaGVscCA6IHQgLT4gdFxuICB2YWwgbGVuZ3RoIDogdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogdCAtPiBib29sXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nIGxpc3RcblxuICBsZXQgZW1wdHkgPSBbXVxuICBsZXQgY3JlYXRlIH5wYXRoX3RvX2V4ZSA9IFsgcGF0aF90b19leGUgXVxuICBsZXQgb2ZfcGFydHMgcGFydHMgPSBMaXN0LnJldiBwYXJ0c1xuICBsZXQgYXBwZW5kIHQgfnN1YmNvbW1hbmQgPSBzdWJjb21tYW5kIDo6IHRcbiAgbGV0IHBhcnRzID0gTGlzdC5yZXZcblxuICBsZXQgcGFydHNfZXhlX2Jhc2VuYW1lIHQgPVxuICAgIG1hdGNoIExpc3QucmV2IHQgd2l0aFxuICAgIHwgW10gLT4gW11cbiAgICB8IGhkIDo6IHRsIC0+IEZpbGVuYW1lX2Jhc2UuYmFzZW5hbWUgaGQgOjogdGxcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nIHQgPSB1bndvcmRzIChwYXJ0c19leGVfYmFzZW5hbWUgdClcbiAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoXG5cbiAgbGV0IHJlcGxhY2VfZmlyc3QgdCB+ZnJvbSB+dG9fID1cbiAgICBsZXQgcmVjIGF1eCBwYXJ0cyB+YWNjIH5mcm9tIH50b18gPVxuICAgICAgbWF0Y2ggcGFydHMgd2l0aFxuICAgICAgfCBbXSAtPiBhY2NcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgaWYgU3RyaW5nLiggPSApIGhkIGZyb21cbiAgICAgICAgdGhlbiBMaXN0LnJldl9hcHBlbmQgdGwgKHRvXyA6OiBhY2MpXG4gICAgICAgIGVsc2UgYXV4IHRsIH5hY2M6KGhkIDo6IGFjYykgfmZyb20gfnRvX1xuICAgIGluXG4gICAgYXV4IChwYXJ0cyB0KSB+YWNjOltdIH5mcm9tIH50b19cbiAgOztcblxuICBsZXQgcG9wX2hlbHAgPSBmdW5jdGlvblxuICAgIHwgXCJoZWxwXCIgOjogdCAtPiB0XG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmdfZG90cyB0ID1cbiAgICAobWF0Y2ggdCB3aXRoXG4gICAgIHwgW10gLT4gW11cbiAgICAgfCBsYXN0IDo6IGluaXQgLT4gbGFzdCA6OiBMaXN0Lm1hcCBpbml0IH5mOihGbi5jb25zdCBcIi5cIikpXG4gICAgfD4gdG9fc3RyaW5nXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5ID0gTGlzdC5pc19lbXB0eVxuZW5kXG5cbm1vZHVsZSBBbm9ucyA9IHN0cnVjdFxuICBtb2R1bGUgR3JhbW1hciA6IHNpZ1xuICAgIHR5cGUgdCA9IFNoYXBlLkFub25zLkdyYW1tYXIudFxuXG4gICAgdmFsIHplcm8gOiB0XG4gICAgdmFsIG9uZSA6IHN0cmluZyAtPiB0XG4gICAgdmFsIG1hbnkgOiB0IC0+IHRcbiAgICB2YWwgbWF5YmUgOiB0IC0+IHRcbiAgICB2YWwgbWF5YmVfaWRlbXBvdGVudCA6IHQgLT4gdFxuICAgIHZhbCBjb25jYXQgOiB0IGxpc3QgLT4gdFxuICAgIHZhbCBhZF9ob2MgOiB1c2FnZTpzdHJpbmcgLT4gdFxuXG4gICAgaW5jbHVkZSBJbnZhcmlhbnQuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgbmFtZXMgOiB0IC0+IHN0cmluZyBsaXN0XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFNoYXBlLkFub25zLkdyYW1tYXIudCA9XG4gICAgICB8IFplcm9cbiAgICAgIHwgT25lIG9mIHN0cmluZ1xuICAgICAgfCBNYW55IG9mIHRcbiAgICAgIHwgTWF5YmUgb2YgdFxuICAgICAgfCBDb25jYXQgb2YgdCBsaXN0XG4gICAgICB8IEFkX2hvYyBvZiBzdHJpbmdcblxuICAgIGxldCBpbnZhcmlhbnQgPSBTaGFwZS5Bbm9ucy5HcmFtbWFyLmludmFyaWFudFxuICAgIGxldCB1c2FnZSA9IFNoYXBlLkFub25zLkdyYW1tYXIudXNhZ2VcblxuICAgIGxldCByZWMgaXNfZml4ZWRfYXJpdHkgPSBmdW5jdGlvblxuICAgICAgfCBaZXJvIC0+IHRydWVcbiAgICAgIHwgT25lIF8gLT4gdHJ1ZVxuICAgICAgfCBNYW55IF8gLT4gZmFsc2VcbiAgICAgIHwgTWF5YmUgXyAtPiBmYWxzZVxuICAgICAgfCBBZF9ob2MgXyAtPiBmYWxzZVxuICAgICAgfCBDb25jYXQgdHMgLT5cbiAgICAgICAgKG1hdGNoIExpc3QucmV2IHRzIHdpdGhcbiAgICAgICAgIHwgW10gLT4gZmFpbHdpdGggXCJidWcgaW4gY29tbWFuZC5tbFwiXG4gICAgICAgICB8IGxhc3QgOjogb3RoZXJzIC0+XG4gICAgICAgICAgIGFzc2VydCAoTGlzdC5mb3JfYWxsIG90aGVycyB+Zjppc19maXhlZF9hcml0eSk7XG4gICAgICAgICAgIGlzX2ZpeGVkX2FyaXR5IGxhc3QpXG4gICAgOztcblxuICAgIGxldCByZWMgbmFtZXMgPSBmdW5jdGlvblxuICAgICAgfCBaZXJvIC0+IFtdXG4gICAgICB8IE9uZSBzIC0+IFsgcyBdXG4gICAgICB8IE1hbnkgdCAtPiBuYW1lcyB0XG4gICAgICB8IE1heWJlIHQgLT4gbmFtZXMgdFxuICAgICAgfCBBZF9ob2MgcyAtPiBbIHMgXVxuICAgICAgfCBDb25jYXQgdHMgLT4gTGlzdC5jb25jYXRfbWFwIHRzIH5mOm5hbWVzXG4gICAgOztcblxuICAgIGxldCB6ZXJvID0gWmVyb1xuICAgIGxldCBvbmUgbmFtZSA9IE9uZSBuYW1lXG5cbiAgICBsZXQgbWFueSA9IGZ1bmN0aW9uXG4gICAgICB8IFplcm8gLT4gWmVybyAoKiBzdHJhbmdlLCBidXQgbm90IG5vbi1zZW5zZSAqKVxuICAgICAgfCB0IC0+XG4gICAgICAgIGlmIG5vdCAoaXNfZml4ZWRfYXJpdHkgdClcbiAgICAgICAgdGhlblxuICAgICAgICAgIGZhaWx3aXRoZlxuICAgICAgICAgICAgXCJpdGVyYXRpb24gb2YgdmFyaWFibGUtbGVuZ3RoIGdyYW1tYXJzIHN1Y2ggYXMgJXMgaXMgZGlzYWxsb3dlZFwiXG4gICAgICAgICAgICAodXNhZ2UgdClcbiAgICAgICAgICAgICgpO1xuICAgICAgICBNYW55IHRcbiAgICA7O1xuXG4gICAgbGV0IG1heWJlID0gZnVuY3Rpb25cbiAgICAgIHwgWmVybyAtPiBaZXJvICgqIHN0cmFuZ2UsIGJ1dCBub3Qgbm9uLXNlbnNlICopXG4gICAgICB8IHQgLT4gTWF5YmUgdFxuICAgIDs7XG5cbiAgICBsZXQgbWF5YmVfaWRlbXBvdGVudCA9IGZ1bmN0aW9uXG4gICAgICB8IFplcm8gLT4gWmVybyAoKiBzdHJhbmdlLCBidXQgbm90IG5vbi1zZW5zZSAqKVxuICAgICAgfCBNYXliZSB0IC0+IE1heWJlIHRcbiAgICAgIHwgTWFueSB0IC0+IE1hbnkgdFxuICAgICAgfCB0IC0+IE1heWJlIHRcbiAgICA7O1xuXG4gICAgbGV0IGNvbmNhdCA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IFplcm9cbiAgICAgIHwgY2FyIDo6IGNkciAtPlxuICAgICAgICBsZXQgY2FyLCBjZHIgPVxuICAgICAgICAgIExpc3QuZm9sZCBjZHIgfmluaXQ6KGNhciwgW10pIH5mOihmdW4gKHQxLCBhY2MpIHQyIC0+XG4gICAgICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICAgICAgfCBaZXJvLCB0IHwgdCwgWmVybyAtPiB0LCBhY2NcbiAgICAgICAgICAgIHwgXywgXyAtPlxuICAgICAgICAgICAgICBpZiBpc19maXhlZF9hcml0eSB0MVxuICAgICAgICAgICAgICB0aGVuIHQyLCB0MSA6OiBhY2NcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZhaWx3aXRoZlxuICAgICAgICAgICAgICAgICAgXCJ0aGUgZ3JhbW1hciAlcyBmb3IgYW5vbnltb3VzIGFyZ3VtZW50cyBpcyBub3Qgc3VwcG9ydGVkIGJlY2F1c2UgdGhlcmUgXFxcbiAgICAgICAgICAgICAgICAgICBpcyB0aGUgcG9zc2liaWxpdHkgZm9yIGFyZ3VtZW50cyAoJXMpIGZvbGxvd2luZyBhIHZhcmlhYmxlIG51bWJlciBvZiBcXFxuICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyAoJXMpLiAgU3VwcG9ydGluZyBzdWNoIGdyYW1tYXJzIHdvdWxkIGNvbXBsaWNhdGUgdGhlIFxcXG4gICAgICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gc2lnbmlmaWNhbnRseS5cIlxuICAgICAgICAgICAgICAgICAgKHVzYWdlIChDb25jYXQgKExpc3QucmV2ICh0MiA6OiB0MSA6OiBhY2MpKSkpXG4gICAgICAgICAgICAgICAgICAodXNhZ2UgdDIpXG4gICAgICAgICAgICAgICAgICAodXNhZ2UgdDEpXG4gICAgICAgICAgICAgICAgICAoKSlcbiAgICAgICAgaW5cbiAgICAgICAgKG1hdGNoIGNkciB3aXRoXG4gICAgICAgICB8IFtdIC0+IGNhclxuICAgICAgICAgfCBfIDo6IF8gLT4gQ29uY2F0IChMaXN0LnJldiAoY2FyIDo6IGNkcikpKVxuICAgIDs7XG5cbiAgICBsZXQgYWRfaG9jIH51c2FnZSA9IEFkX2hvYyB1c2FnZVxuICBlbmRcblxuICBtb2R1bGUgUGFyc2VyIDogc2lnXG4gICAgbW9kdWxlIEJhc2ljIDogc2lnXG4gICAgICB0eXBlICsnYSB0XG5cbiAgICAgIG1vZHVsZSBGb3Jfb3BlbmluZyA6IHNpZ1xuICAgICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuICAgICAgICB2YWwgKCA8Kj4gKSA6ICgnYSAtPiAnYikgdCAtPiAnYSB0IC0+ICdiIHRcbiAgICAgICAgdmFsICggPj58ICkgOiAnYSB0IC0+ICgnYSAtPiAnYikgLT4gJ2IgdFxuICAgICAgZW5kXG5cbiAgICAgIHZhbCBmcm9tX2VudiA6IChFbnYudCAtPiAnYSkgLT4gJ2EgdFxuICAgIGVuZFxuXG4gICAgdHlwZSArJ2EgdCA9ICdhIFBhcnNpbmdfb3V0Y29tZS50IEJhc2ljLnRcblxuICAgIHZhbCBvbmUgOiBuYW1lOnN0cmluZyAtPiAnYSBBcmdfdHlwZS50IC0+ICdhIHRcbiAgICB2YWwgbWF5YmUgOiAnYSB0IC0+ICdhIG9wdGlvbiB0XG4gICAgdmFsIHNlcXVlbmNlIDogJ2EgdCAtPiAnYSBsaXN0IHRcbiAgICB2YWwgc3RvcF9wYXJzaW5nIDogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGZpbmFsX3ZhbHVlIDogJ2EgQmFzaWMudCAtPiBFbnYudCAtPiAnYVxuXG4gICAgbW9kdWxlIENvbnN1bWVfcmVzdWx0IDogc2lnXG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID1cbiAgICAgICAgeyAoKiBJZiBlbWFjcyBoaWdobGlnaHRzIFtwYXJzZXJdIGFzIGlmIGl0IHdlcmUgYSBrZXl3b3JkLCB0aGF0J3Mgb25seSBiZWNhdXNlXG4gICAgICAgICAgICAgW3BhcnNlcl0gd2FzIGEga2V5d29yZCBpbiBjYW1scDQuIFtwYXJzZXJdIGlzIGEgcmVndWxhciBuYW1lIGluIE9DYW1sLiAqKVxuICAgICAgICAgIHBhcnNlciA6ICdhIEJhc2ljLnRcbiAgICAgICAgOyBwYXJzZV9mbGFncyA6IGJvb2xcbiAgICAgICAgOyB1cGRhdGVfZW52IDogRW52LnQgLT4gRW52LnRcbiAgICAgICAgfVxuICAgIGVuZFxuXG4gICAgdmFsIGNvbnN1bWUgOiAnYSBCYXNpYy50IC0+IHN0cmluZyAtPiBmb3JfY29tcGxldGlvbjpib29sIC0+ICdhIENvbnN1bWVfcmVzdWx0LnRcbiAgICB2YWwgY29tcGxldGUgOiAnYSBCYXNpYy50IC0+IEVudi50IC0+IHBhcnQ6c3RyaW5nIC0+IE5vdGhpbmcudFxuXG4gICAgbW9kdWxlIEZvcl9vcGVuaW5nIDogc2lnXG4gICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuICAgICAgdmFsICggPCo+ICkgOiAoJ2EgLT4gJ2IpIHQgLT4gJ2EgdCAtPiAnYiB0XG4gICAgICB2YWwgKCA+PnwgKSA6ICdhIHQgLT4gKCdhIC0+ICdiKSAtPiAnYiB0XG4gICAgZW5kXG4gIGVuZCA9IHN0cnVjdFxuICAgIG1vZHVsZSBCYXNpYyA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgfCBEb25lIG9mIChFbnYudCAtPiAnYSlcbiAgICAgICAgfCBNb3JlIG9mICdhIG1vcmVcbiAgICAgICAgKCogQSBbVGVzdF0gd2lsbCAoZ2VuZXJhbGx5KSByZXR1cm4gYSBbRG9uZSBfXSB2YWx1ZSBpZiB0aGVyZSBpcyBubyBtb3JlIGlucHV0IGFuZFxuICAgICAgICAgICBhIFtNb3JlXSBwYXJzZXIgdG8gdXNlIGlmIHRoZXJlIGlzIGFueSBtb3JlIGlucHV0LiAqKVxuICAgICAgICB8IFRlc3Qgb2YgKG1vcmU6Ym9vbCAtPiAnYSB0KVxuICAgICAgICAoKiBJZiB3ZSdyZSBvbmx5IGNvbXBsZXRpbmcsIHdlIGNhbid0IHB1bGwgdmFsdWVzIG91dCwgYnV0IHdlIGNhbiBzdGlsbCBzdGVwIHRocm91Z2hcbiAgICAgICAgICAgW3RdcyAod2hpY2ggbWF5IGhhdmUgY29tcGxldGlvbiBzZXQgdXApLiAqKVxuICAgICAgICB8IE9ubHlfZm9yX2NvbXBsZXRpb24gb2YgcGFja2VkIGxpc3RcbiAgICAgICAgfCBTdG9wX3BhcnNpbmcgb2YgJ2EgdFxuXG4gICAgICBhbmQgJ2EgbW9yZSA9XG4gICAgICAgIHsgbmFtZSA6IHN0cmluZ1xuICAgICAgICA7IHBhcnNlIDogc3RyaW5nIC0+IGZvcl9jb21wbGV0aW9uOmJvb2wgLT4gJ2EgcGFyc2VfcmVzdWx0XG4gICAgICAgIDsgY29tcGxldGUgOiBDb21wbGV0ZXIudFxuICAgICAgICB9XG5cbiAgICAgIGFuZCBwYWNrZWQgPSBQYWNrZWQgOiAnYSB0IC0+IHBhY2tlZFxuXG4gICAgICBhbmQgJ2EgcGFyc2VfcmVzdWx0ID1cbiAgICAgICAgeyBwYXJzZXIgOiAnYSB0XG4gICAgICAgIDsgdXBkYXRlX2VudiA6IEVudi50IC0+IEVudi50XG4gICAgICAgIH1cblxuICAgICAgbGV0IHBhcnNlX21vcmUgeyBuYW1lOyBwYXJzZTsgY29tcGxldGUgfSB+ZiA9XG4gICAgICAgIGxldCBwYXJzZSBhcmcgfmZvcl9jb21wbGV0aW9uID1cbiAgICAgICAgICBsZXQgeyBwYXJzZXI7IHVwZGF0ZV9lbnYgfSA9IHBhcnNlIGFyZyB+Zm9yX2NvbXBsZXRpb24gaW5cbiAgICAgICAgICB7IHBhcnNlciA9IGYgcGFyc2VyOyB1cGRhdGVfZW52IH1cbiAgICAgICAgaW5cbiAgICAgICAgTW9yZSB7IG5hbWU7IHBhcnNlOyBjb21wbGV0ZSB9XG4gICAgICA7O1xuXG4gICAgICBsZXQgcGFja19mb3JfY29tcGxldGlvbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRG9uZSBfIC0+IFtdICgqIHdvbid0IGNvbXBsZXRlIG9yIGNvbnN1bWUgYW55dGhpbmcgKilcbiAgICAgICAgfCAoTW9yZSBfIHwgVGVzdCBfIHwgU3RvcF9wYXJzaW5nIF8pIGFzIHggLT4gWyBQYWNrZWQgeCBdXG4gICAgICAgIHwgT25seV9mb3JfY29tcGxldGlvbiBwcyAtPiBwc1xuICAgICAgOztcblxuICAgICAgbGV0IHJlYyAoIDwqPiApIHRfbGVmdCB0X3JpZ2h0ID1cbiAgICAgICAgbWF0Y2ggdF9sZWZ0LCB0X3JpZ2h0IHdpdGhcbiAgICAgICAgKCogW0RvbmVdICopXG4gICAgICAgIHwgRG9uZSBmLCBEb25lIHggLT5cbiAgICAgICAgICBEb25lXG4gICAgICAgICAgICAoZnVuIGVudiAtPlxuICAgICAgICAgICAgICBsZXQgZl9vdXRjb21lID0gZiBlbnYgaW5cbiAgICAgICAgICAgICAgbGV0IHhfb3V0Y29tZSA9IHggZW52IGluXG4gICAgICAgICAgICAgIGZfb3V0Y29tZSB4X291dGNvbWUpXG4gICAgICAgICgqIG5leHQgc3RlcCBbTW9yZV0gKilcbiAgICAgICAgfCBNb3JlIG1vcmUsIF8gLT4gcGFyc2VfbW9yZSBtb3JlIH5mOihmdW4gdGwgLT4gdGwgPCo+IHRfcmlnaHQpXG4gICAgICAgIHwgRG9uZSBfLCBNb3JlIG1vcmUgLT4gcGFyc2VfbW9yZSBtb3JlIH5mOihmdW4gdHIgLT4gdF9sZWZ0IDwqPiB0cilcbiAgICAgICAgKCogbmV4dCBzdGVwIFtPbmx5X2Zvcl9jb21wbGV0aW9uXSAqKVxuICAgICAgICB8IE9ubHlfZm9yX2NvbXBsZXRpb24gXywgXyB8IERvbmUgXywgT25seV9mb3JfY29tcGxldGlvbiBfIC0+XG4gICAgICAgICAgT25seV9mb3JfY29tcGxldGlvbiAocGFja19mb3JfY29tcGxldGlvbiB0X2xlZnQgQCBwYWNrX2Zvcl9jb21wbGV0aW9uIHRfcmlnaHQpXG4gICAgICAgICgqIG5leHQgc3RlcCBbU3RvcF9wYXJzaW5nXSAqKVxuICAgICAgICB8IFN0b3BfcGFyc2luZyB0bCwgdHIgfCAoRG9uZSBfIGFzIHRsKSwgU3RvcF9wYXJzaW5nIHRyIC0+IFN0b3BfcGFyc2luZyAodGwgPCo+IHRyKVxuICAgICAgICAoKiBuZXh0IHN0ZXAgW1Rlc3RdICopXG4gICAgICAgIHwgVGVzdCB0ZXN0LCBfIC0+IFRlc3QgKGZ1biB+bW9yZSAtPiB0ZXN0IH5tb3JlIDwqPiB0X3JpZ2h0KVxuICAgICAgICB8IERvbmUgXywgVGVzdCB0ZXN0IC0+IFRlc3QgKGZ1biB+bW9yZSAtPiB0X2xlZnQgPCo+IHRlc3Qgfm1vcmUpXG4gICAgICA7O1xuXG4gICAgICBsZXQgcmV0dXJuIGEgPSBEb25lIChmdW4gXyAtPiBhKVxuICAgICAgbGV0ICggPj58ICkgdCBmID0gcmV0dXJuIGYgPCo+IHRcbiAgICAgIGxldCBmcm9tX2VudiBmID0gRG9uZSAoZnVuIGVudiAtPiBmIGVudilcblxuICAgICAgbW9kdWxlIEZvcl9vcGVuaW5nID0gc3RydWN0XG4gICAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgICAgbGV0ICggPCo+ICkgPSAoIDwqPiApXG4gICAgICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBvcGVuIEJhc2ljXG5cbiAgICB0eXBlICdhIHQgPSAnYSBQYXJzaW5nX291dGNvbWUudCBCYXNpYy50XG5cbiAgICBsZXQgKCA+PnwgKSB0IGYgPSB0ID4+fCBQYXJzaW5nX291dGNvbWUubWFwIH5mXG4gICAgbGV0ICggPCo+ICkgdF9sZWZ0IHRfcmlnaHQgPSByZXR1cm4gUGFyc2luZ19vdXRjb21lLiggPCo+ICkgPCo+IHRfbGVmdCA8Kj4gdF9yaWdodFxuICAgIGxldCByZXR1cm4gYSA9IHJldHVybiAoUGFyc2luZ19vdXRjb21lLnJldHVybiBhKVxuICAgIGxldCByZXR1cm5fd2l0aF9hcmcgYSA9IERvbmUgKGZ1biBfIC0+IFBhcnNpbmdfb3V0Y29tZS5yZXR1cm5fd2l0aF9hcmcgYSlcbiAgICBsZXQgc3RvcF9wYXJzaW5nIHQgPSBTdG9wX3BhcnNpbmcgdFxuXG4gICAgbGV0IG9uZV9tb3JlIH5uYW1lIGFyZ190eXBlID1cbiAgICAgIGxldCBwYXJzZSBhbm9uIH5mb3JfY29tcGxldGlvbiA9XG4gICAgICAgIG1hdGNoIEFyZ190eXBlLnBhcnNlIGFyZ190eXBlIGFub24gd2l0aFxuICAgICAgICB8IEVycm9yIGVycm9yIC0+XG4gICAgICAgICAgaWYgZm9yX2NvbXBsZXRpb25cbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAoKiB3ZSBkb24ndCAqcmVhbGx5KiBjYXJlIGFib3V0IHRoaXMgdmFsdWUsIHNvIGp1c3QgcHV0IGluIGEgZHVtbXkgdmFsdWUgc29cbiAgICAgICAgICAgICAgIGNvbXBsZXRpb24gY2FuIGNvbnRpbnVlICopXG4gICAgICAgICAgICB7IHBhcnNlciA9IE9ubHlfZm9yX2NvbXBsZXRpb24gW107IHVwZGF0ZV9lbnYgPSBGbi5pZCB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGllIFwiZmFpbGVkIHRvIHBhcnNlICVzIHZhbHVlICVTXFxuJXNcIiBuYW1lIGFub24gKEVycm9yLnRvX3N0cmluZ19odW0gZXJyb3IpICgpXG4gICAgICAgIHwgT2sgdiAtPlxuICAgICAgICAgIHsgcGFyc2VyID0gcmV0dXJuX3dpdGhfYXJnIHZcbiAgICAgICAgICA7IHVwZGF0ZV9lbnYgPVxuICAgICAgICAgICAgICAoZnVuIGVudiAtPlxuICAgICAgICAgICAgICAgIE9wdGlvbi5mb2xkIChBcmdfdHlwZS5rZXkgYXJnX3R5cGUpIH5pbml0OmVudiB+ZjooZnVuIGVudiBrZXkgLT5cbiAgICAgICAgICAgICAgICAgIEVudi5tdWx0aV9hZGQgZW52IH5rZXkgfmRhdGE6dikpXG4gICAgICAgICAgfVxuICAgICAgaW5cbiAgICAgIE1vcmUgeyBuYW1lOyBwYXJzZTsgY29tcGxldGUgPSBBcmdfdHlwZS5jb21wbGV0ZSBhcmdfdHlwZSB9XG4gICAgOztcblxuICAgIGxldCBvbmUgfm5hbWUgYXJnX3R5cGUgPVxuICAgICAgVGVzdFxuICAgICAgICAoZnVuIH5tb3JlIC0+XG4gICAgICAgICAgaWYgbW9yZVxuICAgICAgICAgIHRoZW4gb25lX21vcmUgfm5hbWUgYXJnX3R5cGVcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBEb25lXG4gICAgICAgICAgICAgIChmdW4gXyAtPlxuICAgICAgICAgICAgICAgIFBhcnNpbmdfb3V0Y29tZS5lcnJvclxuICAgICAgICAgICAgICAgICAgfmhhc19hcmc6ZmFsc2VcbiAgICAgICAgICAgICAgICAgIChgTWlzc2luZ19yZXF1aXJlZF9mbGFnc1xuICAgICAgICAgICAgICAgICAgICAoRXJyb3Iub2Zfc3RyaW5nIChzcHJpbnRmIFwibWlzc2luZyBhbm9ueW1vdXMgYXJndW1lbnQ6ICVzXCIgbmFtZSkpKSkpXG4gICAgOztcblxuICAgIGxldCBtYXliZSB0ID1cbiAgICAgIFRlc3RcbiAgICAgICAgKGZ1biB+bW9yZSAtPlxuICAgICAgICAgIGlmIG1vcmUgdGhlbiByZXR1cm5fd2l0aF9hcmcgKGZ1biBhIC0+IFNvbWUgYSkgPCo+IHQgZWxzZSByZXR1cm4gTm9uZSlcbiAgICA7O1xuXG4gICAgbGV0IHNlcXVlbmNlIHQgPVxuICAgICAgbGV0IHJlYyBsb29wID1cbiAgICAgICAgVGVzdFxuICAgICAgICAgIChmdW4gfm1vcmUgLT5cbiAgICAgICAgICAgIGlmIG1vcmUgdGhlbiByZXR1cm4gKGZ1biB2IGFjYyAtPiB2IDo6IGFjYykgPCo+IHQgPCo+IGxvb3AgZWxzZSByZXR1cm4gW10pXG4gICAgICBpblxuICAgICAgbG9vcFxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGZpbmFsX3ZhbHVlIHQgZW52ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBEb25lIGEgLT4gYSBlbnZcbiAgICAgIHwgU3RvcF9wYXJzaW5nIHQgLT4gZmluYWxfdmFsdWUgdCBlbnZcbiAgICAgIHwgVGVzdCBmIC0+IGZpbmFsX3ZhbHVlIChmIH5tb3JlOmZhbHNlKSBlbnZcbiAgICAgIHwgTW9yZSBfIC0+XG4gICAgICAgICgqIHRoaXMgZG9lc24ndCBoYXBwZW4gYmVjYXVzZSBhbGwgb2NjdXJyZW5jZXMgb2YgW01vcmVdIGFyZSBwcm90ZWN0ZWRcbiAgICAgICAgICAgYnkgW1Rlc3RdLCB3aGljaCBtZWFucyB0aGVyZSB3aWxsIGFsd2F5cyBiZSBhbiBleHRyYSBhcmd1bWVudCB0byBnaXZlXG4gICAgICAgICAgIGJlZm9yZSByZXF1ZXN0aW5nIHRoZSBmaW5hbCB2YWx1ZSAqKVxuICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICAgIHwgT25seV9mb3JfY29tcGxldGlvbiBfIC0+XG4gICAgICAgIGZhaWx3aXRoIFwiQlVHOiBhc2tlZCBmb3IgZmluYWwgdmFsdWUgd2hlbiBkb2luZyBjb21wbGV0aW9uXCJcbiAgICA7O1xuXG4gICAgbW9kdWxlIENvbnN1bWVfcmVzdWx0ID0gc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID1cbiAgICAgICAgeyBwYXJzZXIgOiAnYSBCYXNpYy50XG4gICAgICAgIDsgcGFyc2VfZmxhZ3MgOiBib29sXG4gICAgICAgIDsgdXBkYXRlX2VudiA6IEVudi50IC0+IEVudi50XG4gICAgICAgIH1cbiAgICBlbmRcblxuICAgIGxldCByZWMgY29uc3VtZVxuICAgICAgOiB0eXBlIGEuIGEgQmFzaWMudCAtPiBzdHJpbmcgLT4gZm9yX2NvbXBsZXRpb246Ym9vbCAtPiBhIENvbnN1bWVfcmVzdWx0LnRcbiAgICAgID1cbiAgICAgIGZ1biB0IGFyZyB+Zm9yX2NvbXBsZXRpb24gLT5cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBEb25lIF8gLT4gZGllIFwidG9vIG1hbnkgYW5vbnltb3VzIGFyZ3VtZW50c1wiICgpXG4gICAgICB8IFRlc3QgZiAtPiBjb25zdW1lIChmIH5tb3JlOnRydWUpIGFyZyB+Zm9yX2NvbXBsZXRpb25cbiAgICAgIHwgTW9yZSB7IHBhcnNlOyBfIH0gLT5cbiAgICAgICAgbGV0IHsgcGFyc2VyOyB1cGRhdGVfZW52IH0gPSBwYXJzZSBhcmcgfmZvcl9jb21wbGV0aW9uIGluXG4gICAgICAgIHsgcGFyc2VyOyBwYXJzZV9mbGFncyA9IHRydWU7IHVwZGF0ZV9lbnYgfVxuICAgICAgfCBTdG9wX3BhcnNpbmcgdCAtPiB7IChjb25zdW1lIHQgYXJnIH5mb3JfY29tcGxldGlvbikgd2l0aCBwYXJzZV9mbGFncyA9IGZhbHNlIH1cbiAgICAgIHwgT25seV9mb3JfY29tcGxldGlvbiBwYWNrZWQgLT5cbiAgICAgICAgKG1hdGNoIHBhY2tlZCB3aXRoXG4gICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgIHsgcGFyc2VyID0gT25seV9mb3JfY29tcGxldGlvbiBbXTsgcGFyc2VfZmxhZ3MgPSB0cnVlOyB1cGRhdGVfZW52ID0gRm4uaWQgfVxuICAgICAgICAgfCBQYWNrZWQgdCA6OiByZXN0IC0+XG4gICAgICAgICAgIGxldCAoeyB1cGRhdGVfZW52OyBwYXJzZV9mbGFnczsgcGFyc2VyIH0gOiBfIENvbnN1bWVfcmVzdWx0LnQpID1cbiAgICAgICAgICAgICBjb25zdW1lIHQgYXJnIH5mb3JfY29tcGxldGlvblxuICAgICAgICAgICBpblxuICAgICAgICAgICB7IHVwZGF0ZV9lbnZcbiAgICAgICAgICAgOyBwYXJzZV9mbGFnc1xuICAgICAgICAgICA7IHBhcnNlciA9IE9ubHlfZm9yX2NvbXBsZXRpb24gKHBhY2tfZm9yX2NvbXBsZXRpb24gcGFyc2VyIEAgcmVzdClcbiAgICAgICAgICAgfSlcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBjb21wbGV0ZSA6IHR5cGUgYS4gYSBCYXNpYy50IC0+IEVudi50IC0+IHBhcnQ6c3RyaW5nIC0+IE5vdGhpbmcudCA9XG4gICAgICBmdW4gdCBlbnYgfnBhcnQgLT5cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBEb25lIF8gLT4gZXhpdCAwXG4gICAgICB8IFRlc3QgZiAtPiBjb21wbGV0ZSAoZiB+bW9yZTp0cnVlKSBlbnYgfnBhcnRcbiAgICAgIHwgTW9yZSB7IGNvbXBsZXRlOyBfIH0gLT4gQ29tcGxldGVyLnJ1bl9hbmRfZXhpdCBjb21wbGV0ZSBlbnYgfnBhcnRcbiAgICAgIHwgU3RvcF9wYXJzaW5nIHQgLT4gY29tcGxldGUgdCBlbnYgfnBhcnRcbiAgICAgIHwgT25seV9mb3JfY29tcGxldGlvbiB0IC0+XG4gICAgICAgIChtYXRjaCB0IHdpdGhcbiAgICAgICAgIHwgW10gLT4gZXhpdCAwXG4gICAgICAgICB8IFBhY2tlZCB0IDo6IF8gLT4gY29tcGxldGUgdCBlbnYgfnBhcnQpXG4gICAgOztcblxuICAgIG1vZHVsZSBGb3Jfb3BlbmluZyA9IHN0cnVjdFxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0ICggPCo+ICkgPSAoIDwqPiApXG4gICAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgICBlbmRcbiAgZW5kXG5cbiAgb3BlbiBQYXJzZXIuRm9yX29wZW5pbmdcblxuICB0eXBlICdhIHQgPVxuICAgIHsgcCA6ICdhIFBhcnNlci50XG4gICAgOyBncmFtbWFyIDogR3JhbW1hci50XG4gICAgfVxuXG4gIGxldCB0MiB0MSB0MiA9XG4gICAgeyBwID0gcmV0dXJuIChmdW4gYTEgYTIgLT4gYTEsIGEyKSA8Kj4gdDEucCA8Kj4gdDIucFxuICAgIDsgZ3JhbW1hciA9IEdyYW1tYXIuY29uY2F0IFsgdDEuZ3JhbW1hcjsgdDIuZ3JhbW1hciBdXG4gICAgfVxuICA7O1xuXG4gIGxldCB0MyB0MSB0MiB0MyA9XG4gICAgeyBwID0gcmV0dXJuIChmdW4gYTEgYTIgYTMgLT4gYTEsIGEyLCBhMykgPCo+IHQxLnAgPCo+IHQyLnAgPCo+IHQzLnBcbiAgICA7IGdyYW1tYXIgPSBHcmFtbWFyLmNvbmNhdCBbIHQxLmdyYW1tYXI7IHQyLmdyYW1tYXI7IHQzLmdyYW1tYXIgXVxuICAgIH1cbiAgOztcblxuICBsZXQgdDQgdDEgdDIgdDMgdDQgPVxuICAgIHsgcCA9IHJldHVybiAoZnVuIGExIGEyIGEzIGE0IC0+IGExLCBhMiwgYTMsIGE0KSA8Kj4gdDEucCA8Kj4gdDIucCA8Kj4gdDMucCA8Kj4gdDQucFxuICAgIDsgZ3JhbW1hciA9IEdyYW1tYXIuY29uY2F0IFsgdDEuZ3JhbW1hcjsgdDIuZ3JhbW1hcjsgdDMuZ3JhbW1hcjsgdDQuZ3JhbW1hciBdXG4gICAgfVxuICA7O1xuXG4gIGxldCBub3JtYWxpemUgc3RyID1cbiAgICAoKiBWZXJpZnkgdGhlIHN0cmluZyBpcyBub3QgZW1wdHkgb3Igc3Vycm91bmRlZCBieSB3aGl0ZXNwYWNlICopXG4gICAgbGV0IHN0cmxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgaWYgc3RybGVuID0gMCB0aGVuIGZhaWx3aXRoIFwiRW1wdHkgYW5vbnltb3VzIGFyZ3VtZW50IG5hbWUgcHJvdmlkZWRcIjtcbiAgICBpZiBTdHJpbmcuKCA8PiApIChTdHJpbmcuc3RyaXAgc3RyKSBzdHJcbiAgICB0aGVuIGZhaWx3aXRoZiBcImFyZ3VtZW50IG5hbWUgJVMgaGFzIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2VcIiBzdHIgKCk7XG4gICAgKCogSWYgdGhlIHN0cmluZyBjb250YWlucyBzcGVjaWFsIHN1cnJvdW5kaW5nIGNoYXJhY3RlcnMsIGRvbid0IGRvIGFueXRoaW5nICopXG4gICAgbGV0IGhhc19zcGVjaWFsX2NoYXJzID1cbiAgICAgIGxldCBzcGVjaWFsX2NoYXJzID1cbiAgICAgICAgU2V0Lm9mX2xpc3QgKG1vZHVsZSBDaGFyKSBbICc8JzsgJz4nOyAnWyc7ICddJzsgJygnOyAnKSc7ICd7JzsgJ30nIF1cbiAgICAgIGluXG4gICAgICBTdHJpbmcuZXhpc3RzIHN0ciB+ZjooU2V0Lm1lbSBzcGVjaWFsX2NoYXJzKVxuICAgIGluXG4gICAgaWYgaGFzX3NwZWNpYWxfY2hhcnMgdGhlbiBzdHIgZWxzZSBTdHJpbmcudXBwZXJjYXNlIHN0clxuICA7O1xuXG4gIGxldCAoICU6ICkgbmFtZSBhcmdfdHlwZSA9XG4gICAgbGV0IG5hbWUgPSBub3JtYWxpemUgbmFtZSBpblxuICAgIHsgcCA9IFBhcnNlci5vbmUgfm5hbWUgYXJnX3R5cGU7IGdyYW1tYXIgPSBHcmFtbWFyLm9uZSBuYW1lIH1cbiAgOztcblxuICBsZXQgbWFwX2Fub25zIHQgfmYgPSB7IHAgPSB0LnAgPj58IGY7IGdyYW1tYXIgPSB0LmdyYW1tYXIgfVxuICBsZXQgbWF5YmUgdCA9IHsgcCA9IFBhcnNlci5tYXliZSB0LnA7IGdyYW1tYXIgPSBHcmFtbWFyLm1heWJlIHQuZ3JhbW1hciB9XG5cbiAgbGV0IG1heWJlX3dpdGhfZGVmYXVsdCBkZWZhdWx0IHQgPVxuICAgIGxldCB0ID0gbWF5YmUgdCBpblxuICAgIHsgdCB3aXRoIHAgPSAodC5wID4+fCBmdW4gdiAtPiBPcHRpb24udmFsdWUgfmRlZmF1bHQgdikgfVxuICA7O1xuXG4gIGxldCBzZXF1ZW5jZSB0ID0geyBwID0gUGFyc2VyLnNlcXVlbmNlIHQucDsgZ3JhbW1hciA9IEdyYW1tYXIubWFueSB0LmdyYW1tYXIgfVxuICBsZXQgbm9uX2VtcHR5X3NlcXVlbmNlX2FzX3BhaXIgdCA9IHQyIHQgKHNlcXVlbmNlIHQpXG5cbiAgbGV0IG5vbl9lbXB0eV9zZXF1ZW5jZV9hc19saXN0IHQgPVxuICAgIGxldCB0ID0gbm9uX2VtcHR5X3NlcXVlbmNlX2FzX3BhaXIgdCBpblxuICAgIHsgdCB3aXRoIHAgPSAodC5wID4+fCBmdW4gKHgsIHhzKSAtPiB4IDo6IHhzKSB9XG4gIDs7XG5cbiAgbGV0IGVzY2FwZSB0ID0geyBwID0gUGFyc2VyLnN0b3BfcGFyc2luZyB0LnA7IGdyYW1tYXIgPSB0LmdyYW1tYXIgfVxuXG4gIG1vZHVsZSBEZXByZWNhdGVkID0gc3RydWN0XG4gICAgbGV0IGFkX2hvYyB+dXNhZ2VfYXJnID1cbiAgICAgIHsgcCA9XG4gICAgICAgICAgUGFyc2VyLnNlcXVlbmNlXG4gICAgICAgICAgICAoUGFyc2VyLm9uZSB+bmFtZTpcIldJTEwgTkVWRVIgQkUgUFJJTlRFRFwiIEFyZ190eXBlLkV4cG9ydC5zdHJpbmcpXG4gICAgICA7IGdyYW1tYXIgPSBHcmFtbWFyLmFkX2hvYyB+dXNhZ2U6dXNhZ2VfYXJnXG4gICAgICB9XG4gICAgOztcbiAgZW5kXG5lbmRcblxubW9kdWxlIENtZGxpbmUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IE5pbFxuICAgIHwgQ29ucyBvZiBzdHJpbmcgKiB0XG4gICAgfCBDb21wbGV0ZSBvZiBzdHJpbmdcbiAgW0BAZGVyaXZpbmcgY29tcGFyZV1cblxuICBsZXQgb2ZfbGlzdCBhcmdzID0gTGlzdC5mb2xkX3JpZ2h0IGFyZ3MgfmluaXQ6TmlsIH5mOihmdW4gYXJnIGFyZ3MgLT4gQ29ucyAoYXJnLCBhcmdzKSlcblxuICBsZXQgcmVjIHRvX2xpc3QgPSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IFtdXG4gICAgfCBDb25zICh4LCB4cykgLT4geCA6OiB0b19saXN0IHhzXG4gICAgfCBDb21wbGV0ZSB4IC0+IFsgeCBdXG4gIDs7XG5cbiAgbGV0IHJlYyBlbmRzX2luX2NvbXBsZXRlID0gZnVuY3Rpb25cbiAgICB8IENvbXBsZXRlIF8gLT4gdHJ1ZVxuICAgIHwgTmlsIC0+IGZhbHNlXG4gICAgfCBDb25zIChfLCBhcmdzKSAtPiBlbmRzX2luX2NvbXBsZXRlIGFyZ3NcbiAgOztcblxuICBsZXQgZXh0ZW5kIHQgfmV4dGVuZCB+cGF0aCA9XG4gICAgaWYgZW5kc19pbl9jb21wbGV0ZSB0XG4gICAgdGhlbiB0XG4gICAgZWxzZSAoXG4gICAgICBsZXQgcGF0aF9saXN0ID0gT3B0aW9uLnZhbHVlIH5kZWZhdWx0OltdIChMaXN0LnRsIChQYXRoLnBhcnRzIHBhdGgpKSBpblxuICAgICAgb2ZfbGlzdCAodG9fbGlzdCB0IEAgZXh0ZW5kIHBhdGhfbGlzdCkpXG4gIDs7XG5lbmRcblxubW9kdWxlIEtleV90eXBlID0gU2hhcGUuUHJpdmF0ZS5LZXlfdHlwZVxuXG5sZXQgYXNzZXJ0X25vX3VuZGVyc2NvcmVzIGtleV90eXBlIGZsYWdfb3Jfc3ViY29tbWFuZCA9XG4gIGlmIFN0cmluZy5leGlzdHMgZmxhZ19vcl9zdWJjb21tYW5kIH5mOihmdW4gYyAtPiBDaGFyLiggPSApIGMgJ18nKVxuICB0aGVuXG4gICAgZmFpbHdpdGhmXG4gICAgICBcIiVzICVzIGNvbnRhaW5zIGFuIHVuZGVyc2NvcmUuIFVzZSBhIGRhc2ggaW5zdGVhZC5cIlxuICAgICAgKEtleV90eXBlLnRvX3N0cmluZyBrZXlfdHlwZSlcbiAgICAgIGZsYWdfb3Jfc3ViY29tbWFuZFxuICAgICAgKClcbjs7XG5cbmxldCBub3JtYWxpemUga2V5X3R5cGUga2V5ID1cbiAgYXNzZXJ0X25vX3VuZGVyc2NvcmVzIGtleV90eXBlIGtleTtcbiAgbWF0Y2gga2V5X3R5cGUgd2l0aFxuICB8IEtleV90eXBlLkZsYWcgLT5cbiAgICBpZiBTdHJpbmcuZXF1YWwga2V5IFwiLVwiIHRoZW4gZmFpbHdpdGhmICFcImludmFsaWQgJXtLZXlfdHlwZX0gbmFtZTogJVNcIiBrZXlfdHlwZSBrZXkgKCk7XG4gICAgaWYgU3RyaW5nLmV4aXN0cyBrZXkgfmY6Q2hhci5pc193aGl0ZXNwYWNlXG4gICAgdGhlbiBmYWlsd2l0aGYgIVwiaW52YWxpZCAle0tleV90eXBlfSBuYW1lIChjb250YWlucyB3aGl0ZXNwYWNlKTogJVNcIiBrZXlfdHlwZSBrZXkgKCk7XG4gICAgaWYgU3RyaW5nLmlzX3ByZWZpeCB+cHJlZml4OlwiLVwiIGtleSB0aGVuIGtleSBlbHNlIFwiLVwiIF4ga2V5XG4gIHwgS2V5X3R5cGUuU3ViY29tbWFuZCAtPiBTdHJpbmcubG93ZXJjYXNlIGtleVxuOztcblxubGV0IGxvb2t1cF9leHBhbmQgPSBTaGFwZS5Qcml2YXRlLmxvb2t1cF9leHBhbmRcblxubGV0IGxvb2t1cF9leHBhbmRfd2l0aF9hbGlhc2VzIG1hcCBwcmVmaXgga2V5X3R5cGUgPVxuICBsZXQgYWxpc3QgPVxuICAgIExpc3QuY29uY2F0X21hcCAoTWFwLmRhdGEgbWFwKSB+ZjooZnVuIGZsYWcgLT5cbiAgICAgIGxldCB7IEZsYWcuSW50ZXJuYWwubmFtZVxuICAgICAgICAgIDsgYWxpYXNlc1xuICAgICAgICAgIDsgYWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHBcbiAgICAgICAgICA7IGFjdGlvbiA9IF9cbiAgICAgICAgICA7IGRvYyA9IF9cbiAgICAgICAgICA7IG51bV9vY2N1cnJlbmNlcyA9IF9cbiAgICAgICAgICA7IGNoZWNrX2F2YWlsYWJsZSA9IF9cbiAgICAgICAgICA7IG5hbWVfbWF0Y2hpbmdcbiAgICAgICAgICB9XG4gICAgICAgID1cbiAgICAgICAgZmxhZ1xuICAgICAgaW5cbiAgICAgIGxldCBkYXRhID0gZmxhZywgbmFtZV9tYXRjaGluZyBpblxuICAgICAgbGV0IGFsaWFzZXMgPSBhbGlhc2VzX2V4Y2x1ZGVkX2Zyb21faGVscCBAIGFsaWFzZXMgaW5cbiAgICAgIChuYW1lLCBkYXRhKSA6OiBMaXN0Lm1hcCBhbGlhc2VzIH5mOihmdW4gYWxpYXMgLT4gYWxpYXMsIGRhdGEpKVxuICBpblxuICBtYXRjaCBMaXN0LmZpbmRfYV9kdXAgYWxpc3QgfmNvbXBhcmU6KGZ1biAoczEsIF8pIChzMiwgXykgLT4gU3RyaW5nLmNvbXBhcmUgczEgczIpIHdpdGhcbiAgfCBOb25lIC0+IGxvb2t1cF9leHBhbmQgYWxpc3QgcHJlZml4IGtleV90eXBlXG4gIHwgU29tZSAoZmxhZywgXykgLT4gZmFpbHdpdGhmIFwibXVsdGlwbGUgZmxhZ3MgbmFtZWQgJXNcIiBmbGFnICgpXG47O1xuXG5tb2R1bGUgQ29tbWFuZF9iYXNlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBzdW1tYXJ5IDogc3RyaW5nXG4gICAgOyByZWFkbWUgOiAodW5pdCAtPiBzdHJpbmcpIG9wdGlvblxuICAgIDsgZmxhZ3MgOiBGbGFnLkludGVybmFsLnQgTWFwLk0oU3RyaW5nKS50XG4gICAgOyBhbm9ucyA6IHVuaXQgLT4gKFsgYFBhcnNlX2FyZ3MgXSAtPiBbIGBSdW5fbWFpbiBdIC0+IHVuaXQpIEFub25zLlBhcnNlci5CYXNpYy50XG4gICAgOyB1c2FnZSA6IEFub25zLkdyYW1tYXIudFxuICAgIH1cblxuICBtb2R1bGUgRGVwcmVjYXRlZCA9IHN0cnVjdFxuICAgIGxldCBzdWJjb21tYW5kX2NtcF9mc3QgKGEsIF8pIChjLCBfKSA9IGhlbHBfc2NyZWVuX2NvbXBhcmUgYSBjXG5cbiAgICBsZXQgZmxhZ3NfaGVscCA/KGRpc3BsYXlfaGVscF9mbGFncyA9IHRydWUpIHQgPVxuICAgICAgbGV0IGZsYWdzID0gTWFwLmRhdGEgdC5mbGFncyBpblxuICAgICAgbGV0IGZsYWdzID1cbiAgICAgICAgaWYgZGlzcGxheV9oZWxwX2ZsYWdzXG4gICAgICAgIHRoZW4gZmxhZ3NcbiAgICAgICAgZWxzZSBMaXN0LmZpbHRlciBmbGFncyB+ZjooZnVuIGYgLT4gU3RyaW5nLiggPD4gKSBmLm5hbWUgXCItaGVscFwiKVxuICAgICAgaW5cbiAgICAgIExpc3QuY29uY2F0X21hcCB+ZjpGbGFnLkludGVybmFsLkRlcHJlY2F0ZWQuaGVscCBmbGFnc1xuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBmb3JtYXR0ZWRfZmxhZ3MgdCA9XG4gICAgTWFwLmRhdGEgdC5mbGFnc1xuICAgIHw+IExpc3QubWFwIH5mOkZsYWcuSW50ZXJuYWwuYWxpZ25cbiAgICAoKiB0aGlzIHNvcnQgcHV0cyBvcHRpb25hbCBmbGFncyBhZnRlciByZXF1aXJlZCBvbmVzICopXG4gICAgfD4gTGlzdC5zb3J0IH5jb21wYXJlOihmdW4gYSBiIC0+IFN0cmluZy5jb21wYXJlIGEubmFtZSBiLm5hbWUpXG4gICAgfD4gU2hhcGUuRmxhZ19oZWxwX2Rpc3BsYXkuc29ydFxuICA7O1xuXG4gIGxldCBzaGFwZSB0IDogU2hhcGUuQmFzZV9pbmZvLnQgPVxuICAgIHsgc3VtbWFyeSA9IHQuc3VtbWFyeVxuICAgIDsgcmVhZG1lID0gT3B0aW9uLm1hcCB0LnJlYWRtZSB+ZjooZnVuIHJlYWRtZSAtPiByZWFkbWUgKCkpXG4gICAgOyBhbm9ucyA9IEdyYW1tYXIgdC51c2FnZVxuICAgIDsgZmxhZ3MgPSBmb3JtYXR0ZWRfZmxhZ3MgdFxuICAgIH1cbiAgOztcblxuICBsZXQgcGF0aF9rZXkgPSBFbnYua2V5X2NyZWF0ZSBcInBhdGhcIlxuICBsZXQgYXJnc19rZXkgPSBFbnYua2V5X2NyZWF0ZSBcImFyZ3NcIlxuICBsZXQgaGVscF9rZXkgPSBFbnYua2V5X2NyZWF0ZSBcImhlbHBcIlxuICBsZXQgbm9ybWFsaXplZF9wYXRoID0gcmVmIE5vbmVcbiAgbGV0IG5vcm1hbGl6ZWRfYXJncyA9IHJlZiBOb25lXG5cbiAgbGV0IGluZGVudF9ieV8yIHN0ciA9XG4gICAgU3RyaW5nLnNwbGl0IH5vbjonXFxuJyBzdHJcbiAgICB8PiBMaXN0Lm1hcCB+ZjooZnVuIGxpbmUgLT4gXCIgIFwiIF4gbGluZSlcbiAgICB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCJcXG5cIlxuICA7O1xuXG4gIGxldCBnZXRfZmxhZ19hbmRfYWN0aW9uIHQgYXJnID1cbiAgICBtYXRjaCBsb29rdXBfZXhwYW5kX3dpdGhfYWxpYXNlcyB0LmZsYWdzIGFyZyBGbGFnIHdpdGhcbiAgICB8IEVycm9yIG1zZyAtPiBkaWUgXCIlc1wiIG1zZyAoKVxuICAgIHwgT2sgKGZsYWdfbmFtZSwgZmxhZykgLT4gZmxhZ19uYW1lLCBmbGFnLmFjdGlvblxuICA7O1xuXG4gIGxldCBnZXRfY29tcGxldGVfZmxhZ19uYW1lIHQgYXJnIChhcmdzIDogQ21kbGluZS50KSA9XG4gICAgbGV0IGZsYWcsIGFjdGlvbiA9IGdldF9mbGFnX2FuZF9hY3Rpb24gdCBhcmcgaW5cbiAgICBtYXRjaCBhY3Rpb24gd2l0aFxuICAgIHwgUHJpbnRfaW5mb19hbmRfcXVpdCBfaW5mbyAtPiBbIGZsYWcgXVxuICAgIHwgTm9fYXJnIF9mIC0+IFsgZmxhZyBdXG4gICAgfCBBcmcgKF9mLCBfY29tcCkgLT5cbiAgICAgIChtYXRjaCBhcmdzIHdpdGhcbiAgICAgICB8IENvbnMgKGFyZywgX3Jlc3QpIC0+IFsgZmxhZzsgYXJnIF1cbiAgICAgICB8IE5pbCB8IENvbXBsZXRlIF8gLT4gW10pXG4gICAgfCBSZXN0IChfZiwgX2NvbXApIC0+IGZsYWcgOjogQ21kbGluZS50b19saXN0IGFyZ3NcbiAgOztcblxuICBsZXQgcnVuX2ZsYWcgdCBlbnYgYXJnIChhcmdzIDogQ21kbGluZS50KSA9XG4gICAgbGV0IGZsYWcsIGFjdGlvbiA9IGdldF9mbGFnX2FuZF9hY3Rpb24gdCBhcmcgaW5cbiAgICBtYXRjaCBhY3Rpb24gd2l0aFxuICAgIHwgUHJpbnRfaW5mb19hbmRfcXVpdCBpbmZvIC0+XG4gICAgICBsZXQgY29tcGxldGluZyA9IENtZGxpbmUuZW5kc19pbl9jb21wbGV0ZSBhcmdzIGluXG4gICAgICAoKiBJZiB3ZSdyZSBkb2luZyBjb21wbGV0aW9uLCB2ZXJzaW9uL2hlbHAgaW5mbyBhcmVuJ3QgdXNlZnVsIGNvbXBsZXRpb25cbiAgICAgICAgIHJlc3BvbnNlcy4gKilcbiAgICAgIGlmIGNvbXBsZXRpbmdcbiAgICAgIHRoZW4gZW52LCBhcmdzXG4gICAgICBlbHNlIChcbiAgICAgICAgcHJpbnRfZW5kbGluZSAoaW5mbyBlbnYpO1xuICAgICAgICBleGl0IDApXG4gICAgfCBOb19hcmcgZiAtPiBmIGVudiwgYXJnc1xuICAgIHwgQXJnIChmLCBjb21wKSAtPlxuICAgICAgKG1hdGNoIGFyZ3Mgd2l0aFxuICAgICAgIHwgTmlsIC0+IGRpZSBcIm1pc3NpbmcgYXJndW1lbnQgZm9yIGZsYWcgJXNcIiBmbGFnICgpXG4gICAgICAgfCBDb25zIChhcmcsIHJlc3QpIC0+XG4gICAgICAgICBsZXQgZW52ID1cbiAgICAgICAgICAgdHJ5IGYgZW52IGFyZyB3aXRoXG4gICAgICAgICAgIHwgRmFpbGVkX3RvX3BhcnNlX2NvbW1hbmRfbGluZSBfIGFzIGUgLT5cbiAgICAgICAgICAgICBpZiBDbWRsaW5lLmVuZHNfaW5fY29tcGxldGUgcmVzdCB0aGVuIGVudiBlbHNlIHJhaXNlIGVcbiAgICAgICAgIGluXG4gICAgICAgICBlbnYsIHJlc3RcbiAgICAgICB8IENvbXBsZXRlIHBhcnQgLT4gTm90aGluZy51bnJlYWNoYWJsZV9jb2RlIChDb21wbGV0ZXIucnVuX2FuZF9leGl0IGNvbXAgZW52IH5wYXJ0KSlcbiAgICB8IFJlc3QgKGYsIGNvbXApIC0+XG4gICAgICBsZXQgYXJnX2xpc3QgPSBDbWRsaW5lLnRvX2xpc3QgYXJncyBpblxuICAgICAgaWYgQ21kbGluZS5lbmRzX2luX2NvbXBsZXRlIGFyZ3NcbiAgICAgIHRoZW4gTm90aGluZy51bnJlYWNoYWJsZV9jb2RlIChDb21wbGV0ZXIucnVuX2FuZF9leGl0IGNvbXAgZW52IH5wYXJ0OmFyZ19saXN0KTtcbiAgICAgIGYgZW52IGFyZ19saXN0LCBOaWxcbiAgOztcblxuICBsZXQgcmVjIHJ1bl9jbWRsaW5lXG4gICAgdFxuICAgIGVudlxuICAgIHBhcnNlclxuICAgIChjbWRsaW5lIDogQ21kbGluZS50KVxuICAgIH5mb3JfY29tcGxldGlvblxuICAgIH5wYXJzZV9mbGFnc1xuICAgIH5ub3JtYWxpemVkX2FyZ3NcbiAgICA9XG4gICAgbWF0Y2ggY21kbGluZSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIExpc3QuaXRlciAoTWFwLmRhdGEgdC5mbGFncykgfmY6KGZ1biBmbGFnIC0+IGZsYWcuY2hlY2tfYXZhaWxhYmxlIGVudik7XG4gICAgICAoIGBPbmx5X3ZhbGlkYXRlX3BhcnNpbmcgKEVudi5tZW0gZW52IGtleV9pbnRlcm5hbF92YWxpZGF0ZV9wYXJzaW5nKVxuICAgICAgLCBBbm9ucy5QYXJzZXIuZmluYWxfdmFsdWUgcGFyc2VyIGVudlxuICAgICAgLCBMaXN0LmNvbmNhdCAoTGlzdC5yZXYgbm9ybWFsaXplZF9hcmdzKSApXG4gICAgfCBDb21wbGV0ZSBwYXJ0IC0+XG4gICAgICBpZiBwYXJzZV9mbGFncyAmJiBTdHJpbmcuaXNfcHJlZml4IHBhcnQgfnByZWZpeDpcIi1cIlxuICAgICAgdGhlbiAoXG4gICAgICAgIExpc3QuaXRlciAoTWFwLmtleXMgdC5mbGFncykgfmY6KGZ1biBuYW1lIC0+XG4gICAgICAgICAgaWYgU3RyaW5nLmlzX3ByZWZpeCBuYW1lIH5wcmVmaXg6cGFydCB0aGVuIHByaW50X2VuZGxpbmUgbmFtZSk7XG4gICAgICAgIGV4aXQgMClcbiAgICAgIGVsc2UgTm90aGluZy51bnJlYWNoYWJsZV9jb2RlIChBbm9ucy5QYXJzZXIuY29tcGxldGUgcGFyc2VyIGVudiB+cGFydClcbiAgICB8IENvbnMgKGFyZywgYXJncykgLT5cbiAgICAgIGxldCBhcmcsIGFyZ3MsIGFyZ19pc19mbGFnID1cbiAgICAgICAgbWF0Y2ggcGFyc2VfZmxhZ3Mgd2l0aFxuICAgICAgICB8IGZhbHNlIC0+IGFyZywgYXJncywgZmFsc2VcbiAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgKG1hdGNoIGFyZywgYXJncyB3aXRoXG4gICAgICAgICAgICgqIHRoZSAnLWFub24nIGZsYWcgaXMgaGVyZSBhcyBhbiBlc2NhcGUgaGF0Y2ggaW4gY2FzZSB5b3UgaGF2ZSBhblxuICAgICAgICAgICAgICBhbm9ueW1vdXMgYXJndW1lbnQgdGhhdCBzdGFydHMgd2l0aCBhIGh5cGhlbi4gKilcbiAgICAgICAgICAgfCBcIi1hbm9uXCIsIENvbnMgKGFyZywgYXJncykgLT4gYXJnLCBhcmdzLCBmYWxzZVxuICAgICAgICAgICAoKiBzdXBwb3J0IHRoZSBjb21tb24gVW5peCBjb252ZW50aW9uIHdoZXJlIFwiLVwiIG1lYW5zIHN0ZGluICopXG4gICAgICAgICAgIHwgXCItXCIsIF8gLT4gYXJnLCBhcmdzLCBmYWxzZVxuICAgICAgICAgICB8IF8sIF8gLT4gYXJnLCBhcmdzLCBTdHJpbmcuaXNfcHJlZml4IGFyZyB+cHJlZml4OlwiLVwiKVxuICAgICAgaW5cbiAgICAgIChtYXRjaCBhcmdfaXNfZmxhZyB3aXRoXG4gICAgICAgfCB0cnVlIC0+XG4gICAgICAgICBsZXQgbm9ybWFsaXplZF9hcmdzID0gZ2V0X2NvbXBsZXRlX2ZsYWdfbmFtZSB0IGFyZyBhcmdzIDo6IG5vcm1hbGl6ZWRfYXJncyBpblxuICAgICAgICAgbGV0IGVudiwgYXJncyA9IHJ1bl9mbGFnIHQgZW52IGFyZyBhcmdzIGluXG4gICAgICAgICBydW5fY21kbGluZSB+bm9ybWFsaXplZF9hcmdzIHQgZW52IHBhcnNlciBhcmdzIH5wYXJzZV9mbGFncyB+Zm9yX2NvbXBsZXRpb25cbiAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICBsZXQgcGFyc2VfZmxhZ3MxID0gcGFyc2VfZmxhZ3MgaW5cbiAgICAgICAgIGxldCAoeyBwYXJzZXI7IHBhcnNlX2ZsYWdzID0gcGFyc2VfZmxhZ3MyOyB1cGRhdGVfZW52IH1cbiAgICAgICAgICAgICAgIDogXyBBbm9ucy5QYXJzZXIuQ29uc3VtZV9yZXN1bHQudClcbiAgICAgICAgICAgPVxuICAgICAgICAgICBBbm9ucy5QYXJzZXIuY29uc3VtZSBwYXJzZXIgYXJnIH5mb3JfY29tcGxldGlvblxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBlbnYgPSB1cGRhdGVfZW52IGVudiBpblxuICAgICAgICAgbGV0IHBhcnNlX2ZsYWdzID0gcGFyc2VfZmxhZ3MxICYmIHBhcnNlX2ZsYWdzMiBpblxuICAgICAgICAgcnVuX2NtZGxpbmVcbiAgICAgICAgICAgfm5vcm1hbGl6ZWRfYXJnczooWyBhcmcgXSA6OiBub3JtYWxpemVkX2FyZ3MpXG4gICAgICAgICAgIHRcbiAgICAgICAgICAgZW52XG4gICAgICAgICAgIHBhcnNlclxuICAgICAgICAgICB+cGFyc2VfZmxhZ3NcbiAgICAgICAgICAgYXJnc1xuICAgICAgICAgICB+Zm9yX2NvbXBsZXRpb24pXG4gIDs7XG5cbiAgbGV0IHJ1bl9leG4gZXhuIH5mb3JfY29tcGxldGlvbiB+cGF0aCB+dmVyYm9zZV9vbl9wYXJzZV9lcnJvciA9XG4gICAgbWF0Y2ggZXhuIHdpdGhcbiAgICB8IEZhaWxlZF90b19wYXJzZV9jb21tYW5kX2xpbmUgXyB3aGVuIGZvcl9jb21wbGV0aW9uIC0+IGV4aXQgMFxuICAgIHwgRXhpdF9jYWxsZWQgeyBzdGF0dXMgfSAtPiBleGl0IHN0YXR1c1xuICAgIHwgXyAtPlxuICAgICAgbGV0IGV4bl9zdHIgPVxuICAgICAgICBtYXRjaCBleG4gd2l0aFxuICAgICAgICB8IEZhaWxlZF90b19wYXJzZV9jb21tYW5kX2xpbmUgbXNnIC0+IG1zZ1xuICAgICAgICB8IF8gLT4gU2V4cC50b19zdHJpbmdfaHVtIFslc2V4cCAoZXhuIDogZXhuKV1cbiAgICAgIGluXG4gICAgICBsZXQgdmVyYm9zZSA9IE9wdGlvbi52YWx1ZSB2ZXJib3NlX29uX3BhcnNlX2Vycm9yIH5kZWZhdWx0OnRydWUgaW5cbiAgICAgIGxldCBlcnJvcl9tc2cgPVxuICAgICAgICBpZiB2ZXJib3NlXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBTdHJpbmcuY29uY2F0XG4gICAgICAgICAgICB+c2VwOlwiXFxuXFxuXCJcbiAgICAgICAgICAgIFsgXCJFcnJvciBwYXJzaW5nIGNvbW1hbmQgbGluZTpcIlxuICAgICAgICAgICAgOyBpbmRlbnRfYnlfMiBleG5fc3RyXG4gICAgICAgICAgICA7IFwiRm9yIHVzYWdlIGluZm9ybWF0aW9uLCBydW5cIlxuICAgICAgICAgICAgOyBcIiAgXCIgXiBQYXRoLnRvX3N0cmluZyBwYXRoIF4gXCIgLWhlbHBcXG5cIlxuICAgICAgICAgICAgXVxuICAgICAgICBlbHNlIGV4bl9zdHJcbiAgICAgIGluXG4gICAgICBwcmVycl9lbmRsaW5lIGVycm9yX21zZztcbiAgICAgIGV4aXQgMVxuICA7O1xuXG4gIGxldCBydW5cbiAgICB0XG4gICAgZW52XG4gICAgfndoZW5fcGFyc2luZ19zdWNjZWVkc1xuICAgIH5wYXRoXG4gICAgfmFyZ3NcbiAgICB+dmVyYm9zZV9vbl9wYXJzZV9lcnJvclxuICAgIH5oZWxwX3RleHRcbiAgICB+b25fZmFpbHVyZVxuICAgID1cbiAgICBsZXQgZm9yX2NvbXBsZXRpb24gPSBDbWRsaW5lLmVuZHNfaW5fY29tcGxldGUgYXJncyBpblxuICAgIGxldCBlbnYgPVxuICAgICAgZW52XG4gICAgICB8PiBFbnYuc2V0IH5rZXk6cGF0aF9rZXkgfmRhdGE6cGF0aFxuICAgICAgfD4gRW52LnNldCB+a2V5OmFyZ3Nfa2V5IH5kYXRhOihDbWRsaW5lLnRvX2xpc3QgYXJncylcbiAgICAgIHw+IEVudi5zZXQgfmtleTpoZWxwX2tleSB+ZGF0YTpoZWxwX3RleHRcbiAgICBpblxuICAgIG1hdGNoXG4gICAgICBSZXN1bHQudHJ5X3dpdGggKGZ1biAoKSAtPlxuICAgICAgICBsZXQgaXNfdXNpbmdfdmFsaWRhdGVfcGFyc2luZywgbWFpbiwgcGFyc2VkX25vcm1hbGl6ZWRfYXJncyA9XG4gICAgICAgICAgcnVuX2NtZGxpbmVcbiAgICAgICAgICAgIHRcbiAgICAgICAgICAgIGVudlxuICAgICAgICAgICAgKHQuYW5vbnMgKCkpXG4gICAgICAgICAgICB+Zm9yX2NvbXBsZXRpb25cbiAgICAgICAgICAgIH5wYXJzZV9mbGFnczp0cnVlXG4gICAgICAgICAgICB+bm9ybWFsaXplZF9hcmdzOltdXG4gICAgICAgICAgICBhcmdzXG4gICAgICAgIGluXG4gICAgICAgIG5vcm1hbGl6ZWRfcGF0aCA6PSBTb21lIHBhdGg7XG4gICAgICAgIG5vcm1hbGl6ZWRfYXJncyA6PSBTb21lIHBhcnNlZF9ub3JtYWxpemVkX2FyZ3M7XG4gICAgICAgIGlzX3VzaW5nX3ZhbGlkYXRlX3BhcnNpbmcsIG1haW4gYFBhcnNlX2FyZ3MpXG4gICAgd2l0aFxuICAgIHwgT2sgKGBPbmx5X3ZhbGlkYXRlX3BhcnNpbmcgdHJ1ZSwgKF90aHVuayA6IF8pKSAtPlxuICAgICAgd2hlbl9wYXJzaW5nX3N1Y2NlZWRzICgpO1xuICAgICAgZXhpdCAwXG4gICAgfCBPayAoYE9ubHlfdmFsaWRhdGVfcGFyc2luZyBmYWxzZSwgdGh1bmspIC0+XG4gICAgICB3aGVuX3BhcnNpbmdfc3VjY2VlZHMgKCk7XG4gICAgICB0aHVuayBgUnVuX21haW5cbiAgICB8IEVycm9yIGV4biAtPiBvbl9mYWlsdXJlIGV4biB+Zm9yX2NvbXBsZXRpb24gfnBhdGggfnZlcmJvc2Vfb25fcGFyc2VfZXJyb3JcbiAgOztcblxuICBtb2R1bGUgUGFyYW0gPSBzdHJ1Y3RcbiAgICB0eXBlICsnYSB0ID1cbiAgICAgIHsgZiA6IHVuaXQgLT4gKHVuaXQgLT4gJ2EgUGFyc2luZ19vdXRjb21lLnQpIEFub25zLlBhcnNlci5CYXNpYy50XG4gICAgICA7IHVzYWdlIDogdW5pdCAtPiBBbm9ucy5HcmFtbWFyLnRcbiAgICAgIDsgZmxhZ3MgOiB1bml0IC0+IEZsYWcuSW50ZXJuYWwudCBsaXN0XG4gICAgICB9XG5cbiAgICBvcGVuIEFub25zLlBhcnNlci5CYXNpYy5Gb3Jfb3BlbmluZ1xuXG4gICAgbGV0IHdyYXBfdmFsdWUgdiAoKSA9IFBhcnNpbmdfb3V0Y29tZS5yZXR1cm5fbm9fYXJnIHZcblxuICAgIGxldCBhcHBseSBmIHggPVxuICAgICAgeyBmID1cbiAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICByZXR1cm4gKGZ1biBmIHggKCkgLT5cbiAgICAgICAgICAgICAgKCogb3JkZXIgb2YgZXZhbHVhdGlvbiBoZXJlIGFmZmVjdHMgaW4gd2hhdCBvcmRlciB0aGUgdXNlcnMnIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgYXJlIGV2YWx1YXRlZCwgc28gaXQncyBpbXBvcnRhbnQgdG8gY2FsbCBbZl0gYmVmb3JlIFt4XSAqKVxuICAgICAgICAgICAgICBsZXQgZl9vdXRjb21lID0gZiAoKSBpblxuICAgICAgICAgICAgICBsZXQgeF9vdXRjb21lID0geCAoKSBpblxuICAgICAgICAgICAgICBQYXJzaW5nX291dGNvbWUuYXBwbHkgZl9vdXRjb21lIHhfb3V0Y29tZSlcbiAgICAgICAgICAgIDwqPiBmLmYgKClcbiAgICAgICAgICAgIDwqPiB4LmYgKCkpXG4gICAgICA7IGZsYWdzID0gKGZ1biAoKSAtPiB4LmZsYWdzICgpIEAgZi5mbGFncyAoKSlcbiAgICAgIDsgdXNhZ2UgPSAoZnVuICgpIC0+IEFub25zLkdyYW1tYXIuY29uY2F0IFsgZi51c2FnZSAoKTsgeC51c2FnZSAoKSBdKVxuICAgICAgfVxuICAgIDs7XG5cbiAgICBsZXQgZW1wdHlfc3BlYyA6ICdtLiAoJ20gLT4gJ20pIHQgPVxuICAgICAgeyBmID0gKGZ1biAoKSAtPiByZXR1cm4gKGZ1biAoKSAtPiBQYXJzaW5nX291dGNvbWUucmV0dXJuX25vX2FyZyBGbi5pZCkpXG4gICAgICA7IGZsYWdzID0gKGZ1biAoKSAtPiBbXSlcbiAgICAgIDsgdXNhZ2UgPSAoZnVuICgpIC0+IEFub25zLkdyYW1tYXIuemVybylcbiAgICAgIH1cbiAgICA7O1xuXG4gICAgbGV0IG1hcF9vdXRjb21lIHggfmYgPVxuICAgICAgeyBmID1cbiAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICB4LmYgKClcbiAgICAgICAgICAgID4+fCBmdW4geCAoKSAtPlxuICAgICAgICAgICAgbGV0IHhfb3V0Y29tZSA9IHggKCkgaW5cbiAgICAgICAgICAgIGYgeF9vdXRjb21lKVxuICAgICAgOyBmbGFncyA9IHguZmxhZ3NcbiAgICAgIDsgdXNhZ2UgPSB4LnVzYWdlXG4gICAgICB9XG4gICAgOztcblxuICAgIGxldCBtYXAgeCB+ZiA9IG1hcF9vdXRjb21lIHggfmY6KFBhcnNpbmdfb3V0Y29tZS5tYXAgfmYpXG5cbiAgICBsZXQgbG9va3VwIGtleSA9XG4gICAgICB7IGYgPVxuICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgIEFub25zLlBhcnNlci5CYXNpYy5mcm9tX2VudiAoZnVuIGVudiAtPiBFbnYuZmluZF9leG4gZW52IGtleSkgPj58IHdyYXBfdmFsdWUpXG4gICAgICA7IGZsYWdzID0gKGZ1biAoKSAtPiBbXSlcbiAgICAgIDsgdXNhZ2UgPSAoZnVuICgpIC0+IEFub25zLkdyYW1tYXIuemVybylcbiAgICAgIH1cbiAgICA7O1xuXG4gICAgbGV0IHBhdGggOiBQYXRoLnQgdCA9IGxvb2t1cCBwYXRoX2tleVxuICAgIGxldCBhcmdzIDogc3RyaW5nIGxpc3QgdCA9IGxvb2t1cCBhcmdzX2tleVxuICAgIGxldCBoZWxwIDogc3RyaW5nIExhenkudCB0ID0gbG9va3VwIGhlbHBfa2V5XG5cbiAgICAoKiBUaGlzIGlzIG9ubHkgdXNlZCBpbnRlcm5hbGx5LCBmb3IgdGhlIGhlbHAgY29tbWFuZC4gKilcbiAgICBsZXQgZW52ID1cbiAgICAgIHsgZiA9IChmdW4gKCkgLT4gQW5vbnMuUGFyc2VyLkJhc2ljLmZyb21fZW52IChmdW4gZW52IC0+IGVudikgPj58IHdyYXBfdmFsdWUpXG4gICAgICA7IGZsYWdzID0gKGZ1biAoKSAtPiBbXSlcbiAgICAgIDsgdXNhZ2UgPSAoZnVuICgpIC0+IEFub25zLkdyYW1tYXIuemVybylcbiAgICAgIH1cbiAgICA7O1xuXG4gICAgaW5jbHVkZSBzdHJ1Y3RcbiAgICAgIG1vZHVsZSBBcmdfdHlwZSA9IEFyZ190eXBlXG4gICAgICBpbmNsdWRlIEFyZ190eXBlLkV4cG9ydFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZSBzdHJ1Y3RcbiAgICAgIG9wZW4gQW5vbnNcblxuICAgICAgbGV0ICggJTogKSA9ICggJTogKVxuICAgICAgbGV0IG1hcF9hbm9ucyA9IG1hcF9hbm9uc1xuICAgICAgbGV0IG1heWJlID0gbWF5YmVcbiAgICAgIGxldCBtYXliZV93aXRoX2RlZmF1bHQgPSBtYXliZV93aXRoX2RlZmF1bHRcbiAgICAgIGxldCBzZXF1ZW5jZSA9IHNlcXVlbmNlXG4gICAgICBsZXQgbm9uX2VtcHR5X3NlcXVlbmNlX2FzX3BhaXIgPSBub25fZW1wdHlfc2VxdWVuY2VfYXNfcGFpclxuICAgICAgbGV0IG5vbl9lbXB0eV9zZXF1ZW5jZV9hc19saXN0ID0gbm9uX2VtcHR5X3NlcXVlbmNlX2FzX2xpc3RcbiAgICAgIGxldCB0MiA9IHQyXG4gICAgICBsZXQgdDMgPSB0M1xuICAgICAgbGV0IHQ0ID0gdDRcblxuICAgICAgbGV0IGFub24gc3BlYyA9XG4gICAgICAgIEFub25zLkdyYW1tYXIuaW52YXJpYW50IHNwZWMuZ3JhbW1hcjtcbiAgICAgICAgeyBmID0gKGZ1biAoKSAtPiBzcGVjLnAgPj58IGZ1biBvdXRjb21lICgpIC0+IG91dGNvbWUpXG4gICAgICAgIDsgZmxhZ3MgPSAoZnVuICgpIC0+IFtdKVxuICAgICAgICA7IHVzYWdlID0gKGZ1biAoKSAtPiBzcGVjLmdyYW1tYXIpXG4gICAgICAgIH1cbiAgICAgIDs7XG4gICAgZW5kXG5cbiAgICBsZXQgZXNjYXBlX2Fub24gfmZpbmFsX2Fub24gPVxuICAgICAgQW5vbnMuZXNjYXBlICh0MiBmaW5hbF9hbm9uIChzZXF1ZW5jZSAoXCJBUkdcIiAlOiBzdHJpbmcpKSkgfD4gYW5vblxuICAgIDs7XG5cbiAgICBpbmNsdWRlIHN0cnVjdFxuICAgICAgb3BlbiBGbGFnXG5cbiAgICAgIGxldCBtYXBfZmxhZyA9IG1hcF9mbGFnXG4gICAgICBsZXQgZXNjYXBlID0gZXNjYXBlXG4gICAgICBsZXQgZXNjYXBlX3dpdGhfYXV0b2NvbXBsZXRlID0gZXNjYXBlX3dpdGhfYXV0b2NvbXBsZXRlXG4gICAgICBsZXQgbGlzdGVkID0gbGlzdGVkXG4gICAgICBsZXQgb25lX29yX21vcmVfYXNfcGFpciA9IG9uZV9vcl9tb3JlX2FzX3BhaXJcbiAgICAgIGxldCBvbmVfb3JfbW9yZV9hc19saXN0ID0gb25lX29yX21vcmVfYXNfbGlzdFxuICAgICAgbGV0IG5vX2FyZyA9IG5vX2FyZ1xuICAgICAgbGV0IG5vX2FyZ19yZXF1aXJlZCA9IG5vX2FyZ19yZXF1aXJlZFxuICAgICAgbGV0IG5vX2FyZ19yZWdpc3RlciA9IG5vX2FyZ19yZWdpc3RlclxuICAgICAgbGV0IG5vX2FyZ19hYm9ydCA9IG5vX2FyZ19hYm9ydFxuICAgICAgbGV0IG5vX2FyZ19zb21lID0gbm9fYXJnX3NvbWVcbiAgICAgIGxldCBvcHRpb25hbCA9IG9wdGlvbmFsXG4gICAgICBsZXQgb3B0aW9uYWxfd2l0aF9kZWZhdWx0ID0gb3B0aW9uYWxfd2l0aF9kZWZhdWx0XG4gICAgICBsZXQgcmVxdWlyZWQgPSByZXF1aXJlZFxuXG4gICAgICBsZXQgZmxhZ19pbnRlcm5hbFxuICAgICAgICA/KGFsaWFzZXMgPSBbXSlcbiAgICAgICAgP2Z1bGxfZmxhZ19yZXF1aXJlZFxuICAgICAgICBuYW1lXG4gICAgICAgIG1vZGVcbiAgICAgICAgfmRvY1xuICAgICAgICB+YWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHBcbiAgICAgICAgPVxuICAgICAgICBsZXQgbm9ybWFsaXplIGZsYWcgPSBub3JtYWxpemUgS2V5X3R5cGUuRmxhZyBmbGFnIGluXG4gICAgICAgIGxldCBuYW1lID0gbm9ybWFsaXplIG5hbWUgaW5cbiAgICAgICAgbGV0IGFsaWFzZXMgPSBMaXN0Lm1hcCB+Zjpub3JtYWxpemUgYWxpYXNlcyBpblxuICAgICAgICBsZXQgeyByZWFkOyBhY3Rpb247IG51bV9vY2N1cnJlbmNlczsgZXh0cmFfZG9jIH0gPSBtb2RlIG5hbWUgaW5cbiAgICAgICAgbGV0IGNoZWNrX2F2YWlsYWJsZSA9XG4gICAgICAgICAgbWF0Y2ggbnVtX29jY3VycmVuY2VzLmF0X2xlYXN0X29uY2Ugd2l0aFxuICAgICAgICAgIHwgZmFsc2UgLT4gKGlnbm9yZSA6IFVuaXZfbWFwLnQgLT4gdW5pdClcbiAgICAgICAgICB8IHRydWUgLT4gZnVuIGVudiAtPiBpZ25vcmUgKHJlYWQgZW52IDogXylcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5hbWVfbWF0Y2hpbmcgPVxuICAgICAgICAgIGlmIE9wdGlvbi5pc19zb21lIGZ1bGxfZmxhZ19yZXF1aXJlZCB0aGVuIGBGdWxsX21hdGNoX3JlcXVpcmVkIGVsc2UgYFByZWZpeFxuICAgICAgICBpblxuICAgICAgICB7IGYgPVxuICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICBBbm9ucy5QYXJzZXIuQmFzaWMuZnJvbV9lbnYgKGZ1biBlbnYgLT4gcmVhZCBlbnYpID4+fCBmdW4gdiAoKSAtPiB2KVxuICAgICAgICA7IGZsYWdzID1cbiAgICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgWyB7IG5hbWVcbiAgICAgICAgICAgICAgICA7IGFsaWFzZXNcbiAgICAgICAgICAgICAgICA7IGFsaWFzZXNfZXhjbHVkZWRfZnJvbV9oZWxwXG4gICAgICAgICAgICAgICAgOyBkb2MgPVxuICAgICAgICAgICAgICAgICAgICAobWF0Y2ggZm9yY2UgZXh0cmFfZG9jIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgIHwgU29tZSBleHRyYV9kb2MgLT4gWyVzdHJpbmcgXCIle2RvY30gJXtleHRyYV9kb2N9XCJdXG4gICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gZG9jKVxuICAgICAgICAgICAgICAgIDsgYWN0aW9uXG4gICAgICAgICAgICAgICAgOyBudW1fb2NjdXJyZW5jZXNcbiAgICAgICAgICAgICAgICA7IGNoZWNrX2F2YWlsYWJsZVxuICAgICAgICAgICAgICAgIDsgbmFtZV9tYXRjaGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgOyB1c2FnZSA9IChmdW4gKCkgLT4gQW5vbnMuR3JhbW1hci56ZXJvKVxuICAgICAgICB9XG4gICAgICA7O1xuXG4gICAgICBsZXQgZmxhZyA9IGZsYWdfaW50ZXJuYWwgfmFsaWFzZXNfZXhjbHVkZWRfZnJvbV9oZWxwOltdXG5cbiAgICAgIGxldCBmbGFnX29wdGlvbmFsX3dpdGhfZGVmYXVsdF9kb2NcbiAgICAgICAgP2FsaWFzZXNcbiAgICAgICAgP2Z1bGxfZmxhZ19yZXF1aXJlZFxuICAgICAgICBuYW1lXG4gICAgICAgIGFyZ190eXBlXG4gICAgICAgIHNleHBfb2ZfZGVmYXVsdFxuICAgICAgICB+ZGVmYXVsdFxuICAgICAgICB+ZG9jXG4gICAgICAgID1cbiAgICAgICAgbGV0IGRvYyA9XG4gICAgICAgICAgbWF0Y2ggc2V4cF9vZl9kZWZhdWx0IGRlZmF1bHQgd2l0aFxuICAgICAgICAgIHwgU2V4cC5BdG9tIFwiX1wiIC0+IGRvY1xuICAgICAgICAgIHwgZGVmYXVsdF9zZXhwIC0+IHNwcmludGYgIVwiJXMgKGRlZmF1bHQ6ICV7U2V4cH0pXCIgZG9jIGRlZmF1bHRfc2V4cFxuICAgICAgICBpblxuICAgICAgICBmbGFnXG4gICAgICAgICAgP2FsaWFzZXNcbiAgICAgICAgICA/ZnVsbF9mbGFnX3JlcXVpcmVkXG4gICAgICAgICAgbmFtZVxuICAgICAgICAgIChvcHRpb25hbF93aXRoX2RlZmF1bHQgZGVmYXVsdCBhcmdfdHlwZSlcbiAgICAgICAgICB+ZG9jXG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbGV0IHJldHVybiB2ID1cbiAgICAgIHsgZiA9IChmdW4gKCkgLT4gcmV0dXJuIChmdW4gKCkgLT4gUGFyc2luZ19vdXRjb21lLnJldHVybl9ub19hcmcgdikpXG4gICAgICA7IGZsYWdzID0gKGZ1biAoKSAtPiBbXSlcbiAgICAgIDsgdXNhZ2UgPSAoZnVuICgpIC0+IEFub25zLkdyYW1tYXIuemVybylcbiAgICAgIH1cbiAgICA7O1xuXG4gICAgbGV0IHJlY292ZXJfZnJvbV9taXNzaW5nX3JlcXVpcmVkX2ZsYWdzIHQgPVxuICAgICAgeyB0IHdpdGhcbiAgICAgICAgZiA9XG4gICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgdC5mICgpXG4gICAgICAgICAgICA+PnwgZnVuIGYgKCkgLT5cbiAgICAgICAgICAgIGxldCBvdXRjb21lID0gZiAoKSBpblxuICAgICAgICAgICAgUGFyc2luZ19vdXRjb21lLnJlY292ZXJfZnJvbV9taXNzaW5nX3JlcXVpcmVkX2ZsYWdzIG91dGNvbWUpXG4gICAgICB9XG4gICAgOztcblxuICAgIGxldCBpbnRyb2R1Y2VfbWlzc2luZ19yZXF1aXJlZF9mbGFncyB0ID1cbiAgICAgIHsgdCB3aXRoXG4gICAgICAgIGYgPVxuICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgIHQuZiAoKVxuICAgICAgICAgICAgPj58IGZ1biBmICgpIC0+XG4gICAgICAgICAgICBsZXQgb3V0Y29tZSA9IGYgKCkgaW5cbiAgICAgICAgICAgIFBhcnNpbmdfb3V0Y29tZS5pbnRyb2R1Y2VfbWlzc2luZ19yZXF1aXJlZF9mbGFncyBvdXRjb21lKVxuICAgICAgfVxuICAgIDs7XG5cbiAgICBsZXQgb3B0aW9uYWxfdG9fcmVxdWlyZWQgdCA9XG4gICAgICB7IHQgd2l0aFxuICAgICAgICBmID1cbiAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICB0LmYgKClcbiAgICAgICAgICAgID4+fCBmdW4gZiAoKSAtPlxuICAgICAgICAgICAgbGV0IG91dGNvbWUgPSBmICgpIGluXG4gICAgICAgICAgICBQYXJzaW5nX291dGNvbWUuaW50cm9kdWNlX21pc3NpbmdfcmVxdWlyZWRfZmxhZ3NcbiAgICAgICAgICAgICAgKFBhcnNpbmdfb3V0Y29tZS5tYXAgb3V0Y29tZSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgIEVycm9yXG4gICAgICAgICAgICAgICAgICAgIChgTWlzc2luZ19yZXF1aXJlZF9mbGFnc1xuICAgICAgICAgICAgICAgICAgICAgIChFcnJvci5vZl9zdHJpbmcgXCJbb3B0aW9uYWxfdG9fcmVxdWlyZWRdIGdvdCBhIFtOb25lXSByZXN1bHRcIikpXG4gICAgICAgICAgICAgICAgfCBTb21lIHYgLT4gT2sgdikpKVxuICAgICAgfVxuICAgIDs7XG5cbiAgICBpbmNsdWRlIEFwcGxpY2F0aXZlLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGFwcGx5ID0gYXBwbHlcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGVuZClcblxuICAgIGxldCBhcmdfbmFtZXMgdCA9XG4gICAgICBsZXQgZmxhZ3MgPSBGbGFnLkludGVybmFsLmNyZWF0ZSAodC5mbGFncyAoKSkgaW5cbiAgICAgIGxldCBmbGFnX25hbWVzID0gTWFwLmtleXMgZmxhZ3MgaW5cbiAgICAgIGxldCBhbm9uX25hbWVzID0gQW5vbnMuR3JhbW1hci5uYW1lcyAodC51c2FnZSAoKSkgaW5cbiAgICAgIExpc3QuY29uY2F0IFsgZmxhZ19uYW1lczsgYW5vbl9uYW1lcyBdXG4gICAgOztcblxuICAgIGxldCByZXF1aXJlZF9hcmdfbmFtZXMgdCA9XG4gICAgICBsZXQgZmxhZ3MgPSBGbGFnLkludGVybmFsLmNyZWF0ZSAodC5mbGFncyAoKSkgaW5cbiAgICAgIExpc3QuZmlsdGVyX21hcCAoTWFwLnRvX2FsaXN0IGZsYWdzKSB+ZjooZnVuIChuYW1lLCBmbGFnKSAtPlxuICAgICAgICBpZiBmbGFnLm51bV9vY2N1cnJlbmNlcy5hdF9sZWFzdF9vbmNlIHRoZW4gU29tZSBuYW1lIGVsc2UgTm9uZSlcbiAgICA7O1xuXG4gICAgbW9kdWxlIENob29zZV9vbmUgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgcGFyYW0gPSAnYSB0XG5cbiAgICAgIG1vZHVsZSBDaG9pY2VfbmFtZSA6IHNpZ1xuICAgICAgICB0eXBlIHQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgICAgICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICAgICAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG4gICAgICAgIHZhbCBsaXN0X3RvX3N0cmluZyA6IHQgbGlzdCAtPiBzdHJpbmdcbiAgICAgICAgdmFsIGNyZWF0ZV9leG4gOiAnYSBwYXJhbSAtPiB0XG4gICAgICAgIHZhbCBlbnVtZXJhdGVfcmVxdWlyZWRfZmxhZ3MgOiB0IC0+IGV4Y2VwdDpzdHJpbmcgLT4gc3RyaW5nIG9wdGlvblxuICAgICAgZW5kID0gc3RydWN0XG4gICAgICAgIG1vZHVsZSBUID0gc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID1cbiAgICAgICAgICAgIHsgYWxsX2FyZ3MgOiBzdHJpbmcgbGlzdFxuICAgICAgICAgICAgOyByZXF1aXJlZF9hcmdzIDogc3RyaW5nIGxpc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBbQEBkZXJpdmluZyBjb21wYXJlXVxuXG4gICAgICAgICAgbGV0IHNleHBfb2ZfdCB0ID0gWyVzZXhwICh0LmFsbF9hcmdzIDogc3RyaW5nIGxpc3QpXVxuICAgICAgICBlbmRcblxuICAgICAgICBpbmNsdWRlIFRcbiAgICAgICAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbiAgICAgICAgbGV0IGNyZWF0ZV9leG4gcGFyYW0gPVxuICAgICAgICAgIGxldCByZXF1aXJlZF9hcmdzID0gcmVxdWlyZWRfYXJnX25hbWVzIHBhcmFtIGluXG4gICAgICAgICAgbGV0IG5hbWVzID0gYXJnX25hbWVzIHBhcmFtIGluXG4gICAgICAgICAgbGV0IG5hbWVzX3dpdGhfY29tbWFzID0gTGlzdC5maWx0ZXIgbmFtZXMgfmY6KGZ1biBzIC0+IFN0cmluZy5jb250YWlucyBzICcsJykgaW5cbiAgICAgICAgICBpZiBub3QgKExpc3QuaXNfZW1wdHkgbmFtZXNfd2l0aF9jb21tYXMpXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgRXJyb3IuY3JlYXRlXG4gICAgICAgICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgICAgICAgXCJGb3Igc2ltcGxpY2l0eSwgW0NvbW1hbmQuU3BlYy5jaG9vc2Vfb25lXSBkb2VzIG5vdCBzdXBwb3J0IG5hbWVzIHdpdGggXFxcbiAgICAgICAgICAgICAgIGNvbW1hcy5cIlxuICAgICAgICAgICAgICBuYW1lc193aXRoX2NvbW1hc1xuICAgICAgICAgICAgICBbJXNleHBfb2Y6IHN0cmluZyBsaXN0XVxuICAgICAgICAgICAgfD4gRXJyb3IucmFpc2U7XG4gICAgICAgICAgbWF0Y2ggbmFtZXMgd2l0aFxuICAgICAgICAgIHwgW10gLT5cbiAgICAgICAgICAgIHJhaXNlX3NcbiAgICAgICAgICAgICAgWyVtZXNzYWdlIFwiW2Nob29zZV9vbmVdIGV4cGVjdHMgY2hvaWNlcyB0byByZWFkIGNvbW1hbmQtbGluZSBhcmd1bWVudHMuXCJdXG4gICAgICAgICAgfCBfIDo6IF8gLT4geyBhbGxfYXJncyA9IG5hbWVzOyByZXF1aXJlZF9hcmdzIH1cbiAgICAgICAgOztcblxuICAgICAgICBsZXQgdG9fc3RyaW5nIHQgPVxuICAgICAgICAgIG1hdGNoIHQucmVxdWlyZWRfYXJncyB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBTdHJpbmcuY29uY2F0IH5zZXA6XCIsXCIgdC5hbGxfYXJnc1xuICAgICAgICAgIHwgXyA6OiBfIC0+IFN0cmluZy5jb25jYXQgfnNlcDpcIixcIiB0LnJlcXVpcmVkX2FyZ3NcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgZW51bWVyYXRlX3JlcXVpcmVkX2ZsYWdzIHQgfmV4Y2VwdCA9XG4gICAgICAgICAgbWF0Y2ggTGlzdC5maWx0ZXIgdC5yZXF1aXJlZF9hcmdzIH5mOihmdW4geCAtPiBub3QgKFN0cmluZy5lcXVhbCBleGNlcHQgeCkpIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IE5vbmVcbiAgICAgICAgICB8IF8gOjogXyBhcyBsIC0+IFNvbWUgKFN0cmluZy5jb25jYXQgfnNlcDpcIixcIiBsKVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCBsaXN0X3RvX3N0cmluZyB0cyA9IExpc3QubWFwIHRzIH5mOnRvX3N0cmluZyB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCJcXG4gIFwiXG4gICAgICBlbmRcblxuICAgICAgbW9kdWxlIElmX25vdGhpbmdfY2hvc2VuID0gc3RydWN0XG4gICAgICAgIHR5cGUgKF8sIF8pIHQgPVxuICAgICAgICAgIHwgRGVmYXVsdF90byA6ICdhIC0+ICgnYSwgJ2EpIHRcbiAgICAgICAgICB8IFJhaXNlIDogKCdhLCAnYSkgdFxuICAgICAgICAgIHwgUmV0dXJuX25vbmUgOiAoJ2EsICdhIG9wdGlvbikgdFxuICAgICAgZW5kXG5cbiAgICAgIGxldCBjaG9vc2Vfb25lX25vbl9vcHRpb25hbFxuICAgICAgICAodHlwZSBhIGIpXG4gICAgICAgID8obmV3X2JlaGF2aW9yID0gdHJ1ZSlcbiAgICAgICAgKHRzIDogYSBwYXJhbSBsaXN0KVxuICAgICAgICB+KGlmX25vdGhpbmdfY2hvc2VuIDogKGEsIGIpIElmX25vdGhpbmdfY2hvc2VuLnQpXG4gICAgICAgID1cbiAgICAgICAgbGV0IGZpeF9mbGFnIHQgPVxuICAgICAgICAgIGlmIG5ld19iZWhhdmlvclxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5hbWVfb2ZfdGhlX2dyb3VwID0gQ2hvaWNlX25hbWUuY3JlYXRlX2V4biB0IGluXG4gICAgICAgICAgICBsZXQgZml4X251bV9vY2N1cnJlbmNlcyBmbGFnID1cbiAgICAgICAgICAgICAgeyBmbGFnIHdpdGhcbiAgICAgICAgICAgICAgICBGbGFnLkludGVybmFsLm51bV9vY2N1cnJlbmNlcyA9XG4gICAgICAgICAgICAgICAgICB7IGZsYWcuRmxhZy5JbnRlcm5hbC5udW1fb2NjdXJyZW5jZXMgd2l0aCBhdF9sZWFzdF9vbmNlID0gZmFsc2UgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmQgZml4X2RvYyBmbGFnID1cbiAgICAgICAgICAgICAgeyBmbGFnIHdpdGhcbiAgICAgICAgICAgICAgICBGbGFnLkludGVybmFsLmRvYyA9XG4gICAgICAgICAgICAgICAgICBzcHJpbnRmXG4gICAgICAgICAgICAgICAgICAgIFwiJXMlc1wiXG4gICAgICAgICAgICAgICAgICAgIGZsYWcuRmxhZy5JbnRlcm5hbC5kb2NcbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgIENob2ljZV9uYW1lLmVudW1lcmF0ZV9yZXF1aXJlZF9mbGFnc1xuICAgICAgICAgICAgICAgICAgICAgICAgIH5leGNlcHQ6ZmxhZy5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZV9vZl90aGVfZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICB8IFNvbWUgZ3JvdXAgLT4gc3ByaW50ZiBcIiBbcmVxdWlyZXM6IFxcXCIlc1xcXCJdXCIgZ3JvdXApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuZCBtYWtlX2Fub25zX29wdGlvbmFsIChhbm9uIDogQW5vbnMuR3JhbW1hci50KSA9XG4gICAgICAgICAgICAgIEFub25zLkdyYW1tYXIubWF5YmVfaWRlbXBvdGVudCBhbm9uXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgeyB0IHdpdGhcbiAgICAgICAgICAgICAgdXNhZ2UgPSAoZnVuICgpIC0+IG1ha2VfYW5vbnNfb3B0aW9uYWwgKHQudXNhZ2UgKCkpKVxuICAgICAgICAgICAgOyBmbGFncyA9XG4gICAgICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgICAgTGlzdC5tYXAgKHQuZmxhZ3MgKCkpIH5mOihmdW4gZmxhZ19pbnRlcm5hbCAtPlxuICAgICAgICAgICAgICAgICAgICBmbGFnX2ludGVybmFsIHw+IGZpeF9udW1fb2NjdXJyZW5jZXMgfD4gZml4X2RvYykpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIGVsc2UgdFxuICAgICAgICBpblxuICAgICAgICBtYXRjaFxuICAgICAgICAgIExpc3QubWFwIHRzIH5mOihmdW4gdCAtPiBDaG9pY2VfbmFtZS5jcmVhdGVfZXhuIHQsIGZpeF9mbGFnIHQpXG4gICAgICAgICAgfD4gTWFwLm9mX2FsaXN0IChtb2R1bGUgQ2hvaWNlX25hbWUpXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBgRHVwbGljYXRlX2tleSBuYW1lIC0+XG4gICAgICAgICAgRXJyb3IuY3JlYXRlXG4gICAgICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgICAgICBcIltDb21tYW5kLlNwZWMuY2hvb3NlX29uZV0gY2FsbGVkIHdpdGggZHVwbGljYXRlIG5hbWVcIlxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgWyVzZXhwX29mOiBDaG9pY2VfbmFtZS50XVxuICAgICAgICAgIHw+IEVycm9yLnJhaXNlXG4gICAgICAgIHwgYE9rIHRzIC0+XG4gICAgICAgICAgTWFwLmZvbGQgdHMgfmluaXQ6KHJldHVybiBbXSkgfmY6KGZ1biB+a2V5Om5hbWUgfmRhdGE6dCBhY2MgLT5cbiAgICAgICAgICAgIG1hcDJcbiAgICAgICAgICAgICAgYWNjXG4gICAgICAgICAgICAgIChyZWNvdmVyX2Zyb21fbWlzc2luZ19yZXF1aXJlZF9mbGFncyB0KVxuICAgICAgICAgICAgICB+ZjooZnVuIGFjYyB7IHJlc3VsdCA9IHZhbHVlOyBoYXNfYXJnIH0gLT5cbiAgICAgICAgICAgICAgbWF0Y2ggaGFzX2FyZyB3aXRoXG4gICAgICAgICAgICAgIHwgZmFsc2UgLT4gYWNjXG4gICAgICAgICAgICAgIHwgdHJ1ZSAtPiAobmFtZSwgdmFsdWUpIDo6IGFjYykpXG4gICAgICAgICAgfD4gbWFwIH5mOihmdW4gdmFsdWVfbGlzdCAtPlxuICAgICAgICAgICAgICAgbGV0IGFyZ19jb3VudGVyID0gTGlzdC5sZW5ndGggdmFsdWVfbGlzdCBpblxuICAgICAgICAgICAgICAgbGV0IG1pc3NpbmdfZmxhZ19lcnJvciBmbXQgPVxuICAgICAgICAgICAgICAgICBrc3ByaW50ZlxuICAgICAgICAgICAgICAgICAgIChmdW4gbXNnICgpIC0+IEVycm9yIChgTWlzc2luZ19yZXF1aXJlZF9mbGFncyAoRXJyb3Iub2Zfc3RyaW5nIG1zZykpKVxuICAgICAgICAgICAgICAgICAgIGZtdFxuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIGxldCBtb3JlX3RoYW5fb25lX2Vycm9yIHBhc3NlZCA9XG4gICAgICAgICAgICAgICAgIGRpZVxuICAgICAgICAgICAgICAgICAgICFcIkNhbm5vdCBwYXNzIG1vcmUgdGhhbiBvbmUgb2YgdGhlc2U6IFxcblxcXG4gICAgICAgICAgICAgICAgICAgIFxcICAle0Nob2ljZV9uYW1lLmxpc3RfdG9fc3RyaW5nfVwiXG4gICAgICAgICAgICAgICAgICAgKExpc3QubWFwIHBhc3NlZCB+Zjpmc3QpXG4gICAgICAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgICAgIGFuZCBzdWNjZXNzX2xpc3QsIGVycm9yX2xpc3QgPVxuICAgICAgICAgICAgICAgICBMaXN0LnBhcnRpdGlvbl9tYXAgdmFsdWVfbGlzdCB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICB8IG5hbWUsIE9rIHZhbHVlIC0+IEZpcnN0IChuYW1lLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICB8IG5hbWUsIEVycm9yIGVyciAtPiBTZWNvbmQgKG5hbWUsIGVycikpXG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgbWF0Y2ggc3VjY2Vzc19saXN0IHdpdGhcbiAgICAgICAgICAgICAgIHwgXyA6OiBfIDo6IF8gYXMgcGFzc2VkIC0+IG1vcmVfdGhhbl9vbmVfZXJyb3IgcGFzc2VkXG4gICAgICAgICAgICAgICB8IFsgKF8sICh2YWx1ZSA6IGEpKSBdIC0+XG4gICAgICAgICAgICAgICAgIGlmIGFyZ19jb3VudGVyID4gMVxuICAgICAgICAgICAgICAgICB0aGVuIG1vcmVfdGhhbl9vbmVfZXJyb3IgdmFsdWVfbGlzdFxuICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgT2tcbiAgICAgICAgICAgICAgICAgICAgIChtYXRjaCBpZl9ub3RoaW5nX2Nob3NlbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgfCBEZWZhdWx0X3RvIChfIDogYSkgLT4gKHZhbHVlIDogYilcbiAgICAgICAgICAgICAgICAgICAgICB8IFJhaXNlIC0+ICh2YWx1ZSA6IGIpXG4gICAgICAgICAgICAgICAgICAgICAgfCBSZXR1cm5fbm9uZSAtPiAoU29tZSB2YWx1ZSA6IGIpKVxuICAgICAgICAgICAgICAgfCBbXSAtPlxuICAgICAgICAgICAgICAgICAobWF0Y2ggZXJyb3JfbGlzdCB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFsgKG5hbWUsIGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzIGVycikgXSAtPlxuICAgICAgICAgICAgICAgICAgICBFcnJvclxuICAgICAgICAgICAgICAgICAgICAgIChgTWlzc2luZ19yZXF1aXJlZF9mbGFnc1xuICAgICAgICAgICAgICAgICAgICAgICAgKEVycm9yLm9mX3N0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNwcmludGZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTm90IGFsbCBmbGFncyBpbiBncm91cCBcXFwiJXNcXFwiIGFyZSBnaXZlbjogJXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKENob2ljZV9uYW1lLnRvX3N0cmluZyBuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEVycm9yLnRvX3N0cmluZ19odW0gZXJyKSkpKVxuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIChtYXRjaCBpZl9ub3RoaW5nX2Nob3NlbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgICB8IERlZmF1bHRfdG8gdmFsdWUgLT4gT2sgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgIHwgUmV0dXJuX25vbmUgLT4gT2sgTm9uZVxuICAgICAgICAgICAgICAgICAgICAgfCBSYWlzZSAtPlxuICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nX2ZsYWdfZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAhXCJNdXN0IHBhc3Mgb25lIG9mIHRoZXNlOlxcbiAgJXtDaG9pY2VfbmFtZS5saXN0X3RvX3N0cmluZ31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgIChNYXAua2V5cyB0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKSkpKVxuICAgICAgICAgIHw+IGludHJvZHVjZV9taXNzaW5nX3JlcXVpcmVkX2ZsYWdzXG4gICAgICA7O1xuXG4gICAgICBsZXQgY2hvb3NlX29uZVxuICAgICAgICAodHlwZSBhIGIpXG4gICAgICAgICh0cyA6IGEgb3B0aW9uIHBhcmFtIGxpc3QpXG4gICAgICAgIH4oaWZfbm90aGluZ19jaG9zZW4gOiAoYSwgYikgSWZfbm90aGluZ19jaG9zZW4udClcbiAgICAgICAgPVxuICAgICAgICBjaG9vc2Vfb25lX25vbl9vcHRpb25hbFxuICAgICAgICAgIH5uZXdfYmVoYXZpb3I6ZmFsc2VcbiAgICAgICAgICB+aWZfbm90aGluZ19jaG9zZW5cbiAgICAgICAgICAoTGlzdC5tYXAgdHMgfmY6KGZ1biB0IC0+XG4gICAgICAgICAgICAgbWFwX291dGNvbWUgdCB+ZjooZnVuIHsgUGFyc2luZ19vdXRjb21lLnJlc3VsdDsgaGFzX2FyZyB9IC0+XG4gICAgICAgICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICAgICAgICAgfCBPayAoU29tZSB2YWx1ZSkgLT4geyBQYXJzaW5nX291dGNvbWUucmVzdWx0ID0gT2sgdmFsdWU7IGhhc19hcmcgPSB0cnVlIH1cbiAgICAgICAgICAgICAgIHwgT2sgTm9uZSAtPlxuICAgICAgICAgICAgICAgICB7IGhhc19hcmcgPSBmYWxzZVxuICAgICAgICAgICAgICAgICA7IHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgICBFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAoYE1pc3NpbmdfcmVxdWlyZWRfZmxhZ3MgKEVycm9yLm9mX3N0cmluZyBcIm1pc3NpbmcgcmVxdWlyZWQgZmxhZ1wiKSlcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfCBFcnJvciBfIGFzIHJlc3VsdCAtPiB7IGhhc19hcmc7IHJlc3VsdCB9KSkpXG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbW9kdWxlIElmX25vdGhpbmdfY2hvc2VuID0gQ2hvb3NlX29uZS5JZl9ub3RoaW5nX2Nob3NlblxuXG4gICAgbGV0IGNob29zZV9vbmUgPSBDaG9vc2Vfb25lLmNob29zZV9vbmVcblxuICAgIGxldCBjaG9vc2Vfb25lX25vbl9vcHRpb25hbCBsc3QgfmlmX25vdGhpbmdfY2hvc2VuID1cbiAgICAgIENob29zZV9vbmUuY2hvb3NlX29uZV9ub25fb3B0aW9uYWwgbHN0IH5pZl9ub3RoaW5nX2Nob3NlblxuICAgIDs7XG5cbiAgICBsZXQgYW5kX2FyZ19uYW1lcyB0ID0gbWFwIHQgfmY6KGZ1biB2YWx1ZSAtPiB2YWx1ZSwgYXJnX25hbWVzIHQpXG5cbiAgICBsZXQgYW5kX2FyZ19uYW1lIHQgPVxuICAgICAgbWF0Y2ggYXJnX25hbWVzIHQgd2l0aFxuICAgICAgfCBbIG5hbWUgXSAtPiBtYXAgdCB+ZjooZnVuIHZhbHVlIC0+IHZhbHVlLCBuYW1lKVxuICAgICAgfCBuYW1lcyAtPlxuICAgICAgICByYWlzZV9zXG4gICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICBcIlthbmRfYXJnX25hbWVdIGV4cGVjdHMgZXhhY3RseSBvbmUgbmFtZSwgZ290XCIgfl86KG5hbWVzIDogc3RyaW5nIGxpc3QpXVxuICAgIDs7XG5cbiAgICBsZXQgcGFyc2UgeyBmbGFnczsgdXNhZ2UgPSBfOyBmIH0gYXJncyA9XG4gICAgICBsZXQgY21kbGluZSA9IENtZGxpbmUub2ZfbGlzdCBhcmdzIGluXG4gICAgICBsZXQgcmVzdWx0ID0gcmVmIE5vbmUgaW5cbiAgICAgIHJ1blxuICAgICAgICB7IHN1bW1hcnkgPSBcIlwiXG4gICAgICAgIDsgcmVhZG1lID0gTm9uZVxuICAgICAgICA7IGZsYWdzID0gZmxhZ3MgKCkgfD4gRmxhZy5JbnRlcm5hbC5jcmVhdGVcbiAgICAgICAgOyBhbm9ucyA9XG4gICAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgIGxldCBvcGVuIEFub25zLlBhcnNlci5CYXNpYy5Gb3Jfb3BlbmluZyBpblxuICAgICAgICAgICAgICBmICgpXG4gICAgICAgICAgICAgID4+fCBmdW4gcGFyYW1zIGBQYXJzZV9hcmdzIGBSdW5fbWFpbiAtPlxuICAgICAgICAgICAgICBsZXQgb3V0Y29tZSA9IHBhcmFtcyAoKSBpblxuICAgICAgICAgICAgICBtYXRjaCBvdXRjb21lLnJlc3VsdCB3aXRoXG4gICAgICAgICAgICAgIHwgRXJyb3IgKGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzIGVycikgLT4gcmVzdWx0IDo9IFNvbWUgKEVycm9yIGVycilcbiAgICAgICAgICAgICAgfCBPayB4IC0+IHJlc3VsdCA6PSBTb21lIChPayB4KSlcbiAgICAgICAgOyB1c2FnZSA9IEFub25zLkdyYW1tYXIuemVyb1xuICAgICAgICB9XG4gICAgICAgIFVuaXZfbWFwLmVtcHR5XG4gICAgICAgIH53aGVuX3BhcnNpbmdfc3VjY2VlZHM6Rm4uaWRcbiAgICAgICAgfmFyZ3M6Y21kbGluZVxuICAgICAgICB+cGF0aDpQYXRoLmVtcHR5XG4gICAgICAgIH52ZXJib3NlX29uX3BhcnNlX2Vycm9yOihTb21lIHRydWUpXG4gICAgICAgIH5oZWxwX3RleHQ6KGxhenkgXCJObyBoZWxwIGZvciBwYXJzaW5nXCIpXG4gICAgICAgIH5vbl9mYWlsdXJlOlxuICAgICAgICAgIChmdW5cbiAgICAgICAgICAgIGV4blxuICAgICAgICAgICAgfmZvcl9jb21wbGV0aW9uOihfIDogYm9vbClcbiAgICAgICAgICAgIH5wYXRoOihfIDogUGF0aC50KVxuICAgICAgICAgICAgfnZlcmJvc2Vfb25fcGFyc2VfZXJyb3I6KF8gOiBib29sIG9wdGlvbilcbiAgICAgICAgICAgIC0+IHJlc3VsdCA6PSBTb21lIChFcnJvciAoRXJyb3Iub2ZfZXhuIGV4bikpKTtcbiAgICAgIE9wdGlvbi52YWx1ZV9leG4gfmhlcmU6WyVoZXJlXSAhcmVzdWx0XG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIFNwZWMgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EgLT4gJ2IpIFBhcmFtLnRcbiAgICB0eXBlICdhIHBhcmFtID0gJ2EgUGFyYW0udFxuXG4gICAgbGV0IGFwcGx5ID0gUGFyYW0uYXBwbHlcbiAgICBsZXQgKCArKyApIHQxIHQyID0gUGFyYW0ubWFwMiB0MSB0MiB+ZjooZnVuIGYxIGYyIHggLT4gZjIgKGYxIHgpKVxuICAgIGxldCAoICs+ICkgdDEgcDIgPSBQYXJhbS5tYXAyIHQxIHAyIH5mOihmdW4gZjEgcDIgeCAtPiAoZjEgeCkgcDIpXG4gICAgbGV0ICggKzwgKSB0MSBwMiA9IFBhcmFtLm1hcDIgcDIgdDEgfmY6KGZ1biBwMiBmMSB4IC0+IGYxICh4IHAyKSlcbiAgICBsZXQgc3RlcCBmID0gUGFyYW0ucmV0dXJuIGZcblxuICAgICgqIElkZWFsbHkgdGhpcyB3b3VsZCBiZSBbbGV0IGVtcHR5ID0gUGFyYW0ucmV0dXJuIEZuLmlkXSwgYnV0IHVuZm9ydHVuYXRlbHkgdGhhdFxuICAgICAgIGRvZXNuJ3QgY29tcGlsZSBiZWNhdXNlIG9mIHRoZSB2YWx1ZSByZXN0cmljdGlvbiAqKVxuICAgIGxldCBlbXB0eSA9IFBhcmFtLmVtcHR5X3NwZWNcbiAgICBsZXQgY29uc3QgeCA9IFBhcmFtLnJldHVybiB4XG4gICAgbGV0IG1hcCA9IFBhcmFtLm1hcFxuICAgIGxldCB3cmFwIGYgdCA9IFBhcmFtLm1hcCB0IH5mOihmdW4gcnVuIG1haW4gLT4gZiB+cnVuIH5tYWluKVxuICAgIGxldCBvZl9wYXJhbSBwID0gbWFwIHAgfmY6KGZ1biBmIGsgLT4gayBmKVxuICAgIGxldCB0b19wYXJhbSB0IG0gPSBtYXAgdCB+ZjooZnVuIGYgLT4gZiBtKVxuICAgIGxldCBwYXRoIDogUGF0aC50IHBhcmFtID0gUGFyYW0ucGF0aFxuICAgIGxldCBhcmdzIDogc3RyaW5nIGxpc3QgcGFyYW0gPSBQYXJhbS5hcmdzXG4gICAgbGV0IGhlbHAgOiBzdHJpbmcgTGF6eS50IHBhcmFtID0gUGFyYW0uaGVscFxuXG4gICAgaW5jbHVkZSBzdHJ1Y3RcbiAgICAgIG1vZHVsZSBBcmdfdHlwZSA9IEFyZ190eXBlXG4gICAgICBpbmNsdWRlIEFyZ190eXBlLkV4cG9ydFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZSBzdHJ1Y3RcbiAgICAgIG9wZW4gQW5vbnNcblxuICAgICAgdHlwZSAnYSBhbm9ucyA9ICdhIHRcblxuICAgICAgbGV0ICggJTogKSA9ICggJTogKVxuICAgICAgbGV0IG1hcF9hbm9ucyA9IG1hcF9hbm9uc1xuICAgICAgbGV0IG1heWJlID0gbWF5YmVcbiAgICAgIGxldCBtYXliZV93aXRoX2RlZmF1bHQgPSBtYXliZV93aXRoX2RlZmF1bHRcbiAgICAgIGxldCBub25fZW1wdHlfc2VxdWVuY2VfYXNfbGlzdCA9IG5vbl9lbXB0eV9zZXF1ZW5jZV9hc19saXN0XG4gICAgICBsZXQgbm9uX2VtcHR5X3NlcXVlbmNlX2FzX3BhaXIgPSBub25fZW1wdHlfc2VxdWVuY2VfYXNfcGFpclxuICAgICAgbGV0IHNlcXVlbmNlID0gc2VxdWVuY2VcbiAgICAgIGxldCB0MiA9IHQyXG4gICAgICBsZXQgdDMgPSB0M1xuICAgICAgbGV0IHQ0ID0gdDRcbiAgICAgIGxldCBhbm9uID0gUGFyYW0uYW5vblxuICAgIGVuZFxuXG4gICAgbGV0IGVzY2FwZV9hbm9uID0gUGFyYW0uZXNjYXBlX2Fub25cblxuICAgIGluY2x1ZGUgc3RydWN0XG4gICAgICBvcGVuIEZsYWdcblxuICAgICAgdHlwZSAnYSBmbGFnID0gJ2EgdFxuXG4gICAgICBsZXQgbWFwX2ZsYWcgPSBtYXBfZmxhZ1xuICAgICAgbGV0IGVzY2FwZSA9IGVzY2FwZVxuICAgICAgbGV0IGVzY2FwZV93aXRoX2F1dG9jb21wbGV0ZSA9IGVzY2FwZV93aXRoX2F1dG9jb21wbGV0ZVxuICAgICAgbGV0IGxpc3RlZCA9IGxpc3RlZFxuICAgICAgbGV0IG9uZV9vcl9tb3JlX2FzX3BhaXIgPSBvbmVfb3JfbW9yZV9hc19wYWlyXG4gICAgICBsZXQgb25lX29yX21vcmVfYXNfbGlzdCA9IG9uZV9vcl9tb3JlX2FzX2xpc3RcbiAgICAgIGxldCBub19hcmcgPSBub19hcmdcbiAgICAgIGxldCBub19hcmdfcmVxdWlyZWQgPSBub19hcmdfcmVxdWlyZWRcbiAgICAgIGxldCBub19hcmdfcmVnaXN0ZXIgPSBub19hcmdfcmVnaXN0ZXJcbiAgICAgIGxldCBub19hcmdfYWJvcnQgPSBub19hcmdfYWJvcnRcbiAgICAgIGxldCBub19hcmdfc29tZSA9IG5vX2FyZ19zb21lXG4gICAgICBsZXQgb3B0aW9uYWwgPSBvcHRpb25hbFxuICAgICAgbGV0IG9wdGlvbmFsX3dpdGhfZGVmYXVsdCA9IG9wdGlvbmFsX3dpdGhfZGVmYXVsdFxuICAgICAgbGV0IHJlcXVpcmVkID0gcmVxdWlyZWRcbiAgICAgIGxldCBmbGFnID0gUGFyYW0uZmxhZ1xuICAgICAgbGV0IGZsYWdfb3B0aW9uYWxfd2l0aF9kZWZhdWx0X2RvYyA9IFBhcmFtLmZsYWdfb3B0aW9uYWxfd2l0aF9kZWZhdWx0X2RvY1xuXG4gICAgICBpbmNsdWRlIEFwcGxpY2F0aXZlLk1ha2UgKHN0cnVjdFxuICAgICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgUGFyYW0udFxuXG4gICAgICAgIGxldCByZXR1cm4gPSBQYXJhbS5yZXR1cm5cbiAgICAgICAgbGV0IGFwcGx5ID0gYXBwbHlcbiAgICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgICBlbmQpXG5cbiAgICAgIGxldCBwYWlyID0gUGFyYW0uYm90aFxuICAgIGVuZFxuXG4gICAgbGV0IGZsYWdzX29mX2FyZ3NfZXhuIGFyZ3MgPVxuICAgICAgTGlzdC5mb2xkIGFyZ3MgfmluaXQ6ZW1wdHkgfmY6KGZ1biBhY2MgKG5hbWUsIHNwZWMsIGRvYykgLT5cbiAgICAgICAgbGV0IGdlbiBmIGZsYWdfdHlwZSA9XG4gICAgICAgICAgc3RlcCAoZnVuIG0geCAtPlxuICAgICAgICAgICAgZiB4O1xuICAgICAgICAgICAgbSlcbiAgICAgICAgICArPiBQYXJhbS5mbGFnIG5hbWUgZmxhZ190eXBlIH5kb2NcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGNhbGwgZiBhcmdfdHlwZSA9IGdlbiAoZnVuIHggLT4gT3B0aW9uLml0ZXIgeCB+ZikgKFBhcmFtLm9wdGlvbmFsIGFyZ190eXBlKSBpblxuICAgICAgICBsZXQgc2V0IHIgYXJnX3R5cGUgPSBjYWxsIChmdW4geCAtPiByIDo9IHgpIGFyZ190eXBlIGluXG4gICAgICAgIGxldCBzZXRfYm9vbCByIGIgPSBnZW4gKGZ1biBwYXNzZWQgLT4gaWYgcGFzc2VkIHRoZW4gciA6PSBiKSBQYXJhbS5ub19hcmcgaW5cbiAgICAgICAgYWNjXG4gICAgICAgICsrXG4gICAgICAgIG1hdGNoIChzcGVjIDogU3RkbGliLkFyZy5zcGVjKSB3aXRoXG4gICAgICAgIHwgVW5pdCBmIC0+IGdlbiAoZnVuIHBhc3NlZCAtPiBpZiBwYXNzZWQgdGhlbiBmICgpKSBQYXJhbS5ub19hcmdcbiAgICAgICAgfCBTZXQgciAtPiBzZXRfYm9vbCByIHRydWVcbiAgICAgICAgfCBDbGVhciByIC0+IHNldF9ib29sIHIgZmFsc2VcbiAgICAgICAgfCBTdHJpbmcgZiAtPiBjYWxsIGYgc3RyaW5nXG4gICAgICAgIHwgU2V0X3N0cmluZyByIC0+IHNldCByIHN0cmluZ1xuICAgICAgICB8IEludCBmIC0+IGNhbGwgZiBpbnRcbiAgICAgICAgfCBTZXRfaW50IHIgLT4gc2V0IHIgaW50XG4gICAgICAgIHwgRmxvYXQgZiAtPiBjYWxsIGYgZmxvYXRcbiAgICAgICAgfCBTZXRfZmxvYXQgciAtPiBzZXQgciBmbG9hdFxuICAgICAgICB8IEJvb2wgZiAtPiBjYWxsIGYgYm9vbFxuICAgICAgICB8IFN5bWJvbCAoc3ltcywgZikgLT5cbiAgICAgICAgICBsZXQgYXJnX3R5cGUgPVxuICAgICAgICAgICAgQXJnX3R5cGUub2ZfYWxpc3RfZXhuXG4gICAgICAgICAgICAgIH5saXN0X3ZhbHVlc19pbl9oZWxwOmZhbHNlXG4gICAgICAgICAgICAgIChMaXN0Lm1hcCBzeW1zIH5mOihmdW4gc3ltIC0+IHN5bSwgc3ltKSlcbiAgICAgICAgICBpblxuICAgICAgICAgIGNhbGwgZiBhcmdfdHlwZVxuICAgICAgICB8IFJlc3QgZiAtPiBnZW4gKGZ1biB4IC0+IE9wdGlvbi5pdGVyIHggfmY6KExpc3QuaXRlciB+ZikpIFBhcmFtLmVzY2FwZVxuICAgICAgICB8IFR1cGxlIF8gLT5cbiAgICAgICAgICBmYWlsd2l0aCBcIkFyZy5UdXBsZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IENvbW1hbmQuU3BlYy5mbGFnc19vZl9hcmdzX2V4blwiXG4gICAgICAgIHwgKChFeHBhbmQgXykgW0BpZiBvY2FtbF92ZXJzaW9uID49ICg0LCAwNSwgMCldKSAtPlxuICAgICAgICAgIGZhaWx3aXRoIFwiQXJnLkV4cGFuZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IENvbW1hbmQuU3BlYy5mbGFnc19vZl9hcmdzX2V4blwiXG4gICAgICAgIHwgKChSZXN0X2FsbCBfKSBbQGlmIG9jYW1sX3ZlcnNpb24gPj0gKDQsIDEyLCAwKV0pIC0+XG4gICAgICAgICAgZmFpbHdpdGggXCJBcmcuUmVzdF9hbGwgaXMgbm90IHN1cHBvcnRlZCBieSBDb21tYW5kLlNwZWMuZmxhZ3Nfb2ZfYXJnc19leG5cIilcbiAgICA7O1xuXG4gICAgbW9kdWxlIERlcHJlY2F0ZWQgPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgRmxhZy5EZXByZWNhdGVkXG4gICAgICBpbmNsdWRlIEFub25zLkRlcHJlY2F0ZWRcbiAgICBlbmRcblxuICAgIGxldCBhcmdfbmFtZXMgPSBQYXJhbS5hcmdfbmFtZXNcblxuICAgIG1vZHVsZSBJZl9ub3RoaW5nX2Nob3NlbiA9IFBhcmFtLkNob29zZV9vbmUuSWZfbm90aGluZ19jaG9zZW5cblxuICAgIGxldCBjaG9vc2Vfb25lID0gUGFyYW0uY2hvb3NlX29uZVxuICAgIGxldCBjaG9vc2Vfb25lX25vbl9vcHRpb25hbCA9IFBhcmFtLmNob29zZV9vbmVfbm9uX29wdGlvbmFsXG4gICAgbGV0IGFuZF9hcmdfbmFtZXMgPSBQYXJhbS5hbmRfYXJnX25hbWVzXG4gICAgbGV0IGFuZF9hcmdfbmFtZSA9IFBhcmFtLmFuZF9hcmdfbmFtZVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgR3JvdXAgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IHN1bW1hcnkgOiBzdHJpbmdcbiAgICA7IHJlYWRtZSA6ICh1bml0IC0+IHN0cmluZykgb3B0aW9uXG4gICAgOyBzdWJjb21tYW5kcyA6IChzdHJpbmcgKiAnYSkgbGlzdCBMYXp5LnRcbiAgICA7IGJvZHkgOiAocGF0aDpzdHJpbmcgbGlzdCAtPiB1bml0KSBvcHRpb25cbiAgICB9XG5cbiAgbGV0IHNoYXBlIH5zdWJjb21tYW5kX3RvX3NoYXBlIHQgOiBfIFNoYXBlLkdyb3VwX2luZm8udCA9XG4gICAgeyBzdW1tYXJ5ID0gdC5zdW1tYXJ5XG4gICAgOyByZWFkbWUgPSBPcHRpb24ubWFwIH5mOihmdW4gcmVhZG1lIC0+IHJlYWRtZSAoKSkgdC5yZWFkbWVcbiAgICA7IHN1YmNvbW1hbmRzID0gTGF6eS5tYXAgdC5zdWJjb21tYW5kcyB+ZjooTGlzdC5Bc3NvYy5tYXAgfmY6c3ViY29tbWFuZF90b19zaGFwZSlcbiAgICB9XG4gIDs7XG5lbmRcblxubGV0IGFic19wYXRoID0gU2hhcGUuUHJpdmF0ZS5hYnNfcGF0aFxubGV0IGNvbXBfY3dvcmQgPSBFbnZfdmFyLkNPTVBfQ1dPUkRcblxubW9kdWxlIEV4ZWMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHN1bW1hcnkgOiBzdHJpbmdcbiAgICA7IHJlYWRtZSA6ICh1bml0IC0+IHN0cmluZykgb3B0aW9uXG4gICAgOyAoKiBJZiBbcGF0aF90b19leGVdIGlzIHJlbGF0aXZlLCBpbnRlcnByZXQgdy5yLnQuIFt3b3JraW5nX2Rpcl0gKilcbiAgICAgIHdvcmtpbmdfZGlyIDogc3RyaW5nXG4gICAgOyBwYXRoX3RvX2V4ZSA6IHN0cmluZ1xuICAgIDsgY2hpbGRfc3ViY29tbWFuZCA6IHN0cmluZyBsaXN0XG4gICAgOyBlbnYgOiBlbnYgb3B0aW9uXG4gICAgfVxuXG4gIGxldCBzaGFwZSB0IDogU2hhcGUuRXhlY19pbmZvLnQgPVxuICAgIHsgc3VtbWFyeSA9IHQuc3VtbWFyeVxuICAgIDsgcmVhZG1lID0gT3B0aW9uLm1hcCB+ZjooZnVuIHJlYWRtZSAtPiByZWFkbWUgKCkpIHQucmVhZG1lXG4gICAgOyB3b3JraW5nX2RpciA9IHQud29ya2luZ19kaXJcbiAgICA7IHBhdGhfdG9fZXhlID0gdC5wYXRoX3RvX2V4ZVxuICAgIDsgY2hpbGRfc3ViY29tbWFuZCA9IHQuY2hpbGRfc3ViY29tbWFuZFxuICAgIH1cbiAgOztcbmVuZFxuXG4oKiBBIHByb3h5IGNvbW1hbmQgaXMgdGhlIHN0cnVjdHVyZSBvZiBhbiBFeGVjIGNvbW1hbmQgb2J0YWluZWQgYnkgcnVubmluZyBpdCBpbiBhXG4gICBzcGVjaWFsIHdheSAqKVxubW9kdWxlIFByb3h5ID0gc3RydWN0XG4gIG1vZHVsZSBLaW5kID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHwgQmFzZSBvZiBTaGFwZS5CYXNlX2luZm8udFxuICAgICAgfCBHcm91cCBvZiAnYSBTaGFwZS5Hcm91cF9pbmZvLnRcbiAgICAgIHwgRXhlYyBvZiBTaGFwZS5FeGVjX2luZm8udFxuICAgICAgfCBMYXp5IG9mICdhIHQgTGF6eS50XG4gIGVuZFxuXG4gIHR5cGUgdCA9XG4gICAgeyB3b3JraW5nX2RpciA6IHN0cmluZ1xuICAgIDsgcGF0aF90b19leGUgOiBzdHJpbmdcbiAgICA7IHBhdGhfdG9fc3ViY29tbWFuZCA6IHN0cmluZyBsaXN0XG4gICAgOyBjaGlsZF9zdWJjb21tYW5kIDogc3RyaW5nIGxpc3RcbiAgICA7IGtpbmQgOiB0IEtpbmQudFxuICAgIH1cbmVuZFxuXG50eXBlIHQgPVxuICB8IEJhc2Ugb2YgQ29tbWFuZF9iYXNlLnRcbiAgfCBHcm91cCBvZiB0IEdyb3VwLnRcbiAgfCBFeGVjIG9mIEV4ZWMudFxuICB8IExhenkgb2YgdCBMYXp5LnRcblxubGV0IHJlYyBzZXhwYWJsZV9zaGFwZSA6IHQgLT4gU2hhcGUuU2V4cGFibGUudCA9IGZ1bmN0aW9uXG4gIHwgQmFzZSBiYXNlIC0+IEJhc2UgKENvbW1hbmRfYmFzZS5zaGFwZSBiYXNlKVxuICB8IEV4ZWMgZXhlYyAtPiBFeGVjIChFeGVjLnNoYXBlIGV4ZWMpXG4gIHwgR3JvdXAgZ3JvdXAgLT4gR3JvdXAgKEdyb3VwLnNoYXBlIH5zdWJjb21tYW5kX3RvX3NoYXBlOnNleHBhYmxlX3NoYXBlIGdyb3VwKVxuICB8IExhenkgdGh1bmsgLT4gTGF6eSAoTGF6eS5tYXAgfmY6c2V4cGFibGVfc2hhcGUgdGh1bmspXG47O1xuXG50eXBlICgnbWFpbiwgJ3Jlc3VsdCkgYmFzaWNfc3BlY19jb21tYW5kID1cbiAgc3VtbWFyeTpzdHJpbmdcbiAgLT4gP3JlYWRtZToodW5pdCAtPiBzdHJpbmcpXG4gIC0+ICgnbWFpbiwgdW5pdCAtPiAncmVzdWx0KSBDb21tYW5kX2Jhc2UuU3BlYy50XG4gIC0+ICdtYWluXG4gIC0+IHRcblxubGV0IGV4dGVuZF9leG4gfm1lbSB+YWRkIG1hcCBrZXlfdHlwZSB+a2V5IGRhdGEgPVxuICBpZiBtZW0gbWFwIGtleVxuICB0aGVuIGZhaWx3aXRoZiBcInRoZXJlIGlzIGFscmVhZHkgYSAlcyBuYW1lZCAlc1wiIChLZXlfdHlwZS50b19zdHJpbmcga2V5X3R5cGUpIGtleSAoKTtcbiAgYWRkIG1hcCB+a2V5IH5kYXRhXG47O1xuXG5sZXQgZXh0ZW5kX21hcF9leG4gbWFwIGtleV90eXBlIH5rZXkgZGF0YSA9XG4gIGV4dGVuZF9leG4gbWFwIGtleV90eXBlIH5rZXkgZGF0YSB+bWVtOk1hcC5tZW0gfmFkZDpNYXAuc2V0XG47O1xuXG5sZXQgZXh0ZW5kX2FsaXN0X2V4biBhbGlzdCBrZXlfdHlwZSB+a2V5IGRhdGEgPVxuICBleHRlbmRfZXhuXG4gICAgYWxpc3RcbiAgICBrZXlfdHlwZVxuICAgIH5rZXlcbiAgICBkYXRhXG4gICAgfm1lbTooZnVuIGFsaXN0IGtleSAtPiBMaXN0LkFzc29jLm1lbSBhbGlzdCBrZXkgfmVxdWFsOlN0cmluZy5lcXVhbClcbiAgICB+YWRkOihmdW4gYWxpc3QgfmtleSB+ZGF0YSAtPiBMaXN0LkFzc29jLmFkZCBhbGlzdCBrZXkgZGF0YSB+ZXF1YWw6U3RyaW5nLmVxdWFsKVxuOztcblxubW9kdWxlIEJhaWxvdXRfZHVtcF9mbGFnID0gc3RydWN0XG4gIGxldCBhZGQgYmFzZSB+bmFtZSB+YWxpYXNlcyB+YWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHAgfnRleHQgfnRleHRfc3VtbWFyeSA9XG4gICAgbGV0IGZsYWdzID0gYmFzZS5Db21tYW5kX2Jhc2UuZmxhZ3MgaW5cbiAgICBsZXQgZmxhZ3MgPVxuICAgICAgZXh0ZW5kX21hcF9leG5cbiAgICAgICAgZmxhZ3NcbiAgICAgICAgS2V5X3R5cGUuRmxhZ1xuICAgICAgICB+a2V5Om5hbWVcbiAgICAgICAgeyBuYW1lXG4gICAgICAgIDsgYWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHBcbiAgICAgICAgOyBhbGlhc2VzXG4gICAgICAgIDsgbnVtX29jY3VycmVuY2VzID0gRmxhZy5OdW1fb2NjdXJyZW5jZXMuYXRfbW9zdF9vbmNlXG4gICAgICAgIDsgY2hlY2tfYXZhaWxhYmxlID0gaWdub3JlXG4gICAgICAgIDsgYWN0aW9uID0gUHJpbnRfaW5mb19hbmRfcXVpdCAoZnVuIGVudiAtPiB0ZXh0IGVudilcbiAgICAgICAgOyBkb2MgPSBzcHJpbnRmIFwiIHByaW50ICVzIGFuZCBleGl0XCIgdGV4dF9zdW1tYXJ5XG4gICAgICAgIDsgbmFtZV9tYXRjaGluZyA9IGBQcmVmaXhcbiAgICAgICAgfVxuICAgIGluXG4gICAgeyBiYXNlIHdpdGggZmxhZ3MgfVxuICA7O1xuZW5kXG5cbmxldCBiYXNpYyB+c3VtbWFyeSA/cmVhZG1lIHsgQ29tbWFuZF9iYXNlLlBhcmFtLnVzYWdlOyBmbGFnczsgZiB9ID1cbiAgbGV0IGZsYWdzID0gZmxhZ3MgKCkgaW5cbiAgbGV0IHVzYWdlID0gdXNhZ2UgKCkgaW5cbiAgbGV0IGFub25zICgpID1cbiAgICBsZXQgb3BlbiBBbm9ucy5QYXJzZXIuQmFzaWMuRm9yX29wZW5pbmcgaW5cbiAgICBmICgpXG4gICAgPj58IGZ1biBwYXJhbXMgYFBhcnNlX2FyZ3MgLT5cbiAgICBsZXQgb3V0Y29tZSA9IHBhcmFtcyAoKSBpblxuICAgIG1hdGNoIG91dGNvbWUucmVzdWx0IHdpdGhcbiAgICB8IEVycm9yIChgTWlzc2luZ19yZXF1aXJlZF9mbGFncyBlcnIpIC0+IGRpZSBcIiVzXCIgKEVycm9yLnRvX3N0cmluZ19odW0gZXJyKSAoKVxuICAgIHwgT2sgdGh1bmsgLT4gZnVuIGBSdW5fbWFpbiAtPiB0aHVuayAoKVxuICBpblxuICBsZXQgZmxhZ3MgPSBGbGFnLkludGVybmFsLmNyZWF0ZSBmbGFncyBpblxuICBsZXQgYmFzZSA9IHsgQ29tbWFuZF9iYXNlLnN1bW1hcnk7IHJlYWRtZTsgdXNhZ2U7IGZsYWdzOyBhbm9ucyB9IGluXG4gIGxldCBiYXNlID1cbiAgICBCYWlsb3V0X2R1bXBfZmxhZy5hZGRcbiAgICAgIGJhc2VcbiAgICAgIH5uYW1lOlwiLWhlbHBcIlxuICAgICAgfmFsaWFzZXM6WyBcIi0/XCIgXVxuICAgICAgfmFsaWFzZXNfZXhjbHVkZWRfZnJvbV9oZWxwOlsgXCItLWhlbHBcIiBdXG4gICAgICB+dGV4dF9zdW1tYXJ5OlwidGhpcyBoZWxwIHRleHRcIlxuICAgICAgfnRleHQ6KGZ1biBlbnYgLT4gTGF6eS5mb3JjZSAoRW52LmZpbmRfZXhuIGVudiBDb21tYW5kX2Jhc2UuaGVscF9rZXkpKVxuICBpblxuICBCYXNlIGJhc2Vcbjs7XG5cbmxldCBiYXNpY19zcGVjIH5zdW1tYXJ5ID9yZWFkbWUgc3BlYyBtYWluID1cbiAgYmFzaWMgfnN1bW1hcnkgP3JlYWRtZSAoQ29tbWFuZF9iYXNlLlNwZWMudG9fcGFyYW0gc3BlYyBtYWluKVxuOztcblxubGV0IHN1YnNfa2V5IDogKHN0cmluZyAqIHQpIGxpc3QgRW52LktleS50ID0gRW52LmtleV9jcmVhdGUgXCJzdWJjb21tYW5kc1wiXG5cbmxldCBsYXp5X2dyb3VwIH5zdW1tYXJ5ID9yZWFkbWUgP3ByZXNlcnZlX3N1YmNvbW1hbmRfb3JkZXIgP2JvZHkgYWxpc3QgPVxuICBsZXQgc3ViY29tbWFuZHMgPVxuICAgIExhenkubWFwIGFsaXN0IH5mOihmdW4gYWxpc3QgLT5cbiAgICAgIGxldCBhbGlzdCA9XG4gICAgICAgIExpc3QubWFwIGFsaXN0IH5mOihmdW4gKG5hbWUsIHQpIC0+IG5vcm1hbGl6ZSBLZXlfdHlwZS5TdWJjb21tYW5kIG5hbWUsIHQpXG4gICAgICBpblxuICAgICAgbWF0Y2ggTWFwLm9mX2FsaXN0IChtb2R1bGUgU3RyaW5nKSBhbGlzdCB3aXRoXG4gICAgICB8IGBEdXBsaWNhdGVfa2V5IG5hbWUgLT4gZmFpbHdpdGhmIFwibXVsdGlwbGUgc3ViY29tbWFuZHMgbmFtZWQgJXNcIiBuYW1lICgpXG4gICAgICB8IGBPayBtYXAgLT5cbiAgICAgICAgKG1hdGNoIHByZXNlcnZlX3N1YmNvbW1hbmRfb3JkZXIgd2l0aFxuICAgICAgICAgfCBTb21lICgpIC0+IGFsaXN0XG4gICAgICAgICB8IE5vbmUgLT4gTWFwLnRvX2FsaXN0IG1hcCkpXG4gIGluXG4gIEdyb3VwIHsgc3VtbWFyeTsgcmVhZG1lOyBzdWJjb21tYW5kczsgYm9keSB9XG47O1xuXG5sZXQgZ3JvdXAgfnN1bW1hcnkgP3JlYWRtZSA/cHJlc2VydmVfc3ViY29tbWFuZF9vcmRlciA/Ym9keSBhbGlzdCA9XG4gIGxldCByZWFkbWUgPSBPcHRpb24ubWFwIHJlYWRtZSB+ZjooZnVuIGYgKCkgLT4gU3RyaW5nLnN0cmlwIChmICgpKSkgaW5cbiAgbGF6eV9ncm91cCB+c3VtbWFyeSA/cmVhZG1lID9wcmVzZXJ2ZV9zdWJjb21tYW5kX29yZGVyID9ib2R5IChMYXp5LmZyb21fdmFsIGFsaXN0KVxuOztcblxubGV0IGV4ZWMgfnN1bW1hcnkgP3JlYWRtZSA/KGNoaWxkX3N1YmNvbW1hbmQgPSBbXSkgP2VudiB+cGF0aF90b19leGUgKCkgPVxuICBsZXQgd29ya2luZ19kaXIgPVxuICAgIEZpbGVuYW1lX2Jhc2UuZGlybmFtZVxuICAgIEBAXG4gICAgbWF0Y2ggcGF0aF90b19leGUgd2l0aFxuICAgIHwgYEFic29sdXRlIF8gfCBgUmVsYXRpdmVfdG9fbWUgXyAtPiBTdGRsaWIuU3lzLmV4ZWN1dGFibGVfbmFtZVxuICAgIHwgYFJlbGF0aXZlX3RvX2FyZ3YwIF8gLT4gU3RkbGliLlN5cy5hcmd2LigwKVxuICBpblxuICBsZXQgcGF0aF90b19leGUgPVxuICAgIG1hdGNoIHBhdGhfdG9fZXhlIHdpdGhcbiAgICB8IGBBYnNvbHV0ZSBwIC0+XG4gICAgICBpZiBub3QgKEZpbGVuYW1lX2Jhc2UuaXNfYWJzb2x1dGUgcClcbiAgICAgIHRoZW4gZmFpbHdpdGggXCJQYXRoIHBhc3NlZCB0byBgQWJzb2x1dGUgbXVzdCBiZSBhYnNvbHV0ZVwiXG4gICAgICBlbHNlIHBcbiAgICB8IGBSZWxhdGl2ZV90b19tZSBwIHwgYFJlbGF0aXZlX3RvX2FyZ3YwIHAgLT5cbiAgICAgIGlmIG5vdCAoRmlsZW5hbWVfYmFzZS5pc19yZWxhdGl2ZSBwKVxuICAgICAgdGhlbiBmYWlsd2l0aCBcIlBhdGggcGFzc2VkIHRvIGBSZWxhdGl2ZV90b19tZSBtdXN0IGJlIHJlbGF0aXZlXCJcbiAgICAgIGVsc2UgcFxuICBpblxuICBFeGVjIHsgc3VtbWFyeTsgcmVhZG1lOyB3b3JraW5nX2RpcjsgcGF0aF90b19leGU7IGNoaWxkX3N1YmNvbW1hbmQ7IGVudiB9XG47O1xuXG5sZXQgb2ZfbGF6eSB0aHVuayA9IExhenkgdGh1bmtcblxubGV0IHJlYyBwcm94eV9vZl9zZXhwYWJsZVxuICBzZXhwYWJsZVxuICB+d29ya2luZ19kaXJcbiAgfnBhdGhfdG9fZXhlXG4gIH5jaGlsZF9zdWJjb21tYW5kXG4gIH5wYXRoX3RvX3N1YmNvbW1hbmRcbiAgOiBQcm94eS50XG4gID1cbiAgbGV0IGtpbmQgPVxuICAgIGtpbmRfb2Zfc2V4cGFibGVcbiAgICAgIHNleHBhYmxlXG4gICAgICB+d29ya2luZ19kaXJcbiAgICAgIH5wYXRoX3RvX2V4ZVxuICAgICAgfmNoaWxkX3N1YmNvbW1hbmRcbiAgICAgIH5wYXRoX3RvX3N1YmNvbW1hbmRcbiAgaW5cbiAgeyB3b3JraW5nX2RpcjsgcGF0aF90b19leGU7IHBhdGhfdG9fc3ViY29tbWFuZDsgY2hpbGRfc3ViY29tbWFuZDsga2luZCB9XG5cbmFuZCBraW5kX29mX3NleHBhYmxlXG4gIHNleHBhYmxlXG4gIH53b3JraW5nX2RpclxuICB+cGF0aF90b19leGVcbiAgfmNoaWxkX3N1YmNvbW1hbmRcbiAgfnBhdGhfdG9fc3ViY29tbWFuZFxuICA9XG4gIG1hdGNoIChzZXhwYWJsZSA6IFNoYXBlLlNleHBhYmxlLnQpIHdpdGhcbiAgfCBCYXNlIGIgLT4gUHJveHkuS2luZC5CYXNlIGJcbiAgfCBFeGVjIGUgLT4gUHJveHkuS2luZC5FeGVjIGVcbiAgfCBMYXp5IGwgLT5cbiAgICBQcm94eS5LaW5kLkxhenlcbiAgICAgIChMYXp5Lm1hcCBsIH5mOihmdW4gc2V4cGFibGUgLT5cbiAgICAgICAgIGtpbmRfb2Zfc2V4cGFibGVcbiAgICAgICAgICAgc2V4cGFibGVcbiAgICAgICAgICAgfndvcmtpbmdfZGlyXG4gICAgICAgICAgIH5wYXRoX3RvX2V4ZVxuICAgICAgICAgICB+Y2hpbGRfc3ViY29tbWFuZFxuICAgICAgICAgICB+cGF0aF90b19zdWJjb21tYW5kKSlcbiAgfCBHcm91cCBnIC0+XG4gICAgUHJveHkuS2luZC5Hcm91cFxuICAgICAgeyBnIHdpdGhcbiAgICAgICAgc3ViY29tbWFuZHMgPVxuICAgICAgICAgIExhenkubWFwXG4gICAgICAgICAgICBnLnN1YmNvbW1hbmRzXG4gICAgICAgICAgICB+ZjpcbiAgICAgICAgICAgICAgKExpc3QubWFwIH5mOihmdW4gKHN0ciwgc2V4cGFibGUpIC0+XG4gICAgICAgICAgICAgICAgIGxldCBwYXRoX3RvX3N1YmNvbW1hbmQgPSBwYXRoX3RvX3N1YmNvbW1hbmQgQCBbIHN0ciBdIGluXG4gICAgICAgICAgICAgICAgIGxldCBwcm94eSA9XG4gICAgICAgICAgICAgICAgICAgcHJveHlfb2Zfc2V4cGFibGVcbiAgICAgICAgICAgICAgICAgICAgIHNleHBhYmxlXG4gICAgICAgICAgICAgICAgICAgICB+d29ya2luZ19kaXJcbiAgICAgICAgICAgICAgICAgICAgIH5wYXRoX3RvX2V4ZVxuICAgICAgICAgICAgICAgICAgICAgfmNoaWxkX3N1YmNvbW1hbmRcbiAgICAgICAgICAgICAgICAgICAgIH5wYXRoX3RvX3N1YmNvbW1hbmRcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgc3RyLCBwcm94eSkpXG4gICAgICB9XG47O1xuXG5tb2R1bGUgVmVyc2lvbl9pbmZvIChWZXJzaW9uX3V0aWwgOiBWZXJzaW9uX3V0aWwpID0gc3RydWN0XG4gIGxldCBwcmludF92ZXJzaW9uIH52ZXJzaW9uID0gcHJpbnRfZW5kbGluZSAoZm9yY2UgdmVyc2lvbilcbiAgbGV0IHByaW50X2J1aWxkX2luZm8gfmJ1aWxkX2luZm8gPSBwcmludF9lbmRsaW5lIChmb3JjZSBidWlsZF9pbmZvKVxuXG4gIGxldCBjb21tYW5kIH52ZXJzaW9uIH5idWlsZF9pbmZvID1cbiAgICBiYXNpY1xuICAgICAgfnN1bW1hcnk6XCJwcmludCB2ZXJzaW9uIGluZm9ybWF0aW9uXCJcbiAgICAgIENvbW1hbmRfYmFzZS5QYXJhbS4oXG4gICAgICAgIHJldHVybiAoZnVuIHZlcnNpb25fZmxhZyBidWlsZF9pbmZvX2ZsYWcgLT5cbiAgICAgICAgICBpZiBidWlsZF9pbmZvX2ZsYWdcbiAgICAgICAgICB0aGVuIHByaW50X2J1aWxkX2luZm8gfmJ1aWxkX2luZm9cbiAgICAgICAgICBlbHNlIGlmIHZlcnNpb25fZmxhZ1xuICAgICAgICAgIHRoZW4gcHJpbnRfdmVyc2lvbiB+dmVyc2lvblxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgcHJpbnRfYnVpbGRfaW5mbyB+YnVpbGRfaW5mbztcbiAgICAgICAgICAgIHByaW50X3ZlcnNpb24gfnZlcnNpb24pO1xuICAgICAgICAgIGV4aXQgMClcbiAgICAgICAgPCo+IGZsYWcgXCItdmVyc2lvblwiIG5vX2FyZyB+ZG9jOlwiIHByaW50IHRoZSB2ZXJzaW9uIG9mIHRoaXMgYnVpbGRcIlxuICAgICAgICA8Kj4gZmxhZyBcIi1idWlsZC1pbmZvXCIgbm9fYXJnIH5kb2M6XCIgcHJpbnQgYnVpbGQgaW5mbyBmb3IgdGhpcyBidWlsZFwiKVxuICA7O1xuXG4gIGxldCByZWMgYWRkIH52ZXJzaW9uIH5idWlsZF9pbmZvIHVudmVyc2lvbmVkID1cbiAgICBtYXRjaCB1bnZlcnNpb25lZCB3aXRoXG4gICAgfCBCYXNlIGJhc2UgLT5cbiAgICAgIGxldCBiYXNlID1cbiAgICAgICAgQmFpbG91dF9kdW1wX2ZsYWcuYWRkXG4gICAgICAgICAgYmFzZVxuICAgICAgICAgIH5uYW1lOlwiLXZlcnNpb25cIlxuICAgICAgICAgIH5hbGlhc2VzOltdXG4gICAgICAgICAgfmFsaWFzZXNfZXhjbHVkZWRfZnJvbV9oZWxwOlsgXCItLXZlcnNpb25cIiBdXG4gICAgICAgICAgfnRleHRfc3VtbWFyeTpcInRoZSB2ZXJzaW9uIG9mIHRoaXMgYnVpbGRcIlxuICAgICAgICAgIH50ZXh0OihmdW4gXyAtPiBmb3JjZSB2ZXJzaW9uKVxuICAgICAgaW5cbiAgICAgIGxldCBiYXNlID1cbiAgICAgICAgQmFpbG91dF9kdW1wX2ZsYWcuYWRkXG4gICAgICAgICAgYmFzZVxuICAgICAgICAgIH5uYW1lOlwiLWJ1aWxkLWluZm9cIlxuICAgICAgICAgIH5hbGlhc2VzOltdXG4gICAgICAgICAgfmFsaWFzZXNfZXhjbHVkZWRfZnJvbV9oZWxwOlsgXCItLWJ1aWxkLWluZm9cIiBdXG4gICAgICAgICAgfnRleHRfc3VtbWFyeTpcImluZm8gYWJvdXQgdGhpcyBidWlsZFwiXG4gICAgICAgICAgfnRleHQ6KGZ1biBfIC0+IGZvcmNlIGJ1aWxkX2luZm8pXG4gICAgICBpblxuICAgICAgQmFzZSBiYXNlXG4gICAgfCBHcm91cCBncm91cCAtPlxuICAgICAgbGV0IHN1YmNvbW1hbmRzID1cbiAgICAgICAgTGF6eS5tYXAgZ3JvdXAuR3JvdXAuc3ViY29tbWFuZHMgfmY6KGZ1biBzdWJjb21tYW5kcyAtPlxuICAgICAgICAgIGV4dGVuZF9hbGlzdF9leG5cbiAgICAgICAgICAgIHN1YmNvbW1hbmRzXG4gICAgICAgICAgICBLZXlfdHlwZS5TdWJjb21tYW5kXG4gICAgICAgICAgICB+a2V5OlwidmVyc2lvblwiXG4gICAgICAgICAgICAoY29tbWFuZCB+dmVyc2lvbiB+YnVpbGRfaW5mbykpXG4gICAgICBpblxuICAgICAgR3JvdXAgeyBncm91cCB3aXRoIEdyb3VwLnN1YmNvbW1hbmRzIH1cbiAgICB8IEV4ZWMgZXhlYyAtPiBFeGVjIGV4ZWNcbiAgICB8IExhenkgdGh1bmsgLT4gTGF6eSAobGF6eSAoYWRkIH52ZXJzaW9uIH5idWlsZF9pbmZvIChMYXp5LmZvcmNlIHRodW5rKSkpXG4gIDs7XG5cbiAgbGV0IG5vcm1hbGl6ZV92ZXJzaW9uX2xpbmVzIGxpbmVzID1cbiAgICBTdHJpbmcuY29uY2F0IH5zZXA6XCJcXG5cIiAoTGlzdC5zb3J0IGxpbmVzIH5jb21wYXJlOlN0cmluZy5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBkZWZhdWx0X3ZlcnNpb24gPSBsYXp5IChub3JtYWxpemVfdmVyc2lvbl9saW5lcyBWZXJzaW9uX3V0aWwudmVyc2lvbl9saXN0KVxuXG4gIGxldCBkZWZhdWx0X2J1aWxkX2luZm8gPVxuICAgIGxhenlcbiAgICAgICgqIGxhenkgdG8gYXZvaWQgbG9hZGluZyBhbGwgdGhlIHRpbWUgem9uZSBzdHVmZiBhdCB0b3BsZXZlbCAqKVxuICAgICAgKFZlcnNpb25fdXRpbC5yZXByaW50X2J1aWxkX2luZm8gVmVyc2lvbl91dGlsLlRpbWUuc2V4cF9vZl90KVxuICA7O1xuZW5kXG5cbmxldCV0ZXN0X21vZHVsZSBcIlZlcnNpb25faW5mb1wiID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICBtb2R1bGUgVmVyc2lvbl9pbmZvID0gVmVyc2lvbl9pbmZvIChzdHJ1Y3RcbiAgICAgIGxldCB2ZXJzaW9uX2xpc3QgPSBbIFwiaGc6Ly9zb21lL3BhdGhfMHhkZWFkYmVlZlwiOyBcInNzaDovL2EvcGF0aF84YmFkZjAwZFwiIF1cbiAgICAgIGxldCByZXByaW50X2J1aWxkX2luZm8gdG9fc2V4cCA9IFNleHAudG9fc3RyaW5nICh0b19zZXhwICgpKVxuXG4gICAgICBtb2R1bGUgVGltZSA9IHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSB1bml0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gICAgICBlbmRcbiAgICBlbmQpXG5cbiAgICBsZXQlZXhwZWN0X3Rlc3QgXCJwcmludCB2ZXJzaW9uIHdoZXJlIG11bHRpcGxlIHJlcG9zIGFyZSB1c2VkXCIgPVxuICAgICAgVmVyc2lvbl9pbmZvLnByaW50X3ZlcnNpb24gfnZlcnNpb246VmVyc2lvbl9pbmZvLmRlZmF1bHRfdmVyc2lvbjtcbiAgICAgIFslZXhwZWN0XG4gICAgICAgIHt8XG4gICAgICAgIGhnOi8vc29tZS9wYXRoXzB4ZGVhZGJlZWZcbiAgICAgICAgc3NoOi8vYS9wYXRoXzhiYWRmMDBkXG4gICAgICAgIHx9XVxuICAgIDs7XG5cbiAgICBsZXQlZXhwZWN0X3Rlc3QgXCJwcmludCBidWlsZCBpbmZvXCIgPVxuICAgICAgVmVyc2lvbl9pbmZvLnByaW50X2J1aWxkX2luZm8gfmJ1aWxkX2luZm86KGxhenkgXCJzb21lIGJ1aWxkIGluZm9cIik7XG4gICAgICBbJWV4cGVjdCB7fCBzb21lIGJ1aWxkIGluZm8gfH1dXG4gICAgOztcbiAgZW5kKVxuOztcblxubGV0IHJlYyBzdW1tYXJ5ID0gZnVuY3Rpb25cbiAgfCBCYXNlIHggLT4geC5zdW1tYXJ5XG4gIHwgR3JvdXAgeCAtPiB4LnN1bW1hcnlcbiAgfCBFeGVjIHggLT4geC5zdW1tYXJ5XG4gIHwgTGF6eSB0aHVuayAtPiBzdW1tYXJ5IChMYXp5LmZvcmNlIHRodW5rKVxuOztcblxubW9kdWxlIFNwZWMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBDb21tYW5kX2Jhc2UuU3BlY1xuXG4gIGxldCBwYXRoID0gbWFwIH5mOlBhdGgucGFydHNfZXhlX2Jhc2VuYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgRGVwcmVjYXRlZCA9IHN0cnVjdFxuICBtb2R1bGUgU3BlYyA9IFNwZWMuRGVwcmVjYXRlZFxuXG4gIGxldCBzdW1tYXJ5ID0gc3VtbWFyeVxuXG4gIGxldCByZWMgZ2V0X2ZsYWdfbmFtZXMgPSBmdW5jdGlvblxuICAgIHwgQmFzZSBiYXNlIC0+IGJhc2UuQ29tbWFuZF9iYXNlLmZsYWdzIHw+IE1hcC5rZXlzXG4gICAgfCBMYXp5IHRodW5rIC0+IGdldF9mbGFnX25hbWVzIChMYXp5LmZvcmNlIHRodW5rKVxuICAgIHwgR3JvdXAgXyB8IEV4ZWMgXyAtPiBhc3NlcnQgZmFsc2VcbiAgOztcblxuICBsZXQgaGVscF9yZWN1cnNpdmUgfmNtZCB+d2l0aF9mbGFncyB+ZXhwYW5kX2RvdHMgdCBzID1cbiAgICBsZXQgcmVjIGhlbHBfcmVjdXJzaXZlX3JlYyB+Y21kIHQgcyA9XG4gICAgICBsZXQgbmV3X3MgPSBzIF4gKGlmIGV4cGFuZF9kb3RzIHRoZW4gY21kIGVsc2UgXCIuXCIpIF4gXCIgXCIgaW5cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBMYXp5IHRodW5rIC0+XG4gICAgICAgIGxldCB0ID0gTGF6eS5mb3JjZSB0aHVuayBpblxuICAgICAgICBoZWxwX3JlY3Vyc2l2ZV9yZWMgfmNtZCB0IHNcbiAgICAgIHwgQmFzZSBiYXNlIC0+XG4gICAgICAgIGxldCBiYXNlX2hlbHAgPSBzIF4gY21kLCBzdW1tYXJ5IChCYXNlIGJhc2UpIGluXG4gICAgICAgIGlmIHdpdGhfZmxhZ3NcbiAgICAgICAgdGhlblxuICAgICAgICAgIGJhc2VfaGVscFxuICAgICAgICAgIDo6IExpc3QubWFwXG4gICAgICAgICAgICAgICB+ZjooZnVuIChmbGFnLCBoKSAtPiBuZXdfcyBeIGZsYWcsIGgpXG4gICAgICAgICAgICAgICAoTGlzdC5zb3J0XG4gICAgICAgICAgICAgICAgICB+Y29tcGFyZTpDb21tYW5kX2Jhc2UuRGVwcmVjYXRlZC5zdWJjb21tYW5kX2NtcF9mc3RcbiAgICAgICAgICAgICAgICAgIChDb21tYW5kX2Jhc2UuRGVwcmVjYXRlZC5mbGFnc19oZWxwIH5kaXNwbGF5X2hlbHBfZmxhZ3M6ZmFsc2UgYmFzZSkpXG4gICAgICAgIGVsc2UgWyBiYXNlX2hlbHAgXVxuICAgICAgfCBHcm91cCB7IHN1bW1hcnk7IHN1YmNvbW1hbmRzOyByZWFkbWUgPSBfOyBib2R5ID0gXyB9IC0+XG4gICAgICAgIChzIF4gY21kLCBzdW1tYXJ5KVxuICAgICAgICA6OiAoTGF6eS5mb3JjZSBzdWJjb21tYW5kc1xuICAgICAgICAgICAgfD4gTGlzdC5zb3J0IH5jb21wYXJlOkNvbW1hbmRfYmFzZS5EZXByZWNhdGVkLnN1YmNvbW1hbmRfY21wX2ZzdFxuICAgICAgICAgICAgfD4gTGlzdC5jb25jYXRfbWFwIH5mOihmdW4gKGNtZCcsIHQpIC0+IGhlbHBfcmVjdXJzaXZlX3JlYyB+Y21kOmNtZCcgdCBuZXdfcylcbiAgICAgICAgICAgKVxuICAgICAgfCBFeGVjIF8gLT5cbiAgICAgICAgKCogQ29tbWFuZC5leGVjIGRvZXMgbm90IHN1cHBvcnQgZGVwcmVjYXRlZCBjb21tYW5kcyAqKVxuICAgICAgICBbXVxuICAgIGluXG4gICAgaGVscF9yZWN1cnNpdmVfcmVjIH5jbWQgdCBzXG4gIDs7XG5lbmRcblxuKCogVGhpcyBzY3JpcHQgd29ya3MgaW4gYm90aCBiYXNoICh2aWEgcmVhZGFycmF5KSBhbmQgenNoICh2aWEgcmVhZCAtQSkuICBJZiB5b3UgY2hhbmdlXG4gICBpdCwgcGxlYXNlIHRlc3QgaW4gYm90aCBiYXNoIGFuZCB6c2guICBJdCBkb2VzIG5vdCB3b3JrIHRjc2ggKGRpZmZlcmVudCBmdW5jdGlvblxuICAgc3ludGF4KS4gKilcbmxldCBhdXRvY29tcGxldGVfZnVuY3Rpb24gfmFyZ3ZfMCB+cGlkID1cbiAgbGV0IGZuYW1lID1cbiAgICAoKiBOb3RlOiB3ZSBwYWQgdGhlIHBpZCB0byBhIGRldGVybWluaXN0aWMgbGVuZ3RoLCBhcyBpbiAyMDIzIGl0IHdhcyBkZXRlcm1pbmVkIHRoYXRcbiAgICAgICBpZiBtdWx0aXBsZSBpbnZvY2F0aW9ucyBvY2N1cnJlZCBhdCB0aGUgc2FtZSB0aW1lIG9mIHJlcXVlc3RpbmcgdGhlc2UgZnVuY3Rpb25zIHRvXG4gICAgICAgYmUgd3JpdHRlbiB0byB0aGUgc2FtZSBmaWxlIChlLmcuIDIgc2hlbGxzIG9wZW5pbmcgYXQgL2V4YWN0bHkvIHRoZSByaWdodCB0aW1lKVxuICAgICAgIHRoZXJlIHdvdWxkIGJlIGJhZCBleHRyYSBieXRlcyBsZWZ0IG92ZXIgaW4gdGhlIHdyaXR0ZW4gZmlsZSwgc28gbWFraW5nIGl0LFxuICAgICAgIGRldGVybWluaXN0aWMgaW4gbGVuZ3RoIGlycmVzcGVjdGl2ZSBvZiB0aGUgcGlkIGlzIGltcG9ydGFudC4gR2l2ZW4gdGhhdCBwaWRzIGRvbid0XG4gICAgICAgZXhjZWVkIDY1NTM2LCAxMCBkaWdpdHMgc2hvdWxkIGdpdmUgdXMgbG90cyBvZiBicmVhdGhpbmcgcm9vbS4gKilcbiAgICBzcHJpbnRmIFwiX2pzYXV0b2NvbV8lMDEwZFwiIHBpZFxuICBpblxuICBzcHJpbnRmXG4gICAgXCJmdW5jdGlvbiAlcyB7XFxuXFxcbiAgICBcXCAgZXhwb3J0IENPTVBfQ1dPUkRcXG5cXFxuICAgIFxcICBDT01QX1dPUkRTWzBdPSVzXFxuXFxcbiAgICBcXCAgaWYgdHlwZSByZWFkYXJyYXkgPiAvZGV2L251bGxcXG5cXFxuICAgIFxcICB0aGVuIHJlYWRhcnJheSAtdCBDT01QUkVQTFkgPCA8KFxcXCIke0NPTVBfV09SRFNbQF19XFxcIilcXG5cXFxuICAgIFxcICBlbHNlIElGUz1cXFwiXFxuXFxcbiAgICAgXFxcIiByZWFkIC1kIFxcXCJcXFwiIC1BIENPTVBSRVBMWSA8IDwoXFxcIiR7Q09NUF9XT1JEU1tAXX1cXFwiKVxcblxcXG4gICAgXFwgIGZpXFxuXFxcbiAgICAgfVxcblxcXG4gICAgIGNvbXBsZXRlIC1GICVzICVzXFxuXFxcbiAgICAgJSFcIlxuICAgIGZuYW1lXG4gICAgYXJndl8wXG4gICAgZm5hbWVcbiAgICBhcmd2XzBcbjs7XG5cbmxldCVleHBlY3RfdGVzdCBcIkRlbW9uc3RyYXRlIFthdXRvY29tcGxldGVfZnVuY3Rpb25dXCIgPVxuICBhdXRvY29tcGxldGVfZnVuY3Rpb24gfmFyZ3ZfMDpcIjxhcmd2XzA+XCIgfnBpZDoxMjM0NSB8PiBwcmludF9lbmRsaW5lO1xuICBbJWV4cGVjdFxuICAgIHt8XG4gICAgZnVuY3Rpb24gX2pzYXV0b2NvbV8wMDAwMDEyMzQ1IHtcbiAgICAgIGV4cG9ydCBDT01QX0NXT1JEXG4gICAgICBDT01QX1dPUkRTWzBdPTxhcmd2XzA+XG4gICAgICBpZiB0eXBlIHJlYWRhcnJheSA+IC9kZXYvbnVsbFxuICAgICAgdGhlbiByZWFkYXJyYXkgLXQgQ09NUFJFUExZIDwgPChcIiR7Q09NUF9XT1JEU1tAXX1cIilcbiAgICAgIGVsc2UgSUZTPVwiXG4gICAgXCIgcmVhZCAtZCBcIlwiIC1BIENPTVBSRVBMWSA8IDwoXCIke0NPTVBfV09SRFNbQF19XCIpXG4gICAgICBmaVxuICAgIH1cbiAgICBjb21wbGV0ZSAtRiBfanNhdXRvY29tXzAwMDAwMTIzNDUgPGFyZ3ZfMD5cbiAgICB8fV1cbjs7XG5cbm1vZHVsZSBGb3JfdW5peCAoRm9yX3VuaXhfd2l0aF9zdHJpbmdfZW52X3ZhciA6IEZvcl91bml4IHdpdGggdHlwZSBlbnZfdmFyIDo9IHN0cmluZykgPVxuc3RydWN0XG4gIG1vZHVsZSBWZXJzaW9uX2luZm8gPSBWZXJzaW9uX2luZm8gKEZvcl91bml4X3dpdGhfc3RyaW5nX2Vudl92YXIuVmVyc2lvbl91dGlsKVxuXG4gIG1vZHVsZSBGb3JfdW5peF93aXRoX2NvbW1hbmRfZW52X3ZhciA6IEZvcl91bml4IHdpdGggdHlwZSBlbnZfdmFyIDo9IEVudl92YXIudCA9IHN0cnVjdFxuICAgICgqIFdlIGZvcmNlIGFjY2VzcyB0byBlbnYgdmFycyB0byBnbyB0aHJvdWdoIFtDb21tYW5kX2Vudl92YXJdIHNvIHRoYXQgd2UgY2FuIGtlZXAgYW5cbiAgICAgICBhY2N1cmF0ZSBlbnVtZXJhdGlvbiBvZiB0aGUgdmFyaWFibGVzIHdlIHVzZS4gKilcblxuICAgIGluY2x1ZGUgRm9yX3VuaXhfd2l0aF9zdHJpbmdfZW52X3ZhclxuXG4gICAgbW9kdWxlIFVuaXggPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgVW5peFxuXG4gICAgICBsZXQgcHV0ZW52IH5rZXkgfmRhdGEgPSBwdXRlbnYgfmtleTooRW52X3Zhci50b19zdHJpbmcga2V5KSB+ZGF0YVxuICAgICAgbGV0IHVuc2V0ZW52IGtleSA9IHVuc2V0ZW52IChFbnZfdmFyLnRvX3N0cmluZyBrZXkpXG4gICAgICBsZXQgdW5zYWZlX2dldGVudiBrZXkgPSB1bnNhZmVfZ2V0ZW52IChFbnZfdmFyLnRvX3N0cmluZyBrZXkpXG5cbiAgICAgIGxldCBjb252ZXJ0X2VudiBlbnYgPVxuICAgICAgICBsZXQgY29udmVydF9jb21tYW5kX2Vudl92YXJfdG9fc3RyaW5nIGxpc3QgPVxuICAgICAgICAgIExpc3QubWFwIGxpc3QgfmY6KGZ1biAoZW52X3Zhciwgc3RyKSAtPiBFbnZfdmFyLnRvX3N0cmluZyBlbnZfdmFyLCBzdHIpXG4gICAgICAgIGluXG4gICAgICAgIG1hdGNoIGVudiB3aXRoXG4gICAgICAgIHwgYFJlcGxhY2UgbGlzdCAtPiBgUmVwbGFjZSAoY29udmVydF9jb21tYW5kX2Vudl92YXJfdG9fc3RyaW5nIGxpc3QpXG4gICAgICAgIHwgYEV4dGVuZCBsaXN0IC0+IGBFeHRlbmQgKGNvbnZlcnRfY29tbWFuZF9lbnZfdmFyX3RvX3N0cmluZyBsaXN0KVxuICAgICAgICB8IGBPdmVycmlkZSBsaXN0IC0+IGBPdmVycmlkZSAoY29udmVydF9jb21tYW5kX2Vudl92YXJfdG9fc3RyaW5nIGxpc3QpXG4gICAgICAgIHwgYFJlcGxhY2VfcmF3IF8gYXMgcmVwbGFjZSAtPiByZXBsYWNlXG4gICAgICA7O1xuXG4gICAgICBsZXQgZXhlYyB+cHJvZyB+YXJndiA/dXNlX3BhdGggP2VudiAoKSA9XG4gICAgICAgIGV4ZWMgfnByb2cgfmFyZ3YgP3VzZV9wYXRoID9lbnY6KE9wdGlvbi5tYXAgZW52IH5mOmNvbnZlcnRfZW52KSAoKVxuICAgICAgOztcblxuICAgICAgbGV0IGNyZWF0ZV9wcm9jZXNzX2VudiA/d29ya2luZ19kaXIgP3Byb2dfc2VhcmNoX3BhdGggP2FyZ3YwIH5wcm9nIH5hcmdzIH5lbnYgKCkgPVxuICAgICAgICBjcmVhdGVfcHJvY2Vzc19lbnZcbiAgICAgICAgICA/d29ya2luZ19kaXJcbiAgICAgICAgICA/cHJvZ19zZWFyY2hfcGF0aFxuICAgICAgICAgID9hcmd2MFxuICAgICAgICAgIH5wcm9nXG4gICAgICAgICAgfmFyZ3NcbiAgICAgICAgICB+ZW52Oihjb252ZXJ0X2VudiBlbnYpXG4gICAgICAgICAgKClcbiAgICAgIDs7XG4gICAgZW5kXG4gIGVuZFxuXG4gIG9wZW4gRm9yX3VuaXhfd2l0aF9jb21tYW5kX2Vudl92YXJcblxuICAoKiBDbGVhciB0aGUgc2V0dGluZyBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZSBhc3NvY2lhdGVkIHdpdGggY29tbWFuZC1saW5lXG4gICAgIGNvbXBsZXRpb24gYW5kIHJlY3Vyc2l2ZSBoZWxwIHNvIHRoYXQgc3VicHJvY2Vzc2VzIGRvbid0IHNlZSB0aGVtLlxuXG4gICAgIFVzZSBbdW5zYWZlX2dldGVudl0gc28gc2V0dWlkLXJvb3QgcHJvZ3JhbXMgY2FuIHN0aWxsIHJlYWQgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICBUaGVyZSBpcyBubyBzZWN1cml0eSByaXNrIGhlcmUgYmVjYXVzZSB0aGUgdmFsdWVzIGFyZSBvbmx5IHVzZWQgYXMgdHJpZ2dlcnMgdG8gZHVtcFxuICAgICBvdXQgY29tbWFuZCBpbmZvcm1hdGlvbi4gKilcbiAgbGV0IGdldGVudl9hbmRfY2xlYXIgdmFyID1cbiAgICBsZXQgdmFsdWUgPSBVbml4LnVuc2FmZV9nZXRlbnYgdmFyIGluXG4gICAgaWYgT3B0aW9uLmlzX3NvbWUgdmFsdWUgdGhlbiBVbml4LnVuc2V0ZW52IHZhcjtcbiAgICB2YWx1ZVxuICA7O1xuXG4gIGxldCBtYXliZV9jb21wX2N3b3JkICgpID0gZ2V0ZW52X2FuZF9jbGVhciBjb21wX2N3b3JkIHw+IE9wdGlvbi5tYXAgfmY6SW50Lm9mX3N0cmluZ1xuXG4gIGxldCBzZXRfY29tcF9jd29yZCBuZXdfdmFsdWUgPVxuICAgIGxldCBuZXdfdmFsdWUgPSBJbnQudG9fc3RyaW5nIG5ld192YWx1ZSBpblxuICAgIFVuaXgucHV0ZW52IH5rZXk6Y29tcF9jd29yZCB+ZGF0YTpuZXdfdmFsdWVcbiAgOztcblxuICBtb2R1bGUgRXhlYyA9IHN0cnVjdFxuICAgIGluY2x1ZGUgRXhlY1xuXG4gICAgbGV0IGV4ZWNfd2l0aF9hcmdzIHQgfmFyZ3Mgfm1heWJlX25ld19jb21wX2N3b3JkID1cbiAgICAgIGxldCBwcm9nID0gYWJzX3BhdGggfmRpcjp0LndvcmtpbmdfZGlyIHQucGF0aF90b19leGUgaW5cbiAgICAgIGxldCBhcmdzID0gdC5jaGlsZF9zdWJjb21tYW5kIEAgYXJncyBpblxuICAgICAgbGV0IGVudiA9IHQuZW52IGluXG4gICAgICBPcHRpb24uaXRlciBtYXliZV9uZXdfY29tcF9jd29yZCB+ZjooZnVuIG4gLT5cbiAgICAgICAgKCogVGhlIGxvZ2ljIGZvciB0cmFja2luZyBbbWF5YmVfbmV3X2NvbXBfY3dvcmRdIGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgd2hldGhlclxuICAgICAgICAgICB0aGlzIGV4ZWMgc3BlY2lmaWVzIGEgY2hpbGQgc3ViY29tbWFuZC4gSWYgaXQgZG9lcywgQ09NUF9DV09SRCBuZWVkcyB0byBiZSBzZXRcbiAgICAgICAgICAgaGlnaGVyIHRvIGFjY291bnQgZm9yIHRoZSBhcmd1bWVudHMgdXNlZCB0byBzcGVjaWZ5IHRoZSBjaGlsZCBzdWJjb21tYW5kLiAqKVxuICAgICAgICBzZXRfY29tcF9jd29yZCAobiArIExpc3QubGVuZ3RoIHQuY2hpbGRfc3ViY29tbWFuZCkpO1xuICAgICAgTm90aGluZy51bnJlYWNoYWJsZV9jb2RlXG4gICAgICAgIChGb3JfdW5peF93aXRoX3N0cmluZ19lbnZfdmFyLlVuaXguZXhlYyA/ZW52IH5wcm9nIH5hcmd2Oihwcm9nIDo6IGFyZ3MpICgpKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBTZXhwYWJsZSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgU2hhcGUuU2V4cGFibGVcblxuICAgIGxldCByZWFkX3N0ZG91dF9hbmRfc3RkZXJyIChwcm9jZXNzX2luZm8gOiBVbml4LlByb2Nlc3NfaW5mby50KSA9XG4gICAgICAoKiBXZSBuZWVkIHRvIHJlYWQgZWFjaCBvZiBzdGRvdXQgYW5kIHN0ZGVyciBpbiBhIHNlcGFyYXRlIHRocmVhZCB0byBhdm9pZCBkZWFkbG9ja3NcbiAgICAgICAgIGlmIHRoZSBjaGlsZCBwcm9jZXNzIGRlY2lkZXMgdG8gd2FpdCBmb3IgYSByZWFkIG9uIG9uZSBiZWZvcmUgY2xvc2luZyB0aGUgb3RoZXIuXG4gICAgICAgICBCdWZmZXJpbmcgbWF5IGhpZGUgdGhpcyBwcm9ibGVtIHVudGlsIG91dHB1dCBpcyBcInN1ZmZpY2llbnRseSBsYXJnZVwiLiAqKVxuICAgICAgbGV0IHN0YXJ0X3JlYWRpbmcgZGVzY3IgaW5mbyA9XG4gICAgICAgIGxldCBvdXRwdXQgPSByZWYgTm9uZSBpblxuICAgICAgICBsZXQgdGhyZWFkID1cbiAgICAgICAgICBUaHJlYWQuY3JlYXRlXG4gICAgICAgICAgICB+b25fdW5jYXVnaHRfZXhuOmBQcmludF90b19zdGRlcnJcbiAgICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgUmVzdWx0LnRyeV93aXRoIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgIGRlc2NyIHw+IFVuaXguaW5fY2hhbm5lbF9vZl9kZXNjciB8PiBJbl9jaGFubmVsLmlucHV0X2FsbClcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgb3V0cHV0IDo9IFNvbWUgcmVzdWx0KVxuICAgICAgICAgICAgKClcbiAgICAgICAgaW5cbiAgICAgICAgU3RhZ2VkLnN0YWdlIChmdW4gKCkgLT5cbiAgICAgICAgICBUaHJlYWQuam9pbiB0aHJlYWQ7XG4gICAgICAgICAgVW5peC5jbG9zZSBkZXNjcjtcbiAgICAgICAgICBtYXRjaCAhb3V0cHV0IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJCVUcgZmFpbGVkIHRvIHJlYWRcIiAoaW5mbyA6IEluZm8udCldXG4gICAgICAgICAgfCBTb21lIChPayBvdXRwdXQpIC0+IG91dHB1dFxuICAgICAgICAgIHwgU29tZSAoRXJyb3IgZXhuKSAtPiByYWlzZSBleG4pXG4gICAgICBpblxuICAgICAgKCogV2UgbWlnaHQgaGFuZyBmb3JldmVyIHRyeWluZyB0byBqb2luIHRoZSByZWFkaW5nIHRocmVhZHMgaWYgdGhlIGNoaWxkIHByb2Nlc3Mga2VlcHNcbiAgICAgICAgIHRoZSBmaWxlIGRlc2NyaXB0b3Igb3Blbi4gTm90IGhhbmRsaW5nIHRoaXMgYmVjYXVzZSBJIHRoaW5rIHdlJ3ZlIG5ldmVyIHNlZW4gaXRcbiAgICAgICAgIGluIHRoZSB3aWxkIGRlc3BpdGUgcnVubmluZyB2dWxuZXJhYmxlIGNvZGUgZm9yIHllYXJzLiAqKVxuICAgICAgKCogV2UgaGF2ZSB0byBzdGFydCBib3RoIHRocmVhZHMgYmVmb3JlIGpvaW5pbmcgYW55IG9mIHRoZW0uICopXG4gICAgICBsZXQgZmluaXNoX3N0ZG91dCA9IHN0YXJ0X3JlYWRpbmcgcHJvY2Vzc19pbmZvLnN0ZG91dCAoSW5mby5vZl9zdHJpbmcgXCJzdGRvdXRcIikgaW5cbiAgICAgIGxldCBmaW5pc2hfc3RkZXJyID0gc3RhcnRfcmVhZGluZyBwcm9jZXNzX2luZm8uc3RkZXJyIChJbmZvLm9mX3N0cmluZyBcInN0ZGVyclwiKSBpblxuICAgICAgU3RhZ2VkLnVuc3RhZ2UgZmluaXNoX3N0ZG91dCAoKSwgU3RhZ2VkLnVuc3RhZ2UgZmluaXNoX3N0ZGVyciAoKVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZXh0ZXJuYWwgfndvcmtpbmdfZGlyIH5wYXRoX3RvX2V4ZSB+Y2hpbGRfc3ViY29tbWFuZCA9XG4gICAgICBsZXQgcHJvY2Vzc19pbmZvID1cbiAgICAgICAgVW5peC5jcmVhdGVfcHJvY2Vzc19lbnZcbiAgICAgICAgICAoKVxuICAgICAgICAgIH5wcm9nOihhYnNfcGF0aCB+ZGlyOndvcmtpbmdfZGlyIHBhdGhfdG9fZXhlKVxuICAgICAgICAgIH5hcmdzOmNoaWxkX3N1YmNvbW1hbmRcbiAgICAgICAgICB+ZW52OlxuICAgICAgICAgICAgKGxldCBoZWxwX3NleHAgPVxuICAgICAgICAgICAgICAgc3VwcG9ydGVkX3ZlcnNpb25zIHw+IFNldC5zZXhwX29mX21fX3QgKG1vZHVsZSBJbnQpIHw+IFNleHAudG9fc3RyaW5nXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBgRXh0ZW5kIFsgQ09NTUFORF9PVVRQVVRfSEVMUF9TRVhQLCBoZWxwX3NleHAgXSlcbiAgICAgIGluXG4gICAgICBVbml4LmNsb3NlIHByb2Nlc3NfaW5mby5zdGRpbjtcbiAgICAgIGxldCBzdGRvdXQsIHN0ZGVyciA9IHJlYWRfc3Rkb3V0X2FuZF9zdGRlcnIgcHJvY2Vzc19pbmZvIGluXG4gICAgICBVbml4LndhaXQgcHJvY2Vzc19pbmZvLnBpZDtcbiAgICAgICgqIE5vdyB3ZSd2ZSBraWxsZWQgYWxsIHRoZSBwcm9jZXNzZXMgYW5kIHRocmVhZHMgd2UgbWFkZS4gKilcbiAgICAgIG1hdGNoIHN0ZG91dCB8PiBTZXhwbGliLlNleHAub2Zfc3RyaW5nIHw+IFZlcnNpb25lZC50X29mX3NleHAgfD4gb2ZfdmVyc2lvbmVkIHdpdGhcbiAgICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgICByYWlzZV9zXG4gICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICBcImNhbm5vdCBwYXJzZSBjb21tYW5kIHNoYXBlXCJcbiAgICAgICAgICAgICAgfl86KGV4biA6IGV4bilcbiAgICAgICAgICAgICAgKHN0ZG91dCA6IHN0cmluZylcbiAgICAgICAgICAgICAgKHN0ZGVyciA6IHN0cmluZyldXG4gICAgICB8IHQgLT4gdFxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGZpbmQgKHQgOiB0KSB+cGF0aF90b19zdWJjb21tYW5kID1cbiAgICAgIG1hdGNoIHBhdGhfdG9fc3ViY29tbWFuZCB3aXRoXG4gICAgICB8IFtdIC0+IHRcbiAgICAgIHwgc3ViIDo6IHN1YnMgLT5cbiAgICAgICAgaWYgU3RyaW5nLmlzX3ByZWZpeCBzdWIgfnByZWZpeDpcIi1cIlxuICAgICAgICB0aGVuIHRcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgICAgfCBCYXNlIF8gLT4gZmFpbHdpdGhmIFwidW5leHBlY3RlZCBzdWJjb21tYW5kICVTXCIgc3ViICgpXG4gICAgICAgICAgfCBMYXp5IHRodW5rIC0+IGZpbmQgKExhenkuZm9yY2UgdGh1bmspIH5wYXRoX3RvX3N1YmNvbW1hbmRcbiAgICAgICAgICB8IEV4ZWMgeyBwYXRoX3RvX2V4ZTsgd29ya2luZ19kaXI7IGNoaWxkX3N1YmNvbW1hbmQ7IF8gfSAtPlxuICAgICAgICAgICAgZmluZFxuICAgICAgICAgICAgICAob2ZfZXh0ZXJuYWwgfndvcmtpbmdfZGlyIH5wYXRoX3RvX2V4ZSB+Y2hpbGRfc3ViY29tbWFuZClcbiAgICAgICAgICAgICAgfnBhdGhfdG9fc3ViY29tbWFuZDooc3ViIDo6IChzdWJzIEAgY2hpbGRfc3ViY29tbWFuZCkpXG4gICAgICAgICAgfCBHcm91cCBnIC0+XG4gICAgICAgICAgICAobWF0Y2ggTGlzdC5Bc3NvYy5maW5kIChMYXp5LmZvcmNlIGcuc3ViY29tbWFuZHMpIH5lcXVhbDpTdHJpbmcuZXF1YWwgc3ViIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gZmFpbHdpdGhmIFwidW5rbm93biBzdWJjb21tYW5kICVTXCIgc3ViICgpXG4gICAgICAgICAgICAgfCBTb21lIHQgLT4gZmluZCB0IH5wYXRoX3RvX3N1YmNvbW1hbmQ6c3VicykpXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHByb3h5X29mX2V4ZSB+d29ya2luZ19kaXIgcGF0aF90b19leGUgY2hpbGRfc3ViY29tbWFuZCA9XG4gICAgU2V4cGFibGUub2ZfZXh0ZXJuYWwgfndvcmtpbmdfZGlyIH5wYXRoX3RvX2V4ZSB+Y2hpbGRfc3ViY29tbWFuZFxuICAgIHw+IHByb3h5X29mX3NleHBhYmxlXG4gICAgICAgICB+d29ya2luZ19kaXJcbiAgICAgICAgIH5wYXRoX3RvX2V4ZVxuICAgICAgICAgfmNoaWxkX3N1YmNvbW1hbmRcbiAgICAgICAgIH5wYXRoX3RvX3N1YmNvbW1hbmQ6W11cbiAgOztcblxuICBsZXQgcmVjIHNoYXBlX29mX3Byb3h5IHByb3h5IDogU2hhcGUudCA9IHNoYXBlX29mX3Byb3h5X2tpbmQgcHJveHkuUHJveHkua2luZFxuXG4gIGFuZCBzaGFwZV9vZl9leGUgKCkgfmNoaWxkX3N1YmNvbW1hbmQgfnBhdGhfdG9fZXhlIH53b3JraW5nX2RpciA9XG4gICAgc2hhcGVfb2ZfcHJveHkgKHByb3h5X29mX2V4ZSB+d29ya2luZ19kaXIgcGF0aF90b19leGUgY2hpbGRfc3ViY29tbWFuZClcblxuICBhbmQgc2hhcGVfb2ZfcHJveHlfa2luZCBraW5kID1cbiAgICBtYXRjaCBraW5kIHdpdGhcbiAgICB8IEJhc2UgYiAtPiBCYXNpYyBiXG4gICAgfCBMYXp5IGwgLT4gTGF6eSAoTGF6eS5tYXAgfmY6c2hhcGVfb2ZfcHJveHlfa2luZCBsKVxuICAgIHwgR3JvdXAgZyAtPlxuICAgICAgR3JvdXBcbiAgICAgICAgeyBnIHdpdGhcbiAgICAgICAgICBzdWJjb21tYW5kcyA9IExhenkubWFwIGcuc3ViY29tbWFuZHMgfmY6KExpc3QuQXNzb2MubWFwIH5mOnNoYXBlX29mX3Byb3h5KVxuICAgICAgICB9XG4gICAgfCBFeGVjICh7IGNoaWxkX3N1YmNvbW1hbmQ7IHBhdGhfdG9fZXhlOyB3b3JraW5nX2RpcjsgXyB9IGFzIGUpIC0+XG4gICAgICBFeGVjIChlLCBzaGFwZV9vZl9leGUgfmNoaWxkX3N1YmNvbW1hbmQgfnBhdGhfdG9fZXhlIH53b3JraW5nX2RpcilcbiAgOztcblxuICBsZXQgcmVjIHNoYXBlIHQgOiBTaGFwZS50ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEJhc2UgYiAtPiBCYXNpYyAoQ29tbWFuZF9iYXNlLnNoYXBlIGIpXG4gICAgfCBHcm91cCBnIC0+IEdyb3VwIChHcm91cC5zaGFwZSB+c3ViY29tbWFuZF90b19zaGFwZTpzaGFwZSBnKVxuICAgIHwgRXhlYyAoeyBFeGVjLmNoaWxkX3N1YmNvbW1hbmQ7IHBhdGhfdG9fZXhlOyB3b3JraW5nX2RpcjsgXyB9IGFzIGUpIC0+XG4gICAgICBFeGVjIChFeGVjLnNoYXBlIGUsIHNoYXBlX29mX2V4ZSB+Y2hpbGRfc3ViY29tbWFuZCB+cGF0aF90b19leGUgfndvcmtpbmdfZGlyKVxuICAgIHwgTGF6eSB0aHVuayAtPiBzaGFwZSAoTGF6eS5mb3JjZSB0aHVuaylcbiAgOztcblxuICBsZXQgZ2F0aGVyX2hlbHAgfnJlY3Vyc2l2ZSB+ZmxhZ3MgfmV4cGFuZF9kb3RzIHNoYXBlID1cbiAgICBsZXQgcmVjIGxvb3AgcGF0aCBhY2Mgc2hhcGUgPVxuICAgICAgbGV0IHN0cmluZ19vZl9wYXRoID0gaWYgZXhwYW5kX2RvdHMgdGhlbiBQYXRoLnRvX3N0cmluZyBlbHNlIFBhdGgudG9fc3RyaW5nX2RvdHMgaW5cbiAgICAgIGxldCBnYXRoZXJfZ3JvdXAgcGF0aCBhY2Mgc3ViY29tbWFuZHMgPVxuICAgICAgICBsZXQgZmlsdGVyZWRfc3ViY29tbWFuZHMgPVxuICAgICAgICAgICgqIE9ubHkgc2hvdyB0aGUgW2hlbHBdIHN1YmNvbW1hbmQgYXQgdG9wLWxldmVsLiAqKVxuICAgICAgICAgIGlmIFBhdGguaXNfZW1wdHkgcGF0aFxuICAgICAgICAgIHRoZW4gc3ViY29tbWFuZHNcbiAgICAgICAgICBlbHNlIExpc3QuQXNzb2MucmVtb3ZlIH5lcXVhbDpTdHJpbmcuKCA9ICkgc3ViY29tbWFuZHMgXCJoZWxwXCJcbiAgICAgICAgaW5cbiAgICAgICAgZmlsdGVyZWRfc3ViY29tbWFuZHNcbiAgICAgICAgfD4gTGlzdC5zdGFibGVfc29ydCB+Y29tcGFyZTooZnVuIGEgYiAtPiBoZWxwX3NjcmVlbl9jb21wYXJlIChmc3QgYSkgKGZzdCBiKSlcbiAgICAgICAgfD4gTGlzdC5mb2xkIH5pbml0OmFjYyB+ZjooZnVuIGFjYyAoc3ViY29tbWFuZCwgc2hhcGUpIC0+XG4gICAgICAgICAgICAgbGV0IHBhdGggPSBQYXRoLmFwcGVuZCBwYXRoIH5zdWJjb21tYW5kIGluXG4gICAgICAgICAgICAgbGV0IG5hbWUgPSBzdHJpbmdfb2ZfcGF0aCBwYXRoIGluXG4gICAgICAgICAgICAgbGV0IGRvYyA9IFNoYXBlLmdldF9zdW1tYXJ5IHNoYXBlIGluXG4gICAgICAgICAgICAgbGV0IGFjYyA9IHsgU2hhcGUuRmxhZ19pbmZvLm5hbWU7IGRvYzsgYWxpYXNlcyA9IFtdIH0gOjogYWNjIGluXG4gICAgICAgICAgICAgaWYgcmVjdXJzaXZlIHRoZW4gbG9vcCBwYXRoIGFjYyBzaGFwZSBlbHNlIGFjYylcbiAgICAgIGluXG4gICAgICBtYXRjaCBzaGFwZSB3aXRoXG4gICAgICB8IEV4ZWMgKF8sIHNoYXBlKSAtPlxuICAgICAgICAoKiBJZiB0aGUgZXhlY3V0YWJsZSBiZWluZyBjYWxsZWQgZG9lc24ndCB1c2UgW0NvcmUuQ29tbWFuZF0sIHRoZW4gc2V4cCBleHRyYWN0aW9uXG4gICAgICAgICAgIHdpbGwgZmFpbC4gKilcbiAgICAgICAgKHRyeSBsb29wIHBhdGggYWNjIChzaGFwZSAoKSkgd2l0aFxuICAgICAgICAgfCBfIC0+IGFjYylcbiAgICAgIHwgR3JvdXAgZyAtPiBnYXRoZXJfZ3JvdXAgcGF0aCBhY2MgKExhenkuZm9yY2UgZy5zdWJjb21tYW5kcylcbiAgICAgIHwgQmFzaWMgYiAtPlxuICAgICAgICBpZiBmbGFnc1xuICAgICAgICB0aGVuXG4gICAgICAgICAgYi5mbGFnc1xuICAgICAgICAgIHw+IExpc3QuZmlsdGVyIH5mOihmdW4gZm10IC0+IFN0cmluZy4oIDw+ICkgZm10Lm5hbWUgXCJbLWhlbHBdXCIpXG4gICAgICAgICAgfD4gTGlzdC5mb2xkIH5pbml0OmFjYyB+ZjooZnVuIGFjYyBmbXQgLT5cbiAgICAgICAgICAgICAgIGxldCBwYXRoID0gUGF0aC5hcHBlbmQgcGF0aCB+c3ViY29tbWFuZDpmbXQubmFtZSBpblxuICAgICAgICAgICAgICAgbGV0IGZtdCA9IHsgZm10IHdpdGggbmFtZSA9IHN0cmluZ19vZl9wYXRoIHBhdGggfSBpblxuICAgICAgICAgICAgICAgZm10IDo6IGFjYylcbiAgICAgICAgZWxzZSBhY2NcbiAgICAgIHwgTGF6eSB0aHVuayAtPiBsb29wIHBhdGggYWNjIChMYXp5LmZvcmNlIHRodW5rKVxuICAgIGluXG4gICAgbG9vcCBQYXRoLmVtcHR5IFtdIHNoYXBlIHw+IExpc3QucmV2XG4gIDs7XG5cbiAgbGV0IGdyb3VwX29yX2V4ZWNfaGVscF90ZXh0IH5mbGFncyB+cGF0aCB+c3VtbWFyeSB+cmVhZG1lIH5mb3JtYXRfbGlzdCA9XG4gICAgdW5wYXJhZ3JhcGhzXG4gICAgICAoTGlzdC5maWx0ZXJfb3B0XG4gICAgICAgICBbIFNvbWUgc3VtbWFyeVxuICAgICAgICAgOyBTb21lIChTdHJpbmcuY29uY2F0IFsgXCIgIFwiOyBQYXRoLnRvX3N0cmluZyBwYXRoOyBcIiBTVUJDT01NQU5EXCIgXSlcbiAgICAgICAgIDsgcmVhZG1lXG4gICAgICAgICA7IFNvbWUgKGlmIGZsYWdzIHRoZW4gXCI9PT0gc3ViY29tbWFuZHMgYW5kIGZsYWdzID09PVwiIGVsc2UgXCI9PT0gc3ViY29tbWFuZHMgPT09XCIpXG4gICAgICAgICA7IFNvbWUgKFNoYXBlLkZsYWdfaGVscF9kaXNwbGF5LnRvX3N0cmluZyBmb3JtYXRfbGlzdClcbiAgICAgICAgIF0pXG4gIDs7XG5cbiAgbGV0IHJlYyBoZWxwX2Zvcl9zaGFwZSBzaGFwZSBwYXRoIH5leHBhbmRfZG90cyB+ZmxhZ3MgfnJlY3Vyc2l2ZSA9XG4gICAgbGV0IGZvcm1hdF9saXN0ID0gZ2F0aGVyX2hlbHAgfmV4cGFuZF9kb3RzIH5mbGFncyB+cmVjdXJzaXZlIHNoYXBlIGluXG4gICAgbWF0Y2ggc2hhcGUgd2l0aFxuICAgIHwgQmFzaWMgYiAtPlxuICAgICAgbGV0IHVzYWdlID0gU2hhcGUuQmFzZV9pbmZvLmdldF91c2FnZSBiIGluXG4gICAgICB1bnBhcmFncmFwaHNcbiAgICAgICAgKExpc3QuZmlsdGVyX29wdFxuICAgICAgICAgICBbIFNvbWUgYi5zdW1tYXJ5XG4gICAgICAgICAgIDsgU29tZSAoXCIgIFwiIF4gUGF0aC50b19zdHJpbmcgcGF0aCBeIFwiIFwiIF4gdXNhZ2UpXG4gICAgICAgICAgIDsgYi5yZWFkbWVcbiAgICAgICAgICAgOyBTb21lIFwiPT09IGZsYWdzID09PVwiXG4gICAgICAgICAgIDsgU29tZSAoU2hhcGUuRmxhZ19oZWxwX2Rpc3BsYXkudG9fc3RyaW5nIGIuZmxhZ3MpXG4gICAgICAgICAgIF0pXG4gICAgfCBHcm91cCBnIC0+XG4gICAgICBncm91cF9vcl9leGVjX2hlbHBfdGV4dFxuICAgICAgICB+ZmxhZ3NcbiAgICAgICAgfnBhdGhcbiAgICAgICAgfnJlYWRtZTpnLnJlYWRtZVxuICAgICAgICB+c3VtbWFyeTpnLnN1bW1hcnlcbiAgICAgICAgfmZvcm1hdF9saXN0XG4gICAgfCBFeGVjIChlLCBfKSAtPlxuICAgICAgZ3JvdXBfb3JfZXhlY19oZWxwX3RleHRcbiAgICAgICAgfmZsYWdzXG4gICAgICAgIH5wYXRoXG4gICAgICAgIH5yZWFkbWU6ZS5yZWFkbWVcbiAgICAgICAgfnN1bW1hcnk6ZS5zdW1tYXJ5XG4gICAgICAgIH5mb3JtYXRfbGlzdFxuICAgIHwgTGF6eSB0aHVuayAtPiBoZWxwX2Zvcl9zaGFwZSAoTGF6eS5mb3JjZSB0aHVuaykgcGF0aCB+ZXhwYW5kX2RvdHMgfmZsYWdzIH5yZWN1cnNpdmVcbiAgOztcblxuICBsZXQgaGVscF9zdWJjb21tYW5kIH5zdW1tYXJ5IH5yZWFkbWUgPVxuICAgIGJhc2ljXG4gICAgICB+c3VtbWFyeTpcImV4cGxhaW4gYSBnaXZlbiBzdWJjb21tYW5kIChwZXJoYXBzIHJlY3Vyc2l2ZWx5KVwiXG4gICAgICBDb21tYW5kX2Jhc2UuUGFyYW0uKFxuICAgICAgICByZXR1cm4gKGZ1biByZWN1cnNpdmUgZmxhZ3MgZXhwYW5kX2RvdHMgcGF0aCAoZW52IDogRW52LnQpIGNtZF9vcHQgKCkgLT5cbiAgICAgICAgICBsZXQgc3VicyA9XG4gICAgICAgICAgICBtYXRjaCBFbnYuZmluZCBlbnYgc3Vic19rZXkgd2l0aFxuICAgICAgICAgICAgfCBTb21lIHN1YnMgLT4gc3Vic1xuICAgICAgICAgICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgKCogbWFpbnRhaW5lZCBieSBbZGlzcGF0Y2hdICopXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgcGF0aCA9XG4gICAgICAgICAgICBsZXQgcGF0aCA9IFBhdGgucG9wX2hlbHAgcGF0aCBpblxuICAgICAgICAgICAgT3B0aW9uLmZvbGQgY21kX29wdCB+aW5pdDpwYXRoIH5mOihmdW4gcGF0aCBzdWJjb21tYW5kIC0+XG4gICAgICAgICAgICAgIFBhdGguYXBwZW5kIHBhdGggfnN1YmNvbW1hbmQpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgcGF0aCwgc2hhcGUgPVxuICAgICAgICAgICAgbWF0Y2ggY21kX29wdCB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgbGV0IHN1YmNvbW1hbmRzID0gTGlzdC5Bc3NvYy5tYXAgc3VicyB+ZjpzaGFwZSB8PiBMYXp5LmZyb21fdmFsIGluXG4gICAgICAgICAgICAgIGxldCByZWFkbWUgPSBPcHRpb24ubWFwIHJlYWRtZSB+ZjooZnVuIHJlYWRtZSAtPiByZWFkbWUgKCkpIGluXG4gICAgICAgICAgICAgIHBhdGgsIFNoYXBlLkdyb3VwIHsgcmVhZG1lOyBzdW1tYXJ5OyBzdWJjb21tYW5kcyB9XG4gICAgICAgICAgICB8IFNvbWUgY21kIC0+XG4gICAgICAgICAgICAgIChtYXRjaFxuICAgICAgICAgICAgICAgICBsb29rdXBfZXhwYW5kXG4gICAgICAgICAgICAgICAgICAgKExpc3QuQXNzb2MubWFwIHN1YnMgfmY6KGZ1biB4IC0+IHgsIGBQcmVmaXgpKVxuICAgICAgICAgICAgICAgICAgIGNtZFxuICAgICAgICAgICAgICAgICAgIFN1YmNvbW1hbmRcbiAgICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICAgIHwgRXJyb3IgZSAtPlxuICAgICAgICAgICAgICAgICBkaWVcbiAgICAgICAgICAgICAgICAgICBcInVua25vd24gc3ViY29tbWFuZCAlcyBmb3IgY29tbWFuZCAlczogJXNcIlxuICAgICAgICAgICAgICAgICAgIGNtZFxuICAgICAgICAgICAgICAgICAgIChQYXRoLnRvX3N0cmluZyBwYXRoKVxuICAgICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICAgICAgICAoKVxuICAgICAgICAgICAgICAgfCBPayAocG9zc2libHlfZXhwYW5kZWRfbmFtZSwgdCkgLT5cbiAgICAgICAgICAgICAgICAgKCogRml4IHRoZSB1bmV4cGFuZGVkIHZhbHVlICopXG4gICAgICAgICAgICAgICAgIGxldCBwYXRoID1cbiAgICAgICAgICAgICAgICAgICBQYXRoLnJlcGxhY2VfZmlyc3QgfmZyb206Y21kIH50b186cG9zc2libHlfZXhwYW5kZWRfbmFtZSBwYXRoXG4gICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgIHBhdGgsIHNoYXBlIHQpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBwcmludF9lbmRsaW5lIChoZWxwX2Zvcl9zaGFwZSBzaGFwZSBwYXRoIH5yZWN1cnNpdmUgfmZsYWdzIH5leHBhbmRfZG90cykpXG4gICAgICAgIDwqPiBmbGFnIFwiLXJlY3Vyc2l2ZVwiIG5vX2FyZyB+ZG9jOlwiIHNob3cgc3ViY29tbWFuZHMgb2Ygc3ViY29tbWFuZHMsIGV0Yy5cIlxuICAgICAgICA8Kj4gZmxhZyBcIi1mbGFnc1wiIG5vX2FyZyB+ZG9jOlwiIHNob3cgZmxhZ3MgYXMgd2VsbCBpbiByZWN1cnNpdmUgaGVscFwiXG4gICAgICAgIDwqPiBmbGFnIFwiLWV4cGFuZC1kb3RzXCIgbm9fYXJnIH5kb2M6XCIgZXhwYW5kIHN1YmNvbW1hbmRzIGluIHJlY3Vyc2l2ZSBoZWxwXCJcbiAgICAgICAgPCo+IHBhdGhcbiAgICAgICAgPCo+IGVudlxuICAgICAgICA8Kj4gYW5vbiAobWF5YmUgKFwiU1VCQ09NTUFORFwiICU6IHN0cmluZykpKVxuICA7O1xuXG4gIGxldCBkdW1wX2F1dG9jb21wbGV0ZV9mdW5jdGlvbiAoKSA9XG4gICAgYXV0b2NvbXBsZXRlX2Z1bmN0aW9uIH5hcmd2XzA6U3RkbGliLlN5cy5hcmd2LigwKSB+cGlkOihVbml4LmdldHBpZCAoKSB8PiBQaWQudG9faW50KVxuICAgIHw+IHByaW50ZiBcIiVzXCJcbiAgOztcblxuICBsZXQgZHVtcF9oZWxwX3NleHAgfnN1cHBvcnRlZF92ZXJzaW9ucyB0IH5wYXRoX3RvX3N1YmNvbW1hbmQgPVxuICAgIFNldC5pbnRlciBTZXhwYWJsZS5zdXBwb3J0ZWRfdmVyc2lvbnMgc3VwcG9ydGVkX3ZlcnNpb25zXG4gICAgfD4gU2V0Lm1heF9lbHRcbiAgICB8PiBmdW5jdGlvblxuICAgIHwgTm9uZSAtPlxuICAgICAgRXJyb3IuY3JlYXRlXG4gICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgXCJDb3VsZG4ndCBjaG9vc2UgYSBzdXBwb3J0ZWQgaGVscCBvdXRwdXQgdmVyc2lvbiBmb3IgQ29tbWFuZC5leGVjIGZyb20gdGhlIGdpdmVuIFxcXG4gICAgICAgICBzdXBwb3J0ZWQgdmVyc2lvbnMuXCJcbiAgICAgICAgU2V4cGFibGUuc3VwcG9ydGVkX3ZlcnNpb25zXG4gICAgICAgIChTZXQuc2V4cF9vZl9tX190IChtb2R1bGUgSW50KSlcbiAgICAgIHw+IEVycm9yLnJhaXNlXG4gICAgfCBTb21lIHZlcnNpb25fdG9fdXNlIC0+XG4gICAgICBzZXhwYWJsZV9zaGFwZSB0XG4gICAgICB8PiBTZXhwYWJsZS5maW5kIH5wYXRoX3RvX3N1YmNvbW1hbmRcbiAgICAgIHw+IFNleHBhYmxlLnRvX3ZlcnNpb25lZCB+dmVyc2lvbl90b191c2VcbiAgICAgIHw+IFNleHBhYmxlLlZlcnNpb25lZC5zZXhwX29mX3RcbiAgICAgIHw+IFNleHAudG9fc3RyaW5nXG4gICAgICB8PiBwcmludF9zdHJpbmdcbiAgOztcblxuICBsZXQgaGFuZGxlX2Vudmlyb25tZW50IHQgfmFyZ3YgPVxuICAgIG1hdGNoIGFyZ3Ygd2l0aFxuICAgIHwgW10gLT4gZmFpbHdpdGggXCJtaXNzaW5nIGV4ZWN1dGFibGUgbmFtZVwiXG4gICAgfCBjbWQgOjogYXJncyAtPlxuICAgICAgT3B0aW9uLml0ZXIgKGdldGVudl9hbmRfY2xlYXIgQ09NTUFORF9PVVRQVVRfSEVMUF9TRVhQKSB+ZjooZnVuIHZlcnNpb24gLT5cbiAgICAgICAgbGV0IHN1cHBvcnRlZF92ZXJzaW9ucyA9XG4gICAgICAgICAgU2V4cGxpYi5TZXhwLm9mX3N0cmluZyB2ZXJzaW9uIHw+IFNldC5tX190X29mX3NleHAgKG1vZHVsZSBJbnQpXG4gICAgICAgIGluXG4gICAgICAgIGR1bXBfaGVscF9zZXhwIH5zdXBwb3J0ZWRfdmVyc2lvbnMgdCB+cGF0aF90b19zdWJjb21tYW5kOmFyZ3M7XG4gICAgICAgIGV4aXQgMCk7XG4gICAgICBPcHRpb24uaXRlciAoZ2V0ZW52X2FuZF9jbGVhciBDT01NQU5EX09VVFBVVF9JTlNUQUxMQVRJT05fQkFTSCkgfmY6KGZ1biBfIC0+XG4gICAgICAgIGR1bXBfYXV0b2NvbXBsZXRlX2Z1bmN0aW9uICgpO1xuICAgICAgICBleGl0IDApO1xuICAgICAgY21kLCBhcmdzXG4gIDs7XG5cbiAgbGV0IHByb2Nlc3NfYXJncyB+Y21kIH5hcmdzID1cbiAgICBsZXQgbWF5YmVfY29tcF9jd29yZCA9IG1heWJlX2NvbXBfY3dvcmQgKCkgaW5cbiAgICBsZXQgYXJncyA9XG4gICAgICBtYXRjaCBtYXliZV9jb21wX2N3b3JkIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBDbWRsaW5lLm9mX2xpc3QgYXJnc1xuICAgICAgfCBTb21lIGNvbXBfY3dvcmQgLT5cbiAgICAgICAgbGV0IGFyZ3MgPSBMaXN0LnRha2UgKGFyZ3MgQCBbIFwiXCIgXSkgY29tcF9jd29yZCBpblxuICAgICAgICBMaXN0LmZvbGRfcmlnaHQgYXJncyB+aW5pdDpDbWRsaW5lLk5pbCB+ZjooZnVuIGFyZyBhcmdzIC0+XG4gICAgICAgICAgbWF0Y2ggYXJncyB3aXRoXG4gICAgICAgICAgfCBDbWRsaW5lLk5pbCAtPiBDbWRsaW5lLkNvbXBsZXRlIGFyZ1xuICAgICAgICAgIHwgXyAtPiBDbWRsaW5lLkNvbnMgKGFyZywgYXJncykpXG4gICAgaW5cbiAgICBQYXRoLmNyZWF0ZSB+cGF0aF90b19leGU6Y21kLCBhcmdzLCBtYXliZV9jb21wX2N3b3JkXG4gIDs7XG5cbiAgbW9kdWxlIE9ubHlfdmFsaWRhdGVfcGFyc2luZyA9IHN0cnVjdFxuICAgIGxldCBmbGFnIGJhc2UgPVxuICAgICAgbGV0IG5hbWUgPSBcIi12YWxpZGF0ZS1wYXJzaW5nXCIgaW5cbiAgICAgIGxldCBmbGFncyA9IGJhc2UuQ29tbWFuZF9iYXNlLmZsYWdzIGluXG4gICAgICBsZXQgZmxhZ3MgPVxuICAgICAgICBleHRlbmRfbWFwX2V4blxuICAgICAgICAgIGZsYWdzXG4gICAgICAgICAgS2V5X3R5cGUuRmxhZ1xuICAgICAgICAgIH5rZXk6bmFtZVxuICAgICAgICAgIHsgbmFtZVxuICAgICAgICAgIDsgYWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHAgPSBbIFwiLS12YWxpZGF0ZS1wYXJzaW5nXCIgXVxuICAgICAgICAgIDsgYWxpYXNlcyA9IFtdXG4gICAgICAgICAgOyBudW1fb2NjdXJyZW5jZXMgPSBGbGFnLk51bV9vY2N1cnJlbmNlcy5hdF9tb3N0X29uY2VcbiAgICAgICAgICA7IGNoZWNrX2F2YWlsYWJsZSA9IGlnbm9yZVxuICAgICAgICAgIDsgYWN0aW9uID1cbiAgICAgICAgICAgICAgTm9fYXJnIChmdW4gZW52IC0+IEVudi5zZXQgfmtleTprZXlfaW50ZXJuYWxfdmFsaWRhdGVfcGFyc2luZyB+ZGF0YTooKSBlbnYpXG4gICAgICAgICAgOyBkb2MgPSBcIiB2YWxpZGF0ZSBhcmd1bWVudHMgYXJlIHBhcnNlZCBjb3JyZWN0bHkgYW5kIGV4aXQgaW1tZWRpYXRlbHlcIlxuICAgICAgICAgIDsgbmFtZV9tYXRjaGluZyA9IGBQcmVmaXhcbiAgICAgICAgICB9XG4gICAgICBpblxuICAgICAgeyBiYXNlIHdpdGggZmxhZ3MgfVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGFkZCA9IGZ1bmN0aW9uXG4gICAgICB8IEJhc2UgYmFzZSAtPiBCYXNlIChmbGFnIGJhc2UpXG4gICAgICB8IEV4ZWMgXyBhcyB0IC0+IHRcbiAgICAgIHwgR3JvdXAgeyBzdW1tYXJ5OyByZWFkbWU7IHN1YmNvbW1hbmRzOyBib2R5IH0gLT5cbiAgICAgICAgbGV0IHN1YmNvbW1hbmRzID1cbiAgICAgICAgICBMYXp5Lm1hcCBzdWJjb21tYW5kcyB+ZjooZnVuIHN1YmNvbW1hbmRzIC0+XG4gICAgICAgICAgICBMaXN0Lm1hcCBzdWJjb21tYW5kcyB+ZjooZnVuIChuYW1lLCBjb21tYW5kKSAtPiBuYW1lLCBhZGQgY29tbWFuZCkpXG4gICAgICAgIGluXG4gICAgICAgIEdyb3VwIHsgc3VtbWFyeTsgcmVhZG1lOyBzdWJjb21tYW5kczsgYm9keSB9XG4gICAgICB8IExhenkgdGh1bmsgLT4gTGF6eSAobGF6eSAoYWRkIChMYXp5LmZvcmNlIHRodW5rKSkpXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHJlYyBhZGRfaGVscF9zdWJjb21tYW5kcyA9IGZ1bmN0aW9uXG4gICAgfCBCYXNlIF8gYXMgdCAtPiB0XG4gICAgfCBFeGVjIF8gYXMgdCAtPiB0XG4gICAgfCBHcm91cCB7IHN1bW1hcnk7IHJlYWRtZTsgc3ViY29tbWFuZHM7IGJvZHkgfSAtPlxuICAgICAgbGV0IHN1YmNvbW1hbmRzID1cbiAgICAgICAgTGF6eS5tYXAgc3ViY29tbWFuZHMgfmY6KGZ1biBzdWJjb21tYW5kcyAtPlxuICAgICAgICAgIGV4dGVuZF9hbGlzdF9leG5cbiAgICAgICAgICAgIChMaXN0LkFzc29jLm1hcCBzdWJjb21tYW5kcyB+ZjphZGRfaGVscF9zdWJjb21tYW5kcylcbiAgICAgICAgICAgIEtleV90eXBlLlN1YmNvbW1hbmRcbiAgICAgICAgICAgIH5rZXk6XCJoZWxwXCJcbiAgICAgICAgICAgIChoZWxwX3N1YmNvbW1hbmQgfnN1bW1hcnkgfnJlYWRtZSkpXG4gICAgICBpblxuICAgICAgR3JvdXAgeyBzdW1tYXJ5OyByZWFkbWU7IHN1YmNvbW1hbmRzOyBib2R5IH1cbiAgICB8IExhenkgdGh1bmsgLT4gTGF6eSAobGF6eSAoYWRkX2hlbHBfc3ViY29tbWFuZHMgKExhenkuZm9yY2UgdGh1bmspKSlcbiAgOztcblxuICBsZXQgbWF5YmVfYXBwbHlfZXh0ZW5kIGFyZ3MgfmV4dGVuZCB+cGF0aCA9XG4gICAgT3B0aW9uLnZhbHVlX21hcCBleHRlbmQgfmRlZmF1bHQ6YXJncyB+ZjooZnVuIGYgLT5cbiAgICAgIENtZGxpbmUuZXh0ZW5kIGFyZ3MgfmV4dGVuZDpmIH5wYXRoKVxuICA7O1xuXG4gIGxldCByZWMgZGlzcGF0Y2hcbiAgICB0XG4gICAgZW52XG4gICAgfmV4dGVuZFxuICAgIH5wYXRoXG4gICAgfmFyZ3NcbiAgICB+bWF5YmVfbmV3X2NvbXBfY3dvcmRcbiAgICB+dmVyc2lvblxuICAgIH5idWlsZF9pbmZvXG4gICAgfnZlcmJvc2Vfb25fcGFyc2VfZXJyb3JcbiAgICB+d2hlbl9wYXJzaW5nX3N1Y2NlZWRzXG4gICAgfmNvbXBsZXRlX3N1YmNvbW1hbmRzXG4gICAgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgTGF6eSB0aHVuayAtPlxuICAgICAgbGV0IHQgPSBMYXp5LmZvcmNlIHRodW5rIGluXG4gICAgICBkaXNwYXRjaFxuICAgICAgICB0XG4gICAgICAgIGVudlxuICAgICAgICB+ZXh0ZW5kXG4gICAgICAgIH5wYXRoXG4gICAgICAgIH5hcmdzXG4gICAgICAgIH5tYXliZV9uZXdfY29tcF9jd29yZFxuICAgICAgICB+dmVyc2lvblxuICAgICAgICB+YnVpbGRfaW5mb1xuICAgICAgICB+dmVyYm9zZV9vbl9wYXJzZV9lcnJvclxuICAgICAgICB+d2hlbl9wYXJzaW5nX3N1Y2NlZWRzXG4gICAgICAgIH5jb21wbGV0ZV9zdWJjb21tYW5kc1xuICAgIHwgQmFzZSBiYXNlIC0+XG4gICAgICBsZXQgYXJncyA9IG1heWJlX2FwcGx5X2V4dGVuZCBhcmdzIH5leHRlbmQgfnBhdGggaW5cbiAgICAgIGxldCBoZWxwX3RleHQgPVxuICAgICAgICBsYXp5XG4gICAgICAgICAgKGhlbHBfZm9yX3NoYXBlIChzaGFwZSB0KSBwYXRoIH5yZWN1cnNpdmU6ZmFsc2UgfmZsYWdzOnRydWUgfmV4cGFuZF9kb3RzOmZhbHNlKVxuICAgICAgaW5cbiAgICAgIENvbW1hbmRfYmFzZS5ydW5cbiAgICAgICAgYmFzZVxuICAgICAgICBlbnZcbiAgICAgICAgfnBhdGhcbiAgICAgICAgfmFyZ3NcbiAgICAgICAgfnZlcmJvc2Vfb25fcGFyc2VfZXJyb3JcbiAgICAgICAgfmhlbHBfdGV4dFxuICAgICAgICB+d2hlbl9wYXJzaW5nX3N1Y2NlZWRzXG4gICAgICAgIH5vbl9mYWlsdXJlOkNvbW1hbmRfYmFzZS5ydW5fZXhuXG4gICAgfCBFeGVjIGV4ZWMgLT5cbiAgICAgIGxldCBhcmdzID0gQ21kbGluZS50b19saXN0IChtYXliZV9hcHBseV9leHRlbmQgYXJncyB+ZXh0ZW5kIH5wYXRoKSBpblxuICAgICAgRXhlYy5leGVjX3dpdGhfYXJncyB+YXJncyBleGVjIH5tYXliZV9uZXdfY29tcF9jd29yZFxuICAgIHwgR3JvdXAgKHsgc3VtbWFyeTsgcmVhZG1lOyBzdWJjb21tYW5kcyA9IHN1YnM7IGJvZHkgfSBhcyBncm91cCkgLT5cbiAgICAgIGxldCBjb21wbGV0aW5nID0gQ21kbGluZS5lbmRzX2luX2NvbXBsZXRlIGFyZ3MgaW5cbiAgICAgIGxldCBlbnYgPSBFbnYuc2V0IGVudiB+a2V5OnN1YnNfa2V5IH5kYXRhOihMYXp5LmZvcmNlIHN1YnMpIGluXG4gICAgICBsZXQgZGllX3Nob3dpbmdfaGVscCBtc2cgPVxuICAgICAgICBpZiBjb21wbGV0aW5nXG4gICAgICAgIHRoZW4gZXhpdCAwXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGVwcmludGZcbiAgICAgICAgICAgIFwiJXNcXG4lIVwiXG4gICAgICAgICAgICAoaGVscF9mb3Jfc2hhcGVcbiAgICAgICAgICAgICAgIH5yZWN1cnNpdmU6ZmFsc2VcbiAgICAgICAgICAgICAgIH5mbGFnczpmYWxzZVxuICAgICAgICAgICAgICAgfmV4cGFuZF9kb3RzOmZhbHNlXG4gICAgICAgICAgICAgICAoc2hhcGUgKEdyb3VwIHsgc3VtbWFyeTsgcmVhZG1lOyBzdWJjb21tYW5kcyA9IHN1YnM7IGJvZHkgfSkpXG4gICAgICAgICAgICAgICBwYXRoKTtcbiAgICAgICAgICBkaWUgXCIlc1wiIG1zZyAoKSlcbiAgICAgIGluXG4gICAgICBsZXQgcmVjIHBhcnNlX2dyb3VwIGFyZ3Mgfm1heWJlX25ld19jb21wX2N3b3JkID1cbiAgICAgICAgbGV0IG1heWJlX25ld19jb21wX2N3b3JkID0gT3B0aW9uLm1hcCB+ZjpJbnQucHJlZCBtYXliZV9uZXdfY29tcF9jd29yZCBpblxuICAgICAgICBsZXQgc2tpcCByZXN0ID0gcGFyc2VfZ3JvdXAgcmVzdCB+bWF5YmVfbmV3X2NvbXBfY3dvcmQgaW5cbiAgICAgICAgbGV0IHJlc29sdmUgc3ViIHJlc3QgPVxuICAgICAgICAgIGxldCBzdWJzID0gTGlzdC5Bc3NvYy5tYXAgKExhenkuZm9yY2Ugc3VicykgfmY6KGZ1biB4IC0+IHgsIGBQcmVmaXgpIGluXG4gICAgICAgICAgbWF0Y2ggbG9va3VwX2V4cGFuZCBzdWJzIHN1YiBTdWJjb21tYW5kIHdpdGhcbiAgICAgICAgICB8IEVycm9yIG1zZyAtPiBkaWVfc2hvd2luZ19oZWxwIG1zZ1xuICAgICAgICAgIHwgT2sgKHN1YiwgdCkgLT5cbiAgICAgICAgICAgIGRpc3BhdGNoXG4gICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgZW52XG4gICAgICAgICAgICAgIH53aGVuX3BhcnNpbmdfc3VjY2VlZHNcbiAgICAgICAgICAgICAgfmV4dGVuZFxuICAgICAgICAgICAgICB+cGF0aDooUGF0aC5hcHBlbmQgcGF0aCB+c3ViY29tbWFuZDpzdWIpXG4gICAgICAgICAgICAgIH5hcmdzOnJlc3RcbiAgICAgICAgICAgICAgfm1heWJlX25ld19jb21wX2N3b3JkXG4gICAgICAgICAgICAgIH52ZXJzaW9uXG4gICAgICAgICAgICAgIH5idWlsZF9pbmZvXG4gICAgICAgICAgICAgIH52ZXJib3NlX29uX3BhcnNlX2Vycm9yXG4gICAgICAgICAgICAgIH5jb21wbGV0ZV9zdWJjb21tYW5kc1xuICAgICAgICBpblxuICAgICAgICBtYXRjaCAoYXJncyA6IENtZGxpbmUudCkgd2l0aFxuICAgICAgICB8IE5pbCAtPlxuICAgICAgICAgIChtYXRjaCBib2R5IHdpdGhcbiAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgZGllX3Nob3dpbmdfaGVscFxuICAgICAgICAgICAgICAgKHNwcmludGYgXCJtaXNzaW5nIHN1YmNvbW1hbmQgZm9yIGNvbW1hbmQgJXNcIiAoUGF0aC50b19zdHJpbmcgcGF0aCkpXG4gICAgICAgICAgIHwgU29tZSBib2R5IC0+IGJvZHkgfnBhdGg6KFBhdGgucGFydHNfZXhlX2Jhc2VuYW1lIHBhdGgpKVxuICAgICAgICB8IENvbnMgKHN1YiwgcmVzdCkgLT5cbiAgICAgICAgICAoKiBNYXRjaCBmb3IgZmxhZ3MgcmVjb2duaXplZCB3aGVuIHN1YmNvbW1hbmRzIGFyZSBleHBlY3RlZCBuZXh0ICopXG4gICAgICAgICAgKG1hdGNoIHN1YiB3aXRoXG4gICAgICAgICAgICgqIFJlY29nbml6ZWQgYXQgdGhlIHRvcCBsZXZlbCBjb21tYW5kIG9ubHkgKilcbiAgICAgICAgICAgfCAoXCItdmVyc2lvblwiIHwgXCItLXZlcnNpb25cIikgd2hlbiBQYXRoLmxlbmd0aCBwYXRoID0gMSAtPlxuICAgICAgICAgICAgIGlmIGNvbXBsZXRpbmdcbiAgICAgICAgICAgICB0aGVuIHNraXAgcmVzdFxuICAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICAgVmVyc2lvbl9pbmZvLnByaW50X3ZlcnNpb24gfnZlcnNpb247XG4gICAgICAgICAgICAgICBleGl0IDApXG4gICAgICAgICAgIHwgKFwiLWJ1aWxkLWluZm9cIiB8IFwiLS1idWlsZC1pbmZvXCIpIHdoZW4gUGF0aC5sZW5ndGggcGF0aCA9IDEgLT5cbiAgICAgICAgICAgICBpZiBjb21wbGV0aW5nXG4gICAgICAgICAgICAgdGhlbiBza2lwIHJlc3RcbiAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgIFZlcnNpb25faW5mby5wcmludF9idWlsZF9pbmZvIH5idWlsZF9pbmZvO1xuICAgICAgICAgICAgICAgZXhpdCAwKVxuICAgICAgICAgICAoKiBSZWNvZ25pemVkIGV2ZXJ5d2hlcmUgKilcbiAgICAgICAgICAgfCBcIi1oZWxwXCIgfCBcIi0taGVscFwiIC0+XG4gICAgICAgICAgICAgaWYgY29tcGxldGluZ1xuICAgICAgICAgICAgIHRoZW4gc2tpcCByZXN0XG4gICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgICBtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgICAgICAgIHwgTmlsIHwgQ29tcGxldGUgKF8gOiBzdHJpbmcpIC0+XG4gICAgICAgICAgICAgICAgIHByaW50X2VuZGxpbmVcbiAgICAgICAgICAgICAgICAgICAoaGVscF9mb3Jfc2hhcGVcbiAgICAgICAgICAgICAgICAgICAgICB+cmVjdXJzaXZlOmZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgfmZsYWdzOmZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgfmV4cGFuZF9kb3RzOmZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgKHNoYXBlIChHcm91cCB7IGdyb3VwIHdpdGggc3ViY29tbWFuZHMgPSBzdWJzIH0pKVxuICAgICAgICAgICAgICAgICAgICAgIHBhdGgpO1xuICAgICAgICAgICAgICAgICBleGl0IDBcbiAgICAgICAgICAgICAgIHwgQ21kbGluZS5Db25zIChmaXJzdF9vZl9yZXN0LCByZXN0X29mX3Jlc3QpIC0+XG4gICAgICAgICAgICAgICAgIHJlc29sdmUgZmlyc3Rfb2ZfcmVzdCAoQ29ucyAoc3ViLCByZXN0X29mX3Jlc3QpKSlcbiAgICAgICAgICAgfCAoXyA6IHN0cmluZykgLT4gcmVzb2x2ZSBzdWIgcmVzdClcbiAgICAgICAgfCBDb21wbGV0ZSBwYXJ0IC0+XG4gICAgICAgICAgbGV0IHN1YnMgPVxuICAgICAgICAgICAgTGF6eS5mb3JjZSBzdWJzXG4gICAgICAgICAgICB8PiBMaXN0Lm1hcCB+Zjpmc3RcbiAgICAgICAgICAgIHw+IExpc3QuZmlsdGVyIH5mOihmdW4gbmFtZSAtPiBTdHJpbmcuaXNfcHJlZml4IG5hbWUgfnByZWZpeDpwYXJ0KVxuICAgICAgICAgICAgfD4gTGlzdC5zb3J0IH5jb21wYXJlOlN0cmluZy5jb21wYXJlXG4gICAgICAgICAgaW5cbiAgICAgICAgICAobWF0Y2ggY29tcGxldGVfc3ViY29tbWFuZHMgd2l0aFxuICAgICAgICAgICB8IFNvbWUgZiAtPlxuICAgICAgICAgICAgIGxldCBzdWJjb21tYW5kcyA9XG4gICAgICAgICAgICAgICBzaGFwZSB0IHw+IFNoYXBlLmZ1bGx5X2ZvcmNlZCB8PiBTaGFwZS5GdWxseV9mb3JjZWQuZXhwYW5kZWRfc3ViY29tbWFuZHNcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIChtYXRjaCBmIH5wYXRoOihQYXRoLnBhcnRzIHBhdGgpIH5wYXJ0IHN1YmNvbW1hbmRzIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGV4aXQgMVxuICAgICAgICAgICAgICB8IFNvbWUgdG9fb3V0cHV0IC0+XG4gICAgICAgICAgICAgICAgcHJpbnRfZW5kbGluZSAoU3RyaW5nLmNvbmNhdCB+c2VwOlwiIFwiIHRvX291dHB1dCk7XG4gICAgICAgICAgICAgICAgZXhpdCAwKVxuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICBMaXN0Lml0ZXIgc3VicyB+ZjpwcmludF9lbmRsaW5lO1xuICAgICAgICAgICAgIGV4aXQgMClcbiAgICAgIGluXG4gICAgICBwYXJzZV9ncm91cCBhcmdzIH5tYXliZV9uZXdfY29tcF9jd29yZFxuICA7O1xuXG4gIGxldCBydW5cbiAgICA/KGFkZF92YWxpZGF0ZV9wYXJzaW5nX2ZsYWcgPSBmYWxzZSlcbiAgICA/dmVyYm9zZV9vbl9wYXJzZV9lcnJvclxuICAgID92ZXJzaW9uXG4gICAgP2J1aWxkX2luZm9cbiAgICA/KGFyZ3YgPSBBcnJheS50b19saXN0IFN0ZGxpYi5TeXMuYXJndilcbiAgICA/ZXh0ZW5kXG4gICAgPyh3aGVuX3BhcnNpbmdfc3VjY2VlZHMgPSBGbi5pZClcbiAgICA/Y29tcGxldGVfc3ViY29tbWFuZHNcbiAgICB0XG4gICAgPVxuICAgIGxldCBidWlsZF9pbmZvID1cbiAgICAgIG1hdGNoIGJ1aWxkX2luZm8gd2l0aFxuICAgICAgfCBTb21lIHYgLT4gbGF6eSB2XG4gICAgICB8IE5vbmUgLT4gVmVyc2lvbl9pbmZvLmRlZmF1bHRfYnVpbGRfaW5mb1xuICAgIGluXG4gICAgbGV0IHZlcnNpb24gPVxuICAgICAgbWF0Y2ggdmVyc2lvbiB3aXRoXG4gICAgICB8IE5vbmUgLT4gVmVyc2lvbl9pbmZvLmRlZmF1bHRfdmVyc2lvblxuICAgICAgfCBTb21lIHYgLT5cbiAgICAgICAgKCogW3ZlcnNpb25dIHdhcyBzcGFjZSBkZWxpbWl0ZWQgYXQgc29tZSBwb2ludCBhbmQgbmV3bGluZSBkZWxpbWl0ZWRcbiAgICAgICAgICAgYXQgYW5vdGhlci4gIFdlIGFsd2F5cyBwcmludCBvbmUgKHJlcG8sIHJldmlzaW9uKSBwYWlyIHBlciBsaW5lXG4gICAgICAgICAgIGFuZCBlbnN1cmUgc29ydGVkIG9yZGVyICopXG4gICAgICAgIGxhenlcbiAgICAgICAgICAoVmVyc2lvbl9pbmZvLm5vcm1hbGl6ZV92ZXJzaW9uX2xpbmVzXG4gICAgICAgICAgICAgKFN0cmluZy5zcGxpdCB2IH5vbjonICcgfD4gTGlzdC5jb25jYXRfbWFwIH5mOihTdHJpbmcuc3BsaXQgfm9uOidcXG4nKSkpXG4gICAgaW5cbiAgICBFeG4uaGFuZGxlX3VuY2F1Z2h0X2FuZF9leGl0IChmdW4gKCkgLT5cbiAgICAgIGxldCB0ID0gVmVyc2lvbl9pbmZvLmFkZCB0IH52ZXJzaW9uIH5idWlsZF9pbmZvIGluXG4gICAgICBsZXQgdCA9IGFkZF9oZWxwX3N1YmNvbW1hbmRzIHQgaW5cbiAgICAgIGxldCB0ID0gaWYgYWRkX3ZhbGlkYXRlX3BhcnNpbmdfZmxhZyB0aGVuIE9ubHlfdmFsaWRhdGVfcGFyc2luZy5hZGQgdCBlbHNlIHQgaW5cbiAgICAgIGxldCBjbWQsIGFyZ3MgPSBoYW5kbGVfZW52aXJvbm1lbnQgdCB+YXJndiBpblxuICAgICAgbGV0IHBhdGgsIGFyZ3MsIG1heWJlX25ld19jb21wX2N3b3JkID0gcHJvY2Vzc19hcmdzIH5jbWQgfmFyZ3MgaW5cbiAgICAgIHRyeVxuICAgICAgICBkaXNwYXRjaFxuICAgICAgICAgIHRcbiAgICAgICAgICBFbnYuZW1wdHlcbiAgICAgICAgICB+ZXh0ZW5kXG4gICAgICAgICAgfnBhdGhcbiAgICAgICAgICB+YXJnc1xuICAgICAgICAgIH5tYXliZV9uZXdfY29tcF9jd29yZFxuICAgICAgICAgIH52ZXJzaW9uXG4gICAgICAgICAgfmJ1aWxkX2luZm9cbiAgICAgICAgICB+dmVyYm9zZV9vbl9wYXJzZV9lcnJvclxuICAgICAgICAgIH53aGVuX3BhcnNpbmdfc3VjY2VlZHNcbiAgICAgICAgICB+Y29tcGxldGVfc3ViY29tbWFuZHNcbiAgICAgIHdpdGhcbiAgICAgIHwgRmFpbGVkX3RvX3BhcnNlX2NvbW1hbmRfbGluZSBtc2cgLT5cbiAgICAgICAgaWYgQ21kbGluZS5lbmRzX2luX2NvbXBsZXRlIGFyZ3NcbiAgICAgICAgdGhlbiBleGl0IDBcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgcHJlcnJfZW5kbGluZSBtc2c7XG4gICAgICAgICAgZXhpdCAxKSlcbiAgOztcblxuICBsZXQgZGVwcmVjYXRlZF9ydW4gdCB+Y21kIH5hcmdzIH5pc19oZWxwIH5pc19oZWxwX3JlYyB+aXNfaGVscF9yZWNfZmxhZ3MgfmlzX2V4cGFuZF9kb3RzXG4gICAgPVxuICAgIGxldCBwYXRoX3N0cmluZ3MgPSBTdHJpbmcuc3BsaXQgY21kIH5vbjonICcgaW5cbiAgICBsZXQgcGF0aCA9IFBhdGgub2ZfcGFydHMgcGF0aF9zdHJpbmdzIGluXG4gICAgbGV0IGFyZ3MgPSBpZiBpc19leHBhbmRfZG90cyB0aGVuIFwiLWV4cGFuZC1kb3RzXCIgOjogYXJncyBlbHNlIGFyZ3MgaW5cbiAgICBsZXQgYXJncyA9IGlmIGlzX2hlbHBfcmVjX2ZsYWdzIHRoZW4gXCItZmxhZ3NcIiA6OiBhcmdzIGVsc2UgYXJncyBpblxuICAgIGxldCBhcmdzID0gaWYgaXNfaGVscF9yZWMgdGhlbiBcIi1yXCIgOjogYXJncyBlbHNlIGFyZ3MgaW5cbiAgICBsZXQgYXJncyA9IGlmIGlzX2hlbHAgdGhlbiBcIi1oZWxwXCIgOjogYXJncyBlbHNlIGFyZ3MgaW5cbiAgICBsZXQgYXJncyA9IENtZGxpbmUub2ZfbGlzdCBhcmdzIGluXG4gICAgbGV0IHQgPSBhZGRfaGVscF9zdWJjb21tYW5kcyB0IGluXG4gICAgZGlzcGF0Y2hcbiAgICAgIHRcbiAgICAgIEVudi5lbXB0eVxuICAgICAgfnBhdGhcbiAgICAgIH5hcmdzXG4gICAgICB+ZXh0ZW5kOk5vbmVcbiAgICAgIH5tYXliZV9uZXdfY29tcF9jd29yZDpOb25lXG4gICAgICB+dmVyc2lvbjpWZXJzaW9uX2luZm8uZGVmYXVsdF92ZXJzaW9uXG4gICAgICB+YnVpbGRfaW5mbzpWZXJzaW9uX2luZm8uZGVmYXVsdF9idWlsZF9pbmZvXG4gICAgICB+dmVyYm9zZV9vbl9wYXJzZV9lcnJvcjpOb25lXG4gICAgICB+d2hlbl9wYXJzaW5nX3N1Y2NlZWRzOkZuLmlkXG4gICAgICB+Y29tcGxldGVfc3ViY29tbWFuZHM6Tm9uZVxuICA7O1xuZW5kXG5cbm1vZHVsZSBQYXJhbSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSArJ2EgdFxuXG4gICAgaW5jbHVkZSBBcHBsaWNhdGl2ZS5TIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgIHZhbCBoZWxwIDogc3RyaW5nIExhenkudCB0XG4gICAgdmFsIHBhdGggOiBzdHJpbmcgbGlzdCB0XG4gICAgdmFsIGFyZ3MgOiBzdHJpbmcgbGlzdCB0XG5cbiAgICB2YWwgZmxhZ1xuICAgICAgOiAgP2FsaWFzZXM6c3RyaW5nIGxpc3RcbiAgICAgIC0+ID9mdWxsX2ZsYWdfcmVxdWlyZWQ6dW5pdFxuICAgICAgLT4gc3RyaW5nXG4gICAgICAtPiAnYSBGbGFnLnRcbiAgICAgIC0+IGRvYzpzdHJpbmdcbiAgICAgIC0+ICdhIHRcblxuICAgIHZhbCBmbGFnX29wdGlvbmFsX3dpdGhfZGVmYXVsdF9kb2NcbiAgICAgIDogID9hbGlhc2VzOnN0cmluZyBsaXN0XG4gICAgICAtPiA/ZnVsbF9mbGFnX3JlcXVpcmVkOnVuaXRcbiAgICAgIC0+IHN0cmluZ1xuICAgICAgLT4gJ2EgQXJnX3R5cGUudFxuICAgICAgLT4gKCdhIC0+IFNleHAudClcbiAgICAgIC0+IGRlZmF1bHQ6J2FcbiAgICAgIC0+IGRvYzpzdHJpbmdcbiAgICAgIC0+ICdhIHRcblxuICAgIHZhbCBhbm9uIDogJ2EgQW5vbnMudCAtPiAnYSB0XG4gICAgdmFsIGVzY2FwZV9hbm9uIDogZmluYWxfYW5vbjonYSBBbm9ucy50IC0+ICgnYSAqIHN0cmluZyBsaXN0KSB0XG5cbiAgICBtb2R1bGUgSWZfbm90aGluZ19jaG9zZW4gOiBzaWdcbiAgICAgIHR5cGUgKF8sIF8pIHQgPVxuICAgICAgICB8IERlZmF1bHRfdG8gOiAnYSAtPiAoJ2EsICdhKSB0XG4gICAgICAgIHwgUmFpc2UgOiAoJ2EsICdhKSB0XG4gICAgICAgIHwgUmV0dXJuX25vbmUgOiAoJ2EsICdhIG9wdGlvbikgdFxuICAgIGVuZFxuXG4gICAgdmFsIGNob29zZV9vbmVcbiAgICAgIDogICdhIG9wdGlvbiB0IGxpc3RcbiAgICAgIC0+IGlmX25vdGhpbmdfY2hvc2VuOignYSwgJ2IpIElmX25vdGhpbmdfY2hvc2VuLnRcbiAgICAgIC0+ICdiIHRcblxuICAgIHZhbCBjaG9vc2Vfb25lX25vbl9vcHRpb25hbFxuICAgICAgOiAgJ2EgdCBsaXN0XG4gICAgICAtPiBpZl9ub3RoaW5nX2Nob3NlbjooJ2EsICdiKSBJZl9ub3RoaW5nX2Nob3Nlbi50XG4gICAgICAtPiAnYiB0XG5cbiAgICB2YWwgYW5kX2FyZ19uYW1lcyA6ICdhIHQgLT4gKCdhICogc3RyaW5nIGxpc3QpIHRcbiAgICB2YWwgYW5kX2FyZ19uYW1lIDogJ2EgdCAtPiAoJ2EgKiBzdHJpbmcpIHRcbiAgICB2YWwgYXJnX25hbWVzIDogJ2EgdCAtPiBzdHJpbmcgbGlzdFxuICBlbmRcblxuICBpbmNsdWRlIENvbW1hbmRfYmFzZS5QYXJhbVxuXG4gIGxldCBwYXRoID0gbWFwIH5mOlBhdGgucGFydHNfZXhlX2Jhc2VuYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBpbmNsdWRlIFBhcmFtXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFBhcmFtXG4gICAgbW9kdWxlIE9wZW5fb25fcmhzID0gUGFyYW1cbiAgZW5kXG5lbmRcblxudHlwZSAncmVzdWx0IGJhc2ljX2NvbW1hbmQgPVxuICBzdW1tYXJ5OnN0cmluZyAtPiA/cmVhZG1lOih1bml0IC0+IHN0cmluZykgLT4gKHVuaXQgLT4gJ3Jlc3VsdCkgUGFyYW0udCAtPiB0XG5cbmxldCBiYXNpYyB+c3VtbWFyeSA/cmVhZG1lIHBhcmFtID1cbiAgbGV0IHJlYWRtZSA9IE9wdGlvbi5tYXAgcmVhZG1lIH5mOihmdW4gZiAoKSAtPiBTdHJpbmcuc3RyaXAgKGYgKCkpKSBpblxuICBiYXNpYyB+c3VtbWFyeSA/cmVhZG1lIHBhcmFtXG47O1xuXG5sZXQgYmFzaWNfb3JfZXJyb3IgfnN1bW1hcnkgP3JlYWRtZSBwYXJhbSA9XG4gIGJhc2ljXG4gICAgfnN1bW1hcnlcbiAgICA/cmVhZG1lXG4gICAgKGxldCVtYXAgcnVuID0gcGFyYW0gaW5cbiAgICAgZnVuICgpIC0+XG4gICAgICAgbWF0Y2ggcnVuICgpIHdpdGhcbiAgICAgICB8IE9rICgpIC0+ICgpXG4gICAgICAgfCBFcnJvciBlIC0+XG4gICAgICAgICBTdGRpby5wcmVycl9lbmRsaW5lIChFcnJvci50b19zdHJpbmdfaHVtIGUpO1xuICAgICAgICAgZXhpdCAxKVxuOztcblxubW9kdWxlIEZvcl90ZWxlbWV0cnkgPSBzdHJ1Y3RcbiAgbGV0IG5vcm1hbGl6ZWRfcGF0aCAoKSA9IE9wdGlvbi5tYXAgIUNvbW1hbmRfYmFzZS5ub3JtYWxpemVkX3BhdGggfmY6UGF0aC5wYXJ0c1xuICBsZXQgbm9ybWFsaXplZF9hcmdzICgpID0gIUNvbW1hbmRfYmFzZS5ub3JtYWxpemVkX2FyZ3NcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgYWJzX3BhdGggPSBhYnNfcGF0aFxuICBsZXQgd29yZF93cmFwID0gU2hhcGUuUHJpdmF0ZS53b3JkX3dyYXBcblxuICBtb2R1bGUgQW5vbnMgPSBBbm9uc1xuICBtb2R1bGUgQ21kbGluZSA9IENtZGxpbmVcbiAgbW9kdWxlIEZvcl91bml4ID0gRm9yX3VuaXhcbiAgbW9kdWxlIFBhdGggPSBQYXRoXG5cbiAgbW9kdWxlIFNwZWMgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFNwZWNcblxuICAgIGxldCB0b19zdHJpbmdfZm9yX2Nob29zZV9vbmUgcGFyYW0gPVxuICAgICAgQ29tbWFuZF9iYXNlLlBhcmFtLkNob29zZV9vbmUuQ2hvaWNlX25hbWUuKGNyZWF0ZV9leG4gcGFyYW0gfD4gdG9fc3RyaW5nKVxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbmxldCBydW4gPSBgVXNlX0NvbW1hbmRfdW5peFxubGV0IHNoYXBlID0gYFVzZV9Db21tYW5kX3VuaXhcbiJdfQ==
