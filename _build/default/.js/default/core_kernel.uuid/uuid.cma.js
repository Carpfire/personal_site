// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Uuid
//# unitInfo: Requires: Base__Bytes, Base__Random, Base__Sexpable, Bin_prot__Shape, Bin_shape, Core, Core__Bytes, Core__Char, Core__Command_internal, Core__Comparable, Core__Comparator, Core__Identifiable, Core__Int, Core__Md5, Core__Quickcheck, Core__Stable, Core__String, Core__Time_ns, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stable_witness
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Uuid$0 = "Uuid",
    cst_t$3 = "t",
    cst_uuid$0 = "uuid",
    cst_uuid_src_uuid_ml = "uuid/src/uuid.ml",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    for_testing = "5a863fc1-67b7-3a0a-dc90-aca2995afbf9",
    module_name = cst_Uuid$0,
    nil = "00000000-0000-0000-0000-000000000000",
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Time_ns = global_data.Core__Time_ns,
    Core_Int = global_data.Core__Int,
    Core_String = global_data.Core__String,
    Core_Md5 = global_data.Core__Md5,
    Core_Bytes = global_data.Core__Bytes,
    Base_Bytes = global_data.Base__Bytes,
    Base_Random = global_data.Base__Random,
    Core_Char = global_data.Core__Char,
    Assert_failure = global_data.Assert_failure,
    Core_Stable = global_data.Core__Stable,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Stable_witness = global_data.Stable_witness,
    Core_Comparator = global_data.Core__Comparator,
    Core_Comparable = global_data.Core__Comparable,
    Base_Sexpable = global_data.Base__Sexpable,
    Core_Identifiable = global_data.Core__Identifiable,
    Core_Command_internal = global_data.Core__Command_internal,
    Core_Quickcheck = global_data.Core__Quickcheck;
   caml_call1(Ppx_module_timer_runtime[4], cst_Uuid$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_uuid$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_uuid_src_uuid_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_uuid$0, "uuid.ml");
   var
    _a_ = Core_Stable[99],
    _b_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$3), 0, _a_], 0],
    _c_ = caml_call1(Bin_shape[4][1], "uuid/src/uuid.ml:21:6"),
    group = caml_call2(Bin_prot_Shape[2], _c_, _b_),
    _d_ = caml_call1(Bin_shape[2][1], cst_t$3),
    bin_shape_t = caml_call1(caml_call2(Bin_prot_Shape[10], group, _d_), 0),
    bin_size_t = Core_Stable[3],
    bin_write_t = Core_Stable[101],
    bin_writer_t = [0, bin_size_t, bin_write_t],
    bin_read_t = Core_Stable[105],
    bin_read_t$0 = Core_Stable[104],
    bin_reader_t = [0, bin_read_t$0, bin_read_t],
    bin_t = [0, bin_shape_t, bin_writer_t, bin_reader_t],
    compare = Core_Stable[442],
    equal = Core_Stable[456],
    hash_fold_t = Core_Stable[287],
    func = Core_Stable[301],
    _v_ =
      [0,
       [2,
        0,
        [12,
         45,
         [2, 0, [12, 45, [2, 0, [12, 45, [2, 0, [12, 45, [2, 0, 0]]]]]]]]],
       "%s-%s-%s-%s-%s"],
    cst_uuid_omitted_in_test = "<uuid-omitted-in-test>",
    _p_ = [0, "-"],
    _k_ = [0, [2, 0, [11, ": not a valid UUID", 0]], "%s: not a valid UUID"],
    _j_ = [0, cst_uuid_src_uuid_ml, 47, 6],
    _i_ = [0, cst_uuid_src_uuid_ml, 48, 6],
    _h_ = [0, cst_uuid_src_uuid_ml, 49, 6],
    _g_ = [0, cst_uuid_src_uuid_ml, 50, 6],
    _f_ = [0, cst_uuid_src_uuid_ml, 51, 6],
    _e_ = [0, cst_uuid_src_uuid_ml, 52, 6],
    cst_t = cst_t$3,
    cst_uuid_src_uuid_ml_68_2 = "uuid/src/uuid.ml:68:2",
    cst_t$0 = cst_t$3,
    cst_t$1 = cst_t$3,
    cst_uuid_src_uuid_ml_162_2 = "uuid/src/uuid.ml:162:2",
    cst_t$2 = cst_t$3,
    cst_uuid = cst_uuid$0,
    cst_Uuid = cst_Uuid$0;
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Core_Stable[355],
    sexp_of_t = Core_Stable[354],
    t_sexp_grammar = Core_Stable[356],
    stable_witness = Stable_witness[6],
    include = caml_call2(Core_Comparator[13][1][1], compare, sexp_of_t),
    comparator = include[1],
    include$0 =
      caml_call1
       (Core_Comparable[26][1][2][1],
        [0,
         stable_witness,
         bin_size_t,
         bin_write_t,
         bin_read_t$0,
         bin_read_t,
         bin_shape_t,
         bin_writer_t,
         bin_reader_t,
         bin_t,
         compare,
         t_of_sexp,
         sexp_of_t,
         comparator]),
    Map = include$0[1],
    Set = include$0[2];
   function to_string(t){return t;}
   function char_is_dash(c){return caml_call2(Core_Char[54], 45, c);}
   function is_valid_exn(s){
    if(! caml_call2(Core[90], runtime.caml_ml_string_length(s), 36))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    var _L_ = caml_call2(Core_String[21], s, char_is_dash);
    if(! caml_call2(Core[90], _L_, 4))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
    if(! char_is_dash(caml_string_get(s, 8)))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    if(! char_is_dash(caml_string_get(s, 13)))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    if(! char_is_dash(caml_string_get(s, 18)))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    if(char_is_dash(caml_string_get(s, 23))) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function of_string(s){
    try{is_valid_exn(s); return s;}
    catch(_K_){return caml_call3(Core[246], _k_, s, 0);}
   }
   var
    _l_ = Core[541],
    _m_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), 0, _l_], 0],
    _n_ = caml_call1(Bin_shape[4][1], cst_uuid_src_uuid_ml_68_2),
    group$0 = caml_call2(Bin_prot_Shape[2], _n_, _m_),
    _o_ = caml_call1(Bin_shape[2][1], cst_t$0),
    bin_shape_t$0 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$0, _o_), 0),
    bin_size_t$0 = Core[542],
    bin_write_t$0 = Core[544],
    bin_writer_t$0 = [0, bin_size_t$0, bin_write_t$0],
    bin_read_t$1 = Core[548],
    bin_read_t$2 = Core[547],
    bin_reader_t$0 = [0, bin_read_t$2, bin_read_t$1],
    bin_t$0 = [0, bin_shape_t$0, bin_writer_t$0, bin_reader_t$0],
    compare$0 = Core[551],
    hash_fold_t$0 = Core[556],
    func$0 = Core[557];
   function hash$0(x){return caml_call1(func$0, x);}
   var counter = [0, 0];
   function set_all_dashes(bytes){
    caml_bytes_set(bytes, 8, 45);
    caml_bytes_set(bytes, 13, 45);
    caml_bytes_set(bytes, 18, 45);
    caml_bytes_set(bytes, 23, 45);
    return;
   }
   function bottom_4_bits_to_hex_char(v){
    var v$0 = v & 15;
    return caml_call2(Core[92], v$0, 10)
            ? caml_call1(Core_Char[14], 48 + v$0 | 0)
            : caml_call1(Core_Char[14], 87 + v$0 | 0);
   }
   var bytes = caml_call1(Core_Bytes[44], 36);
   function create_random(random_state){
    var at = [0, 0], for$0 = 1;
    for(;;){
     var int$0 = [0, caml_call1(Base_Random[19][5], random_state)], for$1 = 1;
     for(;;){
      var _I_ = bottom_4_bits_to_hex_char(int$0[1]);
      caml_bytes_set(bytes, at[1], _I_);
      at[1]++;
      int$0[1] = int$0[1] >>> 4 | 0;
      var _J_ = for$1 + 1 | 0;
      if(6 === for$1) break;
      var for$1 = _J_;
     }
     var _H_ = for$0 + 1 | 0;
     if(6 === for$0){
      set_all_dashes(bytes);
      caml_bytes_set(bytes, 14, 52);
      return caml_call1(Core_Bytes[41], bytes);
     }
     var for$0 = _H_;
    }
   }
   function create(hostname, pid){
    var time = caml_call1(Core_Time_ns[66], 0);
    counter[1]++;
    var
     counter$0 = counter[1],
     _C_ = [0, caml_call1(Core_Int[79], counter$0), 0],
     _D_ = caml_call1(Core_Time_ns[79], time),
     _E_ = [0, caml_call1(Core_Int[79], _D_), _C_],
     _F_ = [0, hostname, [0, caml_call1(Core_Int[79], pid), _E_]],
     base = caml_call2(Core_String[46], _p_, _F_),
     _G_ = caml_call1(Core_Md5[47], base),
     digest = caml_call1(Core_Md5[45], _G_),
     s = caml_call1(Core_Bytes[44], 36);
    set_all_dashes(s);
    caml_call5(Base_Bytes[33][1], digest, 0, s, 0, 8);
    caml_call5(Base_Bytes[33][1], digest, 8, s, 9, 4);
    caml_call5(Base_Bytes[33][1], digest, 12, s, 14, 4);
    caml_call5(Base_Bytes[33][1], digest, 16, s, 19, 4);
    caml_call5(Base_Bytes[33][1], digest, 20, s, 24, 12);
    caml_bytes_set(s, 14, 51);
    return caml_call1(Core_Bytes[41], s);
   }
   var
    include$1 = caml_call1(Base_Sexpable[5], [0, of_string, to_string]),
    t_of_sexp$0 = include$1[2],
    sexp_of_t$0 = include$1[3],
    include$2 =
      caml_call1
       (Core_Identifiable[5],
        [0,
         bin_size_t$0,
         bin_write_t$0,
         bin_read_t$2,
         bin_read_t$1,
         bin_shape_t$0,
         bin_writer_t$0,
         bin_reader_t$0,
         bin_t$0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         comparator,
         of_string,
         to_string,
         module_name]),
    bin_size_t$1 = include$2[1],
    bin_write_t$1 = include$2[2],
    bin_read_t$3 = include$2[3],
    bin_read_t$4 = include$2[4],
    bin_shape_t$1 = include$2[5],
    bin_writer_t$1 = include$2[6],
    bin_reader_t$1 = include$2[7],
    bin_t$1 = include$2[8],
    t_of_sexp$1 = include$2[9],
    sexp_of_t$1 = include$2[10],
    of_string$0 = include$2[11],
    to_string$0 = include$2[12],
    pp = include$2[13],
    symbol = include$2[14],
    symbol$0 = include$2[15],
    symbol$1 = include$2[16],
    symbol$2 = include$2[17],
    symbol$3 = include$2[18],
    symbol$4 = include$2[19],
    equal$0 = include$2[20],
    compare$1 = include$2[21],
    min = include$2[22],
    max = include$2[23],
    ascending = include$2[24],
    descending = include$2[25],
    between = include$2[26],
    clamp_exn = include$2[27],
    clamp = include$2[28],
    validate_lbound = include$2[29],
    validate_ubound = include$2[30],
    validate_bound = include$2[31],
    Replace_polymorphic_compare = include$2[32],
    comparator$0 = include$2[33],
    Map$0 = include$2[34],
    Set$0 = include$2[35],
    hash_fold_t$1 = include$2[36],
    hash$1 = include$2[37],
    hashable = include$2[38],
    Table = include$2[39],
    Hash_set = include$2[40],
    Hash_queue = include$2[41];
   function invariant(t){caml_call1(of_string$0, t); return 0;}
   var
    _q_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$1), 0, bin_shape_t$1], 0],
    _r_ = caml_call1(Bin_shape[4][1], cst_uuid_src_uuid_ml_162_2),
    group$1 = caml_call2(Bin_prot_Shape[2], _r_, _q_),
    _s_ = caml_call1(Bin_shape[2][1], cst_t$2),
    bin_shape_t$2 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$1, _s_), 0),
    bin_writer_t$2 = [0, bin_size_t$1, bin_write_t$1],
    bin_reader_t$2 = [0, bin_read_t$3, bin_read_t$4],
    bin_t$2 = [0, bin_shape_t$2, bin_writer_t$2, bin_reader_t$2];
   function hash$2(x){return caml_call1(hash$1, x);}
   var
    t_sexp_grammar$0 = Core[560],
    arg_type = caml_call3(Core_Command_internal[19][1], 0, 0, of_string$0);
   function sexp_of_t$2(t){
    return Core[628]
            ? caml_call1(Sexplib0_Sexp_conv[7], cst_uuid_omitted_in_test)
            : caml_call1(sexp_of_t$1, t);
   }
   var
    quickcheck_shrinker = caml_call1(Core_Quickcheck[3][3], 0),
    quickcheck_observer =
      caml_call1(Core_Quickcheck[2][3], [0, hash_fold_t$0, hash$0]),
    _t_ = [0, [0, 6., caml_call2(Core_Char[86], 97, 102)], 0],
    gen_hex_digit =
      caml_call1(Core_Quickcheck[1][64], [0, [0, 10., Core_Char[79]], _t_]),
    let_syntax_013 = caml_call2(Core_String[174], 8, gen_hex_digit),
    let_syntax_014 = caml_call2(Core_String[174], 4, gen_hex_digit),
    let_syntax_015 = caml_call2(Core_String[174], 4, gen_hex_digit),
    let_syntax_016 = caml_call2(Core_String[174], 4, gen_hex_digit),
    let_syntax_017 = caml_call2(Core_String[174], 12, gen_hex_digit);
   function _u_(param){
    var
     _A_ = param[2],
     _B_ = _A_[2],
     match = _B_[2],
     fifth = match[2],
     fourth = match[1],
     third = _B_[1],
     second = _A_[1],
     first = param[1];
    return caml_call1
            (of_string$0,
             caml_call6(Core[265], _v_, first, second, third, fourth, fifth));
   }
   var
    _w_ =
      caml_call2(Core_Quickcheck[1][8][4][4], let_syntax_016, let_syntax_017),
    _x_ = caml_call2(Core_Quickcheck[1][8][4][4], let_syntax_015, _w_),
    _y_ = caml_call2(Core_Quickcheck[1][8][4][4], let_syntax_014, _x_),
    _z_ = caml_call2(Core_Quickcheck[1][8][4][4], let_syntax_013, _y_),
    quickcheck_generator = caml_call2(Core_Quickcheck[1][8][4][3], _z_, _u_);
   caml_call1(Ppx_inline_test_lib[7], cst_uuid);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Uuid);
   var
    Uuid =
      [0,
       bin_size_t$1,
       bin_write_t$1,
       bin_read_t$3,
       bin_read_t$4,
       bin_shape_t$1,
       bin_writer_t$1,
       bin_reader_t$1,
       bin_t$1,
       sexp_of_t$2,
       of_string$0,
       to_string$0,
       pp,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal$0,
       compare$1,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       validate_lbound,
       validate_ubound,
       validate_bound,
       Replace_polymorphic_compare,
       comparator$0,
       Map$0,
       Set$0,
       hash_fold_t$1,
       hash$1,
       hashable,
       Table,
       Hash_set,
       Hash_queue,
       invariant,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       t_of_sexp$1,
       create_random,
       arg_type,
       [0,
        bin_size_t$1,
        bin_write_t$1,
        bin_read_t$3,
        bin_read_t$4,
        bin_shape_t$2,
        bin_writer_t$2,
        bin_reader_t$2,
        bin_t$2,
        compare$1,
        equal$0,
        hash_fold_t$1,
        hash$2,
        t_of_sexp$1,
        sexp_of_t$1,
        t_sexp_grammar$0,
        comparator$0],
       [0,
        [0,
         equal,
         hash_fold_t,
         hash,
         t_sexp_grammar,
         stable_witness,
         bin_size_t,
         bin_write_t,
         bin_read_t$0,
         bin_read_t,
         bin_shape_t,
         bin_writer_t,
         bin_reader_t,
         bin_t,
         compare,
         t_of_sexp,
         sexp_of_t,
         comparator,
         Map,
         Set,
         of_string,
         to_string,
         for_testing]],
       [0, is_valid_exn, nil, create, bottom_4_bits_to_hex_char]];
   runtime.caml_register_global(56, Uuid, cst_Uuid$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1dWlkLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJmb3JfdGVzdGluZyIsIm1vZHVsZV9uYW1lIiwibmlsIiwiZ3JvdXAiLCJiaW5fc2hhcGVfdCIsImJpbl9zaXplX3QiLCJiaW5fd3JpdGVfdCIsImJpbl93cml0ZXJfdCIsImJpbl9yZWFkX3QiLCJiaW5fcmVhZF90JDAiLCJiaW5fcmVhZGVyX3QiLCJiaW5fdCIsImNvbXBhcmUiLCJlcXVhbCIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJ4IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJzdGFibGVfd2l0bmVzcyIsImNvbXBhcmF0b3IiLCJ0b19zdHJpbmciLCJ0IiwiY2hhcl9pc19kYXNoIiwiYyIsImlzX3ZhbGlkX2V4biIsInMiLCJvZl9zdHJpbmciLCJncm91cCQwIiwiYmluX3NoYXBlX3QkMCIsImJpbl9zaXplX3QkMCIsImJpbl93cml0ZV90JDAiLCJiaW5fd3JpdGVyX3QkMCIsImJpbl9yZWFkX3QkMSIsImJpbl9yZWFkX3QkMiIsImJpbl9yZWFkZXJfdCQwIiwiYmluX3QkMCIsImNvbXBhcmUkMCIsImhhc2hfZm9sZF90JDAiLCJmdW5jJDAiLCJoYXNoJDAiLCJjb3VudGVyIiwic2V0X2FsbF9kYXNoZXMiLCJieXRlcyIsImJvdHRvbV80X2JpdHNfdG9faGV4X2NoYXIiLCJ2IiwidiQwIiwiY3JlYXRlX3JhbmRvbSIsInJhbmRvbV9zdGF0ZSIsImF0IiwiaW50JDAiLCJjcmVhdGUiLCJob3N0bmFtZSIsInBpZCIsInRpbWUiLCJjb3VudGVyJDAiLCJiYXNlIiwiZGlnZXN0IiwiYmluX3NpemVfdCQxIiwiYmluX3dyaXRlX3QkMSIsImJpbl9yZWFkX3QkMyIsImJpbl9yZWFkX3QkNCIsInRfb2Zfc2V4cCQxIiwic2V4cF9vZl90JDEiLCJlcXVhbCQwIiwiY29tcGFyZSQxIiwiaGFzaF9mb2xkX3QkMSIsImludmFyaWFudCIsImdyb3VwJDEiLCJiaW5fc2hhcGVfdCQyIiwiYmluX3dyaXRlcl90JDIiLCJiaW5fcmVhZGVyX3QkMiIsImJpbl90JDIiLCJoYXNoJDIiLCJ0X3NleHBfZ3JhbW1hciQwIiwiYXJnX3R5cGUiLCJzZXhwX29mX3QkMiIsInF1aWNrY2hlY2tfc2hyaW5rZXIiLCJxdWlja2NoZWNrX29ic2VydmVyIiwiZ2VuX2hleF9kaWdpdCIsImxldF9zeW50YXhfMDEzIiwibGV0X3N5bnRheF8wMTQiLCJsZXRfc3ludGF4XzAxNSIsImxldF9zeW50YXhfMDE2IiwibGV0X3N5bnRheF8wMTciLCJmaWZ0aCIsImZvdXJ0aCIsInRoaXJkIiwic2Vjb25kIiwiZmlyc3QiLCJxdWlja2NoZWNrX2dlbmVyYXRvciJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NvcmVfa2VybmVsL3V1aWQvdXVpZC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7SUE2QlFBO0lBMEhGQztJQU9GQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTFJRTs7SUFBQSxjQUFLO0lBQUwsTUFBQTtJQUFBQyxRQUFBO0lBQUEsTUFBQTtJQUFLQyxjQUFMLFdBQUEsK0JBQUFEO0lBQUFFO0lBQUFDO0lBQUFDLG1CQUFBRixZQUFBQztJQUFBRTtJQUFBQztJQUFBQyxtQkFBQUQsY0FBQUQ7SUFBQUcsWUFBS1AsYUFBTEcsY0FBQUc7SUFBQUU7SUFBQUM7SUFBQUM7SUFBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBQUEsU0FBQUMsS0FBQUMsR0FBQSxPQUFBLFdBQUFGLE1BQUFFLEdBQzZFO0dBRWhFO0lBSGJDO0lBQUFDO0lBQUtDO0lBQUFDO0lBR1EsVUFBQSxzQ0FIYlQsU0FBQU87SUFrREFHOzs7OztTQWxES0Q7U0FBTGhCO1NBQUFDO1NBQUFHO1NBQUFEO1NBQUtKO1NBQUxHO1NBQUFHO1NBQUFDO1NBQUFDO1NB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QyxlQUFBRTtzQkF5SGlDO0lBRjdCdUM7TUFDRjtJQUdjQyxpQkFBQSxnQ0FKWkQ7SUFLU0UsaUJBQUEsZ0NBTFRGO0lBTVFHLGlCQUFBLGdDQU5SSDtJQU9TSSxpQkFBQSxnQ0FQVEo7SUFRUUssaUJBQUEsaUNBUlJMOzs7Ozs7S0FRQU07S0FEQUM7S0FEQUM7S0FEQUM7S0FESUM7SUFLRSxPQUFBOzthQUFBLDJCQUxGQSxPQUNKRCxRQUNBRCxPQUNBRCxRQUNBRDs7Ozs4Q0FEU0YsZ0JBQ0RDO2tEQUZBRjtrREFEQ0Q7a0RBREdEO0lBTmRVOzs7Ozs7OztPQXZCRmhDO09BQUFDO09BQUFDO09BQUFDOzs7OztPQVNFZTs7Ozs7Ozs7OztPQVRGWjtPQUFBQzs7Ozs7Ozs7Ozs7Ozs7O09BQUFDOzs7Ozs7T0FKRUM7T0EyQkF1QjtPQUZBWjtPQURBRDtPQXBCRmY7T0FoRUlmO09BdUVGNEI7O1FBUEZqQjtRQUFBQztRQUFBQztRQUFBQztRQUFZUTtRQUFaQztRQUFBQztRQUFBQztRQUFBUDtRQUFBRDtRQUFBRTtRQUFBTztRQUFBWDtRQUFBQztRQUlJVzs7OztTQWpKQS9EO1NBQUFDO1NBQUFFO1NBQUtJO1NBQUFDO1NBQUxoQjtTQUFBQztTQUFBRztTQUFBRDtTQUFLSjtTQUFMRztTQUFBRztTQUFBQztTQUFBQztTQUFBTTtTQUFBQztTQWtEQUc7OztTQW9CQU87U0FEQU47U0E1REV2QjtXQW1KRjJCLGNBbEJGekIsS0FyQ0VtRCxRQTdCQVA7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogQSBsb29zZSBpbXBsZW1lbnRhdGlvbiBvZiB2ZXJzaW9uIDMgYW5kIHZlcnNpb24gNCBvZiB0aGUgVVVJRCBzcGVjIChSRkMgNDEyMik6XG5cbiAgIFZlcnNpb24gMyBVVUlEcyB1c2UgYSBzY2hlbWUgZGVyaXZpbmcgYSBVVUlEIHZpYSBNRDUgZnJvbSBhIFVSTCwgYSBmdWxseVxuICAgcXVhbGlmaWVkIGRvbWFpbiBuYW1lLCBhbiBvYmplY3QgaWRlbnRpZmllciwgYSBkaXN0aW5ndWlzaGVkIG5hbWUgKEROIGFzIHVzZWRcbiAgIGluIExpZ2h0d2VpZ2h0IERpcmVjdG9yeSBBY2Nlc3MgUHJvdG9jb2wpLCBvciBvbiBuYW1lcyBpbiB1bnNwZWNpZmllZFxuICAgbmFtZXNwYWNlcy4gVGhlIGdlbmVyYXRlZCBVVUlEcyBoYXZlIHRoZSBmb3JtIHh4eHh4eHh4LXh4eHgtM3h4eC14eHh4LXh4eHh4eHh4eHh4eFxuICAgd2l0aCBoZXhhZGVjaW1hbCBkaWdpdHMgeC5cblxuICAgVmVyc2lvbiA0IFVVSURzIHVzZSByYW5kb20gYml0cywgdGhlIGdlbmVyYXRlZCBVVUlEcyBoYXZlIHRoZSBmb3JtXG4gICB4eHh4eHh4eC14eHh4LTR4eHgteHh4eC14eHh4eHh4eHh4eHguXG5cbiAgIEluIGJvdGggY2FzZXMsIFJGQyA0MTIyIGNvbXBsaWFuY2Ugd291bGQgcmVxdWlyZSBzZXR0aW5nIHRoZSBcInZhcmlhbnRcIiBiaXRzLCB3aGljaCB0aGVcbiAgIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgZG8uXG4qKVxuXG5tb2R1bGUgU3RhYmxlID0gc3RydWN0XG4gIG9wZW4gQ29yZS5Db3JlX3N0YWJsZVxuXG4gIG1vZHVsZSBWMSA9IHN0cnVjdFxuICAgIG1vZHVsZSBUID0gc3RydWN0XG4gICAgICB0eXBlIHQgPSBzdHJpbmdcbiAgICAgIFtAQGRlcml2aW5nIGJpbl9pbywgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hciwgc3RhYmxlX3dpdG5lc3NdXG5cbiAgICAgIGluY2x1ZGUgKHZhbCBDb21wYXJhdG9yLlYxLm1ha2UgfmNvbXBhcmUgfnNleHBfb2ZfdClcbiAgICBlbmRcblxuICAgIGluY2x1ZGUgVFxuICAgIGluY2x1ZGUgQ29tcGFyYWJsZS5WMS5XaXRoX3N0YWJsZV93aXRuZXNzLk1ha2UgKFQpXG5cbiAgICBsZXQgZm9yX3Rlc3RpbmcgPSBcIjVhODYzZmMxLTY3YjctM2EwYS1kYzkwLWFjYTI5OTVhZmJmOVwiXG4gICAgbGV0IHRvX3N0cmluZyB0ID0gdFxuXG4gICAgKCp7dlxuICAgICAgIHh4eHh4eHh4LXh4eHgtM3h4eC14eHh4LXh4eHh4eHh4eHh4eFxuICAgICAgIHh4eHh4eHh4LXh4eHgtNHh4eC14eHh4LXh4eHh4eHh4eHh4eFxuICAgICAgIDAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NVxuICAgICAgIDAgICAgICAgICAxICAgICAgICAgMiAgICAgICAgIDNcbiAgICB2fSopXG5cbiAgICBsZXQgY2hhcl9pc19kYXNoIGMgPSBDb3JlLkNoYXIuZXF1YWwgJy0nIGNcblxuICAgIGxldCBpc192YWxpZF9leG4gcyA9XG4gICAgICBsZXQgb3BlbiBDb3JlIGluXG4gICAgICAoKiB3ZSBkb24ndCBjaGVjayBmb3IgYSAzIGluIHRoZSB2ZXJzaW9uIHBvc2l0aW9uICgxNCkgYmVjYXVzZSB3ZSB3YW50IHRvIGJlXG4gICAgICAgICBnZW5lcm91cyBhYm91dCBhY2NlcHRpbmcgVVVJRHMgZ2VuZXJhdGVkIGJ5IG90aGVyIHZlcnNpb25zIG9mIHRoZSBwcm90b2NvbCwgYW5kXG4gICAgICAgICB3ZSB3YW50IHRvIGJlIHJlc2lsaWVudCB0byBmdXR1cmUgY2hhbmdlcyBpbiB0aGlzIGFsZ29yaXRobS4gKilcbiAgICAgIGFzc2VydCAoU3RyaW5nLmxlbmd0aCBzID0gMzYpO1xuICAgICAgYXNzZXJ0IChTdHJpbmcuY291bnQgcyB+ZjpjaGFyX2lzX2Rhc2ggPSA0KTtcbiAgICAgIGFzc2VydCAoY2hhcl9pc19kYXNoIHMuWzhdKTtcbiAgICAgIGFzc2VydCAoY2hhcl9pc19kYXNoIHMuWzEzXSk7XG4gICAgICBhc3NlcnQgKGNoYXJfaXNfZGFzaCBzLlsxOF0pO1xuICAgICAgYXNzZXJ0IChjaGFyX2lzX2Rhc2ggcy5bMjNdKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc3RyaW5nIHMgPVxuICAgICAgdHJ5XG4gICAgICAgIGlzX3ZhbGlkX2V4biBzO1xuICAgICAgICBzXG4gICAgICB3aXRoXG4gICAgICB8IF8gLT4gQ29yZS5mYWlsd2l0aGYgXCIlczogbm90IGEgdmFsaWQgVVVJRFwiIHMgKClcbiAgICA7O1xuICBlbmRcbmVuZFxuXG5vcGVuISBDb3JlXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZyBbQEBkZXJpdmluZyBiaW5faW8sIGNvbXBhcmUsIGhhc2hdXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gU3RhYmxlLlYxLmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yID0gU3RhYmxlLlYxLmNvbXBhcmF0b3JcblxuICBsZXQgbmV4dF9jb3VudGVyID1cbiAgICBsZXQgY291bnRlciA9IHJlZiAwIGluXG4gICAgZnVuICgpIC0+XG4gICAgICAoKiBJbiBPQ2FtbCB0aGlzIGRvZXNuJ3QgYWxsb2NhdGUsIGFuZCB0aHJlYWRzIGNhbid0IGNvbnRleHQgc3dpdGNoIGV4Y2VwdCBvblxuICAgICAgICAgYWxsb2NhdGlvbiAqKVxuICAgICAgaW5jciBjb3VudGVyO1xuICAgICAgIWNvdW50ZXJcbiAgOztcblxuICBsZXQgc2V0X2FsbF9kYXNoZXMgYnl0ZXMgPVxuICAgIEJ5dGVzLnNldCBieXRlcyA4ICctJztcbiAgICBCeXRlcy5zZXQgYnl0ZXMgMTMgJy0nO1xuICAgIEJ5dGVzLnNldCBieXRlcyAxOCAnLSc7XG4gICAgQnl0ZXMuc2V0IGJ5dGVzIDIzICctJ1xuICA7O1xuXG4gIGxldCBzZXRfdmVyc2lvbiBieXRlcyB+dmVyc2lvbiA9IEJ5dGVzLnNldCBieXRlcyAxNCB2ZXJzaW9uXG4gIGxldCB0b19zdHJpbmcgPSBTdGFibGUuVjEudG9fc3RyaW5nXG4gIGxldCBvZl9zdHJpbmcgPSBTdGFibGUuVjEub2Zfc3RyaW5nXG5cbiAgbGV0IGJvdHRvbV80X2JpdHNfdG9faGV4X2NoYXIgdiA9XG4gICAgbGV0IHYgPSB2IGxhbmQgMHgwRiBpblxuICAgIGlmIHYgPCAxMCB0aGVuIENoYXIudW5zYWZlX29mX2ludCAoNDggKyB2KSBlbHNlIENoYXIudW5zYWZlX29mX2ludCAoODcgKyB2KVxuICA7O1xuXG4gIGxldCBjcmVhdGVfcmFuZG9tID1cbiAgICBsZXQgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgMzYgaW5cbiAgICBmdW4gcmFuZG9tX3N0YXRlIC0+XG4gICAgICAoKiBXZSBmaWxsIGFsbCAzNiBieXRlcyB3aXRoIHJhbmRvbSBoZXggZGlnaXRzLCBhbmQgdGhlbiBnbyBiYWNrIGFuZCBzZXQgc3BlY2lmaWNcbiAgICAgICAgIGJ5dGVzIHRvIGRhc2ggYW5kIHRoZSB2ZXJzaW9uIG51bWJlciAoNCkuICBXZSBkbyA2IGdyb3VwcyBvZiA2IGJ5dGVzLCBlYWNoIHRpbWVcbiAgICAgICAgIHVzaW5nIDI0IGJpdHMgb2YgYSByYW5kb20gaW50LCA0IGZvciBlYWNoIGhleCBkaWdpdC4gKilcbiAgICAgIGxldCBhdCA9IHJlZiAwIGluXG4gICAgICBmb3IgXyA9IDEgdG8gNiBkb1xuICAgICAgICBsZXQgaW50ID0gcmVmIChSYW5kb20uU3RhdGUuYml0cyByYW5kb21fc3RhdGUpIGluXG4gICAgICAgIGZvciBfID0gMSB0byA2IGRvXG4gICAgICAgICAgQnl0ZXMuc2V0IGJ5dGVzICFhdCAoYm90dG9tXzRfYml0c190b19oZXhfY2hhciAhaW50KTtcbiAgICAgICAgICBpbmNyIGF0O1xuICAgICAgICAgIGludCA6PSAhaW50IGxzciA0XG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmU7XG4gICAgICBzZXRfYWxsX2Rhc2hlcyBieXRlcztcbiAgICAgIHNldF92ZXJzaW9uIGJ5dGVzIH52ZXJzaW9uOic0JztcbiAgICAgIEJ5dGVzLnRvX3N0cmluZyBieXRlc1xuICA7O1xuXG4gICgqIFtjcmVhdGVdIGlzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBzdHJpbmcgaWRlbnRpZmllcnMuICBJdCBzaG91bGQgYmUgY2xlYXJcbiAgICAgdG8gYSByZWFkZXIgdGhhdCB0aGUgaWQgZ2VuZXJhdGVkIGhhcyBhbiBleHRyZW1lbHkgaGlnaCBwcm9iYWJpbGl0eSBvZiB1bmlxdWVuZXNzXG4gICAgIGFjcm9zcyBhbGwgcG9zc2libGUgbWFjaGluZXMsIHByb2Nlc3NlcywgYW5kIHRocmVhZHMgb2YgZXhlY3V0aW9uLiAqKVxuXG4gIGxldCBjcmVhdGUgfmhvc3RuYW1lIH5waWQgPVxuICAgIGxldCBkaWdlc3QgPVxuICAgICAgbGV0IHRpbWUgPSBUaW1lX25zLm5vdyAoKSBpblxuICAgICAgbGV0IGNvdW50ZXIgPSBuZXh0X2NvdW50ZXIgKCkgaW5cbiAgICAgIGxldCBiYXNlID1cbiAgICAgICAgU3RyaW5nLmNvbmNhdFxuICAgICAgICAgIH5zZXA6XCItXCJcbiAgICAgICAgICBbIGhvc3RuYW1lXG4gICAgICAgICAgOyBJbnQudG9fc3RyaW5nIHBpZFxuICAgICAgICAgIDsgSW50LnRvX3N0cmluZyAoVGltZV9ucy50b19pbnRfbnNfc2luY2VfZXBvY2ggdGltZSlcbiAgICAgICAgICA7IEludC50b19zdHJpbmcgY291bnRlclxuICAgICAgICAgIF1cbiAgICAgIGluXG4gICAgICBNZDUudG9faGV4IChNZDUuZGlnZXN0X3N0cmluZyBiYXNlKVxuICAgIGluXG4gICAgbGV0IHMgPSBCeXRlcy5jcmVhdGUgMzYgaW5cbiAgICBzZXRfYWxsX2Rhc2hlcyBzO1xuICAgIEJ5dGVzLkZyb21fc3RyaW5nLmJsaXQgfnNyYzpkaWdlc3QgfmRzdDpzIH5zcmNfcG9zOjAgfmRzdF9wb3M6MCB+bGVuOjg7XG4gICAgQnl0ZXMuRnJvbV9zdHJpbmcuYmxpdCB+c3JjOmRpZ2VzdCB+ZHN0OnMgfnNyY19wb3M6OCB+ZHN0X3Bvczo5IH5sZW46NDtcbiAgICBCeXRlcy5Gcm9tX3N0cmluZy5ibGl0IH5zcmM6ZGlnZXN0IH5kc3Q6cyB+c3JjX3BvczoxMiB+ZHN0X3BvczoxNCB+bGVuOjQ7XG4gICAgQnl0ZXMuRnJvbV9zdHJpbmcuYmxpdCB+c3JjOmRpZ2VzdCB+ZHN0OnMgfnNyY19wb3M6MTYgfmRzdF9wb3M6MTkgfmxlbjo0O1xuICAgIEJ5dGVzLkZyb21fc3RyaW5nLmJsaXQgfnNyYzpkaWdlc3QgfmRzdDpzIH5zcmNfcG9zOjIwIH5kc3RfcG9zOjI0IH5sZW46MTI7XG4gICAgc2V0X3ZlcnNpb24gcyB+dmVyc2lvbjonMyc7XG4gICAgQnl0ZXMudG9fc3RyaW5nIHNcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFRcblxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZV91c2luZ19jb21wYXJhdG9yIChzdHJ1Y3RcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJVdWlkXCJcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBTZXhwYWJsZS5PZl9zdHJpbmdhYmxlIChUKVxuZW5kKVxuXG5sZXQgaW52YXJpYW50IHQgPSBpZ25vcmUgKG9mX3N0cmluZyB0IDogdClcbmxldCBuaWwgPSBcIjAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMFwiXG5cbm1vZHVsZSBVbnN0YWJsZSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdCBbQEBkZXJpdmluZyBiaW5faW8sIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwXVxuICB0eXBlIG5vbnJlYyBjb21wYXJhdG9yX3dpdG5lc3MgPSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3JcbiAgbGV0IHRfc2V4cF9ncmFtbWFyID0gc3RyaW5nX3NleHBfZ3JhbW1hclxuZW5kXG5cbmxldCBhcmdfdHlwZSA9IENvbW1hbmQuQXJnX3R5cGUuY3JlYXRlIG9mX3N0cmluZ1xuXG5sZXQgc2V4cF9vZl90IHQgPVxuICBpZiBhbV9ydW5uaW5nX3Rlc3QgdGhlbiBbJXNleHAgXCI8dXVpZC1vbWl0dGVkLWluLXRlc3Q+XCJdIGVsc2UgWyVzZXhwICh0IDogdCldXG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgY3JlYXRlID0gY3JlYXRlXG4gIGxldCBpc192YWxpZF9leG4gPSBTdGFibGUuVjEuaXNfdmFsaWRfZXhuXG4gIGxldCBib3R0b21fNF9iaXRzX3RvX2hleF9jaGFyID0gYm90dG9tXzRfYml0c190b19oZXhfY2hhclxuICBsZXQgbmlsID0gbmlsXG5lbmRcblxubGV0IHF1aWNrY2hlY2tfc2hyaW5rZXIgOiB0IFF1aWNrY2hlY2suU2hyaW5rZXIudCA9IFF1aWNrY2hlY2suU2hyaW5rZXIuZW1wdHkgKClcbmxldCBxdWlja2NoZWNrX29ic2VydmVyIDogdCBRdWlja2NoZWNrLk9ic2VydmVyLnQgPSBRdWlja2NoZWNrLk9ic2VydmVyLm9mX2hhc2ggKG1vZHVsZSBUKVxuXG5sZXQgcXVpY2tjaGVja19nZW5lcmF0b3IgOiB0IFF1aWNrY2hlY2suR2VuZXJhdG9yLnQgPVxuICBsZXQgb3BlbiBRdWlja2NoZWNrLkdlbmVyYXRvci5MZXRfc3ludGF4IGluXG4gIGxldCBnZW5faGV4X2RpZ2l0IDogQ2hhci50IFF1aWNrY2hlY2suR2VuZXJhdG9yLnQgPVxuICAgIFF1aWNrY2hlY2suR2VuZXJhdG9yLndlaWdodGVkX3VuaW9uXG4gICAgICBbIDEwLjAsIENoYXIuZ2VuX2RpZ2l0OyA2LjAsIENoYXIuZ2VuX3VuaWZvcm1faW5jbHVzaXZlICdhJyAnZicgXVxuICBpblxuICBsZXQlbWFwIGZpcnN0ID0gU3RyaW5nLmdlbl93aXRoX2xlbmd0aCA4IGdlbl9oZXhfZGlnaXRcbiAgYW5kIHNlY29uZCA9IFN0cmluZy5nZW5fd2l0aF9sZW5ndGggNCBnZW5faGV4X2RpZ2l0XG4gIGFuZCB0aGlyZCA9IFN0cmluZy5nZW5fd2l0aF9sZW5ndGggNCBnZW5faGV4X2RpZ2l0XG4gIGFuZCBmb3VydGggPSBTdHJpbmcuZ2VuX3dpdGhfbGVuZ3RoIDQgZ2VuX2hleF9kaWdpdFxuICBhbmQgZmlmdGggPSBTdHJpbmcuZ2VuX3dpdGhfbGVuZ3RoIDEyIGdlbl9oZXhfZGlnaXQgaW5cbiAgb2Zfc3RyaW5nIChzcHJpbnRmIFwiJXMtJXMtJXMtJXMtJXNcIiBmaXJzdCBzZWNvbmQgdGhpcmQgZm91cnRoIGZpZnRoKVxuOztcbiJdfQ==
