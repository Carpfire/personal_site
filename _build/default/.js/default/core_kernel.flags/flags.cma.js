// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Flags__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Flags = [0], Flags$0 = [0, Flags];
   runtime.caml_register_global(0, Flags$0, "Flags__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Flags__Flags_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Flags_Flags_intf = "Flags__Flags_intf",
    cst_flags = "flags";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Flags_Flags_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_flags);
   caml_call1(Ppx_expect_runtime[1][1], "flags/src/flags_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_flags, "flags_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_flags);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Flags_Flags_intf);
   var Flags_Flags_intf = [0];
   runtime.caml_register_global(11, Flags_Flags_intf, cst_Flags_Flags_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Flags
//# unitInfo: Requires: Bin_prot__Shape, Bin_shape, Core, Core__Comparable, Core__Error, Core__Hashtbl, Core__Int63, Core__Int64, Core__List, Core__Sexp, Core__String, Flags__Flags_intf, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Typerep_lib__Make_typename
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Flags$0 = "Flags",
    cst_flags$0 = "flags",
    cst_flags_src_flags_ml = "flags/src/flags.ml",
    cst_sexp = "sexp",
    cst_t$3 = "t",
    cst_unrecognized_bits = "unrecognized_bits",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    name = "flags/src/flags.ml.Make.t",
    Core_Int63 = global_data.Core__Int63,
    Core_Sexp = global_data.Core__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Core_Int64 = global_data.Core__Int64;
   global_data.Sexplib0__Sexp_conv_error;
   var
    Core_Error = global_data.Core__Error,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename,
    Assert_failure = global_data.Assert_failure,
    Core_String = global_data.Core__String,
    Core_Comparable = global_data.Core__Comparable,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Flags$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_flags$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_flags_src_flags_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_flags$0, "flags.ml");
   var
    _g_ = [0, cst_sexp],
    cst_Of_sexp_error_sexp_format_ =
      "Of_sexp_error: sexp format does not match any recognized format",
    _f_ = [0, cst_sexp],
    cst_Of_sexp_error_list_needed = "Of_sexp_error: list needed",
    _e_ =
      [0,
       [11, "Flags.t_of_sexp got unknown name: ", [2, 0, 0]],
       "Flags.t_of_sexp got unknown name: %s"],
    _d_ = [0, cst_unrecognized_bits],
    _b_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
    cst_t = cst_t$3,
    cst_flags_src_flags_ml_21_2 = "flags/src/flags.ml:21:2",
    cst_t$0 = cst_t$3,
    _c_ = [0, cst_flags_src_flags_ml, 71, 8],
    cst_Flags_Make_got_intersectin = "Flags.Make got intersecting flags",
    cst_Flag_Make_got_flags_with_n = "Flag.Make got flags with no bits set",
    cst_t$1 = cst_t$3,
    cst_flags_src_flags_ml_161_4 = "flags/src/flags.ml:161:4",
    cst_t$2 = cst_t$3,
    cst_Flags_create_got_invalid_b =
      "Flags.create got invalid ~bit (must be between 0 and 62)",
    _a_ = [0, cst_flags_src_flags_ml, 9, 243, 253],
    cst_flags = cst_flags$0,
    cst_Flags = cst_Flags$0;
   function create(n){
    var _ae_ = n < 0 ? 1 : 0, _af_ = _ae_ || (62 < n ? 1 : 0);
    if(_af_)
     caml_call5
      (Core[247], 0, _a_, cst_Flags_create_got_invalid_b, n, Core[389]);
    return caml_call2(Core_Int63[50], Core_Int63[17], n);
   }
   function Make(M){
    var
     _o_ = Core_Int63[98],
     _p_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), 0, _o_], 0],
     _q_ = caml_call1(Bin_shape[4][1], cst_flags_src_flags_ml_21_2),
     group = caml_call2(Bin_prot_Shape[2], _q_, _p_),
     _r_ = caml_call1(Bin_shape[2][1], cst_t$0),
     bin_shape_t = caml_call1(caml_call2(Bin_prot_Shape[10], group, _r_), 0),
     bin_size_t = Core_Int63[94],
     bin_write_t = Core_Int63[95],
     bin_writer_t = [0, bin_size_t, bin_write_t],
     bin_read_t = Core_Int63[97],
     bin_read_t$0 = Core_Int63[96],
     bin_reader_t = [0, bin_read_t$0, bin_read_t],
     bin_t = [0, bin_shape_t, bin_writer_t, bin_reader_t],
     Typename_of_t = caml_call1(Typerep_lib_Make_typename[1], [0, name]),
     typename_of_t = Typename_of_t[2],
     name_of_t = Typename_of_t[1],
     typerep_of_t = [9, [0, name_of_t, [0, Core_Int63[90]]]],
     of_int = Core_Int63[72],
     to_int_exn = Core_Int63[5],
     empty = Core_Int63[16];
    function is_empty(t){return caml_equal(t, empty);}
    function symbol(a, b){return caml_call2(Core_Int63[46], a, b);}
    function symbol$0(a, b){
     var _ad_ = caml_call1(Core_Int63[48], b);
     return caml_call2(Core_Int63[45], a, _ad_);
    }
    var intersect = Core_Int63[45];
    function _s_(acc, param){var flag = param[1]; return symbol(acc, flag);}
    var all = caml_call3(Core_List[20], M[1], empty, _s_);
    function complement(a){return symbol$0(all, a);}
    function is_subset(t, of){
     var _ac_ = caml_call2(intersect, t, of);
     return caml_call2(Core_Int63[109], t, _ac_);
    }
    function do_intersect(t1, t2){
     var _aa_ = Core_Int63[16], _ab_ = caml_call2(Core_Int63[45], t1, t2);
     return caml_call2(Core_Int63[112], _ab_, _aa_);
    }
    function are_disjoint(t1, t2){
     var ___ = Core_Int63[16], _$_ = caml_call2(Core_Int63[45], t1, t2);
     return caml_call2(Core_Int63[109], _$_, ___);
    }
    function error(message, a, sexp_of_a){
     var e = caml_call5(Core_Error[19], 0, 0, message, a, sexp_of_a);
     if(M[4]){
      var
       _Y_ = caml_call1(Core_Error[9], e),
       _Z_ = caml_call2(Core_Sexp[84], 0, _Y_);
      caml_call2(Core[243], _b_, _Z_);
     }
     return caml_call1(Core_Error[30], e);
    }
    if(M[2])
     var
      _t_ =
        function(param){
         var n = param[1];
         return 1 - caml_call2(Core_Int63[113], n, Core_Int63[16]);
        },
      known = caml_call2(Core_List[12], M[1], _t_);
    else
     var known = M[1];
    function any_intersecting(flags){
     var l = flags, acc = empty;
     for(;;){
      if(! l) return 0;
      var l$0 = l[2], flag = l[1][1];
      if(do_intersect(flag, acc)) return 1;
      var acc$0 = symbol(acc, flag), l = l$0, acc = acc$0;
     }
    }
    if(1 - M[3] && any_intersecting(known)){
     var l = known, bad = 0;
     for(;;){
      if(! l) break;
      var
       l$0 = l[2],
       match = l[1],
       name$0 = match[2],
       flag = match[1],
       _u_ =
         function(flag){
           return function(param){
            var flag$0 = param[1];
            return do_intersect(flag, flag$0);};
          }
          (flag),
       bad$0 = caml_call2(Core_List[12], l$0, _u_),
       ac =
         caml_call1(Core_List[18], bad$0)
          ? bad
          : [0, [0, flag, name$0, bad$0], bad],
       l = l$0,
       bad = ac;
     }
     if(caml_call1(Core_List[18], bad))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     error
      (cst_Flags_Make_got_intersectin,
       bad,
       function(x_011){
        function _W_(param){
         var
          arg2_007 = param[3],
          arg1_006 = param[2],
          arg0_005 = param[1],
          res0_008 = caml_call1(Core_Int63[103], arg0_005),
          res1_009 = caml_call1(Core[558], arg1_006);
         function _X_(param){
          var
           arg1_002 = param[2],
           arg0_001 = param[1],
           res0_003 = caml_call1(Core_Int63[103], arg0_001),
           res1_004 = caml_call1(Core[558], arg1_002);
          return [1, [0, res0_003, [0, res1_004, 0]]];
         }
         var res2_010 = caml_call2(Core[472], _X_, arg2_007);
         return [1, [0, res0_008, [0, res1_009, [0, res2_010, 0]]]];
        }
        return caml_call2(Core[472], _W_, x_011);
       });
    }
    function _v_(param){
     var flag = param[1];
     return caml_equal(flag, Core_Int63[16]);
    }
    var bad$1 = caml_call2(Core_List[12], known, _v_);
    if(1 - caml_call1(Core_List[18], bad$1))
     error
      (cst_Flag_Make_got_flags_with_n,
       bad$1,
       function(x_016){
        function _V_(param){
         var
          arg1_013 = param[2],
          arg0_012 = param[1],
          res0_014 = caml_call1(Core_Int63[103], arg0_012),
          res1_015 = caml_call1(Core[558], arg1_013);
         return [1, [0, res0_014, [0, res1_015, 0]]];
        }
        return caml_call2(Core[472], _V_, x_016);
       });
    function sexp_format_of_sexp(x_018){
     return caml_call2(Core[473], Core[559], x_018);
    }
    function sexp_of_sexp_format(x_019){
     return caml_call2(Core[472], Core[558], x_019);
    }
    function sexp_of_sexp_format_with_unrec(param){
     var
      arg1_038 = param[2],
      arg0_037 = param[1],
      res0_039 = caml_call2(Core[472], Core[558], arg0_037),
      v_036 = arg1_038[2],
      res1_040 = [1, [0, _d_, [0, caml_call1(Core[558], v_036), 0]]];
     return [1, [0, res0_039, [0, res1_040, 0]]];
    }
    var known$0 = caml_call1(Core_List[59], known);
    function to_flag_list(t){
     function _T_(param, _U_){
      var
       flag_name = _U_[2],
       flag = _U_[1],
       flag_names = param[2],
       t = param[1];
      return caml_equal(caml_call2(Core_Int63[45], t, flag), flag)
              ? [0, symbol$0(t, flag), [0, flag_name, flag_names]]
              : [0, t, flag_names];
     }
     return caml_call3(Core_List[20], known$0, [0, t, 0], _T_);
    }
    function sexp_of_t(t){
     var match = to_flag_list(t), flag_names = match[2], leftover = match[1];
     if(caml_equal(leftover, empty)) return sexp_of_sexp_format(flag_names);
     var _S_ = caml_call1(Core_Int63[57], leftover);
     return sexp_of_sexp_format_with_unrec
             ([0,
               flag_names,
               [0,
                710664790,
                caml_call1
                 (Core_Int64[71][19],
                  runtime.caml_int64_and(Core_Int64[45], _S_))]]);
    }
    function _w_(param){
     var name = param[2], mask = param[1];
     return [0, name, mask];
    }
    var
     _x_ = caml_call2(Core_List[51], known, _w_),
     known_by_name = caml_call3(Core_String[164][9], 0, 0, _x_);
    function t_of_sexp(sexp){
     function restore_int_of_flags_sexp(flags){
      function _P_(t, name){
       var match = caml_call2(Core_Hashtbl[56], known_by_name, name);
       if(match){var mask = match[1]; return symbol(t, mask);}
       var _R_ = caml_call2(Core[265], _e_, name);
       return caml_call2(Core[154], _R_, sexp);
      }
      var _Q_ = sexp_format_of_sexp(flags);
      return caml_call3(Core_List[20], _Q_, empty, _P_);
     }
     if(0 === sexp[0]){
      var
       _F_ = [0, [1, [0, _f_, [0, caml_call1(Core_Sexp[93], sexp), 0]]], 0],
       _G_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Of_sexp_error_list_needed),
           _F_]];
      return caml_call1(Core[261], _G_);
     }
     var flags = sexp[1];
     if(flags){
      var _H_ = flags[1];
      if(0 !== _H_[0]){
       var _I_ = flags[2];
       if(_I_){
        var _J_ = _I_[1], flags$0 = _H_[1];
        if(0 !== _J_[0] && ! _I_[2]){
         var unrecognized = _J_[1];
         if(unrecognized){
          var _K_ = unrecognized[1];
          if
           (0 === _K_[0]
            && ! runtime.caml_string_notequal(_K_[1], cst_unrecognized_bits)){
           var _N_ = unrecognized[2];
           if(_N_){
            var _O_ = _N_[1];
            if(0 === _O_[0] && ! _N_[2]){
             var
              num = _O_[1],
              _D_ = caml_call1(Core_Int64[71][18], num),
              _E_ = caml_call1(Core_Int63[81], _D_);
             return symbol(restore_int_of_flags_sexp([1, flags$0]), _E_);
            }
           }
          }
         }
         var
          _L_ = [0, [1, [0, _g_, [0, caml_call1(Core_Sexp[93], sexp), 0]]], 0],
          _M_ =
            [1,
             [0,
              caml_call1
               (Sexplib0_Sexp_conv[7], cst_Of_sexp_error_sexp_format_),
              _L_]];
         return caml_call1(Core[261], _M_);
        }
       }
      }
     }
     return restore_int_of_flags_sexp([1, flags]);
    }
    function compare(t, u){
     function flip_top_bit(i){
      return caml_call2(Core_Int63[19], i, Core_Int63[63]);
     }
     var _B_ = flip_top_bit(u), _C_ = flip_top_bit(t);
     return caml_call2(Core_Int63[114], _C_, _B_);
    }
    var
     include =
       caml_call1(Core_Comparable[12], [0, compare, t_of_sexp, sexp_of_t]),
     symbol$1 = include[1],
     symbol$2 = include[2],
     symbol$3 = include[4],
     symbol$4 = include[5],
     compare$0 = include[8],
     min = include[9],
     max = include[10],
     ascending = include[11],
     descending = include[12],
     between = include[13],
     clamp_exn = include[14],
     clamp = include[15],
     comparator = include[16],
     validate_lbound = include[17],
     validate_ubound = include[18],
     validate_bound = include[19],
     Replace_polymorphic_compare = include[20],
     Map = include[21],
     Set = include[22],
     equal = Core_Int63[109],
     symbol$5 = Core_Int63[109],
     symbol$6 = Core_Int63[112],
     _y_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$1), 0, bin_shape_t], 0],
     _z_ = caml_call1(Bin_shape[4][1], cst_flags_src_flags_ml_161_4),
     group$0 = caml_call2(Bin_prot_Shape[2], _z_, _y_),
     _A_ = caml_call1(Bin_shape[2][1], cst_t$2),
     bin_shape_t$0 =
       caml_call1(caml_call2(Bin_prot_Shape[10], group$0, _A_), 0),
     bin_writer_t$0 = [0, bin_size_t, bin_write_t],
     bin_reader_t$0 = [0, bin_read_t$0, bin_read_t],
     bin_t$0 = [0, bin_shape_t$0, bin_writer_t$0, bin_reader_t$0],
     Unstable =
       [0,
        bin_shape_t$0,
        bin_size_t,
        bin_write_t,
        bin_writer_t$0,
        bin_read_t,
        bin_read_t$0,
        bin_reader_t$0,
        bin_t$0,
        compare$0,
        equal,
        t_of_sexp,
        sexp_of_t];
    return [0,
            bin_shape_t,
            bin_size_t,
            bin_write_t,
            bin_writer_t,
            bin_read_t,
            bin_read_t$0,
            bin_reader_t,
            bin_t,
            ,
            ,
            ,
            typename_of_t,
            typerep_of_t,
            of_int,
            to_int_exn,
            empty,
            is_empty,
            symbol,
            symbol$0,
            intersect,
            ,
            complement,
            is_subset,
            do_intersect,
            are_disjoint,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            to_flag_list,
            sexp_of_t,
            ,
            t_of_sexp,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            compare$0,
            min,
            max,
            ascending,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator,
            validate_lbound,
            validate_ubound,
            validate_bound,
            Replace_polymorphic_compare,
            Map,
            Set,
            equal,
            symbol$5,
            symbol$6,
            Unstable];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_flags);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Flags);
   function _h_(_l_){
    var _m_ = Make(_l_), _n_ = _m_[59];
    return [0,
            _m_[2],
            _m_[3],
            _m_[6],
            _m_[5],
            _m_[1],
            _m_[4],
            _m_[7],
            _m_[8],
            _m_[36],
            _m_[34],
            _m_[13],
            _m_[12],
            _m_[37],
            _m_[38],
            _m_[57],
            _m_[39],
            _m_[40],
            _m_[58],
            _m_[56],
            _m_[41],
            _m_[42],
            _m_[43],
            _m_[44],
            _m_[45],
            _m_[46],
            _m_[47],
            _m_[48],
            _m_[49],
            _m_[50],
            _m_[51],
            _m_[52],
            _m_[53],
            _m_[54],
            _m_[55],
            _m_[33],
            _m_[14],
            _m_[15],
            _m_[16],
            _m_[18],
            _m_[19],
            _m_[20],
            _m_[22],
            _m_[17],
            _m_[24],
            _m_[25],
            _m_[23],
            [0,
             _n_[2],
             _n_[3],
             _n_[6],
             _n_[5],
             _n_[1],
             _n_[4],
             _n_[7],
             _n_[8],
             _n_[9],
             _n_[10],
             _n_[11],
             _n_[12]]];
   }
   var
    Flags =
      [0,
       create,
       function(_i_){
        var _j_ = Make(_i_), _k_ = _j_[59];
        return [0,
                _j_[36],
                _j_[34],
                _j_[13],
                _j_[12],
                _j_[37],
                _j_[38],
                _j_[57],
                _j_[39],
                _j_[40],
                _j_[58],
                _j_[56],
                _j_[41],
                _j_[42],
                _j_[43],
                _j_[44],
                _j_[45],
                _j_[46],
                _j_[47],
                _j_[48],
                _j_[49],
                _j_[50],
                _j_[51],
                _j_[52],
                _j_[53],
                _j_[54],
                _j_[55],
                _j_[33],
                _j_[14],
                _j_[15],
                _j_[16],
                _j_[18],
                _j_[19],
                _j_[20],
                _j_[22],
                _j_[17],
                _j_[24],
                _j_[25],
                _j_[23],
                [0,
                 _k_[2],
                 _k_[3],
                 _k_[6],
                 _k_[5],
                 _k_[1],
                 _k_[4],
                 _k_[7],
                 _k_[8],
                 _k_[9],
                 _k_[10],
                 _k_[11],
                 _k_[12]]];
       },
       _h_];
   runtime.caml_register_global(49, Flags, cst_Flags$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJmbGFncy5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsibmFtZSIsImNyZWF0ZSIsIm4iLCJncm91cCIsImJpbl9zaGFwZV90IiwiYmluX3NpemVfdCIsImJpbl93cml0ZV90IiwiYmluX3dyaXRlcl90IiwiYmluX3JlYWRfdCIsImJpbl9yZWFkX3QkMCIsImJpbl9yZWFkZXJfdCIsImJpbl90IiwidHlwZW5hbWVfb2ZfdCIsIm5hbWVfb2ZfdCIsInR5cGVyZXBfb2ZfdCIsIm9mX2ludCIsInRvX2ludF9leG4iLCJlbXB0eSIsImlzX2VtcHR5IiwidCIsInN5bWJvbCIsImEiLCJiIiwic3ltYm9sJDAiLCJpbnRlcnNlY3QiLCJhY2MiLCJmbGFnIiwiYWxsIiwiY29tcGxlbWVudCIsImlzX3N1YnNldCIsIm9mIiwiZG9faW50ZXJzZWN0IiwidDEiLCJ0MiIsImFyZV9kaXNqb2ludCIsImVycm9yIiwibWVzc2FnZSIsInNleHBfb2ZfYSIsImUiLCJrbm93biIsImFueV9pbnRlcnNlY3RpbmciLCJmbGFncyIsImwiLCJsJDAiLCJhY2MkMCIsImJhZCIsIm5hbWUkMCIsImZsYWckMCIsImJhZCQwIiwiYWMiLCJ4XzAxMSIsImFyZzJfMDA3IiwiYXJnMV8wMDYiLCJhcmcwXzAwNSIsInJlczBfMDA4IiwicmVzMV8wMDkiLCJhcmcxXzAwMiIsImFyZzBfMDAxIiwicmVzMF8wMDMiLCJyZXMxXzAwNCIsInJlczJfMDEwIiwiYmFkJDEiLCJ4XzAxNiIsImFyZzFfMDEzIiwiYXJnMF8wMTIiLCJyZXMwXzAxNCIsInJlczFfMDE1Iiwic2V4cF9mb3JtYXRfb2Zfc2V4cCIsInhfMDE4Iiwic2V4cF9vZl9zZXhwX2Zvcm1hdCIsInhfMDE5Iiwic2V4cF9vZl9zZXhwX2Zvcm1hdF93aXRoX3VucmVjIiwiYXJnMV8wMzgiLCJhcmcwXzAzNyIsInJlczBfMDM5Iiwidl8wMzYiLCJyZXMxXzA0MCIsImtub3duJDAiLCJ0b19mbGFnX2xpc3QiLCJmbGFnX25hbWUiLCJmbGFnX25hbWVzIiwic2V4cF9vZl90IiwibGVmdG92ZXIiLCJtYXNrIiwia25vd25fYnlfbmFtZSIsInRfb2Zfc2V4cCIsInNleHAiLCJyZXN0b3JlX2ludF9vZl9mbGFnc19zZXhwIiwiZmxhZ3MkMCIsInVucmVjb2duaXplZCIsIm51bSIsImNvbXBhcmUiLCJ1IiwiZmxpcF90b3BfYml0IiwiaSIsImNvbXBhcmUkMCIsImVxdWFsIiwic3ltYm9sJDUiLCJzeW1ib2wkNiIsImdyb3VwJDAiLCJiaW5fc2hhcGVfdCQwIiwiYmluX3dyaXRlcl90JDAiLCJiaW5fcmVhZGVyX3QkMCIsImJpbl90JDAiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlX2tlcm5lbC9mbGFncy9mbGFnc19fLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvY29yZV9rZXJuZWwvZmxhZ3MvZmxhZ3MubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FLaUIsdUNBQUE7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lDZWZBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBTkVDLE9BQVlDO0lBQ2QsV0FEY0Esb0NBQUFBOztLQVBkOzBEQU9jQTtJQUNVLE9BQUEsMkNBRFZBO0dBRWM7O0lBSTVCOztLQUFBLGNBQUs7S0FBTCxNQUFBO0tBQUFDLFFBQUE7S0FBQSxNQUFBO0tBQUtDLGNBQUwsV0FBQSwrQkFBQUQ7S0FBQUU7S0FBQUM7S0FBQUMsbUJBQUFGLFlBQUFDO0tBQUFFO0tBQUFDO0tBQUFDLG1CQUFBRCxjQUFBRDtLQUFBRyxZQUFLUCxhQUFMRyxjQUFBRztrRUFBQVY7S0FBQVk7S0FBQUM7S0FBQUMsdUJBQUFEO0tBRUlFO0tBQ0FDO0tBQ0FDO2FBQ0FD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QUFDO0tBSkVDO0tBQ0FDO0tBR0YsY0FBWSx5Q0E1SVQ5RjtLQTRJSCxNQUFBO0tBQUErRixVQUFBO0tBQUEsTUFBQTtLQUFZQztPQUFaLFdBQUEsK0JBQUFEO0tBQUFFLHFCQTVJRmhHLFlBQUFDO0tBNElFZ0cscUJBNUlGN0YsY0FBQUQ7S0E0SUUrRixjQUFZSCxlQUFaQyxnQkFBQUM7S0FEZ0I7O1FBQ0pGO1FBNUlkL0Y7UUFBQUM7UUE0SUUrRjtRQTVJRjdGO1FBQUFDO1FBNElFNkY7UUFBQUM7UUFBQVI7UUFBQUM7UUFBQVg7UUFBQUo7SUE3SXlCO1lBQ3RCN0U7WUFBTEM7WUFBQUM7WUFBQUM7WUFBQUM7WUFBQUM7WUFBQUM7WUFBQUM7Ozs7WUFBQUM7WUFBQUU7WUFFSUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUU7WUFDQUc7WUFDQUM7O1lBRUFJO1lBQ0FDO1lBQ0FFO1lBQ0FHOzs7Ozs7OztZQXdEQTRDO1lBdUVGRzs7WUFBQUk7Ozs7O1lBQUFVOzs7Ozs7Ozs7Ozs7Ozs7WUFBQUM7WUFKRUM7WUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EvSUZqRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBieSBkdW5lICopXG5cbigqKiBAY2Fub25pY2FsIEZsYWdzLkZsYWdzX2ludGYgKilcbm1vZHVsZSBGbGFnc19pbnRmID0gRmxhZ3NfX0ZsYWdzX2ludGZcblxubW9kdWxlIEZsYWdzX18gPSBzdHJ1Y3QgZW5kXG5bQEBkZXByZWNhdGVkIFwidGhpcyBtb2R1bGUgaXMgc2hhZG93ZWRcIl1cbiIsIm9wZW4hIENvcmVcbm9wZW4gUG9seVxuaW5jbHVkZSBGbGFnc19pbnRmXG5cbigqIFRvIGFsbG93IFtjcmVhdGVdIHRvIGJlIGVhZ2VybHkgaW5saW5lZCwgbW92ZSB0aGlzIGV4Y2VwdGlvbiB3aXRoIG1hY3JvIGV4cGFuc2lvbiB0b1xuICAgaXRzIG93biBmdW5jdGlvbiBhbmQgbWFyayBpdCBbQGNvbGRdIHNvIHRoYXQgaXQgaXNuJ3QgaW5saW5lZC4gKilcbmxldFtAY29sZF0gcmFpc2VfaW52YWxpZF9iaXQgbiA9XG4gIGZhaWx3aXRoc1xuICAgIH5oZXJlOlslaGVyZV1cbiAgICBcIkZsYWdzLmNyZWF0ZSBnb3QgaW52YWxpZCB+Yml0IChtdXN0IGJlIGJldHdlZW4gMCBhbmQgNjIpXCJcbiAgICBuXG4gICAgWyVzZXhwX29mOiBpbnRdXG47O1xuXG5sZXQgY3JlYXRlIH5iaXQ6biA9XG4gIGlmIG4gPCAwIHx8IG4gPiA2MiB0aGVuIHJhaXNlX2ludmFsaWRfYml0IG47XG4gIEludDYzLnNoaWZ0X2xlZnQgSW50NjMub25lIG5cbjs7XG5cbm1vZHVsZSBNYWtlIChNIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIHR5cGUgdCA9IEludDYzLnQgW0BAZGVyaXZpbmcgYmluX2lvLCBoYXNoLCB0eXBlcmVwXVxuXG4gIGxldCBvZl9pbnQgPSBJbnQ2My5vZl9pbnRcbiAgbGV0IHRvX2ludF9leG4gPSBJbnQ2My50b19pbnRfZXhuXG4gIGxldCBlbXB0eSA9IEludDYzLnplcm9cbiAgbGV0IGlzX2VtcHR5IHQgPSB0ID0gZW1wdHlcbiAgbGV0ICggKyApIGEgYiA9IEludDYzLmJpdF9vciBhIGJcbiAgbGV0ICggLSApIGEgYiA9IEludDYzLmJpdF9hbmQgYSAoSW50NjMuYml0X25vdCBiKVxuICBsZXQgaW50ZXJzZWN0ID0gSW50NjMuYml0X2FuZFxuICBsZXQgYWxsID0gTGlzdC5mb2xkIE0ua25vd24gfmluaXQ6ZW1wdHkgfmY6KGZ1biBhY2MgKGZsYWcsIF8pIC0+IGFjYyArIGZsYWcpXG4gIGxldCBjb21wbGVtZW50IGEgPSBhbGwgLSBhXG4gIGxldCBpc19zdWJzZXQgdCB+b2ZfID0gSW50NjMuKCA9ICkgdCAoaW50ZXJzZWN0IHQgb2ZfKVxuICBsZXQgZG9faW50ZXJzZWN0IHQxIHQyID0gSW50NjMuKCA8PiApIChJbnQ2My5iaXRfYW5kIHQxIHQyKSBJbnQ2My56ZXJvXG4gIGxldCBhcmVfZGlzam9pbnQgdDEgdDIgPSBJbnQ2My4oID0gKSAoSW50NjMuYml0X2FuZCB0MSB0MikgSW50NjMuemVyb1xuXG4gIGxldCBlcnJvciBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgICBsZXQgZSA9IEVycm9yLmNyZWF0ZSBtZXNzYWdlIGEgc2V4cF9vZl9hIGluXG4gICAgaWYgTS5zaG91bGRfcHJpbnRfZXJyb3IgdGhlbiBlcHJpbnRmIFwiJXNcXG4lIVwiIChTZXhwLnRvX3N0cmluZ19odW0gKEVycm9yLnNleHBfb2ZfdCBlKSk7XG4gICAgRXJyb3IucmFpc2UgZVxuICA7O1xuXG4gIGxldCBrbm93biA9XG4gICAgaWYgTS5yZW1vdmVfemVyb19mbGFnc1xuICAgIHRoZW4gTGlzdC5maWx0ZXIgfmY6KGZ1biAobiwgXykgLT4gbm90IChJbnQ2My5lcXVhbCBuIEludDYzLnplcm8pKSBNLmtub3duXG4gICAgZWxzZSBNLmtub3duXG4gIDs7XG5cbiAgbGV0IGFueV9pbnRlcnNlY3RpbmcgZmxhZ3MgPVxuICAgIGxldCByZWMgbG9vcCBsIGFjYyA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gZmFsc2VcbiAgICAgIHwgKGZsYWcsIF8pIDo6IGwgLT4gaWYgZG9faW50ZXJzZWN0IGZsYWcgYWNjIHRoZW4gdHJ1ZSBlbHNlIGxvb3AgbCAoYWNjICsgZmxhZylcbiAgICBpblxuICAgIGxvb3AgZmxhZ3MgZW1wdHlcbiAgOztcblxuICBsZXQgKCkgPVxuICAgIGlmIG5vdCBNLmFsbG93X2ludGVyc2VjdGluZ1xuICAgIHRoZW5cbiAgICAgIGlmIGFueV9pbnRlcnNlY3Rpbmcga25vd25cbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgcmVjIGNoZWNrIGwgYWMgPVxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gYWNcbiAgICAgICAgICB8IChmbGFnLCBuYW1lKSA6OiBsIC0+XG4gICAgICAgICAgICBsZXQgYmFkID0gTGlzdC5maWx0ZXIgbCB+ZjooZnVuIChmbGFnJywgXykgLT4gZG9faW50ZXJzZWN0IGZsYWcgZmxhZycpIGluXG4gICAgICAgICAgICBsZXQgYWMgPSBpZiBMaXN0LmlzX2VtcHR5IGJhZCB0aGVuIGFjIGVsc2UgKGZsYWcsIG5hbWUsIGJhZCkgOjogYWMgaW5cbiAgICAgICAgICAgIGNoZWNrIGwgYWNcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGJhZCA9IGNoZWNrIGtub3duIFtdIGluXG4gICAgICAgIGFzc2VydCAobm90IChMaXN0LmlzX2VtcHR5IGJhZCkpO1xuICAgICAgICBlcnJvclxuICAgICAgICAgIFwiRmxhZ3MuTWFrZSBnb3QgaW50ZXJzZWN0aW5nIGZsYWdzXCJcbiAgICAgICAgICBiYWRcbiAgICAgICAgICBbJXNleHBfb2Y6IChJbnQ2My50ICogc3RyaW5nICogKEludDYzLnQgKiBzdHJpbmcpIGxpc3QpIGxpc3RdKVxuICA7O1xuXG4gIGxldCAoKSA9XG4gICAgbGV0IGJhZCA9IExpc3QuZmlsdGVyIGtub3duIH5mOihmdW4gKGZsYWcsIF8pIC0+IGZsYWcgPSBJbnQ2My56ZXJvKSBpblxuICAgIGlmIG5vdCAoTGlzdC5pc19lbXB0eSBiYWQpXG4gICAgdGhlblxuICAgICAgZXJyb3IgXCJGbGFnLk1ha2UgZ290IGZsYWdzIHdpdGggbm8gYml0cyBzZXRcIiBiYWQgWyVzZXhwX29mOiAoSW50NjMudCAqIHN0cmluZykgbGlzdF1cbiAgOztcblxuICB0eXBlIHNleHBfZm9ybWF0ID0gc3RyaW5nIGxpc3QgW0BAZGVyaXZpbmcgc2V4cF1cblxuICB0eXBlIHNleHBfZm9ybWF0X3dpdGhfdW5yZWNvZ25pemVkX2JpdHMgPSBzdHJpbmcgbGlzdCAqIFsgYHVucmVjb2duaXplZF9iaXRzIG9mIHN0cmluZyBdXG4gIFtAQGRlcml2aW5nIHNleHBdXG5cbiAgbGV0IHRvX2ZsYWdfbGlzdCA9XG4gICAgKCogV2UgcmV2ZXJzZSBba25vd25dIHNvIHRoYXQgdGhlIGZvbGQgYmVsb3cgYWNjdW11bGF0ZXMgZnJvbSByaWdodCB0byBsZWZ0LCBnaXZpbmcgYVxuICAgICAgIGZpbmFsIGxpc3Qgd2l0aCBlbGVtZW50cyBpbiB0aGUgc2FtZSBvcmRlciBhcyBba25vd25dLiAqKVxuICAgIGxldCBrbm93biA9IExpc3QucmV2IGtub3duIGluXG4gICAgZnVuIHQgLT5cbiAgICAgIExpc3QuZm9sZCBrbm93biB+aW5pdDoodCwgW10pIH5mOihmdW4gKHQsIGZsYWdfbmFtZXMpIChmbGFnLCBmbGFnX25hbWUpIC0+XG4gICAgICAgIGlmIEludDYzLmJpdF9hbmQgdCBmbGFnID0gZmxhZ1xuICAgICAgICB0aGVuIHQgLSBmbGFnLCBmbGFnX25hbWUgOjogZmxhZ19uYW1lc1xuICAgICAgICBlbHNlIHQsIGZsYWdfbmFtZXMpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICBsZXQgdG9fdW5zaWduZWRfaGV4X3N0cmluZyB4ID1cbiAgICAgIEludDY0LihtYXhfdmFsdWUgbGFuZCBJbnQ2My50b19pbnQ2NCB4KSB8PiBJbnQ2NC5IZXgudG9fc3RyaW5nXG4gICAgaW5cbiAgICBsZXQgbGVmdG92ZXIsIGZsYWdfbmFtZXMgPSB0b19mbGFnX2xpc3QgdCBpblxuICAgIGlmIGxlZnRvdmVyID0gZW1wdHlcbiAgICB0aGVuIFslc2V4cF9vZjogc2V4cF9mb3JtYXRdIGZsYWdfbmFtZXNcbiAgICBlbHNlXG4gICAgICBbJXNleHBfb2Y6IHNleHBfZm9ybWF0X3dpdGhfdW5yZWNvZ25pemVkX2JpdHNdXG4gICAgICAgIChmbGFnX25hbWVzLCBgdW5yZWNvZ25pemVkX2JpdHMgKHRvX3Vuc2lnbmVkX2hleF9zdHJpbmcgbGVmdG92ZXIpKVxuICA7O1xuXG4gIGxldCBrbm93bl9ieV9uYW1lID1cbiAgICBTdHJpbmcuVGFibGUub2ZfYWxpc3RfZXhuIChMaXN0Lm1hcCBrbm93biB+ZjooZnVuIChtYXNrLCBuYW1lKSAtPiBuYW1lLCBtYXNrKSlcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIChzZXhwIDogU2V4cC50KSA9XG4gICAgbGV0IG9mX3Vuc2lnbmVkX2hleF9zdHJpbmcgcyA9IEludDY0LkhleC5vZl9zdHJpbmcgcyB8PiBJbnQ2My5vZl9pbnQ2NF90cnVuYyBpblxuICAgIGxldCByZXN0b3JlX2ludF9vZl9mbGFnc19zZXhwIGZsYWdzID1cbiAgICAgIExpc3QuZm9sZFxuICAgICAgICAoZmxhZ3MgfD4gWyVvZl9zZXhwOiBzZXhwX2Zvcm1hdF0pXG4gICAgICAgIH5pbml0OmVtcHR5XG4gICAgICAgIH5mOihmdW4gdCBuYW1lIC0+XG4gICAgICAgICAgbWF0Y2ggSGFzaHRibC5maW5kIGtub3duX2J5X25hbWUgbmFtZSB3aXRoXG4gICAgICAgICAgfCBTb21lIG1hc2sgLT4gdCArIG1hc2tcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgIG9mX3NleHBfZXJyb3IgKHNwcmludGYgXCJGbGFncy50X29mX3NleHAgZ290IHVua25vd24gbmFtZTogJXNcIiBuYW1lKSBzZXhwKVxuICAgIGluXG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBTZXhwLkxpc3QgWyBTZXhwLkxpc3QgZmxhZ3M7IFNleHAuTGlzdCB1bnJlY29nbml6ZWQgXSAtPlxuICAgICAgKG1hdGNoIHVucmVjb2duaXplZCB3aXRoXG4gICAgICAgfCBbIFNleHAuQXRvbSBcInVucmVjb2duaXplZF9iaXRzXCI7IFNleHAuQXRvbSBudW0gXSAtPlxuICAgICAgICAgcmVzdG9yZV9pbnRfb2ZfZmxhZ3Nfc2V4cCAoU2V4cC5MaXN0IGZsYWdzKSArIG9mX3Vuc2lnbmVkX2hleF9zdHJpbmcgbnVtXG4gICAgICAgfCBfIC0+XG4gICAgICAgICByYWlzZV9zXG4gICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgIFwiT2Zfc2V4cF9lcnJvcjogc2V4cCBmb3JtYXQgZG9lcyBub3QgbWF0Y2ggYW55IHJlY29nbml6ZWQgZm9ybWF0XCJcbiAgICAgICAgICAgICAgIChzZXhwIDogU2V4cC50KV0pXG4gICAgfCBTZXhwLkxpc3QgZmxhZ3MgLT4gcmVzdG9yZV9pbnRfb2ZfZmxhZ3Nfc2V4cCAoU2V4cC5MaXN0IGZsYWdzKVxuICAgIHwgU2V4cC5BdG9tIF8gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJPZl9zZXhwX2Vycm9yOiBsaXN0IG5lZWRlZFwiIChzZXhwIDogU2V4cC50KV1cbiAgOztcblxuICAoKiB0b3RhbCBvcmRlciBzdWNoIHRoYXQgW3N1YnNldCBhIGJdIGltcGxpZXMgW2EgPD0gYl0gKilcbiAgbGV0IGNvbXBhcmUgdCB1ID1cbiAgICAoKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHt8IEludDYzLihpIGJpdF94b3IgKG9uZSBzaGlmdF9sZWZ0IDYyKSkgfH0gKilcbiAgICBsZXQgZmxpcF90b3BfYml0IGkgPSBJbnQ2My4oICsgKSBpIEludDYzLm1pbl92YWx1ZSBpblxuICAgIEludDYzLmNvbXBhcmUgKGZsaXBfdG9wX2JpdCB0KSAoZmxpcF90b3BfYml0IHUpXG4gIDs7XG5cbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0IFtAQGRlcml2aW5nIHNleHAsIGNvbXBhcmUsIGhhc2hdXG4gIGVuZClcblxuICAoKiBbQ29tcGFyYWJsZS5NYWtlXSB0dXJucyBbZXF1YWxdIGludG8gYSBmdW5jdGlvbiBjYWxsIHRvIFtjb21wYXJlXSByYXRoZXIgdGhhbiB0aGVcbiAgICAgbXVjaCBzaW1wbGVyIChhbmQgZXF1YWxseSBjb3JyZWN0KSBbSW50NjMuKD0pXS4gUmVzdG9yZSBpdCwgYXMgd2VsbCBhcyAoPSkgYW5kICg8PikuICopXG4gIGxldCBlcXVhbCA9IEludDYzLiggPSApXG4gIGxldCAoID0gKSA9IEludDYzLiggPSApXG4gIGxldCAoIDw+ICkgPSBJbnQ2My4oIDw+IClcblxuICBtb2R1bGUgVW5zdGFibGUgPSBzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdCBbQEBkZXJpdmluZyBiaW5faW8sIGNvbXBhcmUsIGVxdWFsLCBzZXhwXVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZV9iaW5hYmxlID0gTWFrZVxuIl19
