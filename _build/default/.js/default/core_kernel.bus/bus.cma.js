// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Bus
//# unitInfo: Requires: Base__Backtrace, Base__Invariant, Core, Core__Array, Core__Error, Core__Gc, Core__Info, Core__Int, Core__List, Core__Option, Core__Option_array, Core__Sexp, Core__Source_code_position, Core__Unique_id, Inline_test_config, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Arity1 = "Arity1",
    cst_Arity2 = "Arity2",
    cst_Arity3 = "Arity3",
    cst_Arity4 = "Arity4",
    cst_Arity5 = "Arity5",
    cst_Bus$0 = "Bus",
    cst$0 = "_",
    cst_backtrace = "backtrace",
    cst_bus$0 = "bus",
    cst_bus_src_bus_ml$1 = "bus/src/bus.ml",
    cst_exn = "exn",
    cst_subscribed_from = "subscribed_from",
    cst_subscribers$0 = "subscribers",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos$0 = "bus/src/bus.ml:866:21",
    pos = "bus/src/bus.ml:865:21",
    all = [0, 0, [0, 1, [0, 2, 0]]],
    cst = "",
    Core_Error = global_data.Core__Error,
    Core = global_data.Core,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Inline_test_config = global_data.Inline_test_config,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Sexp = global_data.Core__Sexp,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Core_Option_array = global_data.Core__Option_array,
    Core_Int = global_data.Core__Int,
    Base_Backtrace = global_data.Base__Backtrace,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Core_Option = global_data.Core__Option,
    Base_Invariant = global_data.Base__Invariant,
    Core_Array = global_data.Core__Array,
    Core_Info = global_data.Core__Info,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Core_Unique_id = global_data.Core__Unique_id;
   caml_call1(Ppx_module_timer_runtime[4], cst_Bus$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_bus$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_bus_src_bus_ml$1);
   caml_call2(Ppx_inline_test_lib[6], cst_bus$0, "bus.ml");
   var
    _aB_ = [0, cst_bus_src_bus_ml$1, 880, 26388, 26412],
    _aC_ = [0, cst_bus_src_bus_ml$1, 881, 26430, 26454],
    _aD_ = [0, cst_bus_src_bus_ml$1, 882, 26472, 26496],
    _aE_ = [0, cst_bus_src_bus_ml$1, 883, 26514, 26538],
    _aF_ = [0, cst_bus_src_bus_ml$1, 884, 26556, 26580],
    _aA_ = [0, cst_bus_src_bus_ml$1, 859, 25410, 25444],
    cst_bus_src_bus_ml = cst_bus_src_bus_ml$1,
    cst_write_doesn_t_allocate_whe = "write doesn't allocate when inlined",
    _ax_ = [0, cst$0],
    _aw_ = [0, cst$0],
    cst_Bus_fold_exn_called_after_ = "Bus.fold_exn called after first write",
    _ay_ = [0, cst_bus_src_bus_ml$1, 841, 24790, 24810],
    _ar_ = [0, cst_Arity1],
    _as_ = [0, cst_Arity2],
    _at_ = [0, cst_Arity3],
    _au_ = [0, cst_Arity4],
    _av_ = [0, cst_Arity5],
    _ap_ = [0, cst$0],
    _ao_ = [0, cst$0],
    cst_Bus_iter_exn_called_after_ = "Bus.iter_exn called after first write",
    _aq_ = [0, cst_bus_src_bus_ml$1, 811, 23923, 23943],
    _ak_ = [0, cst$0],
    _aj_ = [0, cst$0],
    _al_ = [0, cst_bus$0],
    _am_ = [0, cst_subscribed_from],
    cst_Bus_subscribe_exn_called_a =
      "Bus.subscribe_exn called after first write",
    _an_ = [0, cst_bus_src_bus_ml$1, 767, 22321, 22333],
    _ac_ = [0, "original_error"],
    _ad_ = [0, cst_backtrace],
    _ae_ = [0, cst_exn],
    cst_Bus_subscriber_s_on_callba =
      "Bus subscriber's [on_callback_raise] raised",
    _af_ = [0, cst$0],
    _ag_ = [0, "subscriber"],
    _ah_ = [0, cst_backtrace],
    _ai_ = [0, cst_exn],
    cst_Bus_subscriber_raised = "Bus subscriber raised",
    _ab_ = [0, cst_bus_src_bus_ml$1, 439, 19],
    _aa_ = [0, cst_bus_src_bus_ml$1, 425, 2],
    _Z_ = [0, cst$0],
    _Y_ = [0, cst$0],
    _W_ = [0, cst$0],
    _V_ = [0, cst$0],
    cst_Bus_write_called_on_closed = "[Bus.write] called on closed bus",
    _X_ = [0, cst_bus_src_bus_ml$1, 349, 9833, 9853],
    cst_Bus_write_called_from_call =
      "[Bus.write] called from callback on the same bus",
    ___ = [0, cst_bus_src_bus_ml$1, 352, 9958, 9970],
    _$_ = [0, cst_bus_src_bus_ml$1, 356, 19],
    _T_ = [0, cst$0],
    _S_ = [0, cst$0],
    _R_ = [0, cst_bus_src_bus_ml$1, 313, 54],
    _P_ = [0, cst_bus_src_bus_ml$1, 326, 15],
    _Q_ = [0, cst_bus_src_bus_ml$1, 327, 18],
    _O_ = [0, cst_bus_src_bus_ml$1, 305, 11],
    _N_ = [0, cst_bus_src_bus_ml$1, 309, 18],
    _U_ = [0, cst_bus_src_bus_ml$1, 298, 8050, 8072],
    _K_ = [0, cst$0],
    _E_ = [0, cst$0],
    _F_ = [0, cst_subscribers$0],
    _G_ = [0, "write_ever_called"],
    _H_ = [0, "state"],
    _I_ = [0, "on_subscription_after_first_write"],
    _J_ = [0, "created_from"],
    _L_ = [0, "callback_arity"],
    _M_ = [0, "name"],
    _w_ = [0, cst$0],
    _x_ = [0, cst_bus_src_bus_ml$1, 209, 5637, 5661],
    _q_ = [0, 1],
    _r_ = [0, cst_subscribed_from],
    _s_ = [0, "extract_exn"],
    _t_ = [0, "on_callback_raise"],
    _u_ = [0, "subscribers_index"],
    _v_ = [0, "Bus.Subscriber.t"],
    _l_ = [0, "Allow"],
    _m_ = [0, "Allow_and_send_last_value"],
    _n_ = [0, "Raise"],
    _j_ = [0, cst$0],
    _k_ = [0, "arity"],
    cst_Cannot_save_last_value_whe =
      "Cannot save last value when using local args",
    _d_ = [0, cst_Arity1],
    _e_ = [0, "Arity1_local"],
    _f_ = [0, cst_Arity2],
    _g_ = [0, cst_Arity3],
    _h_ = [0, cst_Arity4],
    _i_ = [0, cst_Arity5],
    _a_ = [0, "Closed"],
    _b_ = [0, "Write_in_progress"],
    _c_ = [0, "Ok_to_write"],
    cst_callback = "callback",
    cst_callbacks = "callbacks",
    cst_subscribers = cst_subscribers$0,
    cst_num_subscribers = "num_subscribers",
    cst_bus_src_bus_ml$0 = cst_bus_src_bus_ml$1,
    cst_bus = cst_bus$0,
    cst_Bus = cst_Bus$0;
   function sexp_of_t(of_a_002, param){
    switch(param){
      case 0:
       return _d_;
      case 1:
       return _e_;
      case 2:
       return _f_;
      case 3:
       return _g_;
      case 4:
       return _h_;
      default: return _i_;
    }
   }
   function sexp_of_t$0(param){
    switch(param){case 0: return _l_;case 1: return _m_;default: return _n_;
    }
   }
   var Bus_id = caml_call1(Core_Unique_id[2], 0);
   function callback(r){return r[2];}
   function _o_(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6], r[7]];}
   var
    _p_ = 0,
    callback$0 =
      [0, function(param){return 0;}, cst_callback, _p_, callback, _o_];
   function sexp_of_t$1(param, _ck_){
    var
     extract_exn = _ck_[3],
     subscribers_index = _ck_[4],
     subscribed_from = _ck_[7],
     on_callback_raise = _ck_[5],
     _cl_ = 0,
     match = Ppx_inline_test_lib[1] ? 0 : [0, subscribers_index],
     match$0 = extract_exn ? _q_ : 0,
     match$1 =
       [0,
        [1,
         [0,
          _r_,
          [0, caml_call1(Core_Source_code_position[1], subscribed_from), 0]]],
        0];
    if(match$0)
     var
      v = match$0[1],
      match$2 = [0, [1, [0, _s_, [0, caml_call1(Core[323], v), 0]]], match$1];
    else
     var match$2 = match$1;
    if(on_callback_raise)
     var
      _cm_ = 0,
      _cn_ = function(_cp_){return 0;},
      match$3 =
        [0,
         [1, [0, _t_, [0, caml_call1(Sexplib0_Sexp_conv[24], _cn_), _cm_]]],
         match$2];
    else
     var match$3 = match$2;
    if(match)
     var
      v$0 = match[1],
      res = [0, [1, [0, _u_, [0, caml_call1(Core[389], v$0), 0]]], match$3];
    else
     var res = match$3;
    if(res[2]) var _co_ = [1, res]; else var h = res[1], _co_ = h;
    return [1, [0, _v_, [0, _co_, _cl_]]];
   }
   function callbacks(r){return r[12];}
   function set_callbacks(r, v){r[12] = v; return 0;}
   function subscribers(r){return r[11];}
   function set_subscribers(r, v){r[11] = v; return 0;}
   function num_subscribers(r){return r[10];}
   function set_num_subscribers(r, v){r[10] = v; return 0;}
   function callback_arity(r){return r[3];}
   function _y_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            v,
            r[13]];
   }
   var
    _z_ = [0, set_callbacks],
    callbacks$0 =
      [0, function(param){return 0;}, cst_callbacks, _z_, callbacks, _y_];
   function _A_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            v,
            r[12],
            r[13]];
   }
   var
    _B_ = [0, set_subscribers],
    subscribers$0 =
      [0, function(param){return 0;}, cst_subscribers, _B_, subscribers, _A_];
   function _C_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            v,
            r[11],
            r[12],
            r[13]];
   }
   var
    _D_ = [0, set_num_subscribers],
    num_subscribers$0 =
      [0,
       function(param){return 0;},
       cst_num_subscribers,
       _D_,
       num_subscribers,
       _C_];
   function sexp_of_bus(param, _b8_, _b7_){
    var
     on_subscription_after_first_wr = _b7_[5],
     created_from = _b7_[4],
     callback_arity = _b7_[3],
     name = _b7_[2],
     state = _b7_[8],
     write_ever_called = _b7_[9],
     num_subscribers = _b7_[10],
     subscribers = _b7_[11];
    function _b9_(i){
     return caml_call2(Core_Option_array[44], subscribers, i);
    }
    var
     subscribers$0 = caml_call2(Core_Array[56], num_subscribers, _b9_),
     _b__ = 0,
     _b$_ = 0;
    function _ca_(param){return _E_;}
    function _cb_(_cj_){return sexp_of_t$1(_ca_, _cj_);}
    var
     _cc_ =
       [0,
        [1,
         [0, _F_, [0, caml_call2(Core_Array[20], _cb_, subscribers$0), _b$_]]],
        _b__],
     _cd_ =
       [0,
        [1, [0, _G_, [0, caml_call1(Core[323], write_ever_called), 0]]],
        _cc_],
     _ce_ = 0;
    switch(state){
      case 0:
       var _cf_ = _a_; break;
      case 1:
       var _cf_ = _b_; break;
      default: var _cf_ = _c_;
    }
    var
     _cg_ =
       [0,
        [1, [0, _I_, [0, sexp_of_t$0(on_subscription_after_first_wr), 0]]],
        [0, [1, [0, _H_, [0, _cf_, _ce_]]], _cd_]],
     _ch_ =
       [0,
        [1,
         [0,
          _J_,
          [0, caml_call1(Core_Source_code_position[1], created_from), 0]]],
        _cg_],
     _ci_ = 0,
     match =
       [0,
        [1,
         [0,
          _L_,
          [0, sexp_of_t(function(param){return _K_;}, callback_arity), _ci_]]],
        _ch_];
    if(name)
     var
      v = name[1],
      res = [0, [1, [0, _M_, [0, caml_call1(Core_Info[9], v), 0]]], match];
    else
     var res = match;
    if(res[2]) return [1, res];
    var h = res[1];
    return h;
   }
   function read_only(t){return t;}
   function invariant(invariant_a, param, t){
    function _bU_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      callbacks_fun =
        check
         (function(callbacks){
           var
            _b2_ = caml_call1(Core_Option_array[36], t[11]),
            _b3_ = caml_call1(Core_Option_array[36], callbacks);
           if(! caml_call2(Core[90], _b3_, _b2_))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
           var
            _b5_ = caml_call1(Core_Option_array[36], callbacks) - 1 | 0,
            _b4_ = 0;
           if(_b5_ >= 0){
            var i = _b4_;
            for(;;){
             if(caml_call2(Core[92], i, t[10]))
              caml_call1
               (invariant_a, caml_call2(Core_Option_array[44], callbacks, i));
             else if(! caml_call2(Core_Option_array[45], callbacks, i))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _N_], 1);
             var _b6_ = i + 1 | 0;
             if(_b5_ === i) break;
             var i = _b6_;
            }
           }
           return 0;
          }),
      subscribers_fun =
        check
         (function(subscribers){
           var
            _b0_ = caml_call1(Core_Option_array[36], subscribers) - 1 | 0,
            _bZ_ = 0;
           if(_b0_ >= 0){
            var i = _bZ_;
            for(;;){
             if(caml_call2(Core[92], i, t[10])){
              var
               subscriber = caml_call2(Core_Option_array[44], subscribers, i),
               _bX_ =
                 function(subscriber){
                   return function(param){
                    var
                     callback_fun =
                       caml_call2(Base_Invariant[2], subscriber, invariant_a);
                    caml_call1(callback_fun, callback$0);
                    return 0;};
                  }
                  (subscriber),
               _bY_ =
                 function(x_005){
                  return sexp_of_t$1(function(param){return _w_;}, x_005);
                 };
              caml_call4(Base_Invariant[1], _x_, subscriber, _bY_, _bX_);
              if(! caml_call2(Core[90], i, subscriber[4]))
               throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
             }
             else if(! caml_call2(Core_Option_array[45], subscribers, i))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _Q_], 1);
             var _b1_ = i + 1 | 0;
             if(_b0_ === i) break;
             var i = _b1_;
            }
           }
           return 0;
          }),
      num_subscribers_fun =
        check
         (function(num_subscribers){
           if(caml_call2(Core[88], num_subscribers, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _R_], 1);
          });
     caml_call1(num_subscribers_fun, num_subscribers$0);
     caml_call1(subscribers_fun, subscribers$0);
     caml_call1(callbacks_fun, callbacks$0);
     return 0;
    }
    function _bV_(x_011){
     function _bW_(param){return _S_;}
     return sexp_of_bus(function(param){return _T_;}, _bW_, x_011);
    }
    return caml_call4(Base_Invariant[1], _U_, t, _bV_, _bU_);
   }
   function is_closed(t){
    switch(t[8]){case 0: return 1;case 1: return 0;default: return 0;
    }
   }
   function sexp_of_t$2(of_callback_012, x_013){
    return sexp_of_bus(of_callback_012, Core[212], x_013);
   }
   function invariant$0(invariant_a, t){
    return invariant(invariant_a, function(_bT_){return 0;}, t);
   }
   var Read_write = [0, sexp_of_t$2, invariant$0];
   function sexp_of_t$3(of_callback_014, x_015){
    return sexp_of_bus(of_callback_014, Core[171], x_015);
   }
   function invariant$1(invariant_a, t){
    return invariant(invariant_a, function(_bS_){return 0;}, t);
   }
   var Read_only = [0, sexp_of_t$3, invariant$1];
   function start_write_failing(t){
    switch(t[8]){
      case 0:
       var
        _bO_ =
          function(x_016){
           function _bR_(param){return _V_;}
           return sexp_of_bus(function(param){return _W_;}, _bR_, x_016);
          };
       return caml_call5
               (Core[247], 0, _X_, cst_Bus_write_called_on_closed, t, _bO_);
      case 1:
       var
        _bP_ =
          function(x_017){
           function _bQ_(param){return _Y_;}
           return sexp_of_bus(function(param){return _Z_;}, _bQ_, x_017);
          };
       return caml_call5
               (Core[247], 0, ___, cst_Bus_write_called_from_call, t, _bP_);
      default: throw caml_maybe_attach_backtrace([0, Assert_failure, _$_], 1);
    }
   }
   function capacity(t){return caml_call1(Core_Option_array[36], t[11]);}
   function maybe_shrink_capacity(t){
    var _bL_ = capacity(t), _bM_ = caml_call2(Core[89], t[10] * 4 | 0, _bL_);
    if(_bM_){
     var
      desired_capacity = t[10],
      copy_and_shrink =
        function(array){
         var new_array = caml_call1(Core_Option_array[13], desired_capacity);
         caml_call5(Core_Option_array[61], array, 0, new_array, 0, t[10]);
         return new_array;
        };
     t[11] = copy_and_shrink(t[11]);
     t[12] = copy_and_shrink(t[12]);
     var _bN_ = 0;
    }
    else
     var _bN_ = _bM_;
    return _bN_;
   }
   function add_subscriber(t, subscriber, at_subscribers_index){
    subscriber[4] = at_subscribers_index;
    caml_call3(Core_Option_array[52], t[11], at_subscribers_index, subscriber);
    return caml_call3
            (Core_Option_array[52],
             t[12],
             at_subscribers_index,
             subscriber[2]);
   }
   function remove_subscriber(t, subscriber){
    var subscribers_index = subscriber[4];
    subscriber[4] = -1;
    caml_call2(Core_Option_array[53], t[11], subscribers_index);
    return caml_call2(Core_Option_array[53], t[12], subscribers_index);
   }
   function unsubscribe_assuming_valid_sub(t, subscriber){
    var
     subscriber_index = subscriber[4],
     last_subscriber_index = t[10] - 1 | 0;
    remove_subscriber(t, subscriber);
    if(caml_call2(Core[92], subscriber_index, last_subscriber_index)){
     var
      last_subscriber =
        caml_call2(Core_Option_array[44], t[11], last_subscriber_index);
     remove_subscriber(t, last_subscriber);
     add_subscriber(t, last_subscriber, subscriber_index);
    }
    t[10] = t[10] - 1 | 0;
    return maybe_shrink_capacity(t);
   }
   function unsubscribe(t, subscriber){
    var
     to = t[1],
     _bJ_ = caml_call2(Core[88], subscriber[4], 0),
     _bK_ = _bJ_ ? caml_call2(Bus_id[19], subscriber[1], to) : _bJ_;
    if(_bK_)
     switch(t[8]){
       case 0:
        return 0;
       case 1:
        t[13] = [0, subscriber, t[13]]; return 0;
       default: return unsubscribe_assuming_valid_sub(t, subscriber);
     }
    return _bK_;
   }
   function unsubscribe_all(t){
    if(! is_closed(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aa_], 1);
    var _bG_ = t[10] - 1 | 0, _bF_ = 0;
    if(_bG_ >= 0){
     var i = _bF_;
     for(;;){
      var
       subscriber = caml_call2(Core_Option_array[44], t[11], i),
       _bH_ = function(on_close){return caml_call1(on_close, 0);};
      caml_call2(Core_Option[46], subscriber[6], _bH_);
      remove_subscriber(t, subscriber);
      var _bI_ = i + 1 | 0;
      if(_bG_ === i) break;
      var i = _bI_;
     }
    }
    t[10] = 0;
    return maybe_shrink_capacity(t);
   }
   function finish_write(t){
    if(1 - caml_call1(Core_List[18], t[13])){
     var
      _bD_ = function(_bE_){return unsubscribe_assuming_valid_sub(t, _bE_);};
     caml_call2(Core_List[19], t[13], _bD_);
     t[13] = 0;
    }
    switch(t[8]){
      case 0:
       return unsubscribe_all(t);
      case 1:
       t[8] = 2; return 0;
      default:
       throw caml_maybe_attach_backtrace([0, Assert_failure, _ab_], 1);
    }
   }
   function close(t){
    switch(t[8]){
      case 0:
       return 0;
      case 1:
       t[8] = 0; return 0;
      default: t[8] = 0; return unsubscribe_all(t);
    }
   }
   function call_on_callback_raise(t, error){
    try{caml_call1(t[6], error); return;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     close(t);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function callback_raised(t, i, exn){
    var subscriber = caml_call2(Core_Option_array[44], t[11], i - 1 | 0);
    if(subscriber[3])
     var error = caml_call2(Core_Error[27], 0, exn);
    else
     var
      backtrace$0 = caml_call1(Base_Backtrace[6][4], 0),
      _bx_ = 0,
      _by_ = 0,
      _bz_ =
        [0,
         [1,
          [0,
           _ag_,
           [0, sexp_of_t$1(function(param){return _af_;}, subscriber), _by_]]],
         _bx_],
      _bA_ =
        [0,
         [1, [0, _ah_, [0, caml_call1(Base_Backtrace[1], backtrace$0), 0]]],
         _bz_],
      _bB_ = [0, [1, [0, _ai_, [0, caml_call1(Core[625], exn), 0]]], _bA_],
      _bC_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Bus_subscriber_raised),
          _bB_]],
      error = caml_call1(Core_Error[8], _bC_);
    var match = subscriber[5];
    if(! match) return call_on_callback_raise(t, error);
    var f = match[1];
    try{caml_call1(f, error); return;}
    catch(exn){
     var
      exn$0 = caml_wrap_exception(exn),
      backtrace = caml_call1(Base_Backtrace[6][4], 0),
      _bt_ = [0, [1, [0, _ac_, [0, caml_call1(Core_Error[9], error), 0]]], 0],
      _bu_ =
        [0,
         [1, [0, _ad_, [0, caml_call1(Base_Backtrace[1], backtrace), 0]]],
         _bt_],
      _bv_ = [0, [1, [0, _ae_, [0, caml_call1(Core[625], exn$0), 0]]], _bu_],
      _bw_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Bus_subscriber_s_on_callba),
          _bv_]];
     return call_on_callback_raise(t, caml_call1(Core_Error[8], _bw_));
    }
   }
   function unsafe_get_callback(a, i){
    return caml_call2(Core_Option_array[49], a, i);
   }
   function write(t, a1){
    var callbacks = t[12];
    t[9] = 1;
    if(2 > t[8]) return start_write_failing(t);
    var match = t[7];
    if(match){
     var last_value = match[1], _br_ = last_value[1];
     if(_br_) _br_[1][1] = a1; else last_value[1] = [0, [0, a1]];
    }
    var _bs_ = caml_call2(Core[91], t[10], 0);
    if(! _bs_) return _bs_;
    t[8] = 1;
    if(caml_call2(Core[90], t[10], 1)){
     try{caml_call1(unsafe_get_callback(callbacks, 0), a1);}
     catch(exn){
      var exn$0 = caml_wrap_exception(exn);
      callback_raised(t, 1, exn$0);
     }
     return finish_write(t);
    }
    var len = t[10], i = [0, 0];
    for(;;){
     if(! caml_call2(Core[92], i[1], len)) return finish_write(t);
     try{
      var callback = unsafe_get_callback(callbacks, i[1]);
      i[1]++;
      caml_call1(callback, a1);
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      callback_raised(t, i[1], exn);
      continue;
     }
    }
   }
   function write_local(t, a1){
    var callbacks = t[12];
    t[9] = 1;
    if(2 > t[8]) return start_write_failing(t);
    var _bq_ = caml_call2(Core[91], t[10], 0);
    if(! _bq_) return _bq_;
    t[8] = 1;
    if(caml_call2(Core[90], t[10], 1)){
     try{caml_call1(unsafe_get_callback(callbacks, 0), a1);}
     catch(exn){
      var exn$0 = caml_wrap_exception(exn);
      callback_raised(t, 1, exn$0);
     }
     return finish_write(t);
    }
    var len = t[10], i = [0, 0];
    for(;;){
     if(! caml_call2(Core[92], i[1], len)) return finish_write(t);
     try{
      var callback = unsafe_get_callback(callbacks, i[1]);
      i[1]++;
      caml_call1(callback, a1);
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      callback_raised(t, i[1], exn);
      continue;
     }
    }
   }
   function write2(t, a1, a2){
    var callbacks = t[12];
    t[9] = 1;
    if(2 > t[8]) return start_write_failing(t);
    var match$0 = t[7];
    if(match$0){
     var last_value = match$0[1], _bo_ = last_value[1];
     if(_bo_){
      var match = _bo_[1];
      match[1] = a1;
      match[2] = a2;
     }
     else
      last_value[1] = [0, [1, a1, a2]];
    }
    var _bp_ = caml_call2(Core[91], t[10], 0);
    if(! _bp_) return _bp_;
    t[8] = 1;
    if(caml_call2(Core[90], t[10], 1)){
     try{caml_call2(unsafe_get_callback(callbacks, 0), a1, a2);}
     catch(exn){
      var exn$0 = caml_wrap_exception(exn);
      callback_raised(t, 1, exn$0);
     }
     return finish_write(t);
    }
    var len = t[10], i = [0, 0];
    for(;;){
     if(! caml_call2(Core[92], i[1], len)) return finish_write(t);
     try{
      var callback = unsafe_get_callback(callbacks, i[1]);
      i[1]++;
      caml_call2(callback, a1, a2);
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      callback_raised(t, i[1], exn);
      continue;
     }
    }
   }
   function write3(t, a1, a2, a3){
    var callbacks = t[12];
    t[9] = 1;
    if(2 > t[8]) return start_write_failing(t);
    var match$0 = t[7];
    if(match$0){
     var last_value = match$0[1], _bm_ = last_value[1];
     if(_bm_){
      var match = _bm_[1];
      match[1] = a1;
      match[2] = a2;
      match[3] = a3;
     }
     else
      last_value[1] = [0, [2, a1, a2, a3]];
    }
    var _bn_ = caml_call2(Core[91], t[10], 0);
    if(! _bn_) return _bn_;
    t[8] = 1;
    if(caml_call2(Core[90], t[10], 1)){
     try{caml_call3(unsafe_get_callback(callbacks, 0), a1, a2, a3);}
     catch(exn){
      var exn$0 = caml_wrap_exception(exn);
      callback_raised(t, 1, exn$0);
     }
     return finish_write(t);
    }
    var len = t[10], i = [0, 0];
    for(;;){
     if(! caml_call2(Core[92], i[1], len)) return finish_write(t);
     try{
      var callback = unsafe_get_callback(callbacks, i[1]);
      i[1]++;
      caml_call3(callback, a1, a2, a3);
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      callback_raised(t, i[1], exn);
      continue;
     }
    }
   }
   function write4(t, a1, a2, a3, a4){
    var callbacks = t[12];
    t[9] = 1;
    if(2 > t[8]) return start_write_failing(t);
    var match$0 = t[7];
    if(match$0){
     var last_value = match$0[1], _bk_ = last_value[1];
     if(_bk_){
      var match = _bk_[1];
      match[1] = a1;
      match[2] = a2;
      match[3] = a3;
      match[4] = a4;
     }
     else
      last_value[1] = [0, [3, a1, a2, a3, a4]];
    }
    var _bl_ = caml_call2(Core[91], t[10], 0);
    if(! _bl_) return _bl_;
    t[8] = 1;
    if(caml_call2(Core[90], t[10], 1)){
     try{caml_call4(unsafe_get_callback(callbacks, 0), a1, a2, a3, a4);}
     catch(exn){
      var exn$0 = caml_wrap_exception(exn);
      callback_raised(t, 1, exn$0);
     }
     return finish_write(t);
    }
    var len = t[10], i = [0, 0];
    for(;;){
     if(! caml_call2(Core[92], i[1], len)) return finish_write(t);
     try{
      var callback = unsafe_get_callback(callbacks, i[1]);
      i[1]++;
      caml_call4(callback, a1, a2, a3, a4);
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      callback_raised(t, i[1], exn);
      continue;
     }
    }
   }
   function write5(t, arg1, arg2, arg3, arg4, arg5){
    var callbacks = t[12];
    t[9] = 1;
    if(2 > t[8]) return start_write_failing(t);
    var match$0 = t[7];
    if(match$0){
     var last_value = match$0[1], _bi_ = last_value[1];
     if(_bi_){
      var match = _bi_[1];
      match[1] = arg1;
      match[2] = arg2;
      match[3] = arg3;
      match[4] = arg4;
      match[5] = arg5;
     }
     else
      last_value[1] = [0, [4, arg1, arg2, arg3, arg4, arg5]];
    }
    var _bj_ = caml_call2(Core[91], t[10], 0);
    if(! _bj_) return _bj_;
    t[8] = 1;
    if(caml_call2(Core[90], t[10], 1)){
     try{
      caml_call5
       (unsafe_get_callback(callbacks, 0), arg1, arg2, arg3, arg4, arg5);
     }
     catch(exn){
      var exn$0 = caml_wrap_exception(exn);
      callback_raised(t, 1, exn$0);
     }
     return finish_write(t);
    }
    var len = t[10], i = [0, 0];
    for(;;){
     if(! caml_call2(Core[92], i[1], len)) return finish_write(t);
     try{
      var callback = unsafe_get_callback(callbacks, i[1]);
      i[1]++;
      caml_call5(callback, arg1, arg2, arg3, arg4, arg5);
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      callback_raised(t, i[1], exn);
      continue;
     }
    }
   }
   function create_exn
   (name,
    created_from,
    callback_arity,
    on_subscription_after_first_wr,
    on_callback_raise){
    switch(on_subscription_after_first_wr){
      case 0:
       var last_value = 0; break;
      case 1:
       switch(callback_arity){
         case 0:
          var _bb_ = 0; break;
         case 1:
          var _bb_ = 1; break;
         case 2:
          var _bb_ = 0; break;
         case 3:
          var _bb_ = 0; break;
         case 4:
          var _bb_ = 0; break;
         default: var _bb_ = 0;
       }
       if(_bb_){
        var
         _bc_ = 0,
         _bd_ = 0,
         _be_ =
           [0,
            [1,
             [0,
              _k_,
              [0,
               sexp_of_t(function(param){return _j_;}, callback_arity),
               _bd_]]],
            _bc_],
         _bf_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_Cannot_save_last_value_whe),
             _be_]];
        caml_call1(Core[261], _bf_);
       }
       var last_value = [0, [0, 0]];
       break;
      default: var last_value = 0;
    }
    var
     _bg_ = caml_call1(Core_Option_array[13], 0),
     _bh_ = caml_call1(Core_Option_array[13], 0);
    return [0,
            caml_call1(Bus_id[45], 0),
            name,
            callback_arity,
            created_from,
            on_subscription_after_first_wr,
            on_callback_raise,
            last_value,
            2,
            0,
            0,
            _bh_,
            _bg_,
            0];
   }
   function can_subscribe(t){
    switch(t[5]){
      case 0:
       var _a$_ = 1; break;
      case 1:
       var _a$_ = 1; break;
      default: var _a$_ = 0;
    }
    var _ba_ = _a$_ || 1 - t[9];
    return _ba_;
   }
   function subscribe_exn
   (opt, on_callback_raise, on_close, x_019, subscribed_from, callback){
    if(opt) var sth = opt[1], extract_exn = sth; else var extract_exn = 0;
    if(1 - can_subscribe(x_019)){
     var
      _a2_ = Core_Sexp[93],
      _a3_ = 0,
      _a4_ = 0,
      _a5_ = 0,
      _a6_ = function(param){return _aj_;},
      _a7_ =
        [0,
         [1,
          [0,
           [1,
            [0,
             _al_,
             [0,
              sexp_of_bus(function(param){return _ak_;}, _a6_, x_019),
              _a5_]]],
           _a4_]],
         _a3_],
      _a8_ =
        [1,
         [0,
          [1,
           [0,
            _am_,
            [0, caml_call1(Core_Source_code_position[1], subscribed_from), 0]]],
          _a7_]];
     caml_call5
      (Core[247], 0, _an_, cst_Bus_subscribe_exn_called_a, _a8_, _a2_);
    }
    if(! x_019[8])
     return [0,
             x_019[1],
             callback,
             extract_exn,
             -1,
             on_callback_raise,
             on_close,
             subscribed_from];
    var
     subscriber =
       [0,
        x_019[1],
        callback,
        extract_exn,
        x_019[10],
        on_callback_raise,
        on_close,
        subscribed_from],
     _a9_ = x_019[10],
     _a__ = capacity(x_019);
    if(caml_call2(Core[90], _a__, _a9_)){
     var
      capacity$0 = capacity(x_019),
      new_capacity = caml_call2(Core_Int[90], 1, capacity$0 * 2 | 0),
      copy_and_double =
        function(array){
         var new_array = caml_call1(Core_Option_array[13], new_capacity);
         caml_call5(Core_Option_array[61], array, 0, new_array, 0, capacity$0);
         return new_array;
        };
     x_019[11] = copy_and_double(x_019[11]);
     x_019[12] = copy_and_double(x_019[12]);
    }
    add_subscriber(x_019, subscriber, x_019[10]);
    x_019[10] = x_019[10] + 1 | 0;
    var match$0 = x_019[7];
    if(match$0){
     var last_value = match$0[1], _a1_ = last_value[1];
     if(_a1_){
      var match = _a1_[1];
      switch(match[0]){
        case 0:
         var arg1 = match[1]; caml_call1(callback, arg1); break;
        case 1:
         var arg1$0 = match[1], arg2 = match[2];
         caml_call2(callback, arg1$0, arg2);
         break;
        case 2:
         var arg1$1 = match[1], arg2$0 = match[2], arg3 = match[3];
         caml_call3(callback, arg1$1, arg2$0, arg3);
         break;
        case 3:
         var
          arg1$2 = match[1],
          arg2$1 = match[2],
          arg3$0 = match[3],
          arg4 = match[4];
         caml_call4(callback, arg1$2, arg2$1, arg3$0, arg4);
         break;
        default:
         var
          arg1$3 = match[1],
          arg2$2 = match[2],
          arg3$1 = match[3],
          arg4$0 = match[4],
          arg5 = match[5];
         caml_call5(callback, arg1$3, arg2$2, arg3$1, arg4$0, arg5);
      }
     }
    }
    return subscriber;
   }
   function iter_exn(extract_exn, t, subscribed_from, f){
    if(1 - can_subscribe(t)){
     var
      _aZ_ =
        function(x_020){
         function _a0_(param){return _ao_;}
         return sexp_of_bus(function(param){return _ap_;}, _a0_, x_020);
        };
     caml_call5(Core[247], 0, _aq_, cst_Bus_iter_exn_called_after_, t, _aZ_);
    }
    subscribe_exn(extract_exn, 0, 0, t, subscribed_from, f);
    return 0;
   }
   function sexp_of_t$4(of_a_024, of_b_025, of_c_026, param){
    switch(param){
      case 0:
       return _ar_;
      case 1:
       return _as_;
      case 2:
       return _at_;
      case 3:
       return _au_;
      default: return _av_;
    }
   }
   var Fold_arity = [0, sexp_of_t$4];
   function fold_exn(extract_exn, t, subscribed_from, fold_arity, init, f){
    var state = [0, init];
    if(1 - can_subscribe(t)){
     var
      _aW_ =
        function(x_030){
         function _aY_(param){return _aw_;}
         return sexp_of_bus(function(param){return _ax_;}, _aY_, x_030);
        };
     caml_call5(Core[247], 0, _ay_, cst_Bus_fold_exn_called_after_, t, _aW_);
    }
    switch(fold_arity){
      case 0:
       var
        _aX_ = function(a1){state[1] = caml_call2(f, state[1], a1); return 0;};
       break;
      case 1:
       var
        _aX_ =
          function(a1, a2){
           state[1] = caml_call3(f, state[1], a1, a2);
           return 0;
          };
       break;
      case 2:
       var
        _aX_ =
          function(a1, a2, a3){
           state[1] = caml_call4(f, state[1], a1, a2, a3);
           return 0;
          };
       break;
      case 3:
       var
        _aX_ =
          function(a1, a2, a3, a4){
           state[1] = caml_call5(f, state[1], a1, a2, a3, a4);
           return 0;
          };
       break;
      default:
       var
        _aX_ =
          function(a1, a2, a3, a4, a5){
           state[1] = caml_call6(f, state[1], a1, a2, a3, a4, a5);
           return 0;
          };
    }
    return iter_exn(extract_exn, t, subscribed_from, _aX_);
   }
   function _az_(param){
    function assert_no_allocation(bus_r, callback, write){
     subscribe_exn(0, 0, 0, bus_r, _aA_, callback);
     var
      starting_minor_words = runtime.core_gc_minor_words(0),
      starting_major_words = runtime.core_gc_major_words(0);
     caml_call1(write, 0);
     var
      ending_minor_words = runtime.core_gc_minor_words(0),
      ending_major_words = runtime.core_gc_major_words(0),
      got = ending_minor_words - starting_minor_words | 0,
      sexpifier = Core[389],
      expect = 0,
      equal = 0,
      message = 0,
      here = 0;
     function comparator(a_031, b_032){
      return caml_call2(Core[382], a_031, b_032);
     }
     caml_call8
      (Ppx_assert_lib_Runtime[3],
       pos,
       sexpifier,
       comparator,
       here,
       message,
       equal,
       expect,
       got);
     var
      got$0 = ending_major_words - starting_major_words | 0,
      sexpifier$0 = Core[389],
      expect$0 = 0,
      equal$0 = 0,
      message$0 = 0,
      here$0 = 0;
     function comparator$0(a_033, b_034){
      return caml_call2(Core[382], a_033, b_034);
     }
     return caml_call8
             (Ppx_assert_lib_Runtime[3],
              pos$0,
              sexpifier$0,
              comparator$0,
              here$0,
              message$0,
              equal$0,
              expect$0,
              got$0);
    }
    function _aG_(param){
     function create(created_from, arity){
      return create_exn(0, created_from, arity, 2, Core_Error[30]);
     }
     var
      bus1 = create(_aB_, 0),
      bus2 = create(_aC_, 2),
      bus3 = create(_aD_, 3),
      bus4 = create(_aE_, 4),
      bus5 = create(_aF_, 5);
     function _aH_(param){return write(bus1, 0);}
     assert_no_allocation(bus1, function(param){return 0;}, _aH_);
     function _aI_(param){return write2(bus2, 0, 0);}
     assert_no_allocation(bus2, function(param, _aV_){return 0;}, _aI_);
     function _aJ_(param){return write3(bus3, 0, 0, 0);}
     assert_no_allocation(bus3, function(param, _aU_, _aT_){return 0;}, _aJ_);
     function _aK_(param){return write4(bus4, 0, 0, 0, 0);}
     assert_no_allocation
      (bus4, function(param, _aS_, _aR_, _aQ_){return 0;}, _aK_);
     function _aL_(param){return write5(bus5, 0, 0, 0, 0, 0);}
     assert_no_allocation
      (bus5, function(param, _aP_, _aO_, _aN_, _aM_){return 0;}, _aL_);
     return 0;
    }
    caml_call8
     (Ppx_inline_test_lib[9],
      Inline_test_config,
      cst_write_doesn_t_allocate_whe,
      0,
      cst_bus_src_bus_ml,
      872,
      4,
      945,
      _aG_);
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib[10],
     Inline_test_config,
     cst,
     0,
     cst_bus_src_bus_ml$0,
     855,
     0,
     1803,
     _az_);
   caml_call1(Ppx_inline_test_lib[7], cst_bus);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Bus);
   var
    Bus =
      [0,
       [0, sexp_of_t],
       sexp_of_bus,
       Read_write,
       Read_only,
       [0, all, sexp_of_t$0],
       read_only,
       create_exn,
       callback_arity,
       num_subscribers,
       is_closed,
       close,
       write,
       write_local,
       write2,
       write3,
       write4,
       write5,
       [0, sexp_of_t$1],
       subscribe_exn,
       iter_exn,
       Fold_arity,
       fold_exn,
       unsubscribe];
   runtime.caml_register_global(140, Bus, cst_Bus$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJidXMuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInBvcyQwIiwicG9zIiwiYWxsIiwic2V4cF9vZl90Iiwic2V4cF9vZl90JDAiLCJjYWxsYmFjayIsInIiLCJ2IiwiY2FsbGJhY2skMCIsInNleHBfb2ZfdCQxIiwiZXh0cmFjdF9leG4iLCJzdWJzY3JpYmVyc19pbmRleCIsInN1YnNjcmliZWRfZnJvbSIsIm9uX2NhbGxiYWNrX3JhaXNlIiwibWF0Y2gkMSIsIm1hdGNoJDIiLCJtYXRjaCQzIiwidiQwIiwicmVzIiwiaCIsImNhbGxiYWNrcyIsInNldF9jYWxsYmFja3MiLCJzdWJzY3JpYmVycyIsInNldF9zdWJzY3JpYmVycyIsIm51bV9zdWJzY3JpYmVycyIsInNldF9udW1fc3Vic2NyaWJlcnMiLCJjYWxsYmFja19hcml0eSIsImNhbGxiYWNrcyQwIiwic3Vic2NyaWJlcnMkMCIsIm51bV9zdWJzY3JpYmVycyQwIiwic2V4cF9vZl9idXMiLCJvbl9zdWJzY3JpcHRpb25fYWZ0ZXJfZmlyc3Rfd3IiLCJjcmVhdGVkX2Zyb20iLCJuYW1lIiwic3RhdGUiLCJ3cml0ZV9ldmVyX2NhbGxlZCIsImkiLCJtYXRjaCIsInJlYWRfb25seSIsInQiLCJpbnZhcmlhbnQiLCJpbnZhcmlhbnRfYSIsImNoZWNrIiwiZiIsImNhbGxiYWNrc19mdW4iLCJzdWJzY3JpYmVyc19mdW4iLCJzdWJzY3JpYmVyIiwiY2FsbGJhY2tfZnVuIiwieF8wMDUiLCJudW1fc3Vic2NyaWJlcnNfZnVuIiwieF8wMTEiLCJpc19jbG9zZWQiLCJzZXhwX29mX3QkMiIsIm9mX2NhbGxiYWNrXzAxMiIsInhfMDEzIiwiaW52YXJpYW50JDAiLCJzZXhwX29mX3QkMyIsIm9mX2NhbGxiYWNrXzAxNCIsInhfMDE1IiwiaW52YXJpYW50JDEiLCJzdGFydF93cml0ZV9mYWlsaW5nIiwieF8wMTYiLCJ4XzAxNyIsImNhcGFjaXR5IiwibWF5YmVfc2hyaW5rX2NhcGFjaXR5IiwiZGVzaXJlZF9jYXBhY2l0eSIsImNvcHlfYW5kX3NocmluayIsImFycmF5IiwibmV3X2FycmF5IiwiYWRkX3N1YnNjcmliZXIiLCJhdF9zdWJzY3JpYmVyc19pbmRleCIsInJlbW92ZV9zdWJzY3JpYmVyIiwidW5zdWJzY3JpYmVfYXNzdW1pbmdfdmFsaWRfc3ViIiwic3Vic2NyaWJlcl9pbmRleCIsImxhc3Rfc3Vic2NyaWJlcl9pbmRleCIsImxhc3Rfc3Vic2NyaWJlciIsInVuc3Vic2NyaWJlIiwidG8iLCJ1bnN1YnNjcmliZV9hbGwiLCJvbl9jbG9zZSIsImZpbmlzaF93cml0ZSIsImNsb3NlIiwiY2FsbF9vbl9jYWxsYmFja19yYWlzZSIsImVycm9yIiwiZXhuJDAiLCJleG4iLCJjYWxsYmFja19yYWlzZWQiLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSIsInVuc2FmZV9nZXRfY2FsbGJhY2siLCJhIiwid3JpdGUiLCJhMSIsImxhc3RfdmFsdWUiLCJsZW4iLCJ3cml0ZV9sb2NhbCIsIndyaXRlMiIsImEyIiwid3JpdGUzIiwiYTMiLCJ3cml0ZTQiLCJhNCIsIndyaXRlNSIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFyZzQiLCJhcmc1IiwiY3JlYXRlX2V4biIsImNhbl9zdWJzY3JpYmUiLCJzdWJzY3JpYmVfZXhuIiwib3B0IiwieF8wMTkiLCJzdGgiLCJjYXBhY2l0eSQwIiwibmV3X2NhcGFjaXR5IiwiY29weV9hbmRfZG91YmxlIiwiYXJnMSQwIiwiYXJnMSQxIiwiYXJnMiQwIiwiYXJnMSQyIiwiYXJnMiQxIiwiYXJnMyQwIiwiYXJnMSQzIiwiYXJnMiQyIiwiYXJnMyQxIiwiYXJnNCQwIiwiaXRlcl9leG4iLCJ4XzAyMCIsInNleHBfb2ZfdCQ0IiwiZm9sZF9leG4iLCJmb2xkX2FyaXR5IiwiaW5pdCIsInhfMDMwIiwiYTUiLCJhc3NlcnRfbm9fYWxsb2NhdGlvbiIsImJ1c19yIiwic3RhcnRpbmdfbWlub3Jfd29yZHMiLCJzdGFydGluZ19tYWpvcl93b3JkcyIsImVuZGluZ19taW5vcl93b3JkcyIsImVuZGluZ19tYWpvcl93b3JkcyIsImdvdCIsInNleHBpZmllciIsImV4cGVjdCIsImVxdWFsIiwibWVzc2FnZSIsImhlcmUiLCJjb21wYXJhdG9yIiwiYV8wMzEiLCJiXzAzMiIsImdvdCQwIiwic2V4cGlmaWVyJDAiLCJleHBlY3QkMCIsImVxdWFsJDAiLCJtZXNzYWdlJDAiLCJoZXJlJDAiLCJjb21wYXJhdG9yJDAiLCJhXzAzMyIsImJfMDM0IiwiY3JlYXRlIiwiYXJpdHkiLCJidXMxIiwiYnVzMiIsImJ1czMiLCJidXM0IiwiYnVzNSJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2NvcmVfa2VybmVsL2J1cy9idXMubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7SUFpMkJxQkE7SUFEQUM7SUFqdEJuQkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E5SEEsU0FBQUM7SUFBQTs7T0FDRTs7T0FDQTs7T0FDQTs7T0FDQTs7T0FDQTtlQUNBOztHQUNrQjtZQXVIcEJDO0lBQUEsc0JBQ0UsbUJBQ0Esb0JBQ0E7O0dBQzZCOztZQXFCM0JDLFNBQUFDLEdBQUEsT0FBQUEsS0FBUTtnQkFBUkEsR0FBQUMsR0FBQSxXQUFBRCxNQUFBQyxHQUFBRCxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFRO0dBQVI7O0lBQUFFOzBCQUFBLFNBQVEsc0JBQVJIO1lBYUFJOztLQUlBQztLQUNBQztLQUdBQztLQUZBQzs7OENBREFGO2VBREFEO0tBV0lJOzs7Ozt1REFQSkY7Ozs7TUFPSUw7TUFBQVEscURBQUFSLFVBQUFPOztTQUFBQyxVQUFBRDtPQVRKRDs7OzRC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QUc7T0F4YUF0RDs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBDb3JlXG5cbm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQ2xvc2VkXG4gICAgfCBXcml0ZV9pbl9wcm9ncmVzc1xuICAgIHwgT2tfdG9fd3JpdGVcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaXNfY2xvc2VkID0gZnVuY3Rpb25cbiAgICB8IENsb3NlZCAtPiB0cnVlXG4gICAgfCBXcml0ZV9pbl9wcm9ncmVzcyAtPiBmYWxzZVxuICAgIHwgT2tfdG9fd3JpdGUgLT4gZmFsc2VcbiAgOztcbmVuZFxuXG5tb2R1bGUgQ2FsbGJhY2tfYXJpdHkgPSBzdHJ1Y3RcbiAgdHlwZSBfIHQgPVxuICAgIHwgQXJpdHkxIDogKCdhIC0+IHVuaXQpIHRcbiAgICB8IEFyaXR5MV9sb2NhbCA6ICgnYSAtPiB1bml0KSB0XG4gICAgfCBBcml0eTIgOiAoJ2EgLT4gJ2IgLT4gdW5pdCkgdFxuICAgIHwgQXJpdHkzIDogKCdhIC0+ICdiIC0+ICdjIC0+IHVuaXQpIHRcbiAgICB8IEFyaXR5NCA6ICgnYSAtPiAnYiAtPiAnYyAtPiAnZCAtPiB1bml0KSB0XG4gICAgfCBBcml0eTUgOiAoJ2EgLT4gJ2IgLT4gJ2MgLT4gJ2QgLT4gJ2UgLT4gdW5pdCkgdFxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCB1c2VzX2xvY2FsX2FyZ3MgOiB0eXBlIGEuIGEgdCAtPiBib29sID0gZnVuY3Rpb25cbiAgICB8IEFyaXR5MSAtPiBmYWxzZVxuICAgIHwgQXJpdHkxX2xvY2FsIC0+IHRydWVcbiAgICB8IEFyaXR5MiAtPiBmYWxzZVxuICAgIHwgQXJpdHkzIC0+IGZhbHNlXG4gICAgfCBBcml0eTQgLT4gZmFsc2VcbiAgICB8IEFyaXR5NSAtPiBmYWxzZVxuICA7O1xuZW5kXG5cbm1vZHVsZSBMYXN0X3ZhbHVlIDogc2lnXG4gIHR5cGUgJ2NhbGxiYWNrIHRcblxuICB2YWwgY3JlYXRlX2V4biA6ICdjYWxsYmFjayBDYWxsYmFja19hcml0eS50IC0+ICdjYWxsYmFjayB0XG4gIHZhbCBzZXQxIDogKCdhIC0+IHVuaXQpIHQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgc2V0MiA6ICgnYSAtPiAnYiAtPiB1bml0KSB0IC0+ICdhIC0+ICdiIC0+IHVuaXRcbiAgdmFsIHNldDMgOiAoJ2EgLT4gJ2IgLT4gJ2MgLT4gdW5pdCkgdCAtPiAnYSAtPiAnYiAtPiAnYyAtPiB1bml0XG4gIHZhbCBzZXQ0IDogKCdhIC0+ICdiIC0+ICdjIC0+ICdkIC0+IHVuaXQpIHQgLT4gJ2EgLT4gJ2IgLT4gJ2MgLT4gJ2QgLT4gdW5pdFxuICB2YWwgc2V0NSA6ICgnYSAtPiAnYiAtPiAnYyAtPiAnZCAtPiAnZSAtPiB1bml0KSB0IC0+ICdhIC0+ICdiIC0+ICdjIC0+ICdkIC0+ICdlIC0+IHVuaXRcbiAgdmFsIHNlbmQgOiAnY2FsbGJhY2sgdCAtPiAnY2FsbGJhY2sgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgXyB0dXBsZSA9XG4gICAgfCBUdXBsZTEgOiB7IG11dGFibGUgYXJnMSA6ICdhIH0gLT4gKCdhIC0+IHVuaXQpIHR1cGxlXG4gICAgfCBUdXBsZTIgOlxuICAgICAgICB7IG11dGFibGUgYXJnMSA6ICdhXG4gICAgICAgIDsgbXV0YWJsZSBhcmcyIDogJ2JcbiAgICAgICAgfVxuICAgICAgICAtPiAoJ2EgLT4gJ2IgLT4gdW5pdCkgdHVwbGVcbiAgICB8IFR1cGxlMyA6XG4gICAgICAgIHsgbXV0YWJsZSBhcmcxIDogJ2FcbiAgICAgICAgOyBtdXRhYmxlIGFyZzIgOiAnYlxuICAgICAgICA7IG11dGFibGUgYXJnMyA6ICdjXG4gICAgICAgIH1cbiAgICAgICAgLT4gKCdhIC0+ICdiIC0+ICdjIC0+IHVuaXQpIHR1cGxlXG4gICAgfCBUdXBsZTQgOlxuICAgICAgICB7IG11dGFibGUgYXJnMSA6ICdhXG4gICAgICAgIDsgbXV0YWJsZSBhcmcyIDogJ2JcbiAgICAgICAgOyBtdXRhYmxlIGFyZzMgOiAnY1xuICAgICAgICA7IG11dGFibGUgYXJnNCA6ICdkXG4gICAgICAgIH1cbiAgICAgICAgLT4gKCdhIC0+ICdiIC0+ICdjIC0+ICdkIC0+IHVuaXQpIHR1cGxlXG4gICAgfCBUdXBsZTUgOlxuICAgICAgICB7IG11dGFibGUgYXJnMSA6ICdhXG4gICAgICAgIDsgbXV0YWJsZSBhcmcyIDogJ2JcbiAgICAgICAgOyBtdXRhYmxlIGFyZzMgOiAnY1xuICAgICAgICA7IG11dGFibGUgYXJnNCA6ICdkXG4gICAgICAgIDsgbXV0YWJsZSBhcmc1IDogJ2VcbiAgICAgICAgfVxuICAgICAgICAtPiAoJ2EgLT4gJ2IgLT4gJ2MgLT4gJ2QgLT4gJ2UgLT4gdW5pdCkgdHVwbGVcblxuICB0eXBlICdjYWxsYmFjayB0ID0gJ2NhbGxiYWNrIHR1cGxlIG9wdGlvbiByZWZcblxuICBsZXQgY3JlYXRlX2V4biAodHlwZSBjYWxsYmFjaykgKGFyaXR5IDogY2FsbGJhY2sgQ2FsbGJhY2tfYXJpdHkudCkgOiBjYWxsYmFjayB0ID1cbiAgICBpZiBDYWxsYmFja19hcml0eS51c2VzX2xvY2FsX2FyZ3MgYXJpdHlcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiQ2Fubm90IHNhdmUgbGFzdCB2YWx1ZSB3aGVuIHVzaW5nIGxvY2FsIGFyZ3NcIiAoYXJpdHkgOiBfIENhbGxiYWNrX2FyaXR5LnQpXTtcbiAgICByZWYgTm9uZVxuICA7O1xuXG4gIGxldCBzZXQxIHQgYSA9XG4gICAgbWF0Y2ggIXQgd2l0aFxuICAgIHwgTm9uZSAtPiB0IDo9IFNvbWUgKFR1cGxlMSB7IGFyZzEgPSBhIH0pXG4gICAgfCBTb21lIChUdXBsZTEgYXJncykgLT4gYXJncy5hcmcxIDwtIGFcbiAgOztcblxuICBsZXQgc2V0MiB0IGEgYiA9XG4gICAgbWF0Y2ggIXQgd2l0aFxuICAgIHwgTm9uZSAtPiB0IDo9IFNvbWUgKFR1cGxlMiB7IGFyZzEgPSBhOyBhcmcyID0gYiB9KVxuICAgIHwgU29tZSAoVHVwbGUyIGFyZ3MpIC0+XG4gICAgICBhcmdzLmFyZzEgPC0gYTtcbiAgICAgIGFyZ3MuYXJnMiA8LSBiXG4gIDs7XG5cbiAgbGV0IHNldDMgdCBhIGIgYyA9XG4gICAgbWF0Y2ggIXQgd2l0aFxuICAgIHwgTm9uZSAtPiB0IDo9IFNvbWUgKFR1cGxlMyB7IGFyZzEgPSBhOyBhcmcyID0gYjsgYXJnMyA9IGMgfSlcbiAgICB8IFNvbWUgKFR1cGxlMyBhcmdzKSAtPlxuICAgICAgYXJncy5hcmcxIDwtIGE7XG4gICAgICBhcmdzLmFyZzIgPC0gYjtcbiAgICAgIGFyZ3MuYXJnMyA8LSBjXG4gIDs7XG5cbiAgbGV0IHNldDQgdCBhIGIgYyBkID1cbiAgICBtYXRjaCAhdCB3aXRoXG4gICAgfCBOb25lIC0+IHQgOj0gU29tZSAoVHVwbGU0IHsgYXJnMSA9IGE7IGFyZzIgPSBiOyBhcmczID0gYzsgYXJnNCA9IGQgfSlcbiAgICB8IFNvbWUgKFR1cGxlNCBhcmdzKSAtPlxuICAgICAgYXJncy5hcmcxIDwtIGE7XG4gICAgICBhcmdzLmFyZzIgPC0gYjtcbiAgICAgIGFyZ3MuYXJnMyA8LSBjO1xuICAgICAgYXJncy5hcmc0IDwtIGRcbiAgOztcblxuICBsZXQgc2V0NSB0IGFyZzEgYXJnMiBhcmczIGFyZzQgYXJnNSA9XG4gICAgbWF0Y2ggIXQgd2l0aFxuICAgIHwgTm9uZSAtPiB0IDo9IFNvbWUgKFR1cGxlNSB7IGFyZzE7IGFyZzI7IGFyZzM7IGFyZzQ7IGFyZzUgfSlcbiAgICB8IFNvbWUgKFR1cGxlNSBhcmdzKSAtPlxuICAgICAgYXJncy5hcmcxIDwtIGFyZzE7XG4gICAgICBhcmdzLmFyZzIgPC0gYXJnMjtcbiAgICAgIGFyZ3MuYXJnMyA8LSBhcmczO1xuICAgICAgYXJncy5hcmc0IDwtIGFyZzQ7XG4gICAgICBhcmdzLmFyZzUgPC0gYXJnNVxuICA7O1xuXG4gIGxldCBzZW5kICh0eXBlIGNhbGxiYWNrKSAodCA6IGNhbGxiYWNrIHQpIChjYWxsYmFjayA6IGNhbGxiYWNrKSA6IHVuaXQgPVxuICAgIG1hdGNoICF0IHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgKFR1cGxlMSB7IGFyZzEgfSkgLT4gY2FsbGJhY2sgYXJnMVxuICAgIHwgU29tZSAoVHVwbGUyIHsgYXJnMTsgYXJnMiB9KSAtPiBjYWxsYmFjayBhcmcxIGFyZzJcbiAgICB8IFNvbWUgKFR1cGxlMyB7IGFyZzE7IGFyZzI7IGFyZzMgfSkgLT4gY2FsbGJhY2sgYXJnMSBhcmcyIGFyZzNcbiAgICB8IFNvbWUgKFR1cGxlNCB7IGFyZzE7IGFyZzI7IGFyZzM7IGFyZzQgfSkgLT4gY2FsbGJhY2sgYXJnMSBhcmcyIGFyZzMgYXJnNFxuICAgIHwgU29tZSAoVHVwbGU1IHsgYXJnMTsgYXJnMjsgYXJnMzsgYXJnNDsgYXJnNSB9KSAtPiBjYWxsYmFjayBhcmcxIGFyZzIgYXJnMyBhcmc0IGFyZzVcbiAgOztcbmVuZFxuXG5tb2R1bGUgT25fc3Vic2NyaXB0aW9uX2FmdGVyX2ZpcnN0X3dyaXRlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBBbGxvd1xuICAgIHwgQWxsb3dfYW5kX3NlbmRfbGFzdF92YWx1ZVxuICAgIHwgUmFpc2VcbiAgW0BAZGVyaXZpbmcgZW51bWVyYXRlLCBzZXhwX29mXVxuXG4gIGxldCBhbGxvd19zdWJzY3JpcHRpb25fYWZ0ZXJfZmlyc3Rfd3JpdGUgPSBmdW5jdGlvblxuICAgIHwgQWxsb3cgLT4gdHJ1ZVxuICAgIHwgQWxsb3dfYW5kX3NlbmRfbGFzdF92YWx1ZSAtPiB0cnVlXG4gICAgfCBSYWlzZSAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBzYXZlX2xhc3RfdmFsdWVfZXhuIHQgY2FsbGJhY2tfYXJpdHkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgQWxsb3dfYW5kX3NlbmRfbGFzdF92YWx1ZSAtPiBTb21lIChMYXN0X3ZhbHVlLmNyZWF0ZV9leG4gY2FsbGJhY2tfYXJpdHkpXG4gICAgfCBBbGxvdyAtPiBOb25lXG4gICAgfCBSYWlzZSAtPiBOb25lXG4gIDs7XG5lbmRcblxubW9kdWxlIEJ1c19pZCA9IFVuaXF1ZV9pZC5JbnQ2MyAoKVxuXG5tb2R1bGUgU3Vic2NyaWJlciA9IHN0cnVjdFxuICB0eXBlICdjYWxsYmFjayB0ID1cbiAgICB7IGJ1c19pZCA6IEJ1c19pZC50XG4gICAgOyBjYWxsYmFjayA6ICdjYWxsYmFja1xuICAgIDsgZXh0cmFjdF9leG4gOiBib29sXG4gICAgOyAoKiBbc3Vic2NyaWJlcnNfaW5kZXhdIGlzIHRoZSBpbmRleCBvZiB0aGlzIHN1YnNjcmliZXIgaW4gdGhlIGJ1cydzIFtzdWJzY3JpYmVyc11cbiAgICAgICAgIGFycmF5LiAgWy0xXSBpbmRpY2F0ZXMgdGhhdCB0aGlzIHN1YnNjcmliZXIgaXMgbm90IHN1YnNjcmliZWQuICopXG4gICAgICBtdXRhYmxlIHN1YnNjcmliZXJzX2luZGV4IDogaW50XG4gICAgOyBvbl9jYWxsYmFja19yYWlzZSA6IChFcnJvci50IC0+IHVuaXQpIG9wdGlvblxuICAgIDsgb25fY2xvc2UgOiAodW5pdCAtPiB1bml0KSBvcHRpb25cbiAgICA7IHN1YnNjcmliZWRfZnJvbSA6IFNvdXJjZV9jb2RlX3Bvc2l0aW9uLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXJdXG5cbiAgbGV0IGlzX3N1YnNjcmliZWQgdCB+dG9fID0gdC5zdWJzY3JpYmVyc19pbmRleCA+PSAwICYmIEJ1c19pZC5lcXVhbCB0LmJ1c19pZCB0b19cblxuICBsZXQgc2V4cF9vZl90XG4gICAgX1xuICAgIHsgY2FsbGJhY2sgPSBfXG4gICAgOyBidXNfaWQgPSBfXG4gICAgOyBleHRyYWN0X2V4blxuICAgIDsgc3Vic2NyaWJlcnNfaW5kZXhcbiAgICA7IG9uX2NhbGxiYWNrX3JhaXNlXG4gICAgOyBvbl9jbG9zZSA9IF9cbiAgICA7IHN1YnNjcmliZWRfZnJvbVxuICAgIH1cbiAgICA6IFNleHAudFxuICAgID1cbiAgICBMaXN0XG4gICAgICBbIEF0b20gXCJCdXMuU3Vic2NyaWJlci50XCJcbiAgICAgIDsgWyVtZXNzYWdlXG4gICAgICAgICAgXCJcIlxuICAgICAgICAgICAgfnN1YnNjcmliZXJzX2luZGV4OlxuICAgICAgICAgICAgICAoaWYgUHB4X2lubGluZV90ZXN0X2xpYi5hbV9ydW5uaW5nIHRoZW4gTm9uZSBlbHNlIFNvbWUgc3Vic2NyaWJlcnNfaW5kZXhcbiAgICAgICAgICAgICAgICA6IChpbnQgb3B0aW9uW0BzZXhwLm9wdGlvbl0pKVxuICAgICAgICAgICAgKG9uX2NhbGxiYWNrX3JhaXNlIDogKChFcnJvci50IC0+IHVuaXQpIG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgICAgICAgIH5leHRyYWN0X2V4bjpcbiAgICAgICAgICAgICAgKGlmIGV4dHJhY3RfZXhuIHRoZW4gU29tZSB0cnVlIGVsc2UgTm9uZSA6IChib29sIG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgICAgICAgIChzdWJzY3JpYmVkX2Zyb20gOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50KV1cbiAgICAgIF1cbiAgOztcblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPVxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5idXNfaWQ6aWdub3JlXG4gICAgICAgIH5jYWxsYmFjazooY2hlY2sgaW52YXJpYW50X2EpXG4gICAgICAgIH5leHRyYWN0X2V4bjppZ25vcmVcbiAgICAgICAgfnN1YnNjcmliZXJzX2luZGV4Omlnbm9yZVxuICAgICAgICB+b25fY2FsbGJhY2tfcmFpc2U6aWdub3JlXG4gICAgICAgIH5vbl9jbG9zZTppZ25vcmVcbiAgICAgICAgfnN1YnNjcmliZWRfZnJvbTppZ25vcmUpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZVxuICAgIHN1YnNjcmliZWRfZnJvbVxuICAgIH5jYWxsYmFja1xuICAgIH5idXNfaWRcbiAgICB+ZXh0cmFjdF9leG5cbiAgICB+c3Vic2NyaWJlcnNfaW5kZXhcbiAgICB+b25fY2FsbGJhY2tfcmFpc2VcbiAgICB+b25fY2xvc2VcbiAgICA9XG4gICAgeyBidXNfaWRcbiAgICA7IGNhbGxiYWNrXG4gICAgOyBleHRyYWN0X2V4blxuICAgIDsgc3Vic2NyaWJlcnNfaW5kZXhcbiAgICA7IG9uX2NhbGxiYWNrX3JhaXNlXG4gICAgOyBvbl9jbG9zZVxuICAgIDsgc3Vic2NyaWJlZF9mcm9tXG4gICAgfVxuICA7O1xuZW5kXG5cbnR5cGUgKCdjYWxsYmFjaywgJ3BoYW50b20pIHQgPVxuICB7IGJ1c19pZCA6IEJ1c19pZC50XG4gIDsgbmFtZSA6IEluZm8udCBvcHRpb25cbiAgOyBjYWxsYmFja19hcml0eSA6ICdjYWxsYmFjayBDYWxsYmFja19hcml0eS50XG4gIDsgY3JlYXRlZF9mcm9tIDogU291cmNlX2NvZGVfcG9zaXRpb24udFxuICA7IG9uX3N1YnNjcmlwdGlvbl9hZnRlcl9maXJzdF93cml0ZSA6IE9uX3N1YnNjcmlwdGlvbl9hZnRlcl9maXJzdF93cml0ZS50XG4gIDsgb25fY2FsbGJhY2tfcmFpc2UgOiBFcnJvci50IC0+IHVuaXRcbiAgOyBsYXN0X3ZhbHVlIDogJ2NhbGxiYWNrIExhc3RfdmFsdWUudCBvcHRpb25cbiAgOyBtdXRhYmxlIHN0YXRlIDogU3RhdGUudFxuICA7IG11dGFibGUgd3JpdGVfZXZlcl9jYWxsZWQgOiBib29sXG4gIDsgbXV0YWJsZSBudW1fc3Vic2NyaWJlcnMgOiBpbnRcbiAgOyAoKiBbc3Vic2NyaWJlcnNdIGNvbnRhaW5zIGFsbCBzdWJzY3JpYmVycyB0byB0aGUgYnVzLCBpbiBhIGNvbnRpZ3VvdXMgcHJlZml4IGZyb21cbiAgICAgICBpbmRleCBbMF0gdG8gW251bV9zdWJzY3JpYmVycyAtIDFdLiAqKVxuICAgIG11dGFibGUgc3Vic2NyaWJlcnMgOiAnY2FsbGJhY2sgU3Vic2NyaWJlci50IE9wdGlvbl9hcnJheS50XG4gIDsgKCogW2NhbGxiYWNrc10gaG9sZHMgdGhlIGNhbGxiYWNrcyBvZiB0aGUgY29ycmVzcG9uZGluZyBlbnRyaWVzIG9mIFtzdWJzY3JpYmVyc10uICopXG4gICAgbXV0YWJsZSBjYWxsYmFja3MgOiAnY2FsbGJhY2sgT3B0aW9uX2FycmF5LnRcbiAgOyBtdXRhYmxlIHVuc3Vic2NyaWJlc19kdXJpbmdfd3JpdGUgOiAnY2FsbGJhY2sgU3Vic2NyaWJlci50IGxpc3RcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzIH5pdGVyYXRvcnM6aXRlcl1cblxubGV0IHNleHBfb2ZfdFxuICBfXG4gIF9cbiAgeyBidXNfaWQgPSBfXG4gIDsgY2FsbGJhY2tfYXJpdHlcbiAgOyBjYWxsYmFja3MgPSBfXG4gIDsgY3JlYXRlZF9mcm9tXG4gIDsgbGFzdF92YWx1ZSA9IF9cbiAgOyBuYW1lXG4gIDsgbnVtX3N1YnNjcmliZXJzXG4gIDsgb25fc3Vic2NyaXB0aW9uX2FmdGVyX2ZpcnN0X3dyaXRlXG4gIDsgb25fY2FsbGJhY2tfcmFpc2UgPSBfXG4gIDsgc3RhdGVcbiAgOyBzdWJzY3JpYmVyc1xuICA7IHdyaXRlX2V2ZXJfY2FsbGVkXG4gIDsgdW5zdWJzY3JpYmVzX2R1cmluZ193cml0ZSA9IF9cbiAgfVxuICA9XG4gIGxldCBzdWJzY3JpYmVycyA9XG4gICAgQXJyYXkuaW5pdCBudW1fc3Vic2NyaWJlcnMgfmY6KGZ1biBpIC0+IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gc3Vic2NyaWJlcnMgaSlcbiAgaW5cbiAgWyVtZXNzYWdlXG4gICAgXCJcIlxuICAgICAgKG5hbWUgOiAoSW5mby50IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgIChjYWxsYmFja19hcml0eSA6IF8gQ2FsbGJhY2tfYXJpdHkudClcbiAgICAgIChjcmVhdGVkX2Zyb20gOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50KVxuICAgICAgKG9uX3N1YnNjcmlwdGlvbl9hZnRlcl9maXJzdF93cml0ZSA6IE9uX3N1YnNjcmlwdGlvbl9hZnRlcl9maXJzdF93cml0ZS50KVxuICAgICAgKHN0YXRlIDogU3RhdGUudClcbiAgICAgICh3cml0ZV9ldmVyX2NhbGxlZCA6IGJvb2wpXG4gICAgICAoc3Vic2NyaWJlcnMgOiBfIFN1YnNjcmliZXIudCBBcnJheS50KV1cbjs7XG5cbnR5cGUgKCdjYWxsYmFjaywgJ3BoYW50b20pIGJ1cyA9ICgnY2FsbGJhY2ssICdwaGFudG9tKSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCByZWFkX29ubHkgdCA9ICh0IDo+IChfLCByZWFkKSB0KVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIF8gdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogKF8sIF8pIHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfmJ1c19pZDppZ25vcmVcbiAgICAgIH5uYW1lOmlnbm9yZVxuICAgICAgfmNhbGxiYWNrczpcbiAgICAgICAgKGNoZWNrIChmdW4gY2FsbGJhY2tzIC0+XG4gICAgICAgICAgIGFzc2VydCAoT3B0aW9uX2FycmF5Lmxlbmd0aCBjYWxsYmFja3MgPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuc3Vic2NyaWJlcnMpO1xuICAgICAgICAgICBmb3IgaSA9IDAgdG8gT3B0aW9uX2FycmF5Lmxlbmd0aCBjYWxsYmFja3MgLSAxIGRvXG4gICAgICAgICAgICAgaWYgaSA8IHQubnVtX3N1YnNjcmliZXJzXG4gICAgICAgICAgICAgdGhlbiBpbnZhcmlhbnRfYSAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biBjYWxsYmFja3MgaSlcbiAgICAgICAgICAgICBlbHNlIGFzc2VydCAoT3B0aW9uX2FycmF5LmlzX25vbmUgY2FsbGJhY2tzIGkpXG4gICAgICAgICAgIGRvbmUpKVxuICAgICAgfmNhbGxiYWNrX2FyaXR5Omlnbm9yZVxuICAgICAgfmNyZWF0ZWRfZnJvbTppZ25vcmVcbiAgICAgIH5udW1fc3Vic2NyaWJlcnM6KGNoZWNrIChmdW4gbnVtX3N1YnNjcmliZXJzIC0+IGFzc2VydCAobnVtX3N1YnNjcmliZXJzID49IDApKSlcbiAgICAgIH5vbl9zdWJzY3JpcHRpb25fYWZ0ZXJfZmlyc3Rfd3JpdGU6aWdub3JlXG4gICAgICB+b25fY2FsbGJhY2tfcmFpc2U6aWdub3JlXG4gICAgICB+bGFzdF92YWx1ZTppZ25vcmVcbiAgICAgIH5zdGF0ZTppZ25vcmVcbiAgICAgIH53cml0ZV9ldmVyX2NhbGxlZDppZ25vcmVcbiAgICAgIH5zdWJzY3JpYmVyczpcbiAgICAgICAgKGNoZWNrIChmdW4gc3Vic2NyaWJlcnMgLT5cbiAgICAgICAgICAgZm9yIGkgPSAwIHRvIE9wdGlvbl9hcnJheS5sZW5ndGggc3Vic2NyaWJlcnMgLSAxIGRvXG4gICAgICAgICAgICAgaWYgaSA8IHQubnVtX3N1YnNjcmliZXJzXG4gICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICBsZXQgc3Vic2NyaWJlciA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gc3Vic2NyaWJlcnMgaSBpblxuICAgICAgICAgICAgICAgU3Vic2NyaWJlci5pbnZhcmlhbnQgaW52YXJpYW50X2Egc3Vic2NyaWJlcjtcbiAgICAgICAgICAgICAgIGFzc2VydCAoaSA9IHN1YnNjcmliZXIuc3Vic2NyaWJlcnNfaW5kZXgpKVxuICAgICAgICAgICAgIGVsc2UgYXNzZXJ0IChPcHRpb25fYXJyYXkuaXNfbm9uZSBzdWJzY3JpYmVycyBpKVxuICAgICAgICAgICBkb25lKSlcbiAgICAgIH51bnN1YnNjcmliZXNfZHVyaW5nX3dyaXRlOmlnbm9yZSlcbjs7XG5cbmxldCBpc19jbG9zZWQgdCA9IFN0YXRlLmlzX2Nsb3NlZCB0LnN0YXRlXG5cbm1vZHVsZSBSZWFkX3dyaXRlID0gc3RydWN0XG4gIHR5cGUgJ2NhbGxiYWNrIHQgPSAoJ2NhbGxiYWNrLCByZWFkX3dyaXRlKSBidXMgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPSBpbnZhcmlhbnQgaW52YXJpYW50X2EgaWdub3JlIHRcbmVuZFxuXG5tb2R1bGUgUmVhZF9vbmx5ID0gc3RydWN0XG4gIHR5cGUgJ2NhbGxiYWNrIHQgPSAoJ2NhbGxiYWNrLCByZWFkKSBidXMgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPSBpbnZhcmlhbnQgaW52YXJpYW50X2EgaWdub3JlIHRcbmVuZFxuXG5sZXRbQGNvbGRdIHN0YXJ0X3dyaXRlX2ZhaWxpbmcgdCA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IENsb3NlZCAtPlxuICAgIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwiW0J1cy53cml0ZV0gY2FsbGVkIG9uIGNsb3NlZCBidXNcIiB0IFslc2V4cF9vZjogKF8sIF8pIHRdXG4gIHwgV3JpdGVfaW5fcHJvZ3Jlc3MgLT5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiW0J1cy53cml0ZV0gY2FsbGVkIGZyb20gY2FsbGJhY2sgb24gdGhlIHNhbWUgYnVzXCJcbiAgICAgIHRcbiAgICAgIFslc2V4cF9vZjogKF8sIF8pIHRdXG4gIHwgT2tfdG9fd3JpdGUgLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG5sZXQgY2FwYWNpdHkgdCA9IE9wdGlvbl9hcnJheS5sZW5ndGggdC5zdWJzY3JpYmVyc1xuXG5sZXQgbWF5YmVfc2hyaW5rX2NhcGFjaXR5IHQgPVxuICBpZiB0Lm51bV9zdWJzY3JpYmVycyAqIDQgPD0gY2FwYWNpdHkgdFxuICB0aGVuIChcbiAgICBsZXQgZGVzaXJlZF9jYXBhY2l0eSA9IHQubnVtX3N1YnNjcmliZXJzIGluXG4gICAgbGV0IGNvcHlfYW5kX3NocmluayBhcnJheSA9XG4gICAgICBsZXQgbmV3X2FycmF5ID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOmRlc2lyZWRfY2FwYWNpdHkgaW5cbiAgICAgIE9wdGlvbl9hcnJheS5ibGl0XG4gICAgICAgIH5zcmM6YXJyYXlcbiAgICAgICAgfnNyY19wb3M6MFxuICAgICAgICB+ZHN0Om5ld19hcnJheVxuICAgICAgICB+ZHN0X3BvczowXG4gICAgICAgIH5sZW46dC5udW1fc3Vic2NyaWJlcnM7XG4gICAgICBuZXdfYXJyYXlcbiAgICBpblxuICAgIHQuc3Vic2NyaWJlcnMgPC0gY29weV9hbmRfc2hyaW5rIHQuc3Vic2NyaWJlcnM7XG4gICAgdC5jYWxsYmFja3MgPC0gY29weV9hbmRfc2hyaW5rIHQuY2FsbGJhY2tzKVxuOztcblxubGV0IGFkZF9zdWJzY3JpYmVyIHQgKHN1YnNjcmliZXIgOiBfIFN1YnNjcmliZXIudCkgfmF0X3N1YnNjcmliZXJzX2luZGV4ID1cbiAgc3Vic2NyaWJlci5zdWJzY3JpYmVyc19pbmRleCA8LSBhdF9zdWJzY3JpYmVyc19pbmRleDtcbiAgT3B0aW9uX2FycmF5LnNldF9zb21lIHQuc3Vic2NyaWJlcnMgYXRfc3Vic2NyaWJlcnNfaW5kZXggc3Vic2NyaWJlcjtcbiAgT3B0aW9uX2FycmF5LnNldF9zb21lIHQuY2FsbGJhY2tzIGF0X3N1YnNjcmliZXJzX2luZGV4IHN1YnNjcmliZXIuY2FsbGJhY2tcbjs7XG5cbmxldCByZW1vdmVfc3Vic2NyaWJlciB0IChzdWJzY3JpYmVyIDogXyBTdWJzY3JpYmVyLnQpID1cbiAgbGV0IHN1YnNjcmliZXJzX2luZGV4ID0gc3Vic2NyaWJlci5zdWJzY3JpYmVyc19pbmRleCBpblxuICBzdWJzY3JpYmVyLnN1YnNjcmliZXJzX2luZGV4IDwtIC0xO1xuICBPcHRpb25fYXJyYXkuc2V0X25vbmUgdC5zdWJzY3JpYmVycyBzdWJzY3JpYmVyc19pbmRleDtcbiAgT3B0aW9uX2FycmF5LnNldF9ub25lIHQuY2FsbGJhY2tzIHN1YnNjcmliZXJzX2luZGV4XG47O1xuXG5sZXQgdW5zdWJzY3JpYmVfYXNzdW1pbmdfdmFsaWRfc3Vic2NyaWJlciB0IChzdWJzY3JpYmVyIDogXyBTdWJzY3JpYmVyLnQpID1cbiAgbGV0IHN1YnNjcmliZXJfaW5kZXggPSBzdWJzY3JpYmVyLnN1YnNjcmliZXJzX2luZGV4IGluXG4gIGxldCBsYXN0X3N1YnNjcmliZXJfaW5kZXggPSB0Lm51bV9zdWJzY3JpYmVycyAtIDEgaW5cbiAgcmVtb3ZlX3N1YnNjcmliZXIgdCBzdWJzY3JpYmVyO1xuICBpZiBzdWJzY3JpYmVyX2luZGV4IDwgbGFzdF9zdWJzY3JpYmVyX2luZGV4XG4gIHRoZW4gKFxuICAgIGxldCBsYXN0X3N1YnNjcmliZXIgPSBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuc3Vic2NyaWJlcnMgbGFzdF9zdWJzY3JpYmVyX2luZGV4IGluXG4gICAgcmVtb3ZlX3N1YnNjcmliZXIgdCBsYXN0X3N1YnNjcmliZXI7XG4gICAgYWRkX3N1YnNjcmliZXIgdCBsYXN0X3N1YnNjcmliZXIgfmF0X3N1YnNjcmliZXJzX2luZGV4OnN1YnNjcmliZXJfaW5kZXgpO1xuICB0Lm51bV9zdWJzY3JpYmVycyA8LSB0Lm51bV9zdWJzY3JpYmVycyAtIDE7XG4gIG1heWJlX3Nocmlua19jYXBhY2l0eSB0XG47O1xuXG5sZXQgdW5zdWJzY3JpYmUgdCBzdWJzY3JpYmVyID1cbiAgaWYgU3Vic2NyaWJlci5pc19zdWJzY3JpYmVkIHN1YnNjcmliZXIgfnRvXzp0LmJ1c19pZFxuICB0aGVuIChcbiAgICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgICB8IFdyaXRlX2luX3Byb2dyZXNzIC0+XG4gICAgICB0LnVuc3Vic2NyaWJlc19kdXJpbmdfd3JpdGUgPC0gc3Vic2NyaWJlciA6OiB0LnVuc3Vic2NyaWJlc19kdXJpbmdfd3JpdGVcbiAgICB8IENsb3NlZCAtPlxuICAgICAgKCogVGhpcyBjYW4gaGFwcGVuIGlmIGR1cmluZyBbd3JpdGVdLCBbdW5zdWJzY3JpYmVdIGlzIGNhbGxlZCBhZnRlciBbY2xvc2VdLiAgV2VcbiAgICAgICAgIGRvbid0IGRvIGFueXRoaW5nIGhlcmUgYmVjYXVzZSBhbGwgc3Vic2NyaWJlcnMgd2lsbCBiZSB1bnN1YnNjcmliZWQgYWZ0ZXIgdGhlXG4gICAgICAgICBbd3JpdGVdIGZpbmlzaGVzLiAqKVxuICAgICAgKClcbiAgICB8IE9rX3RvX3dyaXRlIC0+IHVuc3Vic2NyaWJlX2Fzc3VtaW5nX3ZhbGlkX3N1YnNjcmliZXIgdCBzdWJzY3JpYmVyKVxuOztcblxubGV0W0Bjb2xkXSB1bnN1YnNjcmliZV9hZnRlcl9maW5pc2hfd3JpdGUgdCA9XG4gIExpc3QuaXRlciB0LnVuc3Vic2NyaWJlc19kdXJpbmdfd3JpdGUgfmY6KHVuc3Vic2NyaWJlX2Fzc3VtaW5nX3ZhbGlkX3N1YnNjcmliZXIgdCk7XG4gIHQudW5zdWJzY3JpYmVzX2R1cmluZ193cml0ZSA8LSBbXVxuOztcblxubGV0W0Bjb2xkXSB1bnN1YnNjcmliZV9hbGwgdCA9XG4gIGFzc2VydCAoaXNfY2xvc2VkIHQpO1xuICBmb3IgaSA9IDAgdG8gdC5udW1fc3Vic2NyaWJlcnMgLSAxIGRvXG4gICAgbGV0IHN1YnNjcmliZXIgPSBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuc3Vic2NyaWJlcnMgaSBpblxuICAgIE9wdGlvbi5pdGVyIHN1YnNjcmliZXIub25fY2xvc2UgfmY6KGZ1biBvbl9jbG9zZSAtPiBvbl9jbG9zZSAoKSk7XG4gICAgcmVtb3ZlX3N1YnNjcmliZXIgdCBzdWJzY3JpYmVyXG4gIGRvbmU7XG4gIHQubnVtX3N1YnNjcmliZXJzIDwtIDA7XG4gIG1heWJlX3Nocmlua19jYXBhY2l0eSB0XG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGZpbmlzaF93cml0ZSB0ID1cbiAgaWYgbm90IChMaXN0LmlzX2VtcHR5IHQudW5zdWJzY3JpYmVzX2R1cmluZ193cml0ZSkgdGhlbiB1bnN1YnNjcmliZV9hZnRlcl9maW5pc2hfd3JpdGUgdDtcbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgQ2xvc2VkIC0+IHVuc3Vic2NyaWJlX2FsbCB0XG4gIHwgT2tfdG9fd3JpdGUgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgV3JpdGVfaW5fcHJvZ3Jlc3MgLT4gdC5zdGF0ZSA8LSBPa190b193cml0ZVxuOztcblxubGV0W0Bjb2xkXSBjbG9zZSB0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgQ2xvc2VkIC0+ICgpXG4gIHwgV3JpdGVfaW5fcHJvZ3Jlc3MgLT4gdC5zdGF0ZSA8LSBDbG9zZWRcbiAgfCBPa190b193cml0ZSAtPlxuICAgIHQuc3RhdGUgPC0gQ2xvc2VkO1xuICAgIHVuc3Vic2NyaWJlX2FsbCB0XG47O1xuXG5sZXQgY2FsbF9vbl9jYWxsYmFja19yYWlzZSB0IGVycm9yID1cbiAgdHJ5IHQub25fY2FsbGJhY2tfcmFpc2UgZXJyb3Igd2l0aFxuICB8IGV4biAtPlxuICAgIGNsb3NlIHQ7XG4gICAgcmFpc2UgZXhuXG47O1xuXG5sZXQgY2FsbGJhY2tfcmFpc2VkIHQgaSBleG4gPVxuICAoKiBbaV0gd2FzIGluY3JlbWVudGVkIGJlZm9yZSB0aGUgY2FsbGJhY2sgd2FzIGNhbGxlZCwgc28gd2UgaGF2ZSB0byBzdWJ0cmFjdCBvbmVcbiAgICAgaGVyZS4gIFdlIGRvIHRoaXMgaGVyZSwgcmF0aGVyIHRoYW4gYXQgdGhlIGNhbGwgc2l0ZSwgYmVjYXVzZSB0aGVyZSBhcmUgbXVsdGlwbGVcbiAgICAgY2FsbCBzaXRlcyBkdWUgdG8gdGhlIG9wdGltaXphdGlvbnMgbmVlZGVkIHRvIGtlZXAgdGhpcyB6ZXJvLWFsbG9jLiAqKVxuICBsZXQgc3Vic2NyaWJlciA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5zdWJzY3JpYmVycyAoaSAtIDEpIGluXG4gIGxldCBlcnJvciA9XG4gICAgbWF0Y2ggc3Vic2NyaWJlci5leHRyYWN0X2V4biB3aXRoXG4gICAgfCB0cnVlIC0+IEVycm9yLm9mX2V4biBleG5cbiAgICB8IGZhbHNlIC0+XG4gICAgICAoKiBUaGlzIFtCYWNrdHJhY2UuRXhuLm1vc3RfcmVjZW50ICgpXSBpcyBpbnRlbmRlZCB0byBncmFiIHRoZSBiYWNrdHJhY2Ugb2YgdGhlIFt0cnlcbiAgICAgICAgIC4uLiB3aXRoXSdzIHRoYXQgY2FsbCBbY2FsbGJhY2tfcmFpc2VkXS4gIFRoZSBjYWxsIGlzIGhlcmUgcmF0aGVyIHRoYW4gZWFybGllciBzb1xuICAgICAgICAgdGhhdCB3ZSBvbmx5IGRvIGl0IHdoZW4gW3N1YnNjcmliZXIuZXh0cmFjdF9leG4gPSBmYWxzZV0uICopXG4gICAgICBsZXQgYmFja3RyYWNlID0gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudCAoKSBpblxuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiQnVzIHN1YnNjcmliZXIgcmFpc2VkXCJcbiAgICAgICAgICAoZXhuIDogZXhuKVxuICAgICAgICAgIChiYWNrdHJhY2UgOiBCYWNrdHJhY2UudClcbiAgICAgICAgICAoc3Vic2NyaWJlciA6IF8gU3Vic2NyaWJlci50KV1cbiAgICAgIHw+IFslb2Zfc2V4cDogRXJyb3IudF1cbiAgaW5cbiAgbWF0Y2ggc3Vic2NyaWJlci5vbl9jYWxsYmFja19yYWlzZSB3aXRoXG4gIHwgTm9uZSAtPiBjYWxsX29uX2NhbGxiYWNrX3JhaXNlIHQgZXJyb3JcbiAgfCBTb21lIGYgLT5cbiAgICAodHJ5IGYgZXJyb3Igd2l0aFxuICAgICB8IGV4biAtPlxuICAgICAgIGxldCBiYWNrdHJhY2UgPSBCYWNrdHJhY2UuRXhuLm1vc3RfcmVjZW50ICgpIGluXG4gICAgICAgY2FsbF9vbl9jYWxsYmFja19yYWlzZVxuICAgICAgICAgdFxuICAgICAgICAgKGxldCBvcmlnaW5hbF9lcnJvciA9IGVycm9yIGluXG4gICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICBcIkJ1cyBzdWJzY3JpYmVyJ3MgW29uX2NhbGxiYWNrX3JhaXNlXSByYWlzZWRcIlxuICAgICAgICAgICAgICAoZXhuIDogZXhuKVxuICAgICAgICAgICAgICAoYmFja3RyYWNlIDogQmFja3RyYWNlLnQpXG4gICAgICAgICAgICAgIChvcmlnaW5hbF9lcnJvciA6IEVycm9yLnQpXVxuICAgICAgICAgIHw+IFslb2Zfc2V4cDogRXJyb3IudF0pKVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfZ2V0X2NhbGxiYWNrIGEgaSA9XG4gICgqIFdlIGNvbnNpZGVyZWQgdXNpbmcgW09wdGlvbl9hcnJheS5nZXRfc29tZV9leG5dIGFuZFxuICAgICBbT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG5dIGhlcmUsIGJ1dCBib3RoIGFyZSBzaWduaWZpY2FudGx5IHNsb3dlci4gIENoZWNrXG4gICAgIHRoZSB3cml0ZSBiZW5jaG1hcmtzIGluIFtiZW5jaF9idXMubWxdIGJlZm9yZSBjaGFuZ2luZyB0aGlzLiAqKVxuICBPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2Fzc3VtaW5nX3NvbWUgYSBpXG47O1xuXG5sZXQgd3JpdGVfbm9uX29wdGltaXplZCB0IGNhbGxiYWNrcyBhMSA9XG4gIGxldCBsZW4gPSB0Lm51bV9zdWJzY3JpYmVycyBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuIGRvXG4gICAgdHJ5XG4gICAgICBsZXQgY2FsbGJhY2sgPSB1bnNhZmVfZ2V0X2NhbGxiYWNrIGNhbGxiYWNrcyAhaSBpblxuICAgICAgaW5jciBpO1xuICAgICAgY2FsbGJhY2sgYTFcbiAgICB3aXRoXG4gICAgfCBleG4gLT4gY2FsbGJhY2tfcmFpc2VkIHQgIWkgZXhuXG4gIGRvbmU7XG4gIGZpbmlzaF93cml0ZSB0XG47O1xuXG5sZXQgd3JpdGVfbG9jYWxfbm9uX29wdGltaXplZCB0IGNhbGxiYWNrcyBhMSA9XG4gIGxldCBsZW4gPSB0Lm51bV9zdWJzY3JpYmVycyBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuIGRvXG4gICAgdHJ5XG4gICAgICBsZXQgY2FsbGJhY2sgPSB1bnNhZmVfZ2V0X2NhbGxiYWNrIGNhbGxiYWNrcyAhaSBpblxuICAgICAgaW5jciBpO1xuICAgICAgY2FsbGJhY2sgYTFcbiAgICB3aXRoXG4gICAgfCBleG4gLT4gY2FsbGJhY2tfcmFpc2VkIHQgIWkgZXhuXG4gIGRvbmU7XG4gIGZpbmlzaF93cml0ZSB0XG47O1xuXG5sZXQgd3JpdGUyX25vbl9vcHRpbWl6ZWQgdCBjYWxsYmFja3MgYTEgYTIgPVxuICBsZXQgbGVuID0gdC5udW1fc3Vic2NyaWJlcnMgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiBkb1xuICAgIHRyeVxuICAgICAgbGV0IGNhbGxiYWNrID0gdW5zYWZlX2dldF9jYWxsYmFjayBjYWxsYmFja3MgIWkgaW5cbiAgICAgIGluY3IgaTtcbiAgICAgIGNhbGxiYWNrIGExIGEyXG4gICAgd2l0aFxuICAgIHwgZXhuIC0+IGNhbGxiYWNrX3JhaXNlZCB0ICFpIGV4blxuICBkb25lO1xuICBmaW5pc2hfd3JpdGUgdFxuOztcblxubGV0IHdyaXRlM19ub25fb3B0aW1pemVkIHQgY2FsbGJhY2tzIGExIGEyIGEzID1cbiAgbGV0IGxlbiA9IHQubnVtX3N1YnNjcmliZXJzIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gZG9cbiAgICB0cnlcbiAgICAgIGxldCBjYWxsYmFjayA9IHVuc2FmZV9nZXRfY2FsbGJhY2sgY2FsbGJhY2tzICFpIGluXG4gICAgICBpbmNyIGk7XG4gICAgICBjYWxsYmFjayBhMSBhMiBhM1xuICAgIHdpdGhcbiAgICB8IGV4biAtPiBjYWxsYmFja19yYWlzZWQgdCAhaSBleG5cbiAgZG9uZTtcbiAgZmluaXNoX3dyaXRlIHRcbjs7XG5cbmxldCB3cml0ZTRfbm9uX29wdGltaXplZCB0IGNhbGxiYWNrcyBhMSBhMiBhMyBhNCA9XG4gIGxldCBsZW4gPSB0Lm51bV9zdWJzY3JpYmVycyBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuIGRvXG4gICAgdHJ5XG4gICAgICBsZXQgY2FsbGJhY2sgPSB1bnNhZmVfZ2V0X2NhbGxiYWNrIGNhbGxiYWNrcyAhaSBpblxuICAgICAgaW5jciBpO1xuICAgICAgY2FsbGJhY2sgYTEgYTIgYTMgYTRcbiAgICB3aXRoXG4gICAgfCBleG4gLT4gY2FsbGJhY2tfcmFpc2VkIHQgIWkgZXhuXG4gIGRvbmU7XG4gIGZpbmlzaF93cml0ZSB0XG47O1xuXG5sZXQgd3JpdGU1X25vbl9vcHRpbWl6ZWQgdCBjYWxsYmFja3MgYTEgYTIgYTMgYTQgYTUgPVxuICBsZXQgbGVuID0gdC5udW1fc3Vic2NyaWJlcnMgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiBkb1xuICAgIHRyeVxuICAgICAgbGV0IGNhbGxiYWNrID0gdW5zYWZlX2dldF9jYWxsYmFjayBjYWxsYmFja3MgIWkgaW5cbiAgICAgIGluY3IgaTtcbiAgICAgIGNhbGxiYWNrIGExIGEyIGEzIGE0IGE1XG4gICAgd2l0aFxuICAgIHwgZXhuIC0+IGNhbGxiYWNrX3JhaXNlZCB0ICFpIGV4blxuICBkb25lO1xuICBmaW5pc2hfd3JpdGUgdFxuOztcblxuKCogVGhlIFt3cml0ZV9OXSBmdW5jdGlvbnMgYXJlIHdyaXR0ZW4gdG8gbWluaW1pc2UgcmVnaXN0ZXJzIGxpdmUgYWNyb3NzIGZ1bmN0aW9uIGNhbGxzXG4gICAodGhlc2UgaGF2ZSB0byBiZSBzcGlsbGVkKS4gIFRoZXkgYXJlIGFsc28gYW5ub3RhdGVkIGZvciBwYXJ0aWFsIGlubGluaW5nICh0aGVcbiAgIG9uZS1jYWxsYmFjayBjYXNlIGJlY29tZXMgaW5saW5lZCB3aGVyZWFzIHRoZSA+MS1jYWxsYmFjay1jYXNlIHJlcXVpcmVzIGEgZnVydGhlclxuICAgZGlyZWN0IGNhbGwpLiAqKVxuXG5sZXRbQGlubGluZSBhbHdheXNdIHdyaXRlIHQgYTEgPVxuICBsZXQgY2FsbGJhY2tzID0gdC5jYWxsYmFja3MgaW5cbiAgdC53cml0ZV9ldmVyX2NhbGxlZCA8LSB0cnVlO1xuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBDbG9zZWQgfCBXcml0ZV9pbl9wcm9ncmVzcyAtPiBzdGFydF93cml0ZV9mYWlsaW5nIHRcbiAgfCBPa190b193cml0ZSAtPlxuICAgIChtYXRjaCB0Lmxhc3RfdmFsdWUgd2l0aFxuICAgICB8IE5vbmUgLT4gKClcbiAgICAgfCBTb21lIGxhc3RfdmFsdWUgLT4gTGFzdF92YWx1ZS5zZXQxIGxhc3RfdmFsdWUgYTEpO1xuICAgIGlmIHQubnVtX3N1YnNjcmliZXJzID4gMFxuICAgIHRoZW4gKFxuICAgICAgdC5zdGF0ZSA8LSBXcml0ZV9pbl9wcm9ncmVzcztcbiAgICAgIGlmIHQubnVtX3N1YnNjcmliZXJzID0gMVxuICAgICAgdGhlbiAoXG4gICAgICAgICh0cnkgKHVuc2FmZV9nZXRfY2FsbGJhY2sgY2FsbGJhY2tzIDApIGExIHdpdGhcbiAgICAgICAgIHwgZXhuIC0+IGNhbGxiYWNrX3JhaXNlZCB0IDEgZXhuKTtcbiAgICAgICAgZmluaXNoX3dyaXRlIHQpXG4gICAgICBlbHNlICh3cml0ZV9ub25fb3B0aW1pemVkIFtAaW5saW5lZCBuZXZlcl0pIHQgY2FsbGJhY2tzIGExKVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB3cml0ZV9sb2NhbCB0IGExID1cbiAgbGV0IGNhbGxiYWNrcyA9IHQuY2FsbGJhY2tzIGluXG4gIHQud3JpdGVfZXZlcl9jYWxsZWQgPC0gdHJ1ZTtcbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgQ2xvc2VkIHwgV3JpdGVfaW5fcHJvZ3Jlc3MgLT4gc3RhcnRfd3JpdGVfZmFpbGluZyB0XG4gIHwgT2tfdG9fd3JpdGUgLT5cbiAgICBpZiB0Lm51bV9zdWJzY3JpYmVycyA+IDBcbiAgICB0aGVuIChcbiAgICAgIHQuc3RhdGUgPC0gV3JpdGVfaW5fcHJvZ3Jlc3M7XG4gICAgICBpZiB0Lm51bV9zdWJzY3JpYmVycyA9IDFcbiAgICAgIHRoZW4gKFxuICAgICAgICAodHJ5ICh1bnNhZmVfZ2V0X2NhbGxiYWNrIGNhbGxiYWNrcyAwKSBhMSB3aXRoXG4gICAgICAgICB8IGV4biAtPiBjYWxsYmFja19yYWlzZWQgdCAxIGV4bik7XG4gICAgICAgIGZpbmlzaF93cml0ZSB0KVxuICAgICAgZWxzZSAod3JpdGVfbG9jYWxfbm9uX29wdGltaXplZCBbQGlubGluZWQgbmV2ZXJdKSB0IGNhbGxiYWNrcyBhMSlcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gd3JpdGUyIHQgYTEgYTIgPVxuICBsZXQgY2FsbGJhY2tzID0gdC5jYWxsYmFja3MgaW5cbiAgdC53cml0ZV9ldmVyX2NhbGxlZCA8LSB0cnVlO1xuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBDbG9zZWQgfCBXcml0ZV9pbl9wcm9ncmVzcyAtPiBzdGFydF93cml0ZV9mYWlsaW5nIHRcbiAgfCBPa190b193cml0ZSAtPlxuICAgIChtYXRjaCB0Lmxhc3RfdmFsdWUgd2l0aFxuICAgICB8IE5vbmUgLT4gKClcbiAgICAgfCBTb21lIGxhc3RfdmFsdWUgLT4gTGFzdF92YWx1ZS5zZXQyIGxhc3RfdmFsdWUgYTEgYTIpO1xuICAgIGlmIHQubnVtX3N1YnNjcmliZXJzID4gMFxuICAgIHRoZW4gKFxuICAgICAgdC5zdGF0ZSA8LSBXcml0ZV9pbl9wcm9ncmVzcztcbiAgICAgIGlmIHQubnVtX3N1YnNjcmliZXJzID0gMVxuICAgICAgdGhlbiAoXG4gICAgICAgICh0cnkgKHVuc2FmZV9nZXRfY2FsbGJhY2sgY2FsbGJhY2tzIDApIGExIGEyIHdpdGhcbiAgICAgICAgIHwgZXhuIC0+IGNhbGxiYWNrX3JhaXNlZCB0IDEgZXhuKTtcbiAgICAgICAgZmluaXNoX3dyaXRlIHQpXG4gICAgICBlbHNlICh3cml0ZTJfbm9uX29wdGltaXplZCBbQGlubGluZWQgbmV2ZXJdKSB0IGNhbGxiYWNrcyBhMSBhMilcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gd3JpdGUzIHQgYTEgYTIgYTMgPVxuICBsZXQgY2FsbGJhY2tzID0gdC5jYWxsYmFja3MgaW5cbiAgdC53cml0ZV9ldmVyX2NhbGxlZCA8LSB0cnVlO1xuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBDbG9zZWQgfCBXcml0ZV9pbl9wcm9ncmVzcyAtPiBzdGFydF93cml0ZV9mYWlsaW5nIHRcbiAgfCBPa190b193cml0ZSAtPlxuICAgIChtYXRjaCB0Lmxhc3RfdmFsdWUgd2l0aFxuICAgICB8IE5vbmUgLT4gKClcbiAgICAgfCBTb21lIGxhc3RfdmFsdWUgLT4gTGFzdF92YWx1ZS5zZXQzIGxhc3RfdmFsdWUgYTEgYTIgYTMpO1xuICAgIGlmIHQubnVtX3N1YnNjcmliZXJzID4gMFxuICAgIHRoZW4gKFxuICAgICAgdC5zdGF0ZSA8LSBXcml0ZV9pbl9wcm9ncmVzcztcbiAgICAgIGlmIHQubnVtX3N1YnNjcmliZXJzID0gMVxuICAgICAgdGhlbiAoXG4gICAgICAgICh0cnkgKHVuc2FmZV9nZXRfY2FsbGJhY2sgY2FsbGJhY2tzIDApIGExIGEyIGEzIHdpdGhcbiAgICAgICAgIHwgZXhuIC0+IGNhbGxiYWNrX3JhaXNlZCB0IDEgZXhuKTtcbiAgICAgICAgZmluaXNoX3dyaXRlIHQpXG4gICAgICBlbHNlICh3cml0ZTNfbm9uX29wdGltaXplZCBbQGlubGluZWQgbmV2ZXJdKSB0IGNhbGxiYWNrcyBhMSBhMiBhMylcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gd3JpdGU0IHQgYTEgYTIgYTMgYTQgPVxuICBsZXQgY2FsbGJhY2tzID0gdC5jYWxsYmFja3MgaW5cbiAgdC53cml0ZV9ldmVyX2NhbGxlZCA8LSB0cnVlO1xuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBDbG9zZWQgfCBXcml0ZV9pbl9wcm9ncmVzcyAtPiBzdGFydF93cml0ZV9mYWlsaW5nIHRcbiAgfCBPa190b193cml0ZSAtPlxuICAgIChtYXRjaCB0Lmxhc3RfdmFsdWUgd2l0aFxuICAgICB8IE5vbmUgLT4gKClcbiAgICAgfCBTb21lIGxhc3RfdmFsdWUgLT4gTGFzdF92YWx1ZS5zZXQ0IGxhc3RfdmFsdWUgYTEgYTIgYTMgYTQpO1xuICAgIGlmIHQubnVtX3N1YnNjcmliZXJzID4gMFxuICAgIHRoZW4gKFxuICAgICAgdC5zdGF0ZSA8LSBXcml0ZV9pbl9wcm9ncmVzcztcbiAgICAgIGlmIHQubnVtX3N1YnNjcmliZXJzID0gMVxuICAgICAgdGhlbiAoXG4gICAgICAgICh0cnkgKHVuc2FmZV9nZXRfY2FsbGJhY2sgY2FsbGJhY2tzIDApIGExIGEyIGEzIGE0IHdpdGhcbiAgICAgICAgIHwgZXhuIC0+IGNhbGxiYWNrX3JhaXNlZCB0IDEgZXhuKTtcbiAgICAgICAgZmluaXNoX3dyaXRlIHQpXG4gICAgICBlbHNlICh3cml0ZTRfbm9uX29wdGltaXplZCBbQGlubGluZWQgbmV2ZXJdKSB0IGNhbGxiYWNrcyBhMSBhMiBhMyBhNClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gd3JpdGU1IHQgYTEgYTIgYTMgYTQgYTUgPVxuICBsZXQgY2FsbGJhY2tzID0gdC5jYWxsYmFja3MgaW5cbiAgdC53cml0ZV9ldmVyX2NhbGxlZCA8LSB0cnVlO1xuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBDbG9zZWQgfCBXcml0ZV9pbl9wcm9ncmVzcyAtPiBzdGFydF93cml0ZV9mYWlsaW5nIHRcbiAgfCBPa190b193cml0ZSAtPlxuICAgIChtYXRjaCB0Lmxhc3RfdmFsdWUgd2l0aFxuICAgICB8IE5vbmUgLT4gKClcbiAgICAgfCBTb21lIGxhc3RfdmFsdWUgLT4gTGFzdF92YWx1ZS5zZXQ1IGxhc3RfdmFsdWUgYTEgYTIgYTMgYTQgYTUpO1xuICAgIGlmIHQubnVtX3N1YnNjcmliZXJzID4gMFxuICAgIHRoZW4gKFxuICAgICAgdC5zdGF0ZSA8LSBXcml0ZV9pbl9wcm9ncmVzcztcbiAgICAgIGlmIHQubnVtX3N1YnNjcmliZXJzID0gMVxuICAgICAgdGhlbiAoXG4gICAgICAgICh0cnkgKHVuc2FmZV9nZXRfY2FsbGJhY2sgY2FsbGJhY2tzIDApIGExIGEyIGEzIGE0IGE1IHdpdGhcbiAgICAgICAgIHwgZXhuIC0+IGNhbGxiYWNrX3JhaXNlZCB0IDEgZXhuKTtcbiAgICAgICAgZmluaXNoX3dyaXRlIHQpXG4gICAgICBlbHNlICh3cml0ZTVfbm9uX29wdGltaXplZCBbQGlubGluZWQgbmV2ZXJdKSB0IGNhbGxiYWNrcyBhMSBhMiBhMyBhNCBhNSlcbjs7XG5cbmxldCBhbGxvd19zdWJzY3JpcHRpb25fYWZ0ZXJfZmlyc3Rfd3JpdGUgdCA9XG4gIE9uX3N1YnNjcmlwdGlvbl9hZnRlcl9maXJzdF93cml0ZS5hbGxvd19zdWJzY3JpcHRpb25fYWZ0ZXJfZmlyc3Rfd3JpdGVcbiAgICB0Lm9uX3N1YnNjcmlwdGlvbl9hZnRlcl9maXJzdF93cml0ZVxuOztcblxubGV0IGNyZWF0ZV9leG5cbiAgP25hbWVcbiAgY3JlYXRlZF9mcm9tXG4gIGNhbGxiYWNrX2FyaXR5XG4gIH4ob25fc3Vic2NyaXB0aW9uX2FmdGVyX2ZpcnN0X3dyaXRlIDogT25fc3Vic2NyaXB0aW9uX2FmdGVyX2ZpcnN0X3dyaXRlLnQpXG4gIH5vbl9jYWxsYmFja19yYWlzZVxuICA9XG4gIGxldCBsYXN0X3ZhbHVlID1cbiAgICBPbl9zdWJzY3JpcHRpb25fYWZ0ZXJfZmlyc3Rfd3JpdGUuc2F2ZV9sYXN0X3ZhbHVlX2V4blxuICAgICAgb25fc3Vic2NyaXB0aW9uX2FmdGVyX2ZpcnN0X3dyaXRlXG4gICAgICBjYWxsYmFja19hcml0eVxuICBpblxuICB7IGJ1c19pZCA9IEJ1c19pZC5jcmVhdGUgKClcbiAgOyBuYW1lXG4gIDsgY2FsbGJhY2tfYXJpdHlcbiAgOyBjcmVhdGVkX2Zyb21cbiAgOyBudW1fc3Vic2NyaWJlcnMgPSAwXG4gIDsgb25fc3Vic2NyaXB0aW9uX2FmdGVyX2ZpcnN0X3dyaXRlXG4gIDsgb25fY2FsbGJhY2tfcmFpc2VcbiAgOyBsYXN0X3ZhbHVlXG4gIDsgc3Vic2NyaWJlcnMgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46MFxuICA7IGNhbGxiYWNrcyA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjowXG4gIDsgc3RhdGUgPSBPa190b193cml0ZVxuICA7IHdyaXRlX2V2ZXJfY2FsbGVkID0gZmFsc2VcbiAgOyB1bnN1YnNjcmliZXNfZHVyaW5nX3dyaXRlID0gW11cbiAgfVxuOztcblxubGV0IGNhbl9zdWJzY3JpYmUgdCA9IGFsbG93X3N1YnNjcmlwdGlvbl9hZnRlcl9maXJzdF93cml0ZSB0IHx8IG5vdCB0LndyaXRlX2V2ZXJfY2FsbGVkXG5cbmxldCBlbmxhcmdlX2NhcGFjaXR5IHQgPVxuICBsZXQgY2FwYWNpdHkgPSBjYXBhY2l0eSB0IGluXG4gIGxldCBuZXdfY2FwYWNpdHkgPSBJbnQubWF4IDEgKGNhcGFjaXR5ICogMikgaW5cbiAgbGV0IGNvcHlfYW5kX2RvdWJsZSBhcnJheSA9XG4gICAgbGV0IG5ld19hcnJheSA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpuZXdfY2FwYWNpdHkgaW5cbiAgICBPcHRpb25fYXJyYXkuYmxpdCB+c3JjOmFycmF5IH5zcmNfcG9zOjAgfmRzdDpuZXdfYXJyYXkgfmRzdF9wb3M6MCB+bGVuOmNhcGFjaXR5O1xuICAgIG5ld19hcnJheVxuICBpblxuICB0LnN1YnNjcmliZXJzIDwtIGNvcHlfYW5kX2RvdWJsZSB0LnN1YnNjcmliZXJzO1xuICB0LmNhbGxiYWNrcyA8LSBjb3B5X2FuZF9kb3VibGUgdC5jYWxsYmFja3Ncbjs7XG5cbmxldCBzdWJzY3JpYmVfZXhuXG4gID8oZXh0cmFjdF9leG4gPSBmYWxzZSlcbiAgP29uX2NhbGxiYWNrX3JhaXNlXG4gID9vbl9jbG9zZVxuICB0XG4gIHN1YnNjcmliZWRfZnJvbVxuICB+ZjpjYWxsYmFja1xuICA9XG4gIGlmIG5vdCAoY2FuX3N1YnNjcmliZSB0KVxuICB0aGVuXG4gICAgZmFpbHdpdGhzXG4gICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICBcIkJ1cy5zdWJzY3JpYmVfZXhuIGNhbGxlZCBhZnRlciBmaXJzdCB3cml0ZVwiXG4gICAgICBbJXNleHAgfn4oc3Vic2NyaWJlZF9mcm9tIDogU291cmNlX2NvZGVfcG9zaXRpb24udCksIHsgYnVzID0gKHQgOiAoXywgXykgdCkgfV1cbiAgICAgIFslc2V4cF9vZjogU2V4cC50XTtcbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgQ2xvc2VkIC0+XG4gICAgKCogQW55dGhpbmcgdGhhdCBzYXRpc2ZpZXMgdGhlIHJldHVybiB0eXBlIHdpbGwgZG8uICBTaW5jZSB0aGUgc3Vic2NyaWJlciBpcyBuZXZlclxuICAgICAgIHN0b3JlZCBpbiB0aGUgYXJyYXlzLCB0aGUgW29uX2Nsb3NlXSBjYWxsYmFjayB3aWxsIG5ldmVyIGJlIGNhbGxlZC4gKilcbiAgICBTdWJzY3JpYmVyLmNyZWF0ZVxuICAgICAgc3Vic2NyaWJlZF9mcm9tXG4gICAgICB+YnVzX2lkOnQuYnVzX2lkXG4gICAgICB+Y2FsbGJhY2tcbiAgICAgIH5leHRyYWN0X2V4blxuICAgICAgfnN1YnNjcmliZXJzX2luZGV4OigtMSlcbiAgICAgIH5vbl9jYWxsYmFja19yYWlzZVxuICAgICAgfm9uX2Nsb3NlXG4gIHwgT2tfdG9fd3JpdGUgfCBXcml0ZV9pbl9wcm9ncmVzcyAtPlxuICAgICgqIFRoZSBjb2RlIGJlbG93IHNpZGUgZWZmZWN0cyBbdF0sIHdoaWNoIHBvdGVudGlhbGx5IGNvdWxkIGludGVyZmVyZSB3aXRoIGEgd3JpdGUgaW5cbiAgICAgICBwcm9ncmVzcy4gIEhvd2V2ZXIsIHRoZSBzaWRlIGVmZmVjdHMgZG9uJ3QgY2hhbmdlIHRoZSBwcmVmaXggb2YgW3QuY2FsbGJhY2tzXSB0aGF0XG4gICAgICAgd3JpdGUgdXNlczsgdGhleSBvbmx5IGNoYW5nZSBbdC5jYWxsYmFja3NdIGJleW9uZCB0aGF0IHByZWZpeC4gIEFuZCBhbGwgd3JpdGVzXG4gICAgICAgZXh0cmFjdCBbdC5udW1fc3Vic2NyaWJlcnNdIGF0IHRoZSBzdGFydCwgc28gdGhhdCB0aGV5IHdpbGwgbm90IHNlZSBhbnkgc3Vic2VxdWVudFxuICAgICAgIGNoYW5nZXMgdG8gaXQuICopXG4gICAgbGV0IHN1YnNjcmliZXIgPVxuICAgICAgU3Vic2NyaWJlci5jcmVhdGVcbiAgICAgICAgc3Vic2NyaWJlZF9mcm9tXG4gICAgICAgIH5idXNfaWQ6dC5idXNfaWRcbiAgICAgICAgfmNhbGxiYWNrXG4gICAgICAgIH5leHRyYWN0X2V4blxuICAgICAgICB+c3Vic2NyaWJlcnNfaW5kZXg6dC5udW1fc3Vic2NyaWJlcnNcbiAgICAgICAgfm9uX2NhbGxiYWNrX3JhaXNlXG4gICAgICAgIH5vbl9jbG9zZVxuICAgIGluXG4gICAgaWYgY2FwYWNpdHkgdCA9IHQubnVtX3N1YnNjcmliZXJzIHRoZW4gZW5sYXJnZV9jYXBhY2l0eSB0O1xuICAgIGFkZF9zdWJzY3JpYmVyIHQgc3Vic2NyaWJlciB+YXRfc3Vic2NyaWJlcnNfaW5kZXg6dC5udW1fc3Vic2NyaWJlcnM7XG4gICAgdC5udW1fc3Vic2NyaWJlcnMgPC0gdC5udW1fc3Vic2NyaWJlcnMgKyAxO1xuICAgIChtYXRjaCB0Lmxhc3RfdmFsdWUgd2l0aFxuICAgICB8IE5vbmUgLT4gKClcbiAgICAgfCBTb21lIGxhc3RfdmFsdWUgLT4gTGFzdF92YWx1ZS5zZW5kIGxhc3RfdmFsdWUgY2FsbGJhY2spO1xuICAgIHN1YnNjcmliZXJcbjs7XG5cbmxldCBpdGVyX2V4biA/ZXh0cmFjdF9leG4gdCBzdWJzY3JpYmVkX2Zyb20gfmYgPVxuICBpZiBub3QgKGNhbl9zdWJzY3JpYmUgdClcbiAgdGhlblxuICAgIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwiQnVzLml0ZXJfZXhuIGNhbGxlZCBhZnRlciBmaXJzdCB3cml0ZVwiIHQgWyVzZXhwX29mOiAoXywgXykgdF07XG4gIGlnbm9yZSAoc3Vic2NyaWJlX2V4biA/ZXh0cmFjdF9leG4gdCBzdWJzY3JpYmVkX2Zyb20gfmYgOiBfIFN1YnNjcmliZXIudClcbjs7XG5cbm1vZHVsZSBGb2xkX2FyaXR5ID0gc3RydWN0XG4gIHR5cGUgKF8sIF8sIF8pIHQgPVxuICAgIHwgQXJpdHkxIDogKCdhIC0+IHVuaXQsICdzIC0+ICdhIC0+ICdzLCAncykgdFxuICAgIHwgQXJpdHkyIDogKCdhIC0+ICdiIC0+IHVuaXQsICdzIC0+ICdhIC0+ICdiIC0+ICdzLCAncykgdFxuICAgIHwgQXJpdHkzIDogKCdhIC0+ICdiIC0+ICdjIC0+IHVuaXQsICdzIC0+ICdhIC0+ICdiIC0+ICdjIC0+ICdzLCAncykgdFxuICAgIHwgQXJpdHk0IDogKCdhIC0+ICdiIC0+ICdjIC0+ICdkIC0+IHVuaXQsICdzIC0+ICdhIC0+ICdiIC0+ICdjIC0+ICdkIC0+ICdzLCAncykgdFxuICAgIHwgQXJpdHk1XG4gICAgICAgIDogKCAnYSAtPiAnYiAtPiAnYyAtPiAnZCAtPiAnZSAtPiB1bml0XG4gICAgICAgICAgLCAncyAtPiAnYSAtPiAnYiAtPiAnYyAtPiAnZCAtPiAnZSAtPiAnc1xuICAgICAgICAgICwgJ3MgKVxuICAgICAgICAgIHRcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5sZXQgZm9sZF9leG5cbiAgP2V4dHJhY3RfZXhuXG4gICh0eXBlIGMgZiBzKVxuICAodCA6IChjLCBfKSB0KVxuICBzdWJzY3JpYmVkX2Zyb21cbiAgKGZvbGRfYXJpdHkgOiAoYywgZiwgcykgRm9sZF9hcml0eS50KVxuICB+KGluaXQgOiBzKVxuICB+KGYgOiBmKVxuICA9XG4gIGxldCBzdGF0ZSA9IHJlZiBpbml0IGluXG4gIGlmIG5vdCAoY2FuX3N1YnNjcmliZSB0KVxuICB0aGVuXG4gICAgZmFpbHdpdGhzIH5oZXJlOlslaGVyZV0gXCJCdXMuZm9sZF9leG4gY2FsbGVkIGFmdGVyIGZpcnN0IHdyaXRlXCIgdCBbJXNleHBfb2Y6IChfLCBfKSB0XTtcbiAgaXRlcl9leG5cbiAgICA/ZXh0cmFjdF9leG5cbiAgICB0XG4gICAgc3Vic2NyaWJlZF9mcm9tXG4gICAgfmY6XG4gICAgICAobWF0Y2ggZm9sZF9hcml0eSB3aXRoXG4gICAgICAgfCBBcml0eTEgLT4gZnVuIGExIC0+IHN0YXRlIDo9IGYgIXN0YXRlIGExXG4gICAgICAgfCBBcml0eTIgLT4gZnVuIGExIGEyIC0+IHN0YXRlIDo9IGYgIXN0YXRlIGExIGEyXG4gICAgICAgfCBBcml0eTMgLT4gZnVuIGExIGEyIGEzIC0+IHN0YXRlIDo9IGYgIXN0YXRlIGExIGEyIGEzXG4gICAgICAgfCBBcml0eTQgLT4gZnVuIGExIGEyIGEzIGE0IC0+IHN0YXRlIDo9IGYgIXN0YXRlIGExIGEyIGEzIGE0XG4gICAgICAgfCBBcml0eTUgLT4gZnVuIGExIGEyIGEzIGE0IGE1IC0+IHN0YXRlIDo9IGYgIXN0YXRlIGExIGEyIGEzIGE0IGE1KVxuOztcblxubGV0JXRlc3RfbW9kdWxlIF8gPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIGxldCBhc3NlcnRfbm9fYWxsb2NhdGlvbiBidXMgY2FsbGJhY2sgd3JpdGUgPVxuICAgICAgbGV0IGJ1c19yID0gcmVhZF9vbmx5IGJ1cyBpblxuICAgICAgaWdub3JlIChzdWJzY3JpYmVfZXhuIGJ1c19yIFslaGVyZV0gfmY6Y2FsbGJhY2sgOiBfIFN1YnNjcmliZXIudCk7XG4gICAgICBsZXQgc3RhcnRpbmdfbWlub3Jfd29yZHMgPSBHYy5taW5vcl93b3JkcyAoKSBpblxuICAgICAgbGV0IHN0YXJ0aW5nX21ham9yX3dvcmRzID0gR2MubWFqb3Jfd29yZHMgKCkgaW5cbiAgICAgIHdyaXRlICgpO1xuICAgICAgbGV0IGVuZGluZ19taW5vcl93b3JkcyA9IEdjLm1pbm9yX3dvcmRzICgpIGluXG4gICAgICBsZXQgZW5kaW5nX21ham9yX3dvcmRzID0gR2MubWFqb3Jfd29yZHMgKCkgaW5cbiAgICAgIFsldGVzdF9yZXN1bHQ6IGludF0gKGVuZGluZ19taW5vcl93b3JkcyAtIHN0YXJ0aW5nX21pbm9yX3dvcmRzKSB+ZXhwZWN0OjA7XG4gICAgICBbJXRlc3RfcmVzdWx0OiBpbnRdIChlbmRpbmdfbWFqb3Jfd29yZHMgLSBzdGFydGluZ19tYWpvcl93b3JkcykgfmV4cGVjdDowXG4gICAgOztcblxuICAgICgqIFRoaXMgdGVzdCBvbmx5IHdvcmtzIHdoZW4gW3dyaXRlXSBpcyBwcm9wZXJseSBpbmxpbmVkLiAgSXQgZG9lcyBub3QgZ3VhcmFudGVlIHRoYXRcbiAgICAgICBbd3JpdGVdIG5ldmVyIGFsbG9jYXRlcyBpbiBhbnkgc2l0dWF0aW9uLiAgRm9yIGV4YW1wbGUsIGlmIHRoaXMgdGVzdCBpcyBtb3ZlZCB0b1xuICAgICAgIGFub3RoZXIgbGlicmFyeSBhbmQgcnVuIHdpdGggWF9MSUJSQVJZX0lOTElOSU5HPWZhbHNlLCBpdCBmYWlscy4gKilcbiAgICBsZXQldGVzdF91bml0IFwid3JpdGUgZG9lc24ndCBhbGxvY2F0ZSB3aGVuIGlubGluZWRcIiA9XG4gICAgICBsZXQgY3JlYXRlIGNyZWF0ZWRfZnJvbSBhcml0eSA9XG4gICAgICAgIGNyZWF0ZV9leG5cbiAgICAgICAgICBjcmVhdGVkX2Zyb21cbiAgICAgICAgICBhcml0eVxuICAgICAgICAgIH5vbl9zdWJzY3JpcHRpb25fYWZ0ZXJfZmlyc3Rfd3JpdGU6UmFpc2VcbiAgICAgICAgICB+b25fY2FsbGJhY2tfcmFpc2U6RXJyb3IucmFpc2VcbiAgICAgIGluXG4gICAgICBsZXQgYnVzMSA9IGNyZWF0ZSBbJWhlcmVdIEFyaXR5MSBpblxuICAgICAgbGV0IGJ1czIgPSBjcmVhdGUgWyVoZXJlXSBBcml0eTIgaW5cbiAgICAgIGxldCBidXMzID0gY3JlYXRlIFslaGVyZV0gQXJpdHkzIGluXG4gICAgICBsZXQgYnVzNCA9IGNyZWF0ZSBbJWhlcmVdIEFyaXR5NCBpblxuICAgICAgbGV0IGJ1czUgPSBjcmVhdGUgWyVoZXJlXSBBcml0eTUgaW5cbiAgICAgIGFzc2VydF9ub19hbGxvY2F0aW9uIGJ1czEgKGZ1biAoKSAtPiAoKSkgKGZ1biAoKSAtPiB3cml0ZSBidXMxICgpKTtcbiAgICAgIGFzc2VydF9ub19hbGxvY2F0aW9uIGJ1czIgKGZ1biAoKSAoKSAtPiAoKSkgKGZ1biAoKSAtPiB3cml0ZTIgYnVzMiAoKSAoKSk7XG4gICAgICBhc3NlcnRfbm9fYWxsb2NhdGlvbiBidXMzIChmdW4gKCkgKCkgKCkgLT4gKCkpIChmdW4gKCkgLT4gd3JpdGUzIGJ1czMgKCkgKCkgKCkpO1xuICAgICAgYXNzZXJ0X25vX2FsbG9jYXRpb25cbiAgICAgICAgYnVzNFxuICAgICAgICAoZnVuICgpICgpICgpICgpIC0+ICgpKVxuICAgICAgICAoZnVuICgpIC0+IHdyaXRlNCBidXM0ICgpICgpICgpICgpKTtcbiAgICAgIGFzc2VydF9ub19hbGxvY2F0aW9uXG4gICAgICAgIGJ1czVcbiAgICAgICAgKGZ1biAoKSAoKSAoKSAoKSAoKSAtPiAoKSlcbiAgICAgICAgKGZ1biAoKSAtPiB3cml0ZTUgYnVzNSAoKSAoKSAoKSAoKSAoKSlcbiAgICA7O1xuICBlbmQpXG47O1xuIl19
