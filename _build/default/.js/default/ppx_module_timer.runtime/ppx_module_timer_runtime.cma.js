// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ppx_module_timer_runtime
//# unitInfo: Requires: Base, Base__Int, Base__Int63, Base__List, Base__Option, Base__Printf, Base__String, CamlinternalLazy, Stdio, Stdlib, Stdlib__Gc, Stdlib__Sys, Time_now
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_PPX_MODULE_TIMER = "PPX_MODULE_TIMER",
    cst_ns$1 = "ns",
    cst_runtime_ppx_module_timer_r = "runtime/ppx_module_timer_runtime.ml",
    caml_gc_quick_stat = runtime.caml_gc_quick_stat,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = "\n",
    cst$1 = " ",
    cst$2 = cst$4,
    cst$0 = cst$4,
    cst = cst$4,
    am_recording_environment_varia = cst_PPX_MODULE_TIMER,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Base_Int63 = global_data.Base__Int63,
    Stdio = global_data.Stdio,
    Base_Option = global_data.Base__Option,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Printf = global_data.Base__Printf,
    Base_Int = global_data.Base__Int,
    Time_now = global_data.Time_now,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib;
   a:
   {
    var
     cst_ppx_module_timer_overridin =
       "ppx_module_timer: overriding time measurements for testing",
     _e_ = [0, [11, "Line ", [4, 0, 0, 0, 0]], "Line %d"],
     _f_ =
       [0, [11, "Fake__Dependency_", [4, 0, 0, 0, 0]], "Fake__Dependency_%d"],
     _d_ = [0, [2, [1, 1], [12, 32, [2, 0, 0]]], "%*s %s"],
     cst_compactions = "compactions",
     cst_major_collections = "major collections",
     cst_minor_collections = "minor collections",
     _c_ = [0, ", "],
     cst_GC = "; GC: ",
     _b_ = [0, cst_runtime_ppx_module_timer_r, 110, 6],
     _a_ = [0, cst_runtime_ppx_module_timer_r, 94, 6],
     cst_ns$0 = cst_ns$1,
     cst_ns = cst_ns$1;
    try{var value = runtime.caml_sys_getenv(cst_PPX_MODULE_TIMER);}
    catch(_X_){var am_recording_value = 0; break a;}
    var am_recording_value = [0, value];
   }
   var am_recording = caml_call1(Base_Option[53], am_recording_value);
   function to_nanoseconds(t){return t;}
   function of_nanoseconds(t){return t;}
   function of_string(string){
    var _W_ = caml_call2(Base_String[114], string, cst_ns);
    return caml_call1(Base_Int63[10], _W_);
   }
   function to_string(nanos){
    var _V_ = caml_call1(Base_Int63[11], nanos);
    return caml_call2(Base[241], _V_, cst_ns$0);
   }
   function to_string_with_same_unit(list){
    return caml_call2(Base_List[53], list, to_string);
   }
   var format = [0, [0, of_string, to_string_with_same_unit]];
   function create(nested_timer, param){
    var _U_ = caml_gc_quick_stat(0);
    return [0, cst, Base_Int63[42], _U_, nested_timer, 0];
   }
   function record_start(t, description){
    if(am_recording){
     if(! caml_call1(Base_String[14], t[1]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     t[1] = description;
     t[3] = caml_gc_quick_stat(0);
     t[2] = caml_call1(Time_now[2], 0);
     var _T_ = 0;
    }
    else
     var _T_ = am_recording;
    return _T_;
   }
   function record_until(t, description){
    if(! am_recording) return am_recording;
    var
     until = caml_call1(Time_now[2], 0),
     start = t[2],
     gc_stats_after = caml_gc_quick_stat(0),
     gc_stats_before = t[3],
     runtime = caml_call2(Base_Int63[46], until, start);
    if(! caml_call2(Base_String[134], t[1], description))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var
     gc_events =
       [0,
        gc_stats_after[4] - gc_stats_before[4] | 0,
        gc_stats_after[5] - gc_stats_before[5] | 0,
        gc_stats_after[14] - gc_stats_before[14] | 0],
     match$0 = t[4];
    if(match$0)
     var
      nested$0 = match$0[1],
      nested_timing_events = caml_call1(Base_List[63], nested$0[5]);
    else
     var nested_timing_events = 0;
    var
     timing_event = [0, description, runtime, gc_events, nested_timing_events];
    t[5] = [0, timing_event, t[5]];
    t[1] = cst$0;
    t[2] = Base_Int63[42];
    var match = t[4];
    if(! match) return 0;
    var nested = match[1];
    nested[5] = 0;
    return 0;
   }
   var
    definition_timer = create(0, 0),
    module_timer = create([0, definition_timer], 0);
   function record_start$0(module_name){
    return record_start(module_timer, module_name);
   }
   function record_until$0(module_name){
    return record_until(module_timer, module_name);
   }
   function record_definition_start(loc){
    return record_start(definition_timer, loc);
   }
   function record_definition_until(loc){
    return record_until(definition_timer, loc);
   }
   function timing_events_to_strings(list, indent){
    function _D_(timing_event){return timing_event[2];}
    var
     string = caml_call2(Base_List[53], list, _D_),
     Format = format[1],
     duration_strings = caml_call1(Format[2], string),
     prefix = caml_call2(Base_String[66], indent, 32);
    function _E_(duration_string, param){
     var
      nested_timing_events = param[4],
      gc_events = param[3],
      description = param[1];
     function _L_(line){return caml_call2(Base[241], cst$3, line);}
     var
      _M_ = timing_events_to_strings(nested_timing_events, indent + 4 | 0),
      _N_ = caml_call2(Base_List[53], _M_, _L_),
      _O_ = caml_call2(Base_String[68], 0, _N_),
      compactions = gc_events[3],
      major_collections = gc_events[2],
      minor_collections = gc_events[1];
     function to_list(description, count){
      if(0 === count) return 0;
      var
       _R_ = caml_call2(Base[241], cst$1, description),
       _S_ = caml_call1(Base_Int[12], count);
      return [0, caml_call2(Base[241], _S_, _R_), 0];
     }
     var
      _G_ = to_list(cst_compactions, compactions),
      _H_ = to_list(cst_major_collections, major_collections),
      _I_ = caml_call2(Base[222], _H_, _G_),
      _J_ = to_list(cst_minor_collections, minor_collections),
      strings = caml_call2(Base[222], _J_, _I_);
     if(caml_call1(Base_List[18], strings))
      var _P_ = cst$2;
     else
      var
       _K_ = caml_call2(Base_String[68], _c_, strings),
       _P_ = caml_call2(Base[241], cst_GC, _K_);
     var _Q_ = caml_call2(Base[241], _P_, _O_);
     return [0, duration_string, caml_call2(Base[241], description, _Q_)];
    }
    var list$0 = caml_call3(Base_List[98], duration_strings, list, _E_);
    function _A_(width, param){
     var left = param[1];
     return caml_call2
             (Base_Int[16], width, runtime.caml_ml_string_length(left));
    }
    var left_column_width = caml_call3(Base_List[20], list$0, 0, _A_);
    function _B_(param){
     var right = param[2], left = param[1];
     return caml_call4(Base_Printf[2], _d_, left_column_width, left, right);
    }
    var _C_ = caml_call2(Base_List[53], list$0, _B_), _F_ = Base_List[53];
    return caml_call2
            (_F_,
             _C_,
             function(line){return caml_call2(Base[241], prefix, line);});
   }
   function gc_events(i){
    var
     _x_ = 7 === caml_call2(Base[227], i, 8) ? 1 : 0,
     _y_ = 3 === caml_call2(Base[227], i, 4) ? 1 : 0,
     _z_ = 1 === caml_call2(Base[227], i, 2) ? 1 : 0;
    return [0, _z_, _y_, _x_];
   }
   var
    fake_timing_events =
      [246,
       function(_p_){
        function _q_(i){
         if(0 === caml_call2(Base[227], i + 1 | 0, 4))
          var
           _r_ =
             function(j){
              var
               _v_ = gc_events(j),
               _w_ = caml_call1(Base_Int63[100], 900 * (j + 1 | 0) | 0);
              return [0,
                      caml_call2(Base_Printf[2], _e_, j + 1 | 0),
                      _w_,
                      _v_,
                      0];
             },
           _s_ = caml_call2(Base_List[40], i + 1 | 0, _r_);
         else
          var _s_ = 0;
         var
          _t_ = gc_events(i),
          _u_ = caml_call1(Base_Int63[100], 900 * (i + 1 | 0) | 0);
         return [0, caml_call2(Base_Printf[2], _f_, i + 1 | 0), _u_, _t_, _s_];
        }
        return caml_call2(Base_List[40], 12, _q_);
       }];
   if(am_recording){
    var
     _g_ =
       function(param){
        var timing_events$0 = caml_call1(Base_List[63], module_timer[5]);
        function notify_of_overriding(param){
         return caml_call1(Stdio[9], cst_ppx_module_timer_overridin);
        }
        var string = caml_call4(Base_Option[31], 0, 0, 0, am_recording_value);
        a:
        if(runtime.caml_string_notequal(string, "FAKE_MODULES")){
         try{var Format = format[1], override = caml_call1(Format[1], string);
         }
         catch(_o_){var timing_events = timing_events$0; break a;}
         notify_of_overriding(0);
         var
          _i_ =
            function(index, timing_event){
             var
              _l_ = caml_call1(Base_Int63[100], index + 1 | 0),
              runtime = caml_call2(Base_Int63[47], override, _l_);
             function _m_(index, nested_timing_event){
              var
               _n_ = caml_call1(Base_Int63[100], index + 1 | 0),
               runtime = caml_call2(Base_Int63[47], override, _n_);
              return [0,
                      nested_timing_event[1],
                      runtime,
                      nested_timing_event[3],
                      nested_timing_event[4]];
             }
             var
              nested_timing_events =
                caml_call2(Base_List[41], timing_event[4], _m_);
             return [0,
                     timing_event[1],
                     runtime,
                     timing_event[3],
                     nested_timing_events];
            },
          timing_events = caml_call2(Base_List[41], timing_events$0, _i_);
        }
        else{
         notify_of_overriding(0);
         var _j_ = runtime.caml_obj_tag(fake_timing_events);
         b:
         if(250 === _j_)
          var _k_ = fake_timing_events[1];
         else{
          if(246 !== _j_ && 244 !== _j_){
           var _k_ = fake_timing_events;
           break b;
          }
          var _k_ = caml_call1(CamlinternalLazy[2], fake_timing_events);
         }
         var timing_events = _k_;
        }
        var _h_ = timing_events_to_strings(timing_events, 0);
        return caml_call2(Base_List[19], _h_, Stdio[9]);
       };
    caml_call1(Stdlib[100], _g_);
   }
   var
    Ppx_module_timer_runtime =
      [0,
       am_recording,
       am_recording_environment_varia,
       [0, to_nanoseconds, of_nanoseconds, format],
       record_start$0,
       record_until$0,
       record_definition_start,
       record_definition_until];
   runtime.caml_register_global
    (32, Ppx_module_timer_runtime, "Ppx_module_timer_runtime");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImFtX3JlY29yZGluZ19lbnZpcm9ubWVudF92YXJpYSIsInZhbHVlIiwiYW1fcmVjb3JkaW5nX3ZhbHVlIiwiYW1fcmVjb3JkaW5nIiwidG9fbmFub3NlY29uZHMiLCJ0Iiwib2ZfbmFub3NlY29uZHMiLCJvZl9zdHJpbmciLCJzdHJpbmciLCJ0b19zdHJpbmciLCJuYW5vcyIsInRvX3N0cmluZ193aXRoX3NhbWVfdW5pdCIsImxpc3QiLCJmb3JtYXQiLCJjcmVhdGUiLCJuZXN0ZWRfdGltZXIiLCJyZWNvcmRfc3RhcnQiLCJkZXNjcmlwdGlvbiIsInJlY29yZF91bnRpbCIsInVudGlsIiwic3RhcnQiLCJnY19zdGF0c19hZnRlciIsImdjX3N0YXRzX2JlZm9yZSIsInJ1bnRpbWUiLCJnY19ldmVudHMiLCJuZXN0ZWQkMCIsIm5lc3RlZF90aW1pbmdfZXZlbnRzIiwidGltaW5nX2V2ZW50IiwibmVzdGVkIiwiZGVmaW5pdGlvbl90aW1lciIsIm1vZHVsZV90aW1lciIsInJlY29yZF9zdGFydCQwIiwibW9kdWxlX25hbWUiLCJyZWNvcmRfdW50aWwkMCIsInJlY29yZF9kZWZpbml0aW9uX3N0YXJ0IiwibG9jIiwicmVjb3JkX2RlZmluaXRpb25fdW50aWwiLCJ0aW1pbmdfZXZlbnRzX3RvX3N0cmluZ3MiLCJpbmRlbnQiLCJGb3JtYXQiLCJkdXJhdGlvbl9zdHJpbmdzIiwicHJlZml4IiwiZHVyYXRpb25fc3RyaW5nIiwibGluZSIsImNvbXBhY3Rpb25zIiwibWFqb3JfY29sbGVjdGlvbnMiLCJtaW5vcl9jb2xsZWN0aW9ucyIsInRvX2xpc3QiLCJjb3VudCIsInN0cmluZ3MiLCJsaXN0JDAiLCJ3aWR0aCIsImxlZnQiLCJsZWZ0X2NvbHVtbl93aWR0aCIsInJpZ2h0IiwiaSIsImZha2VfdGltaW5nX2V2ZW50cyIsImoiLCJ0aW1pbmdfZXZlbnRzJDAiLCJub3RpZnlfb2Zfb3ZlcnJpZGluZyIsIm92ZXJyaWRlIiwidGltaW5nX2V2ZW50cyIsImluZGV4IiwibmVzdGVkX3RpbWluZ19ldmVudCJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3BweF9tb2R1bGVfdGltZXIvcnVudGltZS9wcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7O0lBS0lBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBSUYsSUFBTSxJQUNKQyxRQURJO21CQUtKQztRQUFBQSx5QkFKQUQ7O0dBS2UsSUFBZkUsZUFBZSw0QkFEZkQ7WUFNRUUsZUFBZUMsR0FBSSxPQUFKQSxFQUFLO1lBQ3BCQyxlQUFlRCxHQUFJLE9BQUpBLEVBQUs7WUFRbEJFLFVBQVVDO0lBQVMsVUFBQSw2QkFBVEE7SUFBUyxPQUFBO0dBQTZEO1lBQ2hGQyxVQUFVQztJQUFRLFVBQUEsMkJBQVJBO0lBQVEsT0FBQTtHQUE0QjtZQUM5Q0MseUJBQXlCQztJQUFPLGlDQUFQQSxNQUR6Qkg7R0FDMEQ7R0FHbkQsSUFBVEksaUJBTEVOLFdBRUFJO1lBMENGRyxPQUFRQztJQUdxQixVQUFBO0lBRi9CLHFDQURVQTtHQU1UO1lBV0NDLGFBQWFYLEdBQUVZO0lBQ2pCLEdBNUVBZDtLQThFUyxLQUFBLDRCQUhNRTtNQUdiLE1BQUE7S0FIYUEsT0FBRVk7S0FBRlosT0FLbUI7S0FMbkJBLE9BT3FCOzs7O2VBbEZwQ0Y7O0dBa0Y4RTtZQUc1RWUsYUFBYWIsR0FBRVk7SUFDakIsS0F0RkFkLGNBQWUsT0FBZkE7SUF5RmM7S0FBUmdCLFFBQVE7S0FDUkMsUUFMU2Y7S0FNVGdCLGlCQUFpQjtLQUNqQkMsa0JBUFNqQjtLQVFUa0IsVUFBVSwyQkFKVkosT0FDQUM7SUFJRyxLQUFBLDZCQVRNZixNQUFFWTtLQVNmLE1BQUE7SUFFRTtLQURFTzs7UUFKQUgs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QVltQ0csT0FBT25DO2FBQ3JDO2NBQW1DLE1BQUEsNEJBRExtQztjQUMxQnZDLFVBQVUsMkJBSGhCcUM7YUFJRSxhQUdZRSxPQUFNQztjQUNkO2VBQW1DLE1BQUEsNEJBRDNCRDtlQUNKdkMsVUFBVSwyQkFScEJxQztjQVNNO3NCQUZjRztzQkFDVnhDO3NCQURVd0M7c0JBQUFBO2FBRXNCO2FBSnRDO2NBREVyQztnQkFDRiwwQkFIbUNDO2FBU3JDO3FCQVRxQ0E7cUJBQ2pDSjtxQkFEaUNJO3FCQUVqQ0Q7WUFPK0M7VUFsQnhEbUMsZ0JBU0csMEJBYndCSDs7O1NBQzNCQzt3Q0ExQkZIOzs7b0JBQUFBOzs7cUJBQUFBOzs7b0RBQUFBOzthQTZCRUs7O2tCQXBERXhCLHlCQW9ERndCO1FBcUJKLE9BQUE7T0FRMEU7SUFGeEU7Ozs7O09Bak9BMUQ7T0FWQUg7V0FlRUksZ0JBQ0FFLGdCQWFBTztPQW9HRmtCO09BQ0FFO09BQ0FDO09BQ0FFOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBCYXNlXG5tb2R1bGUgR2MgPSBTdGRsaWIuR2NcblxuZXh0ZXJuYWwgX19NT0RVTEVfXyA6IHN0cmluZyA9IFwiJWxvY19NT0RVTEVcIlxuXG5sZXQgYW1fcmVjb3JkaW5nX2Vudmlyb25tZW50X3ZhcmlhYmxlID0gXCJQUFhfTU9EVUxFX1RJTUVSXCJcblxubGV0IGdldF9hbV9yZWNvcmRpbmdfZW52aXJvbm1lbnRfdmFyaWFibGUgKCkgPVxuICAoKiBhdm9pZCBTdGRsaWIuU3lzLmdldGVudl9vcHQgdG8gcHJlc2VydmUgNC4wNC54IGNvbXBhdGliaWxpdHkgKilcbiAgbWF0Y2ggU3RkbGliLlN5cy5nZXRlbnYgYW1fcmVjb3JkaW5nX2Vudmlyb25tZW50X3ZhcmlhYmxlIHdpdGhcbiAgfCB2YWx1ZSAtPiBTb21lIHZhbHVlXG4gIHwgZXhjZXB0aW9uIF8gLT4gTm9uZVxuOztcblxubGV0IGFtX3JlY29yZGluZ192YWx1ZSA9IGdldF9hbV9yZWNvcmRpbmdfZW52aXJvbm1lbnRfdmFyaWFibGUgKClcbmxldCBhbV9yZWNvcmRpbmcgPSBPcHRpb24uaXNfc29tZSBhbV9yZWNvcmRpbmdfdmFsdWVcblxubW9kdWxlIER1cmF0aW9uID0gc3RydWN0XG4gIHR5cGUgdCA9IEludDYzLnRcblxuICBsZXQgdG9fbmFub3NlY29uZHMgdCA9IHRcbiAgbGV0IG9mX25hbm9zZWNvbmRzIHQgPSB0XG5cbiAgbW9kdWxlIHR5cGUgRm9ybWF0ID0gc2lnXG4gICAgdmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiB0XG4gICAgdmFsIHRvX3N0cmluZ193aXRoX3NhbWVfdW5pdCA6IHQgbGlzdCAtPiBzdHJpbmcgbGlzdFxuICBlbmRcblxuICBtb2R1bGUgRGVmYXVsdF9mb3JtYXQgPSBzdHJ1Y3RcbiAgICBsZXQgb2Zfc3RyaW5nIHN0cmluZyA9IFN0cmluZy5jaG9wX3N1ZmZpeF9leG4gc3RyaW5nIH5zdWZmaXg6XCJuc1wiIHw+IEludDYzLm9mX3N0cmluZ1xuICAgIGxldCB0b19zdHJpbmcgbmFub3MgPSBJbnQ2My50b19zdHJpbmcgbmFub3MgXiBcIm5zXCJcbiAgICBsZXQgdG9fc3RyaW5nX3dpdGhfc2FtZV91bml0IGxpc3QgPSBMaXN0Lm1hcCBsaXN0IH5mOnRvX3N0cmluZ1xuICBlbmRcblxuICBsZXQgZm9ybWF0ID0gcmVmIChtb2R1bGUgRGVmYXVsdF9mb3JtYXQgOiBGb3JtYXQpXG5cbiAgbGV0IG9mX3N0cmluZyBzdHJpbmcgPVxuICAgIGxldCAobW9kdWxlIEZvcm1hdCkgPSAhZm9ybWF0IGluXG4gICAgRm9ybWF0Lm9mX3N0cmluZyBzdHJpbmdcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nX3dpdGhfc2FtZV91bml0IHN0cmluZyA9XG4gICAgbGV0IChtb2R1bGUgRm9ybWF0KSA9ICFmb3JtYXQgaW5cbiAgICBGb3JtYXQudG9fc3RyaW5nX3dpdGhfc2FtZV91bml0IHN0cmluZ1xuICA7O1xuZW5kXG5cbm1vZHVsZSBHY19ldmVudHMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IG1pbm9yX2NvbGxlY3Rpb25zIDogaW50XG4gICAgOyBtYWpvcl9jb2xsZWN0aW9ucyA6IGludFxuICAgIDsgY29tcGFjdGlvbnMgOiBpbnRcbiAgICB9XG5lbmRcblxubW9kdWxlIFRpbWluZ19ldmVudCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgZGVzY3JpcHRpb24gOiBzdHJpbmdcbiAgICA7IHJ1bnRpbWUgOiBEdXJhdGlvbi50XG4gICAgOyBnY19ldmVudHMgOiBHY19ldmVudHMudFxuICAgIDsgbmVzdGVkX3RpbWluZ19ldmVudHMgOiB0IGxpc3RcbiAgICB9XG5lbmRcblxubW9kdWxlIFRpbWVyID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBtdXRhYmxlIGN1cnJlbnRseV9ydW5uaW5nX2Rlc2NyaXB0aW9uIDogc3RyaW5nXG4gICAgOyBtdXRhYmxlIGN1cnJlbnRseV9ydW5uaW5nX3N0YXJ0X3RpbWUgOiBEdXJhdGlvbi50XG4gICAgOyBtdXRhYmxlIGN1cnJlbnRseV9ydW5uaW5nX2djX3N0YXRzIDogR2Muc3RhdFxuICAgIDsgbXV0YWJsZSBuZXN0ZWRfdGltZXIgOiB0IG9wdGlvblxuICAgIDsgbXV0YWJsZSB0aW1pbmdfZXZlbnRzX2luX3JldmVyc2VfY2hyb25vbG9naWNhbF9vcmRlciA6IFRpbWluZ19ldmVudC50IGxpc3RcbiAgICB9XG5cbiAgbGV0IGNyZWF0ZSA/bmVzdGVkX3RpbWVyICgpID1cbiAgICB7IGN1cnJlbnRseV9ydW5uaW5nX2Rlc2NyaXB0aW9uID0gXCJcIlxuICAgIDsgY3VycmVudGx5X3J1bm5pbmdfc3RhcnRfdGltZSA9IEludDYzLnplcm9cbiAgICA7IGN1cnJlbnRseV9ydW5uaW5nX2djX3N0YXRzID0gR2MucXVpY2tfc3RhdCAoKVxuICAgIDsgbmVzdGVkX3RpbWVyXG4gICAgOyB0aW1pbmdfZXZlbnRzX2luX3JldmVyc2VfY2hyb25vbG9naWNhbF9vcmRlciA9IFtdXG4gICAgfVxuICA7O1xuXG4gIGxldCByZXNldCB0ID1cbiAgICB0LmN1cnJlbnRseV9ydW5uaW5nX2Rlc2NyaXB0aW9uIDwtIFwiXCI7XG4gICAgdC5jdXJyZW50bHlfcnVubmluZ19zdGFydF90aW1lIDwtIEludDYzLnplcm87XG4gICAgbWF0Y2ggdC5uZXN0ZWRfdGltZXIgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBuZXN0ZWQgLT4gbmVzdGVkLnRpbWluZ19ldmVudHNfaW5fcmV2ZXJzZV9jaHJvbm9sb2dpY2FsX29yZGVyIDwtIFtdXG4gIDs7XG5cbiAgbGV0IHJlY29yZF9zdGFydCB0IGRlc2NyaXB0aW9uID1cbiAgICBpZiBhbV9yZWNvcmRpbmdcbiAgICB0aGVuIChcbiAgICAgIGFzc2VydCAoU3RyaW5nLmlzX2VtcHR5IHQuY3VycmVudGx5X3J1bm5pbmdfZGVzY3JpcHRpb24pO1xuICAgICAgdC5jdXJyZW50bHlfcnVubmluZ19kZXNjcmlwdGlvbiA8LSBkZXNjcmlwdGlvbjtcbiAgICAgIHQuY3VycmVudGx5X3J1bm5pbmdfZ2Nfc3RhdHMgPC0gR2MucXVpY2tfc3RhdCAoKTtcbiAgICAgICgqIGNhbGwgW1RpbWVfbm93XSBhcyBsYXRlIGFzIHBvc3NpYmxlIGJlZm9yZSBydW5uaW5nIHRoZSBtb2R1bGUgYm9keSAqKVxuICAgICAgdC5jdXJyZW50bHlfcnVubmluZ19zdGFydF90aW1lIDwtIFRpbWVfbm93Lm5hbm9zZWNvbmRfY291bnRlcl9mb3JfdGltaW5nICgpKVxuICA7O1xuXG4gIGxldCByZWNvcmRfdW50aWwgdCBkZXNjcmlwdGlvbiA9XG4gICAgaWYgYW1fcmVjb3JkaW5nXG4gICAgdGhlbiAoXG4gICAgICAoKiBjb21wdXRlIFtUaW1lX25vd10gYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciBydW5uaW5nIHRoZSBtb2R1bGUgYm9keSAqKVxuICAgICAgbGV0IHVudGlsID0gVGltZV9ub3cubmFub3NlY29uZF9jb3VudGVyX2Zvcl90aW1pbmcgKCkgaW5cbiAgICAgIGxldCBzdGFydCA9IHQuY3VycmVudGx5X3J1bm5pbmdfc3RhcnRfdGltZSBpblxuICAgICAgbGV0IGdjX3N0YXRzX2FmdGVyID0gR2MucXVpY2tfc3RhdCAoKSBpblxuICAgICAgbGV0IGdjX3N0YXRzX2JlZm9yZSA9IHQuY3VycmVudGx5X3J1bm5pbmdfZ2Nfc3RhdHMgaW5cbiAgICAgIGxldCBydW50aW1lID0gSW50NjMuKCAtICkgdW50aWwgc3RhcnQgaW5cbiAgICAgIGFzc2VydCAoU3RyaW5nLmVxdWFsIHQuY3VycmVudGx5X3J1bm5pbmdfZGVzY3JpcHRpb24gZGVzY3JpcHRpb24pO1xuICAgICAgbGV0IGdjX2V2ZW50cyA6IEdjX2V2ZW50cy50ID1cbiAgICAgICAgeyBtaW5vcl9jb2xsZWN0aW9ucyA9XG4gICAgICAgICAgICBnY19zdGF0c19hZnRlci5taW5vcl9jb2xsZWN0aW9ucyAtIGdjX3N0YXRzX2JlZm9yZS5taW5vcl9jb2xsZWN0aW9uc1xuICAgICAgICA7IG1ham9yX2NvbGxlY3Rpb25zID1cbiAgICAgICAgICAgIGdjX3N0YXRzX2FmdGVyLm1ham9yX2NvbGxlY3Rpb25zIC0gZ2Nfc3RhdHNfYmVmb3JlLm1ham9yX2NvbGxlY3Rpb25zXG4gICAgICAgIDsgY29tcGFjdGlvbnMgPSBnY19zdGF0c19hZnRlci5jb21wYWN0aW9ucyAtIGdjX3N0YXRzX2JlZm9yZS5jb21wYWN0aW9uc1xuICAgICAgICB9XG4gICAgICBpblxuICAgICAgbGV0IG5lc3RlZF90aW1pbmdfZXZlbnRzID1cbiAgICAgICAgbWF0Y2ggdC5uZXN0ZWRfdGltZXIgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgfCBTb21lIG5lc3RlZCAtPiBMaXN0LnJldiBuZXN0ZWQudGltaW5nX2V2ZW50c19pbl9yZXZlcnNlX2Nocm9ub2xvZ2ljYWxfb3JkZXJcbiAgICAgIGluXG4gICAgICBsZXQgdGltaW5nX2V2ZW50IDogVGltaW5nX2V2ZW50LnQgPVxuICAgICAgICB7IGRlc2NyaXB0aW9uOyBydW50aW1lOyBnY19ldmVudHM7IG5lc3RlZF90aW1pbmdfZXZlbnRzIH1cbiAgICAgIGluXG4gICAgICB0LnRpbWluZ19ldmVudHNfaW5fcmV2ZXJzZV9jaHJvbm9sb2dpY2FsX29yZGVyXG4gICAgICAgIDwtIHRpbWluZ19ldmVudCA6OiB0LnRpbWluZ19ldmVudHNfaW5fcmV2ZXJzZV9jaHJvbm9sb2dpY2FsX29yZGVyO1xuICAgICAgcmVzZXQgdClcbiAgOztcbmVuZFxuXG5sZXQgZGVmaW5pdGlvbl90aW1lciA9IFRpbWVyLmNyZWF0ZSAoKVxubGV0IG1vZHVsZV90aW1lciA9IFRpbWVyLmNyZWF0ZSB+bmVzdGVkX3RpbWVyOmRlZmluaXRpb25fdGltZXIgKClcbmxldCByZWNvcmRfc3RhcnQgbW9kdWxlX25hbWUgPSBUaW1lci5yZWNvcmRfc3RhcnQgbW9kdWxlX3RpbWVyIG1vZHVsZV9uYW1lXG5sZXQgcmVjb3JkX3VudGlsIG1vZHVsZV9uYW1lID0gVGltZXIucmVjb3JkX3VudGlsIG1vZHVsZV90aW1lciBtb2R1bGVfbmFtZVxubGV0IHJlY29yZF9kZWZpbml0aW9uX3N0YXJ0IGxvYyA9IFRpbWVyLnJlY29yZF9zdGFydCBkZWZpbml0aW9uX3RpbWVyIGxvY1xubGV0IHJlY29yZF9kZWZpbml0aW9uX3VudGlsIGxvYyA9IFRpbWVyLnJlY29yZF91bnRpbCBkZWZpbml0aW9uX3RpbWVyIGxvY1xuXG5sZXQgZ2NfZXZlbnRzX3N1ZmZpeF9zdHJpbmdcbiAgKHsgbWlub3JfY29sbGVjdGlvbnM7IG1ham9yX2NvbGxlY3Rpb25zOyBjb21wYWN0aW9ucyB9IDogR2NfZXZlbnRzLnQpXG4gID1cbiAgbGV0IHRvX2xpc3QgZGVzY3JpcHRpb24gY291bnQgPVxuICAgIGlmIGNvdW50ID0gMCB0aGVuIFtdIGVsc2UgWyBJbnQudG9fc3RyaW5nIGNvdW50IF4gXCIgXCIgXiBkZXNjcmlwdGlvbiBdXG4gIGluXG4gIGxldCBzdHJpbmdzID1cbiAgICB0b19saXN0IFwibWlub3IgY29sbGVjdGlvbnNcIiBtaW5vcl9jb2xsZWN0aW9uc1xuICAgIEAgdG9fbGlzdCBcIm1ham9yIGNvbGxlY3Rpb25zXCIgbWFqb3JfY29sbGVjdGlvbnNcbiAgICBAIHRvX2xpc3QgXCJjb21wYWN0aW9uc1wiIGNvbXBhY3Rpb25zXG4gIGluXG4gIGlmIExpc3QuaXNfZW1wdHkgc3RyaW5ncyB0aGVuIFwiXCIgZWxzZSBcIjsgR0M6IFwiIF4gU3RyaW5nLmNvbmNhdCBzdHJpbmdzIH5zZXA6XCIsIFwiXG47O1xuXG5sZXQgd2l0aF9sZWZ0X2NvbHVtbl9yaWdodF9qdXN0aWZpZWQgbGlzdCA9XG4gIGxldCBsZWZ0X2NvbHVtbl93aWR0aCA9XG4gICAgTGlzdC5mb2xkIGxpc3QgfmluaXQ6MCB+ZjooZnVuIHdpZHRoIChsZWZ0LCBfKSAtPiBJbnQubWF4IHdpZHRoIChTdHJpbmcubGVuZ3RoIGxlZnQpKVxuICBpblxuICBMaXN0Lm1hcCBsaXN0IH5mOihmdW4gKGxlZnQsIHJpZ2h0KSAtPlxuICAgIFByaW50Zi5zcHJpbnRmIFwiJSpzICVzXCIgbGVmdF9jb2x1bW5fd2lkdGggbGVmdCByaWdodClcbjs7XG5cbmxldCByZWMgdGltaW5nX2V2ZW50c190b19zdHJpbmdzIGxpc3QgfmluZGVudCA9XG4gIGxldCBkdXJhdGlvbl9zdHJpbmdzID1cbiAgICBMaXN0Lm1hcCBsaXN0IH5mOihmdW4gKHRpbWluZ19ldmVudCA6IFRpbWluZ19ldmVudC50KSAtPiB0aW1pbmdfZXZlbnQucnVudGltZSlcbiAgICB8PiBEdXJhdGlvbi50b19zdHJpbmdfd2l0aF9zYW1lX3VuaXRcbiAgaW5cbiAgbGV0IHByZWZpeCA9IFN0cmluZy5tYWtlIGluZGVudCAnICcgaW5cbiAgTGlzdC5tYXAyX2V4blxuICAgIGR1cmF0aW9uX3N0cmluZ3NcbiAgICBsaXN0XG4gICAgfmY6XG4gICAgICAoZnVuXG4gICAgICAgIGR1cmF0aW9uX3N0cmluZyB7IHJ1bnRpbWUgPSBfOyBkZXNjcmlwdGlvbjsgZ2NfZXZlbnRzOyBuZXN0ZWRfdGltaW5nX2V2ZW50cyB9IC0+XG4gICAgKCBkdXJhdGlvbl9zdHJpbmdcbiAgICAsIGRlc2NyaXB0aW9uXG4gICAgICBeIGdjX2V2ZW50c19zdWZmaXhfc3RyaW5nIGdjX2V2ZW50c1xuICAgICAgXiBTdHJpbmcuY29uY2F0XG4gICAgICAgICAgKExpc3QubWFwXG4gICAgICAgICAgICAgKHRpbWluZ19ldmVudHNfdG9fc3RyaW5ncyBuZXN0ZWRfdGltaW5nX2V2ZW50cyB+aW5kZW50OihpbmRlbnQgKyA0KSlcbiAgICAgICAgICAgICB+ZjooZnVuIGxpbmUgLT4gXCJcXG5cIiBeIGxpbmUpKSApKVxuICB8PiB3aXRoX2xlZnRfY29sdW1uX3JpZ2h0X2p1c3RpZmllZFxuICB8PiBMaXN0Lm1hcCB+ZjooZnVuIGxpbmUgLT4gcHJlZml4IF4gbGluZSlcbjs7XG5cbmxldCBmYWtlX3RpbWluZ19ldmVudHMgPVxuICBsZXQgZ2NfZXZlbnRzIGkgOiBHY19ldmVudHMudCA9XG4gICAgeyBtaW5vcl9jb2xsZWN0aW9ucyA9IChpZiBpICUgMiA9IDEgdGhlbiAxIGVsc2UgMClcbiAgICA7IG1ham9yX2NvbGxlY3Rpb25zID0gKGlmIGkgJSA0ID0gMyB0aGVuIDEgZWxzZSAwKVxuICAgIDsgY29tcGFjdGlvbnMgPSAoaWYgaSAlIDggPSA3IHRoZW4gMSBlbHNlIDApXG4gICAgfVxuICBpblxuICBsYXp5XG4gICAgKExpc3QuaW5pdCAxMiB+ZjooZnVuIGkgOiBUaW1pbmdfZXZlbnQudCAtPlxuICAgICAgIHsgZGVzY3JpcHRpb24gPSBQcmludGYuc3ByaW50ZiBcIkZha2VfX0RlcGVuZGVuY3lfJWRcIiAoaSArIDEpXG4gICAgICAgOyBydW50aW1lID0gSW50NjMub2ZfaW50ICg5MDAgKiAoaSArIDEpKVxuICAgICAgIDsgZ2NfZXZlbnRzID0gZ2NfZXZlbnRzIGlcbiAgICAgICA7IG5lc3RlZF90aW1pbmdfZXZlbnRzID1cbiAgICAgICAgICAgKGlmIChpICsgMSkgJSA0ID0gMFxuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICBMaXN0LmluaXQgKGkgKyAxKSB+ZjooZnVuIGogOiBUaW1pbmdfZXZlbnQudCAtPlxuICAgICAgICAgICAgICAgIHsgZGVzY3JpcHRpb24gPSBQcmludGYuc3ByaW50ZiBcIkxpbmUgJWRcIiAoaiArIDEpXG4gICAgICAgICAgICAgICAgOyBydW50aW1lID0gSW50NjMub2ZfaW50ICg5MDAgKiAoaiArIDEpKVxuICAgICAgICAgICAgICAgIDsgZ2NfZXZlbnRzID0gZ2NfZXZlbnRzIGpcbiAgICAgICAgICAgICAgICA7IG5lc3RlZF90aW1pbmdfZXZlbnRzID0gW11cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgZWxzZSBbXSlcbiAgICAgICB9KSlcbjs7XG5cbmxldCBwcmludF9yZWNvcmRlZF90aW1pbmdfZXZlbnRzIHRpbWluZ19ldmVudHMgPVxuICBsZXQgbm90aWZ5X29mX292ZXJyaWRpbmcgKCkgPVxuICAgIFN0ZGlvLnByaW50X2VuZGxpbmUgXCJwcHhfbW9kdWxlX3RpbWVyOiBvdmVycmlkaW5nIHRpbWUgbWVhc3VyZW1lbnRzIGZvciB0ZXN0aW5nXCJcbiAgaW5cbiAgbGV0IHRpbWluZ19ldmVudHMgPVxuICAgIG1hdGNoIE9wdGlvbi52YWx1ZV9leG4gYW1fcmVjb3JkaW5nX3ZhbHVlIHdpdGhcbiAgICB8IFwiRkFLRV9NT0RVTEVTXCIgLT5cbiAgICAgIG5vdGlmeV9vZl9vdmVycmlkaW5nICgpO1xuICAgICAgZm9yY2UgZmFrZV90aW1pbmdfZXZlbnRzXG4gICAgfCBzdHJpbmcgLT5cbiAgICAgIChtYXRjaCBEdXJhdGlvbi5vZl9zdHJpbmcgc3RyaW5nIHdpdGhcbiAgICAgICB8IG92ZXJyaWRlIC0+XG4gICAgICAgICBub3RpZnlfb2Zfb3ZlcnJpZGluZyAoKTtcbiAgICAgICAgIExpc3QubWFwaSB0aW1pbmdfZXZlbnRzIH5mOihmdW4gaW5kZXggKHRpbWluZ19ldmVudCA6IFRpbWluZ19ldmVudC50KSAtPlxuICAgICAgICAgICBsZXQgcnVudGltZSA9IEludDYzLiggKiApIG92ZXJyaWRlIChJbnQ2My5vZl9pbnQgKGluZGV4ICsgMSkpIGluXG4gICAgICAgICAgIGxldCBuZXN0ZWRfdGltaW5nX2V2ZW50cyA9XG4gICAgICAgICAgICAgTGlzdC5tYXBpXG4gICAgICAgICAgICAgICB0aW1pbmdfZXZlbnQubmVzdGVkX3RpbWluZ19ldmVudHNcbiAgICAgICAgICAgICAgIH5mOihmdW4gaW5kZXggbmVzdGVkX3RpbWluZ19ldmVudCAtPlxuICAgICAgICAgICAgICAgbGV0IHJ1bnRpbWUgPSBJbnQ2My4oICogKSBvdmVycmlkZSAoSW50NjMub2ZfaW50IChpbmRleCArIDEpKSBpblxuICAgICAgICAgICAgICAgeyBuZXN0ZWRfdGltaW5nX2V2ZW50IHdpdGggcnVudGltZSB9KVxuICAgICAgICAgICBpblxuICAgICAgICAgICB7IHRpbWluZ19ldmVudCB3aXRoIHJ1bnRpbWU7IG5lc3RlZF90aW1pbmdfZXZlbnRzIH0pXG4gICAgICAgfCBleGNlcHRpb24gXyAtPiB0aW1pbmdfZXZlbnRzKVxuICBpblxuICB0aW1pbmdfZXZlbnRzIHw+IHRpbWluZ19ldmVudHNfdG9fc3RyaW5ncyB+aW5kZW50OjAgfD4gTGlzdC5pdGVyIH5mOlN0ZGlvLnByaW50X2VuZGxpbmVcbjs7XG5cbmxldCAoKSA9XG4gIGlmIGFtX3JlY29yZGluZ1xuICB0aGVuXG4gICAgU3RkbGliLmF0X2V4aXQgKGZ1biAoKSAtPlxuICAgICAgcHJpbnRfcmVjb3JkZWRfdGltaW5nX2V2ZW50c1xuICAgICAgICAoTGlzdC5yZXYgbW9kdWxlX3RpbWVyLnRpbWluZ19ldmVudHNfaW5fcmV2ZXJzZV9jaHJvbm9sb2dpY2FsX29yZGVyKSlcbjs7XG4iXX0=
