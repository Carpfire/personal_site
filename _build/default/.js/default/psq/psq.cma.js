// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Psq
//# unitInfo: Requires: Stdlib, Stdlib__Format, Stdlib__List, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    cst$0 = "@ ",
    cst_src_psq_ml = "src/psq.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    pf = Stdlib_Format[137],
    _h_ =
      [0,
       [12,
        40,
        [18,
         [1, [0, 0, cst]],
         [15, [12, 44, [17, [0, cst$0, 1, 0], [15, [17, 0, [12, 41, 0]]]]]]]],
       "(@[%a,@ %a@])"],
    _g_ = [0, [12, 59, [17, [0, cst$0, 1, 0], 0]], ";@ "],
    _i_ =
      [0, [11, "of_sorted_list [", [15, [12, 93, 0]]], "of_sorted_list [%a]"],
    _f_ = [0, [18, [1, [0, 0, cst]], [15, [17, 0, 0]]], "@[%a@]"],
    _e_ = [0, 0, 0],
    _d_ = [0, cst_src_psq_ml, 113, 10],
    _c_ = [0, cst_src_psq_ml, 108, 10],
    _b_ = [0, cst_src_psq_ml, 103, 10],
    _a_ = [0, cst_src_psq_ml, 96, 10];
   function Make(K, P){
    var empty = 0;
    function sg(kp){var k = kp[1]; return [0, kp, k, 0];}
    function is_empty(param){return param ? 0 : 1;}
    function size_t(param){
     if(typeof param === "number") return 0;
     var w = param[5];
     return w;
    }
    function size(param){
     if(! param) return 0;
     var t = param[3];
     return size_t(t) + 1 | 0;
    }
    function nd(kp, t1, sk, t2){
     var k = kp[1];
     if(0 < caml_call2(K[1], k, sk)){
      var _ad_ = size_t(t2);
      return [1, kp, t1, sk, t2, (size_t(t1) + _ad_ | 0) + 1 | 0];
     }
     var _ac_ = size_t(t2);
     return [0, kp, t1, sk, t2, (size_t(t1) + _ac_ | 0) + 1 | 0];
    }
    function outweighs(s1, s2){
     return (s2 * 375 | 0) < (s1 * 100 | 0) ? 1 : 0;
    }
    function symbol(param, _ab_){
     var
      p2 = _ab_[2],
      k2 = _ab_[1],
      p1 = param[2],
      k1 = param[1],
      c = caml_call2(P[1], p1, p2);
     return 0 === c ? caml_call2(K[1], k1, k2) <= 0 ? 1 : 0 : c < 0 ? 1 : 0;
    }
    function rot_l(kp1, t1, sk1, param){
     if(typeof param === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     if(0 === param[0]){
      var kp2 = param[1], t3 = param[4], sk2 = param[3], t2 = param[2];
      if(symbol(kp1, kp2)) return nd(kp1, nd(kp2, t1, sk1, t2), sk2, t3);
      var t3$0 = param[4], sk2$0 = param[3], t2$0 = param[2], kp2$0 = kp2;
     }
     else
      var
       t3$1 = param[4],
       sk2$1 = param[3],
       t2$1 = param[2],
       kp2$1 = param[1],
       t3$0 = t3$1,
       sk2$0 = sk2$1,
       t2$0 = t2$1,
       kp2$0 = kp2$1;
     return nd(kp2$0, nd(kp1, t1, sk1, t2$0), sk2$0, t3$0);
    }
    function rot_r(kp1, tt, sk2, t3){
     if(typeof tt === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     if(0 === tt[0])
      var t2 = tt[4], sk1 = tt[3], t1 = tt[2], kp2 = tt[1];
     else{
      var kp2$0 = tt[1], t2$0 = tt[4], sk1$0 = tt[3], t1$0 = tt[2];
      if(symbol(kp1, kp2$0))
       return nd(kp1, t1$0, sk1$0, nd(kp2$0, t2$0, sk2, t3));
      var
       t2$1 = tt[4],
       sk1$1 = tt[3],
       t1$1 = tt[2],
       t2 = t2$1,
       sk1 = sk1$1,
       t1 = t1$1,
       kp2 = kp2$0;
     }
     return nd(kp2, t1, sk1, nd(kp1, t2, sk2, t3));
    }
    function nd_bal(kp1, t1$0, sk1$0, t2$1){
     var s1 = size_t(t1$0), s2 = size_t(t2$1);
     if(typeof t1$0 !== "number"){
      var t12 = t1$0[4], t11 = t1$0[2];
      if(1 < s1 && outweighs(s1, s2)){
       var _aa_ = size_t(t12);
       if(_aa_ < size_t(t11)) return rot_r(kp1, t1$0, sk1$0, t2$1);
       if(typeof t1$0 === "number")
        throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
       var t2$0 = t1$0[4], sk1 = t1$0[3], t1 = t1$0[2], kp2$0 = t1$0[1];
       return rot_r(kp1, rot_l(kp2$0, t1, sk1, t2$0), sk1$0, t2$1);
      }
     }
     if(typeof t2$1 !== "number"){
      var t22 = t2$1[4], t21 = t2$1[2];
      if(1 < s2 && outweighs(s2, s1)){
       var _$_ = size_t(t22);
       if(size_t(t21) < _$_) return rot_l(kp1, t1$0, sk1$0, t2$1);
       if(typeof t2$1 === "number")
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       var t3 = t2$1[4], sk2 = t2$1[3], t2 = t2$1[2], kp2 = t2$1[1];
       return rot_l(kp1, t1$0, sk1$0, rot_r(kp2, t2, sk2, t3));
      }
     }
     return nd(kp1, t1$0, sk1$0, t2$1);
    }
    function symbol$0(t1, t2){
     if(t1){
      if(t2){
       var
        t2$0 = t2[3],
        sk2 = t2[2],
        kp2 = t2[1],
        t1$0 = t1[3],
        sk1 = t1[2],
        kp1 = t1[1];
       return symbol(kp1, kp2)
               ? [0, kp1, sk2, nd_bal(kp2, t1$0, sk1, t2$0)]
               : [0, kp2, sk2, nd_bal(kp1, t1$0, sk1, t2$0)];
      }
      var t = t1;
     }
     else
      var t = t2;
     return t;
    }
    function symbol$1(kp1, kp2){
     var k2 = kp2[1], k1 = kp1[1];
     return symbol(kp1, kp2)
             ? [0, kp1, k2, [1, kp2, 0, k1, 0, 1]]
             : [0, kp2, k2, [0, kp1, 0, k1, 0, 1]];
    }
    function promote(sk0, param){
     if(typeof param === "number") return 0;
     if(0 === param[0]){
      var t2 = param[4], sk = param[3], t1 = param[2], kp = param[1];
      return symbol$0([0, kp, sk, t1], promote(sk0, t2));
     }
     var t2$0 = param[4], sk$0 = param[3], t1$0 = param[2], kp$0 = param[1];
     return symbol$0(promote(sk$0, t1$0), [0, kp$0, sk0, t2$0]);
    }
    function min(param){
     if(! param) return 0;
     var kp = param[1];
     return [0, kp];
    }
    function rest(param){
     if(! param) return 0;
     var t = param[3], sk = param[2];
     return [0, promote(sk, t)];
    }
    function pop(param){
     if(! param) return 0;
     var t = param[3], sk = param[2], kp = param[1];
     return [0, [0, kp, promote(sk, t)]];
    }
    function find(k0, t){
     if(! t) return 0;
     var t$0 = t[3], match$0 = t[1], p$0 = match$0[2], k$0 = match$0[1];
     if(0 === caml_call2(K[1], k0, k$0)) return [0, p$0];
     var param = t$0;
     for(;;){
      if(typeof param === "number") return 0;
      var
       t2 = param[4],
       sk = param[3],
       t1 = param[2],
       match = param[1],
       p = match[2],
       k = match[1];
      if(0 === caml_call2(K[1], k0, k)) return [0, p];
      var param = 0 < caml_call2(K[1], k0, sk) ? t2 : t1;
     }
    }
    function mem(k0, t){
     if(! t) return 0;
     var
      t$0 = t[3],
      k$0 = t[1][1],
      ___ = 0 === caml_call2(K[1], k0, k$0) ? 1 : 0;
     if(___) return ___;
     var param = t$0;
     for(;;){
      if(typeof param === "number") return 0;
      var
       t2 = param[4],
       sk = param[3],
       t1 = param[2],
       k = param[1][1],
       _Z_ = 0 === caml_call2(K[1], k0, k) ? 1 : 0;
      if(_Z_) return _Z_;
      var param = 0 < caml_call2(K[1], k0, sk) ? t2 : t1;
     }
    }
    function foldr_at_most(p0, f, t, z){
     function f1$0(counter, p0, kp, f, z, t){
      var p = kp[2];
      if(0 < caml_call2(P[1], p, p0)) return caml_call1(z, 0);
      if(counter >= 50)
       return caml_trampoline_return(f2$0, [0, p0, kp, f, z, t]);
      var counter$0 = counter + 1 | 0;
      return f2$0(counter$0, p0, kp, f, z, t);
     }
     function f2$0(counter, p0, kp0, f, z, param){
      var z$0 = z, param$0 = param;
      for(;;){
       if(typeof param$0 === "number") return caml_call2(f, kp0, z$0);
       if(0 === param$0[0]){
        var
         t2 = param$0[4],
         t1 = param$0[2],
         kp = param$0[1],
         _Y_ = function(param){return f2(p0, kp0, f, z$0, t2);};
        if(counter >= 50)
         return caml_trampoline_return(f1$0, [0, p0, kp, f, _Y_, t1]);
        var counter$0 = counter + 1 | 0;
        return f1$0(counter$0, p0, kp, f, _Y_, t1);
       }
       var
        t2$0 = param$0[4],
        t1$0 = param$0[2],
        kp$0 = param$0[1],
        z$2 =
          function(z, t2, kp){
           function z$0(param){return f1(p0, kp, f, z, t2);}
           return z$0;
          },
        z$1 = z$2(z$0, t2$0, kp$0),
        z$0 = z$1,
        param$0 = t1$0;
      }
     }
     function f1(p0, kp, f, z, t){
      return caml_trampoline(f1$0(0, p0, kp, f, z, t));
     }
     function f2(p0, kp0, f, z, param){
      return caml_trampoline(f2$0(0, p0, kp0, f, z, param));
     }
     if(! t) return caml_call1(z, 0);
     var t$0 = t[3], kp0 = t[1];
     return f1(p0, kp0, f, z, t$0);
    }
    function fold_at_most(p0, f, z, t){
     function _X_(param){return z;}
     return foldr_at_most
             (p0,
              function(param, a){
               var p = param[2], k = param[1];
               return caml_call3(f, k, p, caml_call1(a, 0));
              },
              t,
              _X_);
    }
    function iter_at_most(p0, f, t){
     function _V_(_W_){return 0;}
     return foldr_at_most
             (p0,
              function(param, i){
               var p = param[2], k = param[1];
               caml_call2(f, k, p);
               return caml_call1(i, 0);
              },
              t,
              _V_);
    }
    function to_seq_at_most(p0, t, param){
     var _U_ = Stdlib_Seq[20];
     return foldr_at_most(p0, function(kp, seq){return [0, kp, seq];}, t, _U_);
    }
    function go(k0, f, kp1, sk1, param){
     var p1 = kp1[2], k1 = kp1[1];
     if(typeof param !== "number"){
      if(0 === param[0]){
       var t2 = param[4], sk2 = param[3], t1 = param[2], kp2 = param[1];
       return 0 < caml_call2(K[1], k0, sk2)
               ? symbol$0([0, kp2, sk2, t1], go(k0, f, kp1, sk1, t2))
               : symbol$0(go(k0, f, kp2, sk2, t1), [0, kp1, sk1, t2]);
      }
      var
       t2$0 = param[4],
       sk2$0 = param[3],
       t1$0 = param[2],
       kp2$0 = param[1];
      return 0 < caml_call2(K[1], k0, sk2$0)
              ? symbol$0([0, kp1, sk2$0, t1$0], go(k0, f, kp2$0, sk1, t2$0))
              : symbol$0(go(k0, f, kp1, sk2$0, t1$0), [0, kp2$0, sk1, t2$0]);
     }
     var c = caml_call2(K[1], k0, k1);
     if(0 === c){
      var match = caml_call1(f, [0, p1]);
      if(! match) return 0;
      var p = match[1];
      if(p === p1) throw Stdlib[3];
      return sg([0, k0, p]);
     }
     var match$0 = caml_call1(f, 0);
     if(! match$0) throw Stdlib[3];
     var p$0 = match$0[1];
     return 0 <= c ? symbol$1(kp1, [0, k0, p$0]) : symbol$1([0, k0, p$0], kp1);
    }
    function update(k0, f, t){
     if(t){
      var t1 = t[3], sk = t[2], kp = t[1];
      try{var _S_ = go(k0, f, kp, sk, t1); return _S_;}
      catch(_T_){
       var _R_ = caml_wrap_exception(_T_);
       if(_R_ === Stdlib[3]) return t;
       throw caml_maybe_attach_backtrace(_R_, 0);
      }
     }
     var match = caml_call1(f, 0);
     if(! match) return 0;
     var p = match[1];
     return sg([0, k0, p]);
    }
    function add(k, p, t){
     return update(k, function(param){return [0, p];}, t);
    }
    function push(k, p, t){
     return update
             (k,
              function(param){
               if(! param) return [0, p];
               var
                p0 = param[1],
                p0$0 = 0 <= caml_call2(P[1], p, p0) ? p0 : p;
               return [0, p0$0];
              },
              t);
    }
    function remove(k, t){return update(k, function(param){return 0;}, t);}
    function adjust(k, f, t){
     return update
             (k,
              function(param){
               if(! param) return 0;
               var p = param[1];
               return [0, caml_call1(f, p)];
              },
              t);
    }
    function go$0(pf, kp1, sk1, param){
     if(typeof param === "number")
      return caml_call2(pf, kp1[1], kp1[2]) ? sg(kp1) : 0;
     if(0 === param[0]){
      var
       t2 = param[4],
       sk2 = param[3],
       t1 = param[2],
       kp2 = param[1],
       _P_ = go$0(pf, kp1, sk1, t2);
      return symbol$0(go$0(pf, kp2, sk2, t1), _P_);
     }
     var
      t2$0 = param[4],
      sk2$0 = param[3],
      t1$0 = param[2],
      kp2$0 = param[1],
      _Q_ = go$0(pf, kp2$0, sk1, t2$0);
     return symbol$0(go$0(pf, kp1, sk2$0, t1$0), _Q_);
    }
    function filter(pf, param){
     if(! param) return 0;
     var t = param[3], sk = param[2], kp = param[1];
     return go$0(pf, kp, sk, t);
    }
    function partition(pf, t){
     var _O_ = filter(function(k, p){return 1 - caml_call2(pf, k, p);}, t);
     return [0, filter(pf, t), _O_];
    }
    function go$1(k0, pk, sk, param){
     if(typeof param === "number")
      return 0 < caml_call2(K[1], pk[1], k0)
              ? [0, empty, sg(pk)]
              : [0, sg(pk), empty];
     if(0 === param[0]){
      var t2 = param[4], sk1 = param[3], t1 = param[2], pk1 = param[1];
      if(0 < caml_call2(K[1], k0, sk1)){
       var match = go$1(k0, pk, sk, t2), t22 = match[2], t21 = match[1];
       return [0, symbol$0([0, pk1, sk1, t1], t21), t22];
      }
      var
       match$0 = go$1(k0, pk1, sk1, t1),
       t12 = match$0[2],
       t11 = match$0[1];
      return [0, t11, symbol$0(t12, [0, pk, sk, t2])];
     }
     var t2$0 = param[4], sk1$0 = param[3], t1$0 = param[2], pk1$0 = param[1];
     if(0 < caml_call2(K[1], k0, sk1$0)){
      var
       match$1 = go$1(k0, pk1$0, sk, t2$0),
       t22$0 = match$1[2],
       t21$0 = match$1[1];
      return [0, symbol$0([0, pk, sk1$0, t1$0], t21$0), t22$0];
     }
     var
      match$2 = go$1(k0, pk, sk1$0, t1$0),
      t12$0 = match$2[2],
      t11$0 = match$2[1];
     return [0, t11$0, symbol$0(t12$0, [0, pk1$0, sk, t2$0])];
    }
    function split_at(k0, param){
     if(! param) return _e_;
     var t = param[3], sk = param[2], pk = param[1];
     return go$1(k0, pk, sk, t);
    }
    var symbol$2 = function _N_(_L_, _M_){return _N_.fun(_L_, _M_);};
    function app(q1, param){
     if(! param) return q1;
     var match = param[3], sk = param[2], kp = param[1], p = kp[2], k = kp[1];
     if(typeof match === "number") return push(k, p, q1);
     a:
     {
      if(0 === match[0]){
       var kp1 = match[1];
       if(typeof match[2] === "number" && typeof match[4] === "number"){var p2 = kp1[2], k2 = kp1[1]; break a;}
       var
        t2 = match[4],
        sk1 = match[3],
        t1 = match[2],
        match$0 = split_at(sk1, q1),
        q12 = match$0[2],
        q11 = match$0[1],
        _J_ = caml_call2(symbol$2, q12, [0, kp, sk, t2]);
       return symbol$0(caml_call2(symbol$2, q11, [0, kp1, sk1, t1]), _J_);
      }
      var kp1$0 = match[1];
      if(typeof match[2] === "number" && typeof match[4] === "number"){var p2 = kp1$0[2], k2 = kp1$0[1]; break a;}
      var
       t2$0 = match[4],
       sk1$0 = match[3],
       t1$0 = match[2],
       match$1 = split_at(sk1$0, q1),
       q12$0 = match$1[2],
       q11$0 = match$1[1],
       _K_ = caml_call2(symbol$2, q12$0, [0, kp1$0, sk, t2$0]);
      return symbol$0(caml_call2(symbol$2, q11$0, [0, kp, sk1$0, t1$0]), _K_);
     }
     return push(k, p, push(k2, p2, q1));
    }
    runtime.caml_update_dummy
     (symbol$2,
      function(q1, q2){
       var _I_ = size(q2);
       return size(q1) < _I_ ? app(q2, q1) : app(q1, q2);
      });
    function group1(param){
     if(! param) return 0;
     var _D_ = param[2], x = param[1];
     if(! _D_) return [0, sg(x), 0];
     var _E_ = _D_[2], y = _D_[1];
     if(! _E_) return [0, symbol$1(x, y), 0];
     var match = _E_[2], z = _E_[1];
     if(match){
      var xs = match[2], w = match[1], _F_ = group1(xs), _G_ = symbol$1(z, w);
      return [0, symbol$0(symbol$1(x, y), _G_), _F_];
     }
     var _H_ = sg(z);
     return [0, symbol$0(symbol$1(x, y), _H_), 0];
    }
    function group2(r){
     if(r){
      var _z_ = r[2];
      if(_z_){
       var _A_ = _z_[2], y = _z_[1], x = r[1];
       if(! _A_) return [0, symbol$0(x, y), 0];
       var match = _A_[2], z = _A_[1];
       if(! match) return [0, symbol$0(symbol$0(x, y), z), 0];
       var
        xs = match[2],
        w = match[1],
        _B_ = group2(xs),
        _C_ = symbol$0(z, w);
       return [0, symbol$0(symbol$0(x, y), _C_), _B_];
      }
     }
     return r;
    }
    function of_sorted_list(xs){
     var ts$1 = group1(xs), ts = ts$1;
     for(;;){
      if(! ts) return 0;
      if(! ts[2]){var t = ts[1]; return t;}
      var ts$0 = group2(ts), ts = ts$0;
     }
    }
    function cmp_kv(param, _y_){
     var
      p2 = _y_[2],
      k2 = _y_[1],
      p1 = param[2],
      k1 = param[1],
      r = caml_call2(K[1], k2, k1);
     return 0 === r ? caml_call2(P[1], p1, p2) : r;
    }
    function of_list(xs){
     var match = caml_call2(Stdlib_List[59], cmp_kv, xs);
     if(! match) return empty;
     var
      kvs$0 = match[2],
      kv$0 = match[1],
      k0$1 = kv$0[1],
      a$1 = [0, kv$0, 0],
      k0 = k0$1,
      a = a$1,
      param = kvs$0;
     for(;;){
      if(! param) return of_sorted_list(a);
      var kvs = param[2], kv = param[1], k0$0 = kv[1];
      if(0 === caml_call2(K[1], k0, k0$0))
       var param = kvs;
      else
       var a$0 = [0, kv, a], k0 = k0$0, a = a$0, param = kvs;
     }
    }
    function of_seq(xs){
     var _w_ = 0;
     function _x_(xs, a){return [0, a, xs];}
     return of_list(caml_call3(Stdlib_Seq[5], _x_, _w_, xs));
    }
    function add_seq(xs, q){
     function _v_(q, param){
      var p = param[2], k = param[1];
      return add(k, p, q);
     }
     return caml_call3(Stdlib_Seq[5], _v_, q, xs);
    }
    function go$2(pk0, f, param){
     var pk0$0 = pk0, param$0 = param;
     for(;;){
      var k0 = pk0$0[2], p0 = pk0$0[1];
      if(typeof param$0 === "number") return caml_call2(f, p0, k0);
      if(0 === param$0[0]){
       var t2 = param$0[4], t1 = param$0[2], pk = param$0[1];
       go$2(pk, f, t1);
       var param$0 = t2;
      }
      else{
       var t2$0 = param$0[4], t1$0 = param$0[2], pk0$1 = param$0[1];
       go$2(pk0$0, f, t1$0);
       var pk0$0 = pk0$1, param$0 = t2$0;
      }
     }
    }
    function iter(f, param){
     if(! param) return 0;
     var t = param[3], pk = param[1];
     return go$2(pk, f, t);
    }
    function go$3(kp0, f, z, param){
     var kp0$0 = kp0, z$0 = z, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return caml_call2(f, kp0$0, z$0);
      if(0 === param$0[0])
       var
        t2 = param$0[4],
        t1 = param$0[2],
        kp0$1 = param$0[1],
        z$1 = go$3(kp0$0, f, z$0, t2),
        kp0$0 = kp0$1,
        z$0 = z$1,
        param$0 = t1;
      else
       var
        t2$0 = param$0[4],
        t1$0 = param$0[2],
        kp = param$0[1],
        z$2 = go$3(kp, f, z$0, t2$0),
        z$0 = z$2,
        param$0 = t1$0;
     }
    }
    function foldr(f, z, param){
     if(! param) return z;
     var t = param[3], kp = param[1];
     return go$3(kp, f, z, t);
    }
    function go$4(kp0, f, z, param){
     var kp0$0 = kp0, z$0 = z, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return caml_call2(f, kp0$0, z$0);
      if(0 === param$0[0])
       var
        t2 = param$0[4],
        t1 = param$0[2],
        kp0$1 = param$0[1],
        z$3 =
          function(z, kp0, t2){
           function z$0(param){return go$4(kp0, f, z, t2);}
           return z$0;
          },
        z$1 = z$3(z$0, kp0$0, t2),
        kp0$0 = kp0$1,
        z$0 = z$1,
        param$0 = t1;
      else
       var
        t2$0 = param$0[4],
        t1$0 = param$0[2],
        kp = param$0[1],
        z$4 =
          function(z, t2, kp){
           function z$0(param){return go$4(kp, f, z, t2);}
           return z$0;
          },
        z$2 = z$4(z$0, t2$0, kp),
        z$0 = z$2,
        param$0 = t1$0;
     }
    }
    function fold(f, z, t){
     return foldr
             (function(param, z){
               var p = param[2], k = param[1];
               return caml_call3(f, k, p, z);
              },
              z,
              t);
    }
    function to_list(t){
     var _u_ = 0;
     return foldr(function(kp, xs){return [0, kp, xs];}, _u_, t);
    }
    function to_seq(t$0, param){
     var z = Stdlib_Seq[20];
     function f(kp, xs){return [0, kp, xs];}
     if(! t$0) return caml_call1(z, 0);
     var t = t$0[3], kp = t$0[1];
     return go$4(kp, f, z, t);
    }
    function symbol$3(xs, ys){
     if(xs){
      if(ys){
       var yt = ys[2], y = ys[1], xt = xs[2], x = xs[1];
       return symbol(x, y)
               ? [0, x, symbol$3(xt, ys)]
               : [0, y, symbol$3(xs, yt)];
      }
      var l = xs;
     }
     else
      var l = ys;
     return l;
    }
    function go$5(param){
     if(typeof param === "number") return 0;
     if(0 === param[0]){
      var t2 = param[4], t1 = param[2], kp2 = param[1], _s_ = go$5(t2);
      return symbol$3([0, kp2, go$5(t1)], _s_);
     }
     var
      t2$0 = param[4],
      t1$0 = param[2],
      kp2$0 = param[1],
      _t_ = [0, kp2$0, go$5(t2$0)];
     return symbol$3(go$5(t1$0), _t_);
    }
    function to_priority_list(param){
     if(! param) return 0;
     var t = param[3], kp = param[1];
     return [0, kp, go$5(t)];
    }
    function to_priority_seq(t, param){
     function symbol$0(n1, n2){
      if(n1){
       if(n2){
        var yt = n2[2], y = n2[1], xt = n1[2], x = n1[1];
        return symbol(x, y)
                ? [0,
                  x,
                  function(param){return symbol$0(caml_call1(xt, 0), n2);}]
                : [0,
                  y,
                  function(param){return symbol$0(n1, caml_call1(yt, 0));}];
       }
       var n = n1;
      }
      else
       var n = n2;
      return n;
     }
     function go(param){
      if(typeof param === "number") return 0;
      if(0 === param[0]){
       var t2 = param[4], t1 = param[2], kp2 = param[1], _q_ = go(t2);
       return symbol$0([0, kp2, function(param){return go(t1);}], _q_);
      }
      var
       t2$0 = param[4],
       t1$0 = param[2],
       kp2$0 = param[1],
       _r_ = [0, kp2$0, function(param){return go(t2$0);}];
      return symbol$0(go(t1$0), _r_);
     }
     if(! t) return 0;
     var t$0 = t[3], kp = t[1];
     return [0, kp, function(param){return go(t$0);}];
    }
    function sg$0(k, p){return sg([0, k, p]);}
    function depth(t){
     function go(param){
      if(typeof param === "number") return 0;
      var t2 = param[4], t1 = param[2], _o_ = go(t2), _p_ = go(t1);
      return caml_call2(Stdlib[17], _p_, _o_) + 1 | 0;
     }
     if(! t) return 0;
     var t$0 = t[3];
     return go(t$0) + 1 | 0;
    }
    function pp(opt, pp, ppf, t){
     if(opt) var sth = opt[1], sep = sth; else var sep = Stdlib_Format[27];
     var first = [0, 1];
     function k(ppf){
      function _m_(k, p){
       if(first[1]) first[1] = 0; else caml_call2(sep, ppf, 0);
       return caml_call2(pp, ppf, [0, k, p]);
      }
      return function(_n_){return iter(_m_, _n_);};
     }
     return caml_call4(pf, ppf, _f_, k, t);
    }
    function pp_dump(ppk, ppp, ppf){
     function sep(ppf, param){return caml_call2(pf, ppf, _g_);}
     function ppkp(ppf, param){
      var p = param[2], k = param[1];
      return caml_call6(pf, ppf, _h_, ppk, k, ppp, p);
     }
     var _j_ = [0, sep];
     return caml_call3
             (pf,
              ppf,
              _i_,
              function(_k_, _l_){return pp(_j_, ppkp, _k_, _l_);});
    }
    return [0,
            empty,
            sg$0,
            symbol$2,
            is_empty,
            size,
            mem,
            find,
            add,
            push,
            remove,
            adjust,
            update,
            split_at,
            min,
            rest,
            pop,
            fold_at_most,
            iter_at_most,
            to_seq_at_most,
            of_list,
            of_sorted_list,
            of_seq,
            add_seq,
            to_list,
            to_seq,
            fold,
            iter,
            to_priority_list,
            to_priority_seq,
            filter,
            partition,
            pp,
            pp_dump,
            depth];
   }
   var Psq = [0, Make];
   runtime.caml_register_global(14, Psq, "Psq");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwc3EuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInBmIiwiZW1wdHkiLCJzZyIsImtwIiwiayIsImlzX2VtcHR5Iiwic2l6ZV90IiwidyIsInNpemUiLCJ0IiwibmQiLCJ0MSIsInNrIiwidDIiLCJvdXR3ZWlnaHMiLCJzMSIsInMyIiwic3ltYm9sIiwicDIiLCJrMiIsInAxIiwiazEiLCJjIiwicm90X2wiLCJrcDEiLCJzazEiLCJrcDIiLCJ0MyIsInNrMiIsInQzJDAiLCJzazIkMCIsInQyJDAiLCJrcDIkMCIsInQzJDEiLCJzazIkMSIsInQyJDEiLCJrcDIkMSIsInJvdF9yIiwidHQiLCJzazEkMCIsInQxJDAiLCJzazEkMSIsInQxJDEiLCJuZF9iYWwiLCJ0MTIiLCJ0MTEiLCJ0MjIiLCJ0MjEiLCJzeW1ib2wkMCIsInN5bWJvbCQxIiwicHJvbW90ZSIsInNrMCIsInNrJDAiLCJrcCQwIiwibWluIiwicmVzdCIsInBvcCIsImZpbmQiLCJrMCIsInQkMCIsInAkMCIsImskMCIsInAiLCJtZW0iLCJmb2xkcl9hdF9tb3N0IiwicDAiLCJmIiwieiIsImYxJDAiLCJmMiQwIiwia3AwIiwieiQwIiwiZjIiLCJmMSIsImZvbGRfYXRfbW9zdCIsImEiLCJpdGVyX2F0X21vc3QiLCJpIiwidG9fc2VxX2F0X21vc3QiLCJzZXEiLCJnbyIsInVwZGF0ZSIsImFkZCIsInB1c2giLCJwMCQwIiwicmVtb3ZlIiwiYWRqdXN0IiwiZ28kMCIsImZpbHRlciIsInBhcnRpdGlvbiIsImdvJDEiLCJwayIsInBrMSIsInBrMSQwIiwidDIyJDAiLCJ0MjEkMCIsInQxMiQwIiwidDExJDAiLCJzcGxpdF9hdCIsInN5bWJvbCQyIiwiYXBwIiwicTEiLCJxMTIiLCJxMTEiLCJrcDEkMCIsInExMiQwIiwicTExJDAiLCJxMiIsImdyb3VwMSIsIngiLCJ5IiwieHMiLCJncm91cDIiLCJyIiwib2Zfc29ydGVkX2xpc3QiLCJ0cyIsImNtcF9rdiIsIm9mX2xpc3QiLCJrdnMkMCIsImt2JDAiLCJrMCQxIiwia3ZzIiwia3YiLCJrMCQwIiwib2Zfc2VxIiwiYWRkX3NlcSIsInEiLCJnbyQyIiwicGswJDAiLCJwazAkMSIsIml0ZXIiLCJnbyQzIiwia3AwJDAiLCJrcDAkMSIsImZvbGRyIiwiZ28kNCIsImZvbGQiLCJ0b19saXN0IiwidG9fc2VxIiwic3ltYm9sJDMiLCJ5cyIsInl0IiwieHQiLCJsIiwiZ28kNSIsInRvX3ByaW9yaXR5X2xpc3QiLCJ0b19wcmlvcml0eV9zZXEiLCJuMSIsIm4yIiwibiIsInNnJDAiLCJkZXB0aCIsInBwIiwib3B0IiwicHBmIiwic3RoIiwic2VwIiwiZmlyc3QiLCJwcF9kdW1wIiwicHBrIiwicHBwIiwicHBrcCJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3BzcS9wc3EubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7OztJQUtJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQTRERUM7YUFDQUMsR0FBR0MsUUFBQ0MsSUFBREQsT0FBZSxXQUFmQSxJQUFDQzthQUVKQyxnQkFBVyxxQkFBK0I7YUFFMUNDO0tBQVMsOEJBQ0w7U0FDV0M7S0FDTSxPQUROQTtJQUNPO2FBRXRCQztLQUFPLFlBQWM7U0FBYUM7S0FBTSxPQUx4Q0gsT0FLa0NHO0lBQWtCO2FBS3BEQyxHQUFHUCxJQUFhUSxJQUFHQyxJQUFHQztTQUFsQlQsSUFBREQ7S0FDRixPQUFBLGlCQURHQyxHQUFlUTtNQUZpQyxXQVJwRE4sT0FVc0JPO01BRkgsV0FFaEJWLElBQWFRLElBQUdDLElBQUdDLEtBVnRCUCxPQVVnQks7O0tBSG9DLFdBUHBETCxPQVVzQk87S0FISCxXQUdoQlYsSUFBYVEsSUFBR0MsSUFBR0MsS0FWdEJQLE9BVWdCSzs7YUFJaEJHLFVBQVVDLElBQUdDO0tBQUssUUFBTEEsaUJBQUhEO0lBQTJCO2FBRXJDRTtLQUNJO01BRGlCQztNQUFK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a0I7WUFHQUU7WUFHQUU7WUE4SEF1QztZQWZBSDtZQTBCQVU7WUFFQUM7WUF3QkFZO1lBQ0FDO1lBRkFGO1lBckJBTjtZQXlCQWU7WUFVQUM7WUF0R0ExRDtZQU9BQztZQXNIQStEO1lBT0FNO1lBZEFQOzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogQ29weXJpZ2h0IChjKSAyMDE2IERhdmlkIEthbG9wZXIgTWVyxaFpbmphay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgIFNlZSBMSUNFTlNFLm1kICopXG5cbnR5cGUgJ2EgZm10ID0gRm9ybWF0LmZvcm1hdHRlciAtPiAnYSAtPiB1bml0XG5cbmxldCBwZiA9IEZvcm1hdC5mcHJpbnRmXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWQgPSBzaWcgdHlwZSB0IHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludCBlbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIHRcbiAgdHlwZSBrXG4gIHR5cGUgcFxuICB2YWwgZW1wdHkgOiB0XG4gIHZhbCBzZyA6IGsgLT4gcCAtPiB0XG4gIHZhbCAoKyspIDogdCAtPiB0IC0+IHRcbiAgdmFsIGlzX2VtcHR5IDogdCAtPiBib29sXG4gIHZhbCBzaXplIDogdCAtPiBpbnRcbiAgdmFsIG1lbSA6IGsgLT4gdCAtPiBib29sXG4gIHZhbCBmaW5kIDogayAtPiB0IC0+IHAgb3B0aW9uXG4gIHZhbCBhZGQgOiBrIC0+IHAgLT4gdCAtPiB0XG4gIHZhbCBwdXNoIDogayAtPiBwIC0+IHQgLT4gdFxuICB2YWwgcmVtb3ZlIDogayAtPiB0IC0+IHRcbiAgdmFsIGFkanVzdCA6IGsgLT4gKHAgLT4gcCkgLT4gdCAtPiB0XG4gIHZhbCB1cGRhdGUgOiBrIC0+IChwIG9wdGlvbiAtPiBwIG9wdGlvbikgLT4gdCAtPiB0XG4gIHZhbCBzcGxpdF9hdCA6IGsgLT4gdCAtPiB0ICogdFxuICB2YWwgbWluIDogdCAtPiAoayAqIHApIG9wdGlvblxuICB2YWwgcmVzdCA6IHQgLT4gdCBvcHRpb25cbiAgdmFsIHBvcCA6IHQgLT4gKChrICogcCkgKiB0KSBvcHRpb25cbiAgdmFsIGZvbGRfYXRfbW9zdCA6IHAgLT4gKGsgLT4gcCAtPiAnYSAtPiAnYSkgLT4gJ2EgLT4gdCAtPiAnYVxuICB2YWwgaXRlcl9hdF9tb3N0IDogcCAtPiAoayAtPiBwIC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICB2YWwgdG9fc2VxX2F0X21vc3QgOiBwIC0+IHQgLT4gKGsgKiBwKSBTZXEudFxuICB2YWwgb2ZfbGlzdCA6IChrICogcCkgbGlzdCAtPiB0XG4gIHZhbCBvZl9zb3J0ZWRfbGlzdCA6IChrICogcCkgbGlzdCAtPiB0XG4gIHZhbCBvZl9zZXEgOiAoayAqIHApIFNlcS50IC0+IHRcbiAgdmFsIGFkZF9zZXEgOiAoayAqIHApIFNlcS50IC0+IHQgLT4gdFxuICB2YWwgdG9fbGlzdCA6IHQgLT4gKGsgKiBwKSBsaXN0XG4gIHZhbCB0b19zZXEgOiB0IC0+IChrICogcCkgU2VxLnRcbiAgdmFsIGZvbGQgOiAoayAtPiBwIC0+ICdhIC0+ICdhKSAtPiAnYSAtPiB0IC0+ICdhXG4gIHZhbCBpdGVyIDogKGsgLT4gcCAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgdmFsIHRvX3ByaW9yaXR5X2xpc3QgOiB0IC0+IChrICogcCkgbGlzdFxuICB2YWwgdG9fcHJpb3JpdHlfc2VxIDogdCAtPiAoayAqIHApIFNlcS50XG4gIHZhbCBmaWx0ZXIgOiAoayAtPiBwIC0+IGJvb2wpIC0+IHQgLT4gdFxuICB2YWwgcGFydGl0aW9uIDogKGsgLT4gcCAtPiBib29sKSAtPiB0IC0+IHQgKiB0XG4gIHZhbCBwcCA6ID9zZXA6KHVuaXQgZm10KSAtPiAoayAqIHApIGZtdCAtPiB0IGZtdFxuICB2YWwgcHBfZHVtcCA6IGsgZm10IC0+IHAgZm10IC0+IHQgZm10XG4gIHZhbCBkZXB0aCA6IHQgLT4gaW50XG5lbmRcblxubW9kdWxlIE1ha2UgKEs6IE9yZGVyZWQpIChQOiBPcmRlcmVkKSA6XG4gIFMgd2l0aCB0eXBlIGsgPSBLLnQgYW5kIHR5cGUgcCA9IFAudCA9XG5zdHJ1Y3RcblxuICB0eXBlIGsgPSBLLnRcbiAgdHlwZSBwID0gUC50XG5cbiAgdHlwZSB0ID0gKCogU0VBUkNIIFBFTk5BTlRTICopXG4gICAgTlxuICB8IFQgb2YgKGsgKiBwKSAqIGsgKiB0cmVlXG5cbiAgYW5kIHRyZWUgPSAoKiBMT1NFUiBUUkVFUywgT0ggTVkgKilcbiAgICBMZlxuICB8IE5kTCBvZiAoayAqIHApICogdHJlZSAqIGsgKiB0cmVlICogaW50XG4gIHwgTmRSIG9mIChrICogcCkgKiB0cmVlICogayAqIHRyZWUgKiBpbnRcblxuICBsZXQgZW1wdHkgPSBOXG4gIGxldCBzZyAoaywgXyBhcyBrcCkgPSBUIChrcCwgaywgTGYpXG5cbiAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gTiAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gIGxldCBzaXplX3QgPSBmdW5jdGlvblxuICAgIExmIC0+IDBcbiAgfCBOZEwgKF8sIF8sIF8sIF8sIHcpXG4gIHwgTmRSIChfLCBfLCBfLCBfLCB3KSAtPiB3XG5cbiAgbGV0IHNpemUgPSBmdW5jdGlvbiBOIC0+IDAgfCBUIChfLCBfLCB0KSAtPiBzaXplX3QgdCArIDFcblxuICBsZXQgbmRfbCBrcCB0MSBzayB0MiA9IE5kTCAoa3AsIHQxLCBzaywgdDIsIHNpemVfdCB0MSArIHNpemVfdCB0MiArIDEpXG4gIGxldCBuZF9yIGtwIHQxIHNrIHQyID0gTmRSIChrcCwgdDEsIHNrLCB0Miwgc2l6ZV90IHQxICsgc2l6ZV90IHQyICsgMSlcblxuICBsZXQgbmQgKGssIF8gYXMga3ApIHQxIHNrIHQyID1cbiAgICBpZiBLLmNvbXBhcmUgayBzayA8PSAwIHRoZW4gbmRfbCBrcCB0MSBzayB0MiBlbHNlIG5kX3Iga3AgdDEgc2sgdDJcblxuXG4gIGxldCBvdXR3ZWlnaHMgczEgczIgPSBzMSAqIDEwMCA+IHMyICogMzc1XG5cbiAgbGV0IChAPD1AKSAoazEsIHAxKSAoazIsIHAyKSA9XG4gICAgbWF0Y2ggUC5jb21wYXJlIHAxIHAyIHdpdGggMCAtPiBLLmNvbXBhcmUgazEgazIgPD0gMCB8IGMgLT4gYyA8IDBcbiAgW0BAaW5saW5lXVxuXG4gIGxldCByb3RfbCBrcDEgdDEgc2sxID0gZnVuY3Rpb25cbiAgICBOZEwgKGtwMiwgdDIsIHNrMiwgdDMsIF8pIHdoZW4ga3AxIEA8PUAga3AyIC0+XG4gICAgICBuZCBrcDEgKG5kIGtwMiB0MSBzazEgdDIpIHNrMiB0M1xuICB8IE5kTCAoa3AyLCB0Miwgc2syLCB0MywgXykgfCBOZFIgKGtwMiwgdDIsIHNrMiwgdDMsIF8pIC0+XG4gICAgICBuZCBrcDIgKG5kIGtwMSB0MSBzazEgdDIpIHNrMiB0M1xuICB8IExmIC0+IGFzc2VydCBmYWxzZVxuXG4gIGxldCByb3RfciBrcDEgdHQgc2syIHQzID0gbWF0Y2ggdHQgd2l0aFxuICAgIE5kUiAoa3AyLCB0MSwgc2sxLCB0MiwgXykgd2hlbiBrcDEgQDw9QCBrcDIgLT5cbiAgICAgIG5kIGtwMSB0MSBzazEgKG5kIGtwMiB0MiBzazIgdDMpXG4gIHwgTmRMIChrcDIsIHQxLCBzazEsIHQyLCBfKSB8IE5kUiAoa3AyLCB0MSwgc2sxLCB0MiwgXykgLT5cbiAgICAgIG5kIGtwMiB0MSBzazEgKG5kIGtwMSB0MiBzazIgdDMpXG4gIHwgTGYgLT4gYXNzZXJ0IGZhbHNlXG5cbiAgbGV0IHJvdF9sbCBrcDEgdDEgc2sxID0gZnVuY3Rpb25cbiAgICBOZEwgKGtwMiwgdDIsIHNrMiwgdDMsIF8pIHwgTmRSIChrcDIsIHQyLCBzazIsIHQzLCBfKSAtPlxuICAgICAgcm90X2wga3AxIHQxIHNrMSAocm90X3Iga3AyIHQyIHNrMiB0MylcbiAgfCBMZiAtPiBhc3NlcnQgZmFsc2VcblxuICBsZXQgcm90X3JyIGtwMSB0dCBzazIgdDMgPSBtYXRjaCB0dCB3aXRoXG4gICAgTmRMIChrcDIsIHQxLCBzazEsIHQyLCBfKSB8IE5kUiAoa3AyLCB0MSwgc2sxLCB0MiwgXykgLT5cbiAgICAgIHJvdF9yIGtwMSAocm90X2wga3AyIHQxIHNrMSB0Mikgc2syIHQzXG4gIHwgTGYgLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogUHJlY29uZDogYXQgbW9zdCBvbmUgb2YgdDEsIHQyIGlzIGF0IG1vc3QgMSBhd2F5IGZyb20gYSBiYWxhbmNlZFxuICAgICBjb25maWd1cmF0aW9uLiAqKVxuICBsZXQgbmRfYmFsIGtwIHQxIHNrIHQyID1cbiAgICBsZXQgczEgPSBzaXplX3QgdDEgYW5kIHMyID0gc2l6ZV90IHQyIGluXG4gICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgKChOZEwgKF8sIHQxMSwgXywgdDEyLCBfKSB8IE5kUiAoXywgdDExLCBfLCB0MTIsIF8pKSwgXylcbiAgICAgIHdoZW4gczEgPiAxICYmIG91dHdlaWdocyBzMSBzMiAtPlxuICAgICAgICBpZiBzaXplX3QgdDExID4gc2l6ZV90IHQxMiB0aGVuXG4gICAgICAgICAgcm90X3Iga3AgdDEgc2sgdDJcbiAgICAgICAgZWxzZSByb3RfcnIga3AgdDEgc2sgdDJcbiAgICB8IChfLCAoTmRMIChfLCB0MjEsIF8sIHQyMiwgXykgfCBOZFIgKF8sIHQyMSwgXywgdDIyLCBfKSkpXG4gICAgICB3aGVuIHMyID4gMSAmJiBvdXR3ZWlnaHMgczIgczEgLT5cbiAgICAgICAgaWYgc2l6ZV90IHQyMSA8IHNpemVfdCB0MjIgdGhlblxuICAgICAgICAgIHJvdF9sIGtwIHQxIHNrIHQyXG4gICAgICAgIGVsc2Ugcm90X2xsIGtwIHQxIHNrIHQyXG4gICAgfCBfIC0+IG5kIGtwIHQxIHNrIHQyXG5cbiAgbGV0ICg+PCkgdDEgdDIgPSBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgKE4sIHQpIHwgKHQsIE4pIC0+IHRcbiAgfCAoVCAoa3AxLCBzazEsIHQxKSwgVCAoa3AyLCBzazIsIHQyKSkgLT5cbiAgICAgIGlmIGtwMSBAPD1AIGtwMiB0aGVuXG4gICAgICAgIFQgKGtwMSwgc2syLCBuZF9iYWwga3AyIHQxIHNrMSB0MilcbiAgICAgIGVsc2UgVCAoa3AyLCBzazIsIG5kX2JhbCBrcDEgdDEgc2sxIHQyKVxuICBbQEBpbmxpbmVdXG5cbiAgbGV0ICg+fDwpIChrMSwgXyBhcyBrcDEpIChrMiwgXyBhcyBrcDIpID1cbiAgICBpZiBrcDEgQDw9QCBrcDIgdGhlblxuICAgICAgVCAoa3AxLCBrMiwgTmRSIChrcDIsIExmLCBrMSwgTGYsIDEpKVxuICAgIGVsc2UgVCAoa3AyLCBrMiwgTmRMIChrcDEsIExmLCBrMSwgTGYsIDEpKVxuICBbQEBpbmxpbmVdXG5cbiAgbGV0IHJlYyBwcm9tb3RlIHNrMCA9IGZ1bmN0aW9uXG4gICAgTGYgLT4gTlxuICB8IE5kTCAoa3AsIHQxLCBzaywgdDIsIF8pIC0+IFQgKGtwLCBzaywgdDEpID48IHByb21vdGUgc2swIHQyXG4gIHwgTmRSIChrcCwgdDEsIHNrLCB0MiwgXykgLT4gcHJvbW90ZSBzayB0MSA+PCBUIChrcCwgc2swLCB0MilcblxuICBsZXQgbWluID0gZnVuY3Rpb24gTiAtPiBOb25lIHwgVCAoa3AsIF8sIF8pIC0+IFNvbWUga3BcbiAgbGV0IHJlc3QgPSBmdW5jdGlvbiBOIC0+IE5vbmUgfCBUIChfLCBzaywgdCkgLT4gU29tZSAocHJvbW90ZSBzayB0KVxuICBsZXQgcG9wID0gZnVuY3Rpb24gTiAtPiBOb25lIHwgVCAoa3AsIHNrLCB0KSAtPiBTb21lIChrcCwgcHJvbW90ZSBzayB0KVxuXG4gIGxldCBmaW5kIGswIHQgPVxuICAgIGxldCByZWMgZ28gazAgPSBmdW5jdGlvblxuICAgICAgTGYgLT4gTm9uZVxuICAgIHwgTmRMICgoaywgcCksIHQxLCBzaywgdDIsIF8pXG4gICAgfCBOZFIgKChrLCBwKSwgdDEsIHNrLCB0MiwgXykgLT5cbiAgICAgICAgaWYgSy5jb21wYXJlIGswIGsgPSAwIHRoZW4gU29tZSBwIGVsc2VcbiAgICAgICAgICBpZiBLLmNvbXBhcmUgazAgc2sgPD0gMCB0aGVuIGdvIGswIHQxIGVsc2UgZ28gazAgdDIgaW5cbiAgICBtYXRjaCB0IHdpdGhcbiAgICAgIE4gLT4gTm9uZVxuICAgIHwgVCAoKGssIHApLCBfLCB0KSAtPiBpZiBLLmNvbXBhcmUgazAgayA9IDAgdGhlbiBTb21lIHAgZWxzZSBnbyBrMCB0XG5cbiAgbGV0IG1lbSBrMCB0ID1cbiAgICBsZXQgcmVjIGdvIGswID0gZnVuY3Rpb25cbiAgICAgIExmIC0+IGZhbHNlXG4gICAgfCBOZEwgKChrLCBfKSwgdDEsIHNrLCB0MiwgXylcbiAgICB8IE5kUiAoKGssIF8pLCB0MSwgc2ssIHQyLCBfKSAtPlxuICAgICAgICBLLmNvbXBhcmUgazAgayA9IDAgfHxcbiAgICAgICAgaWYgSy5jb21wYXJlIGswIHNrIDw9IDAgdGhlbiBnbyBrMCB0MSBlbHNlIGdvIGswIHQyIGluXG4gICAgbWF0Y2ggdCB3aXRoIE4gLT4gZmFsc2UgfCBUICgoaywgXyksIF8sIHQpIC0+IEsuY29tcGFyZSBrMCBrID0gMCB8fCBnbyBrMCB0XG5cbiAgbGV0IGZvbGRyX2F0X21vc3QgcDAgZiB0IHogPVxuICAgIGxldCByZWMgZjEgcDAgKF8sIHAgYXMga3ApIGYgeiB0ID1cbiAgICAgIGlmIFAuY29tcGFyZSBwIHAwIDw9IDAgdGhlbiBmMiBwMCBrcCBmIHogdCBlbHNlIHogKClcbiAgICBhbmQgZjIgcDAga3AwIGYgeiA9IGZ1bmN0aW9uXG4gICAgICBMZiAtPiBmIGtwMCB6XG4gICAgfCBOZEwgKGtwLCB0MSwgXywgdDIsIF8pIC0+IGYxIHAwIGtwIGYgKGZ1biAoKSAtPiBmMiBwMCBrcDAgZiB6IHQyKSB0MVxuICAgIHwgTmRSIChrcCwgdDEsIF8sIHQyLCBfKSAtPiBmMiBwMCBrcDAgZiAoZnVuICgpIC0+IGYxIHAwIGtwIGYgeiB0MikgdDEgaW5cbiAgICBtYXRjaCB0IHdpdGggVCAoa3AwLCBfLCB0KSAtPiBmMSBwMCBrcDAgZiB6IHQgfCBfIC0+IHogKClcblxuICBsZXQgZm9sZF9hdF9tb3N0IHAwIGYgeiB0ID1cbiAgICBmb2xkcl9hdF9tb3N0IHAwIChmdW4gKGssIHApIGEgLT4gZiBrIHAgKGEgKCkpKSB0IChmdW4gKCkgLT4geilcblxuICBsZXQgaXRlcl9hdF9tb3N0IHAwIGYgdCA9XG4gICAgZm9sZHJfYXRfbW9zdCBwMCAoZnVuIChrLCBwKSBpIC0+IGYgayBwOyBpICgpKSB0IGlnbm9yZVxuXG4gIGxldCB0b19zZXFfYXRfbW9zdCBwMCB0ICgpID1cbiAgICBmb2xkcl9hdF9tb3N0IHAwIChmdW4ga3Agc2VxIC0+IFNlcS5Db25zIChrcCwgc2VxKSkgdCBTZXEuZW1wdHlcblxuICAoKiB0eXBlIHZpZXcgPSBOdiB8IFNndiBvZiAoayAqIHApIHwgQmludiBvZiB0ICogSy50ICogdCAqKVxuXG4gICgqIGxldCB2aWV3ID0gZnVuY3Rpb24gKilcbiAgKCogICBOIC0+IE52ICopXG4gICgqIHwgVCAoa3AsIF8sIExmKSAtPiBTZ3Yga3AgKilcbiAgKCogfCBUIChrcDEsIHNrMSwgTmRMIChrcDIsIHQxLCBzazIsIHQyLCBfKSkgLT4gKilcbiAgKCogICAgIEJpbnYgKFQgKGtwMiwgc2syLCB0MSksIHNrMiwgVCAoa3AxLCBzazEsIHQyKSkgKilcbiAgKCogfCBUIChrcDEsIHNrMSwgTmRSIChrcDIsIHQxLCBzazIsIHQyLCBfKSkgLT4gKilcbiAgKCogICAgIEJpbnYgKFQgKGtwMSwgc2syLCB0MSksIHNrMiwgVCAoa3AyLCBzazEsIHQyKSkgKilcblxuICAoKiBsZXQgcmVjIGFkZCAoazAsIF8gYXMga3AwKSB0ID0gbWF0Y2ggdmlldyB0IHdpdGggKilcbiAgKCogICB8IE52IC0+IHNnIGtwMCAqKVxuICAoKiAgIHwgU2d2IChrLCBfKSAtPiAqKVxuICAoKiAgICAgICBsZXQgYyA9IEsuY29tcGFyZSBrMCBrIGFuZCB0JyA9IHNnIGtwMCBpbiAqKVxuICAoKiAgICAgICBpZiBjIDwgMCB0aGVuIHQnID48IHQgZWxzZSBpZiBjID4gMCB0aGVuIHQgPjwgdCcgZWxzZSB0JyAqKVxuICAoKiAgIHwgQmludiAodDEsIHNrLCB0MikgLT4gKilcbiAgKCogICAgICAgaWYgSy5jb21wYXJlIGswIHNrIDw9IDAgdGhlbiBhZGQga3AwIHQxID48IHQyIGVsc2UgdDEgPjwgYWRkIGtwMCB0MiAqKVxuXG4gICgqIGxldCByZW1vdmUgazAgdCA9ICopXG4gICgqICAgbGV0IHJlYyBnbyBrMCB0ID0gbWF0Y2ggdmlldyB0IHdpdGggKilcbiAgKCogICAgIEJpbnYgKHQxLCBzaywgdDIpIC0+ICopXG4gICgqICAgICAgIGlmIEsuY29tcGFyZSBrMCBzayA8PSAwIHRoZW4gZ28gazAgdDEgPjwgdDIgZWxzZSB0MSA+PCBnbyBrMCB0MiAqKVxuICAoKiAgIHwgU2d2IChrLCBfKSB3aGVuIEsuY29tcGFyZSBrIGswID0gMCAtPiBOICopXG4gICgqICAgfCBTZ3YgXyB8IE52IC0+IHJhaXNlX25vdHJhY2UgRXhpdCBpbiAqKVxuICAoKiAgIHRyeSBnbyBrMCB0IHdpdGggRXhpdCAtPiB0ICopXG5cbiAgKCogbGV0IGFkanVzdCBrMCBmIHQgPSAqKVxuICAoKiAgIGxldCByZWMgZ28gZiBrMCB0ID0gbWF0Y2ggdmlldyB0IHdpdGggKilcbiAgKCogICAgIEJpbnYgKHQxLCBzaywgdDIpIC0+ICopXG4gICgqICAgICAgIGlmIEsuY29tcGFyZSBrMCBzayA8PSAwIHRoZW4gZ28gZiBrMCB0MSA+fDwgdDIgZWxzZSB0MSA+fDwgZ28gZiBrMCB0MiAqKVxuICAoKiAgIHwgU2d2IChrLCBwKSB3aGVuIEsuY29tcGFyZSBrIGswID0gMCAtPiBzZyAoaywgZiBwKSAqKVxuICAoKiAgIHwgU2d2IF8gfCBOdiAtPiByYWlzZV9ub3RyYWNlIEV4aXQgaW4gKilcbiAgKCogICB0cnkgZ28gZiBrMCB0IHdpdGggRXhpdCAtPiB0ICopXG5cbiAgKCogbGV0IHJlYyBmaWx0ZXIgcGYgdCA9IG1hdGNoIHZpZXcgdCB3aXRoICopXG4gICgqICAgTnYgLT4gTiAqKVxuICAoKiB8IFNndiAoaywgcCBhcyBrcCkgLT4gaWYgcGYgayBwIHRoZW4gc2cga3AgZWxzZSBOICopXG4gICgqIHwgQmludiAodDEsIF8sIHQyKSAtPiBmaWx0ZXIgcGYgdDEgPjwgZmlsdGVyIHBmIHQyICopXG5cbiAgbGV0IHVwZGF0ZSA9XG4gICAgbGV0IHJlYyBnbyBrMCBmIChrMSwgcDEgYXMga3AxKSBzazEgPSBmdW5jdGlvblxuICAgICAgTGYgLT5cbiAgICAgICAgbGV0IGMgPSBLLmNvbXBhcmUgazAgazEgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgIG1hdGNoIGYgKFNvbWUgcDEpIHdpdGhcbiAgICAgICAgICB8IFNvbWUgcCB3aGVuIHAgPT0gcDEgLT4gcmFpc2Vfbm90cmFjZSBFeGl0XG4gICAgICAgICAgfCBTb21lIHAgLT4gc2cgKGswLCBwKVxuICAgICAgICAgIHwgTm9uZSAtPiBOXG4gICAgICAgIGVsc2UgKCBtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgIHwgU29tZSBwIHdoZW4gYyA8IDAgLT4gKGswLCBwKSA+fDwga3AxXG4gICAgICAgICAgfCBTb21lIHAgLT4ga3AxID58PCAoazAsIHApXG4gICAgICAgICAgfCBOb25lIC0+IHJhaXNlX25vdHJhY2UgRXhpdCApXG4gICAgfCBOZEwgKGtwMiwgdDEsIHNrMiwgdDIsIF8pIC0+XG4gICAgICAgIGlmIEsuY29tcGFyZSBrMCBzazIgPD0gMCB0aGVuXG4gICAgICAgICAgZ28gazAgZiBrcDIgc2syIHQxID48IFQgKGtwMSwgc2sxLCB0MilcbiAgICAgICAgZWxzZSBUIChrcDIsIHNrMiwgdDEpID48IGdvIGswIGYga3AxIHNrMSB0MlxuICAgIHwgTmRSIChrcDIsIHQxLCBzazIsIHQyLCBfKSAtPlxuICAgICAgICBpZiBLLmNvbXBhcmUgazAgc2syIDw9IDAgdGhlblxuICAgICAgICAgIGdvIGswIGYga3AxIHNrMiB0MSA+PCBUIChrcDIsIHNrMSwgdDIpXG4gICAgICAgIGVsc2UgVCAoa3AxLCBzazIsIHQxKSA+PCBnbyBrMCBmIGtwMiBzazEgdDIgaW5cbiAgICBmdW4gazAgZiAtPiBmdW5jdGlvblxuICAgIHwgTiAtPiAobWF0Y2ggZiBOb25lIHdpdGggU29tZSBwIC0+IHNnIChrMCwgcCkgfCBfIC0+IE4pXG4gICAgfCBUIChrcCwgc2ssIHQxKSBhcyB0IC0+IHRyeSBnbyBrMCBmIGtwIHNrIHQxIHdpdGggRXhpdCAtPiB0XG5cbiAgbGV0IGFkZCBrIHAgdCA9IHVwZGF0ZSBrIChmdW4gXyAtPiBTb21lIHApIHRcbiAgbGV0IHB1c2ggayBwIHQgPSB1cGRhdGUgayAoZnVuY3Rpb25cbiAgICB8IFNvbWUgcDAgLT4gU29tZSAoaWYgUC5jb21wYXJlIHAgcDAgPCAwIHRoZW4gcCBlbHNlIHAwKVxuICAgIHwgTm9uZSAtPiBTb21lIHApIHRcbiAgbGV0IHJlbW92ZSBrIHQgPSB1cGRhdGUgayAoZnVuIF8gLT4gTm9uZSkgdFxuICBsZXQgYWRqdXN0IGsgZiB0ID0gdXBkYXRlIGsgKGZ1bmN0aW9uIFNvbWUgcCAtPiBTb21lIChmIHApIHwgXyAtPiBOb25lKSB0XG5cbiAgbGV0IGZpbHRlciA9XG4gICAgbGV0IHJlYyBnbyBwZiBrcDEgc2sxID0gZnVuY3Rpb25cbiAgICAgIExmIC0+IGlmIHBmIChmc3Qga3AxKSAoc25kIGtwMSkgdGhlbiBzZyBrcDEgZWxzZSBOXG4gICAgfCBOZEwgKGtwMiwgdDEsIHNrMiwgdDIsIF8pIC0+IGdvIHBmIGtwMiBzazIgdDEgPjwgZ28gcGYga3AxIHNrMSB0MlxuICAgIHwgTmRSIChrcDIsIHQxLCBzazIsIHQyLCBfKSAtPiBnbyBwZiBrcDEgc2syIHQxID48IGdvIHBmIGtwMiBzazEgdDIgaW5cbiAgICBmdW4gcGYgLT4gZnVuY3Rpb24gTiAtPiBOIHwgVCAoa3AsIHNrLCB0KSAtPiBnbyBwZiBrcCBzayB0XG5cbiAgbGV0IHBhcnRpdGlvbiBwZiB0ID0gZmlsdGVyIHBmIHQsIGZpbHRlciAoZnVuIGsgcCAtPiBub3QgKHBmIGsgcCkpIHRcblxuICBsZXQgc3BsaXRfYXQgPVxuICAgIGxldCByZWMgZ28gazAgcGsgc2sgPSBmdW5jdGlvblxuICAgIHwgTGYgLT4gaWYgSy5jb21wYXJlIChmc3QgcGspIGswIDw9IDAgdGhlbiBzZyBwaywgZW1wdHkgZWxzZSBlbXB0eSwgc2cgcGtcbiAgICB8IE5kTCAocGsxLCB0MSwgc2sxLCB0MiwgXykgLT5cbiAgICAgICAgaWYgSy5jb21wYXJlIGswIHNrMSA8PSAwIHRoZW5cbiAgICAgICAgICBsZXQgdDExLCB0MTIgPSBnbyBrMCBwazEgc2sxIHQxIGluIHQxMSwgdDEyID48IFQgKHBrLCBzaywgdDIpXG4gICAgICAgIGVsc2UgbGV0IHQyMSwgdDIyID0gZ28gazAgcGsgc2sgdDIgaW4gVCAocGsxLCBzazEsIHQxKSA+PCB0MjEsIHQyMlxuICAgIHwgTmRSIChwazEsIHQxLCBzazEsIHQyLCBfKSAtPlxuICAgICAgICBpZiBLLmNvbXBhcmUgazAgc2sxIDw9IDAgdGhlblxuICAgICAgICAgIGxldCB0MTEsIHQxMiA9IGdvIGswIHBrIHNrMSB0MSBpbiB0MTEsIHQxMiA+PCBUIChwazEsIHNrLCB0MilcbiAgICAgICAgZWxzZSBsZXQgdDIxLCB0MjIgPSBnbyBrMCBwazEgc2sgdDIgaW4gVCAocGssIHNrMSwgdDEpID48IHQyMSwgdDIyIGluXG4gICAgZnVuIGswIC0+IGZ1bmN0aW9uIE4gLT4gTiwgTiB8IFQgKHBrLCBzaywgdCkgLT4gZ28gazAgcGsgc2sgdFxuXG4gIGxldCByZWMgKCsrKSA9XG4gICAgbGV0IGFwcCBxMSA9IGZ1bmN0aW9uXG4gICAgfCBOIC0+IHExXG4gICAgfCBUICgoaywgcCksIF8sIExmKSAtPiBwdXNoIGsgcCBxMVxuICAgIHwgVCAoKGsxLCBwMSksIF8sXG4gICAgICAgICAoTmRMICgoazIsIHAyKSwgTGYsIF8sIExmLCBfKSB8XG4gICAgICAgICAgTmRSICgoazIsIHAyKSwgTGYsIF8sIExmLCBfKSkpIC0+IHB1c2ggazEgcDEgKHB1c2ggazIgcDIgcTEpXG4gICAgfCBUIChrcCwgc2ssIE5kTCAoa3AxLCB0MSwgc2sxLCB0MiwgXykpIC0+XG4gICAgICAgIGxldCBxMTEsIHExMiA9IHNwbGl0X2F0IHNrMSBxMSBpblxuICAgICAgICAocTExICsrIFQgKGtwMSwgc2sxLCB0MSkpID48IChxMTIgKysgVCAoa3AsIHNrLCB0MikpXG4gICAgfCBUIChrcCwgc2ssIE5kUiAoa3AxLCB0MSwgc2sxLCB0MiwgXykpIC0+XG4gICAgICAgIGxldCBxMTEsIHExMiA9IHNwbGl0X2F0IHNrMSBxMSBpblxuICAgICAgICAocTExICsrIFQgKGtwLCBzazEsIHQxKSkgPjwgKHExMiArKyBUIChrcDEsIHNrLCB0MikpIGluXG4gICAgZnVuIHExIHEyIC0+IGlmIHNpemUgcTEgPCBzaXplIHEyIHRoZW4gYXBwIHEyIHExIGVsc2UgYXBwIHExIHEyXG5cbiAgbGV0IG9mX3NvcnRlZF9saXN0ID1cbiAgICBsZXQgcmVjIGdyb3VwMSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgW3hdIC0+IFtzZyB4XVxuICAgIHwgW3g7eV0gLT4gW3ggPnw8IHldXG4gICAgfCBbeDt5O3pdIC0+IFsoeCA+fDwgeSkgPjwgc2cgel1cbiAgICB8IHg6Onk6Ono6Onc6OnhzIC0+ICgoeCA+fDwgeSkgPjwgKHogPnw8IHcpKSA6OiBncm91cDEgeHNcbiAgICBhbmQgZ3JvdXAyID0gZnVuY3Rpb25cbiAgICB8IFtdIHwgW19dIGFzIHIgLT4gclxuICAgIHwgW3g7eV0gLT4gW3ggPjwgeV1cbiAgICB8IFt4O3k7el0gLT4gWyh4ID48IHkpID48IHpdXG4gICAgfCB4Ojp5Ojp6Ojp3Ojp4cyAtPiAoKHggPjwgeSkgPjwgKHogPjwgdykpIDo6IGdyb3VwMiB4c1xuICAgIGFuZCBnbyA9IGZ1bmN0aW9uIFtdIC0+IE4gfCBbdF0gLT4gdCB8IHRzIC0+IGdvIChncm91cDIgdHMpIGluXG4gICAgZnVuIHhzIC0+IGdvIChncm91cDEgeHMpXG5cbiAgbGV0IG9mX2xpc3QgPVxuICAgIGxldCByZWMgc2lldmUgazAgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhXG4gICAgfCAoaywgXykgYXMga3YgOjoga3ZzIC0+XG4gICAgICAgIGlmIEsuY29tcGFyZSBrMCBrID0gMCB0aGVuIHNpZXZlIGswIGEga3ZzIGVsc2Ugc2lldmUgayAoa3YgOjogYSkga3ZzIGluXG4gICAgbGV0IGNtcF9rdiAoazEsIHAxKSAoazIsIHAyKSA9XG4gICAgICBtYXRjaCBLLmNvbXBhcmUgazIgazEgd2l0aCAwIC0+IFAuY29tcGFyZSBwMSBwMiB8IHIgLT4gciBpblxuICAgIGZ1biB4cyAtPiBtYXRjaCBMaXN0LnNvcnQgY21wX2t2IHhzIHdpdGhcbiAgICB8IFtdIC0+IGVtcHR5XG4gICAgfCAoaywgXykgYXMga3YgOjoga3ZzIC0+IHNpZXZlIGsgW2t2XSBrdnMgfD4gb2Zfc29ydGVkX2xpc3RcblxuICBsZXQgb2Zfc2VxIHhzID0gU2VxLmZvbGRfbGVmdCAoZnVuIHhzIGEgLT4gYTo6eHMpIFtdIHhzIHw+IG9mX2xpc3RcblxuICBsZXQgYWRkX3NlcSB4cyBxID0gU2VxLmZvbGRfbGVmdCAoZnVuIHEgKGssIHApIC0+IGFkZCBrIHAgcSkgcSB4c1xuXG4gIGxldCBpdGVyID1cbiAgICBsZXQgcmVjIGdvIChwMCwgazAgYXMgcGswKSBmID0gZnVuY3Rpb25cbiAgICAgIExmIC0+IGYgcDAgazBcbiAgICB8IE5kTCAocGssIHQxLCBfLCB0MiwgXykgLT4gZ28gcGsgZiB0MTsgZ28gcGswIGYgdDJcbiAgICB8IE5kUiAocGssIHQxLCBfLCB0MiwgXykgLT4gZ28gcGswIGYgdDE7IGdvIHBrIGYgdDIgaW5cbiAgICBmdW4gZiAtPiBmdW5jdGlvbiBOIC0+ICgpIHwgVCAocGssIF8sIHQpIC0+IGdvIHBrIGYgdFxuXG4gIGxldCBmb2xkciA9XG4gICAgbGV0IHJlYyBnbyBrcDAgZiB6ID0gZnVuY3Rpb25cbiAgICAgIExmIC0+IGYga3AwIHpcbiAgICB8IE5kTCAoa3AsIHQxLCBfLCB0MiwgXykgLT4gZ28ga3AgZiAoZ28ga3AwIGYgeiB0MikgdDFcbiAgICB8IE5kUiAoa3AsIHQxLCBfLCB0MiwgXykgLT4gZ28ga3AwIGYgKGdvIGtwIGYgeiB0MikgdDEgaW5cbiAgICBmdW4gZiB6IC0+IGZ1bmN0aW9uIE4gLT4geiB8IFQgKGtwLCBfLCB0KSAtPiBnbyBrcCBmIHogdFxuXG4gIGxldCBsZm9sZHIgPVxuICAgIGxldCByZWMgZ28ga3AwIGYgeiA9IGZ1bmN0aW9uXG4gICAgICBMZiAtPiBmIGtwMCB6XG4gICAgfCBOZEwgKGtwLCB0MSwgXywgdDIsIF8pIC0+IGdvIGtwIGYgKGZ1biAoKSAtPiBnbyBrcDAgZiB6IHQyKSB0MVxuICAgIHwgTmRSIChrcCwgdDEsIF8sIHQyLCBfKSAtPiBnbyBrcDAgZiAoZnVuICgpIC0+IGdvIGtwIGYgeiB0MikgdDEgaW5cbiAgICBmdW4gZiB6IC0+IGZ1bmN0aW9uIFQgKGtwLCBfLCB0KSAtPiBnbyBrcCBmIHogdCB8IE4gLT4geiAoKVxuXG4gIGxldCBmb2xkIGYgeiB0ID0gZm9sZHIgKGZ1biAoaywgcCkgeiAtPiBmIGsgcCB6KSB6IHRcbiAgbGV0IHRvX2xpc3QgdCA9IGZvbGRyIChmdW4ga3AgeHMgLT4ga3AgOjogeHMpIFtdIHRcbiAgbGV0IHRvX3NlcSB0ICgpID0gbGZvbGRyIChmdW4ga3AgeHMgLT4gU2VxLkNvbnMgKGtwLCB4cykpIFNlcS5lbXB0eSB0XG5cbiAgbGV0IHRvX3ByaW9yaXR5X2xpc3QgPVxuICAgIGxldCByZWMgKC0tKSB4cyB5cyA9IG1hdGNoIHhzLCB5cyB3aXRoXG4gICAgICBbXSwgbCB8IGwsIFtdIC0+IGxcbiAgICB8IHg6Onh0LCB5Ojp5dCAtPiBpZiB4IEA8PUAgeSB0aGVuIHggOjogKHh0IC0tIHlzKSBlbHNlIHkgOjogKHhzIC0tIHl0KSBpblxuICAgIGxldCByZWMgZ28gPSBmdW5jdGlvblxuICAgICAgTGYgLT4gW11cbiAgICB8IE5kTCAoa3AyLCB0MSwgXywgdDIsIF8pIC0+IChrcDIgOjogZ28gdDEpIC0tIGdvIHQyXG4gICAgfCBOZFIgKGtwMiwgdDEsIF8sIHQyLCBfKSAtPiBnbyB0MSAtLSAoa3AyIDo6IGdvIHQyKSBpblxuICAgIGZ1bmN0aW9uIE4gLT4gW10gfCBUIChrcCwgXywgdCkgLT4ga3AgOjogZ28gdFxuXG4gIGxldCB0b19wcmlvcml0eV9zZXEgdCAoKSA9XG4gICAgbGV0IG9wZW4gU2VxIGluXG4gICAgbGV0IHJlYyAoLS0pIG4xIG4yID0gbWF0Y2ggbjEsIG4yIHdpdGhcbiAgICAgIE5pbCwgbiB8IG4sIE5pbCAtPiBuXG4gICAgfCBDb25zICh4LCB4dCksIENvbnMgKHksIHl0KSAtPlxuICAgICAgICBpZiB4IEA8PUAgeSB0aGVuXG4gICAgICAgICAgQ29ucyAoeCwgZnVuIF8gLT4geHQgKCkgLS0gbjIpXG4gICAgICAgIGVsc2UgQ29ucyAoeSwgZnVuIF8gLT4gbjEgLS0geXQgKCkpIGluXG4gICAgbGV0IHJlYyBnbyA9IGZ1bmN0aW9uXG4gICAgICBMZiAtPiBOaWxcbiAgICB8IE5kTCAoa3AyLCB0MSwgXywgdDIsIF8pIC0+IENvbnMgKGtwMiwgZnVuIF8gLT4gZ28gdDEpIC0tIGdvIHQyXG4gICAgfCBOZFIgKGtwMiwgdDEsIF8sIHQyLCBfKSAtPiBnbyB0MSAtLSBDb25zIChrcDIsIGZ1biBfIC0+IGdvIHQyKSBpblxuICAgIG1hdGNoIHQgd2l0aCBOIC0+IE5pbCB8IFQgKGtwLCBfLCB0KSAtPiBDb25zIChrcCwgZnVuIF8gLT4gZ28gdClcblxuICBsZXQgc2cgayBwID0gc2cgKGssIHApXG5cbiAgbGV0IGRlcHRoIHQgPVxuICAgIGxldCByZWMgZ28gPSBmdW5jdGlvblxuICAgICAgTGYgLT4gMFxuICAgIHwgTmRMIChfLCB0MSwgXywgdDIsIF8pIHwgTmRSIChfLCB0MSwgXywgdDIsIF8pIC0+XG4gICAgICAgIG1heCAoZ28gdDEpIChnbyB0MikgKyAxIGluXG4gICAgbWF0Y2ggdCB3aXRoIE4gLT4gMCB8IFQgKF8sIF8sIHQpIC0+IGdvIHQgKyAxXG5cbiAgbGV0IHBwID8oc2VwID0gRm9ybWF0LnBwX3ByaW50X3NwYWNlKSBwcCBwcGYgdCA9XG4gICAgbGV0IGZpcnN0ID0gcmVmIHRydWUgaW5cbiAgICBsZXQgayBwcGYgPSBpdGVyIEBAIGZ1biBrIHAgLT5cbiAgICAgICggbWF0Y2ggIWZpcnN0IHdpdGggdHJ1ZSAtPiBmaXJzdCA6PSBmYWxzZSB8IF8gLT4gc2VwIHBwZiAoKSk7XG4gICAgICBwcCBwcGYgKGssIHApIGluXG4gICAgcGYgcHBmIFwiQFslYUBdXCIgayB0XG5cbiAgbGV0IHBwX2R1bXAgcHBrIHBwcCBwcGYgPVxuICAgIGxldCBzZXAgcHBmICgpID0gcGYgcHBmIFwiO0AgXCJcbiAgICBhbmQgcHBrcCBwcGYgKGssIHApID0gcGYgcHBmIFwiKEBbJWEsQCAlYUBdKVwiIHBwayBrIHBwcCBwIGluXG4gICAgcGYgcHBmIFwib2Zfc29ydGVkX2xpc3QgWyVhXVwiIChwcCB+c2VwIHBwa3ApXG5lbmRcbiJdfQ==
