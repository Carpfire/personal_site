// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ke__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ke = [0];
   runtime.caml_register_global(0, Ke, "Ke__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ke__Sigs
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Weighted = [0],
    Ke_Sigs = [0, Weighted];
   runtime.caml_register_global(0, Ke_Sigs, "Ke__Sigs");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ke__Rke
//# unitInfo: Requires: Fmt, Stdlib, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_RBA_from = "RBA.from",
    cst_Rke_Weighted_create = "Rke.Weighted.create",
    cst_Rke_create = "Rke.create",
    cst_rke = "rke",
    cst_rke_weighted = "rke:weighted",
    caml_ba_blit = runtime.caml_ba_blit,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ba_sub = runtime.caml_ba_sub,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Fmt = global_data.Fmt,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Stdlib = global_data.Stdlib,
    Empty = [248, "Ke__Rke.Empty", caml_fresh_oo_id(0)],
    _e_ = [0, [11, cst_rke_weighted, 0], cst_rke_weighted],
    _d_ = [0, [11, cst_RBA_from, 0], cst_RBA_from],
    _c_ = [0, [11, cst_Rke_Weighted_create, 0], cst_Rke_Weighted_create],
    _b_ = [0, [11, cst_rke, 0], cst_rke],
    _a_ = [0, [11, cst_Rke_create, 0], cst_Rke_create],
    cst_Ke_Rke_Weighted_Empty = "Ke__Rke.Weighted.Empty",
    cst_Ke_Rke_Weighted_Full = "Ke__Rke.Weighted.Full";
   function mask(t, v){return v & (t[3] - 1 | 0);}
   function empty(t){return t[1] === t[2] ? 1 : 0;}
   function size(t){return t[2] - t[1] | 0;}
   function available(t){return t[3] - (t[2] - t[1] | 0) | 0;}
   function full(t){var _al_ = t[3]; return size(t) === _al_ ? 1 : 0;}
   function length(q){return size(q);}
   function to_power_of_two(v){
    var res = [0, v - 1 | 0];
    res[1] = res[1] | res[1] >>> 1 | 0;
    res[1] = res[1] | res[1] >>> 2 | 0;
    res[1] = res[1] | res[1] >>> 4 | 0;
    res[1] = res[1] | res[1] >>> 8 | 0;
    res[1] = res[1] | res[1] >>> 16 | 0;
    return res[1] + 1 | 0;
   }
   function is_empty(t){return empty(t);}
   function create(capacity, kind){
    a:
    {
     if(capacity){
      var n = capacity[1];
      if(0 !== n){
       var
        _ak_ = 0 <= n ? to_power_of_two(n) : caml_call1(Fmt[13], _a_),
        capacity$0 = _ak_;
       break a;
      }
     }
     var capacity$0 = 1;
    }
    return [0,
            0,
            0,
            capacity$0,
            kind,
            caml_call3
             (Stdlib_Bigarray[19][1], kind, Stdlib_Bigarray[15], capacity$0)];
   }
   function capacity(param){var c = param[3]; return c;}
   function copy(t){
    var
     v = caml_call3(Stdlib_Bigarray[19][1], t[4], Stdlib_Bigarray[15], t[3]);
    caml_ba_blit(t[5], v);
    return [0, t[1], t[2], t[3], t[4], v];
   }
   function grow(t, want){
    var
     max = Stdlib[17],
     c = to_power_of_two(caml_call2(max, 1, caml_call2(max, want, size(t))));
    if(c !== caml_ba_dim_1(t[5])){
     var
      dst = caml_call3(Stdlib_Bigarray[19][1], t[4], Stdlib_Bigarray[15], c),
      sze = size(t),
      msk = mask(t, t[1]),
      pre = t[3] - msk | 0,
      rst = sze - pre | 0;
     if(0 < rst){
      var _ah_ = caml_ba_sub(dst, 0, pre);
      caml_ba_blit(caml_ba_sub(t[5], msk, pre), _ah_);
      var _ai_ = caml_ba_sub(dst, pre, rst);
      caml_ba_blit(caml_ba_sub(t[5], 0, rst), _ai_);
     }
     else{
      var _aj_ = caml_ba_sub(dst, 0, sze);
      caml_ba_blit(caml_ba_sub(t[5], msk, sze), _aj_);
     }
     t[5] = dst;
     t[2] = sze;
     t[3] = c;
     t[1] = 0;
    }
    return;
   }
   function push(t, v){
    if(full(t)) grow(t, 2 * size(t) | 0);
    var _ag_ = mask(t, t[2]);
    caml_ba_set_1(t[5], _ag_, v);
    t[2] = t[2] + 1 | 0;
    return 0;
   }
   function cons(t, v){
    if(full(t)) grow(t, 2 * size(t) | 0);
    var i = t[1] - 1 | 0, _af_ = mask(t, i);
    caml_ba_set_1(t[5], _af_, v);
    t[1] = i;
    return 0;
   }
   function pop_exn(t){
    if(empty(t)) throw caml_maybe_attach_backtrace(Empty, 1);
    var _ae_ = mask(t, t[1]), r = caml_ba_get_1(t[5], _ae_);
    t[1] = t[1] + 1 | 0;
    return r;
   }
   function pop(t){
    try{var _ac_ = [0, pop_exn(t)]; return _ac_;}
    catch(_ad_){
     var _ab_ = caml_wrap_exception(_ad_);
     if(_ab_ === Empty) return 0;
     throw caml_maybe_attach_backtrace(_ab_, 0);
    }
   }
   function peek_exn(t){
    if(empty(t)) throw caml_maybe_attach_backtrace(Empty, 1);
    var _aa_ = mask(t, t[1]);
    return caml_ba_get_1(t[5], _aa_);
   }
   function peek(t){
    try{var ___ = [0, peek_exn(t)]; return ___;}
    catch(_$_){
     var _Z_ = caml_wrap_exception(_$_);
     if(_Z_ === Empty) return 0;
     throw caml_maybe_attach_backtrace(_Z_, 0);
    }
   }
   function blit(src, src_off, dst, dst_off, len){
    var
     a = caml_ba_sub(src, src_off, len),
     b = caml_ba_sub(dst, dst_off, len);
    caml_ba_blit(a, b);
    return;
   }
   function compress(t){
    var
     len = length(t),
     msk = mask(t, t[1]),
     pre = t[3] - msk | 0,
     rst = len - pre | 0;
    if(0 < rst)
     if(pre <= available(t)){
      blit(t[5], 0, t[5], pre, rst);
      blit(t[5], msk, t[5], 0, pre);
     }
     else{
      var
       tmp =
         caml_call3(Stdlib_Bigarray[19][1], t[4], Stdlib_Bigarray[15], pre);
      blit(t[5], msk, tmp, 0, pre);
      blit(t[5], 0, t[5], pre, rst);
      blit(tmp, 0, t[5], 0, pre);
     }
    else
     blit(t[5], msk, t[5], 0, len);
    t[1] = 0;
    t[2] = len;
    return 0;
   }
   function push$0(t, blit, length, opt, len, v){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(length, v) - off | 0;
    if(available(t) < len$1) grow(t, len$1 + size(t) | 0);
    var msk = mask(t, t[2]), pre = t[3] - msk | 0, rst = len$1 - pre | 0;
    if(0 < rst){
     caml_call5(blit, v, off, t[5], msk, pre);
     caml_call5(blit, v, off + pre | 0, t[5], 0, rst);
    }
    else
     caml_call5(blit, v, off, t[5], msk, len$1);
    t[2] = t[2] + len$1 | 0;
    return 0;
   }
   function keep_exn(t, blit, length, opt, len, v){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(length, v) - off | 0;
    if(size(t) < len$1) throw caml_maybe_attach_backtrace(Empty, 1);
    var msk = mask(t, t[1]), pre = t[3] - msk | 0, rst = len$1 - pre | 0;
    return 0 < rst
            ? (caml_call5
               (blit, t[5], msk, v, off, pre),
              caml_call5(blit, t[5], 0, v, off + pre | 0, rst))
            : caml_call5(blit, t[5], msk, v, off, len$1);
   }
   function keep(t, blit, length, off, len, v){
    try{var _X_ = [0, keep_exn(t, blit, length, off, len, v)]; return _X_;}
    catch(_Y_){
     var _W_ = caml_wrap_exception(_Y_);
     if(_W_ === Empty) return 0;
     throw caml_maybe_attach_backtrace(_W_, 0);
    }
   }
   function peek$0(t){
    var len = size(t);
    if(0 === len) return 0;
    var msk = mask(t, t[1]), pre = t[3] - msk | 0, rst = len - pre | 0;
    if(0 >= rst) return [0, caml_ba_sub(t[5], msk, len), 0];
    var _V_ = [0, caml_ba_sub(t[5], 0, rst), 0];
    return [0, caml_ba_sub(t[5], msk, pre), _V_];
   }
   function unsafe_shift(t, len){t[1] = t[1] + len | 0; return 0;}
   function shift_exn(t, len){
    if(size(t) < len) throw caml_maybe_attach_backtrace(Empty, 1);
    return unsafe_shift(t, len);
   }
   function shift(t, len){
    try{var _T_ = [0, shift_exn(t, len)]; return _T_;}
    catch(_U_){
     var _S_ = caml_wrap_exception(_U_);
     if(_S_ === Empty) return 0;
     throw caml_maybe_attach_backtrace(_S_, 0);
    }
   }
   var
    N = [0, push$0, keep_exn, keep, peek$0, unsafe_shift, shift_exn, shift];
   function iter(f, t){
    var idx = [0, t[1]], max = t[2];
    for(;;){
     if(idx[1] === max) return 0;
     var _R_ = mask(t, idx[1]);
     caml_call1(f, caml_ba_get_1(t[5], _R_));
     idx[1]++;
    }
   }
   function rev_iter(f, t){
    if(t[1] === t[2]) return 0;
    var idx = [0, t[2] - 1 | 0], min = t[1];
    for(;;){
     var _Q_ = mask(t, idx[1]);
     caml_call1(f, caml_ba_get_1(t[5], _Q_));
     if(idx[1] === min) return 0;
     idx[1] += -1;
    }
   }
   function fold(f, a, t){
    var a$0 = [0, a];
    iter(function(x){a$0[1] = caml_call2(f, a$0[1], x); return 0;}, t);
    return a$0[1];
   }
   function pp(sep, pp_elt){return caml_call3(Fmt[30], sep, iter, pp_elt);}
   function dump(pp_elt){
    var _P_ = caml_call1(Fmt[18], _b_);
    return caml_call3(Fmt[70][15], iter, _P_, pp_elt);
   }
   function clear(q){q[1] = 0; q[2] = 0; return 0;}
   var
    Empty$0 = [248, cst_Ke_Rke_Weighted_Empty, caml_fresh_oo_id(0)],
    Full = [248, cst_Ke_Rke_Weighted_Full, caml_fresh_oo_id(0)];
   function mask$0(t, v){return v & (t[3] - 1 | 0);}
   function empty$0(t){return t[1] === t[2] ? 1 : 0;}
   function size$0(t){return t[2] - t[1] | 0;}
   function full$0(t){var _O_ = t[3]; return size$0(t) === _O_ ? 1 : 0;}
   function available$0(t){return t[3] - (t[2] - t[1] | 0) | 0;}
   function is_empty$0(t){return empty$0(t);}
   function length$0(q){return size$0(q);}
   function create$0(capacity, kind){
    a:
    {
     if(capacity){
      var n = capacity[1];
      if(0 !== n){
       var
        _N_ = 0 <= n ? to_power_of_two(n) : caml_call1(Fmt[13], _c_),
        capacity$0 = _N_;
       break a;
      }
     }
     var capacity$0 = 1;
    }
    return [0,
            [0,
             0,
             0,
             capacity$0,
             kind,
             caml_call3
              (Stdlib_Bigarray[19][1], kind, Stdlib_Bigarray[15], capacity$0)],
            capacity$0];
   }
   function copy$0(t){
    var
     v = caml_call3(Stdlib_Bigarray[19][1], t[4], Stdlib_Bigarray[15], t[3]);
    caml_ba_blit(t[5], v);
    return [0, t[1], t[2], t[3], t[4], v];
   }
   function from(v){
    var
     v$0 = caml_ba_dim_1(v),
     _L_ = 0 !== v$0 ? 1 : 0,
     _M_ =
       _L_
        ? (v$0 & (caml_call1(Stdlib[21], v$0) + 1 | 0)) === v$0 ? 1 : 0
        : _L_;
    if(1 - _M_) caml_call1(Fmt[13], _d_);
    var c = caml_ba_dim_1(v), k = runtime.caml_ba_kind(v);
    return [0, 0, 0, c, k, v];
   }
   function push_exn(t, v){
    if(full$0(t)) throw caml_maybe_attach_backtrace(Full, 1);
    var _K_ = mask$0(t, t[2]);
    caml_ba_set_1(t[5], _K_, v);
    t[2] = t[2] + 1 | 0;
    return 0;
   }
   function push$1(t, v){
    try{var _I_ = [0, push_exn(t, v)]; return _I_;}
    catch(_J_){
     var _H_ = caml_wrap_exception(_J_);
     if(_H_ === Full) return 0;
     throw caml_maybe_attach_backtrace(_H_, 0);
    }
   }
   function cons_exn(t, v){
    if(full$0(t)) throw caml_maybe_attach_backtrace(Full, 1);
    var i = t[1] - 1 | 0, _G_ = mask$0(t, i);
    caml_ba_set_1(t[5], _G_, v);
    t[1] = i;
    return 0;
   }
   function cons$0(t, v){
    try{var _E_ = [0, cons_exn(t, v)]; return _E_;}
    catch(_F_){
     var _D_ = caml_wrap_exception(_F_);
     if(_D_ === Full) return 0;
     throw caml_maybe_attach_backtrace(_D_, 0);
    }
   }
   function pop_exn$0(t){
    if(empty$0(t)) throw caml_maybe_attach_backtrace(Empty$0, 1);
    var _C_ = mask$0(t, t[1]), r = caml_ba_get_1(t[5], _C_);
    t[1] = t[1] + 1 | 0;
    return r;
   }
   function pop$0(t){
    try{var _A_ = [0, pop_exn$0(t)]; return _A_;}
    catch(_B_){
     var _z_ = caml_wrap_exception(_B_);
     if(_z_ === Empty$0) return 0;
     throw caml_maybe_attach_backtrace(_z_, 0);
    }
   }
   function peek_exn$0(t){
    if(empty$0(t)) throw caml_maybe_attach_backtrace(Empty$0, 1);
    var _y_ = mask$0(t, t[1]);
    return caml_ba_get_1(t[5], _y_);
   }
   function peek$1(t){
    try{var _w_ = [0, peek_exn$0(t)]; return _w_;}
    catch(_x_){
     var _v_ = caml_wrap_exception(_x_);
     if(_v_ === Empty$0) return 0;
     throw caml_maybe_attach_backtrace(_v_, 0);
    }
   }
   function compress$0(t){
    var
     len = length$0(t),
     msk = mask$0(t, t[1]),
     pre = t[3] - msk | 0,
     rst = len - pre | 0;
    if(0 < rst)
     if(pre <= available$0(t)){
      blit(t[5], 0, t[5], pre, rst);
      blit(t[5], msk, t[5], 0, pre);
     }
     else{
      var
       tmp =
         caml_call3(Stdlib_Bigarray[19][1], t[4], Stdlib_Bigarray[15], pre);
      blit(t[5], msk, tmp, 0, pre);
      blit(t[5], 0, t[5], pre, rst);
      blit(tmp, 0, t[5], 0, pre);
     }
    else
     blit(t[5], msk, t[5], 0, len);
    t[1] = 0;
    t[2] = len;
    return 0;
   }
   function push_exn$0(t, blit, length, opt, len, v){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(length, v) - off | 0;
    if(available$0(t) < len$1) throw caml_maybe_attach_backtrace(Full, 1);
    var msk = mask$0(t, t[2]), pre = t[3] - msk | 0, rst = len$1 - pre | 0;
    if(0 < rst){
     caml_call5(blit, v, off, t[5], msk, pre);
     caml_call5(blit, v, off + pre | 0, t[5], 0, rst);
     var
      _s_ = [0, caml_ba_sub(t[5], 0, rst), 0],
      _t_ = mask$0(t, t[2]),
      ret = [0, caml_ba_sub(t[5], _t_, pre), _s_];
    }
    else{
     caml_call5(blit, v, off, t[5], msk, len$1);
     var _u_ = mask$0(t, t[2]), ret = [0, caml_ba_sub(t[5], _u_, len$1), 0];
    }
    t[2] = t[2] + len$1 | 0;
    return ret;
   }
   function push$2(t, blit, length, off, len, v){
    try{var _q_ = [0, push_exn$0(t, blit, length, off, len, v)]; return _q_;}
    catch(_r_){
     var _p_ = caml_wrap_exception(_r_);
     if(_p_ === Full) return 0;
     throw caml_maybe_attach_backtrace(_p_, 0);
    }
   }
   function keep_exn$0(t, blit, length, opt, len, v){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(length, v) - off | 0;
    if(size$0(t) < len$1) throw caml_maybe_attach_backtrace(Empty$0, 1);
    var msk = mask$0(t, t[1]), pre = t[3] - msk | 0, rst = len$1 - pre | 0;
    return 0 < rst
            ? (caml_call5
               (blit, t[5], msk, v, off, pre),
              caml_call5(blit, t[5], 0, v, off + pre | 0, rst))
            : caml_call5(blit, t[5], msk, v, off, len$1);
   }
   function keep$0(t, blit, length, off, len, v){
    try{var _n_ = [0, keep_exn$0(t, blit, length, off, len, v)]; return _n_;}
    catch(_o_){
     var _m_ = caml_wrap_exception(_o_);
     if(_m_ === Empty$0) return 0;
     throw caml_maybe_attach_backtrace(_m_, 0);
    }
   }
   function peek$2(t){
    var len = size$0(t);
    if(0 === len) return 0;
    var msk = mask$0(t, t[1]), pre = t[3] - msk | 0, rst = len - pre | 0;
    if(0 >= rst) return [0, caml_ba_sub(t[5], msk, len), 0];
    var _l_ = [0, caml_ba_sub(t[5], 0, rst), 0];
    return [0, caml_ba_sub(t[5], msk, pre), _l_];
   }
   function unsafe_shift$0(t, len){t[1] = t[1] + len | 0; return 0;}
   function shift_exn$0(t, len){
    if(size$0(t) < len) throw caml_maybe_attach_backtrace(Empty$0, 1);
    return unsafe_shift$0(t, len);
   }
   function shift$0(t, len){
    try{var _j_ = [0, shift_exn$0(t, len)]; return _j_;}
    catch(_k_){
     var _i_ = caml_wrap_exception(_k_);
     if(_i_ === Empty$0) return 0;
     throw caml_maybe_attach_backtrace(_i_, 0);
    }
   }
   var
    N$0 =
      [0,
       push_exn$0,
       push$2,
       keep_exn$0,
       keep$0,
       peek$2,
       unsafe_shift$0,
       shift_exn$0,
       shift$0];
   function iter$0(f, t){
    var idx = [0, t[1]], max = t[2];
    for(;;){
     if(idx[1] === max) return 0;
     var _h_ = mask$0(t, idx[1]);
     caml_call1(f, caml_ba_get_1(t[5], _h_));
     idx[1]++;
    }
   }
   function rev_iter$0(f, t){
    if(t[1] === t[2]) return 0;
    var idx = [0, t[2] - 1 | 0], min = t[1];
    for(;;){
     var _g_ = mask$0(t, idx[1]);
     caml_call1(f, caml_ba_get_1(t[5], _g_));
     if(idx[1] === min) return 0;
     idx[1] += -1;
    }
   }
   function fold$0(f, a, t){
    var a$0 = [0, a];
    iter$0(function(x){a$0[1] = caml_call2(f, a$0[1], x); return 0;}, t);
    return a$0[1];
   }
   function pp$0(sep, pp_elt){
    return caml_call3(Fmt[30], sep, iter$0, pp_elt);
   }
   function dump$0(pp_elt){
    var _f_ = caml_call1(Fmt[18], _e_);
    return caml_call3(Fmt[70][15], iter$0, _f_, pp_elt);
   }
   function clear$0(q){q[1] = 0; q[2] = 0; return 0;}
   function unsafe_bigarray(param){var v = param[5]; return v;}
   var
    Ke_Rke =
      [0,
       Empty,
       is_empty,
       create,
       capacity,
       length,
       push,
       pop,
       pop_exn,
       peek,
       peek_exn,
       cons,
       copy,
       clear,
       compress,
       N,
       iter,
       rev_iter,
       fold,
       pp,
       dump,
       [0,
        Full,
        Empty$0,
        is_empty$0,
        create$0,
        length$0,
        available$0,
        push_exn,
        push$1,
        pop$0,
        pop_exn$0,
        peek$1,
        peek_exn$0,
        cons_exn,
        cons$0,
        copy$0,
        clear$0,
        compress$0,
        N$0,
        iter$0,
        rev_iter$0,
        fold$0,
        pp$0,
        dump$0,
        unsafe_bigarray,
        from]];
   runtime.caml_register_global(11, Ke_Rke, "Ke__Rke");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ke__Fke
//# unitInfo: Requires: CamlinternalLazy, Fmt, Stdlib, Stdlib__Bigarray, Stdlib__Lazy
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_RBA_from = "RBA.from",
    cst_Rke_Weighted_create = "Rke.Weighted.create",
    cst_fke = "fke",
    cst_fke_weighted = "fke:weighted",
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ba_sub = runtime.caml_ba_sub,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    empty = [0, 0],
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Fmt = global_data.Fmt,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Stdlib = global_data.Stdlib,
    Empty = [248, "Ke__Fke.Empty", caml_fresh_oo_id(0)],
    _d_ = [0, [11, cst_fke_weighted, 0], cst_fke_weighted],
    _c_ = [0, [11, cst_RBA_from, 0], cst_RBA_from],
    _b_ = [0, [11, cst_Rke_Weighted_create, 0], cst_Rke_Weighted_create],
    _a_ = [0, [11, cst_fke, 0], cst_fke],
    cst_Ke_Fke_Weighted_Empty = "Ke__Fke.Weighted.Empty",
    cst_Ke_Fke_Weighted_Full = "Ke__Fke.Weighted.Full";
   function one(x){return [0, [0, x]];}
   function two(x, y){return [0, [1, x, y]];}
   function three(x, y, z){return [0, [2, x, y, z]];}
   function is_empty(param){
    if(0 === param[0] && typeof param[1] === "number") return 1;
    return 0;
   }
   function push(q, x){
    if(0 === q[0]){
     var match = q[1];
     if(typeof match === "number") return one(x);
     switch(match[0]){
       case 0:
        var y = match[1]; return two(y, x);
       case 1:
        var z = match[2], y$0 = match[1]; return three(y$0, z, x);
       default:
        var c = match[3], b = match[2], a = match[1];
        return [1, 4, [1, a, b], caml_call1(Stdlib_Lazy[4], empty), [1, c, x]];
     }
    }
    var m = q[3], f = q[2], s = q[1], match$0 = q[4];
    if(typeof match$0 !== "number")
     switch(match$0[0]){
       case 0: break;
       case 1:
        var z$0 = match$0[2], y$2 = match$0[1];
        return [1, s + 1 | 0, f, m, [2, y$2, z$0, x]];
       default:
        var _ak_ = caml_obj_tag(m);
        a:
        if(250 === _ak_)
         var q$0 = m[1];
        else{
         if(246 !== _ak_ && 244 !== _ak_){var q$0 = m; break a;}
         var q$0 = caml_call1(CamlinternalLazy[2], m);
        }
        var
         match$1 = q[4],
         z$1 = match$1[3],
         z$2 = match$1[2],
         y$3 = match$1[1],
         _al_ = [1, z$1, x];
        return [1,
                s + 1 | 0,
                f,
                [246, function(_am_){return push(q$0, [0, y$3, z$2]);}],
                _al_];
     }
    var y$1 = match$0[1];
    return [1, s + 1 | 0, f, m, [1, y$1, x]];
   }
   function pop_exn(q){
    if(0 === q[0]){
     var match = q[1];
     if(typeof match === "number")
      throw caml_maybe_attach_backtrace(Empty, 1);
     switch(match[0]){
       case 0:
        var x = match[1]; return [0, x, empty];
       case 1:
        var y = match[2], x$0 = match[1]; return [0, x$0, one(y)];
       default:
        var z = match[3], y$0 = match[2], x$1 = match[1];
        return [0, x$1, two(y$0, z)];
     }
    }
    var match$0 = q[2], s = q[1];
    if(typeof match$0 !== "number")
     switch(match$0[0]){
       case 0: break;
       case 1:
        var r$0 = q[4], m = q[3], y$2 = match$0[2], x$3 = match$0[1];
        return [0, x$3, [1, s - 1 | 0, [0, y$2], m, r$0]];
       default:
        var
         r$1 = q[4],
         m$0 = q[3],
         z$1 = match$0[3],
         y$3 = match$0[2],
         x$4 = match$0[1];
        return [0, x$4, [1, s - 1 | 0, [1, y$3, z$1], m$0, r$1]];
     }
    var _ah_ = q[3], x$2 = match$0[1], _ai_ = caml_obj_tag(_ah_);
    a:
    if(250 === _ai_)
     var q$0 = _ah_[1];
    else{
     if(246 !== _ai_ && 244 !== _ai_){var q$0 = _ah_; break a;}
     var q$0 = caml_call1(CamlinternalLazy[2], _ah_);
    }
    var r = q[4];
    if(is_empty(q$0)) return [0, x$2, [0, r]];
    var
     _aj_ = pop_exn(q$0),
     q$1 = _aj_[2],
     match$1 = _aj_[1],
     z$0 = match$1[2],
     y$1 = match$1[1];
    return [0,
            x$2,
            [1, s - 1 | 0, [1, y$1, z$0], caml_call1(Stdlib_Lazy[4], q$1), r]];
   }
   function tail_exn(q){
    if(0 === q[0]){
     var match = q[1];
     if(typeof match === "number")
      throw caml_maybe_attach_backtrace(Empty, 1);
     switch(match[0]){
       case 0:
        var x = match[1]; return [0, empty, x];
       case 1:
        var y = match[2], x$0 = match[1]; return [0, one(x$0), y];
       default:
        var z = match[3], y$0 = match[2], x$1 = match[1];
        return [0, two(x$1, y$0), z];
     }
    }
    var m = q[3], f = q[2], s = q[1], _af_ = caml_obj_tag(m);
    a:
    if(250 === _af_)
     var q$0 = m[1];
    else{
     if(246 !== _af_ && 244 !== _af_){var q$0 = m; break a;}
     var q$0 = caml_call1(CamlinternalLazy[2], m);
    }
    var match$0 = q[4];
    if(typeof match$0 !== "number" && 0 !== match$0[0]){
     var match$2 = q[4];
     if(typeof match$2 !== "number" && 2 === match$2[0]){
      var z$1 = match$2[3], y$3 = match$2[2], x$4 = match$2[1];
      return [0, [1, s - 1 | 0, f, m, [1, x$4, y$3]], z$1];
     }
     var y$2 = match$2[2], x$3 = match$2[1];
     return [0, [1, s - 1 | 0, f, m, [0, x$3]], y$2];
    }
    var x$2 = match$0[1];
    if(is_empty(q$0)) return [0, [0, f], x$2];
    var
     _ag_ = tail_exn(q$0),
     match$1 = _ag_[2],
     z$0 = match$1[2],
     y$1 = match$1[1],
     q$1 = _ag_[1];
    return [0,
            [1, s - 1 | 0, f, caml_call1(Stdlib_Lazy[4], q$1), [1, y$1, z$0]],
            x$2];
   }
   function peek_exn(q){
    if(0 === q[0]){
     var match = q[1];
     if(typeof match === "number")
      throw caml_maybe_attach_backtrace(Empty, 1);
     switch(match[0]){
       case 0:
        var x = match[1]; return x;
       case 1:
        var x$0 = match[1]; return x$0;
       default: var x$1 = match[1]; return x$1;
     }
    }
    var match$0 = q[2];
    if(typeof match$0 !== "number")
     switch(match$0[0]){
       case 0: break;
       case 1:
        var x$3 = match$0[1]; return x$3;
       default: var x$4 = match$0[1]; return x$4;
     }
    var x$2 = match$0[1];
    return x$2;
   }
   function pop(q){
    try{var _ad_ = [0, pop_exn(q)]; return _ad_;}
    catch(_ae_){
     var _ac_ = caml_wrap_exception(_ae_);
     if(_ac_ === Empty) return 0;
     throw caml_maybe_attach_backtrace(_ac_, 0);
    }
   }
   function tail(q){
    try{var _aa_ = [0, tail_exn(q)]; return _aa_;}
    catch(_ab_){
     var _$_ = caml_wrap_exception(_ab_);
     if(_$_ === Empty) return 0;
     throw caml_maybe_attach_backtrace(_$_, 0);
    }
   }
   function peek(q){
    try{var _Z_ = [0, peek_exn(q)]; return _Z_;}
    catch(___){
     var _Y_ = caml_wrap_exception(___);
     if(_Y_ === Empty) return 0;
     throw caml_maybe_attach_backtrace(_Y_, 0);
    }
   }
   function cons(q, x){
    if(0 === q[0]){
     var match = q[1];
     if(typeof match === "number") return one(x);
     switch(match[0]){
       case 0:
        var y = match[1]; return two(x, y);
       case 1:
        var z = match[2], y$0 = match[1]; return three(x, y$0, z);
       default:
        var z$0 = match[3], z$1 = match[2], y$1 = match[1];
        return [1,
                4,
                [1, x, y$1],
                caml_call1(Stdlib_Lazy[4], empty),
                [1, z$1, z$0]];
     }
    }
    var match$0 = q[2], s = q[1];
    if(typeof match$0 !== "number")
     switch(match$0[0]){
       case 0: break;
       case 1:
        var r$0 = q[4], m$0 = q[3], z$2 = match$0[2], y$3 = match$0[1];
        return [1, s + 1 | 0, [2, x, y$3, z$2], m$0, r$0];
       default:
        var
         _V_ = q[3],
         z$3 = match$0[3],
         z$4 = match$0[2],
         y$4 = match$0[1],
         _W_ = caml_obj_tag(_V_);
        a:
        if(250 === _W_)
         var q$0 = _V_[1];
        else{
         if(246 !== _W_ && 244 !== _W_){var q$0 = _V_; break a;}
         var q$0 = caml_call1(CamlinternalLazy[2], _V_);
        }
        var r$1 = q[4];
        return [1,
                s + 1 | 0,
                [2, x, y$4, z$4],
                [246, function(_X_){return cons(q$0, [0, z$4, z$3]);}],
                r$1];
     }
    var r = q[4], m = q[3], y$2 = match$0[1];
    return [1, s + 1 | 0, [1, x, y$2], m, r];
   }
   function iter(f, q){
    function go(f, param){
     var param$0 = param;
     for(;;){
      if(0 === param$0[0]){
       var match = param$0[1];
       if(typeof match === "number") return 0;
       switch(match[0]){
         case 0:
          var x = match[1]; return caml_call1(f, x);
         case 1:
          var y = match[2], x$0 = match[1];
          caml_call1(f, x$0);
          return caml_call1(f, y);
         default:
          var z = match[3], y$0 = match[2], x$1 = match[1];
          caml_call1(f, x$1);
          caml_call1(f, y$0);
          return caml_call1(f, z);
       }
      }
      var _T_ = param$0[3], hd = param$0[2], _U_ = caml_obj_tag(_T_);
      a:
      if(250 === _U_)
       var q = _T_[1];
      else{
       if(246 !== _U_ && 244 !== _U_){var q = _T_; break a;}
       var q = caml_call1(CamlinternalLazy[2], _T_);
      }
      var tl = param$0[4];
      go(f, [0, hd]);
      go
       (function(param){
         var y = param[2], x = param[1];
         caml_call1(f, x);
         return caml_call1(f, y);
        },
        q);
      var param$0 = [0, tl];
     }
    }
    return go(f, q);
   }
   function rev_iter(f, q){
    function go(f, param){
     var param$0 = param;
     for(;;){
      if(0 === param$0[0]){
       var match = param$0[1];
       if(typeof match === "number") return 0;
       switch(match[0]){
         case 0:
          var x = match[1]; return caml_call1(f, x);
         case 1:
          var x$0 = match[2], y = match[1];
          caml_call1(f, x$0);
          return caml_call1(f, y);
         default:
          var x$1 = match[3], y$0 = match[2], z = match[1];
          caml_call1(f, x$1);
          caml_call1(f, y$0);
          return caml_call1(f, z);
       }
      }
      var _R_ = param$0[3], hd = param$0[2], _S_ = caml_obj_tag(_R_);
      a:
      if(250 === _S_)
       var q = _R_[1];
      else{
       if(246 !== _S_ && 244 !== _S_){var q = _R_; break a;}
       var q = caml_call1(CamlinternalLazy[2], _R_);
      }
      var tl = param$0[4];
      go(f, [0, tl]);
      go
       (function(param){
         var x = param[2], y = param[1];
         caml_call1(f, x);
         return caml_call1(f, y);
        },
        q);
      var param$0 = [0, hd];
     }
    }
    return go(f, q);
   }
   function fold(f, a, q){
    function go(f, a, param){
     var a$0 = a, param$0 = param;
     for(;;){
      if(0 === param$0[0]){
       var match = param$0[1];
       if(typeof match === "number") return a$0;
       switch(match[0]){
         case 0:
          var x = match[1]; return caml_call2(f, a$0, x);
         case 1:
          var y = match[2], x$0 = match[1];
          return caml_call2(f, caml_call2(f, a$0, x$0), y);
         default:
          var z = match[3], y$0 = match[2], x$1 = match[1];
          return caml_call2(f, caml_call2(f, caml_call2(f, a$0, x$1), y$0), z);
       }
      }
      var _P_ = param$0[3], hd = param$0[2], _Q_ = caml_obj_tag(_P_);
      a:
      if(250 === _Q_)
       var q = _P_[1];
      else{
       if(246 !== _Q_ && 244 !== _Q_){var q = _P_; break a;}
       var q = caml_call1(CamlinternalLazy[2], _P_);
      }
      var
       tl = param$0[4],
       a$1 = go(f, a$0, [0, hd]),
       a$2 =
         go
          (function(a, param){
            var y = param[2], x = param[1];
            return caml_call2(f, caml_call2(f, a, x), y);
           },
           a$1,
           q),
       a$0 = a$2,
       param$0 = [0, tl];
     }
    }
    return go(f, a, q);
   }
   function length(param){
    if(0 !== param[0]){var s = param[1]; return s;}
    var _O_ = param[1];
    if(typeof _O_ === "number") return 0;
    switch(_O_[0]){case 0: return 1;case 1: return 2;default: return 3;
    }
   }
   function pp(sep, pp_elt){return caml_call3(Fmt[30], sep, iter, pp_elt);}
   function dump(pp_elt){
    var _N_ = caml_call1(Fmt[18], _a_);
    return caml_call3(Fmt[70][15], iter, _N_, pp_elt);
   }
   var
    Empty$0 = [248, cst_Ke_Fke_Weighted_Empty, caml_fresh_oo_id(0)],
    Full = [248, cst_Ke_Fke_Weighted_Full, caml_fresh_oo_id(0)];
   function mask(t, v){return v & (t[3] - 1 | 0);}
   function empty$0(t){return t[1] === t[2] ? 1 : 0;}
   function size(t){return t[2] - t[1] | 0;}
   function full(t){var _M_ = t[3]; return size(t) === _M_ ? 1 : 0;}
   function available(t){return t[3] - (t[2] - t[1] | 0) | 0;}
   function is_empty$0(t){return empty$0(t);}
   function length$0(q){return size(q);}
   function create(capacity, kind){
    a:
    {
     if(capacity){
      var v = capacity[1];
      if(0 !== v){
       if(0 <= v){
        var res = [0, v - 1 | 0];
        res[1] = res[1] | res[1] >>> 1 | 0;
        res[1] = res[1] | res[1] >>> 2 | 0;
        res[1] = res[1] | res[1] >>> 4 | 0;
        res[1] = res[1] | res[1] >>> 8 | 0;
        res[1] = res[1] | res[1] >>> 16 | 0;
        var _L_ = res[1] + 1 | 0;
       }
       else
        var _L_ = caml_call1(Fmt[13], _b_);
       var capacity$0 = _L_;
       break a;
      }
     }
     var capacity$0 = 1;
    }
    return [0,
            [0,
             0,
             0,
             capacity$0,
             kind,
             caml_call3
              (Stdlib_Bigarray[19][1], kind, Stdlib_Bigarray[15], capacity$0)],
            capacity$0];
   }
   function copy(t){
    var
     v = caml_call3(Stdlib_Bigarray[19][1], t[4], Stdlib_Bigarray[15], t[3]);
    runtime.caml_ba_blit(t[5], v);
    return [0, t[1], t[2], t[3], t[4], v];
   }
   function from(v){
    var
     v$0 = caml_ba_dim_1(v),
     _J_ = 0 !== v$0 ? 1 : 0,
     _K_ =
       _J_
        ? (v$0 & (caml_call1(Stdlib[21], v$0) + 1 | 0)) === v$0 ? 1 : 0
        : _J_;
    if(1 - _K_) caml_call1(Fmt[13], _c_);
    var c = caml_ba_dim_1(v), k = runtime.caml_ba_kind(v);
    return [0, 0, 0, c, k, v];
   }
   function push_exn(t, v){
    if(full(t)) throw caml_maybe_attach_backtrace(Full, 1);
    var _I_ = mask(t, t[2]);
    caml_ba_set_1(t[5], _I_, v);
    return [0, t[1], t[2] + 1 | 0, t[3], t[4], t[5]];
   }
   function push$0(t, v){
    try{var _G_ = [0, push_exn(t, v)]; return _G_;}
    catch(_H_){
     var _F_ = caml_wrap_exception(_H_);
     if(_F_ === Full) return 0;
     throw caml_maybe_attach_backtrace(_F_, 0);
    }
   }
   function cons_exn(t, v){
    if(full(t)) throw caml_maybe_attach_backtrace(Full, 1);
    var i = t[1] - 1 | 0, _E_ = mask(t, i);
    caml_ba_set_1(t[5], _E_, v);
    return [0, i, t[2], t[3], t[4], t[5]];
   }
   function cons$0(t, v){
    try{var _C_ = [0, cons_exn(t, v)]; return _C_;}
    catch(_D_){
     var _B_ = caml_wrap_exception(_D_);
     if(_B_ === Full) return 0;
     throw caml_maybe_attach_backtrace(_B_, 0);
    }
   }
   function pop_exn$0(t){
    if(empty$0(t)) throw caml_maybe_attach_backtrace(Empty$0, 1);
    var _A_ = mask(t, t[1]), r = caml_ba_get_1(t[5], _A_);
    return [0, r, [0, t[1] + 1 | 0, t[2], t[3], t[4], t[5]]];
   }
   function pop$0(t){
    try{var _y_ = [0, pop_exn$0(t)]; return _y_;}
    catch(_z_){
     var _x_ = caml_wrap_exception(_z_);
     if(_x_ === Empty$0) return 0;
     throw caml_maybe_attach_backtrace(_x_, 0);
    }
   }
   function peek_exn$0(t){
    if(empty$0(t)) throw caml_maybe_attach_backtrace(Empty$0, 1);
    var _w_ = mask(t, t[1]);
    return caml_ba_get_1(t[5], _w_);
   }
   function peek$0(t){
    try{var _u_ = [0, peek_exn$0(t)]; return _u_;}
    catch(_v_){
     var _t_ = caml_wrap_exception(_v_);
     if(_t_ === Empty$0) return 0;
     throw caml_maybe_attach_backtrace(_t_, 0);
    }
   }
   function push_exn$0(t, blit, length, opt, len, v){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(length, v) - off | 0;
    if(available(t) < len$1) throw caml_maybe_attach_backtrace(Full, 1);
    var msk = mask(t, t[2]), pre = t[3] - msk | 0, rst = len$1 - pre | 0;
    if(0 < rst){
     caml_call5(blit, v, off, t[5], msk, pre);
     caml_call5(blit, v, off + pre | 0, t[5], 0, rst);
     var
      _q_ = [0, caml_ba_sub(t[5], 0, rst), 0],
      _r_ = mask(t, t[2]),
      ret = [0, caml_ba_sub(t[5], _r_, pre), _q_];
    }
    else{
     caml_call5(blit, v, off, t[5], msk, len$1);
     var _s_ = mask(t, t[2]), ret = [0, caml_ba_sub(t[5], _s_, len$1), 0];
    }
    return [0, ret, [0, t[1], t[2] + len$1 | 0, t[3], t[4], t[5]]];
   }
   function push$1(t, blit, length, off, len, v){
    try{var _o_ = [0, push_exn$0(t, blit, length, off, len, v)]; return _o_;}
    catch(_p_){
     var _n_ = caml_wrap_exception(_p_);
     if(_n_ === Full) return 0;
     throw caml_maybe_attach_backtrace(_n_, 0);
    }
   }
   function keep_exn(t, blit, length, opt, len, v){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(length, v);
    if(size(t) < len$1) throw caml_maybe_attach_backtrace(Empty$0, 1);
    var msk = mask(t, t[1]), pre = t[3] - msk | 0, rst = len$1 - pre | 0;
    return 0 < rst
            ? (caml_call5
               (blit, t[5], msk, v, off, pre),
              caml_call5(blit, t[5], 0, v, off + pre | 0, rst))
            : caml_call5(blit, t[5], msk, v, off, len$1);
   }
   function keep(t, blit, length, off, len, v){
    try{var _l_ = [0, keep_exn(t, blit, length, off, len, v)]; return _l_;}
    catch(_m_){
     var _k_ = caml_wrap_exception(_m_);
     if(_k_ === Empty$0) return 0;
     throw caml_maybe_attach_backtrace(_k_, 0);
    }
   }
   function unsafe_shift(t, len){
    return [0, t[1] + len | 0, t[2], t[3], t[4], t[5]];
   }
   function shift_exn(t, len){
    if(size(t) < len) throw caml_maybe_attach_backtrace(Empty$0, 1);
    return unsafe_shift(t, len);
   }
   function shift(t, len){
    try{var _i_ = [0, shift_exn(t, len)]; return _i_;}
    catch(_j_){
     var _h_ = caml_wrap_exception(_j_);
     if(_h_ === Empty$0) return 0;
     throw caml_maybe_attach_backtrace(_h_, 0);
    }
   }
   var
    N =
      [0, push_exn$0, push$1, keep_exn, keep, unsafe_shift, shift_exn, shift];
   function iter$0(f, t){
    var idx = [0, t[1]], max = t[2];
    for(;;){
     if(idx[1] === max) return 0;
     var _g_ = mask(t, idx[1]);
     caml_call1(f, caml_ba_get_1(t[5], _g_));
     idx[1]++;
    }
   }
   function rev_iter$0(f, t){
    if(t[1] === t[2]) return 0;
    var idx = [0, t[2] - 1 | 0], min = t[1];
    for(;;){
     var _f_ = mask(t, idx[1]);
     caml_call1(f, caml_ba_get_1(t[5], _f_));
     if(idx[1] === min) return 0;
     idx[1] += -1;
    }
   }
   function fold$0(f, a, t){
    var a$0 = [0, a];
    iter$0(function(x){a$0[1] = caml_call2(f, a$0[1], x); return 0;}, t);
    return a$0[1];
   }
   function clear(t){return [0, 0, 0, t[3], t[4], t[5]];}
   function unsafe_bigarray(param){var v = param[5]; return v;}
   function pp$0(sep, pp_elt){
    return caml_call3(Fmt[30], sep, iter$0, pp_elt);
   }
   function dump$0(pp_elt){
    var _e_ = caml_call1(Fmt[18], _d_);
    return caml_call3(Fmt[70][15], iter$0, _e_, pp_elt);
   }
   var
    Ke_Fke =
      [0,
       Empty,
       empty,
       is_empty,
       length,
       push,
       cons,
       peek,
       peek_exn,
       pop,
       pop_exn,
       tail,
       tail_exn,
       iter,
       rev_iter,
       fold,
       pp,
       dump,
       [0,
        Empty$0,
        Full,
        is_empty$0,
        create,
        length$0,
        available,
        push_exn,
        push$0,
        pop$0,
        pop_exn$0,
        peek$0,
        peek_exn$0,
        cons$0,
        cons_exn,
        copy,
        clear,
        N,
        iter$0,
        rev_iter$0,
        fold$0,
        pp$0,
        dump$0,
        unsafe_bigarray,
        from]];
   runtime.caml_register_global(13, Ke_Fke, "Ke__Fke");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ke
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ke = [0];
   runtime.caml_register_global(0, Ke, "Ke");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJrZS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsibWFzayIsInQiLCJ2IiwiZW1wdHkiLCJzaXplIiwiYXZhaWxhYmxlIiwiZnVsbCIsImxlbmd0aCIsInEiLCJ0b19wb3dlcl9vZl90d28iLCJyZXMiLCJpc19lbXB0eSIsImNyZWF0ZSIsImNhcGFjaXR5Iiwia2luZCIsIm4iLCJjYXBhY2l0eSQwIiwiYyIsImNvcHkiLCJncm93Iiwid2FudCIsIm1heCIsImRzdCIsInN6ZSIsIm1zayIsInByZSIsInJzdCIsInB1c2giLCJjb25zIiwiaSIsInBvcF9leG4iLCJyIiwicG9wIiwicGVla19leG4iLCJwZWVrIiwiYmxpdCIsInNyYyIsInNyY19vZmYiLCJkc3Rfb2ZmIiwibGVuIiwiYSIsImIiLCJjb21wcmVzcyIsInRtcCIsInB1c2gkMCIsIm9wdCIsInN0aCIsIm9mZiIsImxlbiQwIiwibGVuJDEiLCJrZWVwX2V4biIsImtlZXAiLCJwZWVrJDAiLCJ1bnNhZmVfc2hpZnQiLCJzaGlmdF9leG4iLCJzaGlmdCIsIml0ZXIiLCJmIiwiaWR4IiwicmV2X2l0ZXIiLCJtaW4iLCJmb2xkIiwiYSQwIiwieCIsInBwIiwic2VwIiwicHBfZWx0IiwiZHVtcCIsImNsZWFyIiwibWFzayQwIiwiZW1wdHkkMCIsInNpemUkMCIsImZ1bGwkMCIsImF2YWlsYWJsZSQwIiwiaXNfZW1wdHkkMCIsImxlbmd0aCQwIiwiY3JlYXRlJDAiLCJjb3B5JDAiLCJmcm9tIiwidiQwIiwiayIsInB1c2hfZXhuIiwicHVzaCQxIiwiY29uc19leG4iLCJjb25zJDAiLCJwb3BfZXhuJDAiLCJwb3AkMCIsInBlZWtfZXhuJDAiLCJwZWVrJDEiLCJjb21wcmVzcyQwIiwicHVzaF9leG4kMCIsInJldCIsInB1c2gkMiIsImtlZXBfZXhuJDAiLCJrZWVwJDAiLCJwZWVrJDIiLCJ1bnNhZmVfc2hpZnQkMCIsInNoaWZ0X2V4biQwIiwic2hpZnQkMCIsIml0ZXIkMCIsInJldl9pdGVyJDAiLCJmb2xkJDAiLCJwcCQwIiwiZHVtcCQwIiwiY2xlYXIkMCIsInVuc2FmZV9iaWdhcnJheSIsIm9uZSIsInR3byIsInkiLCJ0aHJlZSIsInoiLCJ5JDAiLCJtIiwicyIsInokMCIsInkkMiIsInEkMCIsInokMSIsInokMiIsInkkMyIsInkkMSIsIngkMCIsIngkMSIsInIkMCIsIngkMyIsInIkMSIsIm0kMCIsIngkNCIsIngkMiIsInEkMSIsInRhaWxfZXhuIiwidGFpbCIsInokMyIsInokNCIsInkkNCIsImdvIiwiaGQiLCJ0bCIsImEkMSIsImEkMiJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2tlL3NpZ3MubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9rZS9ya2UubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9rZS9ma2UubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7O0dBd01rQjs7SUFBQTs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHQ2hNbEI7Ozs7OztJQUFBOzs7Ozs7OztZQUtvQkEsS0FBS0MsR0FBRUMsR0FBSSxPQUFKQSxLQUFGRCxjQUFzQjtZQUMzQkUsTUFBTUYsR0FBSSxPQUFKQSxTQUFBQSxhQUFhO1lBQ25CRyxLQUFLSCxHQUFJLE9BQUpBLE9BQUFBLFNBQWE7WUFDbEJJLFVBQVVKLEdBQUksT0FBSkEsUUFBQUEsT0FBQUEsY0FBcUI7WUFDL0JLLEtBQUtMLEdBQUksV0FBSkEsTUFBSSxPQUZURyxLQUVLSCxvQkFBZ0I7WUFDckNNLE9BQU9DLEdBQUksT0FIS0osS0FHVEksR0FBVTtZQUVEQyxnQkFBZ0JQO0lBQ3hCLElBQU5RLFVBRDhCUjtJQUM5QlEsU0FBQUEsU0FBQUE7SUFBQUEsU0FBQUEsU0FBQUE7SUFBQUEsU0FBQUEsU0FBQUE7SUFBQUEsU0FBQUEsU0FBQUE7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dHlwZSAnYSB0XG4gICgqKiBUaGUgdHlwZSBvZiBxdWV1ZXMgY29udGFpbmluZyBlbGVtZW50cyBvZiB0eXBlIFsnYV0uICopXG5cbiAgZXhjZXB0aW9uIEVtcHR5XG4gICgqKiBSYWlzZWQgd2hlbiB7IXBlZWtfZXhufSBvciB7IXBvcF9leG59IGlzIGFwcGxpZWQgdG8gYW4gZW1wdHkgcXVldWUuICopXG5cbiAgdmFsIGVtcHR5IDogJ2EgdFxuICAoKiogQW4gZW1wdHkgcXVldWUuICopXG5cbiAgdmFsIGlzX2VtcHR5IDogJ2EgdCAtPiBib29sXG4gICgqKiBSZXR1cm4gW3RydWVdIGlmIHRoZSBnaXZlbiBxdWV1ZSBpcyBlbXB0eSwgW2ZhbHNlXSBvdGhlcndpc2UuICopXG5cbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gICgqKiBOdW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHF1ZXVlLiAqKVxuXG4gIHZhbCBwdXNoIDogJ2EgdCAtPiAnYSAtPiAnYSB0XG4gICgqKiBQdXNoIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgcXVldWUuICopXG5cbiAgdmFsIGNvbnMgOiAnYSB0IC0+ICdhIC0+ICdhIHRcbiAgKCoqIFB1c2ggZWxlbWVudCBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlLiAqKVxuXG4gIHZhbCBwZWVrIDogJ2EgdCAtPiAnYSBvcHRpb25cbiAgKCoqIFtwZWVrIHFdIHJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHF1ZXVlIFtxXSwgd2l0aG91dCByZW1vdmluZyBpdFxuICAgICBmcm9tIHRoZSBxdWV1ZS4gSWYgW3FdIGlzIGVtcHR5LCBpdCByZXR1cm5zIFtOb25lXS4gKilcblxuICB2YWwgcGVla19leG4gOiAnYSB0IC0+ICdhXG4gICgqKiBTYW1lIGFzIHshcGVla30gYnV0IGl0IHJhaXNlcyBhbiBleGNlcHRpb24gaWYgW3FdIGlzIGVtcHR5LiAqKVxuXG4gIHZhbCBwb3AgOiAnYSB0IC0+ICgnYSAqICdhIHQpIG9wdGlvblxuICAoKiogR2V0IGFuZCByZW1vdmUgdGhlIGZpcnN0IGVsZW1lbnQuIElmIFtxXSBpcyBlbXB0eSwgaXQgcmV0dXJucyBbTm9uZV0uICopXG5cbiAgdmFsIHBvcF9leG4gOiAnYSB0IC0+ICdhICogJ2EgdFxuICAoKiogU2FtZSBhcyB7IXBvcH0gYnV0IGl0IHJhaXNlcyBhbiBleGNlcHRpb24gaWYgW3FdIGlzIGVtcHR5LiAqKVxuXG4gIHZhbCB0YWlsIDogJ2EgdCAtPiAoJ2EgdCAqICdhKSBvcHRpb25cbiAgKCoqIEdldCBhbmQgcmVtb3ZlIHRoZSB7YiBsYXN0fSBlbGVtZW50LiBJZiBbcV0gaXMgZW1wdHksIGl0IHJldHVybnMgW05vbmVdLiAqKVxuXG4gIHZhbCB0YWlsX2V4biA6ICdhIHQgLT4gJ2EgdCAqICdhXG4gICgqKiBTYW1lIGFzIHshdGFpbH0gYnV0IGl0IHJhaXNlcyBhbiBleGNlcHRpb24gaWYgW3FdIGlzIGVtcHR5LiAqKVxuXG4gIHZhbCBpdGVyIDogKCdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAoKiogW2l0ZXIgZiBxXSBhcHBsaWVzIFtmXSBpbiB0dXJuIHRvIGFsbCBlbGVtZW50cyBvZiBbcV0sIGZyb20gdGhlIGxlYXN0XG4gICAgIHJlY2VudGx5IGVudGVyZWQgdG8gdGhlIG1vc3QgcmVjZW50bHkgZW50ZXJlZC4gVGhlIHF1ZXVlIGl0c2VsZiBpc1xuICAgICB1bmNoYW5nZWQuICopXG5cbiAgdmFsIHJldl9pdGVyIDogKCdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAoKiogW3Jldl9pdGVyIGYgcV0gYXBwbGllcyBbZl0gaW4gdHVybiB0byBhbGwgZWxlbWVudHMgb2YgW3FdLCBmcm9tIHRoZSBtb3N0XG4gICAgIHJlY2VudGx5IGVudGVyZWQgdG8gdGhlIGxlYXN0IHJlY2VudGx5IGVudGVyZWQuIFRoZSBxdWV1ZSBpdHNlbGYgaXNcbiAgICAgdW5jaGFuZ2VkLiAqKVxuXG4gIHZhbCBmb2xkIDogKCdhY2MgLT4gJ3ggLT4gJ2FjYykgLT4gJ2FjYyAtPiAneCB0IC0+ICdhY2NcbiAgKCoqIFtmb2xkIGYgYSBxXSBpcyBlcXVpdmFsZW50IHRvIFtMaXN0LmZvbGRfbGVmdCBmIGEgbF0sIHdoZXJlIFtsXSBpcyB0aGVcbiAgICAgbGlzdCBvZiBbcV0ncyBlbGVtZW50cy4gVGhlIHF1ZXVlIHJlbWFpbnMgdW5jaGFuZ2VkLiAqKVxuXG4gIHZhbCBwcCA6ID9zZXA6dW5pdCBGbXQudCAtPiAnYSBGbXQudCAtPiAnYSB0IEZtdC50XG4gICgqKiBQcmV0dHktcHJpbnRlciBvZiB7IXR9LiAqKVxuXG4gIHZhbCBkdW1wIDogJ2EgRm10LnQgLT4gJ2EgdCBGbXQudFxuICAoKiogSHVtYW4tcmVhZGFibGUgcHJldHR5LXByaW50ZXIgb2YgeyF0fS4gKilcbmVuZFxuXG5tb2R1bGUgdHlwZSBSID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICAoKiogVGhlIHR5cGUgb2YgcXVldWVzIGNvbnRhaW5pbmcgZWxlbWVudHMgb2YgdHlwZSBbJ2FdLiAqKVxuXG4gIGV4Y2VwdGlvbiBFbXB0eVxuICAoKiogUmFpc2VkIHdoZW4geyFwZWVrX2V4bn0sIHshcG9wX2V4bn0sIHshTi5rZWVwX2V4bn0gb3IgeyFOLnNoaWZ0X2V4bn0gaXNcbiAgICAgYXBwbGllZCB0byBhbiBlbXB0eSBxdWV1ZS4gKilcblxuICB2YWwgaXNfZW1wdHkgOiAoJ2EsICdiKSB0IC0+IGJvb2xcbiAgKCoqIFJldHVybiBbdHJ1ZV0gaWYgdGhlIGdpdmVuIHF1ZXVlIGlzIGVtcHR5LCBbZmFsc2VdIG90aGVyd2lzZS4gKilcblxuICB2YWwgY3JlYXRlIDogP2NhcGFjaXR5OmludCAtPiAoJ2EsICdiKSBCaWdhcnJheS5raW5kIC0+ICgnYSwgJ2IpIHRcbiAgKCoqIFJldHVybiBhIG5ldyBxdWV1ZSwgaW5pdGlhbGx5IGVtcHR5LiAqKVxuXG4gIHZhbCBjYXBhY2l0eSA6ICgnYSwgJ2IpIHQgLT4gaW50XG4gICgqKiBSZXR1cm5zIGhvdyBtYW55IG9iamVjdHMgW3RdIGNhbiBzdG9yZS4gKilcblxuICB2YWwgbGVuZ3RoIDogKCdhLCAnYikgdCAtPiBpbnRcbiAgKCoqIE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgcXVldWUuICopXG5cbiAgdmFsIHB1c2ggOiAoJ2EsICdiKSB0IC0+ICdhIC0+IHVuaXRcbiAgKCoqIFtwdXNoIHEgeF0gYWRkcyB0aGUgZWxlbWVudHMgW3hdIGF0IHRoZSBlbmQgb2YgdGhlIHF1ZXVlIFtxXS4gKilcblxuICB2YWwgcG9wIDogKCdhLCAnYikgdCAtPiAnYSBvcHRpb25cbiAgKCoqIFtwb3AgcV0gcmVtb3ZlcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBpbiBxdWV1ZSBbcV0uIElmIFtxXSBpc1xuICAgICBlbXB0eSwgaXQgcmV0dXJucyBbTm9uZV0uICopXG5cbiAgdmFsIHBvcF9leG4gOiAoJ2EsICdiKSB0IC0+ICdhXG4gICgqKiBbcG9wX2V4bl0gaXMgdGhlIHNhbWUgYXMgeyFwb3B9IGJ1dCBpdCByYWlzZXMgeyFFbXB0eX0gd2hlbiB0aGUgZ2l2ZW5cbiAgICAgcXVldWUgW3FdIGlzIGVtcHR5LiAqKVxuXG4gIHZhbCBwZWVrIDogKCdhLCAnYikgdCAtPiAnYSBvcHRpb25cbiAgKCoqIFtwZWVrIHFdIHJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHF1ZXVlIFtxXSwgd2l0aG91dCByZW1vdmluZyBpdFxuICAgICBmcm9tIHRoZSBxdWV1ZS4gSWYgW3FdIGlzIGVtcHR5LCBpdCByZXR1cm5zIFtOb25lXS4gKilcblxuICB2YWwgcGVla19leG4gOiAoJ2EsICdiKSB0IC0+ICdhXG4gICgqKiBTYW1lIGFzIHshcGVla30gYnV0IGl0IHJhaXNlcyB7IUVtcHR5fSBpZiBbcV0gaXMgZW1wdHkuICopXG5cbiAgdmFsIGNvbnMgOiAoJ2EsICdiKSB0IC0+ICdhIC0+IHVuaXRcbiAgKCoqIFtjb25zIHEgeF0gYWRkcyBlbGVtZW50IFt4XSBhdCB0aGUgZnJvbnQgb2YgdGhlIGdpdmVuIHF1ZXVlIFtxXS4gSXRcbiAgICAgcmV0dXJucyBbTm9uZV0gaWYgaXQgZmFpbHMuICopXG5cbiAgdmFsIGNvcHkgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHRcbiAgKCoqIFJldHVybiBhIGNvcHkgb2YgdGhlIGdpdmVuIHF1ZXVlLiAqKVxuXG4gIHZhbCBjbGVhciA6ICgnYSwgJ2IpIHQgLT4gdW5pdFxuICAoKiogRGlzY2FyZCBhbGwgZWxlbWVudHMgZnJvbSBhIHF1ZXVlLiAqKVxuXG4gIHZhbCBjb21wcmVzcyA6ICgnYSwgJ2IpIHQgLT4gdW5pdFxuICAoKiogQ29tcHJlc3MgcXVldWUsIHJlYWQgY3Vyc29yIHdpbGwgYmUgc2V0dGVkIHRvIFswXSBhbmQgZGF0YSB3aWxsIGJlIG1vdmVcbiAgICAgdG8uIFRoaXMgb3BlcmF0aW9uIGFsbG93cyB0byBwcm92aWRlIG11Y2ggbW9yZSBzcGFjZSBmb3IgYVxuICAgICB7IXB1c2h9L3shTi5wdXNofSBvcGVyYXRpb24gLSBidXQgaXQgY2FuIG5vdCBlbnN1cmUgZW5vdWdoIGZyZWUgc3BhY2UuICopXG5cbiAgbW9kdWxlIE4gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIGJpZ2FycmF5ID0gKCdhLCAnYiwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkFycmF5MS50XG4gICAgKCoqIFRoZSB0eXBlIG9mIHRoZSBpbnRlcm5hbCBiaWdhcnJheSBvZiB7IXR9LiAqKVxuXG4gICAgdHlwZSAoJ2EsICdiKSBibGl0ID0gJ2EgLT4gaW50IC0+ICdiIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICgqKiBUaGUgdHlwZSBvZiB0aGUgW2JsaXRdIGZ1bmN0aW9uLiAqKVxuXG4gICAgdHlwZSAnYSBsZW5ndGggPSAnYSAtPiBpbnRcbiAgICAoKiogVGhlIHR5cGUgb2YgdGhlIFtsZW5ndGhdIGZ1bmN0aW9uLiAqKVxuXG4gICAgdmFsIHB1c2ggOlxuICAgICAgKCdhLCAnYikgdCAtPlxuICAgICAgYmxpdDooJ3NyYywgKCdhLCAnYikgYmlnYXJyYXkpIGJsaXQgLT5cbiAgICAgIGxlbmd0aDonc3JjIGxlbmd0aCAtPlxuICAgICAgP29mZjppbnQgLT5cbiAgICAgID9sZW46aW50IC0+XG4gICAgICAnc3JjIC0+XG4gICAgICB1bml0XG4gICAgKCoqIFtwdXNoIHEgfmJsaXQgfmxlbmd0aCA/b2ZmID9sZW4gc3JjXSB7aSBibGl0c30gZWxlbWVudHMgaW4gW3NyY10gdG8gdGhlXG4gICAgICAgZ2l2ZW4gcXVldWUgW3FdIGF0IHRoZSBlbmQgKGxpa2UgYSBmYXN0IGl0ZXJhdGl2ZSB7IVIucHVzaH0pLiBEZWZhdWx0XG4gICAgICAgdmFsdWUgb2YgW29mZl0gaXMgWzBdLiBEZWZhdWx0IHZhbHVlIG9mIFtsZW5dIGlzIFtsZW5ndGggc3JjIC0gb2ZmXS4gKilcblxuICAgIHZhbCBrZWVwX2V4biA6XG4gICAgICAoJ2EsICdiKSB0IC0+XG4gICAgICBibGl0OigoJ2EsICdiKSBiaWdhcnJheSwgJ2RzdCkgYmxpdCAtPlxuICAgICAgbGVuZ3RoOidkc3QgbGVuZ3RoIC0+XG4gICAgICA/b2ZmOmludCAtPlxuICAgICAgP2xlbjppbnQgLT5cbiAgICAgICdkc3QgLT5cbiAgICAgIHVuaXRcbiAgICAoKiogW2tlZXBfZXhuIHEgfmJsaXQgfmxlbmd0aCA/b2ZmID9sZW4gZHN0XSB7aSBibGl0c30gZWxlbWVudHMgb2YgdGhlIGdpdmVuXG4gICAgICAgcXVldWUgW3FdIGluIFtkc3RdIGZyb20gdGhlIGZyb250IHRvIHRoZSBlbmQgb2YgW2RzdF0gKGxpa2UgYSBmYXN0XG4gICAgICAgaXRlcmF0aXZlIHshUi5wb3BfZXhufSkuIERlZmF1bHQgdmFsdWUgb2YgW29mZl0gaXMgWzBdLiBEZWZhdWx0IHZhbHVlIG9mXG4gICAgICAgW2xlbl0gaXMgW2xlbmd0aCBkc3QgLSBvZmZdLiBJZiB0aGUgZ2l2ZW4gW3FdIGRvZXMgbm90IGhhdmUgZW5vdWdoXG4gICAgICAgZWxlbWVudHMgdG8gd3JpdGUgb24gW2RzdF0sIGl0IHJhaXNlcyB7IUVtcHR5fSBhbmQgdGhlIGdpdmVuIHF1ZXVlIGlzXG4gICAgICAgdW5jaGFuZ2VkLiAqKVxuXG4gICAgdmFsIGtlZXAgOlxuICAgICAgKCdhLCAnYikgdCAtPlxuICAgICAgYmxpdDooKCdhLCAnYikgYmlnYXJyYXksICdkc3QpIGJsaXQgLT5cbiAgICAgIGxlbmd0aDonZHN0IGxlbmd0aCAtPlxuICAgICAgP29mZjppbnQgLT5cbiAgICAgID9sZW46aW50IC0+XG4gICAgICAnZHN0IC0+XG4gICAgICB1bml0IG9wdGlvblxuICAgICgqKiBTYW1lIGFzIHsha2VlcF9leG59IGJ1dCBpZiBpdCBmYWlscywgaXQgcmV0dXJucyBbTm9uZV0uICopXG5cbiAgICB2YWwgcGVlayA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYiwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkFycmF5MS50IGxpc3RcbiAgICAoKiogUmV0dXJucyBhIHN1Yi1wYXJ0IG9mIGF2YWlsYWJsZSB0byByZWFkIHBheWxvYWRzLiAqKVxuXG4gICAgdmFsIHVuc2FmZV9zaGlmdCA6ICgnYSwgJ2IpIHQgLT4gaW50IC0+IHVuaXRcbiAgICAoKiogW3Vuc2FmZV9zaGlmdCBxIGxdIGRpc2NhcmRzIFtsXSBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gcXVldWUgW3FdIHdpdGhvdXRcbiAgICAgICBhbnkgdmVyaWZpY2F0aW9uLiBNb3N0bHkgdXNlZCBhZnRlciB7IWtlZXBfZXhufSwgaWYgdGhlIGxhc3Qgb25lIGRvZXMgbm90XG4gICAgICAgcmFpc2UgeyFFbXB0eX0sIGl0J3Mgc2FmZSB0byB1c2UgaXQuICopXG5cbiAgICB2YWwgc2hpZnRfZXhuIDogKCdhLCAnYikgdCAtPiBpbnQgLT4gdW5pdFxuICAgICgqKiBbc2hpZnRfZXhuIHEgbF0gZGlzY2FyZHMgW2xdIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBxdWV1ZSBbcV0uIElmIFtxXVxuICAgICAgIGRvZXMgbm90IGhhdmUgZW5vdWdoIGVsZW1lbnRzLCBpdCByYWlzZXMgeyFFbXB0eX0gYW5kIHRoZSBnaXZlbiBxdWV1ZSBpc1xuICAgICAgIHVuY2hhbmdlZC4gKilcblxuICAgIHZhbCBzaGlmdCA6ICgnYSwgJ2IpIHQgLT4gaW50IC0+IHVuaXQgb3B0aW9uXG4gICAgKCoqIFNhbWUgYXMgeyFzaGlmdF9leG59IGJ1dCBpZiBpdCBmYWlscywgaXQgcmV0dXJucyBbTm9uZV0uICopXG4gIGVuZFxuXG4gIHZhbCBpdGVyIDogKCdhIC0+IHVuaXQpIC0+ICgnYSwgJ2IpIHQgLT4gdW5pdFxuICAoKiogW2l0ZXIgZiBxXSBhcHBsaWVzIFtmXSBpbiB0dXJuIHRvIGFsbCBlbGVtZW50cyBvZiBbcV0sIGZyb20gdGhlIGxlYXN0XG4gICAgIHJlY2VudGx5IGVudGVyZWQgdG8gdGhlIG1vc3QgcmVjZW50bHkgZW50ZXJlZC4gVGhlIHF1ZXVlIGl0c2VsZiBpc1xuICAgICB1bmNoYW5nZWQuICopXG5cbiAgdmFsIHJldl9pdGVyIDogKCdhIC0+IHVuaXQpIC0+ICgnYSwgJ2IpIHQgLT4gdW5pdFxuICAoKiogW2l0ZXIgZiBxXSBhcHBsaWVzIFtmXSBpbiB0dXJuIHRvIGFsbCBlbGVtZW50cyBvZiBbcV0sIGZyb20gdGhlIG1vc3RcbiAgICAgcmVjZW50bHkgZW50ZXJlZCB0byB0aGUgbGVhc3QgcmVjZW50bHkgZW50ZXJlZC4gVGhlIHF1ZXVlIGl0c2VsZiBpc1xuICAgICB1bmNoYW5nZWQuICopXG5cbiAgdmFsIGZvbGQgOiAoJ2FjYyAtPiAneCAtPiAnYWNjKSAtPiAnYWNjIC0+ICgneCwgJ2IpIHQgLT4gJ2FjY1xuICAoKiogW2ZvbGQgZiBhIHFdIGlzIGVxdWl2YWxlbnQgdG8gW0xpc3QuZm9sZF9sZWZ0IGYgYSBsXSwgd2hlcmUgW2xdIGlzIHRoZVxuICAgICBsaXN0IG9mIFtxXSdzIGVsZW1lbnRzLiBUaGUgcXVldWUgcmVtYWlucyB1bmNoYW5nZWQuICopXG5cbiAgdmFsIHBwIDogP3NlcDp1bml0IEZtdC50IC0+ICdhIEZtdC50IC0+ICgnYSwgJ2IpIHQgRm10LnRcbiAgKCoqIFByZXR0eS1wcmludGVyIG9mIHshdH0uICopXG5cbiAgdmFsIGR1bXAgOiAnYSBGbXQudCAtPiAoJ2EsICdiKSB0IEZtdC50XG4gICgqKiBIdW1hbi1yZWFkYWJsZSBwcmV0dHktcHJpbnRlciBvZiB7IXR9LiAqKVxuZW5kXG5cbm1vZHVsZSBXZWlnaHRlZCA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBSID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG4gICAgKCoqIFRoZSB0eXBlIG9mIHF1ZXVlcyBjb250YWluaW5nIGVsZW1lbnRzIG9mIHR5cGUgWydhXS4gKilcblxuICAgIGV4Y2VwdGlvbiBGdWxsXG4gICAgKCoqIFJhaXNlZCB3aGVuIHshcHVzaF9leG59IG9yIHshTi5wdXNoX2V4bn0gaXMgYXBwbGllZCB0byBhbiBlbXB0eSBxdWV1ZS4gKilcblxuICAgIGV4Y2VwdGlvbiBFbXB0eVxuICAgICgqKiBSYWlzZWQgd2hlbiB7IXBlZWtfZXhufSwgeyFwb3BfZXhufSBpcyBhcHBsaWVkIHRvIGFuIGVtcHR5IHF1ZXVlLiAqKVxuXG4gICAgdmFsIGlzX2VtcHR5IDogKCdhLCAnYikgdCAtPiBib29sXG4gICAgKCoqIFJldHVybiBbdHJ1ZV0gaWYgdGhlIGdpdmVuIHF1ZXVlIGlzIGVtcHR5LCBbZmFsc2VdIG90aGVyd2lzZS4gKilcblxuICAgIHZhbCBjcmVhdGUgOiA/Y2FwYWNpdHk6aW50IC0+ICgnYSwgJ2IpIEJpZ2FycmF5LmtpbmQgLT4gKCdhLCAnYikgdCAqIGludFxuICAgICgqKiBSZXR1cm4gYSBuZXcgcXVldWUsIGluaXRpYWxseSBlbXB0eSB3aXRoIHRoZSByZWFsIGNhcGFjaXR5IG9mIGl0LiAqKVxuXG4gICAgdmFsIGxlbmd0aCA6ICgnYSwgJ2IpIHQgLT4gaW50XG4gICAgKCoqIE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgcXVldWUuICopXG5cbiAgICB2YWwgYXZhaWxhYmxlIDogKCdhLCAnYikgdCAtPiBpbnRcbiAgICAoKiogRnJlZSBjZWxscyBhdmFpbGFibGVzIG9uIHRoZSBxdWV1ZS4gKilcblxuICAgIHZhbCBwdXNoX2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gdW5pdFxuICAgICgqKiBbcHVzaF9leG4gcSB4XSBhZGRzIHRoZSBlbGVtZW50cyBbeF0gYXQgdGhlIGVuZCBvZiB0aGUgcXVldWUgW3FdLiBJdFxuICAgICAgIHJhaXNlcyB7IUZ1bGx9IGlmIHRoZSBnaXZlbiBxdWV1ZSBbcV0gaXMgZnVsbC4gKilcblxuICAgIHZhbCBwdXNoIDogKCdhLCAnYikgdCAtPiAnYSAtPiB1bml0IG9wdGlvblxuICAgICgqKiBbcHVzaCBxIHhdIGlzIHRoZSBzYW1lIGFzIHshcHVzaF9leG59IGJ1dCByZXR1cm5zIFtOb25lXSBpZiBpdCBmYWlscy4gKilcblxuICAgIHZhbCBwb3AgOiAoJ2EsICdiKSB0IC0+ICdhIG9wdGlvblxuICAgICgqKiBbcG9wIHFdIHJlbW92ZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGdpdmVuIHF1ZXVlIFtxXS4gSWZcbiAgICAgICBbcV0gaXMgZW1wdHksIGl0IHJldHVybnMgW05vbmVdLiAqKVxuXG4gICAgdmFsIHBvcF9leG4gOiAoJ2EsICdiKSB0IC0+ICdhXG4gICAgKCoqIFtwb3BfZXhuIHFdIGlzIHRoZSBzYW1lIGFzIHshcG9wfSBidXQgaXQgcmFpc2VzIGFuIHshRW1wdHl9IGlmIHRoZSBnaXZlblxuICAgICAgIHF1ZXVlIGlzIGVtcHR5LiAqKVxuXG4gICAgdmFsIHBlZWsgOiAoJ2EsICdiKSB0IC0+ICdhIG9wdGlvblxuICAgICgqKiBbcGVlayBxXSByZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBnaXZlbiBxdWV1ZSBbcV0uIElmIFtxXSBpc1xuICAgICAgIGVtcHR5LCBpdCByZXR1cm5zIFtOb25lXS4gKilcblxuICAgIHZhbCBwZWVrX2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2FcbiAgICAoKiogW3BlZWtfZXhuIHFdIHJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGdpdmVuIHF1ZXVlIFtxXS4gSWYgW3FdIGlzXG4gICAgICAgZW1wdHksIGl0IHJhaXNlcyB7IUVtcHR5fS4gKilcblxuICAgIHZhbCBjb25zX2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gdW5pdFxuICAgICgqKiBbY29uc19leG4gcSB4XSBhZGRzIGVsZW1lbnQgW3hdIGF0IHRoZSBmcm9udCBvZiB0aGUgZ2l2ZW4gcXVldWUgW3FdLiBJdFxuICAgICAgIHJhaXNlcyB7IUZ1bGx9IGlmIHRoZSBxdWV1ZSBpcyBmdWxsLiAqKVxuXG4gICAgdmFsIGNvbnMgOiAoJ2EsICdiKSB0IC0+ICdhIC0+IHVuaXQgb3B0aW9uXG4gICAgKCoqIFtjb25zIHEgeF0gYWRkcyBlbGVtZW50IFt4XSBhdCB0aGUgZnJvbnQgb2YgdGhlIGdpdmVuIHF1ZXVlIFtxXS4gSXRcbiAgICAgICByZXR1cm5zIFtOb25lXSBpZiBpdCBmYWlscy4gKilcblxuICAgIHZhbCBjb3B5IDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0XG4gICAgKCoqIFJldHVybiBhIGNvcHkgb2YgdGhlIGdpdmVuIHF1ZXVlLiAqKVxuXG4gICAgdmFsIGNsZWFyIDogKCdhLCAnYikgdCAtPiB1bml0XG4gICAgKCoqIERpc2NhcmQgYWxsIGVsZW1lbnRzIGZyb20gYSBxdWV1ZS4gKilcblxuICAgIHZhbCBjb21wcmVzcyA6ICgnYSwgJ2IpIHQgLT4gdW5pdFxuICAgICgqKiBDb21wcmVzcyBxdWV1ZSwgcmVhZCBjdXJzb3Igd2lsbCBiZSBzZXR0ZWQgdG8gWzBdIGFuZCBkYXRhIHdpbGwgYmUgbW92ZVxuICAgICAgIHRvLiBUaGlzIG9wZXJhdGlvbiBhbGxvd3MgdG8gcHJvdmlkZSBtdWNoIG1vcmUgc3BhY2UgZm9yIGFcbiAgICAgICB7IXB1c2h9L3shTi5wdXNofSBvcGVyYXRpb24gLSBidXQgaXQgY2FuIG5vdCBlbnN1cmUgZW5vdWdoIGZyZWUgc3BhY2UuICopXG5cbiAgICBtb2R1bGUgTiA6IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiKSBiaWdhcnJheSA9ICgnYSwgJ2IsIEJpZ2FycmF5LmNfbGF5b3V0KSBCaWdhcnJheS5BcnJheTEudFxuICAgICAgKCoqIFRoZSB0eXBlIG9mIHRoZSBpbnRlcm5hbCBiaWdhcnJheSBvZiB7IXR9LiAqKVxuXG4gICAgICB0eXBlICgnYSwgJ2IpIGJsaXQgPSAnYSAtPiBpbnQgLT4gJ2IgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAoKiogVGhlIHR5cGUgb2YgdGhlIFtibGl0XSBmdW5jdGlvbi4gKilcblxuICAgICAgdHlwZSAnYSBsZW5ndGggPSAnYSAtPiBpbnRcbiAgICAgICgqKiBUaGUgdHlwZSBvZiB0aGUgW2xlbmd0aF0gZnVuY3Rpb24uICopXG5cbiAgICAgIHZhbCBwdXNoX2V4biA6XG4gICAgICAgICgnYSwgJ2IpIHQgLT5cbiAgICAgICAgYmxpdDooJ3NyYywgKCdhLCAnYikgYmlnYXJyYXkpIGJsaXQgLT5cbiAgICAgICAgbGVuZ3RoOidzcmMgbGVuZ3RoIC0+XG4gICAgICAgID9vZmY6aW50IC0+XG4gICAgICAgID9sZW46aW50IC0+XG4gICAgICAgICdzcmMgLT5cbiAgICAgICAgKCdhLCAnYikgYmlnYXJyYXkgbGlzdFxuICAgICAgKCoqIFtwdXNoX2V4biBxIH5ibGl0IH5sZW5ndGggP29mZiA/bGVuIHNyY10ge2kgYmxpdHN9IGVsZW1lbnRzIGluIFtzcmNdXG4gICAgICAgICB0byB0aGUgZ2l2ZW4gcXVldWUgW3FdIGF0IHRoZSBlbmQgKGxpa2UgYSBmYXN0IGl0ZXJhdGl2ZSB7IVIucHVzaH0pLlxuICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBbb2ZmXSBpcyBbMF0uIERlZmF1bHQgdmFsdWUgb2YgW2xlbl0gaXMgW2xlbmd0aCBzcmMgLSBvZmZdLlxuICAgICAgICAgSXQgcmV0dXJucyBhIGxpc3Qgb2YgaW50ZXJuYWwgeyFiaWdhcnJheX1zIHdoaWNoIGNvbnRhaW4gW2RzdF0uXG4gICAgICAgICBJZiB0aGUgZ2l2ZW4gW3FdIGRvZXMgbm90IGhhdmUgZW5vdWdoIGZyZWUgc3BhY2UgdG8gd3JpdGUgW3NyY10sIGl0XG4gICAgICAgICByYWlzZXMgeyFGdWxsfSBhbmQgdGhlIGdpdmVuIHF1ZXVlIGlzIHVuY2hhbmdlZC4gKilcblxuICAgICAgdmFsIHB1c2ggOlxuICAgICAgICAoJ2EsICdiKSB0IC0+XG4gICAgICAgIGJsaXQ6KCdzcmMsICgnYSwgJ2IpIGJpZ2FycmF5KSBibGl0IC0+XG4gICAgICAgIGxlbmd0aDonc3JjIGxlbmd0aCAtPlxuICAgICAgICA/b2ZmOmludCAtPlxuICAgICAgICA/bGVuOmludCAtPlxuICAgICAgICAnc3JjIC0+XG4gICAgICAgICgnYSwgJ2IpIGJpZ2FycmF5IGxpc3Qgb3B0aW9uXG4gICAgICAoKiogU2FtZSBhcyB7IXB1c2hfZXhufSBidXQgaXQgcmV0dXJucyBbTm9uZV0gaWYgaXQgZmFpbHMuICopXG5cbiAgICAgIHZhbCBrZWVwX2V4biA6XG4gICAgICAgICgnYSwgJ2IpIHQgLT5cbiAgICAgICAgYmxpdDooKCdhLCAnYikgYmlnYXJyYXksICdkc3QpIGJsaXQgLT5cbiAgICAgICAgbGVuZ3RoOidkc3QgbGVuZ3RoIC0+XG4gICAgICAgID9vZmY6aW50IC0+XG4gICAgICAgID9sZW46aW50IC0+XG4gICAgICAgICdkc3QgLT5cbiAgICAgICAgdW5pdFxuICAgICAgKCoqIFtrZWVwX2V4biBxIH5ibGl0IH5sZW5ndGggP29mZiA/bGVuIGRzdF0ge2kgYmxpdHN9IGVsZW1lbnRzIG9mIHRoZVxuICAgICAgICAgZ2l2ZW4gcXVldWUgW3FdIGluIFtkc3RdIGZyb20gdGhlIGZyb250IHRvIHRoZSBlbmQgb2YgW2RzdF0gKGxpa2UgYVxuICAgICAgICAgZmFzdCBpdGVyYXRpdmUgeyFSLnBvcF9leG59KS4gRGVmYXVsdCB2YWx1ZSBvZiBbb2ZmXSBpcyBbMF0uIERlZmF1bHRcbiAgICAgICAgIHZhbHVlIG9mIFtsZW5dIGlzIFtsZW5ndGggZHN0IC0gb2ZmXS4gSWYgdGhlIGdpdmVuIFtxXSBkb2VzIG5vdCBoYXZlXG4gICAgICAgICBlbm91Z2ggZWxlbWVudHMgdG8gd3JpdGUgb24gW2RzdF0sIGl0IHJhaXNlcyB7IUVtcHR5fS4gSW4gYW55IGNhc2UsIHRoZVxuICAgICAgICAgZ2l2ZW4gcXVldWUgaXMgdW5jaGFuZ2VkLiAqKVxuXG4gICAgICB2YWwga2VlcCA6XG4gICAgICAgICgnYSwgJ2IpIHQgLT5cbiAgICAgICAgYmxpdDooKCdhLCAnYikgYmlnYXJyYXksICdkc3QpIGJsaXQgLT5cbiAgICAgICAgbGVuZ3RoOidkc3QgbGVuZ3RoIC0+XG4gICAgICAgID9vZmY6aW50IC0+XG4gICAgICAgID9sZW46aW50IC0+XG4gICAgICAgICdkc3QgLT5cbiAgICAgICAgdW5pdCBvcHRpb25cbiAgICAgICgqKiBTYW1lIGFzIHsha2VlcF9leG59IGJ1dCBpZiBpdCBmYWlscywgaXQgcmV0dXJucyBbTm9uZV0uICopXG5cbiAgICAgIHZhbCBwZWVrIDpcbiAgICAgICAgKCdhLCAnYikgdCAtPiAoJ2EsICdiLCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuQXJyYXkxLnQgbGlzdFxuICAgICAgKCoqIFJldHVybnMgYSBzdWItcGFydCBvZiBhdmFpbGFibGUgdG8gcmVhZCBwYXlsb2Fkcy4gKilcblxuICAgICAgdmFsIHVuc2FmZV9zaGlmdCA6ICgnYSwgJ2IpIHQgLT4gaW50IC0+IHVuaXRcbiAgICAgICgqKiBbdW5zYWZlX3NoaWZ0IHEgbF0gZGlzY2FyZHMgW2xdIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBxdWV1ZSBbcV1cbiAgICAgICAgIHdpdGhvdXQgYW55IHZlcmlmaWNhdGlvbi4gTW9zdGx5IHVzZWQgYWZ0ZXIgeyFrZWVwX2V4bn0sIGlmIHRoZSBsYXN0XG4gICAgICAgICBvbmUgZG9lcyBub3QgcmFpc2UgeyFFbXB0eX0sIGl0J3Mgc2FmZSB0byB1c2UgaXQuICopXG5cbiAgICAgIHZhbCBzaGlmdF9leG4gOiAoJ2EsICdiKSB0IC0+IGludCAtPiB1bml0XG4gICAgICAoKiogW3NoaWZ0X2V4biBxIGxdIGRpc2NhcmRzIFtsXSBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gcXVldWUgW3FdLiBJZiBbcV1cbiAgICAgICAgIGRvZXMgbm90IGhhdmUgZW5vdWdoIGVsZW1lbnRzLCBpdCByYWlzZXMgeyFFbXB0eX0gYW5kIHRoZSBnaXZlbiBxdWV1ZVxuICAgICAgICAgaXMgdW5jaGFuZ2VkLiAqKVxuXG4gICAgICB2YWwgc2hpZnQgOiAoJ2EsICdiKSB0IC0+IGludCAtPiB1bml0IG9wdGlvblxuICAgICAgKCoqIFNhbWUgYXMgeyFzaGlmdF9leG59IGJ1dCBpZiBpdCBmYWlscywgaXQgcmV0dXJucyBbTm9uZV0uICopXG4gICAgZW5kXG5cbiAgICB2YWwgaXRlciA6ICgnYSAtPiB1bml0KSAtPiAoJ2EsICdiKSB0IC0+IHVuaXRcbiAgICAoKiogW2l0ZXIgZiBxXSBhcHBsaWVzIFtmXSBpbiB0dXJuIHRvIGFsbCBlbGVtZW50cyBvZiBbcV0sIGZyb20gdGhlIGxlYXN0XG4gICAgICAgcmVjZW50bHkgZW50ZXJlZCB0byB0aGUgbW9zdCByZWNlbnRseSBlbnRlcmVkLiBUaGUgcXVldWUgaXRzZWxmIGlzXG4gICAgICAgdW5jaGFuZ2VkLiAqKVxuXG4gICAgdmFsIHJldl9pdGVyIDogKCdhIC0+IHVuaXQpIC0+ICgnYSwgJ2IpIHQgLT4gdW5pdFxuICAgICgqKiBbaXRlciBmIHFdIGFwcGxpZXMgW2ZdIGluIHR1cm4gdG8gYWxsIGVsZW1lbnRzIG9mIFtxXSwgZnJvbSB0aGUgbW9zdFxuICAgICAgIHJlY2VudGx5IGVudGVyZWQgdG8gdGhlIGxlYXN0IHJlY2VudGx5IGVudGVyZWQuIFRoZSBxdWV1ZSBpdHNlbGYgaXNcbiAgICAgICB1bmNoYW5nZWQuICopXG5cbiAgICB2YWwgZm9sZCA6ICgnYWNjIC0+ICd4IC0+ICdhY2MpIC0+ICdhY2MgLT4gKCd4LCAnYikgdCAtPiAnYWNjXG4gICAgKCoqIFtmb2xkIGYgYSBxXSBpcyBlcXVpdmFsZW50IHRvIFtMaXN0LmZvbGRfbGVmdCBmIGEgbF0sIHdoZXJlIFtsXSBpcyB0aGVcbiAgICAgICBsaXN0IG9mIFtxXSdzIGVsZW1lbnRzLiBUaGUgcXVldWUgcmVtYWlucyB1bmNoYW5nZWQuICopXG5cbiAgICB2YWwgcHAgOiA/c2VwOnVuaXQgRm10LnQgLT4gJ2EgRm10LnQgLT4gKCdhLCAnYikgdCBGbXQudFxuICAgICgqKiBQcmV0dHktcHJpbnRlciBvZiB7IXR9LiAqKVxuXG4gICAgdmFsIGR1bXAgOiAnYSBGbXQudCAtPiAoJ2EsICdiKSB0IEZtdC50XG4gICAgKCoqIEh1bWFuLXJlYWRhYmxlIHByZXR0eS1wcmludGVyIG9mIHshdH0uICopXG5cbiAgICB2YWwgdW5zYWZlX2JpZ2FycmF5IDpcbiAgICAgICgnYSwgJ2IpIHQgLT4gKCdhLCAnYiwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkFycmF5MS50XG4gICAgKCoqIC8gKiopXG5cbiAgICB2YWwgZnJvbSA6ICgnYSwgJ2IsIEJpZ2FycmF5LmNfbGF5b3V0KSBCaWdhcnJheS5BcnJheTEudCAtPiAoJ2EsICdiKSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEYgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcbiAgICAoKiogVGhlIHR5cGUgb2YgcXVldWVzIGNvbnRhaW5pbmcgZWxlbWVudHMgb2YgdHlwZSBbJ2FdLiAqKVxuXG4gICAgZXhjZXB0aW9uIEVtcHR5XG4gICAgKCoqIFJhaXNlZCB3aGVuIHshcHVzaF9leG59IG9yIHshTi5wdXNoX2V4bn0gaXMgYXBwbGllZCB0byBhbiBlbXB0eSBxdWV1ZS4gKilcblxuICAgIGV4Y2VwdGlvbiBGdWxsXG4gICAgKCoqIFJhaXNlZCB3aGVuIHshcGVla19leG59LCB7IXBvcF9leG59IGlzIGFwcGxpZWQgdG8gYW4gZW1wdHkgcXVldWUuICopXG5cbiAgICB2YWwgaXNfZW1wdHkgOiAoJ2EsICdiKSB0IC0+IGJvb2xcbiAgICAoKiogUmV0dXJuIFt0cnVlXSBpZiB0aGUgZ2l2ZW4gcXVldWUgaXMgZW1wdHksIFtmYWxzZV0gb3RoZXJ3aXNlLiAqKVxuXG4gICAgdmFsIGNyZWF0ZSA6ID9jYXBhY2l0eTppbnQgLT4gKCdhLCAnYikgQmlnYXJyYXkua2luZCAtPiAoJ2EsICdiKSB0ICogaW50XG4gICAgKCoqIFJldHVybiBhIG5ldyBxdWV1ZSwgaW5pdGlhbGx5IGVtcHR5IHdpdGggdGhlIHJlYWwgY2FwYWNpdHkgb2YgaXQuICopXG5cbiAgICB2YWwgbGVuZ3RoIDogKCdhLCAnYikgdCAtPiBpbnRcbiAgICAoKiogTnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS4gKilcblxuICAgIHZhbCBhdmFpbGFibGUgOiAoJ2EsICdiKSB0IC0+IGludFxuICAgICgqKiBGcmVlIGNlbGxzIGF2YWlsYWJsZXMgb24gdGhlIHF1ZXVlLiAqKVxuXG4gICAgdmFsIHB1c2hfZXhuIDogKCdhLCAnYikgdCAtPiAnYSAtPiAoJ2EsICdiKSB0XG4gICAgKCoqIFtwdXNoX2V4biBxIHhdIGFkZHMgdGhlIGVsZW1lbnRzIFt4XSBhdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZSBbcV0gYW5kXG4gICAgICAgcmV0dXJucyB0aGUgbmV3IHF1ZXVlIFtxJ10uIEl0IHJhaXNlcyB7IUZ1bGx9IGlmIHRoZSBnaXZlbiBxdWV1ZSBbcV0gaXNcbiAgICAgICBmdWxsLiAqKVxuXG4gICAgdmFsIHB1c2ggOiAoJ2EsICdiKSB0IC0+ICdhIC0+ICgnYSwgJ2IpIHQgb3B0aW9uXG4gICAgKCoqIFtwdXNoIHEgeF0gaXMgdGhlIHNhbWUgYXMgeyFwdXNoX2V4bn0gYnV0IHJldHVybnMgW05vbmVdIGlmIGl0IGZhaWxzLiAqKVxuXG4gICAgdmFsIHBvcCA6ICgnYSwgJ2IpIHQgLT4gKCdhICogKCdhLCAnYikgdCkgb3B0aW9uXG4gICAgKCoqIFtwb3AgcV0gcmVtb3ZlcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgZ2l2ZW4gcXVldWUgW3FdIGFuZFxuICAgICAgIHJldHVybnMgdGhlIG5ldyBxdWV1ZSBbcSddLiBJZiBbcV0gaXMgZW1wdHksIGl0IHJldHVybnMgW05vbmVdLiAqKVxuXG4gICAgdmFsIHBvcF9leG4gOiAoJ2EsICdiKSB0IC0+ICdhICogKCdhLCAnYikgdFxuICAgICgqKiBbcG9wX2V4biBxXSBpcyB0aGUgc2FtZSBhcyB7IXBvcH0gYnV0IGl0IHJhaXNlcyBhbiB7IUVtcHR5fSBpZiB0aGUgZ2l2ZW5cbiAgICAgICBxdWV1ZSBpcyBlbXB0eS4gKilcblxuICAgIHZhbCBwZWVrIDogKCdhLCAnYikgdCAtPiAnYSBvcHRpb25cbiAgICAoKiogW3BlZWsgcV0gcmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgZ2l2ZW4gcXVldWUgW3FdLiBJZiBbcV0gaXNcbiAgICAgICBlbXB0eSwgaXQgcmV0dXJucyBbTm9uZV0uIFRoZSBnaXZlbiBxdWV1ZSBbcV0gaXMgdW5jaGFuZ2VkLiAqKVxuXG4gICAgdmFsIHBlZWtfZXhuIDogKCdhLCAnYikgdCAtPiAnYVxuICAgICgqKiBbcGVla19leG4gcV0gcmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgZ2l2ZW4gcXVldWUgW3FdLiBJZiBbcV0gaXNcbiAgICAgICBlbXB0eSwgaXQgcmFpc2VzIHshRW1wdHl9LiAqKVxuXG4gICAgdmFsIGNvbnMgOiAoJ2EsICdiKSB0IC0+ICdhIC0+ICgnYSwgJ2IpIHQgb3B0aW9uXG4gICAgKCoqIFtjb25zIHEgeF0gYWRkcyBlbGVtZW50IFt4XSBhdCB0aGUgZnJvbnQgb2YgdGhlIGdpdmVuIHF1ZXVlIFtxXS4gSXRcbiAgICAgICByZXR1cm5zIFtOb25lXSBpZiBpdCBmYWlscyBvciB0aGUgbmV3IHF1ZXVlIFtxJ10uICopXG5cbiAgICB2YWwgY29uc19leG4gOiAoJ2EsICdiKSB0IC0+ICdhIC0+ICgnYSwgJ2IpIHRcbiAgICAoKiogW2NvbnMgcSB4XSBhZGRzIGVsZW1lbnQgW3hdIGF0IHRoZSBmcm9udCBvZiB0aGUgZ2l2ZW4gcXVldWUgW3FdLiBJdFxuICAgICAgIHJhaXNlcyB7IUVtcHR5fSBpZiB0aGUgZ2l2ZW4gcXVldWUgW3FdIGlzIGZ1bGwgb3IgdGhlIG5ldyBxdWV1ZSBbcSddLiAqKVxuXG4gICAgdmFsIGNvcHkgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHRcbiAgICAoKiogUmV0dXJuIGEgY29weSBvZiB0aGUgZ2l2ZW4gcXVldWUuICopXG5cbiAgICB2YWwgY2xlYXIgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHRcbiAgICAoKiogRGlzY2FyZCBhbGwgZWxlbWVudHMgZnJvbSBhIHF1ZXVlLiAqKVxuXG4gICAgbW9kdWxlIE4gOiBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYikgYmlnYXJyYXkgPSAoJ2EsICdiLCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuQXJyYXkxLnRcbiAgICAgICgqKiBUaGUgdHlwZSBvZiB0aGUgaW50ZXJuYWwgYmlnYXJyYXkgb2YgeyF0fS4gKilcblxuICAgICAgdHlwZSAoJ2EsICdiKSBibGl0ID0gJ2EgLT4gaW50IC0+ICdiIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgKCoqIFRoZSB0eXBlIG9mIHRoZSBbYmxpdF0gZnVuY3Rpb24uICopXG5cbiAgICAgIHR5cGUgJ2EgbGVuZ3RoID0gJ2EgLT4gaW50XG4gICAgICAoKiogVGhlIHR5cGUgb2YgdGhlIFtsZW5ndGhdIGZ1bmN0aW9uLiAqKVxuXG4gICAgICB2YWwgcHVzaF9leG4gOlxuICAgICAgICAoJ2EsICdiKSB0IC0+XG4gICAgICAgIGJsaXQ6KCdzcmMsICgnYSwgJ2IpIGJpZ2FycmF5KSBibGl0IC0+XG4gICAgICAgIGxlbmd0aDonc3JjIGxlbmd0aCAtPlxuICAgICAgICA/b2ZmOmludCAtPlxuICAgICAgICA/bGVuOmludCAtPlxuICAgICAgICAnc3JjIC0+XG4gICAgICAgICgnYSwgJ2IpIGJpZ2FycmF5IGxpc3QgKiAoJ2EsICdiKSB0XG4gICAgICAoKiogW3B1c2hfZXhuIHEgfmJsaXQgfmxlbmd0aCA/b2ZmID9sZW4gc3JjXSB7aSBibGl0c30gZWxlbWVudHMgaW4gW3NyY11cbiAgICAgICAgIHRvIHRoZSBnaXZlbiBxdWV1ZSBbcV0gYXQgdGhlIGVuZCAobGlrZSBhIGZhc3QgaXRlcmF0aXZlIHshUi5wdXNofSkuXG4gICAgICAgICBEZWZhdWx0IHZhbHVlIG9mIFtvZmZdIGlzIFswXS4gRGVmYXVsdCB2YWx1ZSBvZiBbbGVuXSBpcyBbbGVuZ3RoIHNyYyAtIG9mZl0uXG4gICAgICAgICBJdCByZXR1cm5zIGEgbGlzdCBvZiBpbnRlcm5hbCB7IWJpZ2FycmF5fXMgd2hpY2ggY29udGFpbiBbZHN0XS5cbiAgICAgICAgIElmIHRoZSBnaXZlbiBbcV0gZG9lcyBub3QgaGF2ZSBlbm91Z2ggZnJlZSBzcGFjZSB0byB3cml0ZSBbc3JjXSwgaXRcbiAgICAgICAgIHJhaXNlcyB7IUZ1bGx9IGFuZCB0aGUgZ2l2ZW4gcXVldWUgaXMgdW5jaGFuZ2VkLiAqKVxuXG4gICAgICB2YWwgcHVzaCA6XG4gICAgICAgICgnYSwgJ2IpIHQgLT5cbiAgICAgICAgYmxpdDooJ3NyYywgKCdhLCAnYikgYmlnYXJyYXkpIGJsaXQgLT5cbiAgICAgICAgbGVuZ3RoOidzcmMgbGVuZ3RoIC0+XG4gICAgICAgID9vZmY6aW50IC0+XG4gICAgICAgID9sZW46aW50IC0+XG4gICAgICAgICdzcmMgLT5cbiAgICAgICAgKCgnYSwgJ2IpIGJpZ2FycmF5IGxpc3QgKiAoJ2EsICdiKSB0KSBvcHRpb25cbiAgICAgICgqKiBTYW1lIGFzIHshcHVzaF9leG59IGJ1dCBpdCByZXR1cm5zIFtOb25lXSBpZiBpdCBmYWlscy4gKilcblxuICAgICAgdmFsIGtlZXBfZXhuIDpcbiAgICAgICAgKCdhLCAnYikgdCAtPlxuICAgICAgICBibGl0OigoJ2EsICdiKSBiaWdhcnJheSwgJ2RzdCkgYmxpdCAtPlxuICAgICAgICBsZW5ndGg6J2RzdCBsZW5ndGggLT5cbiAgICAgICAgP29mZjppbnQgLT5cbiAgICAgICAgP2xlbjppbnQgLT5cbiAgICAgICAgJ2RzdCAtPlxuICAgICAgICB1bml0XG4gICAgICAoKiogW2tlZXBfZXhuIHEgfmJsaXQgfmxlbmd0aCA/b2ZmID9sZW4gZHN0XSB7aSBibGl0c30gZWxlbWVudHMgb2YgdGhlXG4gICAgICAgICBnaXZlbiBxdWV1ZSBbcV0gaW4gW2RzdF0gZnJvbSB0aGUgZnJvbnQgdG8gdGhlIGVuZCBvZiBbZHN0XSAobGlrZSBhXG4gICAgICAgICBmYXN0IGl0ZXJhdGl2ZSB7IVIucG9wX2V4bn0pLiBEZWZhdWx0IHZhbHVlIG9mIFtvZmZdIGlzIFswXS4gRGVmYXVsdFxuICAgICAgICAgdmFsdWUgb2YgW2xlbl0gaXMgW2xlbmd0aCBkc3QgLSBvZmZdLiBJZiB0aGUgZ2l2ZW4gW3FdIGRvZXMgbm90IGhhdmVcbiAgICAgICAgIGVub3VnaCBlbGVtZW50cyB0byB3cml0ZSBvbiBbZHN0XSwgaXQgcmFpc2VzIHshRW1wdHl9LiBJbiBhbnkgY2FzZSwgdGhlXG4gICAgICAgICBnaXZlbiBxdWV1ZSBpcyB1bmNoYW5nZWQuICopXG5cbiAgICAgIHZhbCBrZWVwIDpcbiAgICAgICAgKCdhLCAnYikgdCAtPlxuICAgICAgICBibGl0OigoJ2EsICdiKSBiaWdhcnJheSwgJ2RzdCkgYmxpdCAtPlxuICAgICAgICBsZW5ndGg6J2RzdCBsZW5ndGggLT5cbiAgICAgICAgP29mZjppbnQgLT5cbiAgICAgICAgP2xlbjppbnQgLT5cbiAgICAgICAgJ2RzdCAtPlxuICAgICAgICB1bml0IG9wdGlvblxuICAgICAgKCoqIFNhbWUgYXMgeyFrZWVwX2V4bn0gYnV0IGlmIGl0IGZhaWxzLCBpdCByZXR1cm5zIFtOb25lXS4gKilcblxuICAgICAgdmFsIHVuc2FmZV9zaGlmdCA6ICgnYSwgJ2IpIHQgLT4gaW50IC0+ICgnYSwgJ2IpIHRcbiAgICAgICgqKiBbdW5zYWZlX3NoaWZ0IHEgbF0gZGlzY2FyZHMgW2xdIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBxdWV1ZSBbcV1cbiAgICAgICAgIHdpdGhvdXQgYW55IHZlcmlmaWNhdGlvbi4gTW9zdGx5IHVzZWQgYWZ0ZXIgeyFrZWVwX2V4bn0sIGlmIHRoZSBsYXN0XG4gICAgICAgICBvbmUgZG9lcyBub3QgcmFpc2UgeyFFbXB0eX0sIGl0J3Mgc2FmZSB0byB1c2UgaXQuICopXG5cbiAgICAgIHZhbCBzaGlmdF9leG4gOiAoJ2EsICdiKSB0IC0+IGludCAtPiAoJ2EsICdiKSB0XG4gICAgICAoKiogW3NoaWZ0X2V4biBxIGxdIGRpc2NhcmRzIFtsXSBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gcXVldWUgW3FdLiBJZiBbcV1cbiAgICAgICAgIGRvZXMgbm90IGhhdmUgZW5vdWdoIGVsZW1lbnRzLCBpdCByYWlzZXMgeyFFbXB0eX0gYW5kIHRoZSBnaXZlbiBxdWV1ZVxuICAgICAgICAgaXMgdW5jaGFuZ2VkLiAqKVxuXG4gICAgICB2YWwgc2hpZnQgOiAoJ2EsICdiKSB0IC0+IGludCAtPiAoJ2EsICdiKSB0IG9wdGlvblxuICAgICAgKCoqIFNhbWUgYXMgeyFzaGlmdF9leG59IGJ1dCBpZiBpdCBmYWlscywgaXQgcmV0dXJucyBbTm9uZV0uICopXG4gICAgZW5kXG5cbiAgICB2YWwgaXRlciA6ICgnYSAtPiB1bml0KSAtPiAoJ2EsICdiKSB0IC0+IHVuaXRcbiAgICAoKiogW2l0ZXIgZiBxXSBhcHBsaWVzIFtmXSBpbiB0dXJuIHRvIGFsbCBlbGVtZW50cyBvZiBbcV0sIGZyb20gdGhlIGxlYXN0XG4gICAgICAgcmVjZW50bHkgZW50ZXJlZCB0byB0aGUgbW9zdCByZWNlbnRseSBlbnRlcmVkLiBUaGUgcXVldWUgaXRzZWxmIGlzXG4gICAgICAgdW5jaGFuZ2VkLiAqKVxuXG4gICAgdmFsIHJldl9pdGVyIDogKCdhIC0+IHVuaXQpIC0+ICgnYSwgJ2IpIHQgLT4gdW5pdFxuICAgICgqKiBbaXRlciBmIHFdIGFwcGxpZXMgW2ZdIGluIHR1cm4gdG8gYWxsIGVsZW1lbnRzIG9mIFtxXSwgZnJvbSB0aGUgbW9zdFxuICAgICAgIHJlY2VudGx5IGVudGVyZWQgdG8gdGhlIGxlYXN0IHJlY2VudGx5IGVudGVyZWQuIFRoZSBxdWV1ZSBpdHNlbGYgaXNcbiAgICAgICB1bmNoYW5nZWQuICopXG5cbiAgICB2YWwgZm9sZCA6ICgnYWNjIC0+ICd4IC0+ICdhY2MpIC0+ICdhY2MgLT4gKCd4LCAnYikgdCAtPiAnYWNjXG4gICAgKCoqIFtmb2xkIGYgYSBxXSBpcyBlcXVpdmFsZW50IHRvIFtMaXN0LmZvbGRfbGVmdCBmIGEgbF0sIHdoZXJlIFtsXSBpcyB0aGVcbiAgICAgICBsaXN0IG9mIFtxXSdzIGVsZW1lbnRzLiBUaGUgcXVldWUgcmVtYWlucyB1bmNoYW5nZWQuICopXG5cbiAgICB2YWwgcHAgOiA/c2VwOnVuaXQgRm10LnQgLT4gJ2EgRm10LnQgLT4gKCdhLCAnYikgdCBGbXQudFxuICAgICgqKiBQcmV0dHktcHJpbnRlciBvZiB7IXR9LiAqKVxuXG4gICAgdmFsIGR1bXAgOiAnYSBGbXQudCAtPiAoJ2EsICdiKSB0IEZtdC50XG4gICAgKCoqIEh1bWFuLXJlYWRhYmxlIHByZXR0eS1wcmludGVyIG9mIHshdH0uICopXG5cbiAgICAoKiogLyAqKilcblxuICAgIHZhbCB1bnNhZmVfYmlnYXJyYXkgOlxuICAgICAgKCdhLCAnYikgdCAtPiAoJ2EsICdiLCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuQXJyYXkxLnRcblxuICAgIHZhbCBmcm9tIDogKCdhLCAnYiwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkFycmF5MS50IC0+ICgnYSwgJ2IpIHRcbiAgZW5kXG5lbmRcbiIsInR5cGUgKCdhLCAnYikgdCA9IHtcbiAgbXV0YWJsZSByIDogaW50O1xuICBtdXRhYmxlIHcgOiBpbnQ7XG4gIG11dGFibGUgYyA6IGludDtcbiAgayA6ICgnYSwgJ2IpIEJpZ2FycmF5LmtpbmQ7XG4gIG11dGFibGUgdiA6ICgnYSwgJ2IsIEJpZ2FycmF5LmNfbGF5b3V0KSBCaWdhcnJheS5BcnJheTEudDtcbn1cblxuZXhjZXB0aW9uIEVtcHR5XG5cbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxubGV0ICggPSApIChhIDogaW50KSBiID0gYSA9IGJcbmxldFtAaW5saW5lIGFsd2F5c10gbWFzayB0IHYgPSB2IGxhbmQgKHQuYyAtIDEpXG5sZXRbQGlubGluZSBhbHdheXNdIGVtcHR5IHQgPSB0LnIgPSB0LndcbmxldFtAaW5saW5lIGFsd2F5c10gc2l6ZSB0ID0gdC53IC0gdC5yXG5sZXRbQGlubGluZSBhbHdheXNdIGF2YWlsYWJsZSB0ID0gdC5jIC0gKHQudyAtIHQucilcbmxldFtAaW5saW5lIGFsd2F5c10gZnVsbCB0ID0gc2l6ZSB0ID0gdC5jXG5sZXQgbGVuZ3RoIHEgPSBzaXplIHFcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB0b19wb3dlcl9vZl90d28gdiA9XG4gIGxldCByZXMgPSByZWYgKHByZWQgdikgaW5cbiAgcmVzIDo9ICFyZXMgbG9yICghcmVzIGxzciAxKTtcbiAgcmVzIDo9ICFyZXMgbG9yICghcmVzIGxzciAyKTtcbiAgcmVzIDo9ICFyZXMgbG9yICghcmVzIGxzciA0KTtcbiAgcmVzIDo9ICFyZXMgbG9yICghcmVzIGxzciA4KTtcbiAgcmVzIDo9ICFyZXMgbG9yICghcmVzIGxzciAxNik7XG4gIHN1Y2MgIXJlc1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGlzX3Bvd2VyX29mX3R3byB2ID0gdiA8PiAwICYmIHYgbGFuZCAobG5vdCB2ICsgMSkgPSB2XG5sZXQgaXNfZW1wdHkgdCA9IChlbXB0eSBbQGlubGluZWRdKSB0XG5cbmxldCBjcmVhdGUgP2NhcGFjaXR5IGtpbmQgPVxuICBsZXQgY2FwYWNpdHkgPVxuICAgIG1hdGNoIGNhcGFjaXR5IHdpdGhcbiAgICB8IE5vbmUgfCBTb21lIDAgLT4gMVxuICAgIHwgU29tZSBuIC0+XG4gICAgICAgIGlmIG4gPCAwIHRoZW4gRm10LmludmFsaWRfYXJnIFwiUmtlLmNyZWF0ZVwiIGVsc2UgdG9fcG93ZXJfb2ZfdHdvIG5cbiAgaW5cbiAge1xuICAgIHIgPSAwO1xuICAgIHcgPSAwO1xuICAgIGMgPSBjYXBhY2l0eTtcbiAgICBrID0ga2luZDtcbiAgICB2ID0gQmlnYXJyYXkuQXJyYXkxLmNyZWF0ZSBraW5kIEJpZ2FycmF5LmNfbGF5b3V0IGNhcGFjaXR5O1xuICB9XG5cbmxldCBjYXBhY2l0eSB7IGM7IF8gfSA9IGNcblxubGV0IGNvcHkgdCA9XG4gIGxldCB2ID0gQmlnYXJyYXkuQXJyYXkxLmNyZWF0ZSB0LmsgQmlnYXJyYXkuY19sYXlvdXQgdC5jIGluXG4gIEJpZ2FycmF5LkFycmF5MS5ibGl0IHQudiB2O1xuICB7IHIgPSB0LnI7IHcgPSB0Lnc7IGMgPSB0LmM7IHY7IGsgPSB0LmsgfVxuXG5sZXQgZ3JvdyB0IHdhbnQgPVxuICBsZXQgbWF4IDogaW50IC0+IGludCAtPiBpbnQgPSBtYXggaW5cbiAgbGV0IGMgPSB0b19wb3dlcl9vZl90d28gKG1heCAxIChtYXggd2FudCAoc2l6ZSB0KSkpIGluXG4gIGlmIGMgPD4gQmlnYXJyYXkuQXJyYXkxLmRpbSB0LnYgdGhlbiAoXG4gICAgbGV0IGRzdCA9IEJpZ2FycmF5LkFycmF5MS5jcmVhdGUgdC5rIEJpZ2FycmF5LmNfbGF5b3V0IGMgaW5cbiAgICBsZXQgc3plID0gKHNpemUgW0BpbmxpbmVkXSkgdCBpblxuICAgIGxldCBtc2sgPSAobWFzayBbQGlubGluZWRdKSB0IHQuciBpblxuICAgIGxldCBwcmUgPSB0LmMgLSBtc2sgaW5cbiAgICBsZXQgcnN0ID0gc3plIC0gcHJlIGluXG4gICAgKGlmIHJzdCA+IDAgdGhlbiAoXG4gICAgIEJpZ2FycmF5LkFycmF5MS4oYmxpdCAoc3ViIHQudiBtc2sgcHJlKSAoc3ViIGRzdCAwIHByZSkpO1xuICAgICBCaWdhcnJheS5BcnJheTEuKGJsaXQgKHN1YiB0LnYgMCByc3QpIChzdWIgZHN0IHByZSByc3QpKSlcbiAgICBlbHNlIEJpZ2FycmF5LkFycmF5MS4oYmxpdCAoc3ViIHQudiBtc2sgc3plKSAoc3ViIGRzdCAwIHN6ZSkpKTtcbiAgICB0LnYgPC0gZHN0O1xuICAgIHQudyA8LSBzemU7XG4gICAgdC5jIDwtIGM7XG4gICAgdC5yIDwtIDApXG5cbmxldCBwdXNoIHQgdiA9XG4gIGlmIChmdWxsIFtAaW5saW5lZF0pIHQgdGhlbiBncm93IHQgKDIgKiAoc2l6ZSBbQGlubGluZWRdKSB0KTtcbiAgQmlnYXJyYXkuQXJyYXkxLnVuc2FmZV9zZXQgdC52ICgobWFzayBbQGlubGluZWRdKSB0IHQudykgdjtcbiAgdC53IDwtIHQudyArIDFcblxubGV0IGNvbnMgdCB2ID1cbiAgaWYgKGZ1bGwgW0BpbmxpbmVkXSkgdCB0aGVuIGdyb3cgdCAoMiAqIChzaXplIFtAaW5saW5lZF0pIHQpO1xuICBsZXQgaSA9IHQuciAtIDEgaW5cbiAgQmlnYXJyYXkuQXJyYXkxLnVuc2FmZV9zZXQgdC52ICgobWFzayBbQGlubGluZWRdKSB0IGkpIHY7XG4gIHQuciA8LSBpXG5cbmxldCBwb3BfZXhuIHQgPVxuICBpZiAoZW1wdHkgW0BpbmxpbmVkXSkgdCB0aGVuIHJhaXNlIEVtcHR5O1xuICBsZXQgciA9IEJpZ2FycmF5LkFycmF5MS51bnNhZmVfZ2V0IHQudiAoKG1hc2sgW0BpbmxpbmVkXSkgdCB0LnIpIGluXG4gIHQuciA8LSB0LnIgKyAxO1xuICByXG5cbmxldCBwb3AgdCA9IHRyeSBTb21lIChwb3BfZXhuIHQpIHdpdGggRW1wdHkgLT4gTm9uZVxuXG5sZXQgcGVla19leG4gdCA9XG4gIGlmIChlbXB0eSBbQGlubGluZWRdKSB0IHRoZW4gcmFpc2UgRW1wdHk7XG4gIEJpZ2FycmF5LkFycmF5MS51bnNhZmVfZ2V0IHQudiAoKG1hc2sgW0BpbmxpbmVkXSkgdCB0LnIpXG5cbmxldCBwZWVrIHQgPSB0cnkgU29tZSAocGVla19leG4gdCkgd2l0aCBFbXB0eSAtPiBOb25lXG5cbmxldCBibGl0IHNyYyBzcmNfb2ZmIGRzdCBkc3Rfb2ZmIGxlbiA9XG4gIGxldCBhID0gQmlnYXJyYXkuQXJyYXkxLnN1YiBzcmMgc3JjX29mZiBsZW4gaW5cbiAgbGV0IGIgPSBCaWdhcnJheS5BcnJheTEuc3ViIGRzdCBkc3Rfb2ZmIGxlbiBpblxuICBCaWdhcnJheS5BcnJheTEuYmxpdCBhIGJcblxubGV0IGNvbXByZXNzIHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IG1zayA9IChtYXNrIFtAaW5saW5lZF0pIHQgdC5yIGluXG4gIGxldCBwcmUgPSB0LmMgLSBtc2sgaW5cbiAgbGV0IHJzdCA9IGxlbiAtIHByZSBpblxuICBpZiByc3QgPiAwIHRoZW4gKFxuICAgIGlmIChhdmFpbGFibGUgW0BpbmxpbmVkXSkgdCA+PSBwcmUgdGhlbiAoXG4gICAgICAoKiBYWFgoZGlub3NhdXJlKTogaW4gdGhpcyBjYXNlLCBbcHJlICsgcnN0IDw9IG1za10sIHNvIFtibGl0XSB3aWxsIG5vdFxuICAgICAgICAgb3ZlcmxhcCBieXRlcyBhdCB0aGUgZW5kIG9mIFt0LnZdIChhdCBvZmZzZXQgW21za10pLiAqKVxuICAgICAgYmxpdCB0LnYgMCB0LnYgcHJlIHJzdDtcbiAgICAgIGJsaXQgdC52IG1zayB0LnYgMCBwcmUpXG4gICAgZWxzZVxuICAgICAgbGV0IHRtcCA9IEJpZ2FycmF5LkFycmF5MS5jcmVhdGUgdC5rIEJpZ2FycmF5LmNfbGF5b3V0IHByZSBpblxuICAgICAgYmxpdCB0LnYgbXNrIHRtcCAwIHByZTtcbiAgICAgIGJsaXQgdC52IDAgdC52IHByZSByc3Q7XG4gICAgICBibGl0IHRtcCAwIHQudiAwIHByZSlcbiAgZWxzZSBibGl0IHQudiBtc2sgdC52IDAgbGVuO1xuICB0LnIgPC0gMDtcbiAgdC53IDwtIGxlblxuXG5tb2R1bGUgTiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIGJpZ2FycmF5ID0gKCdhLCAnYiwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkFycmF5MS50XG4gIHR5cGUgKCdhLCAnYikgYmxpdCA9ICdhIC0+IGludCAtPiAnYiAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdHlwZSAnYSBsZW5ndGggPSAnYSAtPiBpbnRcblxuICBsZXQgcHVzaCB0IH5ibGl0IH5sZW5ndGggPyhvZmYgPSAwKSA/bGVuIHYgPVxuICAgIGxldCBsZW4gPSBtYXRjaCBsZW4gd2l0aCBOb25lIC0+IGxlbmd0aCB2IC0gb2ZmIHwgU29tZSBsZW4gLT4gbGVuIGluXG4gICAgaWYgKGF2YWlsYWJsZSBbQGlubGluZWRdKSB0IDwgbGVuIHRoZW4gZ3JvdyB0IChsZW4gKyAoc2l6ZSBbQGlubGluZWRdKSB0KTtcbiAgICBsZXQgbXNrID0gKG1hc2sgW0BpbmxpbmVkXSkgdCB0LncgaW5cbiAgICBsZXQgcHJlID0gdC5jIC0gbXNrIGluXG4gICAgbGV0IHJzdCA9IGxlbiAtIHByZSBpblxuICAgIGlmIHJzdCA+IDAgdGhlbiAoXG4gICAgICBibGl0IHYgb2ZmIHQudiBtc2sgcHJlO1xuICAgICAgYmxpdCB2IChvZmYgKyBwcmUpIHQudiAwIHJzdClcbiAgICBlbHNlIGJsaXQgdiBvZmYgdC52IG1zayBsZW47XG4gICAgdC53IDwtIHQudyArIGxlblxuXG4gIGxldCBrZWVwX2V4biB0IH5ibGl0IH5sZW5ndGggPyhvZmYgPSAwKSA/bGVuIHYgPVxuICAgIGxldCBsZW4gPSBtYXRjaCBsZW4gd2l0aCBOb25lIC0+IGxlbmd0aCB2IC0gb2ZmIHwgU29tZSBsZW4gLT4gbGVuIGluXG4gICAgaWYgKHNpemUgW0BpbmxpbmVkXSkgdCA8IGxlbiB0aGVuIHJhaXNlIEVtcHR5O1xuICAgIGxldCBtc2sgPSAobWFzayBbQGlubGluZWRdKSB0IHQuciBpblxuICAgIGxldCBwcmUgPSB0LmMgLSBtc2sgaW5cbiAgICBsZXQgcnN0ID0gbGVuIC0gcHJlIGluXG4gICAgaWYgcnN0ID4gMCB0aGVuIChcbiAgICAgIGJsaXQgdC52IG1zayB2IG9mZiBwcmU7XG4gICAgICBibGl0IHQudiAwIHYgKG9mZiArIHByZSkgcnN0KVxuICAgIGVsc2UgYmxpdCB0LnYgbXNrIHYgb2ZmIGxlblxuXG4gIGxldCBrZWVwIHQgfmJsaXQgfmxlbmd0aCA/b2ZmID9sZW4gdiA9XG4gICAgdHJ5IFNvbWUgKGtlZXBfZXhuIHQgfmJsaXQgfmxlbmd0aCA/b2ZmID9sZW4gdikgd2l0aCBFbXB0eSAtPiBOb25lXG5cbiAgbGV0IHBlZWsgdCA9XG4gICAgbGV0IGxlbiA9IChzaXplIFtAaW5saW5lZF0pIHQgaW5cbiAgICBpZiBsZW4gPT0gMCB0aGVuIFtdXG4gICAgZWxzZVxuICAgICAgbGV0IG1zayA9IChtYXNrIFtAaW5saW5lZF0pIHQgdC5yIGluXG4gICAgICBsZXQgcHJlID0gdC5jIC0gbXNrIGluXG4gICAgICBsZXQgcnN0ID0gbGVuIC0gcHJlIGluXG4gICAgICBpZiByc3QgPiAwIHRoZW5cbiAgICAgICAgWyBCaWdhcnJheS5BcnJheTEuc3ViIHQudiBtc2sgcHJlOyBCaWdhcnJheS5BcnJheTEuc3ViIHQudiAwIHJzdCBdXG4gICAgICBlbHNlIFsgQmlnYXJyYXkuQXJyYXkxLnN1YiB0LnYgbXNrIGxlbiBdXG5cbiAgbGV0IHVuc2FmZV9zaGlmdCB0IGxlbiA9IHQuciA8LSB0LnIgKyBsZW5cblxuICBsZXQgc2hpZnRfZXhuIHQgbGVuID1cbiAgICBpZiAoc2l6ZSBbQGlubGluZWRdKSB0IDwgbGVuIHRoZW4gcmFpc2UgRW1wdHk7XG4gICAgdW5zYWZlX3NoaWZ0IHQgbGVuXG5cbiAgbGV0IHNoaWZ0IHQgbGVuID0gdHJ5IFNvbWUgKHNoaWZ0X2V4biB0IGxlbikgd2l0aCBFbXB0eSAtPiBOb25lXG5lbmRcblxubGV0IGl0ZXIgZiB0ID1cbiAgbGV0IGlkeCA9IHJlZiB0LnIgaW5cbiAgbGV0IG1heCA9IHQudyBpblxuICB3aGlsZSAhaWR4IDw+IG1heCBkb1xuICAgIGYgKEJpZ2FycmF5LkFycmF5MS51bnNhZmVfZ2V0IHQudiAoKG1hc2sgW0BpbmxpbmVkXSkgdCAhaWR4KSk7XG4gICAgaW5jciBpZHhcbiAgZG9uZVxuXG5sZXQgcmV2X2l0ZXIgZiB0ID1cbiAgaWYgdC5yID09IHQudyB0aGVuICgpXG4gIGVsc2VcbiAgICBsZXQgaWR4ID0gcmVmIChwcmVkIHQudykgaW5cbiAgICBsZXQgbWluID0gdC5yIGluXG4gICAgd2hpbGVcbiAgICAgIGYgKEJpZ2FycmF5LkFycmF5MS51bnNhZmVfZ2V0IHQudiAoKG1hc2sgW0BpbmxpbmVkXSkgdCAhaWR4KSk7XG4gICAgICAhaWR4IDw+IG1pblxuICAgIGRvXG4gICAgICBkZWNyIGlkeFxuICAgIGRvbmVcblxubGV0IGZvbGQgZiBhIHQgPVxuICBsZXQgYSA9IHJlZiBhIGluXG4gIGl0ZXIgKGZ1biB4IC0+IGEgOj0gZiAhYSB4KSB0O1xuICAhYVxuXG5sZXQgcHAgP3NlcCBwcF9lbHQgPSBGbXQuaXRlciA/c2VwIGl0ZXIgcHBfZWx0XG5sZXQgZHVtcCBwcF9lbHQgPSBGbXQuRHVtcC5pdGVyIGl0ZXIgKEZtdC5hbnkgXCJya2VcIikgcHBfZWx0XG5cbmxldCBjbGVhciBxID1cbiAgcS5yIDwtIDA7XG4gIHEudyA8LSAwXG5cbm1vZHVsZSBXZWlnaHRlZCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPSB7XG4gICAgbXV0YWJsZSByIDogaW50O1xuICAgIG11dGFibGUgdyA6IGludDtcbiAgICBjIDogaW50O1xuICAgIGsgOiAoJ2EsICdiKSBCaWdhcnJheS5raW5kO1xuICAgIHYgOiAoJ2EsICdiLCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuQXJyYXkxLnQ7XG4gIH1cblxuICBleGNlcHRpb24gRW1wdHlcbiAgZXhjZXB0aW9uIEZ1bGxcblxuICBsZXRbQGlubGluZSBhbHdheXNdIG1hc2sgdCB2ID0gdiBsYW5kICh0LmMgLSAxKVxuICBsZXRbQGlubGluZSBhbHdheXNdIGVtcHR5IHQgPSB0LnIgPSB0LndcbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBzaXplIHQgPSB0LncgLSB0LnJcbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBmdWxsIHQgPSBzaXplIHQgPSB0LmNcbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBhdmFpbGFibGUgdCA9IHQuYyAtICh0LncgLSB0LnIpXG4gIGxldCBpc19lbXB0eSB0ID0gKGVtcHR5IFtAaW5saW5lZF0pIHRcbiAgbGV0IGxlbmd0aCBxID0gc2l6ZSBxXG5cbiAgbGV0IGNyZWF0ZSA/Y2FwYWNpdHkga2luZCA9XG4gICAgbGV0IGNhcGFjaXR5ID1cbiAgICAgIG1hdGNoIGNhcGFjaXR5IHdpdGhcbiAgICAgIHwgTm9uZSB8IFNvbWUgMCAtPiAxXG4gICAgICB8IFNvbWUgbiAtPlxuICAgICAgICAgIGlmIG4gPCAwIHRoZW4gRm10LmludmFsaWRfYXJnIFwiUmtlLldlaWdodGVkLmNyZWF0ZVwiXG4gICAgICAgICAgZWxzZSB0b19wb3dlcl9vZl90d28gblxuICAgIGluXG4gICAgKCB7XG4gICAgICAgIHIgPSAwO1xuICAgICAgICB3ID0gMDtcbiAgICAgICAgYyA9IGNhcGFjaXR5O1xuICAgICAgICBrID0ga2luZDtcbiAgICAgICAgdiA9IEJpZ2FycmF5LkFycmF5MS5jcmVhdGUga2luZCBCaWdhcnJheS5jX2xheW91dCBjYXBhY2l0eTtcbiAgICAgIH0sXG4gICAgICBjYXBhY2l0eSApXG5cbiAgbGV0IGNvcHkgdCA9XG4gICAgbGV0IHYgPSBCaWdhcnJheS5BcnJheTEuY3JlYXRlIHQuayBCaWdhcnJheS5jX2xheW91dCB0LmMgaW5cbiAgICBCaWdhcnJheS5BcnJheTEuYmxpdCB0LnYgdjtcbiAgICB7IHIgPSB0LnI7IHcgPSB0Lnc7IGMgPSB0LmM7IHY7IGsgPSB0LmsgfVxuXG4gIGxldCBmcm9tIHYgPVxuICAgIGlmIG5vdCAoaXNfcG93ZXJfb2ZfdHdvIChCaWdhcnJheS5BcnJheTEuZGltIHYpKSB0aGVuXG4gICAgICBGbXQuaW52YWxpZF9hcmcgXCJSQkEuZnJvbVwiO1xuICAgIGxldCBjID0gQmlnYXJyYXkuQXJyYXkxLmRpbSB2IGluXG4gICAgbGV0IGsgPSBCaWdhcnJheS5BcnJheTEua2luZCB2IGluXG4gICAgeyByID0gMDsgdyA9IDA7IGM7IGs7IHYgfVxuXG4gIGxldCBwdXNoX2V4biB0IHYgPVxuICAgIGlmIChmdWxsIFtAaW5saW5lZF0pIHQgdGhlbiByYWlzZSBGdWxsO1xuICAgIEJpZ2FycmF5LkFycmF5MS51bnNhZmVfc2V0IHQudiAoKG1hc2sgW0BpbmxpbmVkXSkgdCB0LncpIHY7XG4gICAgdC53IDwtIHQudyArIDFcblxuICBsZXQgcHVzaCB0IHYgPSB0cnkgU29tZSAocHVzaF9leG4gdCB2KSB3aXRoIEZ1bGwgLT4gTm9uZVxuXG4gIGxldCBjb25zX2V4biB0IHYgPVxuICAgIGlmIChmdWxsIFtAaW5saW5lZF0pIHQgdGhlbiByYWlzZSBGdWxsO1xuICAgIGxldCBpID0gdC5yIC0gMSBpblxuICAgIEJpZ2FycmF5LkFycmF5MS51bnNhZmVfc2V0IHQudiAoKG1hc2sgW0BpbmxpbmVkXSkgdCBpKSB2O1xuICAgIHQuciA8LSBpXG5cbiAgbGV0IGNvbnMgdCB2ID0gdHJ5IFNvbWUgKGNvbnNfZXhuIHQgdikgd2l0aCBGdWxsIC0+IE5vbmVcblxuICBsZXQgcG9wX2V4biB0ID1cbiAgICBpZiAoZW1wdHkgW0BpbmxpbmVkXSkgdCB0aGVuIHJhaXNlIEVtcHR5O1xuICAgIGxldCByID0gQmlnYXJyYXkuQXJyYXkxLnVuc2FmZV9nZXQgdC52ICgobWFzayBbQGlubGluZWRdKSB0IHQucikgaW5cbiAgICB0LnIgPC0gdC5yICsgMTtcbiAgICByXG5cbiAgbGV0IHBvcCB0ID0gdHJ5IFNvbWUgKHBvcF9leG4gdCkgd2l0aCBFbXB0eSAtPiBOb25lXG5cbiAgbGV0IHBlZWtfZXhuIHQgPVxuICAgIGlmIChlbXB0eSBbQGlubGluZWRdKSB0IHRoZW4gcmFpc2UgRW1wdHk7XG4gICAgQmlnYXJyYXkuQXJyYXkxLnVuc2FmZV9nZXQgdC52ICgobWFzayBbQGlubGluZWRdKSB0IHQucilcblxuICBsZXQgcGVlayB0ID0gdHJ5IFNvbWUgKHBlZWtfZXhuIHQpIHdpdGggRW1wdHkgLT4gTm9uZVxuXG4gIGxldCBjb21wcmVzcyB0ID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICBsZXQgbXNrID0gKG1hc2sgW0BpbmxpbmVkXSkgdCB0LnIgaW5cbiAgICBsZXQgcHJlID0gdC5jIC0gbXNrIGluXG4gICAgbGV0IHJzdCA9IGxlbiAtIHByZSBpblxuICAgIGlmIHJzdCA+IDAgdGhlbiAoXG4gICAgICBpZiAoYXZhaWxhYmxlIFtAaW5saW5lZF0pIHQgPj0gcHJlIHRoZW4gKFxuICAgICAgICAoKiBYWFgoZGlub3NhdXJlKTogaW4gdGhpcyBjYXNlLCBbcHJlICsgcnN0IDw9IG1za10sIHNvIFtibGl0XSB3aWxsIG5vdFxuICAgICAgICAgICBvdmVybGFwIGJ5dGVzIGF0IHRoZSBlbmQgb2YgW3Qudl0gKGF0IG9mZnNldCBbbXNrXSkuICopXG4gICAgICAgIGJsaXQgdC52IDAgdC52IHByZSByc3Q7XG4gICAgICAgIGJsaXQgdC52IG1zayB0LnYgMCBwcmUpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCB0bXAgPSBCaWdhcnJheS5BcnJheTEuY3JlYXRlIHQuayBCaWdhcnJheS5jX2xheW91dCBwcmUgaW5cbiAgICAgICAgYmxpdCB0LnYgbXNrIHRtcCAwIHByZTtcbiAgICAgICAgYmxpdCB0LnYgMCB0LnYgcHJlIHJzdDtcbiAgICAgICAgYmxpdCB0bXAgMCB0LnYgMCBwcmUpXG4gICAgZWxzZSBibGl0IHQudiBtc2sgdC52IDAgbGVuO1xuICAgIHQuciA8LSAwO1xuICAgIHQudyA8LSBsZW5cblxuICBtb2R1bGUgTiA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYikgYmlnYXJyYXkgPSAoJ2EsICdiLCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuQXJyYXkxLnRcbiAgICB0eXBlICgnYSwgJ2IpIGJsaXQgPSAnYSAtPiBpbnQgLT4gJ2IgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgdHlwZSAnYSBsZW5ndGggPSAnYSAtPiBpbnRcblxuICAgIGxldCBwdXNoX2V4biB0IH5ibGl0IH5sZW5ndGggPyhvZmYgPSAwKSA/bGVuIHYgPVxuICAgICAgbGV0IGxlbiA9IG1hdGNoIGxlbiB3aXRoIE5vbmUgLT4gbGVuZ3RoIHYgLSBvZmYgfCBTb21lIGxlbiAtPiBsZW4gaW5cbiAgICAgIGlmIChhdmFpbGFibGUgW0BpbmxpbmVkXSkgdCA8IGxlbiB0aGVuIHJhaXNlIEZ1bGw7XG4gICAgICBsZXQgbXNrID0gKG1hc2sgW0BpbmxpbmVkXSkgdCB0LncgaW5cbiAgICAgIGxldCBwcmUgPSB0LmMgLSBtc2sgaW5cbiAgICAgIGxldCByc3QgPSBsZW4gLSBwcmUgaW5cbiAgICAgIGxldCByZXQgPVxuICAgICAgICBpZiByc3QgPiAwIHRoZW4gKFxuICAgICAgICAgIGJsaXQgdiBvZmYgdC52IG1zayBwcmU7XG4gICAgICAgICAgYmxpdCB2IChvZmYgKyBwcmUpIHQudiAwIHJzdDtcbiAgICAgICAgICBbXG4gICAgICAgICAgICBCaWdhcnJheS5BcnJheTEuc3ViIHQudiAoKG1hc2sgW0BpbmxpbmVkXSkgdCB0LncpIHByZTtcbiAgICAgICAgICAgIEJpZ2FycmF5LkFycmF5MS5zdWIgdC52IDAgcnN0O1xuICAgICAgICAgIF0pXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGJsaXQgdiBvZmYgdC52IG1zayBsZW47XG4gICAgICAgICAgWyBCaWdhcnJheS5BcnJheTEuc3ViIHQudiAoKG1hc2sgW0BpbmxpbmVkXSkgdCB0LncpIGxlbiBdKVxuICAgICAgaW5cbiAgICAgIHQudyA8LSB0LncgKyBsZW47XG4gICAgICByZXRcblxuICAgIGxldCBwdXNoIHQgfmJsaXQgfmxlbmd0aCA/b2ZmID9sZW4gdiA9XG4gICAgICB0cnkgU29tZSAocHVzaF9leG4gdCB+YmxpdCB+bGVuZ3RoID9vZmYgP2xlbiB2KSB3aXRoIEZ1bGwgLT4gTm9uZVxuXG4gICAgbGV0IGtlZXBfZXhuIHQgfmJsaXQgfmxlbmd0aCA/KG9mZiA9IDApID9sZW4gdiA9XG4gICAgICBsZXQgbGVuID0gbWF0Y2ggbGVuIHdpdGggTm9uZSAtPiBsZW5ndGggdiAtIG9mZiB8IFNvbWUgbGVuIC0+IGxlbiBpblxuICAgICAgaWYgKHNpemUgW0BpbmxpbmVkXSkgdCA8IGxlbiB0aGVuIHJhaXNlIEVtcHR5O1xuICAgICAgbGV0IG1zayA9IChtYXNrIFtAaW5saW5lZF0pIHQgdC5yIGluXG4gICAgICBsZXQgcHJlID0gdC5jIC0gbXNrIGluXG4gICAgICBsZXQgcnN0ID0gbGVuIC0gcHJlIGluXG4gICAgICBpZiByc3QgPiAwIHRoZW4gKFxuICAgICAgICBibGl0IHQudiBtc2sgdiBvZmYgcHJlO1xuICAgICAgICBibGl0IHQudiAwIHYgKG9mZiArIHByZSkgcnN0KVxuICAgICAgZWxzZSBibGl0IHQudiBtc2sgdiBvZmYgbGVuXG5cbiAgICBsZXQga2VlcCB0IH5ibGl0IH5sZW5ndGggP29mZiA/bGVuIHYgPVxuICAgICAgdHJ5IFNvbWUgKGtlZXBfZXhuIHQgfmJsaXQgfmxlbmd0aCA/b2ZmID9sZW4gdikgd2l0aCBFbXB0eSAtPiBOb25lXG5cbiAgICBsZXQgcGVlayB0ID1cbiAgICAgIGxldCBsZW4gPSAoc2l6ZSBbQGlubGluZWRdKSB0IGluXG4gICAgICBpZiBsZW4gPT0gMCB0aGVuIFtdXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBtc2sgPSAobWFzayBbQGlubGluZWRdKSB0IHQuciBpblxuICAgICAgICBsZXQgcHJlID0gdC5jIC0gbXNrIGluXG4gICAgICAgIGxldCByc3QgPSBsZW4gLSBwcmUgaW5cbiAgICAgICAgaWYgcnN0ID4gMCB0aGVuXG4gICAgICAgICAgWyBCaWdhcnJheS5BcnJheTEuc3ViIHQudiBtc2sgcHJlOyBCaWdhcnJheS5BcnJheTEuc3ViIHQudiAwIHJzdCBdXG4gICAgICAgIGVsc2UgWyBCaWdhcnJheS5BcnJheTEuc3ViIHQudiBtc2sgbGVuIF1cblxuICAgIGxldCB1bnNhZmVfc2hpZnQgdCBsZW4gPSB0LnIgPC0gdC5yICsgbGVuXG5cbiAgICBsZXQgc2hpZnRfZXhuIHQgbGVuID1cbiAgICAgIGlmIChzaXplIFtAaW5saW5lZF0pIHQgPCBsZW4gdGhlbiByYWlzZSBFbXB0eTtcbiAgICAgIHVuc2FmZV9zaGlmdCB0IGxlblxuXG4gICAgbGV0IHNoaWZ0IHQgbGVuID0gdHJ5IFNvbWUgKHNoaWZ0X2V4biB0IGxlbikgd2l0aCBFbXB0eSAtPiBOb25lXG4gIGVuZFxuXG4gIGxldCBpdGVyIGYgdCA9XG4gICAgbGV0IGlkeCA9IHJlZiB0LnIgaW5cbiAgICBsZXQgbWF4ID0gdC53IGluXG4gICAgd2hpbGUgIWlkeCA8PiBtYXggZG9cbiAgICAgIGYgKEJpZ2FycmF5LkFycmF5MS51bnNhZmVfZ2V0IHQudiAoKG1hc2sgW0BpbmxpbmVkXSkgdCAhaWR4KSk7XG4gICAgICBpbmNyIGlkeFxuICAgIGRvbmVcblxuICBsZXQgcmV2X2l0ZXIgZiB0ID1cbiAgICBpZiB0LnIgPT0gdC53IHRoZW4gKClcbiAgICBlbHNlXG4gICAgICBsZXQgaWR4ID0gcmVmIChwcmVkIHQudykgaW5cbiAgICAgIGxldCBtaW4gPSB0LnIgaW5cbiAgICAgIHdoaWxlXG4gICAgICAgIGYgKEJpZ2FycmF5LkFycmF5MS51bnNhZmVfZ2V0IHQudiAoKG1hc2sgW0BpbmxpbmVkXSkgdCAhaWR4KSk7XG4gICAgICAgICFpZHggPD4gbWluXG4gICAgICBkb1xuICAgICAgICBkZWNyIGlkeFxuICAgICAgZG9uZVxuXG4gIGxldCBmb2xkIGYgYSB0ID1cbiAgICBsZXQgYSA9IHJlZiBhIGluXG4gICAgaXRlciAoZnVuIHggLT4gYSA6PSBmICFhIHgpIHQ7XG4gICAgIWFcblxuICBsZXQgcHAgP3NlcCBwcF9lbHQgPSBGbXQuaXRlciA/c2VwIGl0ZXIgcHBfZWx0XG4gIGxldCBkdW1wIHBwX2VsdCA9IEZtdC5EdW1wLml0ZXIgaXRlciAoRm10LmFueSBcInJrZTp3ZWlnaHRlZFwiKSBwcF9lbHRcblxuICBsZXQgY2xlYXIgcSA9XG4gICAgcS5yIDwtIDA7XG4gICAgcS53IDwtIDBcblxuICBsZXQgdW5zYWZlX2JpZ2FycmF5IHsgdjsgXyB9ID0gdlxuZW5kXG4iLCJbQEBAd2FybmluZyBcIi0zN1wiXVxuXG5tb2R1bGUgUGVhbm8gPSBzdHJ1Y3RcbiAgdHlwZSB6ZXJvID0gWmVyb1xuICB0eXBlICdhIHN1Y2MgPSBTdWNjXG4gIHR5cGUgb25lID0gemVybyBzdWNjXG4gIHR5cGUgdHdvID0gemVybyBzdWNjIHN1Y2NcbiAgdHlwZSB0aHJlZSA9IHplcm8gc3VjYyBzdWNjXG5lbmRcblxudHlwZSAoJ2EsICdsKSBkaWdpdCA9XG4gIHwgWmVybyA6ICgnYSwgUGVhbm8uemVybykgZGlnaXRcbiAgfCBPbmUgOiAnYSAtPiAoJ2EsIFBlYW5vLm9uZSkgZGlnaXRcbiAgfCBUd28gOiAnYSAqICdhIC0+ICgnYSwgUGVhbm8udHdvKSBkaWdpdFxuICB8IFRocmVlIDogJ2EgKiAnYSAqICdhIC0+ICgnYSwgUGVhbm8udGhyZWUpIGRpZ2l0XG5cbnR5cGUgJ2EgdCA9XG4gIHwgU2hhbGxvdyA6ICgnYSwgJ2wpIGRpZ2l0IC0+ICdhIHRcbiAgfCBEZWVwIDoge1xuICAgICAgcyA6IGludDtcbiAgICAgIGYgOiAoJ2EsICdmIFBlYW5vLnN1Y2MpIGRpZ2l0O1xuICAgICAgbSA6ICgnYSAqICdhKSB0IExhenkudDtcbiAgICAgIHIgOiAoJ2EsICdyIFBlYW5vLnN1Y2MpIGRpZ2l0O1xuICAgIH1cbiAgICAgIC0+ICdhIHRcblxubGV0IGVtcHR5ID0gU2hhbGxvdyBaZXJvXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgX29uZSB4ID0gU2hhbGxvdyAoT25lIHgpXG5sZXQgX3R3byB4IHkgPSBTaGFsbG93IChUd28gKHgsIHkpKVxubGV0IF90aHJlZSB4IHkgeiA9IFNoYWxsb3cgKFRocmVlICh4LCB5LCB6KSlcbmxldCBfZGVlcCBzIGYgbSByID0gRGVlcCB7IHM7IGY7IG07IHIgfVxuXG5sZXQgaXNfZW1wdHkgOiB0eXBlIGEuIGEgdCAtPiBib29sID0gZnVuY3Rpb25cbiAgfCBTaGFsbG93IFplcm8gLT4gdHJ1ZVxuICB8IFNoYWxsb3cgXyB8IERlZXAgXyAtPiBmYWxzZVxuXG5sZXQgcmVjIHB1c2ggOiB0eXBlIGEuIGEgdCAtPiBhIC0+IGEgdCA9XG4gZnVuIHEgeCAtPlxuICBtYXRjaCBxIHdpdGhcbiAgfCBTaGFsbG93IFplcm8gLT4gX29uZSB4XG4gIHwgU2hhbGxvdyAoT25lIHkpIC0+IF90d28geSB4XG4gIHwgU2hhbGxvdyAoVHdvICh5LCB6KSkgLT4gX3RocmVlIHkgeiB4XG4gIHwgU2hhbGxvdyAoVGhyZWUgKGEsIGIsIGMpKSAtPlxuICAgICAgX2RlZXAgNCAoVHdvIChhLCBiKSkgKExhenkuZnJvbV92YWwgZW1wdHkpIChUd28gKGMsIHgpKVxuICB8IERlZXAgeyBzOyBmOyBtOyByID0gT25lIHkgfSAtPiBfZGVlcCAocyArIDEpIGYgbSAoVHdvICh5LCB4KSlcbiAgfCBEZWVwIHsgczsgZjsgbTsgciA9IFR3byAoeSwgeikgfSAtPiBfZGVlcCAocyArIDEpIGYgbSAoVGhyZWUgKHksIHosIHgpKVxuICB8IERlZXAgeyBzOyBmOyBtID0gKGxhenkgcScpOyByID0gVGhyZWUgKHksIHosIHonKSB9IC0+XG4gICAgICBfZGVlcCAocyArIDEpIGYgKGxhenkgKHB1c2ggcScgKHksIHopKSkgKFR3byAoeicsIHgpKVxuXG5sZXQgcmVjIHBvcF9leG4gOiB0eXBlIGEuIGEgdCAtPiBhICogYSB0ID1cbiBmdW4gcSAtPlxuICBtYXRjaCBxIHdpdGhcbiAgfCBTaGFsbG93IFplcm8gLT4gcmFpc2UgRW1wdHlcbiAgfCBTaGFsbG93IChPbmUgeCkgLT4gKHgsIGVtcHR5KVxuICB8IFNoYWxsb3cgKFR3byAoeCwgeSkpIC0+ICh4LCBfb25lIHkpXG4gIHwgU2hhbGxvdyAoVGhyZWUgKHgsIHksIHopKSAtPiAoeCwgX3R3byB5IHopXG4gIHwgRGVlcCB7IHM7IGYgPSBPbmUgeDsgbSA9IChsYXp5IHEnKTsgciB9IC0+XG4gICAgICBpZiBpc19lbXB0eSBxJyB0aGVuICh4LCBTaGFsbG93IHIpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCAoeSwgeiksIHEnID0gcG9wX2V4biBxJyBpblxuICAgICAgICAoeCwgX2RlZXAgKHMgLSAxKSAoVHdvICh5LCB6KSkgKExhenkuZnJvbV92YWwgcScpIHIpXG4gIHwgRGVlcCB7IHM7IGYgPSBUd28gKHgsIHkpOyBtOyByIH0gLT4gKHgsIF9kZWVwIChzIC0gMSkgKE9uZSB5KSBtIHIpXG4gIHwgRGVlcCB7IHM7IGYgPSBUaHJlZSAoeCwgeSwgeik7IG07IHIgfSAtPiAoeCwgX2RlZXAgKHMgLSAxKSAoVHdvICh5LCB6KSkgbSByKVxuXG5sZXQgcmVjIHRhaWxfZXhuIDogdHlwZSBhLiBhIHQgLT4gYSB0ICogYSA9XG4gZnVuIHEgLT5cbiAgbWF0Y2ggcSB3aXRoXG4gIHwgU2hhbGxvdyBaZXJvIC0+IHJhaXNlIEVtcHR5XG4gIHwgU2hhbGxvdyAoT25lIHgpIC0+IChlbXB0eSwgeClcbiAgfCBTaGFsbG93IChUd28gKHgsIHkpKSAtPiAoX29uZSB4LCB5KVxuICB8IFNoYWxsb3cgKFRocmVlICh4LCB5LCB6KSkgLT4gKF90d28geCB5LCB6KVxuICB8IERlZXAgeyBzOyBmOyBtID0gKGxhenkgcScpOyByID0gT25lIHggfSAtPlxuICAgICAgaWYgaXNfZW1wdHkgcScgdGhlbiAoU2hhbGxvdyBmLCB4KVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgcScnLCAoeSwgeikgPSB0YWlsX2V4biBxJyBpblxuICAgICAgICAoX2RlZXAgKHMgLSAxKSBmIChMYXp5LmZyb21fdmFsIHEnJykgKFR3byAoeSwgeikpLCB4KVxuICB8IERlZXAgeyBzOyBmOyBtOyByID0gVHdvICh4LCB5KSB9IC0+IChfZGVlcCAocyAtIDEpIGYgbSAoT25lIHgpLCB5KVxuICB8IERlZXAgeyBzOyBmOyBtOyByID0gVGhyZWUgKHgsIHksIHopIH0gLT4gKF9kZWVwIChzIC0gMSkgZiBtIChUd28gKHgsIHkpKSwgeilcblxubGV0IHBlZWtfZXhuIDogdHlwZSBhLiBhIHQgLT4gYSA9XG4gZnVuIHEgLT5cbiAgbWF0Y2ggcSB3aXRoXG4gIHwgU2hhbGxvdyBaZXJvIC0+IHJhaXNlIEVtcHR5XG4gIHwgU2hhbGxvdyAoT25lIHgpIC0+IHhcbiAgfCBTaGFsbG93IChUd28gKHgsIF8pKSAtPiB4XG4gIHwgU2hhbGxvdyAoVGhyZWUgKHgsIF8sIF8pKSAtPiB4XG4gIHwgRGVlcCB7IGYgPSBPbmUgeDsgXyB9IC0+IHhcbiAgfCBEZWVwIHsgZiA9IFR3byAoeCwgXyk7IF8gfSAtPiB4XG4gIHwgRGVlcCB7IGYgPSBUaHJlZSAoeCwgXywgXyk7IF8gfSAtPiB4XG5cbmxldCBwb3AgcSA9IHRyeSBTb21lIChwb3BfZXhuIHEpIHdpdGggRW1wdHkgLT4gTm9uZVxubGV0IHRhaWwgcSA9IHRyeSBTb21lICh0YWlsX2V4biBxKSB3aXRoIEVtcHR5IC0+IE5vbmVcbmxldCBwZWVrIHEgPSB0cnkgU29tZSAocGVla19leG4gcSkgd2l0aCBFbXB0eSAtPiBOb25lXG5cbmxldCByZWMgY29ucyA6IHR5cGUgYS4gYSB0IC0+IGEgLT4gYSB0ID1cbiBmdW4gcSB4IC0+XG4gIG1hdGNoIHEgd2l0aFxuICB8IFNoYWxsb3cgWmVybyAtPiBfb25lIHhcbiAgfCBTaGFsbG93IChPbmUgeSkgLT4gX3R3byB4IHlcbiAgfCBTaGFsbG93IChUd28gKHksIHopKSAtPiBfdGhyZWUgeCB5IHpcbiAgfCBTaGFsbG93IChUaHJlZSAoeSwgeiwgeicpKSAtPlxuICAgICAgX2RlZXAgNCAoVHdvICh4LCB5KSkgKExhenkuZnJvbV92YWwgZW1wdHkpIChUd28gKHosIHonKSlcbiAgfCBEZWVwIHsgczsgZiA9IE9uZSB5OyBtOyByIH0gLT4gX2RlZXAgKHMgKyAxKSAoVHdvICh4LCB5KSkgbSByXG4gIHwgRGVlcCB7IHM7IGYgPSBUd28gKHksIHopOyBtOyByIH0gLT4gX2RlZXAgKHMgKyAxKSAoVGhyZWUgKHgsIHksIHopKSBtIHJcbiAgfCBEZWVwIHsgczsgZiA9IFRocmVlICh5LCB6LCB6Jyk7IG0gPSAobGF6eSBxJyk7IHIgfSAtPlxuICAgICAgX2RlZXAgKHMgKyAxKSAoVGhyZWUgKHgsIHksIHopKSAobGF6eSAoY29ucyBxJyAoeiwgeicpKSkgclxuXG5sZXQgaXRlciA6IHR5cGUgYS4gKGEgLT4gdW5pdCkgLT4gYSB0IC0+IHVuaXQgPVxuIGZ1biBmIHEgLT5cbiAgbGV0IHJlYyBnbyA6IHR5cGUgYS4gKGEgLT4gdW5pdCkgLT4gYSB0IC0+IHVuaXQgPVxuICAgZnVuIGYgLT4gZnVuY3Rpb25cbiAgICB8IFNoYWxsb3cgWmVybyAtPiAoKVxuICAgIHwgU2hhbGxvdyAoT25lIHgpIC0+IGYgeFxuICAgIHwgU2hhbGxvdyAoVHdvICh4LCB5KSkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBmIHlcbiAgICB8IFNoYWxsb3cgKFRocmVlICh4LCB5LCB6KSkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBmIHk7XG4gICAgICAgIGYgelxuICAgIHwgRGVlcCB7IGYgPSBoZDsgbSA9IChsYXp5IHEpOyByID0gdGw7IF8gfSAtPlxuICAgICAgICBnbyBmIChTaGFsbG93IGhkKTtcbiAgICAgICAgZ29cbiAgICAgICAgICAoZnVuICh4LCB5KSAtPlxuICAgICAgICAgICAgZiB4O1xuICAgICAgICAgICAgZiB5KVxuICAgICAgICAgIHE7XG4gICAgICAgIGdvIGYgKFNoYWxsb3cgdGwpXG4gIGluXG4gIGdvIGYgcVxuXG5sZXQgcmV2X2l0ZXIgOiB0eXBlIGEuIChhIC0+IHVuaXQpIC0+IGEgdCAtPiB1bml0ID1cbiBmdW4gZiBxIC0+XG4gIGxldCByZWMgZ28gOiB0eXBlIGEuIChhIC0+IHVuaXQpIC0+IGEgdCAtPiB1bml0ID1cbiAgIGZ1biBmIC0+IGZ1bmN0aW9uXG4gICAgfCBTaGFsbG93IFplcm8gLT4gKClcbiAgICB8IFNoYWxsb3cgKE9uZSB4KSAtPiBmIHhcbiAgICB8IFNoYWxsb3cgKFR3byAoeSwgeCkpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgZiB5XG4gICAgfCBTaGFsbG93IChUaHJlZSAoeiwgeSwgeCkpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgZiB5O1xuICAgICAgICBmIHpcbiAgICB8IERlZXAgeyBmID0gaGQ7IG0gPSAobGF6eSBxKTsgciA9IHRsOyBfIH0gLT5cbiAgICAgICAgZ28gZiAoU2hhbGxvdyB0bCk7XG4gICAgICAgIGdvXG4gICAgICAgICAgKGZ1biAoeSwgeCkgLT5cbiAgICAgICAgICAgIGYgeDtcbiAgICAgICAgICAgIGYgeSlcbiAgICAgICAgICBxO1xuICAgICAgICBnbyBmIChTaGFsbG93IGhkKVxuICBpblxuICBnbyBmIHFcblxubGV0IGZvbGQgOiB0eXBlIGFjYyB4LiAoYWNjIC0+IHggLT4gYWNjKSAtPiBhY2MgLT4geCB0IC0+IGFjYyA9XG4gZnVuIGYgYSBxIC0+XG4gIGxldCByZWMgZ28gOiB0eXBlIGFjYyB4LiAoYWNjIC0+IHggLT4gYWNjKSAtPiBhY2MgLT4geCB0IC0+IGFjYyA9XG4gICBmdW4gZiBhIC0+IGZ1bmN0aW9uXG4gICAgfCBTaGFsbG93IFplcm8gLT4gYVxuICAgIHwgU2hhbGxvdyAoT25lIHgpIC0+IGYgYSB4XG4gICAgfCBTaGFsbG93IChUd28gKHgsIHkpKSAtPiBmIChmIGEgeCkgeVxuICAgIHwgU2hhbGxvdyAoVGhyZWUgKHgsIHksIHopKSAtPiBmIChmIChmIGEgeCkgeSkgelxuICAgIHwgRGVlcCB7IGYgPSBoZDsgbSA9IChsYXp5IHEpOyByID0gdGw7IF8gfSAtPlxuICAgICAgICBsZXQgYSA9IGdvIGYgYSAoU2hhbGxvdyBoZCkgaW5cbiAgICAgICAgbGV0IGEgPSBnbyAoZnVuIGEgKHgsIHkpIC0+IGYgKGYgYSB4KSB5KSBhIHEgaW5cbiAgICAgICAgZ28gZiBhIChTaGFsbG93IHRsKVxuICBpblxuICBnbyBmIGEgcVxuXG5sZXQgbGVuZ3RoID0gZnVuY3Rpb25cbiAgfCBEZWVwIHsgczsgXyB9IC0+IHNcbiAgfCBTaGFsbG93IFplcm8gLT4gMFxuICB8IFNoYWxsb3cgKE9uZSBfKSAtPiAxXG4gIHwgU2hhbGxvdyAoVHdvIF8pIC0+IDJcbiAgfCBTaGFsbG93IChUaHJlZSBfKSAtPiAzXG5cbmxldCBwcCA/c2VwIHBwX2VsdCA9IEZtdC5pdGVyID9zZXAgaXRlciBwcF9lbHRcbmxldCBkdW1wIHBwX2VsdCA9IEZtdC5EdW1wLml0ZXIgaXRlciAoRm10LmFueSBcImZrZVwiKSBwcF9lbHRcblxubW9kdWxlIFdlaWdodGVkID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9IHtcbiAgICByIDogaW50O1xuICAgIHcgOiBpbnQ7XG4gICAgYyA6IGludDtcbiAgICBrIDogKCdhLCAnYikgQmlnYXJyYXkua2luZDtcbiAgICB2IDogKCdhLCAnYiwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkFycmF5MS50O1xuICB9XG5cbiAgZXhjZXB0aW9uIEVtcHR5XG4gIGV4Y2VwdGlvbiBGdWxsXG5cbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBtYXNrIHQgdiA9IHYgbGFuZCAodC5jIC0gMSlcbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBlbXB0eSB0ID0gdC5yID0gdC53XG4gIGxldFtAaW5saW5lIGFsd2F5c10gc2l6ZSB0ID0gdC53IC0gdC5yXG4gIGxldFtAaW5saW5lIGFsd2F5c10gZnVsbCB0ID0gc2l6ZSB0ID0gdC5jXG4gIGxldFtAaW5saW5lIGFsd2F5c10gYXZhaWxhYmxlIHQgPSB0LmMgLSAodC53IC0gdC5yKVxuICBsZXQgaXNfZW1wdHkgdCA9IChlbXB0eSBbQGlubGluZWRdKSB0XG4gIGxldCBsZW5ndGggcSA9IHNpemUgcVxuXG4gIGxldFtAaW5saW5lIGFsd2F5c10gdG9fcG93ZXJfb2ZfdHdvIHYgPVxuICAgIGxldCByZXMgPSByZWYgKHByZWQgdikgaW5cbiAgICByZXMgOj0gIXJlcyBsb3IgKCFyZXMgbHNyIDEpO1xuICAgIHJlcyA6PSAhcmVzIGxvciAoIXJlcyBsc3IgMik7XG4gICAgcmVzIDo9ICFyZXMgbG9yICghcmVzIGxzciA0KTtcbiAgICByZXMgOj0gIXJlcyBsb3IgKCFyZXMgbHNyIDgpO1xuICAgIHJlcyA6PSAhcmVzIGxvciAoIXJlcyBsc3IgMTYpO1xuICAgIHN1Y2MgIXJlc1xuXG4gIGxldFtAaW5saW5lIGFsd2F5c10gaXNfcG93ZXJfb2ZfdHdvIHYgPSB2IDw+IDAgJiYgdiBsYW5kIChsbm90IHYgKyAxKSA9IHZcblxuICBsZXQgY3JlYXRlID9jYXBhY2l0eSBraW5kID1cbiAgICBsZXQgY2FwYWNpdHkgPVxuICAgICAgbWF0Y2ggY2FwYWNpdHkgd2l0aFxuICAgICAgfCBOb25lIHwgU29tZSAwIC0+IDFcbiAgICAgIHwgU29tZSBuIC0+XG4gICAgICAgICAgaWYgbiA8IDAgdGhlbiBGbXQuaW52YWxpZF9hcmcgXCJSa2UuV2VpZ2h0ZWQuY3JlYXRlXCJcbiAgICAgICAgICBlbHNlIHRvX3Bvd2VyX29mX3R3byBuXG4gICAgaW5cbiAgICAoIHtcbiAgICAgICAgciA9IDA7XG4gICAgICAgIHcgPSAwO1xuICAgICAgICBjID0gY2FwYWNpdHk7XG4gICAgICAgIGsgPSBraW5kO1xuICAgICAgICB2ID0gQmlnYXJyYXkuQXJyYXkxLmNyZWF0ZSBraW5kIEJpZ2FycmF5LmNfbGF5b3V0IGNhcGFjaXR5O1xuICAgICAgfSxcbiAgICAgIGNhcGFjaXR5IClcblxuICBsZXQgY29weSB0ID1cbiAgICBsZXQgdiA9IEJpZ2FycmF5LkFycmF5MS5jcmVhdGUgdC5rIEJpZ2FycmF5LmNfbGF5b3V0IHQuYyBpblxuICAgIEJpZ2FycmF5LkFycmF5MS5ibGl0IHQudiB2O1xuICAgIHsgciA9IHQucjsgdyA9IHQudzsgYyA9IHQuYzsgdjsgayA9IHQuayB9XG5cbiAgbGV0IGZyb20gdiA9XG4gICAgaWYgbm90IChpc19wb3dlcl9vZl90d28gKEJpZ2FycmF5LkFycmF5MS5kaW0gdikpIHRoZW5cbiAgICAgIEZtdC5pbnZhbGlkX2FyZyBcIlJCQS5mcm9tXCI7XG4gICAgbGV0IGMgPSBCaWdhcnJheS5BcnJheTEuZGltIHYgaW5cbiAgICBsZXQgayA9IEJpZ2FycmF5LkFycmF5MS5raW5kIHYgaW5cbiAgICB7IHIgPSAwOyB3ID0gMDsgYzsgazsgdiB9XG5cbiAgbGV0IHB1c2hfZXhuIHQgdiA9XG4gICAgaWYgKGZ1bGwgW0BpbmxpbmVkXSkgdCB0aGVuIHJhaXNlIEZ1bGw7XG4gICAgQmlnYXJyYXkuQXJyYXkxLnVuc2FmZV9zZXQgdC52ICgobWFzayBbQGlubGluZWRdKSB0IHQudykgdjtcbiAgICB7IHQgd2l0aCB3ID0gdC53ICsgMSB9XG5cbiAgbGV0IHB1c2ggdCB2ID0gdHJ5IFNvbWUgKHB1c2hfZXhuIHQgdikgd2l0aCBGdWxsIC0+IE5vbmVcblxuICBsZXQgY29uc19leG4gdCB2ID1cbiAgICBpZiAoZnVsbCBbQGlubGluZWRdKSB0IHRoZW4gcmFpc2UgRnVsbDtcbiAgICBsZXQgaSA9IHQuciAtIDEgaW5cbiAgICBCaWdhcnJheS5BcnJheTEudW5zYWZlX3NldCB0LnYgKChtYXNrIFtAaW5saW5lZF0pIHQgaSkgdjtcbiAgICB7IHQgd2l0aCByID0gaSB9XG5cbiAgbGV0IGNvbnMgdCB2ID0gdHJ5IFNvbWUgKGNvbnNfZXhuIHQgdikgd2l0aCBGdWxsIC0+IE5vbmVcblxuICBsZXQgcG9wX2V4biB0ID1cbiAgICBpZiAoZW1wdHkgW0BpbmxpbmVkXSkgdCB0aGVuIHJhaXNlIEVtcHR5O1xuICAgIGxldCByID0gQmlnYXJyYXkuQXJyYXkxLnVuc2FmZV9nZXQgdC52ICgobWFzayBbQGlubGluZWRdKSB0IHQucikgaW5cbiAgICAociwgeyB0IHdpdGggciA9IHQuciArIDEgfSlcblxuICBsZXQgcG9wIHQgPSB0cnkgU29tZSAocG9wX2V4biB0KSB3aXRoIEVtcHR5IC0+IE5vbmVcblxuICBsZXQgcGVla19leG4gdCA9XG4gICAgaWYgKGVtcHR5IFtAaW5saW5lZF0pIHQgdGhlbiByYWlzZSBFbXB0eTtcbiAgICBCaWdhcnJheS5BcnJheTEudW5zYWZlX2dldCB0LnYgKChtYXNrIFtAaW5saW5lZF0pIHQgdC5yKVxuXG4gIGxldCBwZWVrIHQgPSB0cnkgU29tZSAocGVla19leG4gdCkgd2l0aCBFbXB0eSAtPiBOb25lXG5cbiAgbW9kdWxlIE4gPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2IpIGJpZ2FycmF5ID0gKCdhLCAnYiwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkFycmF5MS50XG4gICAgdHlwZSAoJ2EsICdiKSBibGl0ID0gJ2EgLT4gaW50IC0+ICdiIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgIHR5cGUgJ2EgbGVuZ3RoID0gJ2EgLT4gaW50XG5cbiAgICBsZXQgcHVzaF9leG4gdCB+YmxpdCB+bGVuZ3RoID8ob2ZmID0gMCkgP2xlbiB2ID1cbiAgICAgIGxldCBsZW4gPSBtYXRjaCBsZW4gd2l0aCBOb25lIC0+IGxlbmd0aCB2IC0gb2ZmIHwgU29tZSBsZW4gLT4gbGVuIGluXG4gICAgICBpZiAoYXZhaWxhYmxlIFtAaW5saW5lZF0pIHQgPCBsZW4gdGhlbiByYWlzZSBGdWxsO1xuICAgICAgbGV0IG1zayA9IChtYXNrIFtAaW5saW5lZF0pIHQgdC53IGluXG4gICAgICBsZXQgcHJlID0gdC5jIC0gbXNrIGluXG4gICAgICBsZXQgcnN0ID0gbGVuIC0gcHJlIGluXG4gICAgICBsZXQgcmV0ID1cbiAgICAgICAgaWYgcnN0ID4gMCB0aGVuIChcbiAgICAgICAgICBibGl0IHYgb2ZmIHQudiBtc2sgcHJlO1xuICAgICAgICAgIGJsaXQgdiAob2ZmICsgcHJlKSB0LnYgMCByc3Q7XG4gICAgICAgICAgW1xuICAgICAgICAgICAgQmlnYXJyYXkuQXJyYXkxLnN1YiB0LnYgKChtYXNrIFtAaW5saW5lZF0pIHQgdC53KSBwcmU7XG4gICAgICAgICAgICBCaWdhcnJheS5BcnJheTEuc3ViIHQudiAwIHJzdDtcbiAgICAgICAgICBdKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBibGl0IHYgb2ZmIHQudiBtc2sgbGVuO1xuICAgICAgICAgIFsgQmlnYXJyYXkuQXJyYXkxLnN1YiB0LnYgKChtYXNrIFtAaW5saW5lZF0pIHQgdC53KSBsZW4gXSlcbiAgICAgIGluXG4gICAgICAocmV0LCB7IHQgd2l0aCB3ID0gdC53ICsgbGVuIH0pXG5cbiAgICBsZXQgcHVzaCB0IH5ibGl0IH5sZW5ndGggP29mZiA/bGVuIHYgPVxuICAgICAgdHJ5IFNvbWUgKHB1c2hfZXhuIHQgfmJsaXQgfmxlbmd0aCA/b2ZmID9sZW4gdikgd2l0aCBGdWxsIC0+IE5vbmVcblxuICAgIGxldCBrZWVwX2V4biB0IH5ibGl0IH5sZW5ndGggPyhvZmYgPSAwKSA/bGVuIHYgPVxuICAgICAgbGV0IGxlbiA9IG1hdGNoIGxlbiB3aXRoIE5vbmUgLT4gbGVuZ3RoIHYgfCBTb21lIGxlbiAtPiBsZW4gaW5cbiAgICAgIGlmIChzaXplIFtAaW5saW5lZF0pIHQgPCBsZW4gdGhlbiByYWlzZSBFbXB0eTtcbiAgICAgIGxldCBtc2sgPSAobWFzayBbQGlubGluZWRdKSB0IHQuciBpblxuICAgICAgbGV0IHByZSA9IHQuYyAtIG1zayBpblxuICAgICAgbGV0IHJzdCA9IGxlbiAtIHByZSBpblxuICAgICAgaWYgcnN0ID4gMCB0aGVuIChcbiAgICAgICAgYmxpdCB0LnYgbXNrIHYgb2ZmIHByZTtcbiAgICAgICAgYmxpdCB0LnYgMCB2IChvZmYgKyBwcmUpIHJzdClcbiAgICAgIGVsc2UgYmxpdCB0LnYgbXNrIHYgb2ZmIGxlblxuXG4gICAgbGV0IGtlZXAgdCB+YmxpdCB+bGVuZ3RoID9vZmYgP2xlbiB2ID1cbiAgICAgIHRyeSBTb21lIChrZWVwX2V4biB0IH5ibGl0IH5sZW5ndGggP29mZiA/bGVuIHYpIHdpdGggRW1wdHkgLT4gTm9uZVxuXG4gICAgbGV0IHVuc2FmZV9zaGlmdCB0IGxlbiA9IHsgdCB3aXRoIHIgPSB0LnIgKyBsZW4gfVxuXG4gICAgbGV0IHNoaWZ0X2V4biB0IGxlbiA9XG4gICAgICBpZiAoc2l6ZSBbQGlubGluZWRdKSB0IDwgbGVuIHRoZW4gcmFpc2UgRW1wdHk7XG4gICAgICB1bnNhZmVfc2hpZnQgdCBsZW5cblxuICAgIGxldCBzaGlmdCB0IGxlbiA9IHRyeSBTb21lIChzaGlmdF9leG4gdCBsZW4pIHdpdGggRW1wdHkgLT4gTm9uZVxuICBlbmRcblxuICBsZXQgaXRlciBmIHQgPVxuICAgIGxldCBpZHggPSByZWYgdC5yIGluXG4gICAgbGV0IG1heCA9IHQudyBpblxuICAgIHdoaWxlICFpZHggPD4gbWF4IGRvXG4gICAgICBmIChCaWdhcnJheS5BcnJheTEudW5zYWZlX2dldCB0LnYgKChtYXNrIFtAaW5saW5lZF0pIHQgIWlkeCkpO1xuICAgICAgaW5jciBpZHhcbiAgICBkb25lXG5cbiAgbGV0IHJldl9pdGVyIGYgdCA9XG4gICAgaWYgdC5yID09IHQudyB0aGVuICgpXG4gICAgZWxzZVxuICAgICAgbGV0IGlkeCA9IHJlZiAocHJlZCB0LncpIGluXG4gICAgICBsZXQgbWluID0gdC5yIGluXG4gICAgICB3aGlsZVxuICAgICAgICBmIChCaWdhcnJheS5BcnJheTEudW5zYWZlX2dldCB0LnYgKChtYXNrIFtAaW5saW5lZF0pIHQgIWlkeCkpO1xuICAgICAgICAhaWR4IDw+IG1pblxuICAgICAgZG9cbiAgICAgICAgZGVjciBpZHhcbiAgICAgIGRvbmVcblxuICBsZXQgZm9sZCBmIGEgdCA9XG4gICAgbGV0IGEgPSByZWYgYSBpblxuICAgIGl0ZXIgKGZ1biB4IC0+IGEgOj0gZiAhYSB4KSB0O1xuICAgICFhXG5cbiAgbGV0IGNsZWFyIHQgPSB7IHQgd2l0aCByID0gMDsgdyA9IDAgfVxuICBsZXQgdW5zYWZlX2JpZ2FycmF5IHsgdjsgXyB9ID0gdlxuICBsZXQgcHAgP3NlcCBwcF9lbHQgPSBGbXQuaXRlciA/c2VwIGl0ZXIgcHBfZWx0XG4gIGxldCBkdW1wIHBwX2VsdCA9IEZtdC5EdW1wLml0ZXIgaXRlciAoRm10LmFueSBcImZrZTp3ZWlnaHRlZFwiKSBwcF9lbHRcbmVuZFxuIl19
