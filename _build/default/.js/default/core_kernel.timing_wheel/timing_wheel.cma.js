// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Timing_wheel__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Timing_wheel = [0],
    Timing_wheel$0 = [0, Timing_wheel];
   runtime.caml_register_global(0, Timing_wheel$0, "Timing_wheel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Import
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Import = "Timing_wheel__Import",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1(Ppx_expect_runtime[1][1], "timing_wheel/src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_timing_wheel, "import.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_timing_wheel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Import);
   var Timing_wheel_Import = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Import, cst_Timing_wheel_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Timing_wheel_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Timing_wheel_ = "Timing_wheel__Timing_wheel_intf",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Timing_wheel_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1
    (Ppx_expect_runtime[1][1], "timing_wheel/src/timing_wheel_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_timing_wheel, "timing_wheel_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_timing_wheel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Timing_wheel_);
   var Timing_wheel_Timing_wheel_intf = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Timing_wheel_intf, cst_Timing_wheel_Timing_wheel_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel
//# unitInfo: Requires: Base__Invariant, Base__Sexpable, Core, Core__Array, Core__Binable, Core__Int, Core__Int63, Core__List, Core__Time_ns, Core__Time_ns_alternate_sexp, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_record, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel$0 = "Timing_wheel",
    cst_Timing_wheel_max_alarm_tim$1 =
      "Timing_wheel.max_alarm_time_in_min_interval_exn of empty timing wheel",
    cst = "_",
    cst_alarm_precision$0 = "alarm_precision",
    cst_at = "at",
    cst_bits$0 = "bits",
    cst_bits_per_slot$0 = "bits_per_slot",
    cst_capacity$0 = "capacity",
    cst_config$0 = "config",
    cst_diff_max_min_allowed_key$0 = "diff_max_min_allowed_key",
    cst_elt_key_lower_bound$0 = "elt_key_lower_bound",
    cst_index$0 = "index",
    cst_interval_num = "interval_num",
    cst_key = "key",
    cst_keys_per_slot$0 = "keys_per_slot",
    cst_length$1 = "length",
    cst_level_bits$1 = "level_bits",
    cst_levels$0 = "levels",
    cst_max_allowed_alarm_time$0 = "max_allowed_alarm_time",
    cst_max_allowed_key$0 = "max_allowed_key",
    cst_max_interval_num$0 = "max_interval_num",
    cst_min_allowed_key$0 = "min_allowed_key",
    cst_min_elt$0 = "min_elt",
    cst_min_key_in_same_slot_mask$0 = "min_key_in_same_slot_mask",
    cst_now$0 = "now",
    cst_now_interval_num_start$0 = "now_interval_num_start",
    cst_pool$0 = "pool",
    cst_priority_queue$0 = "priority_queue",
    cst_slots$0 = "slots",
    cst_slots_mask$0 = "slots_mask",
    cst_start$0 = "start",
    cst_timing_wheel$0 = "timing_wheel",
    cst_timing_wheel_src_timing_wh = "timing_wheel/src/timing_wheel.ml",
    cst_value = "value",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos$9 = "timing_wheel/src/timing_wheel.ml:1617:26",
    pos$8 = "timing_wheel/src/timing_wheel.ml:1614:26",
    pos$7 = "timing_wheel/src/timing_wheel.ml:1630:26",
    pos$6 = "timing_wheel/src/timing_wheel.ml:1635:26",
    arg_087 = [0, cst],
    pos$5 = "timing_wheel/src/timing_wheel.ml:993:32",
    pos$4 = "timing_wheel/src/timing_wheel.ml:990:32",
    pos$3 = "timing_wheel/src/timing_wheel.ml:900:31",
    pos$2 = "timing_wheel/src/timing_wheel.ml:907:30",
    pos$1 = "timing_wheel/src/timing_wheel.ml:918:31",
    pos$0 = "timing_wheel/src/timing_wheel.ml:936:32",
    pos = "timing_wheel/src/timing_wheel.ml:941:30",
    error_source_019 = "timing_wheel/src/timing_wheel.ml.Config.t",
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Core_Time_ns_alternate_sexp = global_data.Core__Time_ns_alternate_sexp,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Time_ns = global_data.Core__Time_ns,
    Core_List = global_data.Core__List,
    Core_Int63 = global_data.Core__Int63,
    Core_Array = global_data.Core__Array,
    Tuple_pool = global_data.Tuple_pool,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int,
    Core_Binable = global_data.Core__Binable,
    Base_Sexpable = global_data.Base__Sexpable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_timing_wheel_src_timing_wh);
   caml_call2(Ppx_inline_test_lib[6], cst_timing_wheel$0, "timing_wheel.ml");
   var
    max_time = Core_Time_ns_alternate_sexp[37],
    min_time = Core_Time_ns_alternate_sexp[35],
    zero = Core_Int[59],
    to_int = Core_Int[65],
    t_of_sexp = Core_Int[76],
    sexp_of_t = Core_Int[77],
    symbol = Core_Int[81],
    symbol$0 = Core_Int[82],
    symbol$1 = Core_Int[84],
    equal = Core_Int[87],
    max_num_bits = Core_Int63[61] - 1 | 0,
    _b8_ = [0, cst],
    _b9_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_max_alarm_tim$0 = cst_Timing_wheel_max_alarm_tim$1,
    _b6_ = [0, cst],
    _b7_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_max_alarm_tim = cst_Timing_wheel_max_alarm_tim$1,
    _b4_ = [0, cst],
    _b5_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_min_alarm_int =
      "Timing_wheel.min_alarm_interval_num_exn of empty timing_wheel",
    cst_Timing_wheel_cannot_resche =
      "Timing_wheel cannot reschedule alarm not in timing wheel",
    _b2_ = [0, cst_now_interval_num_start$0],
    _b3_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu$0 =
      "Timing_wheel cannot schedule alarm before start of current interval",
    _b0_ = [0, cst_max_allowed_alarm_time$0],
    _b1_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu =
      "Timing_wheel cannot schedule alarm that far in the future",
    _bZ_ = [0, cst_timing_wheel_src_timing_wh, 1707, 53],
    _bY_ = [0, cst_start$0],
    cst_Timing_wheel_create_got_st =
      "Timing_wheel.create got start before the epoch",
    _bX_ = [0, cst_timing_wheel_src_timing_wh, 1680, 54],
    _bW_ = [0, cst_timing_wheel_src_timing_wh, 1674, 52],
    _bU_ = [0, cst],
    _bT_ = [0, cst_timing_wheel_src_timing_wh, 1640, 6],
    _bS_ = [0, cst_timing_wheel_src_timing_wh, 1644, 6],
    _bR_ = [0, cst_timing_wheel_src_timing_wh, 1646, 6],
    _bQ_ = [0, cst_timing_wheel_src_timing_wh, 1610, 11],
    _bP_ = [0, cst_timing_wheel_src_timing_wh, 1611, 11],
    _bO_ = [0, cst_timing_wheel_src_timing_wh, 1622, 11],
    _bN_ = [0, cst_timing_wheel_src_timing_wh, 1623, 11],
    _bM_ = [0, cst_timing_wheel_src_timing_wh, 1624, 11],
    _bV_ = [0, cst_timing_wheel_src_timing_wh, 1604, 57929, 57951],
    _bK_ = [0, "t.max_interval_num"],
    _bL_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$1 =
      "Timing_wheel.interval_num_start got too large interval_num",
    _bI_ = [0, "min_interval_num"],
    _bJ_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$0 =
      "Timing_wheel.interval_num_start got too small interval_num",
    _bH_ = [0, "time"],
    cst_Timing_wheel_interval_num_ =
      "Timing_wheel.interval_num got time too far in the past",
    _bF_ = [0, cst],
    _bG_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_next_alarm_fi$0 =
      "Timing_wheel.next_alarm_fires_at_exn with all alarms in max interval",
    _bD_ = [0, cst],
    _bE_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_next_alarm_fi =
      "Timing_wheel.next_alarm_fires_at_exn of empty timing wheel",
    _by_ = [0, "alarms"],
    _bz_ = [0, cst_now$0],
    _bA_ = [0, cst_max_interval_num$0],
    _bB_ = [0, cst_start$0],
    _bC_ = [0, cst_config$0],
    _bw_ = [0, cst_value],
    _bx_ = [0, cst_at],
    _be_ = [0, "max_allowed_alarm_interval_num"],
    _bf_ = [0, "min_allowed_alarm_interval_num"],
    _bg_ = [0, cst_interval_num],
    cst_Timing_wheel_add_at_interv =
      "Timing_wheel.add_at_interval_num got invalid interval num",
    _bb_ = [0, cst],
    _bc_ = [0, "level"],
    _bd_ = [0, cst_key],
    cst_Priority_queue_add_elt_key$0 =
      "Priority_queue.add_elt key out of level bounds",
    _a9_ = [0, cst_priority_queue$0],
    _a__ = [0, "max_allowed_key t"],
    _a$_ = [0, "min_allowed_key t"],
    _ba_ = [0, cst_key],
    cst_Priority_queue_add_elt_key =
      "Priority_queue.add_elt key out of bounds",
    _a7_ = [0, cst],
    _a4_ = [0, cst_timing_wheel_src_timing_wh, 965, 38],
    _a3_ = [0, cst_timing_wheel_src_timing_wh, 971, 15],
    _a2_ = [0, cst_timing_wheel_src_timing_wh, 972, 15],
    _a1_ = [0, cst_timing_wheel_src_timing_wh, 975, 13],
    _a0_ = [0, cst_timing_wheel_src_timing_wh, 976, 13],
    _aZ_ = [0, cst_timing_wheel_src_timing_wh, 979, 15],
    _aX_ = [0, cst_timing_wheel_src_timing_wh, 984, 15],
    _aY_ = [0, cst_timing_wheel_src_timing_wh, 982, 13],
    _a6_ = [0, cst_timing_wheel_src_timing_wh, 962, 6],
    _a5_ = [0, cst_timing_wheel_src_timing_wh, 963, 6],
    _aV_ = [0, cst],
    _aU_ = [0, cst_timing_wheel_src_timing_wh, 896, 38],
    _aT_ = [0, cst_timing_wheel_src_timing_wh, 897, 36],
    _aS_ = [0, cst_timing_wheel_src_timing_wh, 904, 15],
    _aR_ = [0, cst_timing_wheel_src_timing_wh, 912, 15],
    _aQ_ = [0, cst_timing_wheel_src_timing_wh, 925, 15],
    _aP_ = [0, cst_timing_wheel_src_timing_wh, 933, 15],
    _aO_ = [0, cst_timing_wheel_src_timing_wh, 954, 21],
    _aN_ = [0, cst_timing_wheel_src_timing_wh, 955, 21],
    _aM_ = [0, cst_timing_wheel_src_timing_wh, 956, 21],
    _aL_ = [0, cst_timing_wheel_src_timing_wh, 957, 21],
    _aW_ = [0, cst_timing_wheel_src_timing_wh, 893, 31661, 31687],
    _a8_ = [0, cst_timing_wheel_src_timing_wh, 960, 34764, 34788],
    _aI_ = [0, "elts"],
    _aJ_ = [0, cst_max_allowed_key$0],
    _aK_ = [0, cst_min_allowed_key$0],
    _aG_ = [0, cst_value],
    _aH_ = [0, cst_key],
    _aB_ = [0, cst_levels$0],
    _aC_ = [0, cst_elt_key_lower_bound$0],
    _aD_ = [0, cst_min_elt$0],
    _aE_ = [0, cst_pool$0],
    _aF_ = [0, cst_length$1],
    _ag_ = [0, cst_slots$0],
    _ah_ = [0, cst_max_allowed_key$0],
    _ai_ = [0, cst_min_allowed_key$0],
    _aj_ = [0, cst_length$1],
    _ak_ = [0, cst_diff_max_min_allowed_key$0],
    _al_ = [0, cst_min_key_in_same_slot_mask$0],
    _am_ = [0, cst_keys_per_slot$0],
    _an_ = [0, cst_bits_per_slot$0],
    _ao_ = [0, cst_slots_mask$0],
    _ap_ = [0, cst_bits$0],
    _aq_ = [0, cst_index$0],
    cst_Timing_wheel_got_invalid_a = "Timing_wheel got invalid alarm",
    _K_ = [0, cst],
    _J_ = [0, cst_timing_wheel_src_timing_wh, 646, 8],
    _I_ = [0, cst_timing_wheel_src_timing_wh, 649, 8],
    _H_ = [0, cst_timing_wheel_src_timing_wh, 651, 8],
    _L_ = [0, cst_timing_wheel_src_timing_wh, 645, 23075, 23101],
    _t_ = [0, 10, [0, 10, [0, 6, [0, 6, [0, 5, 0]]]]],
    _r_ = [0, cst_timing_wheel_src_timing_wh, 257, 6],
    _s_ = [0, cst_timing_wheel_src_timing_wh, 256, 8286, 8310],
    _o_ = [0, cst_capacity$0],
    _p_ = [0, cst_level_bits$1],
    _q_ = [0, cst_alarm_precision$0],
    cst_capacity = cst_capacity$0,
    cst_level_bits$0 = cst_level_bits$1,
    cst_alarm_precision = cst_alarm_precision$0,
    _h_ = [0, "span"],
    cst_Alarm_precision_of_span_fl =
      "[Alarm_precision.of_span_floor_pow2_ns] got non-positive span",
    cst_Alarm_precision_to_span_of =
      "[Alarm_precision.to_span] of negative power of two nanoseconds",
    _e_ = [0, "max_num_bits"],
    _f_ = [0, "got"],
    cst_Level_bits_create_exn_got_$0 =
      "Level_bits.create_exn got too many bits",
    cst_Level_bits_create_exn_got_ =
      "Level_bits.create_exn got nonpositive num bits",
    cst_Level_bits_create_exn_requ =
      "Level_bits.create_exn requires a nonempty list",
    _d_ = [0, cst_timing_wheel_src_timing_wh, 117, 6],
    _c_ = [0, cst_timing_wheel_src_timing_wh, 114, 4],
    _b_ = [0, cst_timing_wheel_src_timing_wh, 82, 4],
    _a_ = [0, cst_timing_wheel_src_timing_wh, 83, 4],
    _g_ = [0, 11, [0, 10, [0, 10, [0, 10, [0, 10, [0, 10, [0, 1, 0]]]]]]],
    cst_level_bits = cst_level_bits$1,
    cst_slots = cst_slots$0,
    cst_max_allowed_key = cst_max_allowed_key$0,
    cst_min_allowed_key = cst_min_allowed_key$0,
    cst_length = cst_length$1,
    cst_diff_max_min_allowed_key = cst_diff_max_min_allowed_key$0,
    cst_min_key_in_same_slot_mask = cst_min_key_in_same_slot_mask$0,
    cst_keys_per_slot = cst_keys_per_slot$0,
    cst_bits_per_slot = cst_bits_per_slot$0,
    cst_slots_mask = cst_slots_mask$0,
    cst_bits = cst_bits$0,
    cst_index = cst_index$0,
    cst_levels = cst_levels$0,
    cst_elt_key_lower_bound = cst_elt_key_lower_bound$0,
    cst_min_elt = cst_min_elt$0,
    cst_pool = cst_pool$0,
    cst_length$0 = cst_length$1,
    cst_priority_queue = cst_priority_queue$0,
    cst_max_allowed_alarm_time = cst_max_allowed_alarm_time$0,
    cst_now_interval_num_start = cst_now_interval_num_start$0,
    cst_now = cst_now$0,
    cst_max_interval_num = cst_max_interval_num$0,
    cst_start = cst_start$0,
    cst_config = cst_config$0,
    cst_timing_wheel = cst_timing_wheel$0,
    cst_Timing_wheel = cst_Timing_wheel$0,
    min_value = 0;
   function invariant(t){
    if(! caml_call2(symbol, t, min_value))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(caml_call2(symbol$0, t, max_num_bits)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function of_int(i){invariant(i); return i;}
   function symbol$2(t1, t2){var t = t1 + t2 | 0; invariant(t); return t;}
   function symbol$3(t1, t2){var t = t1 - t2 | 0; invariant(t); return t;}
   function pow2(t){return caml_call2(Core_Int63[50], Core_Int63[17], t);}
   function sexp_of_t$0(x_007){
    return caml_call2(Core[472], sexp_of_t, x_007);
   }
   function num_bits_internal(t){
    return caml_call3(Core_List[20], t, zero, symbol$2);
   }
   function num_bits(t){return num_bits_internal(t);}
   function invariant$0(t){
    if(caml_call1(Core_List[18], t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    function _fA_(num_key_bits){
     invariant(num_key_bits);
     if(caml_call2(symbol$1, num_key_bits, zero)) return 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    caml_call2(Core_List[19], t, _fA_);
    return invariant(num_bits_internal(t));
   }
   function t_of_sexp$0(x_006){
    var t = caml_call2(Core[473], t_of_sexp, x_006);
    invariant$0(t);
    return t;
   }
   function create_exn(opt, x_008){
    if(opt)
     var sth = opt[1], extend_to_max_num_bits = sth;
    else
     var extend_to_max_num_bits = 0;
    if(caml_call1(Core_List[18], x_008))
     caml_call1(Core[6], cst_Level_bits_create_exn_requ);
    function _fo_(bits){return caml_call2(Core[89], bits, 0);}
    if(caml_call2(Core_List[23], x_008, _fo_)){
     var
      _fp_ = [0, caml_call2(Core[472], Core[389], x_008), 0],
      _fq_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_),
          _fp_]];
     caml_call1(Core[261], _fq_);
    }
    function _fr_(_fz_, _fy_){return _fz_ + _fy_ | 0;}
    var num_bits = caml_call3(Core_List[20], x_008, 0, _fr_);
    if(caml_call2(Core[91], num_bits, max_num_bits)){
     var
      _fs_ =
        [0, [1, [0, _e_, [0, caml_call1(Core[389], max_num_bits), 0]]], 0],
      _ft_ = [0, [1, [0, _f_, [0, caml_call1(Core[389], num_bits), 0]]], _fs_],
      _fu_ = [0, caml_call2(Core[472], Core[389], x_008), _ft_],
      _fv_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_$0),
          _fu_]];
     caml_call1(Core[261], _fv_);
    }
    if(extend_to_max_num_bits)
     var
      _fw_ = caml_call1(Core[242], 1),
      _fx_ = caml_call2(Core_List[40], max_num_bits - num_bits | 0, _fw_),
      ints = caml_call2(Core[156], x_008, _fx_);
    else
     var ints = x_008;
    return caml_call2(Core_List[51], ints, of_int);
   }
   var level_bits_default = create_exn(0, _g_), compare = Core[382];
   function equal$0(x_012, x_013){
    return 0 === caml_call2(compare, x_012, x_013) ? 1 : 0;
   }
   function num_key_bits(t){return of_int(t);}
   function to_sexpable(t){
    if(caml_call2(Core[92], t, 0)){
     var
      _fl_ = [0, caml_call1(Core[389], t), 0],
      _fm_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_to_span_of),
          _fl_]];
     caml_call1(Core[261], _fm_);
    }
    var _fn_ = caml_call1(caml_call1(Core_Int63[50], Core_Int63[17]), t);
    return caml_call1(Core_Time_ns[1][137], _fn_);
   }
   function sexp_of_t$1(t){
    var _fk_ = to_sexpable(t);
    return caml_call1(Core_Time_ns[1][10], _fk_);
   }
   var
    one_nanosecond = 0,
    about_one_microsecond = 10,
    about_one_millisecond = 20,
    about_one_second = 30,
    about_one_day = 46;
   function mul(t, pow2){return t + pow2 | 0;}
   function div(t, pow2){return t - pow2 | 0;}
   function of_span_floor_pow2_ns(span){
    if(caml_call2(Core_Time_ns[1][16], span, Core_Time_ns[1][76])){
     var
      _fh_ =
        [0, [1, [0, _h_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], 0],
      _fi_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_of_span_fl),
          _fh_]];
     caml_call1(Core[261], _fi_);
    }
    var _fj_ = caml_call1(Core_Time_ns[1][136], span);
    return caml_call1(Core_Int63[89], _fj_);
   }
   var
    _i_ = Core_Time_ns[1],
    _j_ =
      caml_call1
       (caml_call1
         (Core_Binable[6], [0, _i_[5], _i_[1], _i_[2], _i_[3], _i_[4]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    bin_size_t = _j_[1],
    bin_write_t = _j_[2],
    bin_read_t = _j_[3],
    bin_read_t$0 = _j_[4],
    bin_shape_t = _j_[5],
    bin_writer_t = _j_[6],
    bin_reader_t = _j_[7],
    bin_t = _j_[8],
    _k_ = Core_Time_ns[1],
    include =
      caml_call1
       (caml_call1(Base_Sexpable[1], [0, _k_[9], _k_[10]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    t_of_sexp$1 = include[1],
    sexp_of_t$2 = include[2],
    _l_ =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       compare,
       t_of_sexp$1,
       sexp_of_t$2];
   function level_bits(r){return r[2];}
   function _m_(r, v){return [0, r[1], v, r[3]];}
   var
    _n_ = 0,
    level_bits$0 =
      [0, function(param){return 0;}, cst_level_bits, _n_, level_bits, _m_];
   function t_of_sexp$2(x_021){
    function _fb_(param){
     var
      _fg_ = param[2],
      capacity = _fg_[2][1],
      level_bits = _fg_[1],
      alarm_precision = param[1];
     return [0, alarm_precision, level_bits, capacity];
    }
    var _fc_ = 0;
    function _fd_(param){
     return caml_string_notequal(param, cst_alarm_precision$0)
             ? caml_string_notequal
                (param, cst_capacity$0)
               ? caml_string_notequal(param, cst_level_bits$1) ? -1 : 1
               : 2
             : 0;
    }
    var
     _fe_ = [0, cst_capacity, 5, Core[390], 0],
     _ff_ =
       [0,
        cst_level_bits$0,
        [0, function(param){return level_bits_default;}],
        t_of_sexp$0,
        _fe_];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_019,
             [0, cst_alarm_precision, 1, _l_[10], _ff_],
             _fd_,
             _fc_,
             _fb_,
             x_021);
   }
   function sexp_of_t$3(param){
    var
     capacity_027 = param[3],
     level_bits_025 = param[2],
     alarm_precision_023 = param[1],
     bnds_022 = 0;
    if(capacity_027)
     var
      v_028 = capacity_027[1],
      arg_030 = caml_call1(Core[389], v_028),
      bnd_029 = [1, [0, _o_, [0, arg_030, 0]]],
      bnds_022$0 = [0, bnd_029, bnds_022];
    else
     var bnds_022$0 = bnds_022;
    var
     arg_026 = sexp_of_t$0(level_bits_025),
     bnds_022$1 = [0, [1, [0, _p_, [0, arg_026, 0]]], bnds_022$0],
     arg_024 = caml_call1(_l_[11], alarm_precision_023),
     bnds_022$2 = [0, [1, [0, _q_, [0, arg_024, 0]]], bnds_022$1];
    return [1, bnds_022$2];
   }
   function alarm_precision(t){return to_sexpable(t[1]);}
   function max_num_level_bits(alarm_precision){
    return symbol$3(max_num_bits, num_key_bits(alarm_precision));
   }
   function invariant$1(t){
    function _e$_(param){
     var _fa_ = max_num_level_bits(t[1]);
     if(! caml_call2(symbol$0, num_bits_internal(t[2]), _fa_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
     var level_bits_fun = caml_call2(Base_Invariant[2], t, invariant$0);
     caml_call1(level_bits_fun, level_bits$0);
     return 0;
    }
    return caml_call4(Base_Invariant[1], _s_, t, sexp_of_t$3, _e$_);
   }
   function create(capacity, opt, alarm_precision, param){
    if(opt)
     var sth = opt[1], level_bits = sth;
    else
     var level_bits = level_bits_default;
    var max_num_bits = max_num_level_bits(alarm_precision);
    if(caml_call2(symbol$0, num_bits_internal(level_bits), max_num_bits))
     var level_bits$0 = level_bits;
    else
     var
      loop =
        function(t, remaining){
         if(! t) return 0;
         var t$0 = t[2], b = t[1];
         return caml_call2(symbol, b, remaining)
                 ? [0, remaining, 0]
                 : [0, b, loop(t$0, symbol$3(remaining, b))];
        },
      level_bits$0 = loop(level_bits, max_num_bits);
    return [0, alarm_precision, level_bits$0, capacity];
   }
   function microsecond_precision(param){
    return create(0, [0, create_exn(0, _t_)], about_one_microsecond, 0);
   }
   function durations(t){
    function _e8_(num_bits_accum, level_num_bits){
     var
      num_bits_accum$0 =
        num_bits_accum + caml_call1(to_int, level_num_bits) | 0,
      _e__ =
        caml_call2(Core[90], num_bits_accum$0, Core_Int63[61] - 1 | 0)
         ? Core_Int63[62]
         : caml_call2(Core_Int63[50], Core_Int63[17], num_bits_accum$0),
      duration = caml_call1(Core_Time_ns[1][137], _e__);
     return [0, num_bits_accum$0, duration];
    }
    var _e9_ = caml_call1(to_int, num_key_bits(t[1]));
    return caml_call3(Core_List[90], t[2], _e9_, _e8_);
   }
   var compare$0 = Core_Int63[114], sexp_of_t$4 = Core_Int63[103];
   function create$0(level_bits){
    var _e6_ = Core_Int63[17], _e7_ = pow2(level_bits);
    return caml_call2(Core_Int63[20], _e7_, _e6_);
   }
   function num_keys(num_bits){return pow2(num_bits);}
   var
    one = Core_Int63[17],
    symbol$4 = Core_Int63[20],
    bit_not = Core_Int63[48],
    sexp_of_t$5 = Core_Int63[103],
    equal$1 = Core_Int63[113];
   function create$1(bits_per_slot){
    return caml_call1(bit_not, caml_call2(symbol$4, pow2(bits_per_slot), one));
   }
   var
    to_int_exn = Core_Int63[5],
    zero$0 = Core_Int63[16],
    one$0 = Core_Int63[17],
    symbol$5 = Core_Int63[19],
    symbol$6 = Core_Int63[21],
    succ = Core_Int63[42],
    pred = Core_Int63[43],
    max_value = Core_Int63[62],
    of_int$0 = Core_Int63[72],
    sexp_of_t$6 = Core_Int63[103],
    symbol$7 = Core_Int63[107],
    symbol$8 = Core_Int63[108],
    symbol$9 = Core_Int63[109],
    symbol$10 = Core_Int63[110],
    symbol$11 = Core_Int63[111],
    symbol$12 = Core_Int63[112],
    equal$2 = Core_Int63[113],
    compare$1 = Core_Int63[114],
    min = Core_Int63[115],
    max = Core_Int63[116],
    ascending = Core_Int63[117],
    descending = Core_Int63[118],
    between = Core_Int63[119],
    clamp_exn = Core_Int63[120],
    clamp = Core_Int63[121],
    Replace_polymorphic_compare = Core_Int63[122],
    comparator = Core_Int63[123],
    Map = Core_Int63[124],
    Set = Core_Int63[125],
    validate_lbound = Core_Int63[132],
    validate_ubound = Core_Int63[133],
    validate_bound = Core_Int63[134];
   function to_int63(t){return t;}
   function of_int63(i){return i;}
   function scale_int(t, i){
    return caml_call2(symbol$6, t, caml_call1(of_int$0, i));
   }
   var
    to_int_exn$0 = Core_Int63[5],
    zero$1 = Core_Int63[16],
    one$1 = Core_Int63[17],
    symbol$13 = Core_Int63[19],
    symbol$14 = Core_Int63[20],
    rem = Core_Int63[28],
    succ$0 = Core_Int63[42],
    pred$0 = Core_Int63[43],
    bit_and = Core_Int63[45],
    shift_right = Core_Int63[51],
    max_value$0 = Core_Int63[62],
    min_value$0 = Core_Int63[63],
    of_int$1 = Core_Int63[72],
    sexp_of_t$7 = Core_Int63[103],
    symbol$15 = Core_Int63[107],
    symbol$16 = Core_Int63[108],
    symbol$17 = Core_Int63[109],
    symbol$18 = Core_Int63[110],
    symbol$19 = Core_Int63[111],
    symbol$20 = Core_Int63[112],
    equal$3 = Core_Int63[113],
    compare$2 = Core_Int63[114],
    min$0 = Core_Int63[115],
    max$0 = Core_Int63[116],
    ascending$0 = Core_Int63[117],
    descending$0 = Core_Int63[118],
    between$0 = Core_Int63[119],
    clamp_exn$0 = Core_Int63[120],
    clamp$0 = Core_Int63[121],
    Replace_polymorphic_compare$0 = Core_Int63[122],
    comparator$0 = Core_Int63[123],
    Map$0 = Core_Int63[124],
    Set$0 = Core_Int63[125],
    hash_fold_t = Core_Int63[126],
    hash = Core_Int63[127],
    hashable = Core_Int63[128],
    Table = Core_Int63[129],
    Hash_set = Core_Int63[130],
    Hash_queue = Core_Int63[131],
    validate_lbound$0 = Core_Int63[132],
    validate_ubound$0 = Core_Int63[133],
    validate_bound$0 = Core_Int63[134];
   function of_int63$0(i){return i;}
   function to_int63$0(t){return t;}
   function add(t, i){return caml_call2(symbol$13, t, i);}
   function add_clamp_to_max(t, i){
    return caml_call2(symbol$18, t, caml_call2(symbol$14, max_value$0, i))
            ? max_value$0
            : caml_call2(symbol$13, t, i);
   }
   function sub(t, i){return caml_call2(symbol$14, t, i);}
   function diff(t1, t2){return caml_call2(symbol$14, t1, t2);}
   function min_key_in_same_slot(t, min_key_in_same_slot_mask){return caml_call2(bit_and, t, min_key_in_same_slot_mask);
   }
   var
    _w_ = Set$0[2],
    _x_ = Set$0[1],
    _z_ = Map$0[2],
    _A_ = Map$0[1],
    _C_ = Set[2],
    _D_ = Set[1],
    _E_ = Map[2],
    _F_ = Map[1],
    _G_ =
      [0,
       sexp_of_t$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       equal$2,
       compare$1,
       min,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       Replace_polymorphic_compare,
       [0,
        [0, _F_[9], _F_[10], _F_[11]],
        [0, _E_[9], _E_[10], _E_[11], _E_[12], _E_[13]],
        Map[3],
        Map[4],
        Map[5],
        Map[6],
        Map[7],
        Map[8],
        Map[9],
        Map[10],
        Map[11],
        Map[12],
        Map[13],
        Map[14],
        Map[15],
        Map[16],
        Map[17],
        Map[18],
        Map[19],
        Map[20],
        Map[21],
        Map[22],
        Map[23],
        Map[24],
        Map[25],
        Map[26],
        Map[27],
        Map[28],
        Map[29],
        Map[30],
        Map[31],
        Map[32],
        Map[33],
        Map[34],
        Map[35],
        Map[36],
        Map[37],
        Map[38],
        Map[39],
        Map[40],
        Map[41],
        Map[42],
        Map[43],
        Map[44],
        Map[45]],
       [0,
        [0, _D_[1], _D_[2], _D_[11]],
        [0, _C_[9], _C_[10], _C_[11], _C_[12], _C_[13]],
        Set[3],
        Set[4],
        Set[5],
        Set[6],
        Set[7],
        Set[8],
        Set[9],
        Set[10],
        Set[11],
        Set[12],
        Set[13],
        Set[14],
        Set[15],
        Set[16],
        Set[17],
        Set[18],
        Set[19],
        Set[20],
        Set[21],
        Set[22],
        Set[23],
        Set[24],
        Set[25],
        Set[26],
        Set[27],
        Set[28]],
       max,
       zero$0,
       one$0,
       max_value,
       of_int63,
       to_int63,
       of_int$0,
       to_int_exn,
       scale_int,
       pred,
       succ,
       symbol$5],
    _u_ =
      [0,
       Hash_set[1],
       Hash_set[2],
       Hash_set[3],
       Hash_set[4],
       Hash_set[5],
       Hash_set[6],
       Hash_set[7]],
    _v_ =
      [0,
       Table[1],
       Table[2],
       Table[3],
       Table[4],
       Table[5],
       Table[6],
       Table[7],
       Table[8],
       Table[9],
       Table[10],
       Table[11],
       Table[12],
       Table[13],
       Table[14],
       Table[15],
       Table[16],
       Table[17],
       Table[18]],
    _y_ =
      [0,
       [0, _x_[1], _x_[2], _x_[11]],
       [0, _w_[9], _w_[10], _w_[11], _w_[12], _w_[13]],
       Set$0[3],
       Set$0[4],
       Set$0[5],
       Set$0[6],
       Set$0[7],
       Set$0[8],
       Set$0[9],
       Set$0[10],
       Set$0[11],
       Set$0[12],
       Set$0[13],
       Set$0[14],
       Set$0[15],
       Set$0[16],
       Set$0[17],
       Set$0[18],
       Set$0[19],
       Set$0[20],
       Set$0[21],
       Set$0[22],
       Set$0[23],
       Set$0[24],
       Set$0[25],
       Set$0[26],
       Set$0[27],
       Set$0[28]],
    _B_ =
      [0,
       [0, _A_[9], _A_[10], _A_[11]],
       [0, _z_[9], _z_[10], _z_[11], _z_[12], _z_[13]],
       Map$0[3],
       Map$0[4],
       Map$0[5],
       Map$0[6],
       Map$0[7],
       Map$0[8],
       Map$0[9],
       Map$0[10],
       Map$0[11],
       Map$0[12],
       Map$0[13],
       Map$0[14],
       Map$0[15],
       Map$0[16],
       Map$0[17],
       Map$0[18],
       Map$0[19],
       Map$0[20],
       Map$0[21],
       Map$0[22],
       Map$0[23],
       Map$0[24],
       Map$0[25],
       Map$0[26],
       Map$0[27],
       Map$0[28],
       Map$0[29],
       Map$0[30],
       Map$0[31],
       Map$0[32],
       Map$0[33],
       Map$0[34],
       Map$0[35],
       Map$0[36],
       Map$0[37],
       Map$0[38],
       Map$0[39],
       Map$0[40],
       Map$0[41],
       Map$0[42],
       Map$0[43],
       Map$0[44],
       Map$0[45]];
   function sexp_of_pool_slots(of_a_033, x_034){
    function _e0_(_e5_){return sexp_of_pool_slots(of_a_033, _e5_);}
    var _e1_ = caml_call1(Tuple_pool[36][3][1], _e0_);
    function _e2_(_e4_){return sexp_of_pool_slots(of_a_033, _e4_);}
    var _e3_ = caml_call1(Tuple_pool[36][3][1], _e2_);
    return caml_call7
            (Tuple_pool[36][1][8],
             sexp_of_t$7,
             Core_Time_ns_alternate_sexp[98],
             of_a_033,
             Core[389],
             _e3_,
             _e1_,
             x_034);
   }
   function sexp_of_t$8(of_a_035, x_036){
    function _eY_(_eZ_){return sexp_of_pool_slots(of_a_035, _eZ_);}
    return caml_call2(Tuple_pool[36][3][1], _eY_, x_036);
   }
   var
    null$0 = Tuple_pool[36][3][4],
    null$1 = Tuple_pool[36][3][4],
    is_null = Tuple_pool[36][3][5],
    free = Tuple_pool[36][14];
   function key(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][3]);
   }
   function at(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][4]);
   }
   function value(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][5]);
   }
   function level_index(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][6]);
   }
   function prev(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][7]);
   }
   function set_prev(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][7], x);
   }
   function next(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][8]);
   }
   function set_next(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][8], x);
   }
   function is_valid(p, t){return caml_call2(Tuple_pool[36][6], p, t);}
   var grow = Tuple_pool[36][12], is_full = Tuple_pool[36][13];
   function of_external_exn(pool, t){
    if(is_valid(pool, t)) return t;
    var
     _eX_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_got_invalid_a);
    return caml_call1(Core[261], _eX_);
   }
   function link(pool, prev, next){
    set_next(pool, prev, next);
    return set_prev(pool, next, prev);
   }
   function iter(pool, first, f){
    var current = [0, first], continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return 0;
     var next$0 = next(pool, current[1]);
     caml_call1(f, current[1]);
     if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
    }
   }
   function min_alarm_time(pool, first, with_key){
    var
     min_alarm_time = [0, Core_Time_ns_alternate_sexp[37]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return min_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _eV_ = min_alarm_time[1], _eW_ = at(pool, current[1]);
      min_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[108], _eW_, _eV_);
     }
     if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
    }
   }
   function slots(r){return r[11];}
   function max_allowed_key(r){return r[10];}
   function set_max_allowed_key(r, v){r[10] = v; return 0;}
   function min_allowed_key(r){return r[9];}
   function set_min_allowed_key(r, v){r[9] = v; return 0;}
   function length(r){return r[8];}
   function set_length(r, v){r[8] = v; return 0;}
   function diff_max_min_allowed_key(r){return r[7];}
   function min_key_in_same_slot_mask(r){return r[6];}
   function keys_per_slot(r){return r[5];}
   function bits_per_slot(r){return r[4];}
   function slots_mask(r){return r[3];}
   function bits(r){return r[2];}
   function index(r){return r[1];}
   function _M_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], v];
   }
   var
    _N_ = 0,
    slots$0 = [0, function(param){return 0;}, cst_slots, _N_, slots, _M_];
   function _O_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], v, r[11]];
   }
   var
    _P_ = [0, set_max_allowed_key],
    max_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_key,
       _P_,
       max_allowed_key,
       _O_];
   function _Q_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11]];
   }
   var
    _R_ = [0, set_min_allowed_key],
    min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_min_allowed_key,
       _R_,
       min_allowed_key,
       _Q_];
   function _S_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11]];
   }
   var
    _T_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _T_, length, _S_];
   function _U_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _V_ = 0,
    diff_max_min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_diff_max_min_allowed_key,
       _V_,
       diff_max_min_allowed_key,
       _U_];
   function _W_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _X_ = 0,
    min_key_in_same_slot_mask$0 =
      [0,
       function(param){return 0;},
       cst_min_key_in_same_slot_mask,
       _X_,
       min_key_in_same_slot_mask,
       _W_];
   function _Y_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _Z_ = 0,
    keys_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_keys_per_slot,
       _Z_,
       keys_per_slot,
       _Y_];
   function ___(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _$_ = 0,
    bits_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_bits_per_slot,
       _$_,
       bits_per_slot,
       ___];
   function _aa_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _ab_ = 0,
    slots_mask$0 =
      [0, function(param){return 0;}, cst_slots_mask, _ab_, slots_mask, _aa_];
   function _ac_(r, v){
    return [0,
            r[1],
            v,
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _ad_ = 0,
    bits$0 = [0, function(param){return 0;}, cst_bits, _ad_, bits, _ac_];
   function _ae_(r, v){
    return [0,
            v,
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _af_ = 0,
    index$0 = [0, function(param){return 0;}, cst_index, _af_, index, _ae_];
   function sexp_of_t$9(of_a_044, param){
    var
     diff_max_min_allowed_key_058 = param[7],
     min_key_in_same_slot_mask_056 = param[6],
     keys_per_slot_054 = param[5],
     bits_per_slot_052 = param[4],
     slots_mask_050 = param[3],
     bits_048 = param[2],
     index_046 = param[1],
     length_060 = param[8],
     min_allowed_key_062 = param[9],
     max_allowed_key_064 = param[10],
     slots_066 = param[11],
     arg_067 = caml_call1(Sexplib0_Sexp_conv[23], slots_066),
     bnds_045 = [0, [1, [0, _ag_, [0, arg_067, 0]]], 0],
     arg_065 = caml_call1(sexp_of_t$7, max_allowed_key_064),
     bnds_045$0 = [0, [1, [0, _ah_, [0, arg_065, 0]]], bnds_045],
     arg_063 = caml_call1(sexp_of_t$7, min_allowed_key_062),
     bnds_045$1 = [0, [1, [0, _ai_, [0, arg_063, 0]]], bnds_045$0],
     arg_061 = caml_call1(Core[389], length_060),
     bnds_045$2 = [0, [1, [0, _aj_, [0, arg_061, 0]]], bnds_045$1],
     arg_059 = caml_call1(_G_[1], diff_max_min_allowed_key_058),
     bnds_045$3 = [0, [1, [0, _ak_, [0, arg_059, 0]]], bnds_045$2],
     arg_057 = caml_call1(sexp_of_t$5, min_key_in_same_slot_mask_056),
     bnds_045$4 = [0, [1, [0, _al_, [0, arg_057, 0]]], bnds_045$3],
     arg_055 = caml_call1(_G_[1], keys_per_slot_054),
     bnds_045$5 = [0, [1, [0, _am_, [0, arg_055, 0]]], bnds_045$4],
     arg_053 = caml_call1(sexp_of_t, bits_per_slot_052),
     bnds_045$6 = [0, [1, [0, _an_, [0, arg_053, 0]]], bnds_045$5],
     arg_051 = caml_call1(sexp_of_t$4, slots_mask_050),
     bnds_045$7 = [0, [1, [0, _ao_, [0, arg_051, 0]]], bnds_045$6],
     arg_049 = caml_call1(sexp_of_t, bits_048),
     bnds_045$8 = [0, [1, [0, _ap_, [0, arg_049, 0]]], bnds_045$7],
     arg_047 = caml_call1(Core[389], index_046),
     bnds_045$9 = [0, [1, [0, _aq_, [0, arg_047, 0]]], bnds_045$8];
    return [1, bnds_045$9];
   }
   function slot(t, key){
    var slots_mask = t[3], bits_per_slot = t[4];
    return caml_call1
            (to_int_exn$0,
             caml_call2
              (bit_and,
               caml_call2(shift_right, key, bits_per_slot),
               slots_mask));
   }
   function next_slot(t, slot){
    var t$0 = t[3];
    return (slot + 1 | 0) & caml_call1(Core_Int63[5], t$0);
   }
   function min_key_in_same_slot$0(t, key){
    return min_key_in_same_slot(key, t[6]);
   }
   function compute_min_allowed_key(t, prev_level_max_allowed_key){
    return caml_call2(equal$3, prev_level_max_allowed_key, max_value$0)
            ? max_value$0
            : min_key_in_same_slot$0
              (t, caml_call1(succ$0, prev_level_max_allowed_key));
   }
   function levels(r){return r[5];}
   function elt_key_lower_bound(r){return r[4];}
   function set_elt_key_lower_bound(r, v){r[4] = v; return 0;}
   function min_elt(r){return r[3];}
   function set_min_elt(r, v){r[3] = v; return 0;}
   function pool(r){return r[2];}
   function set_pool(r, v){r[2] = v; return 0;}
   function length$1(r){return r[1];}
   function set_length$0(r, v){r[1] = v; return 0;}
   function _ar_(r, v){return [0, r[1], r[2], r[3], r[4], v];}
   var
    _as_ = 0,
    levels$0 = [0, function(param){return 0;}, cst_levels, _as_, levels, _ar_];
   function _at_(r, v){return [0, r[1], r[2], r[3], v, r[5]];}
   var
    _au_ = [0, set_elt_key_lower_bound],
    elt_key_lower_bound$0 =
      [0,
       function(param){return 0;},
       cst_elt_key_lower_bound,
       _au_,
       elt_key_lower_bound,
       _at_];
   function _av_(r, v){return [0, r[1], r[2], v, r[4], r[5]];}
   var
    _aw_ = [0, set_min_elt],
    min_elt$0 =
      [0, function(param){return 0;}, cst_min_elt, _aw_, min_elt, _av_];
   function _ax_(r, v){return [0, r[1], v, r[3], r[4], r[5]];}
   var
    _ay_ = [0, set_pool],
    pool$0 = [0, function(param){return 0;}, cst_pool, _ay_, pool, _ax_];
   function _az_(r, v){return [0, v, r[2], r[3], r[4], r[5]];}
   var
    _aA_ = [0, set_length$0],
    length$2 =
      [0, function(param){return 0;}, cst_length$0, _aA_, length$1, _az_];
   function is_empty(t){return caml_call2(Core[90], t[1], 0);}
   function num_levels(t){return t[5].length - 1;}
   function min_allowed_key$1(t){return caml_check_bound(t[5], 0)[1][9];}
   function max_allowed_key$1(t){
    var _eU_ = num_levels(t) - 1 | 0;
    return caml_check_bound(t[5], _eU_)[1 + _eU_][10];
   }
   function internal_iter(t, f){
    var _eM_ = caml_call2(Core[91], t[1], 0);
    if(_eM_){
     var
      pool = t[2],
      levels = t[5],
      _eO_ = levels.length - 1 - 1 | 0,
      _eN_ = 0;
     if(_eO_ >= 0){
      var level_index = _eN_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[91], level[8], 0)){
        var slots = level[11], _eR_ = slots.length - 1 - 1 | 0, _eQ_ = 0;
        if(_eR_ >= 0){
         var slot_index = _eQ_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)) iter(pool, elt, f);
          var _eT_ = slot_index + 1 | 0;
          if(_eR_ === slot_index) break;
          var slot_index = _eT_;
         }
        }
       }
       var _eS_ = level_index + 1 | 0;
       if(_eO_ === level_index) break;
       var level_index = _eS_;
      }
     }
     var _eP_ = 0;
    }
    else
     var _eP_ = _eM_;
    return _eP_;
   }
   function compute_diff_max_min_allowed_k(level_bits, bits_per_slot){
    var bits = symbol$2(level_bits, bits_per_slot);
    if(caml_call2(equal, bits, max_num_bits)) return _G_[26];
    var _eL_ = num_keys(bits);
    return caml_call1(_G_[32], _eL_);
   }
   function min_elt$1(t){
    if(is_empty(t)) return caml_call1(null$1, 0);
    if(! caml_call1(is_null, t[3])) return t[3];
    var
     pool = t[2],
     min_elt_already_found = [0, caml_call1(null$1, 0)],
     min_key_already_found = [0, max_value$0],
     level_index = [0, 0],
     num_levels$0 = num_levels(t);
    for(;;){
     if(! caml_call2(Core[92], level_index[1], num_levels$0)){
      t[3] = min_elt_already_found[1];
      t[4] = min_key_already_found[1];
      return t[3];
     }
     var
      _eI_ = level_index[1],
      level = caml_check_bound(t[5], _eI_)[1 + _eI_];
     if(caml_call2(symbol$18, level[9], min_key_already_found[1]))
      level_index[1] = num_levels$0;
     else if(caml_call2(Core[90], level[8], 0))
      level_index[1]++;
     else{
      var
       slots = level[11],
       slot_min_key =
         [0, min_key_in_same_slot$0(level, caml_call2(max$0, level[9], t[4]))],
       slot$0 = [0, slot(level, slot_min_key[1])];
      for(;;){
       var _eJ_ = slot$0[1];
       if(! caml_call1(is_null, caml_check_bound(slots, _eJ_)[1 + _eJ_]))
        break;
       if(! caml_call2(symbol$19, slot_min_key[1], min_key_already_found[1]))
        break;
       slot$0[1] = next_slot(level, slot$0[1]);
       slot_min_key[1] = add(slot_min_key[1], level[5]);
      }
      var _eK_ = slot$0[1], first = caml_check_bound(slots, _eK_)[1 + _eK_];
      if(1 - caml_call1(is_null, first)){
       var continue$0 = [0, 1], current = [0, first];
       for(;;){
        if(! continue$0[1]) break;
        var current_key = key(pool, current[1]);
        if(caml_call2(symbol$16, current_key, min_key_already_found[1])){
         min_elt_already_found[1] = current[1];
         min_key_already_found[1] = current_key;
        }
        var next$0 = next(pool, current[1]);
        a:
        {
         if(next$0 !== first && ! caml_call2(Core[90], level_index[1], 0)){current[1] = next$0; break a;}
         continue$0[1] = 0;
        }
       }
      }
      level_index[1]++;
     }
    }
   }
   function add_elt(x_114, to_add){
    var
     pool$0 = x_114[2],
     key$0 = key(pool$0, to_add),
     _eB_ = caml_call2(symbol$15, key$0, min_allowed_key$1(x_114)),
     _eC_ =
       _eB_ ? caml_call2(symbol$16, key$0, max_allowed_key$1(x_114)) : _eB_;
    if(1 - _eC_){
     var pool = x_114[2], r = [0, 0], _eq_ = 0, _er_ = 0;
     internal_iter
      (x_114,
       function(elt){
        var _eG_ = r[1], _eH_ = value(pool, elt);
        r[1] = [0, [0, key(pool, elt), _eH_], _eG_];
        return 0;
       });
     var
      elts_094 = caml_call1(Core_List[59], r[1]),
      max_allowed_key_092 = max_allowed_key$1(x_114),
      min_allowed_key_090 = min_allowed_key$1(x_114),
      bnds_089 = 0,
      _ep_ =
        function(param){
         var
          key_084 = param[1],
          bnds_083 = [0, [1, [0, _aG_, [0, arg_087, 0]]], 0],
          arg_085 = caml_call1(sexp_of_t$7, key_084),
          bnds_083$0 = [0, [1, [0, _aH_, [0, arg_085, 0]]], bnds_083];
         return [1, bnds_083$0];
        },
      arg_095 = caml_call2(Core[472], _ep_, elts_094),
      bnds_089$0 = [0, [1, [0, _aI_, [0, arg_095, 0]]], bnds_089],
      arg_093 = caml_call1(sexp_of_t$7, max_allowed_key_092),
      bnds_089$1 = [0, [1, [0, _aJ_, [0, arg_093, 0]]], bnds_089$0],
      arg_091 = caml_call1(sexp_of_t$7, min_allowed_key_090),
      bnds_089$2 = [0, [1, [0, _aK_, [0, arg_091, 0]]], bnds_089$1],
      _es_ =
        [0,
         [1,
          [0, _a__, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(x_114)), 0]]],
         [0, [1, [0, _a9_, [0, [1, bnds_089$2], _er_]]], _eq_]],
      _et_ =
        [0,
         [1,
          [0, _a$_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(x_114)), 0]]],
         _es_],
      _eu_ = [0, [1, [0, _ba_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _et_],
      _ev_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key),
          _eu_]];
     caml_call1(Core[261], _ev_);
    }
    var level_index = [0, 0];
    for(;;){
     var _eD_ = level_index[1];
     if
      (!
       caml_call2
        (symbol$18, key$0, caml_check_bound(x_114[5], _eD_)[1 + _eD_][10]))
      break;
     level_index[1]++;
    }
    var
     level_index$0 = level_index[1],
     level = caml_check_bound(x_114[5], level_index$0)[1 + level_index$0],
     _eE_ = caml_call2(symbol$15, key$0, level[9]),
     _eF_ = _eE_ ? caml_call2(symbol$16, key$0, level[10]) : _eE_;
    if(1 - _eF_){
     var
      _ew_ = 0,
      _ex_ = 0,
      _ey_ =
        [0,
         [1,
          [0,
           _bc_,
           [0, sexp_of_t$9(function(param){return _bb_;}, level), _ex_]]],
         _ew_],
      _ez_ = [0, [1, [0, _bd_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _ey_],
      _eA_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key$0),
          _ez_]];
     caml_call1(Core[261], _eA_);
    }
    level[8] = level[8] + 1 | 0;
    caml_call4
     (Tuple_pool[36][33], pool$0, to_add, Tuple_pool[36][2][6], level_index$0);
    var
     slot$0 = slot(level, key$0),
     slots = level[11],
     first = caml_check_bound(slots, slot$0)[1 + slot$0];
    if(caml_call1(is_null, first)){
     caml_check_bound(slots, slot$0)[1 + slot$0] = to_add;
     return link(pool$0, to_add, to_add);
    }
    var prev$0 = prev(pool$0, first);
    link(pool$0, prev$0, to_add);
    return link(pool$0, to_add, first);
   }
   function internal_add_elt(t, elt){
    var key$0 = key(t[2], elt);
    if(caml_call2(symbol$19, key$0, t[4])){t[3] = elt; t[4] = key$0;}
    add_elt(t, elt);
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function ensure_valid_key(t, key){
    var
     _en_ = caml_call2(symbol$19, key, min_allowed_key$1(t)),
     _eo_ = _en_ || caml_call2(symbol$18, key, max_allowed_key$1(t));
    if(! _eo_) return _eo_;
    var
     _ej_ =
       [0,
        [1, [0, _be_, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(t)), 0]]],
        0],
     _ek_ =
       [0,
        [1, [0, _bf_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(t)), 0]]],
        _ej_],
     _el_ = [0, [1, [0, _bg_, [0, caml_call1(sexp_of_t$7, key), 0]]], _ek_],
     _em_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_add_at_interv),
         _el_]];
    return caml_call1(Core[261], _em_);
   }
   function internal_add(t, key, at, value){
    ensure_valid_key(t, key);
    if(caml_call1(is_full, t[2])) t[2] = caml_call2(grow, 0, t[2]);
    var
     pool = t[2],
     _eh_ = caml_call1(null$1, 0),
     _ei_ = caml_call1(null$1, 0),
     elt =
       caml_call7(Tuple_pool[36][21], pool, key, at, value, -1, _ei_, _eh_);
    internal_add_elt(t, elt);
    return elt;
   }
   function internal_remove(t, elt){
    var pool = t[2], t2 = t[3];
    if(caml_call2(Tuple_pool[36][3][7], elt, t2))
     t[3] = caml_call1(null$1, 0);
    t[1] = t[1] - 1 | 0;
    var
     _ee_ = level_index(pool, elt),
     level = caml_check_bound(t[5], _ee_)[1 + _ee_];
    level[8] = level[8] - 1 | 0;
    var
     slots = level[11],
     slot$0 = slot(level, key(pool, elt)),
     first = caml_check_bound(slots, slot$0)[1 + slot$0];
    if(elt === next(pool, elt)){
     var _ef_ = caml_call1(null$1, 0);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _ef_;
     return;
    }
    if(elt === first){
     var _eg_ = next(pool, elt);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _eg_;
    }
    var _ec_ = next(pool, elt);
    set_next(pool, prev(pool, elt), _ec_);
    var _ed_ = prev(pool, elt);
    return set_prev(pool, next(pool, elt), _ed_);
   }
   var
    _bh_ =
      [0,
       _G_,
       sexp_of_t$7,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       symbol$19,
       symbol$20,
       equal$3,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       validate_lbound$0,
       validate_ubound$0,
       validate_bound$0,
       Replace_polymorphic_compare$0,
       _B_,
       _y_,
       compare$2,
       hash_fold_t,
       hash,
       hashable,
       _v_,
       _u_,
       Hash_queue,
       max$0,
       min$0,
       zero$1,
       one$1,
       min_value$0,
       max_value$0,
       of_int63$0,
       to_int63$0,
       of_int$1,
       to_int_exn$0,
       add,
       sub,
       diff,
       succ$0,
       pred$0,
       rem],
    min_interval_num = _bh_[31];
   function priority_queue(r){return r[7];}
   function max_allowed_alarm_time(r){return r[6];}
   function set_max_allowed_alarm_time(r, v){r[6] = v; return 0;}
   function now_interval_num_start(r){return r[5];}
   function set_now_interval_num_start(r, v){r[5] = v; return 0;}
   function now(r){return r[4];}
   function set_now(r, v){r[4] = v; return 0;}
   function max_interval_num(r){return r[3];}
   function start(r){return r[2];}
   function config(r){return r[1];}
   function _bi_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], r[6], v];}
   var
    _bj_ = 0,
    priority_queue$0 =
      [0,
       function(param){return 0;},
       cst_priority_queue,
       _bj_,
       priority_queue,
       _bi_];
   function _bk_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}
   var
    _bl_ = [0, set_max_allowed_alarm_time],
    max_allowed_alarm_time$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_alarm_time,
       _bl_,
       max_allowed_alarm_time,
       _bk_];
   function _bm_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6], r[7]];}
   var
    _bn_ = [0, set_now_interval_num_start],
    now_interval_num_start$0 =
      [0,
       function(param){return 0;},
       cst_now_interval_num_start,
       _bn_,
       now_interval_num_start,
       _bm_];
   function _bo_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}
   var
    _bp_ = [0, set_now],
    now$0 = [0, function(param){return 0;}, cst_now, _bp_, now, _bo_];
   function _bq_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6], r[7]];}
   var
    _br_ = 0,
    max_interval_num$0 =
      [0,
       function(param){return 0;},
       cst_max_interval_num,
       _br_,
       max_interval_num,
       _bq_];
   function _bs_(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6], r[7]];}
   var
    _bt_ = 0,
    start$0 = [0, function(param){return 0;}, cst_start, _bt_, start, _bs_];
   function _bu_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6], r[7]];}
   var
    _bv_ = 0,
    config$0 = [0, function(param){return 0;}, cst_config, _bv_, config, _bu_];
   function sexp_of_t_now(param, t){
    return caml_call1(Core_Time_ns_alternate_sexp[98], t[4]);
   }
   function alarm_precision$0(t){return alarm_precision(t[1]);}
   function at$0(tw, t){
    var p = tw[7], _eb_ = of_external_exn(p[2], t);
    return at(p[2], _eb_);
   }
   function value$0(tw, t){
    var p = tw[7], _ea_ = of_external_exn(p[2], t);
    return value(p[2], _ea_);
   }
   function interval_num(tw, t){
    var p = tw[7], _d$_ = of_external_exn(p[2], t);
    return key(p[2], _d$_);
   }
   function iter$0(t, f){var t$0 = t[7]; return internal_iter(t$0, f);}
   function compare$3(t1, t2){
    return caml_call2(Core_Time_ns_alternate_sexp[107], t1[1], t2[1]);
   }
   function sexp_of_t$10(sexp_of_a, t){
    var
     max_interval_num_146 = t[3],
     start_144 = t[2],
     config_142 = t[1],
     now_148 = t[4],
     r = [0, 0];
    iter$0
     (t,
      function(alarm){
       var _d__ = r[1], _d9_ = value$0(t, alarm);
       r[1] = [0, [0, at$0(t, alarm), _d9_], _d__];
       return 0;
      });
    var alarms_150 = caml_call2(Core_List[79], r[1], compare$3), bnds_141 = 0;
    function _d8_(param){
     var
      value_138 = param[2],
      at_136 = param[1],
      arg_139 = caml_call1(sexp_of_a, value_138),
      bnds_135 = [0, [1, [0, _bw_, [0, arg_139, 0]]], 0],
      arg_137 = caml_call1(Core_Time_ns_alternate_sexp[98], at_136),
      bnds_135$0 = [0, [1, [0, _bx_, [0, arg_137, 0]]], bnds_135];
     return [1, bnds_135$0];
    }
    var
     arg_151 = caml_call2(Core[472], _d8_, alarms_150),
     bnds_141$0 = [0, [1, [0, _by_, [0, arg_151, 0]]], bnds_141],
     arg_149 = caml_call1(Core_Time_ns_alternate_sexp[98], now_148),
     bnds_141$1 = [0, [1, [0, _bz_, [0, arg_149, 0]]], bnds_141$0],
     arg_147 = caml_call1(_bh_[2], max_interval_num_146),
     bnds_141$2 = [0, [1, [0, _bA_, [0, arg_147, 0]]], bnds_141$1],
     arg_145 = caml_call1(Core_Time_ns_alternate_sexp[98], start_144),
     bnds_141$3 = [0, [1, [0, _bB_, [0, arg_145, 0]]], bnds_141$2],
     arg_143 = sexp_of_t$3(config_142),
     bnds_141$4 = [0, [1, [0, _bC_, [0, arg_143, 0]]], bnds_141$3];
    return [1, bnds_141$4];
   }
   function length$3(t){return t[7][1];}
   function is_empty$0(t){
    var _d7_ = length$3(t);
    return caml_call2(Core[90], _d7_, 0);
   }
   function pool$1(t){return t[7][2];}
   function interval_num_internal(time, alarm_precision){
    var
     _d5_ = caml_call1(Core_Time_ns_alternate_sexp[53], time),
     _d6_ = caml_call2(Core_Int63[51], _d5_, alarm_precision);
    return caml_call1(_bh_[35], _d6_);
   }
   function interval_num_unchecked(t, time){
    return interval_num_internal(time, t[1][1]);
   }
   function interval_num$0(t, time){
    if(caml_call2(Core_Time_ns_alternate_sexp[104], time, min_time)){
     var
      _d3_ =
        [0,
         [1,
          [0, _bH_, [0, caml_call1(Core_Time_ns_alternate_sexp[98], time), 0]]],
         0],
      _d4_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_),
          _d3_]];
     caml_call1(Core[261], _d4_);
    }
    return interval_num_unchecked(t, time);
   }
   function interval_num_start_unchecked(t, interval_num){
    var
     interval_num$0 = caml_call1(_bh_[36], interval_num),
     t$0 = t[1][1],
     _d2_ = caml_call2(Core_Int63[50], interval_num$0, t$0);
    return caml_call1(Core_Time_ns_alternate_sexp[54], _d2_);
   }
   function interval_num_start(t, interval_num){
    if(caml_call2(_bh_[7], interval_num, min_interval_num)){
     var
      _dW_ =
        [0, [1, [0, _bI_, [0, caml_call1(_bh_[2], min_interval_num), 0]]], 0],
      _dX_ =
        [0, [1, [0, _bJ_, [0, caml_call1(_bh_[2], interval_num), 0]]], _dW_],
      _dY_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$0),
          _dX_]];
     caml_call1(Core[261], _dY_);
    }
    if(caml_call2(_bh_[6], interval_num, t[3])){
     var
      _dZ_ = [0, [1, [0, _bK_, [0, caml_call1(_bh_[2], t[3]), 0]]], 0],
      _d0_ =
        [0, [1, [0, _bL_, [0, caml_call1(_bh_[2], interval_num), 0]]], _dZ_],
      _d1_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$1),
          _d0_]];
     caml_call1(Core[261], _d1_);
    }
    return interval_num_start_unchecked(t, interval_num);
   }
   function next_alarm_fires_at_internal(t, key){
    return interval_num_start(t, caml_call1(_bh_[42], key));
   }
   function next_alarm_fires_at(t){
    var elt = min_elt$1(t[7]);
    if(caml_call1(is_null, elt)) return 0;
    var key$0 = key(pool$1(t), elt);
    return caml_call2(_bh_[9], key$0, t[3])
            ? 0
            : [0, next_alarm_fires_at_internal(t, key$0)];
   }
   function next_alarm_fires_at_exn(x_153){
    var elt = min_elt$1(x_153[7]);
    if(caml_call1(is_null, elt)){
     var
      _dO_ = 0,
      _dP_ = 0,
      _dQ_ =
        [0,
         [1,
          [0,
           _bE_,
           [0, sexp_of_t$10(function(param){return _bD_;}, x_153), _dP_]]],
         _dO_],
      _dR_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi),
          _dQ_]];
     caml_call1(Core[261], _dR_);
    }
    var key$0 = key(pool$1(x_153), elt);
    if(caml_call2(_bh_[9], key$0, x_153[3])){
     var
      _dS_ = 0,
      _dT_ = 0,
      _dU_ =
        [0,
         [1,
          [0,
           _bG_,
           [0, sexp_of_t$10(function(param){return _bF_;}, x_153), _dT_]]],
         _dS_],
      _dV_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi$0),
          _dU_]];
     caml_call1(Core[261], _dV_);
    }
    return next_alarm_fires_at_internal(x_153, key$0);
   }
   function compute_max_allowed_alarm_time(t){
    var max_allowed_key = max_allowed_key$1(t[7]);
    if(caml_call2(_bh_[3], max_allowed_key, t[3])) return max_time;
    var
     _dK_ = Core_Time_ns[1][68],
     _dL_ = alarm_precision$0(t),
     _dM_ = caml_call2(Core_Time_ns[1][102], _dL_, _dK_),
     _dN_ = interval_num_start_unchecked(t, max_allowed_key);
    return caml_call2(Core_Time_ns_alternate_sexp[43], _dN_, _dM_);
   }
   function now_interval_num(t){return min_allowed_key$1(t[7]);}
   function max_allowed_alarm_interval_num(t){return interval_num$0(t, t[6]);}
   function interval_start(t, time){
    return interval_num_start_unchecked(t, interval_num$0(t, time));
   }
   function invariant$2(invariant_a, t){
    function _c5_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      priority_queue_fun =
        check
         (function(t){
           var pool = t[2];
           function _de_(param){
            function check(f){return caml_call2(Base_Invariant[2], t, f);}
            if(! caml_call2(symbol$15, min_allowed_key$1(t), zero$1))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _a6_], 1);
            var _dk_ = min_allowed_key$1(t);
            if(! caml_call2(symbol$15, max_allowed_key$1(t), _dk_))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _a5_], 1);
            var
             levels_fun =
               check
                (function(levels){
                  var _dq_ = num_levels(t);
                  if(! caml_call2(Core[91], _dq_, 0))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _aY_], 1);
                  function _dr_(level_index$0, level){
                   if(! caml_call2(Core[90], level_index$0, level[1]))
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _aX_], 1);
                   function _ds_(param){
                    function check(f){
                     return caml_call2(Base_Invariant[2], level, f);
                    }
                    var
                     slots_fun =
                       check
                        (function(slots){
                          function _dz_(elt){
                           var _dC_ = 1 - caml_call1(is_null, elt);
                           if(! _dC_) return _dC_;
                           function _dA_(param){
                            if(! is_valid(pool, elt))
                             throw caml_maybe_attach_backtrace
                                    ([0, Assert_failure, _J_], 1);
                            caml_call1(invariant_a, value(pool, elt));
                            var n = next(pool, elt);
                            if(! caml_call1(is_null, n)){
                             var _dJ_ = prev(pool, n);
                             if(! caml_call2(Tuple_pool[36][3][7], elt, _dJ_))
                              throw caml_maybe_attach_backtrace
                                     ([0, Assert_failure, _I_], 1);
                            }
                            var p = prev(pool, elt);
                            if(! caml_call1(is_null, p)){
                             var _dI_ = next(pool, p);
                             if(! caml_call2(Tuple_pool[36][3][7], elt, _dI_))
                              throw caml_maybe_attach_backtrace
                                     ([0, Assert_failure, _H_], 1);
                            }
                            return 0;
                           }
                           function _dB_(x_041){
                            return sexp_of_t$8(function(param){return _K_;}, x_041);
                           }
                           caml_call4(Base_Invariant[1], _L_, elt, _dB_, _dA_);
                           return iter
                                   (pool,
                                    elt,
                                    function(elt){
                                     var _dD_ = level[9];
                                     if(! caml_call2(symbol$15, key(pool, elt), _dD_))
                                      throw caml_maybe_attach_backtrace
                                             ([0, Assert_failure, _aO_], 1);
                                     var _dE_ = level[10];
                                     if(! caml_call2(symbol$16, key(pool, elt), _dE_))
                                      throw caml_maybe_attach_backtrace
                                             ([0, Assert_failure, _aN_], 1);
                                     var _dF_ = t[4];
                                     if(! caml_call2(symbol$15, key(pool, elt), _dF_))
                                      throw caml_maybe_attach_backtrace
                                             ([0, Assert_failure, _aM_], 1);
                                     var _dG_ = level[1], _dH_ = level_index(pool, elt);
                                     if(caml_call2(Core[90], _dH_, _dG_))
                                      return caml_call1(invariant_a, value(pool, elt));
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _aL_], 1);
                                    });
                          }
                          return caml_call2(Core_Array[35], slots, _dz_);
                         }),
                     max_allowed_key_fun =
                       check
                        (function(max_allowed_key){
                          var
                           expect = add_clamp_to_max(level[9], level[7]),
                           equal = 0,
                           message = 0,
                           here = 0;
                          function comparator(a_107, b_108){
                           return caml_call2(compare$2, a_107, b_108);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos,
                                   sexp_of_t$7,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   max_allowed_key);
                         }),
                     min_allowed_key_fun =
                       check
                        (function(min_allowed_key){
                          if(! caml_call2(symbol$15, min_allowed_key, zero$1))
                           throw caml_maybe_attach_backtrace
                                  ([0, Assert_failure, _aP_], 1);
                          var
                           _dy_ = caml_call2(symbol$19, min_allowed_key, max_value$0);
                          if(! _dy_) return _dy_;
                          var
                           got = caml_call2(rem, min_allowed_key, level[5]),
                           expect = _G_[24],
                           sexpifier = _G_[1],
                           equal = 0,
                           message = 0,
                           here = 0;
                          function comparator(a_105, b_106){
                           return caml_call2(_G_[9], a_105, b_106);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$0,
                                   sexpifier,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   got);
                         }),
                     length_fun =
                       check
                        (function(length){
                          function _dw_(n, first){
                           if(caml_call1(is_null, first)) return n;
                           var r = [0, 0], current = [0, first], continue$0 = [0, 1];
                           for(;;){
                            if(! continue$0[1]) return n + r[1] | 0;
                            r[1]++;
                            var next$0 = next(pool, current[1]);
                            if(next$0 === first)
                             continue$0[1] = 0;
                            else
                             current[1] = next$0;
                           }
                          }
                          var _dx_ = caml_call3(Core_Array[36], level[11], 0, _dw_);
                          if(caml_call2(Core[90], length, _dx_)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aQ_], 1);
                         }),
                     expect = compute_diff_max_min_allowed_k(level[2], level[4]),
                     diff_max_min_allowed_key_fun =
                       check
                        (function(eta){
                          var sexpifier = _G_[1], equal = 0, message = 0, here = 0;
                          function comparator(a_103, b_104){
                           return caml_call2(_G_[9], a_103, b_104);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$1,
                                   sexpifier,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   eta);
                         }),
                     min_key_in_same_slot_mask_fun =
                       check
                        (function(min_key_in_same_slot_mask){
                          if
                           (caml_call2
                             (equal$1, min_key_in_same_slot_mask, create$1(level[4])))
                           return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aR_], 1);
                         }),
                     keys_per_slot_fun =
                       check
                        (function(keys_per_slot){
                          var
                           expect = num_keys(level[4]),
                           sexpifier = _G_[1],
                           equal = 0,
                           message = 0,
                           here = 0;
                          function comparator(a_101, b_102){
                           return caml_call2(_G_[9], a_101, b_102);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$2,
                                   sexpifier,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   keys_per_slot);
                         }),
                     bits_per_slot_fun =
                       check
                        (function(bits_per_slot){
                          if(caml_call2(symbol, bits_per_slot, zero)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aS_], 1);
                         }),
                     expect$0 = create$0(level[2]),
                     slots_mask_fun =
                       check
                        (function(eta){
                          var equal = 0, message = 0, here = 0;
                          function comparator(a_099, b_100){
                           return caml_call2(compare$0, a_099, b_100);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$3,
                                   sexp_of_t$4,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect$0,
                                   eta);
                         }),
                     bits_fun =
                       check
                        (function(bits){
                          if(caml_call2(symbol$1, bits, zero)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aT_], 1);
                         }),
                     index_fun =
                       check
                        (function(index){
                          if(caml_call2(Core[88], index, 0)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aU_], 1);
                         });
                    caml_call1(index_fun, index$0);
                    caml_call1(bits_fun, bits$0);
                    caml_call1(slots_mask_fun, slots_mask$0);
                    caml_call1(bits_per_slot_fun, bits_per_slot$0);
                    caml_call1(keys_per_slot_fun, keys_per_slot$0);
                    caml_call1
                     (min_key_in_same_slot_mask_fun, min_key_in_same_slot_mask$0);
                    caml_call1
                     (diff_max_min_allowed_key_fun, diff_max_min_allowed_key$0);
                    caml_call1(length_fun, length$0);
                    caml_call1(min_allowed_key_fun, min_allowed_key$0);
                    caml_call1(max_allowed_key_fun, max_allowed_key$0);
                    return caml_call1(slots_fun, slots$0);
                   }
                   function _dt_(x_098){
                    return sexp_of_t$9(function(param){return _aV_;}, x_098);
                   }
                   caml_call4(Base_Invariant[1], _aW_, level, _dt_, _ds_);
                   var _du_ = caml_call2(Core[91], level_index$0, 0);
                   if(! _du_) return _du_;
                   var
                    _dv_ = level_index$0 - 1 | 0,
                    prev_level = caml_check_bound(levels, _dv_)[1 + _dv_],
                    got = level[5],
                    expect = caml_call1(_G_[33], prev_level[7]),
                    sexpifier = _G_[1],
                    equal = 0,
                    message = 0,
                    here = 0;
                   function comparator(a_110, b_111){
                    return caml_call2(_G_[9], a_110, b_111);
                   }
                   caml_call8
                    (Ppx_assert_lib_Runtime[3],
                     pos$4,
                     sexpifier,
                     comparator,
                     here,
                     message,
                     equal,
                     expect,
                     got);
                   var
                    got$0 = level[9],
                    expect$0 = compute_min_allowed_key(level, prev_level[10]),
                    equal$0 = 0,
                    message$0 = 0,
                    here$0 = 0;
                   function comparator$0(a_112, b_113){
                    return caml_call2(compare$2, a_112, b_113);
                   }
                   return caml_call8
                           (Ppx_assert_lib_Runtime[3],
                            pos$5,
                            sexp_of_t$7,
                            comparator$0,
                            here$0,
                            message$0,
                            equal$0,
                            expect$0,
                            got$0);
                  }
                  return caml_call2(Core_Array[50], levels, _dr_);
                 }),
             elt_key_lower_bound_fun =
               check
                (function(elt_key_lower_bound){
                  if
                   (!
                    caml_call2
                     (symbol$15, elt_key_lower_bound, min_allowed_key$1(t)))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _a1_], 1);
                  if
                   (!
                    caml_call2
                     (symbol$16, elt_key_lower_bound, max_allowed_key$1(t)))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _a0_], 1);
                  var _dp_ = 1 - caml_call1(is_null, t[3]);
                  if(! _dp_) return _dp_;
                  if
                   (caml_call2(equal$3, elt_key_lower_bound, key(t[2], t[3])))
                   return 0;
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _aZ_], 1);
                 }),
             min_elt_fun =
               check
                (function(elt){
                  var _dn_ = 1 - caml_call1(is_null, elt);
                  if(! _dn_) return _dn_;
                  if(! is_valid(t[2], elt))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _a3_], 1);
                  var _do_ = key(t[2], elt);
                  if(caml_call2(equal$3, t[4], _do_)) return 0;
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _a2_], 1);
                 }),
             pool_fun =
               check
                (function(t){
                  function _dl_(_dm_){return 0;}
                  return caml_call2(Tuple_pool[36][5], _dl_, t);
                 }),
             length_fun =
               check
                (function(length){
                  if(caml_call2(Core[88], length, 0)) return 0;
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _a4_], 1);
                 });
            caml_call1(length_fun, length$2);
            caml_call1(pool_fun, pool$0);
            caml_call1(min_elt_fun, min_elt$0);
            caml_call1(elt_key_lower_bound_fun, elt_key_lower_bound$0);
            return caml_call1(levels_fun, levels$0);
           }
           function _df_(x_109){
            function of_a_068(param){return _a7_;}
            var
             length_070 = x_109[1],
             pool_072 = x_109[2],
             min_elt_074 = x_109[3],
             elt_key_lower_bound_076 = x_109[4],
             levels_078 = x_109[5],
             bnds_069 = 0;
            function _dh_(_dj_){return sexp_of_t$9(of_a_068, _dj_);}
            var
             arg_079 = caml_call2(Core[301], _dh_, levels_078),
             bnds_069$0 = [0, [1, [0, _aB_, [0, arg_079, 0]]], bnds_069],
             arg_077 = caml_call1(sexp_of_t$7, elt_key_lower_bound_076),
             bnds_069$1 = [0, [1, [0, _aC_, [0, arg_077, 0]]], bnds_069$0],
             arg_075 = sexp_of_t$8(of_a_068, min_elt_074),
             bnds_069$2 = [0, [1, [0, _aD_, [0, arg_075, 0]]], bnds_069$1];
            function _dg_(_di_){return sexp_of_pool_slots(of_a_068, _di_);}
            var
             arg_073 = caml_call2(Tuple_pool[36][4], _dg_, pool_072),
             bnds_069$3 = [0, [1, [0, _aE_, [0, arg_073, 0]]], bnds_069$2],
             arg_071 = caml_call1(Core[389], length_070),
             bnds_069$4 = [0, [1, [0, _aF_, [0, arg_071, 0]]], bnds_069$3];
            return [1, bnds_069$4];
           }
           return caml_call4(Base_Invariant[1], _a8_, t, _df_, _de_);
          }),
      max_allowed_alarm_time_fun =
        check
         (function(max_allowed_alarm_time){
           var
            expect = compute_max_allowed_alarm_time(t),
            sexpifier = Core_Time_ns_alternate_sexp[98],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_162, b_163){
            return caml_call2(Core_Time_ns_alternate_sexp[107], a_162, b_163);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$6,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    max_allowed_alarm_time);
          }),
      now_interval_num_start_fun =
        check
         (function(now_interval_num_start){
           var
            expect = interval_num_start(t, now_interval_num(t)),
            sexpifier = Core_Time_ns_alternate_sexp[98],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_160, b_161){
            return caml_call2(Core_Time_ns_alternate_sexp[107], a_160, b_161);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$7,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    now_interval_num_start);
          }),
      now_fun =
        check
         (function(now){
           if(! caml_call2(Core_Time_ns_alternate_sexp[100], now, t[2]))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bO_], 1);
           if(! caml_call2(Core_Time_ns_alternate_sexp[101], now, max_time))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bN_], 1);
           var _dc_ = min_allowed_key$1(t[7]), _dd_ = interval_num$0(t, t[4]);
           if(caml_call2(_bh_[9], _dd_, _dc_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bM_], 1);
          }),
      max_interval_num_fun =
        check
         (function(max_interval_num){
           var
            got = interval_num$0(t, max_time),
            sexpifier = _bh_[2],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_156, b_157){
            return caml_call2(_bh_[22], a_156, b_157);
           }
           caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos$8,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             max_interval_num,
             got);
           var
            got$0 = interval_num$0(t, interval_num_start(t, max_interval_num)),
            sexpifier$0 = _bh_[2],
            equal$0 = 0,
            message$0 = 0,
            here$0 = 0;
           function comparator$0(a_158, b_159){
            return caml_call2(_bh_[22], a_158, b_159);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$9,
                    sexpifier$0,
                    comparator$0,
                    here$0,
                    message$0,
                    equal$0,
                    max_interval_num,
                    got$0);
          }),
      start_fun =
        check
         (function(start){
           if(! caml_call2(Core_Time_ns_alternate_sexp[100], start, min_time))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bQ_], 1);
           if(caml_call2(Core_Time_ns_alternate_sexp[101], start, max_time))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bP_], 1);
          }),
      config_fun = check(invariant$1);
     caml_call1(config_fun, config$0);
     caml_call1(start_fun, start$0);
     caml_call1(max_interval_num_fun, max_interval_num$0);
     caml_call1(now_fun, now$0);
     caml_call1(now_interval_num_start_fun, now_interval_num_start$0);
     caml_call1(max_allowed_alarm_time_fun, max_allowed_alarm_time$0);
     caml_call1(priority_queue_fun, priority_queue$0);
     return iter$0
             (t,
              function(alarm){
               var
                _c7_ = interval_num$0(t, at$0(t, alarm)),
                _c8_ = interval_num(t, alarm);
               if(! caml_call2(_bh_[9], _c8_, _c7_))
                throw caml_maybe_attach_backtrace
                       ([0, Assert_failure, _bT_], 1);
               var
                _c9_ = interval_start(t, t[4]),
                _c__ = interval_start(t, at$0(t, alarm));
               if(! caml_call2(Core_Time_ns_alternate_sexp[100], _c__, _c9_))
                throw caml_maybe_attach_backtrace
                       ([0, Assert_failure, _bS_], 1);
               var
                _c$_ = alarm_precision$0(t),
                _da_ = caml_call2(Core_Time_ns_alternate_sexp[46], t[4], _c$_),
                _db_ = at$0(t, alarm);
               if(caml_call2(Core_Time_ns_alternate_sexp[103], _db_, _da_))
                return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _bR_], 1);
              });
    }
    function _c6_(x_155){
     return sexp_of_t$10(function(param){return _bU_;}, x_155);
    }
    return caml_call4(Base_Invariant[1], _bV_, t, _c6_, _c5_);
   }
   var debug = 0;
   function advance_clock(t, to, handle_removed){
    var _c3_ = caml_call2(Core_Time_ns_alternate_sexp[103], to, t[4]);
    if(_c3_){
     t[4] = to;
     var t_min_allowed_key = interval_num_unchecked(t, to);
     t[5] = interval_num_start_unchecked(t, t_min_allowed_key);
     var t$0 = t[7];
     if(caml_call2(symbol$16, t_min_allowed_key, min_allowed_key$1(t$0)))
      var match = 0;
     else{
      var
       level_index = [0, 0],
       result = [0, 1],
       prev_level_max_allowed_key = [0, caml_call1(pred$0, t_min_allowed_key)],
       levels = t$0[5],
       num_levels$0 = num_levels(t$0);
      for(;;){
       if(! caml_call2(Core[92], level_index[1], num_levels$0)){
        if(caml_call2(symbol$18, t_min_allowed_key, t$0[4])){
         t$0[3] = caml_call1(null$1, 0);
         t$0[4] = min_allowed_key$1(t$0);
        }
        var match = result[1];
        break;
       }
       var
        _c2_ = level_index[1],
        level = caml_check_bound(levels, _c2_)[1 + _c2_],
        min_allowed_key_before = level[9],
        prev_level_max_allowed_key$0 = prev_level_max_allowed_key[1],
        desired_min_allowed_key =
          compute_min_allowed_key(level, prev_level_max_allowed_key$0),
        level_min_allowed_key =
          min_key_in_same_slot$0
           (level,
            caml_call2
             (min$0,
              desired_min_allowed_key,
              caml_call2(max$0, level[9], t$0[4]))),
        level_min_allowed_key$0 = [0, level_min_allowed_key],
        slot$0 = [0, slot(level, level_min_allowed_key$0[1])],
        keys_per_slot = level[5],
        slots = level[11];
       for(;;){
        if
         (!
          caml_call2
           (symbol$19, level_min_allowed_key$0[1], desired_min_allowed_key))
         break;
        if(caml_call2(Core[90], level[8], 0))
         level_min_allowed_key$0[1] = desired_min_allowed_key;
        else{
         var
          _cZ_ = slot$0[1],
          first = caml_check_bound(slots, _cZ_)[1 + _cZ_];
         if(1 - caml_call1(is_null, first)){
          var _c0_ = caml_call1(null$1, 0), _c1_ = slot$0[1];
          caml_check_bound(slots, _c1_)[1 + _c1_] = _c0_;
          var pool = t$0[2], current = [0, first], continue$0 = [0, 1];
          for(;;){
           if(! continue$0[1]) break;
           var next$0 = next(pool, current[1]);
           level[8] = level[8] - 1 | 0;
           if(caml_call2(symbol$15, key(pool, current[1]), t_min_allowed_key))
            add_elt(t$0, current[1]);
           else{
            t$0[1] = t$0[1] - 1 | 0;
            caml_call1(handle_removed, current[1]);
            caml_call2(free, pool, current[1]);
           }
           if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
          }
         }
         slot$0[1] = next_slot(level, slot$0[1]);
         level_min_allowed_key$0[1] =
          add_clamp_to_max(level_min_allowed_key$0[1], keys_per_slot);
        }
       }
       level[9] = desired_min_allowed_key;
       level[10] = add_clamp_to_max(desired_min_allowed_key, level[7]);
       if(caml_call2(equal$3, level[9], min_allowed_key_before)){level_index[1] = num_levels$0; result[1] = 0;}
       else{
        level_index[1] = level_index[1] + 1 | 0;
        prev_level_max_allowed_key[1] = level[10];
       }
      }
     }
     if(match){t[6] = compute_max_allowed_alarm_time(t); return 0;}
     var _c4_ = debug;
    }
    else
     var _c4_ = _c3_;
    return _c4_;
   }
   function advance_clock_stop_at_next_ala(t, to, handle_fired){
    var min_elt = min_elt$1(t[7]);
    if(caml_call1(is_null, min_elt))
     return advance_clock
             (t,
              to,
              function(param){
               throw caml_maybe_attach_backtrace([0, Assert_failure, _bW_], 1);
              });
    var key$0 = key(pool$1(t), min_elt), _cX_ = interval_num_start(t, key$0);
    if(caml_call2(Core_Time_ns_alternate_sexp[104], to, _cX_))
     return advance_clock
             (t,
              to,
              function(param){
               throw caml_maybe_attach_backtrace([0, Assert_failure, _bX_], 1);
              });
    var
     _cY_ = min_alarm_time(pool$1(t), min_elt, key$0),
     to$0 = caml_call2(Core_Time_ns_alternate_sexp[108], to, _cY_);
    return advance_clock(t, to$0, handle_fired);
   }
   function create$2(config, start){
    if
     (caml_call2
       (Core_Time_ns_alternate_sexp[104],
        start,
        Core_Time_ns_alternate_sexp[35])){
     var
      _cN_ =
        [0,
         [1,
          [0,
           _bY_,
           [0, caml_call1(Core_Time_ns_alternate_sexp[98], start), 0]]],
         0],
      _cO_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_create_got_st),
          _cN_]];
     caml_call1(Core[261], _cO_);
    }
    var level_bits = config[2], capacity$0 = config[3];
    function _cJ_(index, param, level_bits){
     var
      levels = param[3],
      max_level_min_allowed_key = param[2],
      bits_per_slot = param[1],
      keys_per_slot = num_keys(bits_per_slot),
      diff_max_min_allowed_key =
        compute_diff_max_min_allowed_k(level_bits, bits_per_slot),
      min_key_in_same_slot_mask = create$1(bits_per_slot),
      min_allowed_key =
        min_key_in_same_slot
         (max_level_min_allowed_key, min_key_in_same_slot_mask),
      max_allowed_key =
        add_clamp_to_max(min_allowed_key, diff_max_min_allowed_key),
      _cR_ = caml_call1(null$1, 0),
      _cS_ = pow2(level_bits),
      _cT_ = caml_call1(Core_Int63[5], _cS_),
      _cU_ = caml_call2(Core_Array[63], _cT_, _cR_),
      level =
        [0,
         index,
         level_bits,
         create$0(level_bits),
         bits_per_slot,
         keys_per_slot,
         min_key_in_same_slot_mask,
         diff_max_min_allowed_key,
         0,
         min_allowed_key,
         max_allowed_key,
         _cU_],
      _cV_ = [0, level, levels],
      _cW_ =
        caml_call2(symbol$17, max_allowed_key, max_value$0)
         ? max_value$0
         : caml_call1(succ$0, max_allowed_key);
     return [0, symbol$2(level_bits, bits_per_slot), _cW_, _cV_];
    }
    var
     levels =
       caml_call3(Core_List[33], level_bits, [0, zero, zero$1, 0], _cJ_)[3],
     _cK_ = caml_call1(Core_Array[99], levels),
     _cL_ = caml_call1(null$1, 0);
    if(capacity$0)
     var sth = capacity$0[1], capacity = sth;
    else
     var capacity = 1;
    var
     _cM_ =
       [0,
        0,
        caml_call2(Tuple_pool[36][35], Tuple_pool[36][1][22], capacity),
        _cL_,
        zero$1,
        _cK_],
     _cP_ = Core_Time_ns_alternate_sexp[38],
     _cQ_ = Core_Time_ns_alternate_sexp[38],
     t =
       [0,
        config,
        start,
        interval_num_internal(max_time, config[1]),
        _cQ_,
        _cP_,
        max_time,
        _cM_];
    t[6] = compute_max_allowed_alarm_time(t);
    advance_clock
     (t,
      start,
      function(param){
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bZ_], 1);
      });
    return t;
   }
   function add_at_interval_num(t, at, value){
    var _cI_ = interval_num_start(t, at);
    return internal_add(t[7], at, _cI_, value);
   }
   function ensure_can_schedule_alarm(t, at){
    if(caml_call2(Core_Time_ns_alternate_sexp[103], at, t[6])){
     var
      _cB_ =
        [0,
         [1,
          [0, _b0_, [0, caml_call1(Core_Time_ns_alternate_sexp[98], t[6]), 0]]],
         0],
      _cC_ =
        [0,
         [1,
          [0, _b1_, [0, caml_call1(Core_Time_ns_alternate_sexp[98], at), 0]]],
         _cB_],
      _cD_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu),
          _cC_]];
     caml_call1(Core[261], _cD_);
    }
    var _cH_ = caml_call2(Core_Time_ns_alternate_sexp[104], at, t[5]);
    if(! _cH_) return _cH_;
    var
     _cE_ =
       [0,
        [1,
         [0, _b2_, [0, caml_call1(Core_Time_ns_alternate_sexp[98], t[5]), 0]]],
        0],
     _cF_ =
       [0,
        [1,
         [0, _b3_, [0, caml_call1(Core_Time_ns_alternate_sexp[98], at), 0]]],
        _cE_],
     _cG_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu$0),
         _cF_]];
    return caml_call1(Core[261], _cG_);
   }
   function add$0(t, at, value){
    ensure_can_schedule_alarm(t, at);
    var _cA_ = interval_num_unchecked(t, at);
    return internal_add(t[7], _cA_, at, value);
   }
   function remove(t, alarm){
    var t$0 = t[7], pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    return caml_call2(free, pool, elt);
   }
   function clear(t){
    var t$0 = t[7], _cr_ = 1 - is_empty(t$0);
    if(_cr_){
     t$0[1] = 0;
     var
      pool = t$0[2],
      free_elt = function(elt){return caml_call2(free, pool, elt);},
      levels = t$0[5],
      _ct_ = levels.length - 1 - 1 | 0,
      _cs_ = 0;
     if(_ct_ >= 0){
      var level_index = _cs_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[91], level[8], 0)){
        level[8] = 0;
        var slots = level[11], _cw_ = slots.length - 1 - 1 | 0, _cv_ = 0;
        if(_cw_ >= 0){
         var slot_index = _cv_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)){
           iter(pool, elt, free_elt);
           var _cy_ = caml_call1(null$1, 0);
           caml_check_bound(slots, slot_index)[1 + slot_index] = _cy_;
          }
          var _cz_ = slot_index + 1 | 0;
          if(_cw_ === slot_index) break;
          var slot_index = _cz_;
         }
        }
       }
       var _cx_ = level_index + 1 | 0;
       if(_ct_ === level_index) break;
       var level_index = _cx_;
      }
     }
     var _cu_ = 0;
    }
    else
     var _cu_ = _cr_;
    return _cu_;
   }
   function mem(t, alarm){var t$0 = t[7]; return is_valid(t$0[2], alarm);}
   function reschedule_gen(t, alarm, key, at){
    if(1 - mem(t, alarm)) caml_call1(Core[6], cst_Timing_wheel_cannot_resche);
    ensure_can_schedule_alarm(t, at);
    var t$0 = t[7];
    ensure_valid_key(t$0, key);
    var pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][3], key);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][4], at);
    return internal_add_elt(t$0, elt);
   }
   function reschedule(t, alarm, at){
    return reschedule_gen(t, alarm, interval_num_unchecked(t, at), at);
   }
   function reschedule_at_interval_num(t, alarm, at){
    return reschedule_gen(t, alarm, at, interval_num_start(t, at));
   }
   function min_alarm_interval_num(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, key(pool$1(t), elt)];
   }
   function min_alarm_interval_num_exn(x_164){
    var elt = min_elt$1(x_164[7]);
    if(! caml_call1(is_null, elt)) return key(pool$1(x_164), elt);
    var
     _cn_ = 0,
     _co_ = 0,
     _cp_ =
       [0,
        [1,
         [0,
          _b5_,
          [0, sexp_of_t$10(function(param){return _b4_;}, x_164), _co_]]],
        _cn_],
     _cq_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_min_alarm_int),
         _cp_]];
    return caml_call1(Core[261], _cq_);
   }
   function max_alarm_time_in_list(t, first){
    var
     pool = pool$1(t),
     with_key = key(pool, first),
     max_alarm_time = [0, Core_Time_ns_alternate_sexp[35]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return max_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _cl_ = max_alarm_time[1], _cm_ = at(pool, current[1]);
      max_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[109], _cm_, _cl_);
     }
     if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
    }
   }
   function min_alarm_time_in_list(t, elt){
    var pool = pool$1(t);
    return min_alarm_time(pool, elt, key(pool, elt));
   }
   function max_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, max_alarm_time_in_list(t, elt)];
   }
   function min_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, min_alarm_time_in_list(t, elt)];
   }
   function max_alarm_time_in_min_interval$0(x_165){
    var elt = min_elt$1(x_165[7]);
    if(caml_call1(is_null, elt)){
     var
      _ch_ = 0,
      _ci_ = 0,
      _cj_ =
        [0,
         [1,
          [0,
           _b7_,
           [0, sexp_of_t$10(function(param){return _b6_;}, x_165), _ci_]]],
         _ch_],
      _ck_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim),
          _cj_]];
     caml_call1(Core[261], _ck_);
    }
    return max_alarm_time_in_list(x_165, elt);
   }
   function min_alarm_time_in_min_interval$0(x_166){
    var elt = min_elt$1(x_166[7]);
    if(caml_call1(is_null, elt)){
     var
      _cd_ = 0,
      _ce_ = 0,
      _cf_ =
        [0,
         [1,
          [0,
           _b9_,
           [0, sexp_of_t$10(function(param){return _b8_;}, x_166), _ce_]]],
         _cd_],
      _cg_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim$0),
          _cf_]];
     caml_call1(Core[261], _cg_);
    }
    return min_alarm_time_in_list(x_166, elt);
   }
   function fire_past_alarms(t, handle_fired){
    var
     now = t[4],
     key = now_interval_num(t),
     t$0 = t[7],
     level = caml_check_bound(t$0[5], 0)[1],
     _b__ = caml_call2(Core[91], level[8], 0);
    if(_b__){
     var
      slot$0 = slot(level, key),
      slots = level[11],
      pool = t$0[2],
      first = [0, caml_check_bound(slots, slot$0)[1 + slot$0]],
      _b$_ = 1 - caml_call1(is_null, first[1]);
     if(_b$_){
      var current = [0, first[1]], continue$0 = [0, 1];
      for(;;){
       if(! continue$0[1]){var _cb_ = 0; break;}
       var elt = current[1], next$0 = next(pool, elt);
       if(next$0 === first[1]) continue$0[1] = 0; else current[1] = next$0;
       var _ca_ = at(pool, elt);
       if(caml_call2(Core_Time_ns_alternate_sexp[101], _ca_, now)){
        caml_call1(handle_fired, elt);
        internal_remove(t$0, elt);
        caml_call2(free, pool, elt);
        first[1] = caml_check_bound(slots, slot$0)[1 + slot$0];
       }
      }
     }
     else
      var _cb_ = _b$_;
     var _cc_ = _cb_;
    }
    else
     var _cc_ = _b__;
    return _cc_;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_timing_wheel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel);
   var
    Timing_wheel =
      [0,
       [0,
        compare,
        sexp_of_t$1,
        equal$0,
        of_span_floor_pow2_ns,
        of_span_floor_pow2_ns,
        to_sexpable,
        one_nanosecond,
        about_one_day,
        about_one_microsecond,
        about_one_millisecond,
        about_one_second,
        mul,
        div,
        _l_],
       sexp_of_t$10,
       sexp_of_t_now,
       _bh_,
       [0, sexp_of_t$8, null$0, at$0, interval_num, value$0],
       invariant$2,
       [0,
        t_of_sexp$0,
        sexp_of_t$0,
        invariant$0,
        max_num_bits,
        create_exn,
        level_bits_default,
        num_bits],
       [0,
        t_of_sexp$2,
        sexp_of_t$3,
        invariant$1,
        create,
        alarm_precision,
        level_bits,
        durations,
        microsecond_precision],
       create$2,
       alarm_precision$0,
       now,
       start,
       is_empty$0,
       length$3,
       iter$0,
       interval_num$0,
       now_interval_num,
       interval_num_start,
       interval_start,
       advance_clock,
       advance_clock_stop_at_next_ala,
       fire_past_alarms,
       max_allowed_alarm_time,
       now_interval_num,
       max_allowed_alarm_interval_num,
       add$0,
       add_at_interval_num,
       mem,
       remove,
       reschedule,
       reschedule_at_interval_num,
       clear,
       min_alarm_interval_num,
       min_alarm_interval_num_exn,
       max_alarm_time_in_min_interval,
       min_alarm_time_in_min_interval,
       max_alarm_time_in_min_interval$0,
       min_alarm_time_in_min_interval$0,
       next_alarm_fires_at,
       next_alarm_fires_at_exn,
       [0, max_time, interval_num_internal, [0, invariant, zero]]];
   runtime.caml_register_global(214, Timing_wheel, cst_Timing_wheel$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0aW1pbmdfd2hlZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInBvcyQ5IiwicG9zJDgiLCJwb3MkNyIsInBvcyQ2IiwiYXJnXzA4NyIsInBvcyQ1IiwicG9zJDQiLCJwb3MkMyIsInBvcyQyIiwicG9zJDEiLCJwb3MkMCIsInBvcyIsImVycm9yX3NvdXJjZV8wMTkiLCJtYXhfdGltZSIsIm1pbl90aW1lIiwibWF4X251bV9iaXRzIiwibWluX3ZhbHVlIiwiaW52YXJpYW50IiwidCIsIm9mX2ludCIsImkiLCJzeW1ib2wkMiIsInQxIiwidDIiLCJzeW1ib2wkMyIsInBvdzIiLCJzZXhwX29mX3QkMCIsInhfMDA3IiwibnVtX2JpdHNfaW50ZXJuYWwiLCJudW1fYml0cyIsImludmFyaWFudCQwIiwibnVtX2tleV9iaXRzIiwidF9vZl9zZXhwJDAiLCJ4XzAwNiIsImNyZWF0ZV9leG4iLCJvcHQiLCJ4XzAwOCIsInN0aCIsImV4dGVuZF90b19tYXhfbnVtX2JpdHMiLCJiaXRzIiwiaW50cyIsImxldmVsX2JpdHNfZGVmYXVsdCIsImNvbXBhcmUiLCJlcXVhbCQwIiwieF8wMTIiLCJ4XzAxMyIsInRvX3NleHBhYmxlIiwic2V4cF9vZl90JDEiLCJvbmVfbmFub3NlY29uZCIsImFib3V0X29uZV9taWNyb3NlY29uZCIsImFib3V0X29uZV9taWxsaXNlY29uZCIsImFib3V0X29uZV9zZWNvbmQiLCJhYm91dF9vbmVfZGF5IiwibXVsIiwiZGl2Iiwib2Zfc3Bhbl9mbG9vcl9wb3cyX25zIiwic3BhbiIsImxldmVsX2JpdHMiLCJyIiwidiIsImxldmVsX2JpdHMkMCIsInRfb2Zfc2V4cCQyIiwieF8wMjEiLCJjYXBhY2l0eSIsImFsYXJtX3ByZWNpc2lvbiIsInNleHBfb2ZfdCQzIiwiY2FwYWNpdHlfMDI3IiwibGV2ZWxfYml0c18wMjUiLCJhbGFybV9wcmVjaXNpb25fMDIzIiwiYm5kc18wMjIiLCJ2XzAyOCIsImFyZ18wMzAiLCJibmRfMDI5IiwiYm5kc18wMjIkMCIsImFyZ18wMjYiLCJibmRzXzAyMiQxIiwiYXJnXzAyNCIsImJuZHNfMDIyJDIiLCJtYXhfbnVtX2xldmVsX2JpdHMiLCJpbnZhcmlhbnQkMSIsImxldmVsX2JpdHNfZnVuIiwiY3JlYXRlIiwibG9vcCIsInJlbWFpbmluZyIsInQkMCIsImIiLCJtaWNyb3NlY29uZF9wcmVjaXNpb24iLCJkdXJhdGlvbnMiLCJudW1fYml0c19hY2N1bSIsImxldmVsX251bV9iaXRzIiwibnVtX2JpdHNfYWNjdW0kMCIsImR1cmF0aW9uIiwiY29tcGFyZSQwIiwic2V4cF9vZl90JDQiLCJjcmVhdGUkMCIsIm51bV9rZXlzIiwiY3JlYXRlJDEiLCJiaXRzX3Blcl9zbG90IiwidG9faW50NjMiLCJvZl9pbnQ2MyIsInNjYWxlX2ludCIsInNleHBfb2ZfdCQ3Iiwib2ZfaW50NjMkMCIsInRvX2ludDYzJDAiLCJhZGQiLCJhZGRfY2xhbXBfdG9fbWF4Iiwic3ViIiwiZGlmZiIsIm1pbl9rZXlfaW5fc2FtZV9zbG90IiwibWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayIsInNleHBfb2ZfcG9vbF9zbG90cyIsIm9mX2FfMDMzIiwieF8wMzQiLCJzZXhwX29mX3QkOCIsIm9mX2FfMDM1IiwieF8wMzYiLCJudWxsJDAiLCJudWxsJDEiLCJpc19udWxsIiwiZnJlZSIsImtleSIsInAiLCJhdCIsInZhbHVlIiwibGV2ZWxfaW5kZXgiLCJwcmV2Iiwic2V0X3ByZXYiLCJ4IiwibmV4dCIsInNldF9uZXh0IiwiaXNfdmFsaWQiLCJncm93IiwiaXNfZnVsbCIsIm9mX2V4dGVybmFsX2V4biIsInBvb2wiLCJsaW5rIiwiaXRlciIsImZpcnN0IiwiZiIsImN1cnJlbnQiLCJjb250aW51ZSQwIiwibmV4dCQwIiwibWluX2FsYXJtX3RpbWUiLCJ3aXRoX2tleSIsInNsb3RzIiwibWF4X2FsbG93ZWRfa2V5Iiwic2V0X21heF9hbGxvd2VkX2tleSIsIm1pbl9hbGxvd2VkX2tleSIsInNldF9taW5fYWxsb3dlZF9rZXkiLCJsZW5ndGgiLCJzZXRfbGVuZ3RoIiwiZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5Iiwia2V5c19wZXJfc2xvdCIsInNsb3RzX21hc2siLCJpbmRleCIsInNsb3RzJDAiLCJtYXhfYWxsb3dlZF9rZXkkMCIsIm1pbl9hbGxvd2VkX2tleSQwIiwibGVuZ3RoJDAiLCJkaWZmX21heF9taW5fYWxsb3dlZF9rZXkkMCIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2skMCIsImtleXNfcGVyX3Nsb3QkMCIsImJpdHNfcGVyX3Nsb3QkMCIsInNsb3RzX21hc2skMCIsImJpdHMkMCIsImluZGV4JDAiLCJzZXhwX29mX3QkOSIsIm9mX2FfMDQ0IiwiZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XzA1OCIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tfMDU2Iiwia2V5c19wZXJfc2xvdF8wNTQiLCJiaXRzX3Blcl9zbG90XzA1MiIsInNsb3RzX21hc2tfMDUwIiwiYml0c18wNDgiLCJpbmRleF8wNDYiLCJsZW5ndGhfMDYwIiwibWluX2FsbG93ZWRfa2V5XzA2MiIsIm1heF9hbGxvd2VkX2tleV8wNjQiLCJzbG90c18wNjYiLCJhcmdfMDY3IiwiYm5kc18wNDUiLCJhcmdfMDY1IiwiYm5kc18wNDUkMCIsImFyZ18wNjMiLCJibmRzXzA0NSQxIiwiYXJnXzA2MSIsImJuZHNfMDQ1JDIiLCJhcmdfMDU5IiwiYm5kc18wNDUkMyIsImFyZ18wNTciLCJibmRzXzA0NSQ0IiwiYXJnXzA1NSIsImJuZHNfMDQ1JDUiLCJhcmdfMDUzIiwiYm5kc18wNDUkNiIsImFyZ18wNTEiLCJibmRzXzA0NSQ3IiwiYXJnXzA0OSIsImJuZHNfMDQ1JDgiLCJhcmdfMDQ3IiwiYm5kc18wNDUkOSIsInNsb3QiLCJuZXh0X3Nsb3QiLCJtaW5fa2V5X2luX3NhbWVfc2xvdCQwIiwiY29tcHV0ZV9taW5fYWxsb3dlZF9rZXkiLCJwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSIsImxldmVscyIsImVsdF9rZXlfbG93ZXJfYm91bmQiLCJzZXRfZWx0X2tleV9sb3dlcl9ib3VuZCIsIm1pbl9lbHQiLCJzZXRfbWluX2VsdCIsInNldF9wb29sIiwibGVuZ3RoJDEiLCJzZXRfbGVuZ3RoJDAiLCJsZXZlbHMkMCIsImVsdF9rZXlfbG93ZXJfYm91bmQkMCIsIm1pbl9lbHQkMCIsInBvb2wkMCIsImxlbmd0aCQyIiwiaXNfZW1wdHkiLCJudW1fbGV2ZWxzIiwibWluX2FsbG93ZWRfa2V5JDEiLCJtYXhfYWxsb3dlZF9rZXkkMSIsImludGVybmFsX2l0ZXIiLCJsZXZlbCIsInNsb3RfaW5kZXgiLCJlbHQiLCJjb21wdXRlX2RpZmZfbWF4X21pbl9hbGxvd2VkX2siLCJtaW5fZWx0JDEiLCJtaW5fZWx0X2FscmVhZHlfZm91bmQiLCJtaW5fa2V5X2FscmVhZHlfZm91bmQiLCJudW1fbGV2ZWxzJDAiLCJzbG90X21pbl9rZXkiLCJzbG90JDAiLCJjdXJyZW50X2tleSIsImFkZF9lbHQiLCJ4XzExNCIsInRvX2FkZCIsImtleSQwIiwiZWx0c18wOTQiLCJtYXhfYWxsb3dlZF9rZXlfMDkyIiwibWluX2FsbG93ZWRfa2V5XzA5MCIsImJuZHNfMDg5Iiwia2V5XzA4NCIsImJuZHNfMDgzIiwiYXJnXzA4NSIsImJuZHNfMDgzJDAiLCJhcmdfMDk1IiwiYm5kc18wODkkMCIsImFyZ18wOTMiLCJibmRzXzA4OSQxIiwiYXJnXzA5MSIsImJuZHNfMDg5JDIiLCJsZXZlbF9pbmRleCQwIiwicHJldiQwIiwiaW50ZXJuYWxfYWRkX2VsdCIsImVuc3VyZV92YWxpZF9rZXkiLCJpbnRlcm5hbF9hZGQiLCJpbnRlcm5hbF9yZW1vdmUiLCJtaW5faW50ZXJ2YWxfbnVtIiwicHJpb3JpdHlfcXVldWUiLCJtYXhfYWxsb3dlZF9hbGFybV90aW1lIiwic2V0X21heF9hbGxvd2VkX2FsYXJtX3RpbWUiLCJub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0Iiwic2V0X25vd19pbnRlcnZhbF9udW1fc3RhcnQiLCJub3ciLCJzZXRfbm93IiwibWF4X2ludGVydmFsX251bSIsInN0YXJ0IiwiY29uZmlnIiwicHJpb3JpdHlfcXVldWUkMCIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWUkMCIsIm5vd19pbnRlcnZhbF9udW1fc3RhcnQkMCIsIm5vdyQwIiwibWF4X2ludGVydmFsX251bSQwIiwic3RhcnQkMCIsImNvbmZpZyQwIiwic2V4cF9vZl90X25vdyIsImFsYXJtX3ByZWNpc2lvbiQwIiwiYXQkMCIsInR3IiwidmFsdWUkMCIsImludGVydmFsX251bSIsIml0ZXIkMCIsImNvbXBhcmUkMyIsInNleHBfb2ZfdCQxMCIsInNleHBfb2ZfYSIsIm1heF9pbnRlcnZhbF9udW1fMTQ2Iiwic3RhcnRfMTQ0IiwiY29uZmlnXzE0MiIsIm5vd18xNDgiLCJhbGFybSIsImFsYXJtc18xNTAiLCJibmRzXzE0MSIsInZhbHVlXzEzOCIsImF0XzEzNiIsImFyZ18xMzkiLCJibmRzXzEzNSIsImFyZ18xMzciLCJibmRzXzEzNSQwIiwiYXJnXzE1MSIsImJuZHNfMTQxJDAiLCJhcmdfMTQ5IiwiYm5kc18xNDEkMSIsImFyZ18xNDciLCJibmRzXzE0MSQyIiwiYXJnXzE0NSIsImJuZHNfMTQxJDMiLCJhcmdfMTQzIiwiYm5kc18xNDEkNCIsImxlbmd0aCQzIiwiaXNfZW1wdHkkMCIsInBvb2wkMSIsImludGVydmFsX251bV9pbnRlcm5hbCIsInRpbWUiLCJpbnRlcnZhbF9udW1fdW5jaGVja2VkIiwiaW50ZXJ2YWxfbnVtJDAiLCJpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIiwiaW50ZXJ2YWxfbnVtX3N0YXJ0IiwibmV4dF9hbGFybV9maXJlc19hdF9pbnRlcm5hbCIsIm5leHRfYWxhcm1fZmlyZXNfYXQiLCJuZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biIsInhfMTUzIiwiY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIiwibm93X2ludGVydmFsX251bSIsIm1heF9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bSIsImludGVydmFsX3N0YXJ0IiwiaW52YXJpYW50JDIiLCJpbnZhcmlhbnRfYSIsImNoZWNrIiwicHJpb3JpdHlfcXVldWVfZnVuIiwibGV2ZWxzX2Z1biIsInNsb3RzX2Z1biIsIm4iLCJ4XzA0MSIsIm1heF9hbGxvd2VkX2tleV9mdW4iLCJleHBlY3QiLCJlcXVhbCIsIm1lc3NhZ2UiLCJoZXJlIiwiY29tcGFyYXRvciIsImFfMTA3IiwiYl8xMDgiLCJtaW5fYWxsb3dlZF9rZXlfZnVuIiwiZ290Iiwic2V4cGlmaWVyIiwiYV8xMDUiLCJiXzEwNiIsImxlbmd0aF9mdW4iLCJkaWZmX21heF9taW5fYWxsb3dlZF9rZXlfZnVuIiwiZXRhIiwiYV8xMDMiLCJiXzEwNCIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tfZnVuIiwia2V5c19wZXJfc2xvdF9mdW4iLCJhXzEwMSIsImJfMTAyIiwiYml0c19wZXJfc2xvdF9mdW4iLCJleHBlY3QkMCIsInNsb3RzX21hc2tfZnVuIiwiYV8wOTkiLCJiXzEwMCIsImJpdHNfZnVuIiwiaW5kZXhfZnVuIiwieF8wOTgiLCJwcmV2X2xldmVsIiwiYV8xMTAiLCJiXzExMSIsImdvdCQwIiwibWVzc2FnZSQwIiwiaGVyZSQwIiwiY29tcGFyYXRvciQwIiwiYV8xMTIiLCJiXzExMyIsImVsdF9rZXlfbG93ZXJfYm91bmRfZnVuIiwibWluX2VsdF9mdW4iLCJwb29sX2Z1biIsInhfMTA5Iiwib2ZfYV8wNjgiLCJsZW5ndGhfMDcwIiwicG9vbF8wNzIiLCJtaW5fZWx0XzA3NCIsImVsdF9rZXlfbG93ZXJfYm91bmRfMDc2IiwibGV2ZWxzXzA3OCIsImJuZHNfMDY5IiwiYXJnXzA3OSIsImJuZHNfMDY5JDAiLCJhcmdfMDc3IiwiYm5kc18wNjkkMSIsImFyZ18wNzUiLCJibmRzXzA2OSQyIiwiYXJnXzA3MyIsImJuZHNfMDY5JDMiLCJhcmdfMDcxIiwiYm5kc18wNjkkNCIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWVfZnVuIiwiYV8xNjIiLCJiXzE2MyIsIm5vd19pbnRlcnZhbF9udW1fc3RhcnRfZnVuIiwiYV8xNjAiLCJiXzE2MSIsIm5vd19mdW4iLCJtYXhfaW50ZXJ2YWxfbnVtX2Z1biIsImFfMTU2IiwiYl8xNTciLCJzZXhwaWZpZXIkMCIsImFfMTU4IiwiYl8xNTkiLCJzdGFydF9mdW4iLCJjb25maWdfZnVuIiwieF8xNTUiLCJkZWJ1ZyIsImFkdmFuY2VfY2xvY2siLCJ0byIsImhhbmRsZV9yZW1vdmVkIiwidF9taW5fYWxsb3dlZF9rZXkiLCJyZXN1bHQiLCJtaW5fYWxsb3dlZF9rZXlfYmVmb3JlIiwicHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkkMCIsImRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IiwibGV2ZWxfbWluX2FsbG93ZWRfa2V5IiwibGV2ZWxfbWluX2FsbG93ZWRfa2V5JDAiLCJhZHZhbmNlX2Nsb2NrX3N0b3BfYXRfbmV4dF9hbGEiLCJoYW5kbGVfZmlyZWQiLCJ0byQwIiwiY3JlYXRlJDIiLCJjYXBhY2l0eSQwIiwibWF4X2xldmVsX21pbl9hbGxvd2VkX2tleSIsImFkZF9hdF9pbnRlcnZhbF9udW0iLCJlbnN1cmVfY2FuX3NjaGVkdWxlX2FsYXJtIiwiYWRkJDAiLCJyZW1vdmUiLCJjbGVhciIsImZyZWVfZWx0IiwibWVtIiwicmVzY2hlZHVsZV9nZW4iLCJyZXNjaGVkdWxlIiwicmVzY2hlZHVsZV9hdF9pbnRlcnZhbF9udW0iLCJtaW5fYWxhcm1faW50ZXJ2YWxfbnVtIiwibWluX2FsYXJtX2ludGVydmFsX251bV9leG4iLCJ4XzE2NCIsIm1heF9hbGFybV90aW1lX2luX2xpc3QiLCJtYXhfYWxhcm1fdGltZSIsIm1pbl9hbGFybV90aW1lX2luX2xpc3QiLCJtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwiLCJtaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwiLCJtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwkMCIsInhfMTY1IiwibWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsJDAiLCJ4XzE2NiIsImZpcmVfcGFzdF9hbGFybXMiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlX2tlcm5lbC90aW1pbmdfd2hlZWwvdGltaW5nX3doZWVsX18ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlX2tlcm5lbC90aW1pbmdfd2hlZWwvdGltaW5nX3doZWVsLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0dBUXdCOztJQUFBOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7OztJQ3drREVBO0lBSEFDO0lBZ0JBQztJQUtBQztJQW54QmhCQztJQWlKc0JDO0lBSEFDO0lBMUZEQztJQU9EQztJQVdDQztJQWtCQ0M7SUFLRkM7SUFsc0I1QkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F6TGtEO0lBSWhEQztJQUNBQzs7Ozs7Ozs7O0lBc0RFQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBakNBQztZQUtBQyxVQUFVQztJQUNaLEtBQU8sbUJBREtBLEdBTFZGO0tBTUYsTUFBQTtJQUNPLEdBQUEscUJBRktFLEdBNEJWSDtJQTFCRixNQUFBO0dBQXVCO1lBR3JCSSxPQUFPQyxHQUxQSCxVQUtPRyxJQUNULE9BRFNBLEVBRVI7WUFHQ0MsU0FBTUMsSUFBR0MsSUFDWCxJQUFJTCxJQURJSSxLQUFHQyxRQVZUTixVQVdFQyxJQUNKLE9BRElBLEVBRUg7WUFHQ00sU0FBTUYsSUFBR0MsSUFDWCxJQUFJTCxJQURJSSxLQUFHQyxRQWhCVE4sVUFpQkVDLElBQ0osT0FESUEsRUFFSDtZQUdDTyxLQUFLUCxHQUFJLE9BQUEsMkNBQUpBLEdBQWdDO1lBSXpDUSxZQUFBQztJQUFBLE9BQUEsaUNBQUFBO0dBQXVEO1lBR25EQyxrQkFBa0JWO0lBQUksaUNBQUpBLFNBbkJsQkc7R0FtQitFO1lBQy9FUSxTQUFTWCxHQUFLLE9BRGRVLGtCQUNTVixHQUF3QjtZQXNKdkJZLFlBcEpBWjtJQUNaLEdBQVksMEJBREFBO0tBQ1osTUFBQTtrQkFDb0JhO0tBbENsQmQsVUFrQ2tCYztLQUVYLEdBQUEscUJBRldBO0tBRWxCLE1BQUE7SUFBMEQ7SUFGNUQsMEJBRlliO0lBS1csT0FyQ3JCRCxVQTZCQVcsa0JBR1VWO0dBS2dDO1lBRzFDYyxZQUFVQztJQWRkLElBZU1mLElBZk4saUNBY2NlO0lBNElBSCxZQTNJUlo7SUFDSixPQURJQTtHQUVIO1lBR0NnQixXQUFhQyxLQUFnQ0M7SUFDL0MsR0FEZUQ7U0FBeUJFLE1BQXpCRixRQUFBRyx5QkFBeUJEOztTQUF6QkM7SUFDWixHQUFBLDBCQUQ0Q0Y7S0FDcEI7SUFBQSxjQUNDRyxNQUFRLE9BQUEscUJBQVJBLFNBQWlCO0lBQTFDLEdBQUEsMEJBRjRDSDs7a0RBQUFBOzs7Ozs7S0FJN0M7O0lBQUEsMEI7SUFFYSxJQUFYUCxXQUFXLDBCQU5nQ087SUFPNUMsR0FBQSxxQkFEQ1AsVUF4QkZkOzs7bURBQUFBO3dEQXdCRWM7a0RBTjJDTzs7Ozs7O0tBUzdDOztPQVRhRTtLQWlCc0M7TUFBQSxPQUFBO01BQXZDLE9BQUEsMEJBbkNadkIsZUF3QkVjO01BU0FXLE9BRUcsc0JBakJ3Q0o7O1NBZTNDSSxPQWYyQ0o7SUFvQi9DLE9BQUEsMEJBTElJLE1BeERGckI7R0E2RGtDO0dBR3hCLElBbUZWc0IscUJBMUdBUCxvQkEyRkFRO1lBeENBQyxRQUF5QkMsT0FBQUM7SSxhQUFBLFdBd0N6QkgsU0F4Q3lCRSxPQUFBQzs7WUFDekJkLGFBQWFiLEdBQUksT0E3RmpCQyxPQTZGYUQsR0FBNEI7WUE0Q3JDNEIsWUExQ0k1QjtJQUNWLEdBQUcscUJBRE9BOzt1Q0FBQUE7Ozs7OztLQUdSOztJQUdGLFdBQUEsV0FBTyw0Q0FOR0E7SUFNVixPQUFBO0dBQW9EO1lBR2xENkIsWUFBVTdCO0lBQVksV0FpQ2xCNEIsWUFqQ001QjtJQUFZLE9BQUE7OztJQUN0QjhCO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBQ0FDLElBQUluQyxHQUFHTyxNQUFPLE9BQVZQLElBQUdPLFNBQWU7WUFDdEI2QixJQUFJcEMsR0FBR08sTUFBTyxPQUFWUCxJQUFHTyxTQUFlO1lBeUJsQjhCLHNCQWxCa0JDO0lBQ3hCLEdBQUcsZ0NBRHFCQTs7OzZEQUFBQTs7Ozs7O0tBR3RCOztJQUlGLFdBQUEsaUNBUHdCQTtJQU94QixPQUFBO0dBQW9EO0dBckNsRDs7Ozs7O1lBaURJVixhQURBUzs7Ozs7Ozs7Ozs7OztZQUNBVCxhQURBUzs7O0lBaERKOzs7Ozs7Ozs7O09BNENBYjs7O1lBbUJBZSxXQUFBQyxHQUFBLE9BQUFBLEtBQVU7Z0JBQVZBLEdBQUFDLEdBQUEsV0FBQUQsTUFBQUMsR0FBQUQsTUFBVTtHQUFWOztJQUFBRTswQkFBQSxTQUFVLHdCQUFWSDtZQUZKSSxZQUFBQzs7S0FBQTs7TUFHSUM7TUFEQU47TUFEQU87S0FESixXQUNJQSxpQkFDQVAsWUFDQU07SUFFOEM7SUFMbEQ7O0tBQUE7Ozs7OztJQUtrRDtJQUxsRDtLQUFBO0tBQUE7Ozs0QkFBQSxPQUZJdEIsbUJBTzhDO1FBdkg5Q1Q7O0lBa0hKLE9BQUE7O2FBQUFwQjs7Ozs7YUFBQWtEO0dBS2tEO1lBTGxERztJQUFBO0tBR0lDO0tBREFDO0tBREFDO0tBREpDO0lBR0ksR0FBQUg7S0FBQTtNQUFBSSxRQUFBSjtNQUFBSyxVQUFBLHNCQUFBRDtNQUFBRSwyQkFBQUQ7TUFISkUsaUJBR0lELFNBSEpIOztTQUFBSSxhQUFBSjtJQUVJO0tBQUFLLFVBbElKaEQsWUFrSUl5QztLQUZKUSxrQ0FFSUQsZUFGSkQ7S0FDSUcsVUFBQSxvQkFBQVI7S0FESlMsa0NBQ0lELGVBREpEO0lBQUEsV0FBQUU7R0FLa0Q7WUFFOUNiLGdCQUFnQjlDLEdBQUksT0FuQmhCNEIsWUFtQlk1QixNQUE2QztZQU83RDRELG1CQUFtQmQ7SUFDckIsT0F6SkV4QyxTQVlBVCxjQXNFQWdCLGFBc0VtQmlDO0dBRzJCO1lBRzlDZSxZQUFVN0Q7O0tBS04sV0FYSjRELG1CQU1VNUQ7S0FFSCxLQUFBLHFCQW5KUFUsa0JBaUpVVjtNQUVWLE1BQUE7S0FJYyxJQTFCYjhELGlCQTBCYSw4QkFOSjlELEdBTUFZO0tBMUJULFdBQUFrRCxnQkFFRHBCO0tBQ0E7SUEyQjBDO0lBVEEsT0FBQSxtQ0FEaEMxQyxHQXBCZCtDO0dBOEIrQztZQUczQ2dCLE9BQVFsQixVQUFXNUIsS0FBa0M2QjtJQUN2RCxHQURxQjdCO1NBQWFFLE1BQWJGLFFBcEhkc0IsYUFvSDJCcEI7O1NBcEgzQm9CLGFBaUZMaEI7SUFxQ3lDLElBdEhqQzFCLGVBaUdSK0QsbUJBbUJxRGQ7SUFuSHBELEdBQUEscUJBM0NEcEMsa0JBMENLNkIsYUFBRzFDO1NBcUhONkMsZUFySEdIOzs7TUFJR3lCO2lCQUFLaEUsR0FBR2lFO1NBQ2QsS0FEV2pFLEdBRUg7YUFDRGtFLE1BSElsRSxNQUdUbUUsSUFIU25FO1NBSU4sT0FBQSxtQkFESG1FLEdBSFlGO3VCQUFBQTt1QkFHWkUsR0FISUgsS0FHQ0UsS0E5RFQ1RCxTQTJEZ0IyRCxXQUdaRTtRQUc0RDtNQTJHOUR6QixlQWpITXNCLEtBSkh6QixZQUFHMUM7SUF3SFYsV0FKdURpRCxpQkFDbkRKLGNBRE1HO0dBSStCO1lBR3ZDdUI7SUFDRixPQVJFTCxjQTdJQS9DLHFCQWlFQWU7R0F1RnVEO1lBR3ZEc0MsVUFBVXJFO2tCQUlGc0UsZ0JBQWVDO0tBQ3JCO01BQUlDO1FBREVGLGlCQUNnQyxtQkFEakJDO01BSWI7UUFBQSxxQkFISkM7O1dBS00sMkNBTE5BO01BQ0FDLFdBQ0Y7S0FLRixXQVBJRCxrQkFDQUM7SUFNb0I7SUFUcEIsV0FBQSxtQkExR041RCxhQXVHVWI7SUFJUCxPQUFBLDBCQUpPQTtHQVlpQjtHQXlMM0IsSUFBQTBFLDZCQXFheUJDO1lBbmFyQkMsU0FBUXJDO0lBQWEsSUFBQSx1QkFBWSxPQTFYckNoQyxLQTBYWWdDO0lBQWEsT0FBQTtHQUFvRDtZQUkzRXNDLFNBQVNsRSxVQUFXLE9BOVh0QkosS0E4WFdJLFVBQXFDOzs7Ozs7O1lBSzVDbUUsU0FBUUM7SUFBZ0IsT0FBUSxvQkFBQSxxQkFuWXBDeEUsS0FtWVl3RTtHQUErRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQU12RUMsU0FBU2hGLEdBQUksT0FBSkEsRUFBSztZQUNkaUYsU0FBUy9FLEdBQUksT0FBSkEsRUFBSztZQUNkZ0YsVUFBVWxGLEdBQUVFO0lBQUksT0FBSSxxQkFBVkYsR0FBVSxxQkFBUkU7R0FBZ0I7Ozs7Ozs7Ozs7Ozs7OztJQStlTmlGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQTFleEJDLFdBQVNsRixHQUFJLE9BQUpBLEVBQUs7WUFDZG1GLFdBQVNyRixHQUFJLE9BQUpBLEVBQUs7WUFDZHNGLElBQUl0RixHQUFFRSxHQUFJLE9BQUEsc0JBQU5GLEdBQUVFLEdBQVM7WUFDZnFGLGlCQUFpQnZGLEdBQUVFO0lBQUksT0FBRyxzQkFBVEYsR0FBYSxtQ0FBWEU7O2NBQTZDLHNCQUEvQ0YsR0FBRUU7R0FBa0Q7WUFFckVzRixJQUFJeEYsR0FBRUUsR0FBSSxPQUFBLHNCQUFORixHQUFFRSxHQUFTO1lBQ2Z1RixLQUFLckYsSUFBR0MsSUFBSyxPQUFBLHNCQUFSRCxJQUFHQyxJQUFZO1lBTXBCcUYscUJBQXFCMUYsR0FBRTJGLDJCQUN6QixPQUFBLG9CQUR1QjNGLEdBQUUyRjtHQUNVO0dBdkNqQzs7Ozs7Ozs7O0lBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JFVjtPQURBRDs7O09BRUFFOzs7O0lBckJGOzs7Ozs7Ozs7SUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBNklKVSxtQkE1RktDLFVBQUxDO3dCLE9BNEZBRixtQkE1RktDOzt3QixPQTRGTEQsbUJBNUZLQzs7SUFBTCxPQUFBOzthQW1kNEJWOzthQW5kdkJVOzs7O2FBQUxDO0dBUW9CO1lBeTRCdEJDLFlBdjRCT0MsVUFBTEM7d0IsT0FrRkFMLG1CQWxGS0k7SUFBTCxPQUFBLHVDQUFBQztHQUF3RDs7SUF5NEJ0REM7SUFwekJFQztJQUNBQztJQU9BQztZQUNBQyxJQUFJQyxHQUFFdkc7SUFBSSxzQ0FBTnVHLEdBQUV2RztHQUE2QjtZQUVuQ3dHLEdBQUdELEdBQUV2RztJQUFJLHNDQUFOdUcsR0FBRXZHO0dBQTZCO1lBRWxDeUcsTUFBTUYsR0FBRXZHO0lBQUksc0NBQU51RyxHQUFFdkc7R0FBNkI7WUFDckMwRyxZQUFZSCxHQUFFdkc7SUFBSSxzQ0FBTnVHLEdBQUV2RztHQUE2QjtZQUUzQzJHLEtBQUtKLEdBQUV2RztJQUFJLHNDQUFOdUcsR0FBRXZHO0dBQTZCO1lBQ3BDNEcsU0FBU0wsR0FBRXZHLEdBQUU2RztJQUFJLE9BQUEsK0JBQVJOLEdBQUV2Ryx5QkFBRTZHO0dBQStCO1lBQzVDQyxLQUFLUCxHQUFFdkc7SUFBSSxzQ0FBTnVHLEdBQUV2RztHQUE2QjtZQUNwQytHLFNBQVNSLEdBQUV2RyxHQUFFNkc7SUFBSSxPQUFBLCtCQUFSTixHQUFFdkcseUJBQUU2RztHQUErQjtZQUM1Q0csU0FBU1QsR0FBRXZHLEdBQUksT0FBQSw4QkFBTnVHLEdBQUV2RyxHQUE2QjtPQWtCdENpSCwyQkFDQUM7WUFLRkMsZ0JBQWdCQyxNQUFLcEg7SUFDdkIsR0F6QkVnSCxTQXdCZ0JJLE1BQUtwSCxJQUNDLE9BRERBOzs7O0dBQzJEO1lBUWhGcUgsS0FBS0QsTUFBS1QsTUFBS0c7SUFsQ2ZDLFNBa0NLSyxNQUFLVCxNQUFLRztJQUNqQixPQXJDRUYsU0FvQ0tRLE1BQVVOLE1BQUxIO0dBRVc7WUFXckJXLEtBQUtGLE1BQUtHLE9BQU9DO0lBQ25CLElBQUlDLGNBRFFGLFFBRVJHOztVQUFBQTtLQUdTLElBQVBDLFNBckRKYixLQWdES00sTUFDSEs7S0FLRixXQU5pQkQsR0FDZkM7UUFJRUUsV0FMTUosT0FFUkcsd0JBREFELGFBSUVFOztHQUdGO1lBNEJGQyxlQUFlUixNQUFLRyxPQUFPTTtJQUM3QjtLQUFJRDtLQUNBSCxjQUZrQkY7S0FHbEJHOztVQUFBQSxzQkFGQUU7S0FJUyxJQUFQRCxTQXpGSmIsS0FvRmVNLE1BRWJLO0tBY0MsR0FBQSxvQkE3R0huQixJQTZGZWMsTUFFYkssYUFGeUJJO01BaUJRLFdBaEJqQ0QsbUJBZ0JpQyxPQTVHbkNwQixHQTJGZVksTUFFYks7TUFEQUc7T0FnQnFCOztRQVpuQkQsV0FMZ0JKLE9BR2xCRyx3QkFEQUQsYUFHRUU7O0dBZVM7R0FZakIsU0FzQklHLE1BQUF0RixHQUFBLE9BQUFBLE1BQUs7WUFIR3VGLGdCQUFBdkYsR0FBQSxPQUFBQSxNQUFlO1lBQWZ3RixvQkFBQXhGLEdBQUFDLEdBQUFELFFBQUFDLFlBQWU7WUFEZndGLGdCQUFBekYsR0FBQSxPQUFBQSxLQUFlO1lBQWYwRixvQkFBQTFGLEdBQUFDLEdBQUFELE9BQUFDLFlBQWU7WUFIZjBGLE9BQUEzRixHQUFBLE9BQUFBLEtBQU07WUFBTjRGLFdBQUE1RixHQUFBQyxHQUFBRCxPQUFBQyxZQUFNO1lBRmQ0Rix5QkFBQTdGLEdBQUEsT0FBQUEsS0FBd0I7WUFGeEJtRCwwQkFBQW5ELEdBQUEsT0FBQUEsS0FBeUI7WUFEekI4RixjQUFBOUYsR0FBQSxPQUFBQSxLQUFhO1lBRGJ1QyxjQUFBdkMsR0FBQSxPQUFBQSxLQUFhO1lBSGIrRixXQUFBL0YsR0FBQSxPQUFBQSxLQUFVO1lBRlZuQixLQUFBbUIsR0FBQSxPQUFBQSxLQUFJO1lBRkpnRyxNQUFBaEcsR0FBQSxPQUFBQSxLQUFLO2dCQW9CTEEsR0FBQUM7SUFBQSxXQUFBRCxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxPQUFBQztHQUFLO0dBQUw7O0lBQUFnRyw4QkFBQSxTQUFLLG1CQUFMWDtnQkFIUXRGLEdBQUFDO0lBQUEsV0FBQUQsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUMsR0FBQUQ7R0FBZTtHQUFmO0lBQUEsVUFBQXdGO0lBQUFVOzt1QkFBQSxTQUFlOzs7T0FBZlg7O2dCQURBdkYsR0FBQUM7SUFBQTtZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQztZQUFBRDtZQUFBQTtHQUFlO0dBQWY7SUFBQSxVQUFBMEY7SUFBQVM7O3VCQUFBLFNBQWU7OztPQUFmVjs7Z0JBSEF6RixHQUFBQztJQUFBO1lBQUFEO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFDO1lBQUFEO1lBQUFBO1lBQUFBO0dBQU07R0FBTjtJQUFBLFVBQUE0RjtJQUFBUSwrQkFBQSxTQUFNLG9CQUFOVDtnQkFGUjNGLEdBQUFDO0lBQUE7WUFBQUQ7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUM7WUFBQUQ7WUFBQUE7WUFBQUE7WUFBQUE7R0FBd0I7R0FBeEI7O0lBQUFxRzs7dUJBQUEsU0FBd0I7OztPQUF4QlI7O2dCQUZBN0YsR0FBQUM7SUFBQTtZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQztZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtHQUF5QjtHQUF6Qjs7SUFBQXNHOzt1QkFBQSxTQUF5Qjs7O09BQXpCbkQ7O2dCQURBbkQsR0FBQUM7SUFBQTtZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQztZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtHQUFhO0dBQWI7O0lBQUF1Rzs7dUJBQUEsU0FBYTs7O09BQWJUOztnQkFEQTlGLEdBQUFDO0lBQUE7WUFBQUQ7WUFBQUE7WUFBQUE7WUFBQUM7WUFBQUQ7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7R0FBYTtHQUFiOztJQUFBd0c7O3VCQUFBLFNBQWE7OztPQUFiakU7O2lCQUhBdkMsR0FBQUM7SUFBQTtZQUFBRDtZQUFBQTtZQUFBQztZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtHQUFVO0dBQVY7O0lBQUF5RzswQkFBQSxTQUFVLHlCQUFWVjtpQkFGQS9GLEdBQUFDO0lBQUE7WUFBQUQ7WUFBQUM7WUFBQUQ7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7R0FBSTtHQUFKOztJQUFBMEcsNkJBQUEsU0FBSSxtQkFBSjdIO2lCQUZBbUIsR0FBQUM7SUFBQTtZQUFBQTtZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtHQUFLO0dBQUw7O0lBQUEyRyw4QkFBQSxTQUFLLG9CQUFMWDtZQUZKWSxZQUFLQztJQXNCRDtLQVRBQztLQUZBQztLQURBQztLQURBQztLQUhBQztLQUZBQztLQUZBQztLQWFRQztLQUdBQztLQUNBQztLQUdSQztLQUFBQyxVQUFBLG1DQUFBRDtLQXRCSkUsaUNBc0JJRDtLQUhRRSxVQUFBLFdBMk5nQmhGLGFBM05oQjRFO0tBbkJaSyxtQ0FtQllELGVBbkJaRDtLQWtCWUcsVUFBQSxXQTROZ0JsRixhQTVOaEIyRTtLQWxCWlEsbUNBa0JZRCxlQWxCWkQ7S0FlWUcsVUFBQSxzQkFBQVY7S0FmWlcsbUNBZVlELGVBZlpEO0tBYUlHLFVBQUEsbUJBQUFuQjtLQWJKb0IsbUNBYUlELGVBYkpEO0tBV0lHLFVBQUEsd0JBQUFwQjtLQVhKcUIsbUNBV0lELGVBWEpEO0tBVUlHLFVBQUEsbUJBQUFyQjtLQVZKc0IsbUNBVUlELGVBVkpEO0tBU0lHLFVBQUEsc0JBQUF0QjtLQVRKdUIsbUNBU0lELGVBVEpEO0tBTUlHLFVBQUEsV0EySXVCdEcsYUEzSXZCK0U7S0FOSndCLG1DQU1JRCxlQU5KRDtLQUlJRyxVQUFBLHNCQUFBeEI7S0FKSnlCLG1DQUlJRCxlQUpKRDtLQUVJRyxVQUFBLHNCQUFBekI7S0FGSjBCLG1DQUVJRCxlQUZKRDtJQUFBLFdBQUFFOztZQTBCSUMsS0FBS3ZMLEdBQUdzRztJQUFNLElBOVE0QmlDLGFBOFFyQ3ZJLE1BOVFJK0UsZ0JBOFFKL0U7SUE3UUksT0FBQTs7YUFBQTs7ZUFBUyx3QkE2UVZzRyxLQTlRQ3ZCO2VBQWlDd0Q7R0E4UXdDO1lBQ2xGaUQsVUFBVXhMLEdBQUV1TDtJQUFPLElBNVNQckgsTUE0U0ZsRTtZQUFFdUwsZ0JBNVN5QiwwQkFBekJySDtHQTRTNkM7WUFFekR1SCx1QkFBcUJ6TCxHQUFHc0c7SUFDMUIsT0E5UUVaLHFCQTZRd0JZLEtBQUh0RztHQUNpQztZQUd0RDBMLHdCQUF3QjFMLEdBQUcyTDtJQUc3QixPQUFHLG9CQUgwQkE7O2NBSjNCRjtlQUl3QnpMLEdBS08sbUJBTEoyTDtHQUt5QztHQUkxRSxTQU9JQyxPQUFBcEosR0FBQSxPQUFBQSxLQUFNO1lBREVxSixvQkFBQXJKLEdBQUEsT0FBQUEsS0FBbUI7WUFBbkJzSix3QkFBQXRKLEdBQUFDLEdBQUFELE9BQUFDLFlBQW1CO1lBRm5Cc0osUUFBQXZKLEdBQUEsT0FBQUEsS0FBTztZQUFQd0osWUFBQXhKLEdBQUFDLEdBQUFELE9BQUFDLFlBQU87WUFGUDJFLEtBQUE1RSxHQUFBLE9BQUFBLEtBQUk7WUFBSnlKLFNBQUF6SixHQUFBQyxHQUFBRCxPQUFBQyxZQUFJO1lBREp5SixTQUFBMUosR0FBQSxPQUFBQSxLQUFNO1lBQU4ySixhQUFBM0osR0FBQUMsR0FBQUQsT0FBQUMsWUFBTTtpQkFNZEQsR0FBQUMsR0FBQSxXQUFBRCxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQyxHQUFNO0dBQU47O0lBQUEySiwrQkFBQSxTQUFNLHFCQUFOUjtpQkFEUXBKLEdBQUFDLEdBQUEsV0FBQUQsTUFBQUEsTUFBQUEsTUFBQUMsR0FBQUQsTUFBbUI7R0FBbkI7SUFBQSxXQUFBc0o7SUFBQU87O3VCQUFBLFNBQW1COzs7T0FBbkJSOztpQkFGQXJKLEdBQUFDLEdBQUEsV0FBQUQsTUFBQUEsTUFBQUMsR0FBQUQsTUFBQUEsTUFBTztHQUFQO0lBQUEsV0FBQXdKO0lBQUFNOzBCQUFBLFNBQU8sc0JBQVBQO2lCQUZBdkosR0FBQUMsR0FBQSxXQUFBRCxNQUFBQyxHQUFBRCxNQUFBQSxNQUFBQSxNQUFJO0dBQUo7SUFBQSxXQUFBeUo7SUFBQU0sNkJBQUEsU0FBSSxtQkFBSm5GO2lCQURBNUUsR0FBQUMsR0FBQSxXQUFBQSxHQUFBRCxNQUFBQSxNQUFBQSxNQUFBQSxNQUFNO0dBQU47SUFBQSxXQUFBMko7SUFBQUs7MEJBQUEsU0FBTSx1QkFBTk47WUFzQlJPLFNBQVN6TSxHQUFJLE9BQUEscUJBQUpBLFNBQWdCO1lBQ3pCME0sV0FBVzFNLEdBQUksT0FBSkEsZ0JBQXlCO1lBQ3BDMk0sa0JBQWdCM00sR0FBSSx3QkFBSkEsZUFBc0M7WUFDdEQ0TSxrQkFBZ0I1TTtJQUFvQyxXQUZwRDBNLFdBRWdCMU07SUFBMEIsd0JBQTFCQTtHQUFxRDtZQUVyRTZNLGNBQWM3TSxHQUFHd0g7SUFDaEIsV0FBQSxxQkFEYXhIO0lBQ2I7S0FHRDtNQURJb0gsT0FIVXBIO01BSVY0TCxTQUpVNUw7YUFJVjRMOzs7VUFDSmxGOztPQUNjLElBQVJvRyx5QkFGRmxCLFFBQ0psRixpQkFBQUE7T0FFSyxHQUFBLHFCQURDb0c7WUFHRWhGLFFBSEZnRixrQkFHRWhGOzthQUNKaUY7O1VBQ1ksSUFBTkMsdUJBRkZsRixPQUNKaUYsZ0JBQUFBO2lCQUVTLFdBdk5YM0csU0FzTlE0RyxNQXJKUjFGLEtBNklFRixNQVFNNEYsS0FYT3hGO1VBVWIsV0FBQXVGO3NCQUFBQTtjQUFBQTs7OztPQUxKLFdBQUFyRzttQkFBQUE7V0FBQUE7Ozs7Ozs7O0dBU0s7WUE0Q0x1RywrQkFBa0MxSyxZQUFZd0M7SUFDckMsSUFBUDFELE9BenhCRmxCLFNBd3hCa0NvQyxZQUFZd0M7SUFFN0MsR0FBQSxrQkFEQzFELE1BdndCRnhCO0lBMHdCaUIsV0FsWmZnRixTQStZQXhEO0lBR2UsT0FBQTtHQUFtQjtZQW9IcEM2TCxVQUFTbE47SUFDWCxHQXhMRXlNLFNBdUxTek0sSUFFTixPQUFBLFdBaFlEbUc7SUFpWVEsS0FBQSxXQWhZUkMsU0E2WE9wRyxjQUFBQTtJQU9tQjtLQUR4Qm9ILE9BTktwSDtLQU9MbU4sNEJBQTRCLFdBclk5QmhIO0tBc1lFaUg7S0FDQTFHO0tBQ0EyRyxlQWhNSlgsV0FzTFMxTTs7S0FXSCxLQUFBLHFCQUZGMEcsZ0JBQ0EyRztNQVZLck4sT0FPTG1OO01BUEtuTixPQVFMb047YUFSS3BOOztLQVlLO2FBSFYwRztNQUdFb0cseUJBWkc5TTtLQWFKLEdBQUEsc0JBREM4TSxVQUpGTTtNQUNBMUcsaUJBQ0EyRzthQU9NLHFCQUxKUDtNQUhGcEc7O01BY0U7T0FGRW9CLFFBVEZnRjtPQVVFUTthQWpQTjdCLHVCQXVPSXFCLE9BY1Usa0JBZFZBLFVBWkc5TTtPQTRCRHVOLGFBMVBOaEMsS0EwT0l1QixPQVVFUTs7a0JBTUFDO09BR0YsS0FBQSxXQTVaSm5ILDBCQWtaTTBCOztPQVdDLEtBQUEsc0JBVkR3RixpQkFkSkY7O09Bb0JJRyxZQXpQTi9CLFVBeU9Jc0IsT0FnQkVTO09BTkFELGtCQXhnQk5oSSxJQXdnQk1nSSxpQkFWRlI7O01BeUJVLFdBVFJTLFdBU0FoRyx5QkFoQkFPO2FBaUJHLFdBbmFUMUIsU0FrYU1tQjtPQUlhLElBQVhHLHFCQUNBRCxjQUxGRjs7YUFJRUc7UUFHZ0IsSUFBZDhGLGNBamFWbEgsSUEyWEVjLE1Bb0NNSztRQUdDLEdBQUEsc0JBREMrRixhQXBDUko7U0FEQUQsMkJBbUNNMUY7U0FsQ04yRiwyQkFvQ1FJOztRQUtPLElBQVA3RixTQTdaVmIsS0FrWEVNLE1Bb0NNSzs7O1NBWTBCLEdBTHhCRSxXQVpKSixXQWlCNEIscUJBN0NoQ2Isb0JBaUNNZSxhQU9FRTtTQVJGRDs7OztNQWhDTmhCOzs7R0FzRE07WUFtQlYrRyxRQUFRQyxPQXBaZ0JDO0lBcVoxQjtLQXJaa0JwQixTQW9aUm1CO0tBTnFDRSxRQWpjM0N0SCxJQW1EY2lHLFFBQVFvQjtLQXVabEIsT0FBQSxzQkFUdUNDLE9BalE3Q2pCLGtCQXVRUWU7S0FHRjtjQUFzQyxzQkFUQ0UsT0FoUTdDaEIsa0JBc1FRYzs7S0EzTkcsSUFKVHRHLE9BK05Nc0csVUEzTkRsTDtLQXpDUHFLO09Bb1FRYTtnQkExTm1CVjtRQUN0QixXQUZFeEssTUFJYSxPQTVPbEJpRSxNQW9PQVcsTUFLeUI0RjtRQURwQnhLLGVBNU9MOEQsSUF3T0FjLE1BS3lCNEY7O09BS1o7S0FDWjtNQWpCRGEsV0FpQkMsMEJBUElyTDtNQVhMc0wsc0JBaENGbEIsa0JBc1FRYztNQXZPTkssc0JBaENGcEIsa0JBdVFRZTtNQXhPVk07OztTQUxNO1VBREFDO1VBREpDLGlDQUVJaFA7VUFEQWlQLFVBQUEsV0FrSnNCaEosYUFsSnRCOEk7VUFESkcsbUNBQ0lELGVBREpEO1NBQUEsV0FBQUU7O01BVUVDLFVBQUEsNEJBQUFSO01BSEpTLG1DQUdJRCxlQUhKTDtNQUVJTyxVQUFBLFdBMEl3QnBKLGFBMUl4QjJJO01BRkpVLG1DQUVJRCxlQUZKRDtNQUNJRyxVQUFBLFdBMkl3QnRKLGFBM0l4QjRJO01BREpXLG1DQUNJRCxlQURKRDs7OzttQ0E0STRCckosYUExSzFCeUgsa0JBc1FRYzttQ0F4T1ZnQjs7OzttQ0E0STRCdkosYUEzSzFCd0gsa0JBdVFRZTs7OENBNUZrQnZJLGFBc0ZtQnlJOzs7Ozs7OztJQWEzQixJQUFkbEg7O2dCQUFBQTtLQUNFOztPQUFBO29CQWR1Q2tILHdCQU1yQ0Y7O0tBT0poSDs7SUFNTTtLQTljWWlJLGdCQXdjbEJqSTtLQVZzRW9HLHlCQUdsRVksVUFqY2NpQixtQkFBQUE7S0ErY2hCLE9BQUEsc0JBcEJ1Q2YsT0FHNkJkO0tBaUJwRSxjQUF3QyxzQkFwQkRjLE9BRzZCZDs7Ozs7Ozs7OztlQXZVNUUxRCw0QixlQXVVNEUwRDs7OENBekZoRDNILGFBc0ZtQnlJOzs7Ozs7OztJQUc2QmQsV0FBQUE7SUE5YmhEOzBCQTZDVlAsUUFBUW9CLDhCQTdDRmdCO0lBbWRiO0tBQVBwQixTQWxVQWhDLEtBNlN3RXVCLE9BSDdCYztLQXlCM0M5RixRQXRCd0VnRjtLQWpackR2Rix5QkF1YW5CTyxPQURBeUYsWUFBQUE7SUFHRyxHQUFBLFdBcGVIbkgsU0EyRG1CbUI7S0E0YXJCLGlCQUxFTyxPQURBeUYsWUFBQUEsVUF0YXNCSTtLQUZBLE9BTHRCdEcsS0FPY2tGLFFBQVFvQixRQUFBQTs7SUFDYixJQUFQaUIsU0E3Q0ZqSSxLQTRDYzRGLFFBQUtoRjtJQVBuQkYsS0FPY2tGLFFBQ1pxQyxRQURvQmpCO0lBRXhCLE9BVEV0RyxLQU9ja0YsUUFBUW9CLFFBQUhwRztHQTZhYztZQUduQ3NILGlCQUFpQjdPLEdBQUVnTjtJQUNYLElBQU5ZLFFBcGVBdEgsSUFtZWV0RyxNQUFFZ047SUFFbEIsR0FBQSxzQkFEQ1ksT0FEZTVOLE9BQUFBLE9BQUVnTixLQUFGaE4sT0FDZjROO0lBN0JGSCxRQTRCaUJ6TixHQUFFZ047SUFBRmhOLE9BQUFBOztHQU9LO1lBWXRCOE8saUJBQWlCOU8sR0FBR3NHO0lBQ3RCO0tBQUcsT0FBQSxzQkFEbUJBLEtBdFRwQnFHLGtCQXNUaUIzTTtLQUNoQixlQUFxQyxzQkFEbEJzRyxLQXJUcEJzRyxrQkFxVGlCNU07SUFDcUIsV0FBckM7Ozs7cUNBNUl5Qm1GLGFBMUsxQnlILGtCQXFUaUI1TTs7OztxQ0EzSVNtRixhQTNLMUJ3SCxrQkFzVGlCM007OzZDQTNJU21GLGFBMklObUI7Ozs7Ozs7R0FFVTtZQUc5QnlJLGFBQWEvTyxHQWhnQkVzRyxLQUFLRSxJQUFJQztJQTJmeEJxSSxpQkFLYTlPLEdBaGdCRXNHO0lBa2dCZCxHQUFBLFdBL2RHWSxTQTZkU2xILE9BQUFBLE9BRW9DLFdBaGU3Q2lILFNBOGRTakg7SUEvZnFDO0tBRHpDb0gsT0FnZ0JJcEg7S0EvZnFDLE9BQUEsV0FMaERtRztLQUtzQyxPQUFBLFdBTHRDQTtLQXVnQkE2RztPQWxnQmdELCtCQUR6QzVGLE1BQU1kLEtBQUtFLElBQUlDO0lBd2V4Qm9JLGlCQXdCYTdPLEdBR1hnTjtJQUNKLE9BRElBO0dBRUQ7WUFxTERnQyxnQkFBZ0JoUCxHQTlvQkZnTjtJQStvQmhCLElBL29CVzVGLE9BOG9CT3BILE1BNXJCTEssS0E0ckJLTDtJQUVmLEdBOXJCZSxpQ0E4Q0ZnTixLQTlDSDNNO0tBNHJCS0wsT0FJSCxXQWxzQlhtRztJQThyQmNuRyxPQUFBQTtJQVFJO0tBQUEsT0F4ckJsQjBHLFlBa0NPVSxNQUFLNEY7S0FzcEJaRix5QkFSYzlNO0lBUWQ4TSxXQUFBQTtJQUdPO0tBRFBoRixRQUZBZ0Y7S0FHQVMsU0F6aUJBaEMsS0FzaUJBdUIsT0E3ckJBeEcsSUF1Q09jLE1BQUs0RjtLQTBwQlp6Rix5QkFGQU8sT0FDQXlGLFlBQUFBO09BenBCWVAsUUE5QlpsRyxLQThCT00sTUFBSzRGO0tBNnBCRSxXQUFBLFdBN3NCZDdHO0tBNnNCRixpQkFMRTJCLE9BQ0F5RixZQUFBQTtLQUlGOztPQTdwQmNQLFFBMHBCWnpGO0tBSzJDLFdBN3JCM0NULEtBOEJPTSxNQUFLNEY7S0ErcEJlLGlCQVAzQmxGLE9BQ0F5RixZQUFBQTs7SUF4cEIwQixXQS9CMUJ6RyxLQThCT00sTUFBSzRGO0lBN0JaakcsU0E2Qk9LLE1BaENQVCxLQWdDT1MsTUFBSzRGO0lBRWMsV0FsQzFCckcsS0FnQ09TLE1BQUs0RjtJQUVjLE9BakMxQnBHLFNBK0JPUSxNQTlCUE4sS0E4Qk9NLE1BQUs0RjtHQWdxQmU7R0FuNUI3QjtJQUFBOzs7T0F1akIwQjdIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0ExZXhCQztPQUNBQzs7O09BQ0FDO09BR0FFO09BQ0FDOzs7O0lBMDRCSndKO0dBS0osU0FRSUMsZUFBQTFNLEdBQUEsT0FBQUEsS0FBYztZQUROMk0sdUJBQUEzTSxHQUFBLE9BQUFBLEtBQXNCO1lBQXRCNE0sMkJBQUE1TSxHQUFBQyxHQUFBRCxPQUFBQyxZQUFzQjtZQUR0QjRNLHVCQUFBN00sR0FBQSxPQUFBQSxLQUFzQjtZQUF0QjhNLDJCQUFBOU0sR0FBQUMsR0FBQUQsT0FBQUMsWUFBc0I7WUFEdEI4TSxJQUFBL00sR0FBQSxPQUFBQSxLQUFHO1lBQUhnTixRQUFBaE4sR0FBQUMsR0FBQUQsT0FBQUMsWUFBRztZQURYZ04saUJBQUFqTixHQUFBLE9BQUFBLEtBQWdCO1lBRmhCa04sTUFBQWxOLEdBQUEsT0FBQUEsS0FBSztZQURMbU4sT0FBQW5OLEdBQUEsT0FBQUEsS0FBTTtpQkFPTkEsR0FBQUMsR0FBQSxXQUFBRCxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQyxHQUFjO0dBQWQ7O0lBQUFtTjs7dUJBQUEsU0FBYzs7O09BQWRWOztpQkFEUTFNLEdBQUFDLEdBQUEsV0FBQUQsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUMsR0FBQUQsTUFBc0I7R0FBdEI7SUFBQSxXQUFBNE07SUFBQVM7O3VCQUFBLFNBQXNCOzs7T0FBdEJWOztpQkFEQTNNLEdBQUFDLEdBQUEsV0FBQUQsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUMsR0FBQUQsTUFBQUEsTUFBc0I7R0FBdEI7SUFBQSxXQUFBOE07SUFBQVE7O3VCQUFBLFNBQXNCOzs7T0FBdEJUOztpQkFEQTdNLEdBQUFDLEdBQUEsV0FBQUQsTUFBQUEsTUFBQUEsTUFBQUMsR0FBQUQsTUFBQUEsTUFBQUEsTUFBRztHQUFIO0lBQUEsV0FBQWdOO0lBQUFPLDRCQUFBLFNBQUcsa0JBQUhSO2lCQURSL00sR0FBQUMsR0FBQSxXQUFBRCxNQUFBQSxNQUFBQyxHQUFBRCxNQUFBQSxNQUFBQSxNQUFBQSxNQUFnQjtHQUFoQjs7SUFBQXdOOzt1QkFBQSxTQUFnQjs7O09BQWhCUDs7aUJBRkFqTixHQUFBQyxHQUFBLFdBQUFELE1BQUFDLEdBQUFELE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUs7R0FBTDs7SUFBQXlOLDhCQUFBLFNBQUssb0JBQUxQO2lCQURBbE4sR0FBQUMsR0FBQSxXQUFBQSxHQUFBRCxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFNO0dBQU47O0lBQUEwTiwrQkFBQSxTQUFNLHFCQUFOUDtZQWNBUSxxQkFBZ0JuUTtJLG1EQUFBQTs7WUFDaEJvUSxrQkFBZ0JwUSxHQUFJLE9BMXFDbEI4QyxnQkEwcUNjOUMsTUFBbUM7WUFNakRxUSxLQUFHQyxJQXBuQkl0UTtJQW9uQkcsSUFwbkJMdUcsSUFvbkJGK0osT0FwbkIrQixPQXJKaENuSixnQkFxSkdaLE1BQUV2RztJQUEyQixPQXRMaEN3RyxHQXNMR0Q7R0FvbkI4QztZQUNuRGdLLFFBQU1ELElBbm5CSXRRO0lBbW5CRyxJQW5uQkx1RyxJQW1uQkYrSixPQW5uQmtDLE9Bdkp0Q25KLGdCQXVKTVosTUFBRXZHO0lBQThCLE9BdEx0Q3lHLE1Bc0xNRjtHQW1uQmlEO1lBQ3pEaUssYUFBYUYsSUFybkJMdFE7SUFxbkJZLElBcm5CZHVHLElBcW5CTytKLE9Bcm5CdUIsT0F0SmxDbkosZ0JBc0pJWixNQUFFdkc7SUFBNEIsT0F6TGxDc0csSUF5TElDO0dBcW5Cd0Q7WUFJaEVrSyxPQUFLelEsR0FBR3dILEdBQUksSUE5bEJMdEQsTUE4bEJGbEUsTUE5bEJTLE9BakJaNk0sY0FpQkszSSxLQThsQkNzRCxHQUEyQztZQVcvQ2tKLFVBQVF0USxJQUFHQztJQUFLLE9BQXdCLDZDQUFoQ0QsT0FBR0M7R0FBb0M7WUE2Qm5Ec1EsYUFBVUMsV0FBVTVRO0lBQ3RCO0tBeEJJNlEsdUJBdUJrQjdRO0tBeEJsQjhRLFlBd0JrQjlRO0tBekJsQitRLGFBeUJrQi9RO0tBdEJsQmdSLFVBc0JrQmhSO0tBTmxCd0M7SUFsQ0ZpTztNQXdDb0J6UTtlQUxQaVI7T0FBSyxXQURoQnpPLE1BeEJvRCxPQWZwRCtOLFFBNkNrQnZRLEdBTFBpUjtPQURYek8sZUF4Q0E2TixLQThDa0JyUSxHQUxQaVI7O01BQXVDO0lBQ3pDLElBakJUQyxhQWlCUywwQkFGVDFPLE1BdkJFa08sWUFHTlM7O0tBUk07TUFBQUM7TUFEQUM7TUFDQUMsVUFBQSxXQWtDTVYsV0FsQ05RO01BRkpHLGlDQUVJRDtNQURBRSxVQUFBLDRDQUFBSDtNQURKSSxtQ0FDSUQsZUFESkQ7S0FBQSxXQUFBRTs7SUFlRTtLQUFBQyxVQUFBLDRCQUFBUjtLQUxKUyxtQ0FLSUQsZUFMSlA7S0FJSVMsVUFBQSw0Q0FBQVo7S0FKSmEsbUNBSUlELGVBSkpEO0tBR0lHLFVBQUEsb0JBQUFqQjtLQUhKa0IsbUNBR0lELGVBSEpEO0tBRUlHLFVBQUEsNENBQUFsQjtLQUZKbUIsbUNBRUlELGVBRkpEO0tBQ0lHLFVBNXNDSm5QLFlBNHNDSWdPO0tBREpvQixtQ0FDSUQsZUFESkQ7SUFBQSxXQUFBRTtHQTZCNEM7WUFHMUNDLFNBQU9wUyxHQUFJLE9BQUpBLFFBQTBDO1lBQ2pEcVMsV0FBU3JTO0lBQUksV0FEYm9TLFNBQ1NwUztJQUFJLE9BQUE7R0FBWTtZQWV6QnNTLE9BQUt0UyxHQUFJLE9BQUpBLFFBQXdDO1lBRTdDdVMsc0JBQXVCQyxNQUFNMVA7SUFDL0I7S0FueUM0QyxPQUFBLDRDQWt5Q25CMFA7S0FseUNDLE9BQUEsaUNBa3lDSzFQO0lBQ1QsT0FBQTtHQUFtRDtZQUd2RTJQLHVCQUF1QnpTLEdBQUV3UztJQUMzQixPQUxFRCxzQkFJeUJDLE1BQUZ4UztHQUM0QztZQUduRTBTLGVBQWExUyxHQUFFd1M7SUFDakIsR0FBRyw2Q0FEY0EsTUF6N0NmNVM7Ozs7O29FQXk3Q2U0Uzs7Ozs7OztLQUdmOztJQUFBLE9BUEFDLHVCQUlhelMsR0FBRXdTO0dBTVk7WUFHM0JHLDZCQUE2QjNTLEdBQUV3UTtJQUNqQztLQWx6Q3lCa0MsaUJBb3pDdkIscUJBSCtCbEM7S0FqekNWdE0sTUFpekNRbEU7S0FoekM3QixPQUFBLDJCQUR1QjBTLGdCQUFGeE87SUFDckIsT0FBQTtHQW16Q3VDO1lBbUJ2QzBPLG1CQUFtQjVTLEdBQUV3UTtJQUN2QixHQUFHLG9CQURvQkEsY0F4SXJCdkI7OztrREFBQUE7O2tEQXdJcUJ1Qjs7Ozs7Ozs7SUFHcEIsR0FBQSxvQkFIb0JBLGNBQUZ4UTs7dURBQUFBOztrREFBRXdROzs7Ozs7OztJQUlsQixPQTFCSG1DLDZCQXNCbUIzUyxHQUFFd1E7R0FLb0I7WUFHekNxQyw2QkFBNkI3UyxHQUFFc0c7SUFNakMsT0FkRXNNLG1CQVE2QjVTLEdBTVYscUJBTllzRztHQU1FO1lBR2pDd00sb0JBQW9COVM7SUFDWixJQUFOZ04sTUF0akJBRSxVQXFqQmtCbE47SUFFbkIsR0FBQSxXQXA3QkdvRyxTQW03QkY0RyxNQUVDO0lBRU8sSUFBTlksUUEvNkJBdEgsSUFnM0JKZ00sT0EwRG9CdFMsSUFDbEJnTjtJQUtDLE9BQUEsb0JBRENZLE9BTGdCNU47O2tCQVRwQjZTLDZCQVNvQjdTLEdBS2hCNE47R0FHMkM7WUFHL0NtRix3QkFBd0JDO0lBQ2hCLElBQU5oRyxNQWprQkFFLFVBZ2tCc0I4RjtJQUV2QixHQUFBLFdBLzdCRzVNLFNBODdCRjRHOzs7Ozs7Ozs7ZUE1RkYyRCw2QixlQTJGd0JxQzs7Ozs7Ozs7O0lBR2hCLElBQU5wRixRQXg3QkV0SCxJQWczQkpnTSxPQXFFd0JVLFFBQ3RCaEc7SUFHRCxHQUFBLG9CQURDWSxPQUhzQm9GOzs7Ozs7Ozs7ZUEzRnhCckMsNkIsZUEyRndCcUM7Ozs7Ozs7OztJQUtyQixPQXpCSEgsNkJBb0J3QkcsT0FHdEJwRjtHQUc4QjtZQUdoQ3FGLCtCQUErQmpUO0lBQ1gsSUFBbEIrSCxrQkE5dkJBNkUsa0JBNnZCNkI1TTtJQUU5QixHQUFBLG9CQURDK0gsaUJBRDZCL0gsT0FsZ0RpQixPQUloREw7SUFxZ0RzQjs7S0FBQSxPQS9KdEJ5USxrQkF3SitCcFE7S0FPN0IsT0FBQTtLQURBLE9BakVGMlMsNkJBMkQrQjNTLEdBQzdCK0g7SUFNQSxPQUFBO0dBQWdFO1lBR2xFbUwsaUJBQWlCbFQsR0FBSSxPQXh3Qm5CMk0sa0JBd3dCZTNNLE1BQW1EO1lBRXBFbVQsK0JBQStCblQsR0FBSSxPQWhGbkMwUyxlQWdGK0IxUyxHQUFBQSxNQUE2QztZQUM1RW9ULGVBQWVwVCxHQUFFd1M7SUFBTyxPQXhFeEJHLDZCQXdFZTNTLEdBakZmMFMsZUFpRmUxUyxHQUFFd1M7R0FBMkQ7WUFFNUVhLFlBLzdCbUJDLGFBKzdCR3RUOztjQUVsQnVULE1BQU0vTCxHQUFJLE9BQUEsOEJBRlF4SCxHQUVad0gsR0FBNkI7S0FpQ3JCO01BMU5kZ007UUF5TEFEO21CQTNzQm9CdlQ7ZUFoTWJvSCxPQWdNYXBIOztxQkF1RWxCdVQsTUFBTS9MLEdBQUksT0FBQSw4QkF2RVF4SCxHQXVFWndILEdBQTZCO1lBQ2hDLEtBQUEsc0JBNUlQbUYsa0JBb0VzQjNNO2FBd0V0QixNQUFBO1lBQ3VDLFdBN0l2QzJNLGtCQW9Fc0IzTTtZQXlFZixLQUFBLHNCQTVJUDRNLGtCQW1Fc0I1TTthQXlFdEIsTUFBQTtZQWtCSTthQXhMQXlUO2VBb0tBRjswQkFvQlkzSDtrQkFDRCxXQWpLZmMsV0FxRXNCMU07a0JBNEZSLEtBQUE7bUJBQVAsTUFBQTs7Z0NBQzJCMk8sZUFBWTdCO21CQUNyQyxLQUFPLHFCQURrQjZCLGVBQVk3QjtvQkFDckMsTUFBQTs7OzZCQTFGSHlHLE1BQU0vTDtxQkFBSSxPQUFBLDhCQXlGOEJzRixPQXpGbEN0RjtvQkFBaUM7b0JBc0R2QztxQkFqTUFrTTt1QkEySUFIO2tDQXNEWXpMO3dDQWhUV2tGOzJCQWtUWCxlQUFBLFdBeFVoQjVHLFNBc0IyQjRHO3NDQWtUWDs7NEJBaFRoQixLQUxBaEcsU0F5RE9JLE1BdERvQjRGOzZCQUUzQixNQUFBOzs0QkFDQSxXQUhlc0csYUFWZjdNLE1BZ0VPVyxNQXREb0I0Rjs0QkFJbkIsSUFBSjJHLElBVEo3TSxLQTJET00sTUF0RG9CNEY7NEJBS25CLEtBQUEsV0EzQlI1RyxTQTBCSXVOOzZCQUNzQyxXQVoxQ2hOLEtBNkRPUyxNQWxESHVNOzZCQUNpQixLQUFBLGlDQUxNM0c7OEJBSzNCLE1BQUE7Ozs0QkFDUSxJQUFKekcsSUFiSkksS0E2RE9TLE1BdERvQjRGOzRCQU9uQixLQUFBLFdBN0JSNUcsU0E0QklHOzZCQUNzQyxXQVoxQ08sS0EyRE9NLE1BaERIYjs2QkFDaUIsS0FBQSxpQ0FQTXlHOzhCQU8zQixNQUFBOzs7OzJCQUF3RDt5Q0FOakI0Rzs0QixPQTB4QjdDN04sNEIsY0ExeEI2QzZOOzsyQkFBSyxtQ0FEakI1RzsyQkFxVGMsT0ExUXpDMUY7b0NBV09GO29DQXREb0I0Rjs2Q0FxVG1CQTtxQ0FDakMsV0E2QitCRjtxQ0E3QnhCLEtBQUEsc0JBcFVwQnhHLElBb0VPYyxNQStQdUM0RjtzQ0FDakMsTUFBQTs7Z0RBNkIrQkY7cUNBNUJ4QixLQUFBLHNCQXJVcEJ4RyxJQW9FT2MsTUErUHVDNEY7c0NBRWpDLE1BQUE7O2dEQWpFT2hOO3FDQWtFQSxLQUFBLHNCQXRVcEJzRyxJQW9FT2MsTUErUHVDNEY7c0NBR2pDLE1BQUE7O3FDQUNRLFdBMEJ1QkYsVUExQnZCLE9BbFVyQnBHLFlBK0RPVSxNQStQdUM0RjtxQ0FJMUIsR0FBQTtzQ0FDSyxPQUFBLFdBMVRWc0csYUFWZjdNLE1BZ0VPVyxNQStQdUM0RjtxQ0FJakMsTUFBQTs7b0NBQ3lDOzBCQUFFOzBCQVQ3QixPQUFBLDJCQURYbEY7eUJBVXlDO3FCQTNNckQrTDt1QkEySUFOO2tDQStDa0J4TDswQkFBZjsyQkFBZStMLFNBbmJ0QnZPLGlCQTZkNEN1SCxVQUFBQTsyQkExQ3RCaUg7MkJBQUFDOzJCQUFBQzttQ0FBQUMsV0FBQUMsT0FBQUM7MkJBQUEsT0FBQSxzQkFBQUQsT0FBQUM7MEJBQUs7OzttQ0FBTDNVO21DQW9ERTBGO21DQXBERitPO21DQUFBRDttQ0FBQUQ7bUNBQUFEO21DQUFBRDttQ0FBQS9MO3lCQUt1QjtxQkEvTHpDc007dUJBMklBZDtrQ0FzQ1l0TDswQkFDVCxLQUFPLHNCQURFQTsyQkFDVCxNQUFBOzswQkFDRztrQ0FBQSxzQkFGTUE7MEJBRU4sV0FBQTswQkFHQzsyQkFEYXFNLE1BQ2IsZ0JBTEtyTSxpQkFtRDRCNkU7MkJBL0NwQmdIOzJCQUFBUzsyQkFBQVI7MkJBQUFDOzJCQUFBQzttQ0FBQUMsV0FBQU0sT0FBQUM7MkJBQUEsT0FBQSxtQkFBQUQsT0FBQUM7MEJBQVU7OzttQ0FBVmpWO21DQUFBK1U7bUNBQUFMO21DQUFBRDttQ0FBQUQ7bUNBQUFEO21DQUFBRDttQ0FBQVE7eUJBRVE7cUJBdkw1Qkk7dUJBMklBbkI7a0NBOEJZcEw7d0NBR2tDd0wsR0FyT3RDcE07MkJBc09DLEdBQUcsV0FsVGhCbkIsU0E0RVltQixRQXVPTSxPQUZnQ29NOzJCQXBPNUMsSUFBSm5SLFlBQ0FpRixjQUZVRixRQUdWRzs7aUNBQUFBLHNCQWtPZ0RpTSxJQXBPaERuUjs0QkFBQUE7NEJBS1MsSUFBUG1GLFNBakVKYixLQTJET00sTUFFTEs7K0JBSUVFLFdBTlFKOzZCQUdWRzs7NkJBREFELGFBSUVFOzswQkFrTzhDOzBCQUh2QyxXQUFBLDJCQXdEaUNtRjswQkExRDlCLEdBQUEscUJBREUzRTswQkFDVCxNQUFBOzt5QkFLNkM7cUJBWjdCMkwsU0FuQ3pCN0csK0JBb0c4Q0gsVUFBQUE7cUJBcE94QzZIO3VCQTJJQXBCO2tDQXdCbUJxQjs4QkFBQUwsb0JBQUFSLFdBQUFDLGFBQUFDO21DQUFBQyxXQUFBVyxPQUFBQzsyQkFBQSxPQUFBLG1CQUFBRCxPQUFBQzswQkFBVTs7O21DQUFWdlY7bUNBQUFnVjttQ0FBQUw7bUNBQUFEO21DQUFBRDttQ0FBQUQ7bUNBQUFEO21DQUFBYzs7cUJBbktuQkc7dUJBMklBeEI7a0NBaUJZNU47MEJBQ1Q7NEJBQU87dUNBREVBLDJCQXJhZGIsU0E2ZTBDZ0k7OzBCQXZFckMsTUFBQTs7eUJBRzBFO3FCQWhLN0VrSTt1QkEySUF6QjtrQ0Fha0JqTDswQkFBZjsyQkFBZXdMLFNBdGF0QmpQLFNBa2Y0Q2lJOzJCQTVFdEJ5SDsyQkFBQVI7MkJBQUFDOzJCQUFBQzttQ0FBQUMsV0FBQWUsT0FBQUM7MkJBQUEsT0FBQSxtQkFBQUQsT0FBQUM7MEJBQVU7OzttQ0FBVjVWO21DQUFBaVY7bUNBQUFMO21DQUFBRDttQ0FBQUQ7bUNBQUFEO21DQUFBRDttQ0FBQXhMO3lCQUU2QjtxQkExSi9DNk07dUJBMklBNUI7a0NBU1l4TzswQkFDVCxHQUFPLG1CQURFQTswQkFDVCxNQUFBOzt5QkFBNEQ7cUJBSjVDcVEsV0FuYXJCeFEsU0FzZjBDa0k7cUJBcE94Q3VJO3VCQTJJQTlCO2tDQU1tQnFCOzhCQUFBYixXQUFBQyxhQUFBQzttQ0FBQUMsV0FBQW9CLE9BQUFDOzJCQUFBLE9BQUEsV0FyYXpCN1EsV0FxYXlCNFEsT0FBQUM7MEJBQVk7OzttQ0FBWmxXO21DQUFBc0Y7bUNBQUF1UDttQ0FBQUQ7bUNBQUFEO21DQUFBRDttQ0FBQXFCO21DQUFBUjs7cUJBakpuQlk7dUJBMklBakM7a0NBR2dCbFM7MEJBQVEsR0FBTyxxQkFBZkE7MEJBQVEsTUFBQTs7eUJBQWtEO3FCQTlJMUVvVTt1QkEySUFsQztrQ0FFaUIvSzswQkFBUyxHQUFPLHFCQUFoQkE7MEJBQVMsTUFBQTs7eUJBQW1CO29CQTdJN0MsV0FBQWlOLFdBRUp0TTtvQkFGSSxXQUFBcU0sVUFJSnRNO29CQUpJLFdBQUFtTSxnQkFNSnBNO29CQU5JLFdBQUFrTSxtQkFTSm5NO29CQVRJLFdBQUFnTSxtQkFVSmpNO29CQVZJO3NCQUFBZ00sK0JBV0pqTTtvQkFYSTtzQkFBQTZMLDhCQWFKOUw7b0JBYkksV0FBQTZMLFlBZUk5TDtvQkFmSixXQUFBeUwscUJBa0JJMUw7b0JBbEJKLFdBQUFrTCxxQkFtQkluTDtvQkFHUixPQUFBLFdBdEJJZ0wsV0FzQkpqTDttQkFxTDJEO2lDQWpFaEJpTjtvQixPQTFJL0N0TSw0QixlQTBJK0NzTTs7bUJBQVcsb0NBMEZWNUk7bUJBR2xDLFdBQUEscUJBSHNCNkI7bUJBR3RCLFdBQUE7bUJBQ0U7b0JBQUEsT0FKb0JBO29CQUtuQmdILDhCQVBDL0o7b0JBU1UwSSxNQVBvQnhIO29CQU9wQmdILFNBRUwsb0JBSk42QjtvQkFFV3BCO29CQUFBUjtvQkFBQUM7b0JBQUFDOzRCQUFBQyxXQUFBMEIsT0FBQUM7b0JBQUEsT0FBQSxtQkFBQUQsT0FBQUM7bUJBQVU7OztxQkFBVnpXO3FCQUFBbVY7cUJBQUFMO3FCQUFBRDtxQkFBQUQ7cUJBQUFEO3FCQUFBRDtxQkFBQVE7bUJBTVg7b0JBSFd3QixRQVZvQmhKO29CQVVwQnNJLFdBN014QjFKLHdCQW1NNENvQixPQUsvQjZJO29CQUtXbFU7b0JBQUFzVTtvQkFBQUM7NEJBQUFDLGFBQUFDLE9BQUFDO29CQUFBLE9BQUEsc0JBQUFELE9BQUFDO21CQUFLOzs7NEJBQUxoWDs0QkFBQWdHOzRCQUFBOFE7NEJBQUFEOzRCQUFBRDs0QkFBQXRVOzRCQUFBMlQ7NEJBQUFVO2tCQUtnRDtrQkFmN0MsT0FBQSwyQkFGYmxLO2lCQWlCMkQ7YUF6TXZFd0s7ZUFvS0E3QzswQkFhWTFIO2tCQUNUOztvQkFBTztpQ0FERUEscUJBeEpoQmMsa0JBb0VzQjNNO21CQXFGZixNQUFBOztrQkFDTzs7b0JBQUE7aUNBRkU2TCxxQkF2SmhCZSxrQkFtRXNCNU07bUJBc0ZmLE1BQUE7O2tCQUNPLGVBQUEsV0FuV1pvRyxTQTRRb0JwRzs2QkF1RlI7a0JBRUU7b0JBQUEsb0JBTEE2TCxxQkF4VmR2RixJQW9Rb0J0RyxNQUFBQTs7a0JBeUZiLE1BQUE7O2lCQUEwRTthQXRML0VxVztlQW9LQTlDOzBCQU9Zdkc7a0JBQ0YsZUFBQSxXQTNWWjVHLFNBMFZjNEc7NkJBQ0Y7a0JBRUUsS0ExVWRoRyxTQXlQb0JoSCxNQThFTmdOO21CQUdQLE1BQUE7O2tCQUN3QyxXQXRWL0MxRyxJQW9Rb0J0RyxNQThFTmdOO2tCQUlBLEdBQUEsb0JBbEZNaE47a0JBa0ZiLE1BQUE7O2lCQUF3RTthQS9LN0VzVztlQW9LQS9DOzBCQWhUdUJ2VDtzQztrQkFBSSxPQUFBLG9DQUFKQTs7YUE0SXZCMFU7ZUFvS0FuQjswQkFJa0JwTDtrQkFBVSxHQUFPLHFCQUFqQkE7a0JBQVUsTUFBQTs7aUJBQW9CO1lBeEtoRCxXQUFBdU0sWUFDSWxJO1lBREosV0FBQThKLFVBRUkvSjtZQUZKLFdBQUE4SixhQUlJL0o7WUFKSixXQUFBOEoseUJBTUkvSjtZQUNSLE9BQUEsV0FQSW9ILFlBT0pySDtXQWtNNkU7eUJBdEN0Q21LO3FCQWpUbENDLGdCOzthQStJR0MsYUFrSytCRjthQWpUdkNHLFdBaVR1Q0g7YUEvSi9CSSxjQStKK0JKO2FBN0ovQkssMEJBNkorQkw7YUE1SnZDTSxhQTRKdUNOO2FBbkszQ087Z0MsT0ExQ0UxTixZQXBHT29OO1lBcUpMO2FBQUFPLFVBQUEsNEJBQUFGO2FBUEpHLG1DQU9JRCxlQVBKRDthQU1ZRyxVQUFBLFdBOExrQjlSLGFBOUxsQnlSO2FBTlpNLG1DQU1ZRCxlQU5aRDthQUlZRyxVQThuQlpwUixZQWh4QlN5USxVQWtKR0c7YUFKWlMsbUNBSVlELGVBSlpEO2dDLE9BbkxFdFIsbUJBcUNPNFE7WUFBTDthQWdKUWEsVUFoSlIsb0NBQUFYO2FBOElKWSxtQ0FFWUQsZUFGWkQ7YUFDWUcsVUFBQSxzQkFBQWQ7YUFEWmUsbUNBQ1lELGVBRFpEO1lBQUEsV0FBQUU7O1dBbUt5RCxPQUFBLG9DQXRFL0J4WDs7TUFraEJwQnlYO1FBeUxBbEU7bUJBOEJrQnBFO1dBQWY7WUFBZTJFLFNBL0N0QmIsK0JBZXNCalQ7WUFnQ0F1VTtZQUFBUjtZQUFBQztZQUFBQztvQkFBQUMsV0FBQXdELE9BQUFDO1lBQUEsT0FBQSw2Q0FBQUQsT0FBQUM7V0FBUzs7O29CQUFUMVk7b0JBQUFzVjtvQkFBQUw7b0JBQUFEO29CQUFBRDtvQkFBQUQ7b0JBQUFEO29CQUFBM0U7VUFFNkI7TUF6Ti9DeUk7UUF5TEFyRTttQkF5QmtCbEU7V0FBZjtZQUFleUUsU0EvRXRCbEIsbUJBb0RzQjVTLEdBTHRCa1QsaUJBS3NCbFQ7WUEyQkF1VTtZQUFBUjtZQUFBQztZQUFBQztvQkFBQUMsV0FBQTJELE9BQUFDO1lBQUEsT0FBQSw2Q0FBQUQsT0FBQUM7V0FBUzs7O29CQUFUOVk7b0JBQUF1VjtvQkFBQUw7b0JBQUFEO29CQUFBRDtvQkFBQUQ7b0JBQUFEO29CQUFBekU7VUFFc0M7TUFwTnhEMEk7UUF5TEF4RTttQkFnQlloRTtXQUNULEtBQU8sNkNBREVBLEtBbEJNdlA7WUFtQmYsTUFBQTtXQUNPLEtBQUEsNkNBRkV1UCxLQS9oRGhCNVA7WUFpaURPLE1BQUE7V0FJSSxJQUFBLE9BcnlCVGdOLGtCQTZ3Qm9CM00sT0F1QlgsT0ExR1gwUyxlQW1Gc0IxUyxHQUFBQTtXQXFCUixHQUFBO1dBQVAsTUFBQTtVQUdzRDtNQS9NekRnWTtRQXlMQXpFO21CQVlrQjlEO1dBSGY7WUFBZTZFLE1BOUZ0QjVCLGVBbUZzQjFTLEdBN2dEdEJMO1lBd2hEc0I0VTtZQUFBUjtZQUFBQztZQUFBQztvQkFBQUMsV0FBQStELE9BQUFDO1lBQUEsT0FBQSxxQkFBQUQsT0FBQUM7V0FBYzs7O2FBQWRuWjthQUFBd1Y7YUFBQUw7YUFBQUQ7YUFBQUQ7YUFBQUQ7YUFHQXRFO2FBSEE2RTtXQUtiO1lBRmF3QixRQWpHdEJwRCxlQW1Gc0IxUyxHQXBEdEI0UyxtQkFvRHNCNVMsR0FjQXlQO1lBQUEwSTtZQUFBMVc7WUFBQXNVO1lBQUFDO29CQUFBQyxhQUFBbUMsT0FBQUM7WUFBQSxPQUFBLHFCQUFBRCxPQUFBQztXQUFjOzs7b0JBQWR2WjtvQkFBQXFaO29CQUFBbEM7b0JBQUFEO29CQUFBRDtvQkFBQXRVO29CQUFBZ087b0JBQUFxRztVQUUyQztNQXZNN0R3QztRQXlMQS9FO21CQUlZN0Q7V0FDVCxLQUFPLDZDQURFQSxPQWxoRGhCOVA7WUFtaERPLE1BQUE7V0FDTyxHQUFBLDZDQUZFOFAsT0FuaERoQi9QOztXQXFoRE8sTUFBQTtVQUFzQztNQS9MekM0WSxhQXlMQWhGLE1BdDBDRjFQO0tBNm9DRSxXQUFBMFUsWUFDSnJJO0tBREksV0FBQW9JLFdBRUpySTtLQUZJLFdBQUErSCxzQkFJSmhJO0tBSkksV0FBQStILFNBS0loSTtLQUxKLFdBQUE2SCw0QkFNSTlIO0tBTkosV0FBQTJILDRCQU9JNUg7S0FDUixXQVJJMkQsb0JBUUo1RDtLQW1OVSxPQS9MVmE7Y0EySnNCelE7dUJBb0NQaVI7ZUFDYjtnQkFHSSxPQTNITnlCLGVBbUZzQjFTLEdBaktwQnFRLEtBaUtvQnJRLEdBb0NQaVI7Z0JBR1QsT0F0TUpULGFBK0pvQnhRLEdBb0NQaVI7ZUFDTixLQUFBO2dCQUFQLE1BQUE7O2VBS3VEO2dCQUFBLE9BNUN6RG1DLGVBRXNCcFQsR0FBQUE7Z0JBMENILE9BNUNuQm9ULGVBRXNCcFQsR0FqS3BCcVEsS0FpS29CclEsR0FvQ1BpUjtlQUtOLEtBQUE7Z0JBQVAsTUFBQTs7ZUFFOEQ7Z0JBQUEsT0FsTmhFYixrQkF1S3NCcFE7Z0JBMkNxQixPQUFBLDRDQTNDckJBO2dCQTJDRSxPQTVNdEJxUSxLQWlLb0JyUSxHQW9DUGlSO2VBT04sR0FBQTs7ZUFBUCxNQUFBO2NBQW1GO0lBQUM7a0JBMUMvQ3VIO0ssT0FwSHZDN0gsNkIsZUFvSHVDNkg7O0lBQUssT0FBQSxvQ0FEdEJ4WTtHQTJDaUU7T0FHdkZ5WTtZQUVBQyxjQUFjMVksR0FBRzJZLElBQUtDO0lBQ3JCLFdBQUEsNkNBRGdCRCxJQUFIM1k7SUFDYjtLQURhQSxPQUFHMlk7S0FJUCxJQTlhb0JFLG9CQW1TOUJwRyx1QkF1SWN6UyxHQUFHMlk7S0FBSDNZLE9BMUhkMlMsNkJBMEhjM1MsR0ExYWdCNlk7U0FBSDNVLE1BMGFibEU7S0F6YVgsR0FBQSxzQkFEMkI2WSxtQkFuWjVCbE0sa0JBbVp5QnpJOzs7TUFPUDtPQUFkd0M7T0FDQW9TO09BQ0FuTixpQ0FBaUMsbUJBVFRrTjtPQVV4QmpOLFNBVnFCMUg7T0FXckJtSixlQS9aSlgsV0FvWnlCeEk7O09BWW5CLEtBQUEscUJBTEZ3QyxnQkFJQTJHO1FBb0JELEdBQUEsc0JBL0J5QndMLG1CQUFIM1U7U0FBQUEsU0FtQ1YsV0EvbkJiaUM7U0E0bEJ1QmpDLFNBblp6QnlJLGtCQW1aeUJ6STs7b0JBUXJCNFU7OztPQUtVO2VBTlZwUztRQXhETG9HLHlCQTJES2xCO1FBSUVtTix5QkEvRFBqTTtRQUNBa00sK0JBeURLck47UUFyREZzTjtVQXpZQXZOLHdCQW9ZSG9CLE9BQ0FrTTtRQVVHRTtVQW5aQXpOO1lBd1lIcUI7WUFlSzs7Y0FWRm1NO2NBWUssa0JBakJSbk0sVUFpRDBCNUk7UUE5QnZCaVYsOEJBUkFEO1FBU0EzTCxhQS9aQWhDLEtBMllIdUIsT0FtQkdxTTtRQUVBN1EsZ0JBckJId0U7UUFzQkdoRixRQXRCSGdGOztRQXVCSzs7VUFBQTt1QkFKRnFNLDRCQWRBRjs7UUFtQkMsR0FBQSxxQkF4QkpuTTtTQW1CR3FNLDZCQWRBRjs7U0F5Qlk7aUJBVloxTDtVQS9DMENoRyx5QkFpRDFDTztnQkFTTyxXQXprQlAxQixTQStnQjBDbUI7VUE0RHZCLElBQUEsT0FBQSxXQTVrQm5CcEIsbUJBK2pCQW9IO1VBYUUsaUJBWEZ6RjtVQTlDVSxJQURWVixPQTBFdUJsRCxRQXpFdkJ1RCxjQUgwQ0YsUUFJMUNHOztnQkFBQUE7V0FJUyxJQUFQQyxTQXRnQkZiLEtBZ2dCQU0sTUFDQUs7V0F3QkhxRixXQUFBQTtXQWpCSSxHQUFBLHNCQWpoQkR4RyxJQXlnQkFjLE1BQ0FLLGFBeUUwQm9SO1lBNUk1QnBMLFFBNEl5QnZKLEtBekV2QnVEOztZQXlFdUJ2RCxTQUFBQTtZQTlEdkIsV0F3ZWtCMFUsZ0JBbmZsQm5SO1lBWUEsV0F2aEJBcEIsTUEwZ0JBZSxNQUNBSzs7Y0FLRUUsV0FSd0NKLE9BSTFDRyx3QkFEQUQsYUFLRUU7OztTQXVDRjRGLFlBOVpBL0IsVUEwWUhzQixPQW9CR1M7U0FEQTRMO1VBanJCQTVULGlCQWlyQkE0VCw0QkFFQTdROzs7T0FyQkh3RSxXQUtHbU07T0FMSG5NLFlBOXBCR3ZILGlCQW1xQkEwVCx5QkFMSG5NO09Bc0VNLEdBQUEsb0JBdEVOQSxVQStET2lNLHlCQVBGclMsaUJBSUEyRyxjQUhBeUw7O1FBREFwUyxpQkFBQUE7UUFFQWlGLGdDQTFETG1COzs7O2VBMmRhOU0sT0EvRGRpVCwrQkErRGNqVDtnQkFGZHlZOzs7OztHQW1CK0Q7WUFHL0RXLCtCQUFpQ3BaLEdBQUcyWSxJQUFLVTtJQUM3QixJQUFWdE4sVUE3cEJBbUIsVUE0cEIrQmxOO0lBRWhDLEdBQUEsV0EzaENHb0csU0EwaENGMkY7S0FFb0MsT0F2QnRDMk07Y0FvQmlDMVk7Y0FBRzJZOztlQUdZLE1BQUE7Y0FBWTtJQUVsRCxJQUFOL0ssUUF0aENBdEgsSUFnM0JKZ00sT0FpS2lDdFMsSUFDL0IrTCxVQU9tQixPQWhJckI2RyxtQkF3SGlDNVMsR0FLN0I0TjtJQUdELEdBQUEsNkNBUmlDK0s7S0FTSSxPQTdCeENEO2NBb0JpQzFZO2NBQUcyWTs7ZUFTYyxNQUFBO2NBQVk7SUFHMUM7S0FBQSxPQWg4QmhCL1EsZUFteEJKMEssT0FpS2lDdFMsSUFDL0IrTCxTQUlFNkI7S0FNRTBMLE9BQ0YsNkNBWmdDWDtJQWNsQyxPQWxDRkQsY0FvQmlDMVksR0FXM0JzWixNQVhtQ0Q7R0FjSDtZQUd0Q0UsU0FBUTVKLFFBQVFEO0lBQ2xCO01BQUc7O1FBRGVBOzs7Ozs7OzsyREFBQUE7Ozs7Ozs7S0FHaEI7O1FBemFJbk4sYUFzYUlvTixXQXRnQ082SixhQXNnQ1A3SjtrQkEzWkFuSCxjQUVDakc7S0FISDtNQUU2Q3FKO01BQTNCNk47TUFBZjFVO01BR0R1RCxnQkE1eEJKekQsU0F5eEJLRTtNQUlEc0Q7UUEvWU40RSwrQkE0WU8xSyxZQURBd0M7TUFPRFksNEJBM3hCRmIsU0FveEJHQztNQVFEa0Q7UUFud0JKdkM7VUEydkJvQitULDJCQU9oQjlUO01BMXdCY29DO1FBRGxCeEMsaUJBNHdCSTBDLGlCQUpBSTtNQXdCSSxPQUFBLFdBN3FCUmxDO01BNHFCK0IsT0FsckNqQzVGLEtBd3BDT2dDO01BMEJRLE9BQUE7TUFEUCxPQUFBO01BWkZ1Szs7U0FmQXRFO1NBRUNqRztTQTl4QkhxQyxTQTh4QkdyQztTQURBd0M7U0FHRHVEO1NBSUEzQztTQUhBMEM7O1NBSUFKO1NBM3dCY0Y7O01Bb3lCaEIsV0FuQkUrRSxPQWQyQ2xCO01BbndCdEI7UUFBQSxzQkFBUDdEOztXQUF5QyxtQkFBekNBO0tBa3lCbEIsV0Fsc0NGNUgsU0FvcUNPb0MsWUFEQXdDO0lBaUNlO0lBTWI7S0E5Q0Q2RztPQUNSLDBCQU5Fcko7S0FtRE8sT0FBQSwyQkE5Q0RxSjtLQTRDRSxPQUFBLFdBdHJCUnpGO09BcUNXcVQ7U0FBV3JZLE1BQVhxWSxlQUFBM1csV0FBVzFCOztTQUFYMEI7SUErb0JmO0tBQUE7OztRQS9vQmtDLHNEQUFuQkE7Ozs7OztLQTJnQ2I3Qzs7UUFMTTJQO1FBQVFEO1FBaExoQjZDLHNCQWw3Q0E1UyxVQWttRFFnUTs7O1FBbG1EUmhROztJQXVtREVLLE9BekdGaVQsK0JBeUdFalQ7SUExQ0YwWTtNQTBDRTFZO01BTGMwUDs7T0FtQmlDLE1BQUE7TUFBWTtJQUEvRCxPQWRJMVA7R0FlSDtZQUdDMFosb0JBQW9CMVosR0FBR3dHLElBQUdDO0lBS25CLFdBcktQbU0sbUJBZ0tvQjVTLEdBQUd3RztJQUV2QixPQWhrQkV1SSxhQThqQmtCL08sTUFBR3dHLFVBQUdDO0dBTWpCO1lBbUJUa1QsMEJBQTBCM1osR0FBR3dHO0lBQy9CLEdBQUcsNkNBRDRCQSxJQUFIeEc7Ozs7O29FQUFBQTs7Ozs7b0VBQUd3Rzs7Ozs7Ozs7O0lBRTVCLFdBQUEsNkNBRjRCQSxJQUFIeEc7SUFFekIsV0FBQTs7Ozs7bUVBRnlCQTs7Ozs7bUVBQUd3Rzs7Ozs7Ozs7R0FHaUI7WUFHOUNvVCxNQUFJNVosR0FBR3dHLElBQUdDO0lBTlZrVCwwQkFNSTNaLEdBQUd3RztJQUtDLFdBdk9SaU0sdUJBa09JelMsR0FBR3dHO0lBR1AsT0FobUJFdUksYUE2bEJFL08sWUFBR3dHLElBQUdDO0dBT0Q7WUFHVG9ULE9BQU83WixHQUFFaVI7SUFBUSxJQXhaUi9NLE1Bd1pGbEUsTUF2WkhvSCxPQURLbEQsUUFFTDhJLE1BenFCQTdGLGdCQXdxQkFDLE1BdVpLNko7SUE3YVBqQyxnQkFxQk85SyxLQUVMOEk7SUFDSixPQUFBLFdBOXNCSTNHLE1BNHNCQWUsTUFDQTRGO0dBc1p5RDtZQUM3RDhNLE1BQU05WjtJQUFJLElBOVdGa0UsTUE4V0ZsRSxNQTdXQyxXQXhqQkx5TSxTQXVqQk12STs7S0FBQUE7S0FNTjtNQUZJa0QsT0FKRWxEO01BS0Y2VixvQkFBUy9NLEtBQU0sT0FBQSxXQTN2QmpCM0csTUEwdkJFZSxNQUNTNEYsS0FBZ0M7TUFDekNwQixTQU5FMUg7YUFNRjBIOzs7VUFDSmxGOztPQUNjLElBQVJvRyx5QkFGRmxCLFFBQ0psRixpQkFBQUE7T0FFSyxHQUFBLHFCQURDb0c7UUFBQUE7WUFJRWhGLFFBSkZnRixrQkFJRWhGOzthQUNKaUY7O1VBQ1ksSUFBTkMsdUJBRkZsRixPQUNKaUYsZ0JBQUFBO2lCQUVTLFdBNXdCWDNHLFNBMndCUTRHO1dBMXNCUjFGLEtBZ3NCRUYsTUFVTTRGLEtBVE4rTTtXQWEwQixXQUFBLFdBaHhCNUI1VDtXQWd4Qk0saUJBTkEyQixPQUNKaUYsZ0JBQUFBOztVQUFBLFdBQUFBO3NCQUFBQTtjQUFBQTs7OztPQU5KLFdBQUFyRzttQkFBQUE7V0FBQUE7Ozs7Ozs7O0dBdVc2QztZQUMvQ3NULElBQUloYSxHQUFFaVIsT0FBUSxJQWpiUi9NLE1BaWJGbEUsTUFqYlUsT0F4cUJWZ0gsU0F3cUJFOUMsUUFpYkErTSxPQUFpRDtZQUV2RGdKLGVBQWVqYSxHQUFFaVIsT0FybUNEM0ssS0FFREU7SUFvbUNqQixPQUhFd1QsSUFFZWhhLEdBQUVpUixRQUVkO0lBdEJIMEksMEJBb0JlM1osR0FubUNBd0c7UUF3dUJOdEMsTUEyWE1sRTtJQWhuQmI4TyxpQkFxUE81SyxLQTF1Qk9vQztJQTZ1Qk4sSUEzdUJDYyxPQXd1QkZsRCxRQXh1Qkk4SSxNQWdDVDdGLGdCQWhDT0MsTUFtbUNNNko7SUFqYmZqQyxnQkFzRE85SyxLQXh1Qkk4STtJQUZPLCtCQUVUNUYsTUFBRTRGLDJCQUZHMUc7SUFFRywrQkFBUmMsTUFBRTRGLDJCQUFFeEc7SUE4dUJmLE9BOVFFcUksaUJBd1FPM0ssS0F4dUJJOEk7R0F1bUNzQztZQUduRGtOLFdBQVdsYSxHQUFFaVIsT0FBT3pLO0lBQUssT0FQekJ5VCxlQU9XamEsR0FBRWlSLE9BdlBid0IsdUJBdVBXelMsR0FBU3dHLEtBQUFBO0dBQWtFO1lBRXRGMlQsMkJBQTJCbmEsR0FBRWlSLE9BQU96SztJQUN0QyxPQVZFeVQsZUFTMkJqYSxHQUFFaVIsT0FBT3pLLElBdE5wQ29NLG1CQXNOMkI1UyxHQUFTd0c7R0FDc0I7WUFHMUQ0VCx1QkFBdUJwYTtJQUNmLElBQU5nTixNQS92QkFFLFVBOHZCcUJsTjtJQUV0QixPQUFBLFdBN25DR29HLFNBNG5DRjRHLGVBcG5DRTFHLElBZzNCSmdNLE9BbVF1QnRTLElBQ3JCZ047R0FDMkU7WUFHN0VxTiwyQkFBMkJDO0lBQ25CLElBQU50TixNQXB3QkFFLFVBbXdCeUJvTjtJQUUxQixLQUFBLFdBbG9DR2xVLFNBaW9DRjRHLE1BT0MsT0Fob0NDMUcsSUFnM0JKZ00sT0F3UTJCZ0ksUUFDekJ0Tjs7Ozs7Ozs7O2NBL1JGMkQsNkIsZUE4UjJCMko7Ozs7Ozs7O0dBUUs7WUFHaENDLHVCQUF1QnZhLEdBbmpDQ3VIO0lBb2pDMUI7S0FwakNxQkgsT0FneUJuQmtMLE9BbVJ1QnRTO0tBbmpDUTZILFdBaEYzQnZCLElBZ0ZlYyxNQUFLRztLQUNsQmlUO0tBQ0EvUyxjQUZrQkY7S0FHbEJHOztVQUFBQSxzQkFGQThTO0tBSVMsSUFBUDdTLFNBNUVKYixLQXVFZU0sTUFFYks7S0FJQyxHQUFBLG9CQXRGSG5CLElBZ0ZlYyxNQUViSyxhQUZ5Qkk7TUFPUSxXQU5qQzJTLG1CQU1pQyxPQXJGbkNoVSxHQThFZVksTUFFYks7TUFEQStTO09BTXFCOztRQUZuQjdTLFdBTGdCSixPQUdsQkcsd0JBREFELGFBR0VFOztHQWdqQ2dFO1lBR3hFOFMsdUJBQXVCemEsR0FBRWdOO0lBQ2hCLElBQVA1RixPQXpSRmtMLE9Bd1J1QnRTO0lBRXNCLE9BN2lDekM0SCxlQTRpQ0ZSLE1BRHVCNEYsS0F4b0NyQjFHLElBeW9DRmMsTUFEdUI0RjtHQUUrQztZQUd4RTBOLCtCQUErQjFhO0lBQ3ZCLElBQU5nTixNQXp4QkFFLFVBd3hCNkJsTjtJQUU5QixPQUFBLFdBdnBDR29HLFNBc3BDRjRHLGVBWEZ1Tix1QkFVK0J2YSxHQUM3QmdOO0dBQzBFO1lBRzVFMk4sK0JBQStCM2E7SUFDdkIsSUFBTmdOLE1BOXhCQUUsVUE2eEI2QmxOO0lBRTlCLE9BQUEsV0E1cENHb0csU0EycENGNEcsZUFYRnlOLHVCQVUrQnphLEdBQzdCZ047R0FDMEU7WUFHNUU0TixpQ0FBbUNDO0lBQzNCLElBQU43TixNQW55QkFFLFVBa3lCaUMyTjtJQUVsQyxHQUFBLFdBanFDR3pVLFNBZ3FDRjRHOzs7Ozs7Ozs7ZUE5VEYyRCw2QixlQTZUbUNrSzs7Ozs7OztLQUluQzs7SUFBQSxPQXhCQU4sdUJBb0JtQ00sT0FDakM3TjtHQU93QjtZQUcxQjhOLGlDQUFtQ0M7SUFDM0IsSUFBTi9OLE1BOXlCQUUsVUE2eUJpQzZOO0lBRWxDLEdBQUEsV0E1cUNHM1UsU0EycUNGNEc7Ozs7Ozs7OztlQXpVRjJELDZCLGVBd1VtQ29LOzs7Ozs7O0tBSW5DOztJQUFBLE9BOUJBTix1QkEwQm1DTSxPQUNqQy9OO0dBT3dCO1lBRzFCZ08saUJBQWlCaGIsR0FBR3FaO0lBQ3RCO0tBN2QyQzlKLE1BNGR4QnZQO0tBNWRtQnNHLE1BdVBwQzRNLGlCQXFPaUJsVDtLQTVkRWtFLE1BNGRGbEU7S0EzZGI4TSx5QkFEZTVJO0tBRWhCLE9BQUEscUJBREM0STtJQUNEO0tBRVU7TUFBUFMsU0E5akJGaEMsS0EyakJBdUIsT0FEZ0N4RztNQUs5QndCLFFBSkZnRjtNQUtFMUYsT0FOYWxEO01BT2JxRCw2QkFGQU8sT0FEQXlGLFlBQUFBO01BSUcsV0FBQSxXQWp1QkxuSCxTQWd1QkVtQjs7TUFHWSxJQUFWRSxjQUhGRixXQUlFRzs7WUFBQUE7T0FHUyxJQURQc0YsTUFIRnZGLFlBSUVFLFNBdHRCTmIsS0E4c0JFTSxNQU9JNEY7VUFDQXJGLFdBUEpKLFVBSUVHLHdCQURBRCxhQUlFRTtPQUVjLFdBL3RCcEJuQixHQXF0QkVZLE1BT0k0RjtPQUdELEdBQUEsbURBaEJnQ3VDO1FBa0JqQyxXQTBjWThKLGNBL2NWck07UUF6Q1JnQyxnQkE0QmlCOUssS0FhVDhJO1FBT0YsV0F0dUJKM0csTUF3dEJFZSxNQU9JNEY7UUFOSnpGLDRCQUZBTyxPQURBeUYsWUFBQUE7Ozs7Ozs7Ozs7O0dBNmRJOzs7Ozs7Ozs7UUE5a0RSL0w7UUE1QkFLO1FBWkFKO1FBNENJWTtRQUFBQTtRQUNBVDtRQWhDSkU7UUFJQUk7UUFIQUg7UUFDQUM7UUFDQUM7UUFFQUU7UUFDQUM7O09BMndDRnVPO09BckRBUjs7V0FJRnBLLGFBRUlHLFFBQ0FtSyxNQUVBRyxjQURBRDtPQWdLRjhDOztRQTE4Q0V2UztRQWRKTjtRQTBKY0k7UUF4SlZmO1FBa0JBbUI7UUEwR0FPO1FBMUhBWjs7UUE0SEpnQztRQUFBSTtRQW9CSWM7UUFhQUU7UUExQkFqQjtRQUxBUDtRQTZDQThCO1FBUEFEO09BcTRDRm1WO09BNVBBbko7T0FYUWI7T0FIUkc7T0F5RUEyQztPQURBRDtPQTlDQTNCO09Bd0VBaUM7T0E4RUFRO09BL0NBTjtPQWtEQVE7T0FrREFzRjtPQW9CQVU7T0E0SkE0QjtPQWhaUTdMO09BMktSK0Q7T0FFQUM7T0E4SUF5RztPQS9CQUY7T0EyQ0FNO09BRkFIO09BV0FLO09BRUFDO09BWkFMO09BZ0JBTTtPQUtBQztPQXFCQUs7T0FLQUM7T0FLQUM7T0FXQUU7T0F4UEFoSTtPQVdBQztXQXIvQ0FwVCxVQWs3Q0E0UywyQkF2NUNFeFM7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgVGltaW5nX3doZWVsLkltcG9ydCAqKVxubW9kdWxlIEltcG9ydCA9IFRpbWluZ193aGVlbF9fSW1wb3J0XG5cbigqKiBAY2Fub25pY2FsIFRpbWluZ193aGVlbC5UaW1pbmdfd2hlZWxfaW50ZiAqKVxubW9kdWxlIFRpbWluZ193aGVlbF9pbnRmID0gVGltaW5nX3doZWVsX19UaW1pbmdfd2hlZWxfaW50ZlxuXG5tb2R1bGUgVGltaW5nX3doZWVsX18gPSBzdHJ1Y3QgZW5kXG5bQEBkZXByZWNhdGVkIFwidGhpcyBtb2R1bGUgaXMgc2hhZG93ZWRcIl1cbiIsIigqIEJlIHN1cmUgYW5kIGZpcnN0IHJlYWQgdGhlIGltcGxlbWVudGF0aW9uIG92ZXJ2aWV3IGluIHRpbWluZ193aGVlbF9pbnRmLm1sLlxuXG4gICBBIHRpbWluZyB3aGVlbCBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBcImxldmVsc1wiLCB3aGVyZSBlYWNoIGxldmVsIGlzIGFuIGFycmF5IG9mXG4gICBcInNsb3RzXCIuICBFYWNoIHNsb3QgcmVwcmVzZW50cyBhIHJhbmdlIG9mIGtleXMsIGFuZCBob2xkcyBlbGVtZW50cyBhc3NvY2lhdGVkIHdpdGhcbiAgIHRob3NlIGtleXMuICBFYWNoIGxldmVsIGlzIGRldGVybWluZWQgYnkgdHdvIHBhcmFtZXRlcnM6IFtiaXRzXSwgdGhlIG51bWJlciBvZiBrZXkgYml0c1xuICAgdGhhdCB0aGF0IGxldmVsIGlzIHJlc3BvbnNpYmxlIGZvciBkaXN0aW5ndWlzaGluZywgYW5kIFtiaXRzX3Blcl9zbG90XSwgdGhlIHNpemUgb2YgdGhlXG4gICByYW5nZSBvZiBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBhIHNpbmdsZSBzbG90IGluIHRoZSBhcnJheS4gIENvbmNlcHR1YWxseSwgZWFjaCBsZXZlbFxuICAgYnJlYWtzIHVwIGFsbCBwb3NzaWJsZSBrZXlzIGludG8gcmFuZ2VzIG9mIHNpemUgWzJeYml0c19wZXJfc2xvdF0uICBUaGUgbGVuZ3RoIG9mIGFcbiAgIGxldmVsIGFycmF5IGlzIFsyXmJpdHNdLCBhbmQgdGhlIGFycmF5IGlzIHVzZWQgbGlrZSBhIGNpcmN1bGFyIGJ1ZmZlciB0byB0cmF2ZXJzZSB0aGVcbiAgIHJhbmdlcyBhcyB0aGUgdGltaW5nIHdoZWVsJ3MgW21pbl9hbGxvd2VkX2tleV0gaW5jcmVhc2VzLiAgQSBrZXkgW2tdLCBpZiBzdG9yZWQgaW4gdGhlXG4gICBsZXZlbCwgaXMgc3RvcmVkIGF0IGluZGV4IFsoayAvIDJeYml0c19wZXJfc2xvdCkgbW9kIDJeYml0c10uXG5cbiAgIFRoZSBzZXR0aW5ncyBvZiB0aGUgW2JpdHNdIHZhbHVlcyBhcmUgY29uZmlndXJhYmxlIGJ5IHVzZXIgY29kZSB1c2luZyBbTGV2ZWxfYml0c10sXG4gICBhbHRob3VnaCB0aGVyZSBpcyBhIHJlYXNvbmFibGUgZGVmYXVsdCBzZXR0aW5nLiAgR2l2ZW4gdGhlIFtiaXRzXSB2YWx1ZXMsIHRoZVxuICAgW2JpdHNfcGVyX3Nsb3RdIGFyZSBjaG9zZW4gc28gdGhhdCBbYml0c19wZXJfc2xvdF0gYXQgbGV2ZWwgW2ldIGlzIHRoZSBzdW0gb2YgdGhlXG4gICBbYml0c10gYXQgYWxsIGxvd2VyIGxldmVscy4gIFRodXMsIGEgc2xvdCdzIHJhbmdlIGF0IGxldmVsIFtpXSBpcyBhcyBsYXJnZSBhcyB0aGVcbiAgIGVudGlyZSByYW5nZSBvZiB0aGUgYXJyYXkgYXQgbGV2ZWwgW2kgLSAxXS5cblxuICAgRWFjaCBsZXZlbCBoYXMgYSBbbWluX2FsbG93ZWRfa2V5XSBhbmQgYSBbbWF4X2FsbG93ZWRfa2V5XSB0aGF0IGRldGVybWluZSB0aGUgcmFuZ2Ugb2ZcbiAgIGtleXMgdGhhdCBpdCBjdXJyZW50bHkgcmVwcmVzZW50cy4gIFRoZSBjcnVjaWFsIGludmFyaWFudCBvZiB0aGUgdGltaW5nIHdoZWVsIGRhdGFcbiAgIHN0cnVjdHVyZSBpcyB0aGF0IHRoZSBbbWluX2FsbG93ZWRfa2V5XSBhdCBsZXZlbCBbaV0gaXMgbm8gbW9yZSB0aGFuIHRoZVxuICAgW21heF9hbGxvd2VkX2tleSArIDFdIG9mIGxldmVsIFtpIC0gMV0uICBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgbGV2ZWxzIGNhbiByZXByZXNlbnQgYWxsXG4gICBrZXlzIGZyb20gdGhlIFttaW5fYWxsb3dlZF9rZXldIG9mIHRoZSBsb3dlc3QgbGV2ZWwgdG8gdGhlIFttYXhfYWxsb3dlZF9rZXldIG9mIHRoZVxuICAgaGlnaGVzdCBsZXZlbC4gIFRoZSBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcmVzdG9yaW5nXG4gICB0aGlzIGludmFyaWFudC5cblxuICAgQXQgbGV2ZWwgMCwgW2JpdHNfcGVyX3Nsb3QgPSAwXSwgYW5kIHNvIHRoZSBzaXplIG9mIGVhY2ggc2xvdCBpcyBbMV0uICBUaGF0IGlzLCBsZXZlbCAwXG4gICBwcmVjaXNlbHkgZGlzdGluZ3Vpc2hlcyBhbGwgdGhlIGtleXMgYmV0d2VlbiBpdHMgW21pbl9hbGxvd2VkX2tleV0gKHdoaWNoIGlzIHRoZSBzYW1lXG4gICBhcyB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgdGhlIGVudGlyZSB0aW1pbmcgd2hlZWwpIGFuZCBbbWF4X2FsbG93ZWRfa2V5XS4gIEFzIHRoZVxuICAgbGV2ZWxzIGluY3JlYXNlLCB0aGUgW21pbl9hbGxvd2VkX2tleV0gaW5jcmVhc2VzLCB0aGUgW2JpdHNfcGVyX3Nsb3RdIGluY3JlYXNlcywgYW5kXG4gICB0aGUgcmFuZ2Ugb2Yga2V5cyBzdG9yZWQgaW4gdGhlIGxldmVsIGluY3JlYXNlcyAoZHJhbWF0aWNhbGx5KS5cblxuICAgVGhlIGlkZWEgb2YgdGhlIGltcGxlbWVudGF0aW9uIGlzIHNpbWlsYXIgdG8gdGhlIGhpZXJhcmNoaWNhbCBhcHByb2FjaCBkZXNjcmliZWQgaW46XG5cbiAgIHt2XG4gICAgIEhhc2hlZCBhbmQgSGllcmFyY2hpY2FsIFRpbWluZyBXaGVlbHM6XG4gICAgIEVmZmljaWVudCBEYXRhIFN0cnVjdHVyZXMgZm9yIEltcGxlbWVudGluZyBhIFRpbWVyIEZhY2lsaXR5XG5cbiAgICAgVmFyZ2hlc2UgJiBMYXVjaywgMTk5NlxuICAgdn1cblxuICAgSG93ZXZlciwgdGhlIGNvZGUgaXMgY29tcGxldGVseSBuZXcuICopXG5cbm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiEgVGltaW5nX3doZWVsX2ludGZcbm1vZHVsZSBQb29sID0gVHVwbGVfcG9vbFxubW9kdWxlIFRpbWVfbnMgPSBDb3JlX3ByaXZhdGUuVGltZV9uc19hbHRlcm5hdGVfc2V4cFxuXG5sZXQgc2V4cF9vZl90X3N0eWxlIDogWyBgUHJldHR5IHwgYEludGVybmFsIF0gcmVmID0gcmVmIGBQcmV0dHlcblxuKCogW3ttYXgsbWlufV90aW1lXSBhcmUgYm91bmRzIG9uIHRoZSB0aW1lcyBzdXBwb3J0ZWQgYnkgYSB0aW1pbmcgd2hlZWwuICopXG5cbmxldCBtYXhfdGltZSA9IFRpbWVfbnMubWF4X3ZhbHVlX3JlcHJlc2VudGFibGVcbmxldCBtaW5fdGltZSA9IFRpbWVfbnMuZXBvY2hcblxubW9kdWxlIE51bV9rZXlfYml0cyA6IHNpZ1xuICB0eXBlIHQgPSBwcml2YXRlIGludCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIGluY2x1ZGUgQ29tcGFyYWJsZSB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgSW52YXJpYW50LlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCB6ZXJvIDogdFxuXG4gICgqIHZhbCBtaW5fdmFsdWUgOiB0ICopXG5cbiAgdmFsIG1heF92YWx1ZSA6IHRcbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICB2YWwgKCArICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAtICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgcG93MiA6IHQgLT4gSW50NjMudFxuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgSW50XG5cbiAgbGV0IG1pbl92YWx1ZSA9IDBcblxuICAoKiogV2Ugc3VwcG9ydCBhbGwgbm9uLW5lZ2F0aXZlIFtUaW1lX25zLnRdIHZhbHVlcy4gKilcbiAgbGV0IG1heF92YWx1ZSA9IEludDYzLm51bV9iaXRzIC0gMVxuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgYXNzZXJ0ICh0ID49IG1pbl92YWx1ZSk7XG4gICAgYXNzZXJ0ICh0IDw9IG1heF92YWx1ZSlcbiAgOztcblxuICBsZXQgb2ZfaW50IGkgPVxuICAgIGludmFyaWFudCBpO1xuICAgIGlcbiAgOztcblxuICBsZXQgKCArICkgdDEgdDIgPVxuICAgIGxldCB0ID0gdDEgKyB0MiBpblxuICAgIGludmFyaWFudCB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgKCAtICkgdDEgdDIgPVxuICAgIGxldCB0ID0gdDEgLSB0MiBpblxuICAgIGludmFyaWFudCB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgcG93MiB0ID0gSW50NjMuc2hpZnRfbGVmdCBJbnQ2My5vbmUgdFxuZW5kXG5cbm1vZHVsZSBMZXZlbF9iaXRzID0gc3RydWN0XG4gIHR5cGUgdCA9IE51bV9rZXlfYml0cy50IGxpc3QgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICBsZXQgbWF4X251bV9iaXRzID0gKE51bV9rZXlfYml0cy5tYXhfdmFsdWUgOj4gaW50KVxuICBsZXQgbnVtX2JpdHNfaW50ZXJuYWwgdCA9IExpc3QuZm9sZCB0IH5pbml0Ok51bV9rZXlfYml0cy56ZXJvIH5mOk51bV9rZXlfYml0cy4oICsgKVxuICBsZXQgbnVtX2JpdHMgdCA9IChudW1fYml0c19pbnRlcm5hbCB0IDo+IGludClcblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIGFzc2VydCAobm90IChMaXN0LmlzX2VtcHR5IHQpKTtcbiAgICBMaXN0Lml0ZXIgdCB+ZjooZnVuIG51bV9rZXlfYml0cyAtPlxuICAgICAgTnVtX2tleV9iaXRzLmludmFyaWFudCBudW1fa2V5X2JpdHM7XG4gICAgICBhc3NlcnQgKE51bV9rZXlfYml0cy4oID4gKSBudW1fa2V5X2JpdHMgTnVtX2tleV9iaXRzLnplcm8pKTtcbiAgICBOdW1fa2V5X2JpdHMuaW52YXJpYW50IChudW1fYml0c19pbnRlcm5hbCB0KVxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHQgPSBzZXhwIHw+IFslb2Zfc2V4cDogdF0gaW5cbiAgICBpbnZhcmlhbnQgdDtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9leG4gPyhleHRlbmRfdG9fbWF4X251bV9iaXRzID0gZmFsc2UpIGludHMgPVxuICAgIGlmIExpc3QuaXNfZW1wdHkgaW50cyB0aGVuIGZhaWx3aXRoIFwiTGV2ZWxfYml0cy5jcmVhdGVfZXhuIHJlcXVpcmVzIGEgbm9uZW1wdHkgbGlzdFwiO1xuICAgIGlmIExpc3QuZXhpc3RzIGludHMgfmY6KGZ1biBiaXRzIC0+IGJpdHMgPD0gMClcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcIkxldmVsX2JpdHMuY3JlYXRlX2V4biBnb3Qgbm9ucG9zaXRpdmUgbnVtIGJpdHNcIiB+XzooaW50cyA6IGludCBsaXN0KV07XG4gICAgbGV0IG51bV9iaXRzID0gTGlzdC5mb2xkIGludHMgfmluaXQ6MCB+ZjooICsgKSBpblxuICAgIGlmIG51bV9iaXRzID4gbWF4X251bV9iaXRzXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIkxldmVsX2JpdHMuY3JlYXRlX2V4biBnb3QgdG9vIG1hbnkgYml0c1wiXG4gICAgICAgICAgICB+XzooaW50cyA6IGludCBsaXN0KVxuICAgICAgICAgICAgfmdvdDoobnVtX2JpdHMgOiBpbnQpXG4gICAgICAgICAgICAobWF4X251bV9iaXRzIDogaW50KV07XG4gICAgbGV0IGludHMgPVxuICAgICAgaWYgZXh0ZW5kX3RvX21heF9udW1fYml0c1xuICAgICAgdGhlbiBpbnRzIEAgTGlzdC5pbml0IChtYXhfbnVtX2JpdHMgLSBudW1fYml0cykgfmY6KGNvbnN0IDEpXG4gICAgICBlbHNlIGludHNcbiAgICBpblxuICAgIExpc3QubWFwIGludHMgfmY6TnVtX2tleV9iaXRzLm9mX2ludFxuICA7O1xuXG4gIGxldCBkZWZhdWx0ID0gY3JlYXRlX2V4biBbIDExOyAxMDsgMTA7IDEwOyAxMDsgMTA7IDEgXVxuXG4gIGxldCB0cmltIHQgfm1heF9udW1fYml0cyA9XG4gICAgaWYgTnVtX2tleV9iaXRzLiggPD0gKSAobnVtX2JpdHNfaW50ZXJuYWwgdCkgbWF4X251bV9iaXRzXG4gICAgdGhlbiB0XG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgdCB+cmVtYWluaW5nID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgW10gLT4gW11cbiAgICAgICAgfCBiIDo6IHQgLT5cbiAgICAgICAgICBpZiBOdW1fa2V5X2JpdHMuKCA+PSApIGIgcmVtYWluaW5nXG4gICAgICAgICAgdGhlbiBbIHJlbWFpbmluZyBdXG4gICAgICAgICAgZWxzZSBiIDo6IGxvb3AgdCB+cmVtYWluaW5nOihOdW1fa2V5X2JpdHMuKCAtICkgcmVtYWluaW5nIGIpXG4gICAgICBpblxuICAgICAgbG9vcCB0IH5yZW1haW5pbmc6bWF4X251bV9iaXRzKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBBbGFybV9wcmVjaXNpb24gOiBzaWdcbiAgaW5jbHVkZSBBbGFybV9wcmVjaXNpb25cblxuICB2YWwgbnVtX2tleV9iaXRzIDogdCAtPiBOdW1fa2V5X2JpdHMudFxuICB2YWwgaW50ZXJ2YWxfbnVtIDogdCAtPiBUaW1lX25zLnQgLT4gSW50NjMudFxuICB2YWwgaW50ZXJ2YWxfbnVtX3N0YXJ0IDogdCAtPiBJbnQ2My50IC0+IFRpbWVfbnMudFxuZW5kID0gc3RydWN0XG4gICgqKiBbdF0gaXMgcmVwcmVzZW50ZWQgYXMgdGhlIGxvZzIgb2YgYSBudW1iZXIgb2YgbmFub3NlY29uZHMuICopXG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZyBjb21wYXJlLCBoYXNoXVxuXG4gIGxldCBlcXVhbCA9IFslY29tcGFyZS5lcXVhbDogdF1cbiAgbGV0IG51bV9rZXlfYml0cyB0ID0gdCB8PiBOdW1fa2V5X2JpdHMub2ZfaW50XG5cbiAgbGV0IHRvX3NwYW4gdCA9XG4gICAgaWYgdCA8IDBcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiW0FsYXJtX3ByZWNpc2lvbi50b19zcGFuXSBvZiBuZWdhdGl2ZSBwb3dlciBvZiB0d28gbmFub3NlY29uZHNcIiB+XzoodCA6IGludCldO1xuICAgIEludDYzLihzaGlmdF9sZWZ0IG9uZSkgdCB8PiBUaW1lX25zLlNwYW4ub2ZfaW50NjNfbnNcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPSBbJXNleHAgKHQgfD4gdG9fc3BhbiA6IFRpbWVfbnMuU3Bhbi50KV1cbiAgbGV0IG9uZV9uYW5vc2Vjb25kID0gMFxuICBsZXQgYWJvdXRfb25lX21pY3Jvc2Vjb25kID0gMTBcbiAgbGV0IGFib3V0X29uZV9taWxsaXNlY29uZCA9IDIwXG4gIGxldCBhYm91dF9vbmVfc2Vjb25kID0gMzBcbiAgbGV0IGFib3V0X29uZV9kYXkgPSA0NlxuICBsZXQgbXVsIHQgfnBvdzIgPSB0ICsgcG93MlxuICBsZXQgZGl2IHQgfnBvdzIgPSB0IC0gcG93MlxuICBsZXQgaW50ZXJ2YWxfbnVtIHQgdGltZSA9IEludDYzLnNoaWZ0X3JpZ2h0ICh0aW1lIHw+IFRpbWVfbnMudG9faW50NjNfbnNfc2luY2VfZXBvY2gpIHRcblxuICBsZXQgaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgaW50ZXJ2YWxfbnVtID1cbiAgICBJbnQ2My5zaGlmdF9sZWZ0IGludGVydmFsX251bSB0IHw+IFRpbWVfbnMub2ZfaW50NjNfbnNfc2luY2VfZXBvY2hcbiAgOztcblxuICBsZXQgb2Zfc3Bhbl9mbG9vcl9wb3cyX25zIHNwYW4gPVxuICAgIGlmIFRpbWVfbnMuU3Bhbi4oIDw9ICkgc3BhbiBUaW1lX25zLlNwYW4uemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJbQWxhcm1fcHJlY2lzaW9uLm9mX3NwYW5fZmxvb3JfcG93Ml9uc10gZ290IG5vbi1wb3NpdGl2ZSBzcGFuXCJcbiAgICAgICAgICAgIChzcGFuIDogVGltZV9ucy5TcGFuLnQpXTtcbiAgICBzcGFuIHw+IFRpbWVfbnMuU3Bhbi50b19pbnQ2M19ucyB8PiBJbnQ2My5mbG9vcl9sb2cyXG4gIDs7XG5cbiAgbGV0IG9mX3NwYW4gPSBvZl9zcGFuX2Zsb29yX3BvdzJfbnNcblxuICBtb2R1bGUgVW5zdGFibGUgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgY29tcGFyZV1cblxuICAgICAgbGV0IG9mX2JpbmFibGUgPSBvZl9zcGFuX2Zsb29yX3BvdzJfbnNcbiAgICAgIGxldCB0b19iaW5hYmxlID0gdG9fc3BhblxuICAgICAgbGV0IG9mX3NleHBhYmxlID0gb2Zfc3Bhbl9mbG9vcl9wb3cyX25zXG4gICAgICBsZXQgdG9fc2V4cGFibGUgPSB0b19zcGFuXG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIFRcbiAgICBpbmNsdWRlIEJpbmFibGUuT2ZfYmluYWJsZV93aXRob3V0X3V1aWQgW0BhbGVydCBcIi1sZWdhY3lcIl0gKFRpbWVfbnMuU3BhbikgKFQpXG4gICAgaW5jbHVkZSBTZXhwYWJsZS5PZl9zZXhwYWJsZSAoVGltZV9ucy5TcGFuKSAoVClcbiAgZW5kXG5lbmRcblxubW9kdWxlIENvbmZpZyA9IHN0cnVjdFxuICBsZXQgbGV2ZWxfYml0c19kZWZhdWx0ID0gTGV2ZWxfYml0cy5kZWZhdWx0XG5cbiAgdHlwZSB0ID1cbiAgICB7IGFsYXJtX3ByZWNpc2lvbiA6IEFsYXJtX3ByZWNpc2lvbi5VbnN0YWJsZS50XG4gICAgOyBsZXZlbF9iaXRzIDogTGV2ZWxfYml0cy50IFtAZGVmYXVsdCBsZXZlbF9iaXRzX2RlZmF1bHRdXG4gICAgOyBjYXBhY2l0eSA6IGludCBvcHRpb24gW0BzZXhwLm9wdGlvbl1cbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycyB+aXRlcmF0b3JzOml0ZXIsIHNleHBdXG5cbiAgbGV0IGFsYXJtX3ByZWNpc2lvbiB0ID0gQWxhcm1fcHJlY2lzaW9uLnRvX3NwYW4gdC5hbGFybV9wcmVjaXNpb25cblxuICAoKiBbbWF4X251bV9sZXZlbF9iaXRzIGFsYXJtX3ByZWNpc2lvbl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGxldmVsIGJpdHMgbmVlZGVkIGZvciBhXG4gICAgIHRpbWluZyB3aGVlbCB3aXRoIHRoZSBzcGVjaWZpZWQgW2FsYXJtX3ByZWNpc2lvbl0gdG8gYmUgYWJsZSB0byByZXByZXNlbnQgYWxsXG4gICAgIHBvc3NpYmxlIHRpbWVzIGZyb20gW1RpbWVfbnMuZXBvY2hdIG9ud2FyZC4gIFNpbmNlIG5vbi1uZWdhdGl2ZSB0aW1lcyBoYXZlIDYyIGJpdHMsXG4gICAgIHdlIHJlcXVpcmUgW0wgPD0gNjIgLSBBXSwgd2hlcmUgW0FdIGlzIHRoZSBudW1iZXIgb2YgYWxhcm0gYml0cyBhbmQgW0xdIGlzIHRoZVxuICAgICBudW1iZXIgb2YgbGV2ZWwgYml0cy4gKilcbiAgbGV0IG1heF9udW1fbGV2ZWxfYml0cyBhbGFybV9wcmVjaXNpb24gPVxuICAgIE51bV9rZXlfYml0cy4oIC0gKVxuICAgICAgTnVtX2tleV9iaXRzLm1heF92YWx1ZVxuICAgICAgKEFsYXJtX3ByZWNpc2lvbi5udW1fa2V5X2JpdHMgYWxhcm1fcHJlY2lzaW9uKVxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgICBhc3NlcnQgKFxuICAgICAgICBOdW1fa2V5X2JpdHMuKCA8PSApXG4gICAgICAgICAgKExldmVsX2JpdHMubnVtX2JpdHNfaW50ZXJuYWwgdC5sZXZlbF9iaXRzKVxuICAgICAgICAgIChtYXhfbnVtX2xldmVsX2JpdHMgdC5hbGFybV9wcmVjaXNpb24pKTtcbiAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgfmFsYXJtX3ByZWNpc2lvbjppZ25vcmVcbiAgICAgICAgfmNhcGFjaXR5Omlnbm9yZVxuICAgICAgICB+bGV2ZWxfYml0czooY2hlY2sgTGV2ZWxfYml0cy5pbnZhcmlhbnQpKVxuICA7O1xuXG4gIGxldCBjcmVhdGUgP2NhcGFjaXR5ID8obGV2ZWxfYml0cyA9IGxldmVsX2JpdHNfZGVmYXVsdCkgfmFsYXJtX3ByZWNpc2lvbiAoKSA9XG4gICAgbGV0IGxldmVsX2JpdHMgPVxuICAgICAgTGV2ZWxfYml0cy50cmltIGxldmVsX2JpdHMgfm1heF9udW1fYml0czoobWF4X251bV9sZXZlbF9iaXRzIGFsYXJtX3ByZWNpc2lvbilcbiAgICBpblxuICAgIHsgYWxhcm1fcHJlY2lzaW9uOyBsZXZlbF9iaXRzOyBjYXBhY2l0eSB9XG4gIDs7XG5cbiAgbGV0IG1pY3Jvc2Vjb25kX3ByZWNpc2lvbiAoKSA9XG4gICAgY3JlYXRlXG4gICAgICAoKVxuICAgICAgfmFsYXJtX3ByZWNpc2lvbjpBbGFybV9wcmVjaXNpb24uYWJvdXRfb25lX21pY3Jvc2Vjb25kXG4gICAgICB+bGV2ZWxfYml0czooTGV2ZWxfYml0cy5jcmVhdGVfZXhuIFsgMTA7IDEwOyA2OyA2OyA1IF0pXG4gIDs7XG5cbiAgbGV0IGR1cmF0aW9ucyB0ID1cbiAgICBMaXN0LmZvbGRpbmdfbWFwXG4gICAgICB0LmxldmVsX2JpdHNcbiAgICAgIH5pbml0OihBbGFybV9wcmVjaXNpb24ubnVtX2tleV9iaXRzIHQuYWxhcm1fcHJlY2lzaW9uIHw+IE51bV9rZXlfYml0cy50b19pbnQpXG4gICAgICB+ZjooZnVuIG51bV9iaXRzX2FjY3VtIGxldmVsX251bV9iaXRzIC0+XG4gICAgICAgIGxldCBudW1fYml0c19hY2N1bSA9IG51bV9iaXRzX2FjY3VtICsgKGxldmVsX251bV9iaXRzIHw+IE51bV9rZXlfYml0cy50b19pbnQpIGluXG4gICAgICAgIGxldCBkdXJhdGlvbiA9XG4gICAgICAgICAgVGltZV9ucy5TcGFuLm9mX2ludDYzX25zXG4gICAgICAgICAgICAoaWYgbnVtX2JpdHNfYWNjdW0gPSBJbnQ2My5udW1fYml0cyAtIDFcbiAgICAgICAgICAgICB0aGVuIEludDYzLm1heF92YWx1ZVxuICAgICAgICAgICAgIGVsc2UgSW50NjMuc2hpZnRfbGVmdCBJbnQ2My5vbmUgbnVtX2JpdHNfYWNjdW0pXG4gICAgICAgIGluXG4gICAgICAgIG51bV9iaXRzX2FjY3VtLCBkdXJhdGlvbilcbiAgOztcbmVuZFxuXG4oKiogVGltaW5nIHdoZWVsIGlzIGltcGxlbWVudGVkIGFzIGEgcHJpb3JpdHkgcXVldWUgaW4gd2hpY2ggdGhlIGtleXMgYXJlXG4gICAgbm9uLW5lZ2F0aXZlIGludGVnZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGludGVydmFscyBvZiB0aW1lLiAgVGhlIHByaW9yaXR5IHF1ZXVlIGlzXG4gICAgdW5saWtlIGEgdHlwaWNhbCBwcmlvcml0eSBxdWV1ZSBpbiB0aGF0IHJhdGhlciB0aGFuIGhhdmluZyBhIFwiZGVsZXRlIG1pblwiIG9wZXJhdGlvbixcbiAgICBpdCBoYXMgYSBub25kZWNyZWFzaW5nIG1pbmltdW0gYWxsb3dlZCBrZXksIHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBjdXJyZW50IHRpbWUsXG4gICAgYW5kIGFuIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIG9wZXJhdGlvbiwgd2hpY2ggaW1wbGVtZW50cyBbYWR2YW5jZV9jbG9ja10uXG4gICAgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gYXMgYSBzaWRlIGVmZmVjdCByZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIHRoZSB0aW1pbmdcbiAgICB3aGVlbCB3aG9zZSBrZXkgaXMgc21hbGxlciB0aGFuIHRoZSBuZXcgbWluaW11bSwgd2hpY2ggaW1wbGVtZW50cyBmaXJpbmcgdGhlIGFsYXJtc1xuICAgIHdob3NlIHRpbWUgaGFzIGV4cGlyZWQuXG5cbiAgICBBZGRpbmcgZWxlbWVudHMgdG8gYW5kIHJlbW92aW5nIGVsZW1lbnRzIGZyb20gYSB0aW1pbmcgd2hlZWwgdGFrZXMgY29uc3RhbnQgdGltZSxcbiAgICB1bmxpa2UgYSBoZWFwLWJhc2VkIHByaW9yaXR5IHF1ZXVlIHdoaWNoIHRha2VzIGxvZyhOKSwgd2hlcmUgTiBpcyB0aGUgbnVtYmVyIG9mXG4gICAgZWxlbWVudHMgaW4gdGhlIGhlYXAuICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSB0YWtlcyB0aW1lIHByb3BvcnRpb25hbCB0byB0aGVcbiAgICBhbW91bnQgb2YgaW5jcmVhc2UgaW4gdGhlIG1pbi1hbGxvd2VkIGtleSwgYXMgY29tcGFyZWQgdG8gbG9nKE4pIGZvciBhIGhlYXAuICBJdCBpc1xuICAgIHRoZXNlIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VzIHRoYXQgbW90aXZhdGUgdGhlIGV4aXN0ZW5jZSBvZiB0aW1pbmcgd2hlZWxzIGFuZCBtYWtlXG4gICAgdGhlbSBhIGdvb2QgY2hvaWNlIGZvciBtYWludGFpbmcgYSBzZXQgb2YgYWxhcm1zLiAgV2l0aCBhIHRpbWluZyB3aGVlbCwgb25lIGNhblxuICAgIHN1cHBvcnQgYW55IG51bWJlciBvZiBhbGFybXMgcGF5aW5nIGNvbnN0YW50IG92ZXJoZWFkIHBlciBhbGFybSwgd2hpbGUgcGF5aW5nIGFcbiAgICBzbWFsbCBjb25zdGFudCBvdmVyaGVhZCBwZXIgdW5pdCBvZiB0aW1lIHBhc3NlZC5cblxuICAgIEFzIHRoZSBtaW5pbXVtIGFsbG93ZWQga2V5IGluY3JlYXNlcywgdGhlIHRpbWluZyB3aGVlbCBkb2VzIGEgbGF6eSByYWRpeCBzb3J0IG9mIHRoZVxuICAgIGVsZW1lbnQga2V5cywgd2l0aCBsZXZlbCAwIGhhbmRsaW5nIHRoZSBsZWFzdCBzaWduaWZpY2FudCBbYl8wXSBiaXRzIGluIGEga2V5LCBhbmRcbiAgICBlYWNoIHN1YnNlcXVlbnQgbGV2ZWwgW2ldIGhhbmRsaW5nIHRoZSBuZXh0IG1vc3Qgc2lnbmlmaWNhbnQgW2JfaV0gYml0cy4gIFRoZSBsZXZlbHNcbiAgICBob2xkIGluY3JlYXNpbmdseSBsYXJnZXIgcmFuZ2VzIG9mIGtleXMsIHdoZXJlIHRoZSB1bmlvbiBvZiBhbGwgdGhlIGxldmVscyBjYW4gaG9sZFxuICAgIGFueSBrZXkgZnJvbSBbbWluX2FsbG93ZWRfa2V5IHRdIHRvIFttYXhfYWxsb3dlZF9rZXkgdF0uICBXaGVuIGEga2V5IGlzIGFkZGVkIHRvIHRoZVxuICAgIHRpbWluZyB3aGVlbCwgaXQgaXMgYWRkZWQgYXQgdGhlIGxvd2VzdCBwb3NzaWJsZSBsZXZlbCB0aGF0IGNhbiBzdG9yZSB0aGUga2V5LiAgQXNcbiAgICB0aGUgbWluaW11bSBhbGxvd2VkIGtleSBpbmNyZWFzZXMsIHRpbWluZy13aGVlbCBlbGVtZW50cyBtb3ZlIGRvd24gbGV2ZWxzIHVudGlsIHRoZXlcbiAgICByZWFjaCBsZXZlbCAwLCBhbmQgdGhlbiBhcmUgZXZlbnR1YWxseSByZW1vdmVkLiAgKilcbm1vZHVsZSBQcmlvcml0eV9xdWV1ZSA6IHNpZ1xuICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAnYSBwcmlvcml0eV9xdWV1ZSA9ICdhIHRcblxuICBtb2R1bGUgS2V5IDogSW50ZXJ2YWxfbnVtXG5cbiAgbW9kdWxlIEVsdCA6IHNpZ1xuICAgICgqKiBBbiBbRWx0LnRdIHJlcHJlc2VudHMgYW4gZWxlbWVudCB0aGF0IHdhcyBhZGRlZCB0byBhIHRpbWluZyB3aGVlbC4gKilcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHZhbCBhdCA6ICdhIHByaW9yaXR5X3F1ZXVlIC0+ICdhIHQgLT4gVGltZV9ucy50XG4gICAgdmFsIGtleSA6ICdhIHByaW9yaXR5X3F1ZXVlIC0+ICdhIHQgLT4gS2V5LnRcbiAgICB2YWwgdmFsdWUgOiAnYSBwcmlvcml0eV9xdWV1ZSAtPiAnYSB0IC0+ICdhXG4gICAgdmFsIG51bGwgOiB1bml0IC0+ICdhIHRcbiAgZW5kXG5cbiAgbW9kdWxlIEludGVybmFsX2VsdCA6IHNpZ1xuICAgIG1vZHVsZSBQb29sIDogc2lnXG4gICAgICB0eXBlICdhIHRcbiAgICBlbmRcblxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGtleSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IEtleS50XG4gICAgdmFsIG1heF9hbGFybV90aW1lIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gd2l0aF9rZXk6S2V5LnQgLT4gVGltZV9ucy50XG4gICAgdmFsIG1pbl9hbGFybV90aW1lIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gd2l0aF9rZXk6S2V5LnQgLT4gVGltZV9ucy50XG4gICAgdmFsIGlzX251bGwgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCB0b19leHRlcm5hbCA6ICdhIHQgLT4gJ2EgRWx0LnRcbiAgZW5kXG5cbiAgdmFsIHBvb2wgOiAnYSB0IC0+ICdhIEludGVybmFsX2VsdC5Qb29sLnRcblxuICBpbmNsdWRlIEludmFyaWFudC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgKCoqIFtjcmVhdGUgP2xldmVsX2JpdHMgKCldIGNyZWF0ZXMgYSBuZXcgZW1wdHkgdGltaW5nIHdoZWVsLCBbdF0sIHdpdGggW2xlbmd0aCB0ID0gMF1cbiAgICAgIGFuZCBbbWluX2FsbG93ZWRfa2V5IHQgPSAwXS4gKilcbiAgdmFsIGNyZWF0ZSA6ID9jYXBhY2l0eTppbnQgLT4gP2xldmVsX2JpdHM6TGV2ZWxfYml0cy50IC0+IHVuaXQgLT4gJ2EgdFxuXG4gICgqKiBbbGVuZ3RoIHRdIHJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdGltaW5nIHdoZWVsLiAqKVxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuXG4gICgqKiBbbWluX2FsbG93ZWRfa2V5IHRdIGlzIHRoZSBtaW5pbXVtIGtleSB0aGF0IGNhbiBiZSBzdG9yZWQgaW4gW3RdLiAgVGhpcyBvbmx5XG4gICAgICBpbmRpY2F0ZXMgdGhlIHBvc3NpYmlsaXR5OyB0aGVyZSBuZWVkIG5vdCBiZSBhbiBlbGVtZW50IFtlbHRdIGluIFt0XSB3aXRoIFtFbHQua2V5XG4gICAgICBlbHQgPSBtaW5fYWxsb3dlZF9rZXkgdF0uICBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgXCJtaW5fa2V5XCIgb3BlcmF0aW9uIGluIGFcbiAgICAgIHR5cGljYWwgcHJpb3JpdHkgcXVldWUuXG5cbiAgICAgIFttaW5fYWxsb3dlZF9rZXkgdF0gY2FuIGluY3JlYXNlIG92ZXIgdGltZSwgdmlhIGNhbGxzIHRvXG4gICAgICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XS4gKilcbiAgdmFsIG1pbl9hbGxvd2VkX2tleSA6IF8gdCAtPiBLZXkudFxuXG4gICgqKiBbbWF4X2FsbG93ZWRfa2V5IHRdIGlzIHRoZSBtYXhpbXVtIGFsbG93ZWQga2V5IHRoYXQgY2FuIGJlIHN0b3JlZCBpbiBbdF0uICBBc1xuICAgICAgW21pbl9hbGxvd2VkX2tleV0gaW5jcmVhc2VzLCBzbyBkb2VzIFttYXhfYWxsb3dlZF9rZXldOyBob3dldmVyIGl0IGlzIG5vdCB0aGUgY2FzZVxuICAgICAgdGhhdCBbbWF4X2FsbG93ZWRfa2V5IHQgLSBtaW5fYWxsb3dlZF9rZXkgdF0gaXMgYSBjb25zdGFudC4gIEl0IGlzIGd1YXJhbnRlZWQgdGhhdFxuICAgICAgW21heF9hbGxvd2VkX2tleSB0ID49IG1pbl9hbGxvd2VkX2tleSB0ICsgMl5CIC0gMV0sXG4gICAgICB3aGVyZSBbQl0gaXMgdGhlIHN1bSBvZiB0aGUgYl9pIGluIFtsZXZlbF9iaXRzXS4gKilcbiAgdmFsIG1heF9hbGxvd2VkX2tleSA6IF8gdCAtPiBLZXkudFxuXG4gIHZhbCBtaW5fZWx0XyA6ICdhIHQgLT4gJ2EgSW50ZXJuYWxfZWx0LnRcbiAgdmFsIGludGVybmFsX2FkZCA6ICdhIHQgLT4ga2V5OktleS50IC0+IGF0OlRpbWVfbnMudCAtPiAnYSAtPiAnYSBJbnRlcm5hbF9lbHQudFxuXG4gICgqKiBbcmVtb3ZlIHQgZWx0XSByZW1vdmVzIFtlbHRdIGZyb20gW3RdLiAgSXQgaXMgYW4gZXJyb3IgaWYgW2VsdF0gaXMgbm90IGN1cnJlbnRseVxuICAgICAgaW4gW3RdLCBhbmQgdGhpcyBlcnJvciBtYXkgb3IgbWF5IG5vdCBiZSBkZXRlY3RlZC4gKilcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4gJ2EgRWx0LnQgLT4gdW5pdFxuXG4gIHZhbCBjaGFuZ2UgOiAnYSB0IC0+ICdhIEVsdC50IC0+IGtleTpLZXkudCAtPiBhdDpUaW1lX25zLnQgLT4gdW5pdFxuXG4gICgqKiBbY2xlYXIgdF0gcmVtb3ZlcyBhbGwgZWx0cyBmcm9tIFt0XS4gKilcbiAgdmFsIGNsZWFyIDogXyB0IC0+IHVuaXRcblxuICB2YWwgbWVtIDogJ2EgdCAtPiAnYSBFbHQudCAtPiBib29sXG5cbiAgbW9kdWxlIEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQgOiBzaWdcbiAgICB0eXBlIHQgPVxuICAgICAgfCBNYXhfYWxsb3dlZF9rZXlfZGlkX25vdF9jaGFuZ2VcbiAgICAgIHwgTWF4X2FsbG93ZWRfa2V5X21heWJlX2NoYW5nZWRcbiAgZW5kXG5cbiAgKCoqIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXkgdCB+a2V5IH5oYW5kbGVfcmVtb3ZlZF0gaW5jcmVhc2VzIHRoZSBtaW5pbXVtIGFsbG93ZWRcbiAgICAgIGtleSBpbiBbdF0gdG8gW2tleV0sIGFuZCByZW1vdmVzIGFsbCBlbGVtZW50cyB3aXRoIGtleXMgbGVzcyB0aGFuIFtrZXldLCBhcHBseWluZ1xuICAgICAgW2hhbmRsZV9yZW1vdmVkXSB0byBlYWNoIGVsZW1lbnQgdGhhdCBpcyByZW1vdmVkLiAgSWYgW2tleSA8PSBtaW5fYWxsb3dlZF9rZXkgdF0sXG4gICAgICB0aGVuIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIGRvZXMgbm90aGluZy4gIE90aGVyd2lzZSwgaWZcbiAgICAgIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIHJldHVybnMgc3VjY2Vzc2Z1bGx5LCBbbWluX2FsbG93ZWRfa2V5IHQgPSBrZXldLlxuXG4gICAgICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSB0YWtlcyB0aW1lIHByb3BvcnRpb25hbCB0byBba2V5IC0gbWluX2FsbG93ZWRfa2V5IHRdLFxuICAgICAgYWx0aG91Z2ggcG9zc2libHkgbGVzcyB0aW1lLlxuXG4gICAgICBCZWhhdmlvciBpcyB1bnNwZWNpZmllZCBpZiBbaGFuZGxlX3JlbW92ZWRdIGFjY2Vzc2VzIFt0XSBpbiBhbnkgd2F5IG90aGVyIHRoYW5cbiAgICAgIFtFbHRdIGZ1bmN0aW9ucy4gKilcbiAgdmFsIGluY3JlYXNlX21pbl9hbGxvd2VkX2tleVxuICAgIDogICdhIHRcbiAgICAtPiBrZXk6S2V5LnRcbiAgICAtPiBoYW5kbGVfcmVtb3ZlZDooJ2EgRWx0LnQgLT4gdW5pdClcbiAgICAtPiBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0LnRcblxuICB2YWwgaXRlciA6ICdhIHQgLT4gZjooJ2EgRWx0LnQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBmaXJlX3Bhc3RfYWxhcm1zXG4gICAgOiAgJ2EgdFxuICAgIC0+IGhhbmRsZV9maXJlZDooJ2EgRWx0LnQgLT4gdW5pdClcbiAgICAtPiBrZXk6S2V5LnRcbiAgICAtPiBub3c6VGltZV9ucy50XG4gICAgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gICgqKiBFYWNoIHNsb3QgaW4gYSBsZXZlbCBpcyBhIChwb3NzaWJseSBudWxsKSBwb2ludGVyIHRvIGEgY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0XG4gICAgICBvZiBlbGVtZW50cy4gIFdlIHBvb2wgdGhlIGVsZW1lbnRzIHNvIHRoYXQgd2UgY2FuIHJldXNlIHRoZW0gYWZ0ZXIgdGhleSBhcmUgcmVtb3ZlZFxuICAgICAgZnJvbSB0aGUgdGltaW5nIHdoZWVsIChlaXRoZXIgdmlhIFtyZW1vdmVdIG9yIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldKS4gIEluXG4gICAgICBhZGRpdGlvbiB0byBzdG9yaW5nIHRoZSBba2V5XSwgW2F0XSwgYW5kIFt2YWx1ZV0gaW4gdGhlIGVsZW1lbnQsIHdlIHN0b3JlIHRoZVxuICAgICAgW2xldmVsX2luZGV4XSBzbyB0aGF0IHdlIGNhbiBxdWlja2x5IGdldCB0byB0aGUgbGV2ZWwgaG9sZGluZyBhbiBlbGVtZW50IHdoZW4gd2VcbiAgICAgIFtyZW1vdmVdIGl0LlxuXG4gICAgICBXZSBkaXN0aW5ndWlzaCBiZXR3ZWVuIFtFeHRlcm5hbF9lbHRdIGFuZCBbSW50ZXJuYWxfZWx0XSwgd2hpY2ggYXJlIHRoZSBzYW1lXG4gICAgICB1bmRlcm5lYXRoLiAgV2UgbWFpbnRhaW4gdGhlIGludmFyaWFudCB0aGF0IGFuIFtJbnRlcm5hbF9lbHRdIGlzIGVpdGhlciBbbnVsbF0gb3IgYVxuICAgICAgdmFsaWQgcG9pbnRlci4gIE9uIHRoZSBvdGhlciBoYW5kLCBbRXh0ZXJuYWxfZWx0XXMgYXJlIHJldHVybmVkIHRvIHVzZXIgY29kZSwgc29cbiAgICAgIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSBvZiB2YWxpZGl0eSAtLSB3ZSBhbHdheXMgdmFsaWRhdGUgYW4gW0V4dGVybmFsX2VsdF0gYmVmb3JlXG4gICAgICBkb2luZyBhbnl0aGluZyB3aXRoIGl0LlxuXG4gICAgICBJdCBpcyB0aGVyZWZvcmUgT0sgdG8gdXNlIFtQb29sLlVuc2FmZV0sIGJlY2F1c2Ugd2Ugd2lsbCBuZXZlciBhdHRlbXB0IHRvIGFjY2VzcyBhXG4gICAgICBzbG90IG9mIGFuIGludmFsaWQgcG9pbnRlci4gKilcbiAgbW9kdWxlIFBvb2wgPSBQb29sLlVuc2FmZVxuXG4gIG1vZHVsZSBQb2ludGVyID0gUG9vbC5Qb2ludGVyXG5cbiAgbW9kdWxlIEtleSA6IHNpZ1xuICAgICgqKiBbSW50ZXJ2YWxfbnVtXSBpcyB0aGUgcHVibGljIEFQSS4gIEV2ZXJ5dGhpbmcgZm9sbG93aW5nIGluIHRoZSBzaWduYXR1cmUgaXNcbiAgICAgICAgZm9yIGludGVybmFsIHVzZS4gKilcbiAgICBpbmNsdWRlIFRpbWluZ193aGVlbF9pbnRmLkludGVydmFsX251bVxuXG4gICAgKCoqIFthZGRfY2xhbXBfdG9fbWF4XSBkb2Vzbid0IHdvcmsgYXQgYWxsIHdpdGggbmVnYXRpdmUgc3BhbnMgKilcbiAgICB2YWwgYWRkX2NsYW1wX3RvX21heCA6IHQgLT4gU3Bhbi50IC0+IHRcblxuICAgIHZhbCBzdWNjX2NsYW1wX3RvX21heCA6IHQgLT4gdFxuXG4gICAgKCoqIFtTbG90c19tYXNrXSBpcyB1c2VkIHRvIHF1aWNrbHkgZGV0ZXJtaW5lIGEga2V5J3Mgc2xvdCBpbiBhIGdpdmVuIGxldmVsLiAqKVxuICAgIG1vZHVsZSBTbG90c19tYXNrIDogc2lnXG4gICAgICB0eXBlIHQgPSBwcml2YXRlIEludDYzLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgICAgdmFsIGNyZWF0ZSA6IGxldmVsX2JpdHM6TnVtX2tleV9iaXRzLnQgLT4gdFxuICAgICAgdmFsIG5leHRfc2xvdCA6IHQgLT4gaW50IC0+IGludFxuICAgIGVuZFxuXG4gICAgKCoqIFtNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXSBpcyB1c2VkIHRvIHF1aWNrbHkgZGV0ZXJtaW5lIHRoZSBtaW5pbXVtIGtleSBpbiB0aGVcbiAgICAgICAgc2FtZSBzbG90IGFzIGEgZ2l2ZW4ga2V5LiAqKVxuICAgIG1vZHVsZSBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIDogc2lnXG4gICAgICB0eXBlIHQgPSBwcml2YXRlIEludDYzLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgICAgaW5jbHVkZSBFcXVhbC5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgICAgdmFsIGNyZWF0ZSA6IGJpdHNfcGVyX3Nsb3Q6TnVtX2tleV9iaXRzLnQgLT4gdFxuICAgIGVuZFxuXG4gICAgdmFsIG51bV9rZXlzIDogTnVtX2tleV9iaXRzLnQgLT4gU3Bhbi50XG4gICAgdmFsIG1pbl9rZXlfaW5fc2FtZV9zbG90IDogdCAtPiBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrLnQgLT4gdFxuICAgIHZhbCBzbG90IDogdCAtPiBiaXRzX3Blcl9zbG90Ok51bV9rZXlfYml0cy50IC0+IHNsb3RzX21hc2s6U2xvdHNfbWFzay50IC0+IGludFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgU2xvdHNfbWFzayA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gSW50NjMudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgICBsZXQgY3JlYXRlIH5sZXZlbF9iaXRzID0gSW50NjMuKCAtICkgKE51bV9rZXlfYml0cy5wb3cyIGxldmVsX2JpdHMpIEludDYzLm9uZVxuICAgICAgbGV0IG5leHRfc2xvdCB0IHNsb3QgPSAoc2xvdCArIDEpIGxhbmQgSW50NjMudG9faW50X2V4biB0XG4gICAgZW5kXG5cbiAgICBsZXQgbnVtX2tleXMgbnVtX2JpdHMgPSBOdW1fa2V5X2JpdHMucG93MiBudW1fYml0c1xuXG4gICAgbW9kdWxlIE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgSW50NjNcblxuICAgICAgbGV0IGNyZWF0ZSB+Yml0c19wZXJfc2xvdCA9IGJpdF9ub3QgKE51bV9rZXlfYml0cy5wb3cyIGJpdHNfcGVyX3Nsb3QgLSBvbmUpXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgU3BhbiA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBJbnQ2M1xuXG4gICAgICBsZXQgdG9faW50NjMgdCA9IHRcbiAgICAgIGxldCBvZl9pbnQ2MyBpID0gaVxuICAgICAgbGV0IHNjYWxlX2ludCB0IGkgPSB0ICogb2ZfaW50IGlcbiAgICBlbmRcblxuICAgIGluY2x1ZGUgSW50NjNcblxuICAgIGxldCBvZl9pbnQ2MyBpID0gaVxuICAgIGxldCB0b19pbnQ2MyB0ID0gdFxuICAgIGxldCBhZGQgdCBpID0gdCArIGlcbiAgICBsZXQgYWRkX2NsYW1wX3RvX21heCB0IGkgPSBpZiB0ID4gbWF4X3ZhbHVlIC0gaSB0aGVuIG1heF92YWx1ZSBlbHNlIHQgKyBpXG4gICAgbGV0IHN1Y2NfY2xhbXBfdG9fbWF4IHQgPSBpZiB0ID0gbWF4X3ZhbHVlIHRoZW4gbWF4X3ZhbHVlIGVsc2Ugc3VjYyB0XG4gICAgbGV0IHN1YiB0IGkgPSB0IC0gaVxuICAgIGxldCBkaWZmIHQxIHQyID0gdDEgLSB0MlxuXG4gICAgbGV0IHNsb3QgdCB+KGJpdHNfcGVyX3Nsb3QgOiBOdW1fa2V5X2JpdHMudCkgfnNsb3RzX21hc2sgPVxuICAgICAgdG9faW50X2V4biAoYml0X2FuZCAoc2hpZnRfcmlnaHQgdCAoYml0c19wZXJfc2xvdCA6PiBpbnQpKSBzbG90c19tYXNrKVxuICAgIDs7XG5cbiAgICBsZXQgbWluX2tleV9pbl9zYW1lX3Nsb3QgdCBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrID1cbiAgICAgIGJpdF9hbmQgdCBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgPSBLZXkuTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICBtb2R1bGUgU2xvdHNfbWFzayA9IEtleS5TbG90c19tYXNrXG5cbiAgbW9kdWxlIEV4dGVybmFsX2VsdCA9IHN0cnVjdFxuICAgICgqKiBUaGUgW3Bvb2xfc2xvdHNdIGhlcmUgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCB0aGUgc2xvdHMgaW4gYSBsZXZlbCBhcnJheS4gIFRoaXMgaXNcbiAgICAgICAgZm9yIHRoZSBzbG90cyBpbiB0aGUgcG9vbCB0dXBsZSByZXByZXNlbnRpbmcgYSBsZXZlbCBlbGVtZW50LiAqKVxuICAgIHR5cGUgJ2EgcG9vbF9zbG90cyA9XG4gICAgICAoIEtleS50XG4gICAgICAsIFRpbWVfbnMudFxuICAgICAgLCAnYVxuICAgICAgLCBpbnRcbiAgICAgICwgJ2EgcG9vbF9zbG90cyBQb2ludGVyLnRcbiAgICAgICwgJ2EgcG9vbF9zbG90cyBQb2ludGVyLnQgKVxuICAgICAgUG9vbC5TbG90cy50NlxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB0eXBlICdhIHQgPSAnYSBwb29sX3Nsb3RzIFBvaW50ZXIudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgbGV0IG51bGwgPSBQb2ludGVyLm51bGxcbiAgZW5kXG5cbiAgbW9kdWxlIEludGVybmFsX2VsdCA6IHNpZ1xuICAgIG1vZHVsZSBQb29sIDogc2lnXG4gICAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgICAgaW5jbHVkZSBJbnZhcmlhbnQuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgICB2YWwgY3JlYXRlIDogP2NhcGFjaXR5OmludCAtPiB1bml0IC0+IF8gdFxuICAgICAgdmFsIGlzX2Z1bGwgOiBfIHQgLT4gYm9vbFxuICAgICAgdmFsIGdyb3cgOiA/Y2FwYWNpdHk6aW50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIGVuZFxuXG4gICAgdHlwZSAnYSB0ID0gcHJpdmF0ZSAnYSBFeHRlcm5hbF9lbHQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgdmFsIG51bGwgOiB1bml0IC0+IF8gdFxuICAgIHZhbCBpc19udWxsIDogXyB0IC0+IGJvb2xcbiAgICB2YWwgaXNfdmFsaWQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBib29sXG5cbiAgICAoKiogRGVhbGluZyB3aXRoIFtFeHRlcm5hbF9lbHRdcy4gKilcblxuICAgIHZhbCBleHRlcm5hbF9pc192YWxpZCA6ICdhIFBvb2wudCAtPiAnYSBFeHRlcm5hbF9lbHQudCAtPiBib29sXG4gICAgdmFsIHRvX2V4dGVybmFsIDogJ2EgdCAtPiAnYSBFeHRlcm5hbF9lbHQudFxuICAgIHZhbCBvZl9leHRlcm5hbF9leG4gOiAnYSBQb29sLnQgLT4gJ2EgRXh0ZXJuYWxfZWx0LnQgLT4gJ2EgdFxuICAgIHZhbCBlcXVhbCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGludmFyaWFudCA6ICdhIFBvb2wudCAtPiAoJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG5cbiAgICAoKiogW2NyZWF0ZV0gcmV0dXJucyBhbiBlbGVtZW50IHdob3NlIFtuZXh0XSBhbmQgW3ByZXZdIGFyZSBbbnVsbF0uICopXG4gICAgdmFsIGNyZWF0ZVxuICAgICAgOiAgJ2EgUG9vbC50XG4gICAgICAtPiBrZXk6S2V5LnRcbiAgICAgICAgICAgKCoqIFthdF0gaXMgdXNlZCB3aGVuIHRoZSBwcmlvcml0eSBxdWV1ZSBpcyB1c2VkIHRvIGltcGxlbWVudCBhIHRpbWluZyB3aGVlbC4gIElmXG4gICAgICAgICAgdW51c2VkLCBpdCB3aWxsIGJlIFtUaW1lX25zLmVwb2NoXS4gKilcbiAgICAgIC0+IGF0OlRpbWVfbnMudFxuICAgICAgLT4gdmFsdWU6J2FcbiAgICAgIC0+IGxldmVsX2luZGV4OmludFxuICAgICAgLT4gJ2EgdFxuXG4gICAgdmFsIGZyZWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB1bml0XG5cbiAgICAoKiogYWNjZXNzb3JzICopXG5cbiAgICB2YWwga2V5IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gS2V5LnRcbiAgICB2YWwgYXQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBUaW1lX25zLnRcbiAgICB2YWwgbGV2ZWxfaW5kZXggOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBpbnRcbiAgICB2YWwgbmV4dCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgdmFsdWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiAnYVxuXG4gICAgKCoqIG11dGF0b3JzICopXG5cbiAgICB2YWwgc2V0X2tleSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IEtleS50IC0+IHVuaXRcbiAgICB2YWwgc2V0X2F0IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gVGltZV9ucy50IC0+IHVuaXRcbiAgICB2YWwgc2V0X2xldmVsX2luZGV4IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gaW50IC0+IHVuaXRcblxuICAgICgqKiBbaW5zZXJ0X2F0X2VuZCBwb29sIHQgfnRvX2FkZF0gdHJlYXRzIFt0XSBhcyB0aGUgaGVhZCBvZiB0aGUgbGlzdCBhbmQgYWRkcyBbdG9fYWRkXVxuICAgICAgICB0byB0aGUgZW5kIG9mIGl0LiAqKVxuICAgIHZhbCBpbnNlcnRfYXRfZW5kIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gdG9fYWRkOidhIHQgLT4gdW5pdFxuXG4gICAgKCoqIFtsaW5rX3RvX3NlbGYgcG9vbCB0XSBtYWtlcyBbdF0gYmUgYSBzaW5nbGV0b24gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0LiAqKVxuICAgIHZhbCBsaW5rX3RvX3NlbGYgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB1bml0XG5cbiAgICAoKiogW3VubGluayBwIHRdIHVubGlua3MgW3RdIGZyb20gdGhlIGNpcmN1bGFybHkgZG91Ymx5LWxpbmtlZCBsaXN0IHRoYXQgaXQgaXMgaW4uICBJdFxuICAgICAgICBjaGFuZ2VzIHRoZSBwb2ludGVycyBvZiBbdF0ncyBbcHJldl0gYW5kIFtuZXh0XSBlbHRzLCBidXQgbm90IFt0XSdzIFtwcmV2XSBhbmRcbiAgICAgICAgW25leHRdIHBvaW50ZXJzLiAgW3VubGlua10gaXMgbWVhbmluZ2xlc3MgaWYgW3RdIGlzIGEgc2luZ2xldG9uLiAqKVxuICAgIHZhbCB1bmxpbmsgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB1bml0XG5cbiAgICAoKiogSXRlcmF0b3JzLiAgW2l0ZXIgcCB0IH5pbml0IH5mXSB2aXNpdHMgZWFjaCBlbGVtZW50IGluIHRoZSBkb3VibHktbGlua2VkIGxpc3RcbiAgICAgICAgY29udGFpbmluZyBbdF0sIHN0YXJ0aW5nIGF0IFt0XSwgYW5kIGZvbGxvd2luZyBbbmV4dF0gcG9pbnRlcnMuICBbbGVuZ3RoXSBjb3VudHNcbiAgICAgICAgYnkgdmlzaXRpbmcgZWFjaCBlbGVtZW50IGluIHRoZSBsaXN0LiAqKVxuICAgIHZhbCBpdGVyIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gZjooJ2EgdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgICB2YWwgbGVuZ3RoIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gaW50XG5cbiAgICAoKiogW21heF9hbGFybV90aW1lIHQgZWx0IH53aXRoX2tleV0gZmluZHMgdGhlIG1heCBbYXRdIGluIFtlbHRdJ3MgbGlzdCBhbW9uZyB0aGUgZWx0c1xuICAgICAgICB3aG9zZSBrZXkgaXMgW3dpdGhfa2V5XSwgcmV0dXJuaW5nIFtUaW1lX25zLmVwb2NoXSBpZiB0aGUgbGlzdCBpcyBlbXB0eS4gKilcbiAgICB2YWwgbWF4X2FsYXJtX3RpbWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB3aXRoX2tleTpLZXkudCAtPiBUaW1lX25zLnRcblxuICAgIHZhbCBtaW5fYWxhcm1fdGltZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHdpdGhfa2V5OktleS50IC0+IFRpbWVfbnMudFxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHBvb2xfc2xvdHMgPSAnYSBFeHRlcm5hbF9lbHQucG9vbF9zbG90cyBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIHR5cGUgJ2EgdCA9ICdhIEV4dGVybmFsX2VsdC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBsZXQgbnVsbCA9IFBvaW50ZXIubnVsbFxuICAgIGxldCBpc19udWxsID0gUG9pbnRlci5pc19udWxsXG4gICAgbGV0IGVxdWFsIHQxIHQyID0gUG9pbnRlci5waHlzX2VxdWFsIHQxIHQyXG5cbiAgICBsZXQgY3JlYXRlIHBvb2wgfmtleSB+YXQgfnZhbHVlIH5sZXZlbF9pbmRleCA9XG4gICAgICBQb29sLm5ldzYgcG9vbCBrZXkgYXQgdmFsdWUgbGV2ZWxfaW5kZXggKG51bGwgKCkpIChudWxsICgpKVxuICAgIDs7XG5cbiAgICBsZXQgZnJlZSA9IFBvb2wuZnJlZVxuICAgIGxldCBrZXkgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50MFxuICAgIGxldCBzZXRfa2V5IHAgdCBrID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50MCBrXG4gICAgbGV0IGF0IHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDFcbiAgICBsZXQgc2V0X2F0IHAgdCB4ID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50MSB4XG4gICAgbGV0IHZhbHVlIHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDJcbiAgICBsZXQgbGV2ZWxfaW5kZXggcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50M1xuICAgIGxldCBzZXRfbGV2ZWxfaW5kZXggcCB0IGkgPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQzIGlcbiAgICBsZXQgcHJldiBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQ0XG4gICAgbGV0IHNldF9wcmV2IHAgdCB4ID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50NCB4XG4gICAgbGV0IG5leHQgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50NVxuICAgIGxldCBzZXRfbmV4dCBwIHQgeCA9IFBvb2wuc2V0IHAgdCBQb29sLlNsb3QudDUgeFxuICAgIGxldCBpc192YWxpZCBwIHQgPSBQb29sLnBvaW50ZXJfaXNfdmFsaWQgcCB0XG4gICAgbGV0IGV4dGVybmFsX2lzX3ZhbGlkID0gaXNfdmFsaWRcblxuICAgIGxldCBpbnZhcmlhbnQgcG9vbCBpbnZhcmlhbnRfYSB0ID1cbiAgICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgICAgIGFzc2VydCAoaXNfdmFsaWQgcG9vbCB0KTtcbiAgICAgICAgaW52YXJpYW50X2EgKHZhbHVlIHBvb2wgdCk7XG4gICAgICAgIGxldCBuID0gbmV4dCBwb29sIHQgaW5cbiAgICAgICAgYXNzZXJ0IChpc19udWxsIG4gfHwgUG9pbnRlci5waHlzX2VxdWFsIHQgKHByZXYgcG9vbCBuKSk7XG4gICAgICAgIGxldCBwID0gcHJldiBwb29sIHQgaW5cbiAgICAgICAgYXNzZXJ0IChpc19udWxsIHAgfHwgUG9pbnRlci5waHlzX2VxdWFsIHQgKG5leHQgcG9vbCBwKSkpXG4gICAgOztcblxuICAgIG1vZHVsZSBQb29sID0gc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBwb29sX3Nsb3RzIFBvb2wudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICBsZXQgaW52YXJpYW50IF9pbnZhcmlhbnRfYSB0ID0gUG9vbC5pbnZhcmlhbnQgaWdub3JlIHRcbiAgICAgIGxldCBjcmVhdGUgPyhjYXBhY2l0eSA9IDEpICgpID0gUG9vbC5jcmVhdGUgUG9vbC5TbG90cy50NiB+Y2FwYWNpdHlcbiAgICAgIGxldCBncm93ID0gUG9vbC5ncm93XG4gICAgICBsZXQgaXNfZnVsbCA9IFBvb2wuaXNfZnVsbFxuICAgIGVuZFxuXG4gICAgbGV0IHRvX2V4dGVybmFsIHQgPSB0XG5cbiAgICBsZXQgb2ZfZXh0ZXJuYWxfZXhuIHBvb2wgdCA9XG4gICAgICBpZiBpc192YWxpZCBwb29sIHQgdGhlbiB0IGVsc2UgcmFpc2VfcyBbJW1lc3NhZ2UgXCJUaW1pbmdfd2hlZWwgZ290IGludmFsaWQgYWxhcm1cIl1cbiAgICA7O1xuXG4gICAgbGV0IHVubGluayBwb29sIHQgPVxuICAgICAgc2V0X25leHQgcG9vbCAocHJldiBwb29sIHQpIChuZXh0IHBvb2wgdCk7XG4gICAgICBzZXRfcHJldiBwb29sIChuZXh0IHBvb2wgdCkgKHByZXYgcG9vbCB0KVxuICAgIDs7XG5cbiAgICBsZXQgbGluayBwb29sIHByZXYgbmV4dCA9XG4gICAgICBzZXRfbmV4dCBwb29sIHByZXYgbmV4dDtcbiAgICAgIHNldF9wcmV2IHBvb2wgbmV4dCBwcmV2XG4gICAgOztcblxuICAgIGxldCBsaW5rX3RvX3NlbGYgcG9vbCB0ID0gbGluayBwb29sIHQgdFxuXG4gICAgbGV0IGluc2VydF9hdF9lbmQgcG9vbCB0IH50b19hZGQgPVxuICAgICAgbGV0IHByZXYgPSBwcmV2IHBvb2wgdCBpblxuICAgICAgbGluayBwb29sIHByZXYgdG9fYWRkO1xuICAgICAgbGluayBwb29sIHRvX2FkZCB0XG4gICAgOztcblxuICAgIGxldCBpdGVyIHBvb2wgZmlyc3QgfmYgPVxuICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgKCogV2UgZ2V0IFtuZXh0XSBiZWZvcmUgY2FsbGluZyBbZl0gc28gdGhhdCBbZl0gY2FuIG1vZGlmeSBvciBbZnJlZV0gWyFjdXJyZW50XS4gKilcbiAgICAgICAgbGV0IG5leHQgPSBuZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgZiAhY3VycmVudDtcbiAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgIGRvbmVcbiAgICA7O1xuXG4gICAgbGV0IGxlbmd0aCBwb29sIGZpcnN0ID1cbiAgICAgIGxldCByID0gcmVmIDAgaW5cbiAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgIGluY3IgcjtcbiAgICAgICAgbGV0IG5leHQgPSBuZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgIGRvbmU7XG4gICAgICAhclxuICAgIDs7XG5cbiAgICBsZXQgbWF4X2FsYXJtX3RpbWUgcG9vbCBmaXJzdCB+d2l0aF9rZXkgPVxuICAgICAgbGV0IG1heF9hbGFybV90aW1lID0gcmVmIFRpbWVfbnMuZXBvY2ggaW5cbiAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgIGxldCBuZXh0ID0gbmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICAgIGlmIEtleS5lcXVhbCAoa2V5IHBvb2wgIWN1cnJlbnQpIHdpdGhfa2V5XG4gICAgICAgIHRoZW4gbWF4X2FsYXJtX3RpbWUgOj0gVGltZV9ucy5tYXggKGF0IHBvb2wgIWN1cnJlbnQpICFtYXhfYWxhcm1fdGltZTtcbiAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgIGRvbmU7XG4gICAgICAhbWF4X2FsYXJtX3RpbWVcbiAgICA7O1xuXG4gICAgbGV0IG1pbl9hbGFybV90aW1lIHBvb2wgZmlyc3QgfndpdGhfa2V5ID1cbiAgICAgIGxldCBtaW5fYWxhcm1fdGltZSA9IHJlZiBUaW1lX25zLm1heF92YWx1ZV9yZXByZXNlbnRhYmxlIGluXG4gICAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICBsZXQgbmV4dCA9IG5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICAoKiBUaGUgW2tleV0gY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgZm9yIFttYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxdIGJlY2F1c2VcbiAgICAgICAgICAgbWF4IHRpbWUgcGVyIGludGVydmFsIGlzIG5vdCB0aGUgc2FtZSBhcyBtYXggdGltZSBnbG9iYWxseS5cblxuICAgICAgICAgICBUaGlzIGlzIG5vdCBzbyBmb3IgW21pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF0sIHNvIHRoaXMgY2FuIHBvdGVudGlhbGx5XG4gICAgICAgICAgIGJlIHNpbXBsaWZpZWQuXG5cbiAgICAgICAgICAgUHJvYmFibHkgYSBiZXR0ZXIgY2hhbmdlIHdvdWxkIGJlIHRvIHNpbXBseSB0cmFuc2ZlciB0aGUgZXZlbnRzIHRvIHRoZVxuICAgICAgICAgICBcImZpcmVkXCIgY29sbGVjdGlvbiAoYW5kIHJlbmFtZSBpdCB0byBcImFib3V0IHRvIGZpcmVcIiksIHdoaWNoIGlzIHNvcnRlZCBieSB0aW1lLFxuICAgICAgICAgICBzbyBnZXR0aW5nIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhhdCBjb2xsZWN0aW9uIGlzIGVmZmljaWVudC5cbiAgICAgICAgKilcbiAgICAgICAgaWYgS2V5LmVxdWFsIChrZXkgcG9vbCAhY3VycmVudCkgd2l0aF9rZXlcbiAgICAgICAgdGhlbiBtaW5fYWxhcm1fdGltZSA6PSBUaW1lX25zLm1pbiAoYXQgcG9vbCAhY3VycmVudCkgIW1pbl9hbGFybV90aW1lO1xuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZTtcbiAgICAgICFtaW5fYWxhcm1fdGltZVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBMZXZlbCA9IHN0cnVjdFxuICAgICgqKiBGb3IgZ2l2ZW4gbGV2ZWwsIG9uZSBjYW4gYnJlYWsgdGhlIGJpdHMgaW50byBhIGtleSBpbnRvIHRocmVlIHJlZ2lvbnM6XG5cbiAgICAgICAge3ZcbiAgICAgICAgIHwgaGlnaGVyIGxldmVscyB8IHRoaXMgbGV2ZWwgfCBsb3dlciBsZXZlbHMgfFxuICAgICAgICB2fVxuXG4gICAgICAgIFwiTG93ZXIgbGV2ZWxzXCIgaXMgW2JpdHNfcGVyX3Nsb3RdIGJpdHMgd2lkZS4gIFwiVGhpcyBsZXZlbFwiIGlzIFtiaXRzXSB3aWRlLiAqKVxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7ICgqIFRoZSBbaW5kZXhdIGluIHRoZSB0aW1pbmcgd2hlZWwncyBhcnJheSBvZiBsZXZlbHMgd2hlcmUgdGhpcyBsZXZlbCBpcy4gKilcbiAgICAgICAgaW5kZXggOiBpbnRcbiAgICAgIDsgKCogSG93IG1hbnkgW2JpdHNdIHRoaXMgbGV2ZWwgaXMgcmVzcG9uc2libGUgZm9yLiAqKVxuICAgICAgICBiaXRzIDogTnVtX2tleV9iaXRzLnRcbiAgICAgIDsgKCogW3Nsb3RzX21hc2sgPSBTbG90c19tYXNrLmNyZWF0ZSB+bGV2ZWxfYml0czp0LmJpdHNdLiAqKVxuICAgICAgICBzbG90c19tYXNrIDogU2xvdHNfbWFzay50XG4gICAgICA7ICgqIFtiaXRzX3Blcl9zbG90XSBpcyBob3cgbWFueSBiaXRzIGVhY2ggc2xvdCBkaXN0aW5ndWlzaGVzLCBhbmQgaXMgdGhlIHN1bSBvZiBvZlxuICAgICAgICAgICB0aGUgW2JpdHNdIG9mIGFsbCB0aGUgbG93ZXIgbGV2ZWxzLiAqKVxuICAgICAgICBiaXRzX3Blcl9zbG90IDogTnVtX2tleV9iaXRzLnRcbiAgICAgIDsga2V5c19wZXJfc2xvdCA6IEtleS5TcGFuLnRcbiAgICAgIDsgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA6IE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sudFxuICAgICAgOyAoKiBbZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5ID0ga2V5c19wZXJfc2xvdCAqIEFycmF5Lmxlbmd0aCBzbG90cyAtIDFdICopXG4gICAgICAgIGRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSA6IEtleS5TcGFuLnRcbiAgICAgIDsgKCogW2xlbmd0aF0gaXMgdGhlIG51bWJlciBvZiBlbHRzIGN1cnJlbnRseSBpbiB0aGlzIGxldmVsLiAqKVxuICAgICAgICBtdXRhYmxlIGxlbmd0aCA6IGludFxuICAgICAgOyAoKiBBbGwgZWxlbWVudHMgYXQgdGhpcyBsZXZlbCBoYXZlIHRoZWlyIFtrZXldIHNhdGlzZnkgW21pbl9hbGxvd2VkX2tleSA8PSBrZXkgPD1cbiAgICAgICAgICAgbWF4X2FsbG93ZWRfa2V5XS4gIEFsc28sIFttaW5fYWxsb3dlZF9rZXldIGlzIGEgbXVsdGlwbGUgb2YgW2tleXNfcGVyX3Nsb3RdLiAqKVxuICAgICAgICBtdXRhYmxlIG1pbl9hbGxvd2VkX2tleSA6IEtleS50XG4gICAgICA7IG11dGFibGUgbWF4X2FsbG93ZWRfa2V5IDogS2V5LnRcbiAgICAgIDsgKCogW3Nsb3RzXSBob2xkcyB0aGUgKHBvc3NpYmx5IG51bGwpIHBvaW50ZXJzIHRvIHRoZSBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3RzXG4gICAgICAgICAgIG9mIGVsdHMuICBbQXJyYXkubGVuZ3RoIHNsb3RzID0gMSBsc2wgYml0c10uICopXG4gICAgICAgIHNsb3RzIDogKCdhIEludGVybmFsX2VsdC50IGFycmF5W0BzZXhwLm9wYXF1ZV0pXG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxuICAgIGxldCBzbG90IHQgfmtleSA9IEtleS5zbG90IGtleSB+Yml0c19wZXJfc2xvdDp0LmJpdHNfcGVyX3Nsb3QgfnNsb3RzX21hc2s6dC5zbG90c19tYXNrXG4gICAgbGV0IG5leHRfc2xvdCB0IHNsb3QgPSBTbG90c19tYXNrLm5leHRfc2xvdCB0LnNsb3RzX21hc2sgc2xvdFxuXG4gICAgbGV0IG1pbl9rZXlfaW5fc2FtZV9zbG90IHQgfmtleSA9XG4gICAgICBLZXkubWluX2tleV9pbl9zYW1lX3Nsb3Qga2V5IHQubWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICAgIDs7XG5cbiAgICBsZXQgY29tcHV0ZV9taW5fYWxsb3dlZF9rZXkgdCB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkgPVxuICAgICAgKCogVGhpcyBjb21wdXRhdGlvbiBlbnN1cmVzIHRoYXQgW3RdJ3MgW21pbl9hbGxvd2VkX2tleV0gaXMgYXMgbGFyZ2UgYXMgcG9zc2libGVcbiAgICAgICAgIHN1YmplY3QgdG8gdGhlIGNvbnN0cmFpbnQgdGhhdCB0aGVyZSBpcyBubyBpbnRlci1sZXZlbCBnYXAuICopXG4gICAgICBpZiBLZXkuZXF1YWwgcHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkgS2V5Lm1heF92YWx1ZVxuICAgICAgdGhlbiBLZXkubWF4X3ZhbHVlXG4gICAgICBlbHNlIG1pbl9rZXlfaW5fc2FtZV9zbG90IHQgfmtleTooS2V5LnN1Y2MgcHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkpXG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSAnYSB0ID1cbiAgICB7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gICAgOyBtdXRhYmxlIHBvb2wgOiAnYSBJbnRlcm5hbF9lbHQuUG9vbC50XG4gICAgOyAoKiBbbWluX2VsdF0gaXMgZWl0aGVyIG51bGwgb3IgYW4gZWxlbWVudCB3aG9zZSBrZXkgaXMgW2VsdF9rZXlfbG93ZXJfYm91bmRdLiAqKVxuICAgICAgbXV0YWJsZSBtaW5fZWx0IDogJ2EgSW50ZXJuYWxfZWx0LnRcbiAgICA7ICgqIEFsbCBlbGVtZW50cyBpbiB0aGUgcHJpb3JpdHkgcXVldWUgaGF2ZSB0aGVpciBrZXkgWz49IGVsdF9rZXlfbG93ZXJfYm91bmRdLiAqKVxuICAgICAgbXV0YWJsZSBlbHRfa2V5X2xvd2VyX2JvdW5kIDogS2V5LnRcbiAgICA7IGxldmVscyA6ICdhIExldmVsLnQgYXJyYXlcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbiAgdHlwZSAnYSBwcmlvcml0eV9xdWV1ZSA9ICdhIHRcblxuICBtb2R1bGUgRWx0ID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgRXh0ZXJuYWxfZWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGxldCBudWxsID0gRXh0ZXJuYWxfZWx0Lm51bGxcbiAgICBsZXQgYXQgcCB0ID0gSW50ZXJuYWxfZWx0LmF0IHAucG9vbCAoSW50ZXJuYWxfZWx0Lm9mX2V4dGVybmFsX2V4biBwLnBvb2wgdClcbiAgICBsZXQga2V5IHAgdCA9IEludGVybmFsX2VsdC5rZXkgcC5wb29sIChJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHAucG9vbCB0KVxuICAgIGxldCB2YWx1ZSBwIHQgPSBJbnRlcm5hbF9lbHQudmFsdWUgcC5wb29sIChJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHAucG9vbCB0KVxuICBlbmRcblxuICBsZXQgc2V4cF9vZl90X2ludGVybmFsID0gc2V4cF9vZl90XG4gIGxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG4gIGxldCBudW1fbGV2ZWxzIHQgPSBBcnJheS5sZW5ndGggdC5sZXZlbHNcbiAgbGV0IG1pbl9hbGxvd2VkX2tleSB0ID0gTGV2ZWwubWluX2FsbG93ZWRfa2V5IHQubGV2ZWxzLigwKVxuICBsZXQgbWF4X2FsbG93ZWRfa2V5IHQgPSBMZXZlbC5tYXhfYWxsb3dlZF9rZXkgdC5sZXZlbHMuKG51bV9sZXZlbHMgdCAtIDEpXG5cbiAgbGV0IGludGVybmFsX2l0ZXIgdCB+ZiA9XG4gICAgaWYgdC5sZW5ndGggPiAwXG4gICAgdGhlbiAoXG4gICAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgICAgbGV0IGxldmVscyA9IHQubGV2ZWxzIGluXG4gICAgICBmb3IgbGV2ZWxfaW5kZXggPSAwIHRvIEFycmF5Lmxlbmd0aCBsZXZlbHMgLSAxIGRvXG4gICAgICAgIGxldCBsZXZlbCA9IGxldmVscy4obGV2ZWxfaW5kZXgpIGluXG4gICAgICAgIGlmIGxldmVsLmxlbmd0aCA+IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICAgICAgICBmb3Igc2xvdF9pbmRleCA9IDAgdG8gQXJyYXkubGVuZ3RoIHNsb3RzIC0gMSBkb1xuICAgICAgICAgICAgbGV0IGVsdCA9IHNsb3RzLihzbG90X2luZGV4KSBpblxuICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQpIHRoZW4gSW50ZXJuYWxfZWx0Lml0ZXIgcG9vbCBlbHQgfmZcbiAgICAgICAgICBkb25lKVxuICAgICAgZG9uZSlcbiAgOztcblxuICBsZXQgaXRlciB0IH5mID0gaW50ZXJuYWxfaXRlciB0IH5mOihmIDogXyBFbHQudCAtPiB1bml0IDo+IF8gSW50ZXJuYWxfZWx0LnQgLT4gdW5pdClcblxuICBtb2R1bGUgUHJldHR5ID0gc3RydWN0XG4gICAgbW9kdWxlIEVsdCA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgeyBrZXkgOiBLZXkudFxuICAgICAgICA7IHZhbHVlIDogJ2FcbiAgICAgICAgfVxuICAgICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICBlbmRcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IG1pbl9hbGxvd2VkX2tleSA6IEtleS50XG4gICAgICA7IG1heF9hbGxvd2VkX2tleSA6IEtleS50XG4gICAgICA7IGVsdHMgOiAnYSBFbHQudCBsaXN0XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbGV0IHByZXR0eSB0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIHsgUHJldHR5Lm1pbl9hbGxvd2VkX2tleSA9IG1pbl9hbGxvd2VkX2tleSB0XG4gICAgOyBtYXhfYWxsb3dlZF9rZXkgPSBtYXhfYWxsb3dlZF9rZXkgdFxuICAgIDsgZWx0cyA9XG4gICAgICAgIChsZXQgciA9IHJlZiBbXSBpblxuICAgICAgICAgaW50ZXJuYWxfaXRlciB0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgIHJcbiAgICAgICAgICAgICA6PSB7IFByZXR0eS5FbHQua2V5ID0gSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdFxuICAgICAgICAgICAgICAgIDsgdmFsdWUgPSBJbnRlcm5hbF9lbHQudmFsdWUgcG9vbCBlbHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOjogIXIpO1xuICAgICAgICAgTGlzdC5yZXYgIXIpXG4gICAgfVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIG1hdGNoICFzZXhwX29mX3Rfc3R5bGUgd2l0aFxuICAgIHwgYEludGVybmFsIC0+IFslc2V4cCAodCA6IGEgdF9pbnRlcm5hbCldXG4gICAgfCBgUHJldHR5IC0+IFslc2V4cCAocHJldHR5IHQgOiBhIFByZXR0eS50KV1cbiAgOztcblxuICBsZXQgY29tcHV0ZV9kaWZmX21heF9taW5fYWxsb3dlZF9rZXkgfmxldmVsX2JpdHMgfmJpdHNfcGVyX3Nsb3QgPVxuICAgIGxldCBiaXRzID0gTnVtX2tleV9iaXRzLiggKyApIGxldmVsX2JpdHMgYml0c19wZXJfc2xvdCBpblxuICAgIGlmIE51bV9rZXlfYml0cy5lcXVhbCBiaXRzIE51bV9rZXlfYml0cy5tYXhfdmFsdWVcbiAgICB0aGVuIEtleS5TcGFuLm1heF92YWx1ZVxuICAgIGVsc2UgS2V5LlNwYW4ucHJlZCAoS2V5Lm51bV9rZXlzIGJpdHMpXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0IDogdW5pdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBsZXQgbGV2ZWxfaW52YXJpYW50IGxldmVsID1cbiAgICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSBsZXZlbCBbJXNleHBfb2Y6IF8gTGV2ZWwudF0gKGZ1biAoKSAtPlxuICAgICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCBsZXZlbCBmIGluXG4gICAgICAgIExldmVsLkZpZWxkcy5pdGVyXG4gICAgICAgICAgfmluZGV4OihjaGVjayAoZnVuIGluZGV4IC0+IGFzc2VydCAoaW5kZXggPj0gMCkpKVxuICAgICAgICAgIH5iaXRzOihjaGVjayAoZnVuIGJpdHMgLT4gYXNzZXJ0IChOdW1fa2V5X2JpdHMuKCA+ICkgYml0cyBOdW1fa2V5X2JpdHMuemVybykpKVxuICAgICAgICAgIH5zbG90c19tYXNrOlxuICAgICAgICAgICAgKGNoZWNrXG4gICAgICAgICAgICAgICAoWyV0ZXN0X3Jlc3VsdDogU2xvdHNfbWFzay50XVxuICAgICAgICAgICAgICAgICAgfmV4cGVjdDooU2xvdHNfbWFzay5jcmVhdGUgfmxldmVsX2JpdHM6bGV2ZWwuYml0cykpKVxuICAgICAgICAgIH5iaXRzX3Blcl9zbG90OlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gYml0c19wZXJfc2xvdCAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChOdW1fa2V5X2JpdHMuKCA+PSApIGJpdHNfcGVyX3Nsb3QgTnVtX2tleV9iaXRzLnplcm8pKSlcbiAgICAgICAgICB+a2V5c19wZXJfc2xvdDpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIGtleXNfcGVyX3Nsb3QgLT5cbiAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEtleS5TcGFuLnRdXG4gICAgICAgICAgICAgICAgIGtleXNfcGVyX3Nsb3RcbiAgICAgICAgICAgICAgICAgfmV4cGVjdDooS2V5Lm51bV9rZXlzIGxldmVsLmJpdHNfcGVyX3Nsb3QpKSlcbiAgICAgICAgICB+bWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzazpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICAgIE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2suZXF1YWxcbiAgICAgICAgICAgICAgICAgICBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgICAgICAgICAgICAgICAgKE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2suY3JlYXRlIH5iaXRzX3Blcl9zbG90OmxldmVsLmJpdHNfcGVyX3Nsb3QpKSkpXG4gICAgICAgICAgfmRpZmZfbWF4X21pbl9hbGxvd2VkX2tleTpcbiAgICAgICAgICAgIChjaGVja1xuICAgICAgICAgICAgICAgKFsldGVzdF9yZXN1bHQ6IEtleS5TcGFuLnRdXG4gICAgICAgICAgICAgICAgICB+ZXhwZWN0OlxuICAgICAgICAgICAgICAgICAgICAoY29tcHV0ZV9kaWZmX21heF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgfmxldmVsX2JpdHM6bGV2ZWwuYml0c1xuICAgICAgICAgICAgICAgICAgICAgICB+Yml0c19wZXJfc2xvdDpsZXZlbC5iaXRzX3Blcl9zbG90KSkpXG4gICAgICAgICAgfmxlbmd0aDpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIGxlbmd0aCAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICAgICAgICAgID0gQXJyYXkuZm9sZCBsZXZlbC5zbG90cyB+aW5pdDowIH5mOihmdW4gbiBlbHQgLT5cbiAgICAgICAgICAgICAgICAgICAgIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdFxuICAgICAgICAgICAgICAgICAgICAgdGhlbiBuXG4gICAgICAgICAgICAgICAgICAgICBlbHNlIG4gKyBJbnRlcm5hbF9lbHQubGVuZ3RoIHBvb2wgZWx0KSkpKVxuICAgICAgICAgIH5taW5fYWxsb3dlZF9rZXk6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBtaW5fYWxsb3dlZF9rZXkgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoS2V5LiggPj0gKSBtaW5fYWxsb3dlZF9rZXkgS2V5Lnplcm8pO1xuICAgICAgICAgICAgICAgaWYgS2V5LiggPCApIG1pbl9hbGxvd2VkX2tleSBLZXkubWF4X3ZhbHVlXG4gICAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEtleS5TcGFuLnRdXG4gICAgICAgICAgICAgICAgICAgKEtleS5yZW0gbWluX2FsbG93ZWRfa2V5IGxldmVsLmtleXNfcGVyX3Nsb3QpXG4gICAgICAgICAgICAgICAgICAgfmV4cGVjdDpLZXkuU3Bhbi56ZXJvKSlcbiAgICAgICAgICB+bWF4X2FsbG93ZWRfa2V5OlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbWF4X2FsbG93ZWRfa2V5IC0+XG4gICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkudF1cbiAgICAgICAgICAgICAgICAgbWF4X2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgICAgKEtleS5hZGRfY2xhbXBfdG9fbWF4XG4gICAgICAgICAgICAgICAgICAgICAgbGV2ZWwubWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5KSkpXG4gICAgICAgICAgfnNsb3RzOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gc2xvdHMgLT5cbiAgICAgICAgICAgICAgIEFycmF5Lml0ZXIgc2xvdHMgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQpXG4gICAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICAgIEludGVybmFsX2VsdC5pbnZhcmlhbnQgcG9vbCBpbnZhcmlhbnRfYSBlbHQ7XG4gICAgICAgICAgICAgICAgICAgSW50ZXJuYWxfZWx0Lml0ZXIgcG9vbCBlbHQgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAoS2V5LiggPj0gKSAoSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdCkgbGV2ZWwubWluX2FsbG93ZWRfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAoS2V5LiggPD0gKSAoSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdCkgbGV2ZWwubWF4X2FsbG93ZWRfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAoS2V5LiggPj0gKSAoSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdCkgdC5lbHRfa2V5X2xvd2VyX2JvdW5kKTtcbiAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAoSW50ZXJuYWxfZWx0LmxldmVsX2luZGV4IHBvb2wgZWx0ID0gbGV2ZWwuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgaW52YXJpYW50X2EgKEludGVybmFsX2VsdC52YWx1ZSBwb29sIGVsdCkpKSkpKSlcbiAgICBpblxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0X2ludGVybmFsXSAoZnVuICgpIC0+XG4gICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgIGFzc2VydCAoS2V5LiggPj0gKSAobWluX2FsbG93ZWRfa2V5IHQpIEtleS56ZXJvKTtcbiAgICAgIGFzc2VydCAoS2V5LiggPj0gKSAobWF4X2FsbG93ZWRfa2V5IHQpIChtaW5fYWxsb3dlZF9rZXkgdCkpO1xuICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgfmxlbmd0aDooY2hlY2sgKGZ1biBsZW5ndGggLT4gYXNzZXJ0IChsZW5ndGggPj0gMCkpKVxuICAgICAgICB+cG9vbDooY2hlY2sgKEludGVybmFsX2VsdC5Qb29sLmludmFyaWFudCBpZ25vcmUpKVxuICAgICAgICB+bWluX2VsdDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBlbHRfIC0+XG4gICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHRfKVxuICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgYXNzZXJ0IChJbnRlcm5hbF9lbHQuaXNfdmFsaWQgdC5wb29sIGVsdF8pO1xuICAgICAgICAgICAgICAgYXNzZXJ0IChLZXkuZXF1YWwgdC5lbHRfa2V5X2xvd2VyX2JvdW5kIChJbnRlcm5hbF9lbHQua2V5IHQucG9vbCBlbHRfKSkpKSlcbiAgICAgICAgfmVsdF9rZXlfbG93ZXJfYm91bmQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gZWx0X2tleV9sb3dlcl9ib3VuZCAtPlxuICAgICAgICAgICAgIGFzc2VydCAoS2V5LiggPj0gKSBlbHRfa2V5X2xvd2VyX2JvdW5kIChtaW5fYWxsb3dlZF9rZXkgdCkpO1xuICAgICAgICAgICAgIGFzc2VydCAoS2V5LiggPD0gKSBlbHRfa2V5X2xvd2VyX2JvdW5kIChtYXhfYWxsb3dlZF9rZXkgdCkpO1xuICAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgdC5taW5fZWx0KVxuICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgIGFzc2VydCAoS2V5LmVxdWFsIGVsdF9rZXlfbG93ZXJfYm91bmQgKEludGVybmFsX2VsdC5rZXkgdC5wb29sIHQubWluX2VsdCkpKSlcbiAgICAgICAgfmxldmVsczpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBsZXZlbHMgLT5cbiAgICAgICAgICAgICBhc3NlcnQgKG51bV9sZXZlbHMgdCA+IDApO1xuICAgICAgICAgICAgIEFycmF5Lml0ZXJpIGxldmVscyB+ZjooZnVuIGxldmVsX2luZGV4IGxldmVsIC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKGxldmVsX2luZGV4ID0gTGV2ZWwuaW5kZXggbGV2ZWwpO1xuICAgICAgICAgICAgICAgbGV2ZWxfaW52YXJpYW50IGxldmVsO1xuICAgICAgICAgICAgICAgaWYgbGV2ZWxfaW5kZXggPiAwXG4gICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgbGV0IHByZXZfbGV2ZWwgPSBsZXZlbHMuKGxldmVsX2luZGV4IC0gMSkgaW5cbiAgICAgICAgICAgICAgICAgbGV0IG1vZHVsZSBMID0gTGV2ZWwgaW5cbiAgICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LlNwYW4udF1cbiAgICAgICAgICAgICAgICAgICAoTC5rZXlzX3Blcl9zbG90IGxldmVsKVxuICAgICAgICAgICAgICAgICAgIH5leHBlY3Q6KEtleS5TcGFuLnN1Y2MgcHJldl9sZXZlbC5kaWZmX21heF9taW5fYWxsb3dlZF9rZXkpO1xuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkudF1cbiAgICAgICAgICAgICAgICAgICBsZXZlbC5taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgICB+ZXhwZWN0OlxuICAgICAgICAgICAgICAgICAgICAgKExldmVsLmNvbXB1dGVfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgfnByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5OnByZXZfbGV2ZWwubWF4X2FsbG93ZWRfa2V5KSkpKSkpXG4gIDs7XG5cbiAgKCoqIFttaW5fZWx0X10gcmV0dXJucyBbbnVsbF0gaWYgaXQgY2FuJ3QgZmluZCB0aGUgZGVzaXJlZCBlbGVtZW50LiAgV2Ugd3JhcCBpdCB1cFxuICAgICAgYWZ0ZXJ3YXJkcyB0byByZXR1cm4gYW4gW29wdGlvbl0uICopXG4gIGxldCBtaW5fZWx0XyB0ID1cbiAgICBpZiBpc19lbXB0eSB0XG4gICAgdGhlbiBJbnRlcm5hbF9lbHQubnVsbCAoKVxuICAgIGVsc2UgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCB0Lm1pbl9lbHQpXG4gICAgdGhlbiB0Lm1pbl9lbHRcbiAgICBlbHNlIChcbiAgICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgICBsZXQgbWluX2VsdF9hbHJlYWR5X2ZvdW5kID0gcmVmIChJbnRlcm5hbF9lbHQubnVsbCAoKSkgaW5cbiAgICAgIGxldCBtaW5fa2V5X2FscmVhZHlfZm91bmQgPSByZWYgS2V5Lm1heF92YWx1ZSBpblxuICAgICAgbGV0IGxldmVsX2luZGV4ID0gcmVmIDAgaW5cbiAgICAgIGxldCBudW1fbGV2ZWxzID0gbnVtX2xldmVscyB0IGluXG4gICAgICB3aGlsZSAhbGV2ZWxfaW5kZXggPCBudW1fbGV2ZWxzIGRvXG4gICAgICAgIGxldCBsZXZlbCA9IHQubGV2ZWxzLighbGV2ZWxfaW5kZXgpIGluXG4gICAgICAgIGlmIEtleS4oID4gKSAoTGV2ZWwubWluX2FsbG93ZWRfa2V5IGxldmVsKSAhbWluX2tleV9hbHJlYWR5X2ZvdW5kXG4gICAgICAgIHRoZW5cbiAgICAgICAgICAoKiBXZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIGFueSBtb3JlIGxldmVscy4gIFF1aXQgdGhlIGxvb3AuICopXG4gICAgICAgICAgbGV2ZWxfaW5kZXggOj0gbnVtX2xldmVsc1xuICAgICAgICBlbHNlIGlmIGxldmVsLmxlbmd0aCA9IDBcbiAgICAgICAgdGhlbiBpbmNyIGxldmVsX2luZGV4XG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIExvb2sgaW4gW2xldmVsXS4gKilcbiAgICAgICAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgICAgICAgIGxldCBzbG90X21pbl9rZXkgPVxuICAgICAgICAgICAgcmVmXG4gICAgICAgICAgICAgIChMZXZlbC5taW5fa2V5X2luX3NhbWVfc2xvdFxuICAgICAgICAgICAgICAgICBsZXZlbFxuICAgICAgICAgICAgICAgICB+a2V5OihLZXkubWF4IGxldmVsLm1pbl9hbGxvd2VkX2tleSB0LmVsdF9rZXlfbG93ZXJfYm91bmQpKVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHNsb3QgPSByZWYgKExldmVsLnNsb3QgbGV2ZWwgfmtleTohc2xvdF9taW5fa2V5KSBpblxuICAgICAgICAgICgqIEZpbmQgdGhlIGZpcnN0IG5vbmVtcHR5IHNsb3Qgd2l0aCBhIHNtYWxsIGVub3VnaCBbc2xvdF9taW5fa2V5XS4gKilcbiAgICAgICAgICB3aGlsZVxuICAgICAgICAgICAgSW50ZXJuYWxfZWx0LmlzX251bGwgc2xvdHMuKCFzbG90KVxuICAgICAgICAgICAgJiYgS2V5LiggPCApICFzbG90X21pbl9rZXkgIW1pbl9rZXlfYWxyZWFkeV9mb3VuZFxuICAgICAgICAgIGRvXG4gICAgICAgICAgICBzbG90IDo9IExldmVsLm5leHRfc2xvdCBsZXZlbCAhc2xvdDtcbiAgICAgICAgICAgIHNsb3RfbWluX2tleSA6PSBLZXkuYWRkICFzbG90X21pbl9rZXkgbGV2ZWwua2V5c19wZXJfc2xvdFxuICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgbGV0IGZpcnN0ID0gc2xvdHMuKCFzbG90KSBpblxuICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZmlyc3QpXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAoKiBWaXNpdCBhbGwgb2YgdGhlIGVsdHMgaW4gdGhpcyBzbG90IGFuZCBmaW5kIG9uZSB3aXRoIG1pbmltdW0ga2V5LiAqKVxuICAgICAgICAgICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICAgICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgICAgICAgbGV0IGN1cnJlbnRfa2V5ID0gSW50ZXJuYWxfZWx0LmtleSBwb29sICFjdXJyZW50IGluXG4gICAgICAgICAgICAgIGlmIEtleS4oIDw9ICkgY3VycmVudF9rZXkgIW1pbl9rZXlfYWxyZWFkeV9mb3VuZFxuICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICBtaW5fZWx0X2FscmVhZHlfZm91bmQgOj0gIWN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgbWluX2tleV9hbHJlYWR5X2ZvdW5kIDo9IGN1cnJlbnRfa2V5KTtcbiAgICAgICAgICAgICAgbGV0IG5leHQgPSBJbnRlcm5hbF9lbHQubmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICAgICAgICAgICgqIElmIFshbGV2ZWxfaW5kZXggPSAwXSB0aGVuIGFsbCBlbHRzIGluIHRoaXMgc2xvdCBoYXZlIHRoZSBzYW1lIFtrZXldLFxuICAgICAgICAgICAgICAgICBpLmUuIFshc2xvdF9taW5fa2V5XS4gIFNvLCB3ZSBkb24ndCBoYXZlIHRvIGNoZWNrIGFueSBlbGVtZW50cyBhZnRlclxuICAgICAgICAgICAgICAgICBbZmlyc3RdLiAgVGhpcyBpcyBhIHVzZWZ1bCBzaG9ydCBjdXQgaW4gdGhlIGNvbW1vbiBjYXNlIHRoYXQgdGhlcmUgYXJlXG4gICAgICAgICAgICAgICAgIG11bHRpcGxlIGVsZW1lbnRzIGluIHRoZSBzYW1lIG1pbiBzbG90IGluIGxldmVsIDAuICopXG4gICAgICAgICAgICAgIGlmIHBoeXNfZXF1YWwgbmV4dCBmaXJzdCB8fCAhbGV2ZWxfaW5kZXggPSAwXG4gICAgICAgICAgICAgIHRoZW4gY29udGludWUgOj0gZmFsc2VcbiAgICAgICAgICAgICAgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgICAgICAgIGRvbmUpO1xuICAgICAgICAgICgqIEZpbmlzaGVkIGxvb2tpbmcgaW4gW2xldmVsXS4gIE1vdmUgdXAgdG8gdGhlIG5leHQgbGV2ZWwuICopXG4gICAgICAgICAgaW5jciBsZXZlbF9pbmRleClcbiAgICAgIGRvbmU7XG4gICAgICB0Lm1pbl9lbHQgPC0gIW1pbl9lbHRfYWxyZWFkeV9mb3VuZDtcbiAgICAgIHQuZWx0X2tleV9sb3dlcl9ib3VuZCA8LSAhbWluX2tleV9hbHJlYWR5X2ZvdW5kO1xuICAgICAgdC5taW5fZWx0KVxuICA7O1xuXG4gIGxldFtAY29sZF0gcmFpc2VfYWRkX2VsdF9rZXlfb3V0X29mX2JvdW5kcyB0IGtleSA9XG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiUHJpb3JpdHlfcXVldWUuYWRkX2VsdCBrZXkgb3V0IG9mIGJvdW5kc1wiXG4gICAgICAgICAgKGtleSA6IEtleS50KVxuICAgICAgICAgIChtaW5fYWxsb3dlZF9rZXkgdCA6IEtleS50KVxuICAgICAgICAgIChtYXhfYWxsb3dlZF9rZXkgdCA6IEtleS50KVxuICAgICAgICAgIH5wcmlvcml0eV9xdWV1ZToodCA6IF8gdCldXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9hZGRfZWx0X2tleV9vdXRfb2ZfbGV2ZWxfYm91bmRzIGtleSBsZXZlbCA9XG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiUHJpb3JpdHlfcXVldWUuYWRkX2VsdCBrZXkgb3V0IG9mIGxldmVsIGJvdW5kc1wiIChrZXkgOiBLZXkudCkgKGxldmVsIDogXyBMZXZlbC50KV1cbiAgOztcblxuICBsZXQgYWRkX2VsdCB0IGVsdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBsZXQga2V5ID0gSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdCBpblxuICAgIGlmIG5vdCAoS2V5LiggPj0gKSBrZXkgKG1pbl9hbGxvd2VkX2tleSB0KSAmJiBLZXkuKCA8PSApIGtleSAobWF4X2FsbG93ZWRfa2V5IHQpKVxuICAgIHRoZW4gcmFpc2VfYWRkX2VsdF9rZXlfb3V0X29mX2JvdW5kcyB0IGtleTtcbiAgICAoKiBGaW5kIHRoZSBsb3dlc3QgbGV2ZWwgdGhhdCB3aWxsIGhvbGQgW2VsdF0uICopXG4gICAgbGV0IGxldmVsX2luZGV4ID1cbiAgICAgIGxldCBsZXZlbF9pbmRleCA9IHJlZiAwIGluXG4gICAgICB3aGlsZSBLZXkuKCA+ICkga2V5IChMZXZlbC5tYXhfYWxsb3dlZF9rZXkgdC5sZXZlbHMuKCFsZXZlbF9pbmRleCkpIGRvXG4gICAgICAgIGluY3IgbGV2ZWxfaW5kZXhcbiAgICAgIGRvbmU7XG4gICAgICAhbGV2ZWxfaW5kZXhcbiAgICBpblxuICAgIGxldCBsZXZlbCA9IHQubGV2ZWxzLihsZXZlbF9pbmRleCkgaW5cbiAgICBpZiBub3QgKEtleS4oID49ICkga2V5IGxldmVsLm1pbl9hbGxvd2VkX2tleSAmJiBLZXkuKCA8PSApIGtleSBsZXZlbC5tYXhfYWxsb3dlZF9rZXkpXG4gICAgdGhlbiByYWlzZV9hZGRfZWx0X2tleV9vdXRfb2ZfbGV2ZWxfYm91bmRzIGtleSBsZXZlbDtcbiAgICBsZXZlbC5sZW5ndGggPC0gbGV2ZWwubGVuZ3RoICsgMTtcbiAgICBJbnRlcm5hbF9lbHQuc2V0X2xldmVsX2luZGV4IHBvb2wgZWx0IGxldmVsX2luZGV4O1xuICAgIGxldCBzbG90ID0gTGV2ZWwuc2xvdCBsZXZlbCB+a2V5IGluXG4gICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICBsZXQgZmlyc3QgPSBzbG90cy4oc2xvdCkgaW5cbiAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGZpcnN0KVxuICAgIHRoZW4gSW50ZXJuYWxfZWx0Lmluc2VydF9hdF9lbmQgcG9vbCBmaXJzdCB+dG9fYWRkOmVsdFxuICAgIGVsc2UgKFxuICAgICAgc2xvdHMuKHNsb3QpIDwtIGVsdDtcbiAgICAgIEludGVybmFsX2VsdC5saW5rX3RvX3NlbGYgcG9vbCBlbHQpXG4gIDs7XG5cbiAgbGV0IGludGVybmFsX2FkZF9lbHQgdCBlbHQgPVxuICAgIGxldCBrZXkgPSBJbnRlcm5hbF9lbHQua2V5IHQucG9vbCBlbHQgaW5cbiAgICBpZiBLZXkuKCA8ICkga2V5IHQuZWx0X2tleV9sb3dlcl9ib3VuZFxuICAgIHRoZW4gKFxuICAgICAgdC5taW5fZWx0IDwtIGVsdDtcbiAgICAgIHQuZWx0X2tleV9sb3dlcl9ib3VuZCA8LSBrZXkpO1xuICAgIGFkZF9lbHQgdCBlbHQ7XG4gICAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9nb3RfaW52YWxpZF9rZXkgdCBrZXkgPVxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlRpbWluZ193aGVlbC5hZGRfYXRfaW50ZXJ2YWxfbnVtIGdvdCBpbnZhbGlkIGludGVydmFsIG51bVwiXG4gICAgICAgICAgfmludGVydmFsX251bTooa2V5IDogS2V5LnQpXG4gICAgICAgICAgfm1pbl9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bToobWluX2FsbG93ZWRfa2V5IHQgOiBLZXkudClcbiAgICAgICAgICB+bWF4X2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtOihtYXhfYWxsb3dlZF9rZXkgdCA6IEtleS50KV1cbiAgOztcblxuICBsZXQgZW5zdXJlX3ZhbGlkX2tleSB0IH5rZXkgPVxuICAgIGlmIEtleS4oIDwgKSBrZXkgKG1pbl9hbGxvd2VkX2tleSB0KSB8fCBLZXkuKCA+ICkga2V5IChtYXhfYWxsb3dlZF9rZXkgdClcbiAgICB0aGVuIHJhaXNlX2dvdF9pbnZhbGlkX2tleSB0IGtleVxuICA7O1xuXG4gIGxldCBpbnRlcm5hbF9hZGQgdCB+a2V5IH5hdCB2YWx1ZSA9XG4gICAgZW5zdXJlX3ZhbGlkX2tleSB0IH5rZXk7XG4gICAgaWYgSW50ZXJuYWxfZWx0LlBvb2wuaXNfZnVsbCB0LnBvb2wgdGhlbiB0LnBvb2wgPC0gSW50ZXJuYWxfZWx0LlBvb2wuZ3JvdyB0LnBvb2w7XG4gICAgbGV0IGVsdCA9IEludGVybmFsX2VsdC5jcmVhdGUgdC5wb29sIH5rZXkgfmF0IH52YWx1ZSB+bGV2ZWxfaW5kZXg6KC0xKSBpblxuICAgIGludGVybmFsX2FkZF9lbHQgdCBlbHQ7XG4gICAgZWx0XG4gIDs7XG5cbiAgKCoqIFtyZW1vdmVfb3JfcmVfYWRkX2VsdHNdIHZpc2l0cyBlYWNoIGVsZW1lbnQgaW4gdGhlIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdFxuICAgICAgW2ZpcnN0XS4gIElmIHRoZSBlbGVtZW50J3Mga2V5IGlzIFs+PSB0X21pbl9hbGxvd2VkX2tleV0sIHRoZW4gaXQgYWRkcyB0aGUgZWxlbWVudFxuICAgICAgYmFjayBhdCBhIGxvd2VyIGxldmVsLiAgSWYgbm90LCB0aGVuIGl0IGNhbGxzIFtoYW5kbGVfcmVtb3ZlZF0gYW5kIFtmcmVlXXMgdGhlXG4gICAgICBlbGVtZW50LiAqKVxuICBsZXQgcmVtb3ZlX29yX3JlX2FkZF9lbHRzIHQgKGxldmVsIDogXyBMZXZlbC50KSBmaXJzdCB+dF9taW5fYWxsb3dlZF9rZXkgfmhhbmRsZV9yZW1vdmVkXG4gICAgPVxuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgKCogV2UgZXh0cmFjdCBbbmV4dF0gZnJvbSBbY3VycmVudF0gZmlyc3QsIGJlY2F1c2Ugd2Ugd2lsbCBtb2RpZnkgb3IgW2ZyZWVdXG4gICAgICAgICBbY3VycmVudF0gYmVmb3JlIGNvbnRpbnVpbmcgdGhlIGxvb3AuICopXG4gICAgICBsZXQgbmV4dCA9IEludGVybmFsX2VsdC5uZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgIGxldmVsLmxlbmd0aCA8LSBsZXZlbC5sZW5ndGggLSAxO1xuICAgICAgaWYgS2V5LiggPj0gKSAoSW50ZXJuYWxfZWx0LmtleSBwb29sICFjdXJyZW50KSB0X21pbl9hbGxvd2VkX2tleVxuICAgICAgdGhlbiBhZGRfZWx0IHQgIWN1cnJlbnRcbiAgICAgIGVsc2UgKFxuICAgICAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gICAgICAgIGhhbmRsZV9yZW1vdmVkIChJbnRlcm5hbF9lbHQudG9fZXh0ZXJuYWwgIWN1cnJlbnQpO1xuICAgICAgICBJbnRlcm5hbF9lbHQuZnJlZSBwb29sICFjdXJyZW50KTtcbiAgICAgIGlmIHBoeXNfZXF1YWwgbmV4dCBmaXJzdCB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlIGVsc2UgY3VycmVudCA6PSBuZXh0XG4gICAgZG9uZVxuICA7O1xuXG4gICgqKiBbaW5jcmVhc2VfbGV2ZWxfbWluX2FsbG93ZWRfa2V5XSBpbmNyZWFzZXMgdGhlIFttaW5fYWxsb3dlZF9rZXldIG9mIFtsZXZlbF0gdG8gYXNcbiAgICAgIGxhcmdlIGEgdmFsdWUgYXMgcG9zc2libGUsIGJ1dCBubyBtb3JlIHRoYW4gW21heF9sZXZlbF9taW5fYWxsb3dlZF9rZXldLlxuICAgICAgW3RfbWluX2FsbG93ZWRfa2V5XSBpcyB0aGUgbWluaW11bSBhbGxvd2VkIGtleSBmb3IgdGhlIGVudGlyZSB0aW1pbmcgd2hlZWwuICBBc1xuICAgICAgZWxlbWVudHMgYXJlIGVuY291bnRlcmVkLCB0aGV5IGFyZSByZW1vdmVkIGZyb20gdGhlIHRpbWluZyB3aGVlbCBpZiB0aGVpciBrZXkgaXNcbiAgICAgIHNtYWxsZXIgdGhhbiBbdF9taW5fYWxsb3dlZF9rZXldLCBvciBhZGRlZCBhdCBhIGxvd2VyIGxldmVsIGlmIG5vdC4gKilcbiAgbGV0IGluY3JlYXNlX2xldmVsX21pbl9hbGxvd2VkX2tleVxuICAgIHRcbiAgICAobGV2ZWwgOiBfIExldmVsLnQpXG4gICAgfnByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5XG4gICAgfnRfbWluX2FsbG93ZWRfa2V5XG4gICAgfmhhbmRsZV9yZW1vdmVkXG4gICAgPVxuICAgIGxldCBkZXNpcmVkX21pbl9hbGxvd2VkX2tleSA9XG4gICAgICBMZXZlbC5jb21wdXRlX21pbl9hbGxvd2VkX2tleSBsZXZlbCB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXlcbiAgICBpblxuICAgICgqIFdlIHJlcXVpcmUgdGhhdCBbbW9kIGxldmVsLm1pbl9hbGxvd2VkX2tleSBsZXZlbC5rZXlzX3Blcl9zbG90ID0gMF0uICBTbyxcbiAgICAgICB3ZSBzdGFydCBbbGV2ZWxfbWluX2FsbG93ZWRfa2V5XSB3aGVyZSB0aGF0IGlzIHRydWUsIGFuZCB0aGVuIGluY3JlYXNlIGl0IGJ5XG4gICAgICAgW2tleXNfcGVyX3Nsb3RdIGVhY2ggaXRlcmF0aW9uIG9mIHRoZSBsb29wLiAqKVxuICAgIGxldCBsZXZlbF9taW5fYWxsb3dlZF9rZXkgPVxuICAgICAgTGV2ZWwubWluX2tleV9pbl9zYW1lX3Nsb3RcbiAgICAgICAgbGV2ZWxcbiAgICAgICAgfmtleTpcbiAgICAgICAgICAoS2V5Lm1pblxuICAgICAgICAgICAgIGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgKEtleS5tYXggbGV2ZWwubWluX2FsbG93ZWRfa2V5IHQuZWx0X2tleV9sb3dlcl9ib3VuZCkpXG4gICAgaW5cbiAgICBsZXQgbGV2ZWxfbWluX2FsbG93ZWRfa2V5ID0gcmVmIGxldmVsX21pbl9hbGxvd2VkX2tleSBpblxuICAgIGxldCBzbG90ID0gcmVmIChMZXZlbC5zbG90IGxldmVsIH5rZXk6IWxldmVsX21pbl9hbGxvd2VkX2tleSkgaW5cbiAgICBsZXQga2V5c19wZXJfc2xvdCA9IGxldmVsLmtleXNfcGVyX3Nsb3QgaW5cbiAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgIHdoaWxlIEtleS4oIDwgKSAhbGV2ZWxfbWluX2FsbG93ZWRfa2V5IGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IGRvXG4gICAgICBpZiBsZXZlbC5sZW5ndGggPSAwXG4gICAgICB0aGVuXG4gICAgICAgICgqIElmIG5vIGVsZW1lbnRzIHJlbWFpbiBhdCB0aGlzIGxldmVsLCB3ZSBjYW4ganVzdCBzZXQgW21pbl9hbGxvd2VkX2tleV0gdG8gdGhlXG4gICAgICAgICAgIGRlc2lyZWQgdmFsdWUuICopXG4gICAgICAgIGxldmVsX21pbl9hbGxvd2VkX2tleSA6PSBkZXNpcmVkX21pbl9hbGxvd2VkX2tleVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBmaXJzdCA9IHNsb3RzLighc2xvdCkgaW5cbiAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBmaXJzdClcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgc2xvdHMuKCFzbG90KSA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKTtcbiAgICAgICAgICByZW1vdmVfb3JfcmVfYWRkX2VsdHMgdCBsZXZlbCBmaXJzdCB+dF9taW5fYWxsb3dlZF9rZXkgfmhhbmRsZV9yZW1vdmVkKTtcbiAgICAgICAgc2xvdCA6PSBMZXZlbC5uZXh0X3Nsb3QgbGV2ZWwgIXNsb3Q7XG4gICAgICAgIGxldmVsX21pbl9hbGxvd2VkX2tleSA6PSBLZXkuYWRkX2NsYW1wX3RvX21heCAhbGV2ZWxfbWluX2FsbG93ZWRfa2V5IGtleXNfcGVyX3Nsb3QpXG4gICAgZG9uZTtcbiAgICBsZXZlbC5taW5fYWxsb3dlZF9rZXkgPC0gZGVzaXJlZF9taW5fYWxsb3dlZF9rZXk7XG4gICAgbGV2ZWwubWF4X2FsbG93ZWRfa2V5XG4gICAgICA8LSBLZXkuYWRkX2NsYW1wX3RvX21heCBkZXNpcmVkX21pbl9hbGxvd2VkX2tleSBsZXZlbC5kaWZmX21heF9taW5fYWxsb3dlZF9rZXlcbiAgOztcblxuICBtb2R1bGUgSW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5X3Jlc3VsdCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB8IE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZVxuICAgICAgfCBNYXhfYWxsb3dlZF9rZXlfbWF5YmVfY2hhbmdlZFxuICBlbmRcblxuICBsZXQgaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5IHQgfmtleSB+aGFuZGxlX3JlbW92ZWQgOiBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0LnQgPVxuICAgIGlmIEtleS4oIDw9ICkga2V5IChtaW5fYWxsb3dlZF9rZXkgdClcbiAgICB0aGVuIE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZVxuICAgIGVsc2UgKFxuICAgICAgKCogV2UgaW5jcmVhc2UgdGhlIFttaW5fYWxsb3dlZF9rZXldIG9mIGxldmVscyBpbiBvcmRlciB0byByZXN0b3JlIHRoZSBpbnZhcmlhbnRcbiAgICAgICAgIHRoYXQgdGhleSBoYXZlIGFzIGxhcmdlIGFzIHBvc3NpYmxlIGEgW21pbl9hbGxvd2VkX2tleV0sIHdoaWxlIGxlYXZpbmcgbm8gZ2Fwc1xuICAgICAgICAgaW4ga2V5cy4gKilcbiAgICAgIGxldCBsZXZlbF9pbmRleCA9IHJlZiAwIGluXG4gICAgICBsZXQgcmVzdWx0ID0gcmVmIEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQuTWF4X2FsbG93ZWRfa2V5X21heWJlX2NoYW5nZWQgaW5cbiAgICAgIGxldCBwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSA9IHJlZiAoS2V5LnByZWQga2V5KSBpblxuICAgICAgbGV0IGxldmVscyA9IHQubGV2ZWxzIGluXG4gICAgICBsZXQgbnVtX2xldmVscyA9IG51bV9sZXZlbHMgdCBpblxuICAgICAgd2hpbGUgIWxldmVsX2luZGV4IDwgbnVtX2xldmVscyBkb1xuICAgICAgICBsZXQgbGV2ZWwgPSBsZXZlbHMuKCFsZXZlbF9pbmRleCkgaW5cbiAgICAgICAgbGV0IG1pbl9hbGxvd2VkX2tleV9iZWZvcmUgPSBsZXZlbC5taW5fYWxsb3dlZF9rZXkgaW5cbiAgICAgICAgaW5jcmVhc2VfbGV2ZWxfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgdFxuICAgICAgICAgIGxldmVsXG4gICAgICAgICAgfnByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5OiFwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleVxuICAgICAgICAgIH50X21pbl9hbGxvd2VkX2tleTprZXlcbiAgICAgICAgICB+aGFuZGxlX3JlbW92ZWQ7XG4gICAgICAgIGlmIEtleS5lcXVhbCAoTGV2ZWwubWluX2FsbG93ZWRfa2V5IGxldmVsKSBtaW5fYWxsb3dlZF9rZXlfYmVmb3JlXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgICgqIFRoaXMgbGV2ZWwgZGlkIG5vdCBzaGlmdC4gIERvbid0IHNoaWZ0IGFueSBoaWdoZXIgbGV2ZWxzLiAqKVxuICAgICAgICAgIGxldmVsX2luZGV4IDo9IG51bV9sZXZlbHM7XG4gICAgICAgICAgcmVzdWx0IDo9IE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZSlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogTGV2ZWwgW2xldmVsX2luZGV4XSBzaGlmdGVkLiAgQ29uc2lkZXIgc2hpZnRpbmcgaGlnaGVyIGxldmVscy4gKilcbiAgICAgICAgICBsZXZlbF9pbmRleCA6PSAhbGV2ZWxfaW5kZXggKyAxO1xuICAgICAgICAgIHByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5IDo9IExldmVsLm1heF9hbGxvd2VkX2tleSBsZXZlbClcbiAgICAgIGRvbmU7XG4gICAgICBpZiBLZXkuKCA+ICkga2V5IHQuZWx0X2tleV9sb3dlcl9ib3VuZFxuICAgICAgdGhlbiAoXG4gICAgICAgICgqIFdlIGhhdmUgcmVtb3ZlZCBbdC5taW5fZWx0XSBvciBpdCB3YXMgYWxyZWFkeSBudWxsLCBzbyBqdXN0IHNldCBpdCB0b1xuICAgICAgICAgICBudWxsLiAqKVxuICAgICAgICB0Lm1pbl9lbHQgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKCk7XG4gICAgICAgIHQuZWx0X2tleV9sb3dlcl9ib3VuZCA8LSBtaW5fYWxsb3dlZF9rZXkgdCk7XG4gICAgICAhcmVzdWx0KVxuICA7O1xuXG4gIGxldCBjcmVhdGUgP2NhcGFjaXR5ID9sZXZlbF9iaXRzICgpID1cbiAgICBsZXQgbGV2ZWxfYml0cyA9XG4gICAgICBtYXRjaCBsZXZlbF9iaXRzIHdpdGhcbiAgICAgIHwgU29tZSBsIC0+IGxcbiAgICAgIHwgTm9uZSAtPiBMZXZlbF9iaXRzLmRlZmF1bHRcbiAgICBpblxuICAgIGxldCBfLCBfLCBsZXZlbHMgPVxuICAgICAgTGlzdC5mb2xkaVxuICAgICAgICBsZXZlbF9iaXRzXG4gICAgICAgIH5pbml0OihOdW1fa2V5X2JpdHMuemVybywgS2V5Lnplcm8sIFtdKVxuICAgICAgICB+ZjpcbiAgICAgICAgICAoZnVuXG4gICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgKGJpdHNfcGVyX3Nsb3QsIG1heF9sZXZlbF9taW5fYWxsb3dlZF9rZXksIGxldmVscylcbiAgICAgICAgICAgIChsZXZlbF9iaXRzIDogTnVtX2tleV9iaXRzLnQpXG4gICAgICAgICAgICAtPlxuICAgICAgICBsZXQga2V5c19wZXJfc2xvdCA9IEtleS5udW1fa2V5cyBiaXRzX3Blcl9zbG90IGluXG4gICAgICAgIGxldCBkaWZmX21heF9taW5fYWxsb3dlZF9rZXkgPVxuICAgICAgICAgIGNvbXB1dGVfZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5IH5sZXZlbF9iaXRzIH5iaXRzX3Blcl9zbG90XG4gICAgICAgIGluXG4gICAgICAgIGxldCBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrID0gTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay5jcmVhdGUgfmJpdHNfcGVyX3Nsb3QgaW5cbiAgICAgICAgbGV0IG1pbl9hbGxvd2VkX2tleSA9XG4gICAgICAgICAgS2V5Lm1pbl9rZXlfaW5fc2FtZV9zbG90IG1heF9sZXZlbF9taW5fYWxsb3dlZF9rZXkgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICAgICAgICBpblxuICAgICAgICBsZXQgbWF4X2FsbG93ZWRfa2V5ID1cbiAgICAgICAgICBLZXkuYWRkX2NsYW1wX3RvX21heCBtaW5fYWxsb3dlZF9rZXkgZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgIGluXG4gICAgICAgIGxldCBsZXZlbCA9XG4gICAgICAgICAgeyBMZXZlbC5pbmRleFxuICAgICAgICAgIDsgYml0cyA9IGxldmVsX2JpdHNcbiAgICAgICAgICA7IHNsb3RzX21hc2sgPSBTbG90c19tYXNrLmNyZWF0ZSB+bGV2ZWxfYml0c1xuICAgICAgICAgIDsgYml0c19wZXJfc2xvdFxuICAgICAgICAgIDsga2V5c19wZXJfc2xvdFxuICAgICAgICAgIDsgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICAgICAgICAgIDsgZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgOyBsZW5ndGggPSAwXG4gICAgICAgICAgOyBtaW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICA7IG1heF9hbGxvd2VkX2tleVxuICAgICAgICAgIDsgc2xvdHMgPVxuICAgICAgICAgICAgICBBcnJheS5jcmVhdGVcbiAgICAgICAgICAgICAgICB+bGVuOihJbnQ2My50b19pbnRfZXhuIChOdW1fa2V5X2JpdHMucG93MiBsZXZlbF9iaXRzKSlcbiAgICAgICAgICAgICAgICAoSW50ZXJuYWxfZWx0Lm51bGwgKCkpXG4gICAgICAgICAgfVxuICAgICAgICBpblxuICAgICAgICAoIE51bV9rZXlfYml0cy4oICsgKSBsZXZlbF9iaXRzIGJpdHNfcGVyX3Nsb3RcbiAgICAgICAgLCBLZXkuc3VjY19jbGFtcF90b19tYXggbWF4X2FsbG93ZWRfa2V5XG4gICAgICAgICwgbGV2ZWwgOjogbGV2ZWxzICkpXG4gICAgaW5cbiAgICB7IGxlbmd0aCA9IDBcbiAgICA7IHBvb2wgPSBJbnRlcm5hbF9lbHQuUG9vbC5jcmVhdGUgP2NhcGFjaXR5ICgpXG4gICAgOyBtaW5fZWx0ID0gSW50ZXJuYWxfZWx0Lm51bGwgKClcbiAgICA7IGVsdF9rZXlfbG93ZXJfYm91bmQgPSBLZXkuemVyb1xuICAgIDsgbGV2ZWxzID0gQXJyYXkub2ZfbGlzdF9yZXYgbGV2ZWxzXG4gICAgfVxuICA7O1xuXG4gIGxldCBtZW0gdCBlbHQgPSBJbnRlcm5hbF9lbHQuZXh0ZXJuYWxfaXNfdmFsaWQgdC5wb29sIGVsdFxuXG4gIGxldCBpbnRlcm5hbF9yZW1vdmUgdCBlbHQgPVxuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgaWYgSW50ZXJuYWxfZWx0LmVxdWFsIGVsdCB0Lm1pbl9lbHRcbiAgICB0aGVuXG4gICAgICB0Lm1pbl9lbHQgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKClcbiAgICAgICgqIFdlIGtlZXAgW3QuZWx0X2xvd2VyX2JvdW5kXSBzaW5jZSBpdCBpcyB2YWxpZCBldmVuIHRob3VnaCBbdC5taW5fZWx0XSBpcyBiZWluZ1xuICAgICAgIHJlbW92ZWQuICopO1xuICAgIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMTtcbiAgICBsZXQgbGV2ZWwgPSB0LmxldmVscy4oSW50ZXJuYWxfZWx0LmxldmVsX2luZGV4IHBvb2wgZWx0KSBpblxuICAgIGxldmVsLmxlbmd0aCA8LSBsZXZlbC5sZW5ndGggLSAxO1xuICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgbGV0IHNsb3QgPSBMZXZlbC5zbG90IGxldmVsIH5rZXk6KEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpIGluXG4gICAgbGV0IGZpcnN0ID0gc2xvdHMuKHNsb3QpIGluXG4gICAgaWYgcGh5c19lcXVhbCBlbHQgKEludGVybmFsX2VsdC5uZXh0IHBvb2wgZWx0KVxuICAgIHRoZW4gKCogW2VsdF0gaXMgdGhlIG9ubHkgZWxlbWVudCBpbiB0aGUgc2xvdCAqKVxuICAgICAgc2xvdHMuKHNsb3QpIDwtIEludGVybmFsX2VsdC5udWxsICgpXG4gICAgZWxzZSAoXG4gICAgICBpZiBwaHlzX2VxdWFsIGVsdCBmaXJzdCB0aGVuIHNsb3RzLihzbG90KSA8LSBJbnRlcm5hbF9lbHQubmV4dCBwb29sIGVsdDtcbiAgICAgIEludGVybmFsX2VsdC51bmxpbmsgcG9vbCBlbHQpXG4gIDs7XG5cbiAgbGV0IHJlbW92ZSB0IGVsdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBsZXQgZWx0ID0gSW50ZXJuYWxfZWx0Lm9mX2V4dGVybmFsX2V4biBwb29sIGVsdCBpblxuICAgIGludGVybmFsX3JlbW92ZSB0IGVsdDtcbiAgICBJbnRlcm5hbF9lbHQuZnJlZSBwb29sIGVsdFxuICA7O1xuXG4gIGxldCBmaXJlX3Bhc3RfYWxhcm1zIHQgfmhhbmRsZV9maXJlZCB+a2V5IH5ub3cgPVxuICAgIGxldCBsZXZlbCA9IHQubGV2ZWxzLigwKSBpblxuICAgIGlmIGxldmVsLmxlbmd0aCA+IDBcbiAgICB0aGVuIChcbiAgICAgIGxldCBzbG90ID0gTGV2ZWwuc2xvdCBsZXZlbCB+a2V5IGluXG4gICAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICAgIGxldCBmaXJzdCA9IHJlZiBzbG90cy4oc2xvdCkgaW5cbiAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgIWZpcnN0KVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBjdXJyZW50ID0gcmVmICFmaXJzdCBpblxuICAgICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgICBsZXQgZWx0ID0gIWN1cnJlbnQgaW5cbiAgICAgICAgICBsZXQgbmV4dCA9IEludGVybmFsX2VsdC5uZXh0IHBvb2wgZWx0IGluXG4gICAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0ICFmaXJzdCB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlIGVsc2UgY3VycmVudCA6PSBuZXh0O1xuICAgICAgICAgIGlmIFRpbWVfbnMuKCA8PSApIChJbnRlcm5hbF9lbHQuYXQgcG9vbCBlbHQpIG5vd1xuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgaGFuZGxlX2ZpcmVkIChJbnRlcm5hbF9lbHQudG9fZXh0ZXJuYWwgZWx0KTtcbiAgICAgICAgICAgIGludGVybmFsX3JlbW92ZSB0IGVsdDtcbiAgICAgICAgICAgIEludGVybmFsX2VsdC5mcmVlIHBvb2wgZWx0O1xuICAgICAgICAgICAgKCogV2UgcmVjb21wdXRlIFtmaXJzdF0gYmVjYXVzZSBbaW50ZXJuYWxfcmVtb3ZlXSBtYXkgaGF2ZSBjaGFuZ2VkIGl0LiAqKVxuICAgICAgICAgICAgZmlyc3QgOj0gc2xvdHMuKHNsb3QpKVxuICAgICAgICBkb25lKSlcbiAgOztcblxuICBsZXQgY2hhbmdlIHQgZWx0IH5rZXkgfmF0ID1cbiAgICBlbnN1cmVfdmFsaWRfa2V5IHQgfmtleTtcbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBlbHQgPSBJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHBvb2wgZWx0IGluXG4gICAgaW50ZXJuYWxfcmVtb3ZlIHQgZWx0O1xuICAgIEludGVybmFsX2VsdC5zZXRfa2V5IHBvb2wgZWx0IGtleTtcbiAgICBJbnRlcm5hbF9lbHQuc2V0X2F0IHBvb2wgZWx0IGF0O1xuICAgIGludGVybmFsX2FkZF9lbHQgdCBlbHRcbiAgOztcblxuICBsZXQgY2xlYXIgdCA9XG4gICAgaWYgbm90IChpc19lbXB0eSB0KVxuICAgIHRoZW4gKFxuICAgICAgdC5sZW5ndGggPC0gMDtcbiAgICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgICBsZXQgZnJlZV9lbHQgZWx0ID0gSW50ZXJuYWxfZWx0LmZyZWUgcG9vbCBlbHQgaW5cbiAgICAgIGxldCBsZXZlbHMgPSB0LmxldmVscyBpblxuICAgICAgZm9yIGxldmVsX2luZGV4ID0gMCB0byBBcnJheS5sZW5ndGggbGV2ZWxzIC0gMSBkb1xuICAgICAgICBsZXQgbGV2ZWwgPSBsZXZlbHMuKGxldmVsX2luZGV4KSBpblxuICAgICAgICBpZiBsZXZlbC5sZW5ndGggPiAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldmVsLmxlbmd0aCA8LSAwO1xuICAgICAgICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgICAgICAgZm9yIHNsb3RfaW5kZXggPSAwIHRvIEFycmF5Lmxlbmd0aCBzbG90cyAtIDEgZG9cbiAgICAgICAgICAgIGxldCBlbHQgPSBzbG90cy4oc2xvdF9pbmRleCkgaW5cbiAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0KVxuICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgIEludGVybmFsX2VsdC5pdGVyIHBvb2wgZWx0IH5mOmZyZWVfZWx0O1xuICAgICAgICAgICAgICBzbG90cy4oc2xvdF9pbmRleCkgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKCkpXG4gICAgICAgICAgZG9uZSlcbiAgICAgIGRvbmUpXG4gIDs7XG5lbmRcblxubW9kdWxlIEludGVybmFsX2VsdCA9IFByaW9yaXR5X3F1ZXVlLkludGVybmFsX2VsdFxubW9kdWxlIEtleSA9IFByaW9yaXR5X3F1ZXVlLktleVxubW9kdWxlIEludGVydmFsX251bSA9IEtleVxuXG5sZXQgbWluX2ludGVydmFsX251bSA9IEludGVydmFsX251bS56ZXJvXG5cbigqIEFsbCB0aW1lIGZyb20gdGhlIGVwb2NoIG9ud2FyZHMgaXMgYnJva2VuIGludG8gaGFsZi1vcGVuIGludGVydmFscyBvZiBzaXplXG4gICBbQ29uZmlnLmFsYXJtX3ByZWNpc2lvbiBjb25maWddLiAgVGhlIGludGVydmFscyBhcmUgbnVtYmVyZWQgc3RhcnRpbmcgYXQgemVybywgYW5kIGFcbiAgIHRpbWUncyBpbnRlcnZhbCBudW1iZXIgc2VydmVzIGFzIGl0cyBrZXkgaW4gW3ByaW9yaXR5X3F1ZXVlXS4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgY29uZmlnIDogQ29uZmlnLnRcbiAgOyBzdGFydCA6IFRpbWVfbnMudFxuICA7ICgqIFttYXhfaW50ZXJ2YWxfbnVtXSBpcyB0aGUgaW50ZXJ2YWwgbnVtYmVyIG9mIFttYXhfdGltZV0uICopXG4gICAgbWF4X2ludGVydmFsX251bSA6IEludGVydmFsX251bS50XG4gIDsgbXV0YWJsZSBub3cgOiBUaW1lX25zLnRcbiAgOyBtdXRhYmxlIG5vd19pbnRlcnZhbF9udW1fc3RhcnQgOiBUaW1lX25zLnRcbiAgOyBtdXRhYmxlIG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgOiBUaW1lX25zLnRcbiAgOyBwcmlvcml0eV9xdWV1ZSA6ICdhIFByaW9yaXR5X3F1ZXVlLnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxudHlwZSAnYSB0aW1pbmdfd2hlZWwgPSAnYSB0XG50eXBlICdhIHRfbm93ID0gJ2EgdFxuXG5sZXQgc2V4cF9vZl90X25vdyBfIHQgPSBbJXNleHAgKHQubm93IDogVGltZV9ucy50KV1cbmxldCBhbGFybV9wcmVjaXNpb24gdCA9IENvbmZpZy5hbGFybV9wcmVjaXNpb24gdC5jb25maWdcblxubW9kdWxlIEFsYXJtID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIFByaW9yaXR5X3F1ZXVlLkVsdC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IG51bGwgPSBQcmlvcml0eV9xdWV1ZS5FbHQubnVsbFxuICBsZXQgYXQgdHcgdCA9IFByaW9yaXR5X3F1ZXVlLkVsdC5hdCB0dy5wcmlvcml0eV9xdWV1ZSB0XG4gIGxldCB2YWx1ZSB0dyB0ID0gUHJpb3JpdHlfcXVldWUuRWx0LnZhbHVlIHR3LnByaW9yaXR5X3F1ZXVlIHRcbiAgbGV0IGludGVydmFsX251bSB0dyB0ID0gUHJpb3JpdHlfcXVldWUuRWx0LmtleSB0dy5wcmlvcml0eV9xdWV1ZSB0XG5lbmRcblxubGV0IHNleHBfb2ZfdF9pbnRlcm5hbCA9IHNleHBfb2ZfdFxubGV0IGl0ZXIgdCB+ZiA9IFByaW9yaXR5X3F1ZXVlLml0ZXIgdC5wcmlvcml0eV9xdWV1ZSB+ZlxuXG5tb2R1bGUgUHJldHR5ID0gc3RydWN0XG4gIG1vZHVsZSBBbGFybSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IGF0IDogVGltZV9ucy50XG4gICAgICA7IHZhbHVlIDogJ2FcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMsIHNleHBfb2ZdXG5cbiAgICBsZXQgY3JlYXRlIHQgYWxhcm0gPSB7IGF0ID0gQWxhcm0uYXQgdCBhbGFybTsgdmFsdWUgPSBBbGFybS52YWx1ZSB0IGFsYXJtIH1cbiAgICBsZXQgY29tcGFyZSB0MSB0MiA9IFRpbWVfbnMuY29tcGFyZSAoYXQgdDEpIChhdCB0MilcbiAgZW5kXG5cbiAgdHlwZSAnYSB0ID1cbiAgICB7IGNvbmZpZyA6IENvbmZpZy50XG4gICAgOyBzdGFydCA6IFRpbWVfbnMudFxuICAgIDsgbWF4X2ludGVydmFsX251bSA6IEludGVydmFsX251bS50XG4gICAgOyBub3cgOiBUaW1lX25zLnRcbiAgICA7IGFsYXJtcyA6ICdhIEFsYXJtLnQgbGlzdFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5sZXQgcHJldHR5XG4gICh7IGNvbmZpZ1xuICAgOyBzdGFydFxuICAgOyBtYXhfaW50ZXJ2YWxfbnVtXG4gICA7IG5vd1xuICAgOyBub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0ID0gX1xuICAgOyBtYXhfYWxsb3dlZF9hbGFybV90aW1lID0gX1xuICAgOyBwcmlvcml0eV9xdWV1ZSA9IF9cbiAgIH0gYXMgdClcbiAgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IHIgOj0gUHJldHR5LkFsYXJtLmNyZWF0ZSB0IGEgOjogIXIpO1xuICBsZXQgYWxhcm1zID0gTGlzdC5zb3J0ICFyIH5jb21wYXJlOlByZXR0eS5BbGFybS5jb21wYXJlIGluXG4gIHsgUHJldHR5LmNvbmZpZzsgc3RhcnQ7IG1heF9pbnRlcnZhbF9udW07IG5vdzsgYWxhcm1zIH1cbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICBtYXRjaCAhc2V4cF9vZl90X3N0eWxlIHdpdGhcbiAgfCBgSW50ZXJuYWwgLT4gc2V4cF9vZl90X2ludGVybmFsIHNleHBfb2ZfYSB0XG4gIHwgYFByZXR0eSAtPiBbJXNleHAgKHByZXR0eSB0IDogYSBQcmV0dHkudCldXG47O1xuXG5sZXQgbGVuZ3RoIHQgPSBQcmlvcml0eV9xdWV1ZS5sZW5ndGggdC5wcmlvcml0eV9xdWV1ZVxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0W0Bjb2xkXSByYWlzZV9uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4bl9vZl9lbXB0eV90aW1pbmdfd2hlZWwgdCA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIG9mIGVtcHR5IHRpbWluZyB3aGVlbFwiIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV9uZXh0X2FsYXJtX2ZpcmVzX2F0X3dpdGhfYWxsX2FsYXJtc19pbl9tYXhfaW50ZXJ2YWwgdCA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIHdpdGggYWxsIGFsYXJtcyBpbiBtYXggaW50ZXJ2YWxcIlxuICAgICAgICB+dGltaW5nX3doZWVsOih0IDogXyB0KV1cbjs7XG5cbmxldCBwb29sIHQgPSBQcmlvcml0eV9xdWV1ZS5wb29sIHQucHJpb3JpdHlfcXVldWVcblxubGV0IGludGVydmFsX251bV9pbnRlcm5hbCB+dGltZSB+YWxhcm1fcHJlY2lzaW9uID1cbiAgSW50ZXJ2YWxfbnVtLm9mX2ludDYzIChBbGFybV9wcmVjaXNpb24uaW50ZXJ2YWxfbnVtIGFsYXJtX3ByZWNpc2lvbiB0aW1lKVxuOztcblxubGV0IGludGVydmFsX251bV91bmNoZWNrZWQgdCB0aW1lID1cbiAgaW50ZXJ2YWxfbnVtX2ludGVybmFsIH50aW1lIH5hbGFybV9wcmVjaXNpb246dC5jb25maWcuYWxhcm1fcHJlY2lzaW9uXG47O1xuXG5sZXQgaW50ZXJ2YWxfbnVtIHQgdGltZSA9XG4gIGlmIFRpbWVfbnMuKCA8ICkgdGltZSBtaW5fdGltZVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGltaW5nX3doZWVsLmludGVydmFsX251bSBnb3QgdGltZSB0b28gZmFyIGluIHRoZSBwYXN0XCIgKHRpbWUgOiBUaW1lX25zLnQpXTtcbiAgaW50ZXJ2YWxfbnVtX3VuY2hlY2tlZCB0IHRpbWVcbjs7XG5cbmxldCBpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQgaW50ZXJ2YWxfbnVtID1cbiAgQWxhcm1fcHJlY2lzaW9uLmludGVydmFsX251bV9zdGFydFxuICAgIHQuY29uZmlnLmFsYXJtX3ByZWNpc2lvblxuICAgIChpbnRlcnZhbF9udW0gfD4gSW50ZXJ2YWxfbnVtLnRvX2ludDYzKVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV9pbnRlcnZhbF9udW1fc3RhcnRfZ290X3Rvb19zbWFsbCBpbnRlcnZhbF9udW0gPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbC5pbnRlcnZhbF9udW1fc3RhcnQgZ290IHRvbyBzbWFsbCBpbnRlcnZhbF9udW1cIlxuICAgICAgICAoaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnQpXG4gICAgICAgIChtaW5faW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnQpXVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV9pbnRlcnZhbF9udW1fc3RhcnRfZ290X3Rvb19sYXJnZSB0IGludGVydmFsX251bSA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsLmludGVydmFsX251bV9zdGFydCBnb3QgdG9vIGxhcmdlIGludGVydmFsX251bVwiXG4gICAgICAgIChpbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udClcbiAgICAgICAgKHQubWF4X2ludGVydmFsX251bSA6IEludGVydmFsX251bS50KV1cbjs7XG5cbmxldCBpbnRlcnZhbF9udW1fc3RhcnQgdCBpbnRlcnZhbF9udW0gPVxuICBpZiBJbnRlcnZhbF9udW0uKCA8ICkgaW50ZXJ2YWxfbnVtIG1pbl9pbnRlcnZhbF9udW1cbiAgdGhlbiByYWlzZV9pbnRlcnZhbF9udW1fc3RhcnRfZ290X3Rvb19zbWFsbCBpbnRlcnZhbF9udW07XG4gIGlmIEludGVydmFsX251bS4oID4gKSBpbnRlcnZhbF9udW0gdC5tYXhfaW50ZXJ2YWxfbnVtXG4gIHRoZW4gcmFpc2VfaW50ZXJ2YWxfbnVtX3N0YXJ0X2dvdF90b29fbGFyZ2UgdCBpbnRlcnZhbF9udW07XG4gIGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCBpbnRlcnZhbF9udW1cbjs7XG5cbmxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0X2ludGVybmFsIHQga2V5ID1cbiAgKCogW2ludGVydmFsX251bV9zdGFydCB0IGtleV0gaXMgdGhlIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdGFydCBvZiB0aGUgdGltZSBpbnRlcnZhbFxuICAgICBob2xkaW5nIHRoZSBmaXJzdCBhbGFybSBpbiBbdF0uICBBZHZhbmNpbmcgdG8gdGhhdCB3b3VsZCBub3QgYmUgZW5vdWdoLCBzaW5jZSB0aGVcbiAgICAgYWxhcm1zIGluIHRoYXQgaW50ZXJ2YWwgZG9uJ3QgZmlyZSB1bnRpbCB0aGUgY2xvY2sgaXMgYWR2YW5jZWQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICBuZXh0IGludGVydmFsLiAgU28sIHdlIHVzZSBbc3VjYyBrZXldIHRvIGFkdmFuY2UgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0XG4gICAgIGludGVydmFsLiAqKVxuICBpbnRlcnZhbF9udW1fc3RhcnQgdCAoS2V5LnN1Y2Mga2V5KVxuOztcblxubGV0IG5leHRfYWxhcm1fZmlyZXNfYXQgdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGtleSA9IEludGVybmFsX2VsdC5rZXkgKHBvb2wgdCkgZWx0IGluXG4gICAgaWYgSW50ZXJ2YWxfbnVtLmVxdWFsIGtleSB0Lm1heF9pbnRlcnZhbF9udW1cbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIFNvbWUgKG5leHRfYWxhcm1fZmlyZXNfYXRfaW50ZXJuYWwgdCBrZXkpKVxuOztcblxubGV0IG5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQgdGhlbiByYWlzZV9uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4bl9vZl9lbXB0eV90aW1pbmdfd2hlZWwgdDtcbiAgbGV0IGtleSA9IEludGVybmFsX2VsdC5rZXkgKHBvb2wgdCkgZWx0IGluXG4gIGlmIEludGVydmFsX251bS5lcXVhbCBrZXkgdC5tYXhfaW50ZXJ2YWxfbnVtXG4gIHRoZW4gcmFpc2VfbmV4dF9hbGFybV9maXJlc19hdF93aXRoX2FsbF9hbGFybXNfaW5fbWF4X2ludGVydmFsIHQ7XG4gIG5leHRfYWxhcm1fZmlyZXNfYXRfaW50ZXJuYWwgdCBrZXlcbjs7XG5cbmxldCBjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdCA9XG4gIGxldCBtYXhfYWxsb3dlZF9rZXkgPSBQcmlvcml0eV9xdWV1ZS5tYXhfYWxsb3dlZF9rZXkgdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcnZhbF9udW0uKCA+PSApIG1heF9hbGxvd2VkX2tleSB0Lm1heF9pbnRlcnZhbF9udW1cbiAgdGhlbiBtYXhfdGltZVxuICBlbHNlXG4gICAgVGltZV9ucy5hZGRcbiAgICAgIChpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQgbWF4X2FsbG93ZWRfa2V5KVxuICAgICAgKFRpbWVfbnMuU3Bhbi4oIC0gKSAoYWxhcm1fcHJlY2lzaW9uIHQpIFRpbWVfbnMuU3Bhbi5uYW5vc2Vjb25kKVxuOztcblxubGV0IG5vd19pbnRlcnZhbF9udW0gdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9hbGxvd2VkX2tleSB0LnByaW9yaXR5X3F1ZXVlXG5sZXQgbWluX2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtID0gbm93X2ludGVydmFsX251bVxubGV0IG1heF9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bSB0ID0gaW50ZXJ2YWxfbnVtIHQgKG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgdClcbmxldCBpbnRlcnZhbF9zdGFydCB0IHRpbWUgPSBpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQgKGludGVydmFsX251bSB0IHRpbWUpXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5jb25maWc6KGNoZWNrIENvbmZpZy5pbnZhcmlhbnQpXG4gICAgICB+c3RhcnQ6XG4gICAgICAgIChjaGVjayAoZnVuIHN0YXJ0IC0+XG4gICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oID49ICkgc3RhcnQgbWluX3RpbWUpO1xuICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA8PSApIHN0YXJ0IG1heF90aW1lKSkpXG4gICAgICB+bWF4X2ludGVydmFsX251bTpcbiAgICAgICAgKGNoZWNrIChmdW4gbWF4X2ludGVydmFsX251bSAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBJbnRlcnZhbF9udW0udF1cbiAgICAgICAgICAgICB+ZXhwZWN0Om1heF9pbnRlcnZhbF9udW1cbiAgICAgICAgICAgICAoaW50ZXJ2YWxfbnVtIHQgbWF4X3RpbWUpO1xuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBJbnRlcnZhbF9udW0udF1cbiAgICAgICAgICAgICB+ZXhwZWN0Om1heF9pbnRlcnZhbF9udW1cbiAgICAgICAgICAgICAoaW50ZXJ2YWxfbnVtIHQgKGludGVydmFsX251bV9zdGFydCB0IG1heF9pbnRlcnZhbF9udW0pKSkpXG4gICAgICB+bm93OlxuICAgICAgICAoY2hlY2sgKGZ1biBub3cgLT5cbiAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPj0gKSBub3cgdC5zdGFydCk7XG4gICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oIDw9ICkgbm93IG1heF90aW1lKTtcbiAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICBJbnRlcnZhbF9udW0uZXF1YWxcbiAgICAgICAgICAgICAgIChpbnRlcnZhbF9udW0gdCB0Lm5vdylcbiAgICAgICAgICAgICAgIChQcmlvcml0eV9xdWV1ZS5taW5fYWxsb3dlZF9rZXkgdC5wcmlvcml0eV9xdWV1ZSkpKSlcbiAgICAgIH5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0OlxuICAgICAgICAoY2hlY2sgKGZ1biBub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0IC0+XG4gICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IFRpbWVfbnMudF1cbiAgICAgICAgICAgICBub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0XG4gICAgICAgICAgICAgfmV4cGVjdDooaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgKG5vd19pbnRlcnZhbF9udW0gdCkpKSlcbiAgICAgIH5tYXhfYWxsb3dlZF9hbGFybV90aW1lOlxuICAgICAgICAoY2hlY2sgKGZ1biBtYXhfYWxsb3dlZF9hbGFybV90aW1lIC0+XG4gICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IFRpbWVfbnMudF1cbiAgICAgICAgICAgICBtYXhfYWxsb3dlZF9hbGFybV90aW1lXG4gICAgICAgICAgICAgfmV4cGVjdDooY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQpKSlcbiAgICAgIH5wcmlvcml0eV9xdWV1ZTooY2hlY2sgKFByaW9yaXR5X3F1ZXVlLmludmFyaWFudCBpbnZhcmlhbnRfYSkpO1xuICAgIGl0ZXIgdCB+ZjooZnVuIGFsYXJtIC0+XG4gICAgICBhc3NlcnQgKFxuICAgICAgICBJbnRlcnZhbF9udW0uZXF1YWxcbiAgICAgICAgICAoQWxhcm0uaW50ZXJ2YWxfbnVtIHQgYWxhcm0pXG4gICAgICAgICAgKGludGVydmFsX251bSB0IChBbGFybS5hdCB0IGFsYXJtKSkpO1xuICAgICAgYXNzZXJ0IChcbiAgICAgICAgVGltZV9ucy4oID49ICkgKGludGVydmFsX3N0YXJ0IHQgKEFsYXJtLmF0IHQgYWxhcm0pKSAoaW50ZXJ2YWxfc3RhcnQgdCAobm93IHQpKSk7XG4gICAgICBhc3NlcnQgKFRpbWVfbnMuKCA+ICkgKEFsYXJtLmF0IHQgYWxhcm0pIChUaW1lX25zLnN1YiAobm93IHQpIChhbGFybV9wcmVjaXNpb24gdCkpKSkpXG47O1xuXG5sZXQgZGVidWcgPSBmYWxzZVxuXG5sZXQgYWR2YW5jZV9jbG9jayB0IH50b18gfmhhbmRsZV9maXJlZCA9XG4gIGlmIFRpbWVfbnMuKCA+ICkgdG9fIChub3cgdClcbiAgdGhlbiAoXG4gICAgdC5ub3cgPC0gdG9fO1xuICAgIGxldCBrZXkgPSBpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgdG9fIGluXG4gICAgdC5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0IDwtIGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCBrZXk7XG4gICAgbWF0Y2hcbiAgICAgIFByaW9yaXR5X3F1ZXVlLmluY3JlYXNlX21pbl9hbGxvd2VkX2tleVxuICAgICAgICB0LnByaW9yaXR5X3F1ZXVlXG4gICAgICAgIH5rZXlcbiAgICAgICAgfmhhbmRsZV9yZW1vdmVkOmhhbmRsZV9maXJlZFxuICAgIHdpdGhcbiAgICB8IE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZSAtPlxuICAgICAgaWYgZGVidWdcbiAgICAgIHRoZW5cbiAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPSApIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSAoY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQpKVxuICAgIHwgTWF4X2FsbG93ZWRfa2V5X21heWJlX2NoYW5nZWQgLT5cbiAgICAgIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA8LSBjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdClcbjs7XG5cbmxldCBhZHZhbmNlX2Nsb2NrX3N0b3BfYXRfbmV4dF9hbGFybSB0IH50b18gfmhhbmRsZV9maXJlZCA9XG4gIGxldCBtaW5fZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBtaW5fZWx0XG4gIHRoZW4gYWR2YW5jZV9jbG9jayB0IH50b18gfmhhbmRsZV9maXJlZDooZnVuIF8gLT4gYXNzZXJ0IGZhbHNlKVxuICBlbHNlIChcbiAgICBsZXQga2V5ID0gSW50ZXJuYWxfZWx0LmtleSAocG9vbCB0KSBtaW5fZWx0IGluXG4gICAgKCogYXMgYW4gb3B0aW1pemF0aW9uLCBjb21wYXJlIGFnYWluc3QgW2ludGVydmFsX251bV9zdGFydF0gdG8gYXZvaWQgdGhlIHBvdGVudGlhbGx5XG4gICAgICAgY29zdGx5IGNvbXB1dGF0aW9uIG9mIFtJbnRlcm5hbF9lbHQubWluX2FsYXJtX3RpbWVdICopXG4gICAgaWYgVGltZV9ucy4oIDwgKSB0b18gKGludGVydmFsX251bV9zdGFydCB0IGtleSlcbiAgICB0aGVuIGFkdmFuY2VfY2xvY2sgdCB+dG9fIH5oYW5kbGVfZmlyZWQ6KGZ1biBfIC0+IGFzc2VydCBmYWxzZSlcbiAgICBlbHNlIChcbiAgICAgIGxldCB0b18gPVxuICAgICAgICBUaW1lX25zLm1pbiB0b18gKEludGVybmFsX2VsdC5taW5fYWxhcm1fdGltZSAocG9vbCB0KSBtaW5fZWx0IH53aXRoX2tleTprZXkpXG4gICAgICBpblxuICAgICAgYWR2YW5jZV9jbG9jayB0IH50b18gfmhhbmRsZV9maXJlZCkpXG47O1xuXG5sZXQgY3JlYXRlIH5jb25maWcgfnN0YXJ0ID1cbiAgaWYgVGltZV9ucy4oIDwgKSBzdGFydCBUaW1lX25zLmVwb2NoXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2UgXCJUaW1pbmdfd2hlZWwuY3JlYXRlIGdvdCBzdGFydCBiZWZvcmUgdGhlIGVwb2NoXCIgKHN0YXJ0IDogVGltZV9ucy50KV07XG4gIGxldCB0ID1cbiAgICB7IGNvbmZpZ1xuICAgIDsgc3RhcnRcbiAgICA7IG1heF9pbnRlcnZhbF9udW0gPVxuICAgICAgICBpbnRlcnZhbF9udW1faW50ZXJuYWwgfnRpbWU6bWF4X3RpbWUgfmFsYXJtX3ByZWNpc2lvbjpjb25maWcuYWxhcm1fcHJlY2lzaW9uXG4gICAgOyBub3cgPSBUaW1lX25zLm1pbl92YWx1ZV9mb3JfMXVzX3JvdW5kaW5nICgqIHNldCBieSBbYWR2YW5jZV9jbG9ja10gYmVsb3cgKilcbiAgICA7IG5vd19pbnRlcnZhbF9udW1fc3RhcnQgPVxuICAgICAgICBUaW1lX25zLm1pbl92YWx1ZV9mb3JfMXVzX3JvdW5kaW5nICgqIHNldCBieSBbYWR2YW5jZV9jbG9ja10gYmVsb3cgKilcbiAgICA7IG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgPSBtYXhfdGltZSAoKiBzZXQgYnkgW2FkdmFuY2VfY2xvY2tdIGJlbG93ICopXG4gICAgOyBwcmlvcml0eV9xdWV1ZSA9XG4gICAgICAgIFByaW9yaXR5X3F1ZXVlLmNyZWF0ZSA/Y2FwYWNpdHk6Y29uZmlnLmNhcGFjaXR5IH5sZXZlbF9iaXRzOmNvbmZpZy5sZXZlbF9iaXRzICgpXG4gICAgfVxuICBpblxuICB0Lm1heF9hbGxvd2VkX2FsYXJtX3RpbWUgPC0gY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQ7XG4gIGFkdmFuY2VfY2xvY2sgdCB+dG9fOnN0YXJ0IH5oYW5kbGVfZmlyZWQ6KGZ1biBfIC0+IGFzc2VydCBmYWxzZSk7XG4gIHRcbjs7XG5cbmxldCBhZGRfYXRfaW50ZXJ2YWxfbnVtIHQgfmF0IHZhbHVlID1cbiAgSW50ZXJuYWxfZWx0LnRvX2V4dGVybmFsXG4gICAgKFByaW9yaXR5X3F1ZXVlLmludGVybmFsX2FkZFxuICAgICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICAgICB+a2V5OmF0XG4gICAgICAgfmF0OihpbnRlcnZhbF9udW1fc3RhcnQgdCBhdClcbiAgICAgICB2YWx1ZSlcbjs7XG5cbmxldFtAY29sZF0gcmFpc2VfdGhhdF9mYXJfaW5fdGhlX2Z1dHVyZSB0IGF0ID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwgY2Fubm90IHNjaGVkdWxlIGFsYXJtIHRoYXQgZmFyIGluIHRoZSBmdXR1cmVcIlxuICAgICAgICAoYXQgOiBUaW1lX25zLnQpXG4gICAgICAgIH5tYXhfYWxsb3dlZF9hbGFybV90aW1lOih0Lm1heF9hbGxvd2VkX2FsYXJtX3RpbWUgOiBUaW1lX25zLnQpXVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV9iZWZvcmVfc3RhcnRfb2ZfY3VycmVudF9pbnRlcnZhbCB0IGF0ID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwgY2Fubm90IHNjaGVkdWxlIGFsYXJtIGJlZm9yZSBzdGFydCBvZiBjdXJyZW50IGludGVydmFsXCJcbiAgICAgICAgKGF0IDogVGltZV9ucy50KVxuICAgICAgICB+bm93X2ludGVydmFsX251bV9zdGFydDoodC5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0IDogVGltZV9ucy50KV1cbjs7XG5cbmxldCBlbnN1cmVfY2FuX3NjaGVkdWxlX2FsYXJtIHQgfmF0ID1cbiAgaWYgVGltZV9ucy4oID4gKSBhdCB0Lm1heF9hbGxvd2VkX2FsYXJtX3RpbWUgdGhlbiByYWlzZV90aGF0X2Zhcl9pbl90aGVfZnV0dXJlIHQgYXQ7XG4gIGlmIFRpbWVfbnMuKCA8ICkgYXQgdC5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0XG4gIHRoZW4gcmFpc2VfYmVmb3JlX3N0YXJ0X29mX2N1cnJlbnRfaW50ZXJ2YWwgdCBhdFxuOztcblxubGV0IGFkZCB0IH5hdCB2YWx1ZSA9XG4gIGVuc3VyZV9jYW5fc2NoZWR1bGVfYWxhcm0gdCB+YXQ7XG4gIEludGVybmFsX2VsdC50b19leHRlcm5hbFxuICAgIChQcmlvcml0eV9xdWV1ZS5pbnRlcm5hbF9hZGRcbiAgICAgICB0LnByaW9yaXR5X3F1ZXVlXG4gICAgICAgfmtleTooaW50ZXJ2YWxfbnVtX3VuY2hlY2tlZCB0IGF0KVxuICAgICAgIH5hdFxuICAgICAgIHZhbHVlKVxuOztcblxubGV0IHJlbW92ZSB0IGFsYXJtID0gUHJpb3JpdHlfcXVldWUucmVtb3ZlIHQucHJpb3JpdHlfcXVldWUgYWxhcm1cbmxldCBjbGVhciB0ID0gUHJpb3JpdHlfcXVldWUuY2xlYXIgdC5wcmlvcml0eV9xdWV1ZVxubGV0IG1lbSB0IGFsYXJtID0gUHJpb3JpdHlfcXVldWUubWVtIHQucHJpb3JpdHlfcXVldWUgYWxhcm1cblxubGV0IHJlc2NoZWR1bGVfZ2VuIHQgYWxhcm0gfmtleSB+YXQgPVxuICBpZiBub3QgKG1lbSB0IGFsYXJtKVxuICB0aGVuIGZhaWx3aXRoIFwiVGltaW5nX3doZWVsIGNhbm5vdCByZXNjaGVkdWxlIGFsYXJtIG5vdCBpbiB0aW1pbmcgd2hlZWxcIjtcbiAgZW5zdXJlX2Nhbl9zY2hlZHVsZV9hbGFybSB0IH5hdDtcbiAgUHJpb3JpdHlfcXVldWUuY2hhbmdlIHQucHJpb3JpdHlfcXVldWUgYWxhcm0gfmtleSB+YXRcbjs7XG5cbmxldCByZXNjaGVkdWxlIHQgYWxhcm0gfmF0ID0gcmVzY2hlZHVsZV9nZW4gdCBhbGFybSB+a2V5OihpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgYXQpIH5hdFxuXG5sZXQgcmVzY2hlZHVsZV9hdF9pbnRlcnZhbF9udW0gdCBhbGFybSB+YXQgPVxuICByZXNjaGVkdWxlX2dlbiB0IGFsYXJtIH5rZXk6YXQgfmF0OihpbnRlcnZhbF9udW1fc3RhcnQgdCBhdClcbjs7XG5cbmxldCBtaW5fYWxhcm1faW50ZXJ2YWxfbnVtIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQgdGhlbiBOb25lIGVsc2UgU29tZSAoSW50ZXJuYWxfZWx0LmtleSAocG9vbCB0KSBlbHQpXG47O1xuXG5sZXQgbWluX2FsYXJtX2ludGVydmFsX251bV9leG4gdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGltaW5nX3doZWVsLm1pbl9hbGFybV9pbnRlcnZhbF9udW1fZXhuIG9mIGVtcHR5IHRpbWluZ193aGVlbFwiXG4gICAgICAgICAgfnRpbWluZ193aGVlbDoodCA6IF8gdCldXG4gIGVsc2UgSW50ZXJuYWxfZWx0LmtleSAocG9vbCB0KSBlbHRcbjs7XG5cbmxldCBtYXhfYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0ID1cbiAgbGV0IHBvb2wgPSBwb29sIHQgaW5cbiAgSW50ZXJuYWxfZWx0Lm1heF9hbGFybV90aW1lIHBvb2wgZWx0IH53aXRoX2tleTooSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdClcbjs7XG5cbmxldCBtaW5fYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0ID1cbiAgbGV0IHBvb2wgPSBwb29sIHQgaW5cbiAgSW50ZXJuYWxfZWx0Lm1pbl9hbGFybV90aW1lIHBvb2wgZWx0IH53aXRoX2tleTooSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdClcbjs7XG5cbmxldCBtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwgdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdCB0aGVuIE5vbmUgZWxzZSBTb21lIChtYXhfYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0KVxuOztcblxubGV0IG1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKG1pbl9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQpXG47O1xuXG5sZXQgbWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwubWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biBvZiBlbXB0eSB0aW1pbmcgd2hlZWxcIlxuICAgICAgICAgIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXTtcbiAgbWF4X2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdFxuOztcblxubGV0IG1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF9leG4gdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGltaW5nX3doZWVsLm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF9leG4gb2YgZW1wdHkgdGltaW5nIHdoZWVsXCJcbiAgICAgICAgICB+dGltaW5nX3doZWVsOih0IDogXyB0KV07XG4gIG1pbl9hbGFybV90aW1lX2luX2xpc3QgdCBlbHRcbjs7XG5cbmxldCBmaXJlX3Bhc3RfYWxhcm1zIHQgfmhhbmRsZV9maXJlZCA9XG4gIFByaW9yaXR5X3F1ZXVlLmZpcmVfcGFzdF9hbGFybXNcbiAgICB0LnByaW9yaXR5X3F1ZXVlXG4gICAgfmhhbmRsZV9maXJlZFxuICAgIH5rZXk6KG5vd19pbnRlcnZhbF9udW0gdClcbiAgICB+bm93OnQubm93XG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgTnVtX2tleV9iaXRzID0gTnVtX2tleV9iaXRzXG5cbiAgbGV0IGludGVydmFsX251bV9pbnRlcm5hbCA9IGludGVydmFsX251bV9pbnRlcm5hbFxuICBsZXQgbWF4X3RpbWUgPSBtYXhfdGltZVxuZW5kXG4iXX0=
