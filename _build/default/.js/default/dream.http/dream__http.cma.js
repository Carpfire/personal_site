// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Dream__http
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Dream_http = [0];
   runtime.caml_register_global(0, Dream_http, "Dream__http");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream__http__Adapt
//# unitInfo: Requires: Dream_h2__H2, Dream_httpaf___Httpaf, Dream_pure__Message, Dream_pure__Stream, Stdlib__Printf, Unix
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_h2_H2 = global_data.Dream_h2__H2,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Dream_pure_Stream = global_data.Dream_pure__Stream,
    Dream_pure_Message = global_data.Dream_pure__Message,
    Unix = global_data.Unix,
    Stdlib_Printf = global_data.Stdlib__Printf,
    _a_ = [0, [2, 0, [12, 58, [4, 3, 0, 0, 0]]], "%s:%i"];
   function address_to_string(param){
    if(0 === param[0]){var path = param[1]; return path;}
    var
     port = param[2],
     address = param[1],
     _h_ = caml_call1(Unix[127], address);
    return caml_call3(Stdlib_Printf[4], _a_, _h_, port);
   }
   function forward_body_general
   (response, write_string, write_buffer, http_flush, close){
    function abort(exn){return caml_call1(close, 1000);}
    var bytes_since_flush = [0, 0];
    function send(param){
     var stream = caml_call1(Dream_pure_Message[27], response);
     return caml_call7
             (Dream_pure_Stream[12],
              stream,
              data,
              flush,
              ping,
              pong,
              close,
              abort);
    }
    function data(chunk, off, len, binary, fin){
     caml_call3(write_buffer, [0, off], [0, len], chunk);
     bytes_since_flush[1] = bytes_since_flush[1] + len | 0;
     return 4096 <= bytes_since_flush[1]
             ? (bytes_since_flush[1] = 0, caml_call1(http_flush, send))
             : send(0);
    }
    function flush(param){
     bytes_since_flush[1] = 0;
     return caml_call1(http_flush, send);
    }
    function ping(buffer, offset, length){return send(0);}
    function pong(buffer, offset, length){return send(0);}
    return send(0);
   }
   function forward_body(response, body){
    function _e_(code){return caml_call1(Dream_httpaf_Httpaf[5][2][6], body);}
    var
     _f_ = caml_call1(Dream_httpaf_Httpaf[5][2][5], body),
     _g_ = caml_call1(Dream_httpaf_Httpaf[5][2][3], body);
    return forward_body_general
            (response,
             caml_call1(Dream_httpaf_Httpaf[5][2][2], body),
             _g_,
             _f_,
             _e_);
   }
   function forward_body_h2(response, body){
    function _b_(code){return caml_call1(Dream_h2_H2[4][2][6], body);}
    var
     _c_ = caml_call1(Dream_h2_H2[4][2][5], body),
     _d_ = caml_call1(Dream_h2_H2[4][2][3], body);
    return forward_body_general
            (response, caml_call1(Dream_h2_H2[4][2][2], body), _d_, _c_, _b_);
   }
   var
    Dream_http_Adapt =
      [0,
       address_to_string,
       forward_body_general,
       forward_body,
       forward_body_h2];
   runtime.caml_register_global(7, Dream_http_Adapt, "Dream__http__Adapt");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream__http__Error_handler
//# unitInfo: Requires: Dream__http__Adapt, Dream__server__Error_template, Dream__server__Helpers, Dream__server__Log, Dream_h2__H2, Dream_httpaf___Httpaf, Dream_pure__Formats, Dream_pure__Message, Dream_pure__Method, Dream_pure__Status, Dream_pure__Stream, Dream_websocketaf__Websocketaf, Lwt, Stdlib, Stdlib__Buffer, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst$6 = "\n",
    cst_s_s = "\n%s: %s",
    cst_s = "%s",
    cst_s$0 = "%s\n",
    cst_Library_error_without_desc =
      "(Library error without description payload)\n",
    cst$5 = ": ",
    cst_Bad_request = "Bad request",
    cst_Content_Length_missing_or_ = "Content-Length missing or negative",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ")",
    cst$0 = " (",
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = cst$5,
    Dream_server_Helpers = global_data.Dream__server__Helpers,
    Lwt = global_data.Lwt,
    Dream_websocketaf_Websocketaf = global_data.Dream_websocketaf__Websocketaf,
    Dream_http_Adapt = global_data.Dream__http__Adapt,
    Dream_pure_Message = global_data.Dream_pure__Message,
    Dream_h2_H2 = global_data.Dream_h2__H2,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Dream_pure_Stream = global_data.Dream_pure__Stream,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Dream_server_Log = global_data.Dream__server__Log,
    Dream_pure_Status = global_data.Dream_pure__Status,
    Dream_pure_Formats = global_data.Dream_pure__Formats,
    Dream_server_Error_template = global_data.Dream__server__Error_template,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Dream_pure_Method = global_data.Dream_pure__Method,
    Stdlib_List = global_data.Stdlib__List,
    log = caml_call2(Dream_server_Log[19], 0, "dream.http"),
    _y_ = [0, -976970511, cst_Bad_request],
    _z_ = [0, -976970511, cst_Content_Length_missing_or_],
    _x_ = [0, -976970511, cst_Bad_request],
    _w_ = [0, -976970511, cst_Content_Length_missing_or_],
    _u_ = [0, -949323947],
    _v_ = [0, 798549870],
    _t_ = [0, 798549870],
    _s_ = [0, 798549870],
    _r_ = [0, [2, 0, 0], cst_s],
    _q_ =
      [0,
       [11, "Error handler raised: ", [2, 0, 0]],
       "Error handler raised: %s"],
    cst_Content_Type = "Content-Type",
    _p_ = [0, [2, 0, 0], cst_s],
    _o_ = [0, [2, 0, 0], cst_s],
    cst_HTTP = "HTTP",
    cst_HTTP_2 = "HTTP/2",
    cst_WebSocket = "WebSocket",
    cst_TLS = "TLS",
    _i_ = [0, [12, 10, 0], cst$6],
    _j_ = [0, [12, 10, [2, 0, [11, cst$5, [2, 0, 0]]]], cst_s_s],
    _h_ = [0, [12, 10, [2, 0, [11, cst$5, [2, 0, 0]]]], cst_s_s],
    _k_ = [0, [2, 0, [12, 10, 0]], cst_s$0],
    _l_ = [0, [2, 0, [12, 10, 0]], cst_s$0],
    _n_ =
      [0,
       [11, cst_Library_error_without_desc, 0],
       cst_Library_error_without_desc],
    _m_ = [0, [2, 0, [12, 10, 0]], cst_s$0],
    _a_ = [0, [4, 3, 0, 0, [12, 32, [2, 0, [12, 10, 0]]]], "%i %s\n"],
    _b_ = [0, [12, 10, 0], cst$6],
    cst_HTTP_library = "HTTP library",
    cst_HTTP2_library = "HTTP2 library",
    cst_WebSocket_library = "WebSocket library",
    cst_Application = "Application",
    cst_TLS_library = "TLS library",
    cst_Client = "Client",
    cst_Server = "Server",
    cst_Info = "Info",
    cst_Error = "Error",
    cst_Debug = "Debug",
    cst_Warning = "Warning",
    _c_ = [0, [11, "From: ", [2, 0, [12, 10, 0]]], "From: %s\n"],
    _d_ = [0, [11, "Blame: ", [2, 0, [12, 10, 0]]], "Blame: %s\n"],
    _e_ = [0, [11, "Severity: ", [2, 0, 0]], "Severity: %s"],
    _f_ = [0, [11, "\n\nClient: ", [2, 0, 0]], "\n\nClient: %s"],
    _g_ = [0, [11, "\n\n", [2, 0, [12, 32, [2, 0, 0]]]], "\n\n%s %s"];
   function select_log(param){
    return 106380200 <= param
            ? 815031438 <= param ? log[3] : log[1]
            : -364068301 <= param ? log[4] : log[2];
   }
   function customize(template, error){
    var condition = error[1];
    if(-71406943 !== condition[1]){
     var match$3 = error[6];
     if(match$3)
      var
       client$0 = match$3[1],
       _at_ = caml_call2(Stdlib[28], client$0, cst),
       client$1 = caml_call2(Stdlib[28], cst$0, _at_);
     else
      var client$1 = cst$3;
     var
      _au_ = error[2],
      layer$0 =
        4194267 === _au_
         ? [0, caml_call2(Stdlib[28], cst_TLS, client$1), 0]
         : 748663722
           <= _au_
           ? 802644872
             <= _au_
             ? [0, caml_call2(Stdlib[28], cst_HTTP, client$1), 0]
             : [0, caml_call2(Stdlib[28], cst_HTTP_2, client$1), 0]
           : 117713735
             <= _au_
             ? [0, caml_call2(Stdlib[28], cst_WebSocket, client$1), 0]
             : 0;
     if(3458171 <= condition[1])
      var
       exn$0 = condition[2],
       backtrace$0 = caml_call1(Stdlib_Printexc[6], 0),
       backtrace$1 = backtrace$0,
       description = caml_call1(Stdlib_Printexc[1], exn$0);
     else
      var
       string$0 = condition[2],
       backtrace$1 = cst$2,
       description = string$0;
     var
      _av_ = caml_call2(Stdlib[37], layer$0, [0, description, 0]),
      message = caml_call2(Stdlib_String[7], cst$1, _av_),
      _aw_ = function(log){return caml_call3(log, error[4], _o_, message);};
     caml_call1(select_log(error[7]), _aw_);
     var
      _ax_ =
        function(line){
         function _ay_(log){return caml_call3(log, error[4], _p_, line);}
         return caml_call1(select_log(error[7]), _ay_);
        };
     caml_call1(caml_call1(Dream_server_Log[21], _ax_), backtrace$1);
    }
    if(! error[8]) return Lwt[37];
    var buffer = caml_call1(Stdlib_Buffer[1], 4096);
    function p(format){return caml_call2(Stdlib_Printf[5], buffer, format);}
    var match = error[1], _ad_ = match[1];
    if(-71406943 === _ad_){
     var
      response = match[2],
      status = caml_call1(Dream_pure_Message[7], response),
      _ae_ = caml_call1(Dream_pure_Status[9], status),
      _af_ = caml_call1(Dream_pure_Status[6], status);
     caml_call2(p(_a_), _af_, _ae_);
    }
    else if(3458171 <= _ad_){
     var
      exn = match[2],
      backtrace = caml_call1(Stdlib_Printexc[6], 0),
      _ap_ = caml_call1(Stdlib_Printexc[1], exn);
     caml_call1(p(_k_), _ap_);
     var _aq_ = p(_l_);
     caml_call1(caml_call1(Dream_server_Log[21], _aq_), backtrace);
    }
    else{
     var string = match[2];
     if(runtime.caml_string_notequal(string, cst$4))
      caml_call1(p(_m_), string);
     else
      p(_n_);
    }
    p(_b_);
    var
     _ag_ = error[2],
     layer =
       4194267 === _ag_
        ? cst_TLS_library
        : 748663722
          <= _ag_
          ? 802644872 <= _ag_ ? cst_HTTP_library : cst_HTTP2_library
          : 117713735 <= _ag_ ? cst_WebSocket_library : cst_Application,
     blame = 1055145579 <= error[3] ? cst_Client : cst_Server,
     _ah_ = error[7],
     severity =
       106380200 <= _ah_
        ? 815031438 <= _ah_ ? cst_Info : cst_Error
        : -364068301 <= _ah_ ? cst_Debug : cst_Warning;
    caml_call1(p(_c_), layer);
    caml_call1(p(_d_), blame);
    caml_call1(p(_e_), severity);
    var match$0 = error[6];
    if(match$0){var client = match$0[1]; caml_call1(p(_f_), client);}
    var match$1 = error[4];
    if(match$1){
     var
      request = match$1[1],
      _ai_ = caml_call1(Dream_pure_Message[3], request),
      _aj_ = caml_call1(Dream_pure_Message[2], request),
      _ak_ = caml_call1(Dream_pure_Method[1], _aj_);
     caml_call2(p(_g_), _ak_, _ai_);
     var
      _al_ = caml_call1(Dream_pure_Message[11], request),
      _am_ =
        function(param){
         var value = param[2], name = param[1];
         return caml_call2(p(_h_), name, value);
        };
     caml_call1(caml_call1(Stdlib_List[18], _am_), _al_);
     var
      _an_ = 1,
      _ao_ =
        function(name, value, first){
         if(first) p(_i_);
         caml_call2(p(_j_), name, value);
         return 0;
        };
     caml_call3(Dream_pure_Message[42], _ao_, _an_, request);
    }
    var debug_dump = caml_call1(Stdlib_Buffer[2], buffer), match$2 = error[1];
    a:
    {
     if(typeof match$2 !== "number" && -71406943 === match$2[1]){
      var response$1 = match$2[2], response$0 = response$1;
      break a;
     }
     var
      status$0 = 1055145579 <= error[3] ? -949323947 : 798549870,
      response$0 =
        caml_call5
         (Dream_pure_Message[6],
          [0, status$0],
          0,
          0,
          Dream_pure_Stream[8],
          Dream_pure_Stream[7]);
    }
    var ppx_lwt_0 = caml_call3(template, error, debug_dump, response$0);
    function _ar_(response){return caml_call1(Lwt[4], [0, response]);}
    function _as_(exn){
     try{throw caml_maybe_attach_backtrace(exn, 0);}
     catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
    }
    return caml_call3(Lwt[81], _as_, ppx_lwt_0, _ar_);
   }
   function default_template(error, debug_dump, response){return caml_call1(Lwt[4], response);
   }
   function debug_template(error, debug_dump, response){
    var
     status = caml_call1(Dream_pure_Message[7], response),
     code = caml_call1(Dream_pure_Status[6], status),
     reason = caml_call1(Dream_pure_Status[9], status);
    caml_call3
     (Dream_pure_Message[15],
      response,
      cst_Content_Type,
      Dream_pure_Formats[13]);
    var
     _ac_ =
       caml_call3(Dream_server_Error_template[2], debug_dump, code, reason);
    caml_call2(Dream_pure_Message[20], response, _ac_);
    return caml_call1(Lwt[4], response);
   }
   function default$0(_ab_){return customize(default_template, _ab_);}
   function debug_error_handler(_aa_){return customize(debug_template, _aa_);}
   function double_faults(f, default$0){
    function _Y_(exn){
     var backtrace = caml_call1(Stdlib_Printexc[6], 0);
     function _Z_(log){
      return caml_call3(log, 0, _q_, caml_call1(Stdlib_Printexc[1], exn));
     }
     caml_call1(log[1], _Z_);
     function ___(line){
      function _$_(log){return caml_call3(log, 0, _r_, line);}
      return caml_call1(log[1], _$_);
     }
     caml_call1(caml_call1(Dream_server_Log[21], ___), backtrace);
     return caml_call1(default$0, 0);
    }
    return caml_call2(Lwt[7], f, _Y_);
   }
   function respond_with_option(f){
    function _U_(param){
     var
      _X_ =
        caml_call5
         (Dream_pure_Message[6],
          _s_,
          0,
          0,
          Dream_pure_Stream[8],
          Dream_pure_Stream[7]);
     return caml_call1(Lwt[4], _X_);
    }
    return double_faults
            (function(param){
              var _V_ = caml_call1(f, 0);
              function _W_(param){
               if(! param)
                return caml_call5
                        (Dream_pure_Message[6],
                         _t_,
                         0,
                         0,
                         Dream_pure_Stream[8],
                         Dream_pure_Stream[7]);
               var response = param[1];
               return response;
              }
              return caml_call1(caml_call1(Lwt[28], _W_), _V_);
             },
             _U_);
   }
   function app(user_s_error_handler, error){
    return respond_with_option
            (function(param){return caml_call1(user_s_error_handler, error);});
   }
   function default_response(param){
    return 1055145579 <= param
            ? caml_call5
              (Dream_pure_Message[6],
               _u_,
               0,
               0,
               Dream_pure_Stream[8],
               Dream_pure_Stream[7])
            : caml_call5
              (Dream_pure_Message[6],
               _v_,
               0,
               0,
               Dream_pure_Stream[8],
               Dream_pure_Stream[7]);
   }
   function httpaf
   (user_s_error_handler, client_address, request, error, start_response){
    if(typeof error === "number")
     if(-732353682 === error)
      var caused_by = 583778019, severity = 106380200, condition = _w_;
     else
      var caused_by = 1055145579, severity = -685964740, condition = _x_;
    else
     var
      exn = error[2],
      condition$0 = [0, 3458171, exn],
      caused_by = 583778019,
      severity = 106380200,
      condition = condition$0;
    var
     error$0 =
       [0,
        condition,
        802644872,
        caused_by,
        0,
        0,
        [0, caml_call1(Dream_http_Adapt[1], client_address)],
        severity,
        1];
    function _P_(param){
     var _Q_ = Lwt[4];
     return double_faults
             (function(param){
               var ppx_lwt_0 = caml_call1(user_s_error_handler, error$0);
               function _R_(response){
                if(response)
                 var response$0 = response[1], response$1 = response$0;
                else
                 var response$1 = default_response(caused_by);
                var
                 _T_ = caml_call1(Dream_pure_Message[11], response$1),
                 headers = caml_call1(Dream_httpaf_Httpaf[4][2], _T_),
                 body = caml_call1(start_response, headers);
                caml_call2(Dream_http_Adapt[3], response$1, body);
                return Lwt[36];
               }
               function _S_(exn){
                try{throw caml_maybe_attach_backtrace(exn, 0);}
                catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;
                }
               }
               return caml_call3(Lwt[81], _S_, ppx_lwt_0, _R_);
              },
              _Q_);
    }
    return caml_call1(Lwt[11], _P_);
   }
   function h2
   (user_s_error_handler, client_address, request, error, start_response){
    if(typeof error === "number")
     if(-99004555 <= error)
      var caused_by = 1055145579, severity = -685964740, condition = _y_;
     else
      var caused_by = 583778019, severity = 106380200, condition = _z_;
    else
     var
      exn = error[2],
      condition$0 = [0, 3458171, exn],
      caused_by = 583778019,
      severity = 106380200,
      condition = condition$0;
    var
     error$0 =
       [0,
        condition,
        748663722,
        caused_by,
        0,
        0,
        [0, caml_call1(Dream_http_Adapt[1], client_address)],
        severity,
        1];
    function _K_(param){
     var _L_ = Lwt[4];
     return double_faults
             (function(param){
               var ppx_lwt_0 = caml_call1(user_s_error_handler, error$0);
               function _M_(response){
                if(response)
                 var response$0 = response[1], response$1 = response$0;
                else
                 var response$1 = default_response(caused_by);
                var
                 _O_ = caml_call1(Dream_pure_Message[11], response$1),
                 headers = caml_call1(Dream_h2_H2[3][2], _O_),
                 body = caml_call1(start_response, headers);
                caml_call2(Dream_http_Adapt[4], response$1, body);
                return Lwt[36];
               }
               function _N_(exn){
                try{throw caml_maybe_attach_backtrace(exn, 0);}
                catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;
                }
               }
               return caml_call3(Lwt[81], _N_, ppx_lwt_0, _M_);
              },
              _L_);
    }
    return caml_call1(Lwt[11], _K_);
   }
   function tls(user_s_error_handler, client_address, error){
    var
     error$0 =
       [0,
        [0, 3458171, error],
        4194267,
        1055145579,
        0,
        0,
        [0, caml_call1(Dream_http_Adapt[1], client_address)],
        -685964740,
        0];
    function _F_(param){
     var _G_ = Lwt[4];
     return double_faults
             (function(param){
               var _H_ = caml_call1(user_s_error_handler, error$0);
               function _I_(_J_){return 0;}
               return caml_call2(Lwt[28], _I_, _H_);
              },
              _G_);
    }
    return caml_call1(Lwt[11], _F_);
   }
   function websocket(user_s_error_handler, request, response, socket, error){
    caml_call2(Dream_websocketaf_Websocketaf[3][6], 0, socket);
    var
     exn = error[2],
     error$0 =
       [0,
        [0, 3458171, exn],
        117713735,
        583778019,
        [0, request],
        [0, response],
        [0, caml_call1(Dream_server_Helpers[2], request)],
        -685964740,
        0];
    function _A_(param){
     var _B_ = Lwt[4];
     return double_faults
             (function(param){
               var _C_ = caml_call1(user_s_error_handler, error$0);
               function _D_(_E_){return 0;}
               return caml_call2(Lwt[28], _D_, _C_);
              },
              _B_);
    }
    return caml_call1(Lwt[11], _A_);
   }
   function websocket_handshake
   (user_s_error_handler, request, response, error_string){
    var
     error =
       [0,
        [0, -976970511, error_string],
        117713735,
        1055145579,
        [0, request],
        [0, response],
        [0, caml_call1(Dream_server_Helpers[2], request)],
        -685964740,
        1];
    return respond_with_option
            (function(param){return caml_call1(user_s_error_handler, error);});
   }
   var
    Dream_http_Error_handler =
      [0,
       default$0,
       debug_error_handler,
       customize,
       app,
       httpaf,
       h2,
       tls,
       websocket,
       websocket_handshake,
       log];
   runtime.caml_register_global
    (68, Dream_http_Error_handler, "Dream__http__Error_handler");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream__http__Http
//# unitInfo: Requires: Digestif, Dream__certificate, Dream__http__Adapt, Dream__http__Error_handler, Dream__server__Catch, Dream__server__Helpers, Dream__server__Log, Dream_gluten__Gluten, Dream_gluten_lwt_unix__Gluten_lwt_unix, Dream_h2__H2, Dream_h2_lwt_unix__H2_lwt_unix, Dream_httpaf__Websocket, Dream_httpaf___Httpaf, Dream_httpaf__lwt_unix__Httpaf_lwt_unix, Dream_pure__Message, Dream_pure__Method, Dream_pure__Status, Dream_pure__Stream, Dream_websocketaf__Websocketaf, Lwt, Lwt_io, Lwt_main, Lwt_ssl, Lwt_unix, Ssl, Stdlib, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_127_0_0_1 = "127.0.0.1",
    cst_localhost = "://localhost:",
    cst_A_response_header_is_empty =
      "A response header is empty or contains only whitespace",
    cst_Dream = "Dream.",
    cst_Dream_run_adjust_terminal_ =
      "Dream.run: ~adjust_terminal is deprecated",
    cst_In_memory_certificates_wil =
      "In-memory certificates will be written to temporary files",
    cst_Running_on = "Running on ",
    cst_See_arguments_certificate_ =
      "See arguments ~certificate_file and ~key_file",
    cst_Type_Ctrl_C_to_stop = "Type Ctrl+C to stop",
    cst_Using_a_development_SSL_ce =
      "Using a development SSL certificate on a public interface",
    cst_h2 = "h2",
    cst_http_1_1 = "http/1.1",
    cst_localhost$0 = "localhost",
    cst_src_http_http_ml = "src/http/http.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    default_interface = cst_localhost$0,
    Dream_http_Error_handler = global_data.Dream__http__Error_handler,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Dream_server_Log = global_data.Dream__server__Log,
    Lwt_main = global_data.Lwt_main,
    Lwt_io = global_data.Lwt_io,
    Lwt = global_data.Lwt,
    Dream_certificate = global_data.Dream__certificate,
    Stdlib = global_data.Stdlib,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Lwt_unix = global_data.Lwt_unix,
    Dream_server_Catch = global_data.Dream__server__Catch,
    Dream_pure_Message = global_data.Dream_pure__Message,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Dream_httpaf_lwt_unix_Httpaf_l =
      global_data.Dream_httpaf__lwt_unix__Httpaf_lwt_unix,
    Lwt_ssl = global_data.Lwt_ssl,
    Ssl = global_data.Ssl,
    Assert_failure = global_data.Assert_failure,
    Dream_h2_lwt_unix_H2_lwt_unix = global_data.Dream_h2_lwt_unix__H2_lwt_unix,
    Dream_gluten_lwt_unix_Gluten_l =
      global_data.Dream_gluten_lwt_unix__Gluten_lwt_unix,
    Dream_h2_H2 = global_data.Dream_h2__H2,
    Dream_http_Adapt = global_data.Dream__http__Adapt,
    Dream_pure_Stream = global_data.Dream_pure__Stream,
    Dream_server_Helpers = global_data.Dream__server__Helpers,
    Dream_httpaf_Websocket = global_data.Dream_httpaf__Websocket,
    Dream_websocketaf_Websocketaf = global_data.Dream_websocketaf__Websocketaf,
    Dream_gluten_Gluten = global_data.Dream_gluten__Gluten,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Digestif = global_data.Digestif,
    Dream_pure_Status = global_data.Dream_pure__Status,
    Dream_pure_Method = global_data.Dream_pure__Method,
    _m_ =
      [0,
       [11, cst_Dream_run_adjust_terminal_, 0],
       cst_Dream_run_adjust_terminal_],
    cst_https = "https",
    cst_http = "http",
    _n_ = [0, [11, cst_Running_on, [2, 0, 0]], "Running on %s"],
    _q_ =
      [0,
       [11, "Running at ", [2, 0, [11, cst_localhost, [4, 3, 0, 0, 0]]]],
       "Running at %s://localhost:%i"],
    _p_ =
      [0,
       [11,
        cst_Running_on,
        [2,
         0,
         [12,
          58,
          [4,
           3,
           0,
           0,
           [11, " (", [2, 0, [11, cst_localhost, [4, 3, 0, 0, [12, 41, 0]]]]]]]]],
       "Running on %s:%i (%s://localhost:%i)"],
    _o_ = [0, [11, cst_Type_Ctrl_C_to_stop, 0], cst_Type_Ctrl_C_to_stop],
    cst_run = "run",
    cst_serve = "serve",
    _i_ = [0, [11, "Writing key to ", [2, 0, 0]], "Writing key to %s"],
    _h_ =
      [0,
       [11, "Writing certificate to ", [2, 0, 0]],
       "Writing certificate to %s"],
    _l_ =
      [0,
       [11, cst_See_arguments_certificate_, 0],
       cst_See_arguments_certificate_],
    _k_ =
      [0,
       [11, cst_Using_a_development_SSL_ce, 0],
       cst_Using_a_development_SSL_ce],
    _j_ =
      [0,
       [11, cst_In_memory_certificates_wil, 0],
       cst_In_memory_certificates_wil],
    cst_Must_specify_exactly_one_p =
      "Must specify exactly one pair of certificate and key",
    _g_ = [0, [2, 0, 0], "%s"],
    _f_ =
      [0,
       [11, cst_Dream, [2, 0, [11, ": exception ", [2, 0, 0]]]],
       "Dream.%s: exception %s"],
    _e_ =
      [0,
       [11,
        cst_Dream,
        [2, 0, [11, ": no interface with address ", [2, 0, 0]]]],
       "Dream.%s: no interface with address %s"],
    _d_ =
      [0,
       [11, cst_A_response_header_is_empty, 0],
       cst_A_response_header_is_empty],
    _b_ = [0, cst_src_http_http_ml, 366, 10],
    _c_ = [0, cst_src_http_http_ml, 346, 8],
    _a_ = [0, [0, cst_h2, [0, cst_http_1_1, 0]]],
    cst_dream_websocket = "dream.websocket";
   function to_dream_method(method){
    var _bc_ = caml_call1(Dream_httpaf_Httpaf[2][4], method);
    return caml_call1(Dream_pure_Method[2], _bc_);
   }
   function to_httpaf_status(status){
    var _bb_ = caml_call1(Dream_pure_Status[6], status);
    return caml_call1(Dream_httpaf_Httpaf[3][3], _bb_);
   }
   function to_h2_status(status){
    var _ba_ = caml_call1(Dream_pure_Status[6], status);
    return caml_call1(Dream_h2_H2[2][3], _ba_);
   }
   function sha1(s){
    var _a$_ = caml_call3(Digestif[2][12], 0, 0, s);
    return caml_call1(Digestif[2][39], _a$_);
   }
   var
    websocket_log = caml_call2(Dream_server_Log[19], 0, cst_dream_websocket);
   function wrap_handler(tls, user_s_error_handler, user_s_dream_handler){
    function httpaf_request_handler(client_address, conn){
     caml_call1(Dream_server_Log[23], 0);
     var
      upgrade = conn[2],
      conn$0 = conn[1],
      httpaf_request = caml_call1(Dream_httpaf_Httpaf[9][1], conn$0),
      client = caml_call1(Dream_http_Adapt[1], client_address),
      method = to_dream_method(httpaf_request[1]),
      target = httpaf_request[2],
      headers = caml_call1(Dream_httpaf_Httpaf[4][4], httpaf_request[4]),
      body = caml_call1(Dream_httpaf_Httpaf[9][2], conn$0);
     function read(data, param, _a8_, _a7_, close, _a6_){
      function _a9_(buffer, off, len){
       return caml_call5(data, buffer, off, len, 1, 0);
      }
      function _a__(param){return caml_call1(close, 1000);}
      return caml_call3(Dream_httpaf_Httpaf[5][1][1], body, _a__, _a9_);
     }
     function close(code){
      return caml_call1(Dream_httpaf_Httpaf[5][1][2], body);
     }
     var
      body$0 = caml_call3(Dream_pure_Stream[1], read, close, close),
      body$1 = caml_call2(Dream_pure_Stream[6], body$0, Dream_pure_Stream[5]),
      request =
        caml_call6
         (Dream_server_Helpers[7],
          client,
          method,
          target,
          tls,
          headers,
          body$1);
     function _aU_(param){
      function _aV_(exn){
       caml_call2(Dream_httpaf_Httpaf[9][10], conn$0, exn);
       return Lwt[36];
      }
      function _aW_(param){
       var ppx_lwt_0 = caml_call1(user_s_dream_handler, request);
       function _aX_(response){
        function forward_response(response){
         caml_call1(Dream_pure_Message[21], response);
         var
          _a5_ = caml_call1(Dream_pure_Message[11], response),
          headers = caml_call1(Dream_httpaf_Httpaf[4][2], _a5_),
          status =
            to_httpaf_status(caml_call1(Dream_pure_Message[7], response)),
          httpaf_response =
            caml_call4(Dream_httpaf_Httpaf[7][1], 0, 0, [0, headers], status),
          body =
            caml_call3(Dream_httpaf_Httpaf[9][7], 0, conn$0, httpaf_response);
         caml_call2(Dream_http_Adapt[3], response, body);
         return Lwt[36];
        }
        var match = caml_call1(Dream_pure_Message[32], response);
        if(! match) return forward_response(response);
        var
         client_stream = match[1][1],
         error_handler =
           caml_call3
            (Dream_http_Error_handler[8],
             user_s_error_handler,
             request,
             response);
        function proceed(param){
         var
          _a2_ = caml_call1(Dream_httpaf_Websocket[1], client_stream),
          _a3_ =
            caml_call2
             (Dream_websocketaf_Websocketaf[7][2], [0, error_handler], _a2_),
          _a4_ = Dream_websocketaf_Websocketaf[7];
         return caml_call1
                 (upgrade,
                  caml_call1
                   (caml_call1
                     (Dream_gluten_Gluten[1],
                      [0,
                       _a4_[3],
                       _a4_[5],
                       _a4_[6],
                       _a4_[9],
                       _a4_[4],
                       _a4_[7],
                       _a4_[10],
                       _a4_[8],
                       _a4_[11],
                       _a4_[12]]),
                    _a3_));
        }
        var
         _aZ_ = caml_call1(Dream_pure_Message[11], response),
         headers = caml_call1(Dream_httpaf_Httpaf[4][2], _aZ_),
         param =
           caml_call4
            (Dream_websocketaf_Websocketaf[4][3],
             [0, headers],
             sha1,
             conn$0,
             proceed);
        if(0 === param[0]) return Lwt[36];
        var
         error_string = param[1],
         ppx_lwt_0 =
           caml_call4
            (Dream_http_Error_handler[9],
             user_s_error_handler,
             request,
             response,
             error_string);
        function _a0_(response){return forward_response(response);}
        function _a1_(exn){
         try{throw caml_maybe_attach_backtrace(exn, 0);}
         catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
        }
        return caml_call3(Lwt[81], _a1_, ppx_lwt_0, _a0_);
       }
       function _aY_(exn){
        try{throw caml_maybe_attach_backtrace(exn, 0);}
        catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
       }
       return caml_call3(Lwt[81], _aY_, ppx_lwt_0, _aX_);
      }
      return caml_call1(caml_call1(Lwt[7], _aW_), _aV_);
     }
     return caml_call1(Lwt[11], _aU_);
    }
    return httpaf_request_handler;
   }
   function wrap_handler_h2(tls, user_s_error_handler, user_s_dream_handler){
    function httpaf_request_handler(client_address, conn){
     caml_call1(Dream_server_Log[23], 0);
     var
      httpaf_request = caml_call1(Dream_h2_H2[8][1], conn),
      client = caml_call1(Dream_http_Adapt[1], client_address),
      method = to_dream_method(httpaf_request[1]),
      target = httpaf_request[2],
      headers = caml_call1(Dream_h2_H2[3][4], httpaf_request[4]),
      body = caml_call1(Dream_h2_H2[8][2], conn);
     function read(data, param, _aR_, _aQ_, close, _aP_){
      function _aS_(buffer, off, len){
       return caml_call5(data, buffer, off, len, 1, 0);
      }
      function _aT_(param){return caml_call1(close, 1000);}
      return caml_call3(Dream_h2_H2[4][1][1], body, _aT_, _aS_);
     }
     function close(code){return caml_call1(Dream_h2_H2[4][1][2], body);}
     var
      body$0 = caml_call3(Dream_pure_Stream[1], read, close, close),
      body$1 = caml_call2(Dream_pure_Stream[6], body$0, Dream_pure_Stream[5]),
      request =
        caml_call6
         (Dream_server_Helpers[7],
          client,
          method,
          target,
          tls,
          headers,
          body$1);
     function _aJ_(param){
      function _aK_(exn){
       caml_call2(Dream_h2_H2[8][11], conn, exn);
       return Lwt[36];
      }
      function _aL_(param){
       var ppx_lwt_0 = caml_call1(user_s_dream_handler, request);
       function _aM_(response){
        if(caml_call1(Dream_pure_Message[32], response)) return Lwt[36];
        caml_call1(Dream_pure_Message[22], response);
        caml_call1(Dream_pure_Message[18], response);
        var
         _aO_ = caml_call1(Dream_pure_Message[11], response),
         headers = caml_call1(Dream_h2_H2[3][2], _aO_),
         status = to_h2_status(caml_call1(Dream_pure_Message[7], response)),
         h2_response = caml_call2(Dream_h2_H2[6][1], [0, headers], status),
         body = caml_call3(Dream_h2_H2[8][7], conn, 0, h2_response);
        caml_call2(Dream_http_Adapt[4], response, body);
        return Lwt[36];
       }
       function _aN_(exn){
        try{throw caml_maybe_attach_backtrace(exn, 0);}
        catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
       }
       return caml_call3(Lwt[81], _aN_, ppx_lwt_0, _aM_);
      }
      return caml_call1(caml_call1(Lwt[7], _aL_), _aK_);
     }
     return caml_call1(Lwt[11], _aJ_);
    }
    return httpaf_request_handler;
   }
   var
    log = Dream_http_Error_handler[10],
    no_tls =
      [0,
       function(param, _aG_, handler, error_handler){
        var
         _aH_ = caml_call1(Dream_http_Error_handler[5], error_handler),
         _aI_ = wrap_handler(0, error_handler, handler);
        return caml_call3(Dream_httpaf_lwt_unix_Httpaf_l[1][1], 0, _aI_, _aH_);
       }],
    openssl =
      [0,
       function(certificate_file, key_file, handler, error_handler){
        var
         _az_ = caml_call1(Dream_http_Error_handler[5], error_handler),
         _aA_ = wrap_handler(1, error_handler, handler),
         httpaf_handler =
           caml_call3(Dream_httpaf_lwt_unix_Httpaf_l[1][3][1], 0, _aA_, _az_),
         _aB_ = caml_call1(Dream_http_Error_handler[6], error_handler),
         _aC_ = wrap_handler_h2(1, error_handler, handler),
         h2_handler =
           caml_call3(Dream_h2_lwt_unix_H2_lwt_unix[1][3][1], 0, _aC_, _aB_),
         perform_tls_handshake =
           caml_call3
            (Dream_gluten_lwt_unix_Gluten_l[1][4][3],
             _a_,
             certificate_file,
             key_file);
        return function(client_address, unix_socket){
         var
          ppx_lwt_0 =
            caml_call2(perform_tls_handshake, client_address, unix_socket);
         function _aD_(tls_endpoint){
          var match = caml_call1(Lwt_ssl[1], tls_endpoint);
          if(! match)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
          var
           tls_socket = match[1],
           match$0 = caml_call1(Ssl[64], tls_socket);
          if(! match$0)
           return caml_call2(httpaf_handler, client_address, tls_endpoint);
          var _aF_ = match$0[1];
          if(! caml_string_notequal(_aF_, cst_h2))
           return caml_call2(h2_handler, client_address, tls_endpoint);
          if(caml_string_notequal(_aF_, cst_http_1_1))
           throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
          return caml_call2(httpaf_handler, client_address, tls_endpoint);
         }
         function _aE_(exn){
          try{throw caml_maybe_attach_backtrace(exn, 0);}
          catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
         }
         return caml_call3(Lwt[81], _aE_, ppx_lwt_0, _aD_);};
       }],
    ocaml_tls =
      [0,
       function(certificate_file, key_file, handler, error_handler){
        var
         _ax_ = caml_call1(Dream_http_Error_handler[5], error_handler),
         _ay_ = wrap_handler(1, error_handler, handler);
        return caml_call5
                (Dream_httpaf_lwt_unix_Httpaf_l[1][2][2],
                 certificate_file,
                 key_file,
                 0,
                 _ay_,
                 _ax_);
       }];
   function check_headers_middleware(next_handler, request){
    var ppx_lwt_0 = caml_call1(next_handler, request);
    function _as_(response){
     var _au_ = caml_call1(Dream_pure_Message[11], response);
     function _av_(param){
      var name = param[1];
      return caml_string_equal(caml_call1(Stdlib_String[24], name), cst$1);
     }
     var
      invalid_headers_exist =
        caml_call1(caml_call1(Stdlib_List[34], _av_), _au_);
     if(invalid_headers_exist){
      var _aw_ = function(log){return caml_call2(log, [0, request], _d_);};
      caml_call1(log[2], _aw_);
     }
     return caml_call1(Lwt[4], response);
    }
    function _at_(exn){
     try{throw caml_maybe_attach_backtrace(exn, 0);}
     catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
    }
    return caml_call3(Lwt[81], _at_, ppx_lwt_0, _as_);
   }
   function built_in_middleware(error_handler){
    var
     _aq_ = caml_call1(Dream_http_Error_handler[4], error_handler),
     _ar_ =
       [0,
        check_headers_middleware,
        [0, caml_call1(Dream_server_Catch[1], _aq_), 0]];
    return caml_call1(Dream_pure_Message[38], _ar_);
   }
   function serve_with_details
   (caller_function_for_error_mess,
    tls_library,
    interface$0,
    network,
    ppx_lwt_0,
    error_handler,
    certificate_file,
    key_file,
    builtins,
    user_s_dream_handler){
    var
     user_s_dream_handler$0 =
       builtins
        ? caml_call1(built_in_middleware(error_handler), user_s_dream_handler)
        : user_s_dream_handler,
     httpaf_connection_handler =
       caml_call4
        (tls_library[1],
         certificate_file,
         key_file,
         user_s_dream_handler$0,
         error_handler),
     tls_error_handler =
       caml_call1(Dream_http_Error_handler[7], error_handler);
    function httpaf_connection_handler$0(client_address, socket){
     function _ao_(exn){
      caml_call2(tls_error_handler, client_address, exn);
      return Lwt[36];
     }
     function _ap_(param){
      return caml_call2(httpaf_connection_handler, client_address, socket);
     }
     return caml_call2(Lwt[7], _ap_, _ao_);
    }
    if(948106920 <= network[1])
     var path = network[2], ppx_lwt_0$0 = caml_call1(Lwt[4], [0, path]);
    else
     var
      port = network[2],
      _ah_ = caml_call1(Stdlib[33], port),
      ppx_lwt_0$1 = caml_call3(Lwt_unix[130], interface$0, _ah_, 0),
      _ai_ =
        function(addresses){
         if(! addresses)
          return caml_call4
                  (Stdlib_Printf[10],
                   Stdlib[2],
                   _e_,
                   caller_function_for_error_mess,
                   interface$0);
         var address = addresses[1];
         return caml_call1(Lwt[4], address[4]);
        },
      _aj_ =
        function(exn){
         try{throw caml_maybe_attach_backtrace(exn, 0);}
         catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
        },
      ppx_lwt_0$0 = caml_call3(Lwt[81], _aj_, ppx_lwt_0$1, _ai_);
    function _af_(listen_address){
     var
      ppx_lwt_0$0 =
        caml_call5
         (Lwt_io[77], 0, 0, 0, listen_address, httpaf_connection_handler$0);
     function _ak_(server){
      function _am_(param){return caml_call1(Lwt_io[79], server);}
      function _an_(exn){
       try{throw caml_maybe_attach_backtrace(exn, 0);}
       catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
      }
      return caml_call3(Lwt[81], _an_, ppx_lwt_0, _am_);
     }
     function _al_(exn){
      try{throw caml_maybe_attach_backtrace(exn, 0);}
      catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
     }
     return caml_call3(Lwt[81], _al_, ppx_lwt_0$0, _ak_);
    }
    function _ag_(exn){
     try{throw caml_maybe_attach_backtrace(exn, 0);}
     catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
    }
    return caml_call3(Lwt[81], _ag_, ppx_lwt_0$0, _af_);
   }
   function is_localhost(interface$0){
    var
     _ad_ = caml_string_equal(interface$0, cst_localhost$0),
     _ae_ = _ad_ || caml_string_equal(interface$0, cst_127_0_0_1);
    return _ae_;
   }
   function serve_with_maybe_https
   (caller_function_for_error_mess,
    interface$0,
    network,
    stop,
    error_handler,
    tls_library,
    certificate_file,
    key_file,
    certificate_string,
    key_string,
    builtins,
    user_s_dream_handler){
    function _K_(exn){
     var backtrace = caml_call1(Stdlib_Printexc[6], 0);
     function _aa_(log){
      return caml_call4
              (log,
               0,
               _f_,
               caller_function_for_error_mess,
               caml_call1(Stdlib_Printexc[1], exn));
     }
     caml_call1(log[1], _aa_);
     function _ab_(line){
      function _ac_(log){return caml_call3(log, 0, _g_, line);}
      return caml_call1(log[1], _ac_);
     }
     caml_call1(caml_call1(Dream_server_Log[21], _ab_), backtrace);
     throw caml_maybe_attach_backtrace(exn, 1);
    }
    function _L_(param){
     if(17505 === tls_library)
      return serve_with_details
              (caller_function_for_error_mess,
               no_tls,
               interface$0,
               network,
               stop,
               error_handler,
               cst$0,
               cst,
               builtins,
               user_s_dream_handler);
     a:
     {
      if(certificate_file){
       if(key_file && ! certificate_string && ! key_string){
        var
         key_file$0 = key_file[1],
         certificate_file$0 = certificate_file[1],
         certificate_and_key =
           [0, 781515420, [0, certificate_file$0, key_file$0]];
        break a;
       }
      }
      else
       if(! key_file)
        if(certificate_string){
         if(key_string){
          var
           key_string$1 = key_string[1],
           certificate_string$1 = certificate_string[1],
           _O_ = function(log){return caml_call2(log, 0, _j_);};
          caml_call1(log[2], _O_);
          var
           certificate_and_key =
             [0,
              961822497,
              [0, certificate_string$1, key_string$1, 1057685346]];
          break a;
         }
        }
        else if(! key_string){
         if(1 - is_localhost(interface$0)){
          var _P_ = function(log){return caml_call2(log, 0, _k_);};
          caml_call1(log[2], _P_);
          var _Q_ = function(log){return caml_call2(log, 0, _l_);};
          caml_call1(log[2], _Q_);
         }
         var
          certificate_and_key =
            [0,
             961822497,
             [0, Dream_certificate[1], Dream_certificate[2], -329127243]];
         break a;
        }
      throw caml_maybe_attach_backtrace
             ([0, Stdlib[6], cst_Must_specify_exactly_one_p], 1);
     }
     var tls_library$0 = 226845186 <= tls_library ? openssl : ocaml_tls;
     if(961822497 <= certificate_and_key[1]){
      var
       match = certificate_and_key[2],
       verbose_or_silent = match[3],
       key_string$0 = match[2],
       certificate_string$0 = match[1],
       _N_ =
         function(param){
          var certificate_stream = param[2], certificate_file = param[1];
          function _R_(param){
           var key_stream = param[2], key_file = param[1];
           if(-329127243 !== verbose_or_silent){
            var
             _S_ =
               function(log){
                return caml_call3(log, 0, _h_, certificate_file);
               };
            caml_call1(log[2], _S_);
            var
             _T_ = function(log){return caml_call3(log, 0, _i_, key_file);};
            caml_call1(log[2], _T_);
           }
           var
            ppx_lwt_0 =
              caml_call2(Lwt_io[43], certificate_stream, certificate_string$0);
           function _U_(param){
            var ppx_lwt_0 = caml_call2(Lwt_io[43], key_stream, key_string$0);
            function _W_(param){
             var ppx_lwt_0 = caml_call1(Lwt_io[15], certificate_stream);
             function _Y_(param){
              var ppx_lwt_0 = caml_call1(Lwt_io[15], key_stream);
              function ___(param){
               return serve_with_details
                       (caller_function_for_error_mess,
                        tls_library$0,
                        interface$0,
                        network,
                        stop,
                        error_handler,
                        certificate_file,
                        key_file,
                        builtins,
                        user_s_dream_handler);
              }
              function _$_(exn){
               try{throw caml_maybe_attach_backtrace(exn, 0);}
               catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
              }
              return caml_call3(Lwt[81], _$_, ppx_lwt_0, ___);
             }
             function _Z_(exn){
              try{throw caml_maybe_attach_backtrace(exn, 0);}
              catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
             }
             return caml_call3(Lwt[81], _Z_, ppx_lwt_0, _Y_);
            }
            function _X_(exn){
             try{throw caml_maybe_attach_backtrace(exn, 0);}
             catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
            }
            return caml_call3(Lwt[81], _X_, ppx_lwt_0, _W_);
           }
           function _V_(exn){
            try{throw caml_maybe_attach_backtrace(exn, 0);}
            catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
           }
           return caml_call3(Lwt[81], _V_, ppx_lwt_0, _U_);
          }
          return caml_call7(Lwt_io[70], 0, 0, 0, 0, 0, 0, _R_);
         };
      return caml_call7(Lwt_io[70], 0, 0, 0, 0, 0, 0, _N_);
     }
     var
      match$0 = certificate_and_key[2],
      key_file$1 = match$0[2],
      certificate_file$1 = match$0[1];
     return serve_with_details
             (caller_function_for_error_mess,
              tls_library$0,
              interface$0,
              network,
              stop,
              error_handler,
              certificate_file$1,
              key_file$1,
              builtins,
              user_s_dream_handler);
    }
    function _M_(exn){
     try{throw caml_maybe_attach_backtrace(exn, 0);}
     catch(exn){var exn$0 = caml_wrap_exception(exn); return exn$0;}
    }
    return caml_call3(Lwt[82], _M_, _L_, _K_);
   }
   var never = caml_call1(Lwt[1], 0)[1], default_port = 8080;
   function network(port, socket_path){
    if(! socket_path) return [0, 815031220, port];
    var path = socket_path[1];
    return [0, 948106920, path];
   }
   function serve
   (opt,
    _G_,
    socket_path,
    _F_,
    _E_,
    _D_,
    certificate_file,
    key_file,
    _C_,
    user_s_dream_handler){
    if(opt)
     var sth = opt[1], interface$0 = sth;
    else
     var interface$0 = default_interface;
    if(_G_) var sth$0 = _G_[1], port = sth$0; else var port = default_port;
    if(_F_) var sth$1 = _F_[1], stop = sth$1; else var stop = never;
    if(_E_)
     var sth$2 = _E_[1], error_handler = sth$2;
    else
     var error_handler = Dream_http_Error_handler[1];
    if(_D_) var sth$3 = _D_[1], tls = sth$3; else var tls = 0;
    if(_C_) var sth$4 = _C_[1], builtins = sth$4; else var builtins = 1;
    var _H_ = 0, _I_ = 0, _J_ = tls ? 226845186 : 17505;
    return serve_with_maybe_https
            (cst_serve,
             interface$0,
             network(port, socket_path),
             stop,
             error_handler,
             _J_,
             certificate_file,
             key_file,
             _I_,
             _H_,
             builtins,
             user_s_dream_handler);
   }
   function run
   (opt,
    _w_,
    socket_path,
    _v_,
    _u_,
    _t_,
    certificate_file,
    key_file,
    _s_,
    _r_,
    adjust_terminal,
    user_s_dream_handler){
    if(opt)
     var sth = opt[1], interface$0 = sth;
    else
     var interface$0 = default_interface;
    if(_w_) var sth$0 = _w_[1], port = sth$0; else var port = default_port;
    if(_v_) var sth$1 = _v_[1], stop = sth$1; else var stop = never;
    if(_u_)
     var sth$2 = _u_[1], error_handler = sth$2;
    else
     var error_handler = Dream_http_Error_handler[1];
    if(_t_) var sth$3 = _t_[1], tls = sth$3; else var tls = 0;
    if(_s_) var sth$4 = _s_[1], builtins = sth$4; else var builtins = 1;
    if(_r_) var sth$5 = _r_[1], greeting = sth$5; else var greeting = 1;
    if(Stdlib_Sys[6]) caml_call2(Stdlib_Sys[15], Stdlib_Sys[23], 1);
    var log = Dream_server_Log[20];
    if(0 !== adjust_terminal){
     var _x_ = function(log){return caml_call2(log, 0, _m_);};
     caml_call1(Dream_http_Error_handler[10][2], _x_);
    }
    if(greeting){
     var scheme = tls ? cst_https : cst_http;
     a:
     if(socket_path){
      var path = socket_path[1];
      caml_call2(log, _n_, path);
     }
     else{
      b:
      {
       if
        (caml_string_notequal(interface$0, cst_127_0_0_1)
         && caml_string_notequal(interface$0, cst_localhost$0))
        break b;
       if(! socket_path){caml_call3(log, _q_, scheme, port); break a;}
      }
      caml_call5(log, _p_, interface$0, port, scheme, port);
     }
     caml_call1(log, _o_);
    }
    var
     _y_ = 0,
     _z_ = 0,
     _A_ = tls ? 226845186 : 17505,
     _B_ =
       serve_with_maybe_https
        (cst_run,
         interface$0,
         network(port, socket_path),
         stop,
         error_handler,
         _A_,
         certificate_file,
         key_file,
         _z_,
         _y_,
         builtins,
         user_s_dream_handler);
    return caml_call1(Lwt_main[1], _B_);
   }
   var
    Dream_http_Http =
      [0,
       to_dream_method,
       to_httpaf_status,
       to_h2_status,
       sha1,
       websocket_log,
       wrap_handler,
       wrap_handler_h2,
       log,
       no_tls,
       openssl,
       ocaml_tls,
       check_headers_middleware,
       built_in_middleware,
       serve_with_details,
       is_localhost,
       serve_with_maybe_https,
       default_interface,
       default_port,
       never,
       network,
       serve,
       run];
   runtime.caml_register_global(65, Dream_http_Http, "Dream__http__Http");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJkcmVhbV9faHR0cC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiYWRkcmVzc190b19zdHJpbmciLCJwYXRoIiwicG9ydCIsImFkZHJlc3MiLCJmb3J3YXJkX2JvZHlfZ2VuZXJhbCIsInJlc3BvbnNlIiwid3JpdGVfc3RyaW5nIiwid3JpdGVfYnVmZmVyIiwiaHR0cF9mbHVzaCIsImNsb3NlIiwiYWJvcnQiLCJleG4iLCJieXRlc19zaW5jZV9mbHVzaCIsInNlbmQiLCJzdHJlYW0iLCJkYXRhIiwiZmx1c2giLCJwaW5nIiwicG9uZyIsImNodW5rIiwib2ZmIiwibGVuIiwiYmluYXJ5IiwiZmluIiwiYnVmZmVyIiwib2Zmc2V0IiwibGVuZ3RoIiwiZm9yd2FyZF9ib2R5IiwiYm9keSIsImNvZGUiLCJmb3J3YXJkX2JvZHlfaDIiLCJsb2ciLCJzZWxlY3RfbG9nIiwiY3VzdG9taXplIiwidGVtcGxhdGUiLCJlcnJvciIsImNvbmRpdGlvbiIsImNsaWVudCQwIiwiY2xpZW50JDEiLCJsYXllciQwIiwiZXhuJDAiLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwiZGVzY3JpcHRpb24iLCJzdHJpbmckMCIsIm1lc3NhZ2UiLCJsaW5lIiwicCIsImZvcm1hdCIsInN0YXR1cyIsImJhY2t0cmFjZSIsInN0cmluZyIsImxheWVyIiwiYmxhbWUiLCJzZXZlcml0eSIsImNsaWVudCIsInJlcXVlc3QiLCJ2YWx1ZSIsIm5hbWUiLCJmaXJzdCIsImRlYnVnX2R1bXAiLCJyZXNwb25zZSQxIiwicmVzcG9uc2UkMCIsInN0YXR1cyQwIiwicHB4X2x3dF8wIiwiZGVmYXVsdF90ZW1wbGF0ZSIsImRlYnVnX3RlbXBsYXRlIiwicmVhc29uIiwiZGVmYXVsdCQwIiwiZGVidWdfZXJyb3JfaGFuZGxlciIsImRvdWJsZV9mYXVsdHMiLCJmIiwicmVzcG9uZF93aXRoX29wdGlvbiIsImFwcCIsInVzZXJfc19lcnJvcl9oYW5kbGVyIiwiZGVmYXVsdF9yZXNwb25zZSIsImh0dHBhZiIsImNsaWVudF9hZGRyZXNzIiwic3RhcnRfcmVzcG9uc2UiLCJjYXVzZWRfYnkiLCJjb25kaXRpb24kMCIsImVycm9yJDAiLCJoZWFkZXJzIiwiaDIiLCJ0bHMiLCJ3ZWJzb2NrZXQiLCJzb2NrZXQiLCJ3ZWJzb2NrZXRfaGFuZHNoYWtlIiwiZXJyb3Jfc3RyaW5nIiwiZGVmYXVsdF9pbnRlcmZhY2UiLCJ0b19kcmVhbV9tZXRob2QiLCJtZXRob2QiLCJ0b19odHRwYWZfc3RhdHVzIiwidG9faDJfc3RhdHVzIiwic2hhMSIsInMiLCJ3ZWJzb2NrZXRfbG9nIiwid3JhcF9oYW5kbGVyIiwidXNlcl9zX2RyZWFtX2hhbmRsZXIiLCJodHRwYWZfcmVxdWVzdF9oYW5kbGVyIiwiY29ubiIsInVwZ3JhZGUiLCJjb25uJDAiLCJodHRwYWZfcmVxdWVzdCIsInRhcmdldCIsInJlYWQiLCJib2R5JDAiLCJib2R5JDEiLCJmb3J3YXJkX3Jlc3BvbnNlIiwiaHR0cGFmX3Jlc3BvbnNlIiwiY2xpZW50X3N0cmVhbSIsImVycm9yX2hhbmRsZXIiLCJwcm9jZWVkIiwid3JhcF9oYW5kbGVyX2gyIiwiaDJfcmVzcG9uc2UiLCJub190bHMiLCJoYW5kbGVyIiwib3BlbnNzbCIsImNlcnRpZmljYXRlX2ZpbGUiLCJrZXlfZmlsZSIsImh0dHBhZl9oYW5kbGVyIiwiaDJfaGFuZGxlciIsInBlcmZvcm1fdGxzX2hhbmRzaGFrZSIsInVuaXhfc29ja2V0IiwidGxzX2VuZHBvaW50IiwidGxzX3NvY2tldCIsIm9jYW1sX3RscyIsImNoZWNrX2hlYWRlcnNfbWlkZGxld2FyZSIsIm5leHRfaGFuZGxlciIsImludmFsaWRfaGVhZGVyc19leGlzdCIsImJ1aWx0X2luX21pZGRsZXdhcmUiLCJzZXJ2ZV93aXRoX2RldGFpbHMiLCJjYWxsZXJfZnVuY3Rpb25fZm9yX2Vycm9yX21lc3MiLCJ0bHNfbGlicmFyeSIsImludGVyZmFjZSQwIiwibmV0d29yayIsImJ1aWx0aW5zIiwidXNlcl9zX2RyZWFtX2hhbmRsZXIkMCIsImh0dHBhZl9jb25uZWN0aW9uX2hhbmRsZXIiLCJ0bHNfZXJyb3JfaGFuZGxlciIsImh0dHBhZl9jb25uZWN0aW9uX2hhbmRsZXIkMCIsInBweF9sd3RfMCQwIiwicHB4X2x3dF8wJDEiLCJhZGRyZXNzZXMiLCJsaXN0ZW5fYWRkcmVzcyIsInNlcnZlciIsImlzX2xvY2FsaG9zdCIsInNlcnZlX3dpdGhfbWF5YmVfaHR0cHMiLCJzdG9wIiwiY2VydGlmaWNhdGVfc3RyaW5nIiwia2V5X3N0cmluZyIsImtleV9maWxlJDAiLCJjZXJ0aWZpY2F0ZV9maWxlJDAiLCJjZXJ0aWZpY2F0ZV9hbmRfa2V5Iiwia2V5X3N0cmluZyQxIiwiY2VydGlmaWNhdGVfc3RyaW5nJDEiLCJ0bHNfbGlicmFyeSQwIiwidmVyYm9zZV9vcl9zaWxlbnQiLCJrZXlfc3RyaW5nJDAiLCJjZXJ0aWZpY2F0ZV9zdHJpbmckMCIsImNlcnRpZmljYXRlX3N0cmVhbSIsImtleV9zdHJlYW0iLCJrZXlfZmlsZSQxIiwiY2VydGlmaWNhdGVfZmlsZSQxIiwibmV2ZXIiLCJkZWZhdWx0X3BvcnQiLCJzb2NrZXRfcGF0aCIsInNlcnZlIiwib3B0Iiwic3RoIiwic3RoJDAiLCJzdGgkMSIsInN0aCQyIiwic3RoJDMiLCJzdGgkNCIsInJ1biIsImFkanVzdF90ZXJtaW5hbCIsInN0aCQ1IiwiZ3JlZXRpbmciLCJzY2hlbWUiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS9odHRwL2FkYXB0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0vaHR0cC9lcnJvcl9oYW5kbGVyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0vaHR0cC9odHRwLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7OztZQWVJQTtJQUE4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QjdELGdCQUFnQjZEOztTQUFoQjdEO0lBU0osWUFSVThELGdCQUFOekYsTUFBTXlGLGdCQUFOekY7SUFRSixZQUxlMEYsZ0JBQVh0QyxXQUFXc0MsZ0JBQVh0QztJQUtKLFlBSmV5QyxnQkFBWEMsV0FBV0QsZ0JBQVhDO0lBSUosa0JBQ087SUFBQSxJQUdIbko7YUFQRGlKO0tBVzZCLG1CQUNDakosS0FDN0IsT0FBQSxXQUQ2QkEsYUFDa0I7S0FGbkI7O09BWjVCbUo7U0FrQkVDLFNBdEJGL0Y7O1FBSERrRjtVQWlDU3JLLE9BakNUcUs7TUFrQ0MsV0FuQkF2SSxVQWtCUTlCOzs7Ozs7OEJBbkNScUk7aUNBQUFBOztZQUVEZ0MsYUFvQ0MsV0FyQkF2SSxVQVVFb0osUUExQkZqTDs7TUF1Q0EsV0F2QkE2QixVQWpCQXVHLGFBQ0FwSSxNQTBCRWlMLFFBMUJGakw7O0tBeUNGLFdBekJFNkI7O0lBNEJTOzs7V0F4Q1RxRDtLQXdDUztPQW5PWCtEOztTQXNMRWI7U0FsQ0ZDLFFBbUNFckksTUFDRG9LO1NBQ0NsQjtTQUNBckM7O1NBRURPO1NBQ0FDOzs7U0FDQ2lCO1NBR0Z0QztJQWtDVyxPQUFBOzs7OztPQWxyQlhSO09BR0FFO09BR0FDO09BR0FDO09BS0FFO09BZ0JBQztPQWlJQWdCO09BK0ZBbEY7T0FnQkFvRjtPQVlBRTtPQTJEQVM7T0FjQUM7T0FXQUc7T0FNQUM7T0F3RkFlO09BR0FDO09BZ0pBMUQ7T0FDQTRFO09BQ0FEO09BRUE3QjtPQUtBZ0M7T0E0QkFROzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIERyZWFtLCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kXG4gICBmb3IgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL2FhbnRyb24vZHJlYW0uXG5cbiAgIENvcHlyaWdodCAyMDIxIEFudG9uIEJhY2hpbiAqKVxuXG5cblxubW9kdWxlIEh0dHBhZiA9IERyZWFtX2h0dHBhZl8uSHR0cGFmXG5tb2R1bGUgSDIgPSBEcmVhbV9oMi5IMlxuXG5tb2R1bGUgU3RyZWFtID0gRHJlYW1fcHVyZS5TdHJlYW1cbm1vZHVsZSBNZXNzYWdlID0gRHJlYW1fcHVyZS5NZXNzYWdlXG5cblxuXG5sZXQgYWRkcmVzc190b19zdHJpbmcgOiBVbml4LnNvY2thZGRyIC0+IHN0cmluZyA9IGZ1bmN0aW9uXG4gIHwgQUREUl9VTklYIHBhdGggLT4gcGF0aFxuICB8IEFERFJfSU5FVCAoYWRkcmVzcywgcG9ydCkgLT5cbiAgICBQcmludGYuc3ByaW50ZiBcIiVzOiVpXCIgKFVuaXguc3RyaW5nX29mX2luZXRfYWRkciBhZGRyZXNzKSBwb3J0XG5cblxuXG4oKiBUT0RPIFdyaXRlIGEgdGVzdCBzaW11bGF0aW5nIGNsaWVudCBleGl0IGR1cmluZyBTU0U7IHRoaXMgd2FzIGtpbGxpbmcgdGhlXG4gICBzZXJ2ZXIgYXQgc29tZSBwb2ludC4gKilcbmxldCBmb3J3YXJkX2JvZHlfZ2VuZXJhbFxuICAgIChyZXNwb25zZSA6IE1lc3NhZ2UucmVzcG9uc2UpXG4gICAgKF93cml0ZV9zdHJpbmcgOiA/b2ZmOmludCAtPiA/bGVuOmludCAtPiBzdHJpbmcgLT4gdW5pdClcbiAgICAod3JpdGVfYnVmZmVyIDogP29mZjppbnQgLT4gP2xlbjppbnQgLT4gU3RyZWFtLmJ1ZmZlciAtPiB1bml0KVxuICAgIGh0dHBfZmx1c2hcbiAgICBjbG9zZSA9XG5cbiAgbGV0IGFib3J0IF9leG4gPSBjbG9zZSAxMDAwIGluXG5cbiAgbGV0IGJ5dGVzX3NpbmNlX2ZsdXNoID0gcmVmIDAgaW5cblxuICBsZXQgcmVjIHNlbmQgKCkgPVxuICAgIE1lc3NhZ2UuY2xpZW50X3N0cmVhbSByZXNwb25zZVxuICAgIHw+IGZ1biBzdHJlYW0gLT5cbiAgICAgIFN0cmVhbS5yZWFkXG4gICAgICAgIHN0cmVhbVxuICAgICAgICB+ZGF0YVxuICAgICAgICB+Zmx1c2hcbiAgICAgICAgfnBpbmdcbiAgICAgICAgfnBvbmdcbiAgICAgICAgfmNsb3NlXG4gICAgICAgIH5leG46YWJvcnRcblxuICBhbmQgZGF0YSBjaHVuayBvZmYgbGVuIF9iaW5hcnkgX2ZpbiA9XG4gICAgd3JpdGVfYnVmZmVyIH5vZmYgfmxlbiBjaHVuaztcbiAgICBieXRlc19zaW5jZV9mbHVzaCA6PSAhYnl0ZXNfc2luY2VfZmx1c2ggKyBsZW47XG4gICAgaWYgIWJ5dGVzX3NpbmNlX2ZsdXNoID49IDQwOTYgdGhlbiBiZWdpblxuICAgICAgYnl0ZXNfc2luY2VfZmx1c2ggOj0gMDtcbiAgICAgIGh0dHBfZmx1c2ggc2VuZFxuICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHNlbmQgKClcblxuICBhbmQgZmx1c2ggKCkgPVxuICAgIGJ5dGVzX3NpbmNlX2ZsdXNoIDo9IDA7XG4gICAgaHR0cF9mbHVzaCBzZW5kXG5cbiAgYW5kIHBpbmcgX2J1ZmZlciBfb2Zmc2V0IF9sZW5ndGggPVxuICAgIHNlbmQgKClcblxuICBhbmQgcG9uZyBfYnVmZmVyIF9vZmZzZXQgX2xlbmd0aCA9XG4gICAgc2VuZCAoKVxuXG4gIGluXG5cbiAgc2VuZCAoKVxuXG5sZXQgZm9yd2FyZF9ib2R5XG4gICAgKHJlc3BvbnNlIDogTWVzc2FnZS5yZXNwb25zZSlcbiAgICAoYm9keSA6IEh0dHBhZi5Cb2R5LldyaXRlci50KSA9XG5cbiAgZm9yd2FyZF9ib2R5X2dlbmVyYWxcbiAgICByZXNwb25zZVxuICAgIChIdHRwYWYuQm9keS5Xcml0ZXIud3JpdGVfc3RyaW5nIGJvZHkpXG4gICAgKEh0dHBhZi5Cb2R5LldyaXRlci53cml0ZV9iaWdzdHJpbmcgYm9keSlcbiAgICAoSHR0cGFmLkJvZHkuV3JpdGVyLmZsdXNoIGJvZHkpXG4gICAgKGZ1biBfY29kZSAtPiBIdHRwYWYuQm9keS5Xcml0ZXIuY2xvc2UgYm9keSlcblxubGV0IGZvcndhcmRfYm9keV9oMlxuICAgIChyZXNwb25zZSA6IE1lc3NhZ2UucmVzcG9uc2UpXG4gICAgKGJvZHkgOiBIMi5Cb2R5LldyaXRlci50KSA9XG5cbiAgZm9yd2FyZF9ib2R5X2dlbmVyYWxcbiAgICByZXNwb25zZVxuICAgIChIMi5Cb2R5LldyaXRlci53cml0ZV9zdHJpbmcgYm9keSlcbiAgICAoSDIuQm9keS5Xcml0ZXIud3JpdGVfYmlnc3RyaW5nIGJvZHkpXG4gICAgKEgyLkJvZHkuV3JpdGVyLmZsdXNoIGJvZHkpXG4gICAgKGZ1biBfY29kZSAtPiBIMi5Cb2R5LldyaXRlci5jbG9zZSBib2R5KVxuIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgRHJlYW0sIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWRcbiAgIGZvciBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vYWFudHJvbi9kcmVhbS5cblxuICAgQ29weXJpZ2h0IDIwMjEgQW50b24gQmFjaGluICopXG5cblxuXG5tb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcbm1vZHVsZSBIMiA9IERyZWFtX2gyLkgyXG5tb2R1bGUgV2Vic29ja2V0YWYgPSBEcmVhbV93ZWJzb2NrZXRhZi5XZWJzb2NrZXRhZlxuXG5tb2R1bGUgQ2F0Y2ggPSBEcmVhbV9fc2VydmVyLkNhdGNoXG5tb2R1bGUgRXJyb3JfdGVtcGxhdGUgPSBEcmVhbV9fc2VydmVyLkVycm9yX3RlbXBsYXRlXG5tb2R1bGUgTWV0aG9kID0gRHJlYW1fcHVyZS5NZXRob2Rcbm1vZHVsZSBIZWxwZXJzID0gRHJlYW1fX3NlcnZlci5IZWxwZXJzXG5tb2R1bGUgTG9nID0gRHJlYW1fX3NlcnZlci5Mb2dcbm1vZHVsZSBNZXNzYWdlID0gRHJlYW1fcHVyZS5NZXNzYWdlXG5tb2R1bGUgU3RhdHVzID0gRHJlYW1fcHVyZS5TdGF0dXNcbm1vZHVsZSBTdHJlYW0gPSBEcmVhbV9wdXJlLlN0cmVhbVxuXG5cblxuKCogVE9ETyBET0MgVGhlIGVycm9yIGhhbmRsZXIgaXMgYWxtb3N0IGEgbWlkZGxld2FyZS4gQnV0IGl0IG5lZWRzIHRvIHBsdWcgaW4gdG9cbiAgIHRoZSBsb3dlciBsZXZlbHMgb2YgdGhlIGZyYW1ld29yay4gQWxzbywgYSBiZW5lZml0IG9mIGl0IG5vdCBiZWluZyBkaXJlY3RseVxuICAgYSBtaWRkbGV3YXJlIGlzIHRoYXQgaXQgY2Fubm90IHdyb25nbHkgYXBwZWFyIGNvbXBvc2VkIGludG8gZGVlcGVyIGxldmVscyBvZlxuICAgYW4gYXBwLiAqKVxuXG5sZXQgbG9nID1cbiAgTG9nLnN1Yl9sb2cgXCJkcmVhbS5odHRwXCJcblxubGV0IHNlbGVjdF9sb2cgPSBmdW5jdGlvblxuICB8IGBFcnJvciAtPiBsb2cuZXJyb3JcbiAgfCBgV2FybmluZyAtPiBsb2cud2FybmluZ1xuICB8IGBJbmZvIC0+IGxvZy5pbmZvXG4gIHwgYERlYnVnIC0+IGxvZy5kZWJ1Z1xuXG5cblxubGV0IGR1bXAgKGVycm9yIDogQ2F0Y2guZXJyb3IpID1cbiAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5jcmVhdGUgNDA5NiBpblxuICBsZXQgcCBmb3JtYXQgPSBQcmludGYuYnByaW50ZiBidWZmZXIgZm9ybWF0IGluXG5cbiAgYmVnaW4gbWF0Y2ggZXJyb3IuY29uZGl0aW9uIHdpdGhcbiAgfCBgUmVzcG9uc2UgcmVzcG9uc2UgLT5cbiAgICBsZXQgc3RhdHVzID0gTWVzc2FnZS5zdGF0dXMgcmVzcG9uc2UgaW5cbiAgICBwIFwiJWkgJXNcXG5cIiAoU3RhdHVzLnN0YXR1c190b19pbnQgc3RhdHVzKSAoU3RhdHVzLnN0YXR1c190b19zdHJpbmcgc3RhdHVzKVxuXG4gIHwgYFN0cmluZyBcIlwiIC0+XG4gICAgcCBcIihMaWJyYXJ5IGVycm9yIHdpdGhvdXQgZGVzY3JpcHRpb24gcGF5bG9hZClcXG5cIlxuXG4gIHwgYFN0cmluZyBzdHJpbmcgLT5cbiAgICBwIFwiJXNcXG5cIiBzdHJpbmdcblxuICB8IGBFeG4gZXhuIC0+XG4gICAgbGV0IGJhY2t0cmFjZSA9IFByaW50ZXhjLmdldF9iYWNrdHJhY2UgKCkgaW5cbiAgICBwIFwiJXNcXG5cIiAoUHJpbnRleGMudG9fc3RyaW5nIGV4bik7XG4gICAgYmFja3RyYWNlIHw+IExvZy5pdGVyX2JhY2t0cmFjZSAocCBcIiVzXFxuXCIpXG4gIGVuZDtcblxuICBwIFwiXFxuXCI7XG5cbiAgbGV0IGxheWVyID1cbiAgICBtYXRjaCBlcnJvci5sYXllciB3aXRoXG4gICAgfCBgVExTIC0+IFwiVExTIGxpYnJhcnlcIlxuICAgIHwgYEhUVFAgLT4gXCJIVFRQIGxpYnJhcnlcIlxuICAgIHwgYEhUVFAyIC0+IFwiSFRUUDIgbGlicmFyeVwiXG4gICAgfCBgV2ViU29ja2V0IC0+IFwiV2ViU29ja2V0IGxpYnJhcnlcIlxuICAgIHwgYEFwcCAtPiBcIkFwcGxpY2F0aW9uXCJcbiAgaW5cblxuICBsZXQgYmxhbWUgPVxuICAgIG1hdGNoIGVycm9yLmNhdXNlZF9ieSB3aXRoXG4gICAgfCBgU2VydmVyIC0+IFwiU2VydmVyXCJcbiAgICB8IGBDbGllbnQgLT4gXCJDbGllbnRcIlxuICBpblxuXG4gIGxldCBzZXZlcml0eSA9XG4gICAgbWF0Y2ggZXJyb3Iuc2V2ZXJpdHkgd2l0aFxuICAgIHwgYEVycm9yIC0+IFwiRXJyb3JcIlxuICAgIHwgYFdhcm5pbmcgLT4gXCJXYXJuaW5nXCJcbiAgICB8IGBJbmZvIC0+IFwiSW5mb1wiXG4gICAgfCBgRGVidWcgLT4gXCJEZWJ1Z1wiXG4gIGluXG5cbiAgcCBcIkZyb206ICVzXFxuXCIgbGF5ZXI7XG4gIHAgXCJCbGFtZTogJXNcXG5cIiBibGFtZTtcbiAgcCBcIlNldmVyaXR5OiAlc1wiIHNldmVyaXR5O1xuXG4gIGJlZ2luIG1hdGNoIGVycm9yLmNsaWVudCB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgY2xpZW50IC0+IHAgXCJcXG5cXG5DbGllbnQ6ICVzXCIgY2xpZW50XG4gIGVuZDtcblxuICBiZWdpbiBtYXRjaCBlcnJvci5yZXF1ZXN0IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSByZXF1ZXN0IC0+XG4gICAgcCBcIlxcblxcbiVzICVzXCJcbiAgICAgIChNZXRob2QubWV0aG9kX3RvX3N0cmluZyAoTWVzc2FnZS5tZXRob2RfIHJlcXVlc3QpKVxuICAgICAgKE1lc3NhZ2UudGFyZ2V0IHJlcXVlc3QpO1xuXG4gICAgTWVzc2FnZS5hbGxfaGVhZGVycyByZXF1ZXN0XG4gICAgfD4gTGlzdC5pdGVyIChmdW4gKG5hbWUsIHZhbHVlKSAtPiBwIFwiXFxuJXM6ICVzXCIgbmFtZSB2YWx1ZSk7XG5cbiAgICBNZXNzYWdlLmZvbGRfZmllbGRzIChmdW4gbmFtZSB2YWx1ZSBmaXJzdCAtPlxuICAgICAgaWYgZmlyc3QgdGhlblxuICAgICAgICBwIFwiXFxuXCI7XG4gICAgICBwIFwiXFxuJXM6ICVzXCIgbmFtZSB2YWx1ZTtcbiAgICAgIGZhbHNlKVxuICAgICAgdHJ1ZVxuICAgICAgcmVxdWVzdFxuICAgIHw+IGlnbm9yZVxuICBlbmQ7XG5cbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZmZlclxuXG4oKiBUT0RPIExBVEVSIFNvbWUgbGlicmFyeSBpcyByZWdpc3RlcmluZyBTLWV4cC1iYXNlZCBwcmludGVycyBmb3IgZXhwcmVzc2lvbnMsXG4gICB3aGljaCBhcmUgY2FsbGluZyBmdW5jdGlvbnMgdGhhdCB1c2UgZXhjZXB0aW9ucyBkdXJpbmcgcGFyc2luZywgd2hpY2ggYXJlXG4gICBjbG9iYmVyaW5nIHRoZSBiYWNrdHJhY2UuICopXG5sZXQgY3VzdG9taXplIHRlbXBsYXRlIChlcnJvciA6IENhdGNoLmVycm9yKSA9XG5cbiAgKCogRmlyc3QsIGxvZyB0aGUgZXJyb3IuICopXG5cbiAgYmVnaW4gbWF0Y2ggZXJyb3IuY29uZGl0aW9uIHdpdGhcbiAgfCBgUmVzcG9uc2UgXyAtPiAoKVxuICB8IGBTdHJpbmcgXyB8IGBFeG4gXyBhcyBjb25kaXRpb24gLT5cblxuICAgIGxldCBjbGllbnQgPVxuICAgICAgbWF0Y2ggZXJyb3IuY2xpZW50IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgICB8IFNvbWUgY2xpZW50IC0+ICBcIiAoXCIgXiBjbGllbnQgXiBcIilcIlxuICAgIGluXG5cbiAgICBsZXQgbGF5ZXIgPVxuICAgICAgbWF0Y2ggZXJyb3IubGF5ZXIgd2l0aFxuICAgICAgfCBgVExTIC0+IFtcIlRMU1wiIF4gY2xpZW50XVxuICAgICAgfCBgSFRUUCAtPiBbXCJIVFRQXCIgXiBjbGllbnRdXG4gICAgICB8IGBIVFRQMiAtPiBbXCJIVFRQLzJcIiBeIGNsaWVudF1cbiAgICAgIHwgYFdlYlNvY2tldCAtPiBbXCJXZWJTb2NrZXRcIiBeIGNsaWVudF1cbiAgICAgIHwgYEFwcCAtPiBbXVxuICAgIGluXG5cbiAgICBsZXQgZGVzY3JpcHRpb24sIGJhY2t0cmFjZSA9XG4gICAgICBtYXRjaCBjb25kaXRpb24gd2l0aFxuICAgICAgfCBgU3RyaW5nIHN0cmluZyAtPiBzdHJpbmcsIFwiXCJcbiAgICAgIHwgYEV4biBleG4gLT5cbiAgICAgICAgbGV0IGJhY2t0cmFjZSA9IFByaW50ZXhjLmdldF9iYWNrdHJhY2UgKCkgaW5cbiAgICAgICAgUHJpbnRleGMudG9fc3RyaW5nIGV4biwgYmFja3RyYWNlXG4gICAgaW5cblxuICAgIGxldCBtZXNzYWdlID0gU3RyaW5nLmNvbmNhdCBcIjogXCIgKGxheWVyIEAgW2Rlc2NyaXB0aW9uXSkgaW5cblxuICAgIHNlbGVjdF9sb2cgZXJyb3Iuc2V2ZXJpdHkgKGZ1biBsb2cgLT5cbiAgICAgIGxvZyA/cmVxdWVzdDplcnJvci5yZXF1ZXN0IFwiJXNcIiBtZXNzYWdlKTtcbiAgICBiYWNrdHJhY2UgfD4gTG9nLml0ZXJfYmFja3RyYWNlIChmdW4gbGluZSAtPlxuICAgICAgc2VsZWN0X2xvZyBlcnJvci5zZXZlcml0eSAoZnVuIGxvZyAtPlxuICAgICAgICBsb2cgP3JlcXVlc3Q6ZXJyb3IucmVxdWVzdCBcIiVzXCIgbGluZSkpXG4gIGVuZDtcblxuICAoKiBJZiBEcmVhbSB3aWxsIG5vdCBzZW5kIGEgcmVzcG9uc2UgZm9yIHRoaXMgZXJyb3IsIHdlIGFyZSBkb25lIGFmdGVyXG4gICAgIGxvZ2dpbmcuIE90aGVyd2lzZSwgaWYgZGVidWdnaW5nIGlzIGVuYWJsZWQsIGdhdGhlciBhIGJ1bmNoIG9mIGluZm9ybWF0aW9uLlxuICAgICBUaGVuLCBjYWxsIHRoZSB0ZW1wbGF0ZSwgYW5kIHJldHVybiB0aGUgcmVzcG9uc2UuICopXG5cbiAgaWYgbm90IGVycm9yLndpbGxfc2VuZF9yZXNwb25zZSB0aGVuXG4gICAgTHd0LnJldHVybl9ub25lXG5cbiAgZWxzZVxuICAgIGxldCBkZWJ1Z19kdW1wID0gZHVtcCBlcnJvciBpblxuXG4gICAgbGV0IHJlc3BvbnNlID1cbiAgICAgIG1hdGNoIGVycm9yLmNvbmRpdGlvbiB3aXRoXG4gICAgICB8IGBSZXNwb25zZSByZXNwb25zZSAtPiByZXNwb25zZVxuICAgICAgfCBfIC0+XG4gICAgICAgIGxldCBzdGF0dXMgPVxuICAgICAgICAgIG1hdGNoIGVycm9yLmNhdXNlZF9ieSB3aXRoXG4gICAgICAgICAgfCBgU2VydmVyIC0+IGBJbnRlcm5hbF9TZXJ2ZXJfRXJyb3JcbiAgICAgICAgICB8IGBDbGllbnQgLT4gYEJhZF9SZXF1ZXN0XG4gICAgICAgIGluXG4gICAgICAgIE1lc3NhZ2UucmVzcG9uc2UgfnN0YXR1cyBTdHJlYW0uZW1wdHkgU3RyZWFtLm51bGxcbiAgICBpblxuXG4gICAgKCogTm8gbmVlZCB0byBjYXRjaCBlcnJvcnMgd2hlbiBjYWxsaW5nIHRoZSB0ZW1wbGF0ZSwgYmVjYXVzZSBldmVyeSBjYWxsXG4gICAgICAgc2l0ZSBvZiB0aGUgZXJyb3IgaGFuZGxlciBhbHJlYWR5IGhhcyBlcnJvciBoYW5kbGVycyBmb3IgY2F0Y2hpbmcgZG91YmxlXG4gICAgICAgZmF1bHRzLiAqKVxuICAgIGxldCVsd3QgcmVzcG9uc2UgPSB0ZW1wbGF0ZSBlcnJvciBkZWJ1Z19kdW1wIHJlc3BvbnNlIGluXG4gICAgTHd0LnJldHVybiAoU29tZSByZXNwb25zZSlcblxuXG5cbmxldCBkZWZhdWx0X3RlbXBsYXRlIF9lcnJvciBfZGVidWdfZHVtcCByZXNwb25zZSA9XG4gIEx3dC5yZXR1cm4gcmVzcG9uc2VcblxubGV0IGRlYnVnX3RlbXBsYXRlIF9lcnJvciBkZWJ1Z19kdW1wIHJlc3BvbnNlID1cbiAgbGV0IHN0YXR1cyA9IE1lc3NhZ2Uuc3RhdHVzIHJlc3BvbnNlIGluXG4gIGxldCBjb2RlID0gU3RhdHVzLnN0YXR1c190b19pbnQgc3RhdHVzXG4gIGFuZCByZWFzb24gPSBTdGF0dXMuc3RhdHVzX3RvX3N0cmluZyBzdGF0dXMgaW5cbiAgTWVzc2FnZS5zZXRfaGVhZGVyIHJlc3BvbnNlIFwiQ29udGVudC1UeXBlXCIgRHJlYW1fcHVyZS5Gb3JtYXRzLnRleHRfaHRtbDtcbiAgTWVzc2FnZS5zZXRfYm9keSByZXNwb25zZSAoRXJyb3JfdGVtcGxhdGUucmVuZGVyIH5kZWJ1Z19kdW1wIH5jb2RlIH5yZWFzb24pO1xuICBMd3QucmV0dXJuIHJlc3BvbnNlXG5cbmxldCBkZWZhdWx0ID1cbiAgY3VzdG9taXplIGRlZmF1bHRfdGVtcGxhdGVcblxubGV0IGRlYnVnX2Vycm9yX2hhbmRsZXIgPVxuICBjdXN0b21pemUgZGVidWdfdGVtcGxhdGVcblxuXG5cbigqIEVycm9yIHJlcG9ydGVycyAoY2FsbGVkIGluIHZhcmlvdXMgcGxhY2VzIGJ5IHRoZSBmcmFtZXdvcmspLiAqKVxuXG5cblxubGV0IGRvdWJsZV9mYXVsdHMgZiBkZWZhdWx0ID1cbiAgTHd0LmNhdGNoIGYgYmVnaW4gZnVuIGV4biAtPlxuICAgIGxldCBiYWNrdHJhY2UgPSBQcmludGV4Yy5nZXRfYmFja3RyYWNlICgpIGluXG5cbiAgICBsb2cuZXJyb3IgKGZ1biBsb2cgLT5cbiAgICAgIGxvZyBcIkVycm9yIGhhbmRsZXIgcmFpc2VkOiAlc1wiIChQcmludGV4Yy50b19zdHJpbmcgZXhuKSk7XG5cbiAgICBiYWNrdHJhY2VcbiAgICB8PiBMb2cuaXRlcl9iYWNrdHJhY2UgKGZ1biBsaW5lIC0+XG4gICAgICBsb2cuZXJyb3IgKGZ1biBsb2cgLT4gbG9nIFwiJXNcIiBsaW5lKSk7XG5cbiAgICBkZWZhdWx0ICgpXG4gIGVuZFxuXG4oKiBJZiB0aGUgdXNlcidzIGhhbmRsZXIgZmFpbHMgdG8gcHJvdmlkZSBhIHJlc3BvbnNlLCByZXR1cm4gYW4gZW1wdHkgNTAwXG4gICByZXNwb25zZS4gRG9uJ3QgcmV0dXJuIHRoZSBvcmlnaW5hbCByZXNwb25zZSB3ZSBwYXNzZWQgdG8gdGhlIGVycm9yIGhhbmRsZXIsXG4gICBiZWNhdXNlIHRoZSBhcHAgbWF5IGhhdmUgYmVlbiB1c2luZyB0aGF0IHRvIGNvbW11bmljYXRlIHNvbWUgaW50ZXJuYWxcbiAgIGluZm9ybWF0aW9uIHRvIHRoZSBlcnJvciBoYW5kbGVyLiBOb3QgcmV0dXJuaW5nIGEgcmVzcG9uc2UgZnJvbSB0aGUgaGFuZGxlclxuICAgaXMgYSBwcm9ncmFtbWluZyBlcnJvciwgc28gaXQncyBwcm9iYWJseSBmaW5lIHRvIHJldHVybiBhIGdlbmVyaWMgc2VydmVyXG4gICBlcnJvci4gKilcbmxldCByZXNwb25kX3dpdGhfb3B0aW9uIGYgPVxuICBkb3VibGVfZmF1bHRzXG4gICAgKGZ1biAoKSAtPlxuICAgICAgZiAoKVxuICAgICAgfD4gTHd0Lm1hcCAoZnVuY3Rpb25cbiAgICAgICAgfCBTb21lIHJlc3BvbnNlIC0+IHJlc3BvbnNlXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIE1lc3NhZ2UucmVzcG9uc2VcbiAgICAgICAgICAgIH5zdGF0dXM6YEludGVybmFsX1NlcnZlcl9FcnJvciBTdHJlYW0uZW1wdHkgU3RyZWFtLm51bGwpKVxuICAgIChmdW4gKCkgLT5cbiAgICAgIE1lc3NhZ2UucmVzcG9uc2UgfnN0YXR1czpgSW50ZXJuYWxfU2VydmVyX0Vycm9yIFN0cmVhbS5lbXB0eSBTdHJlYW0ubnVsbFxuICAgICAgfD4gTHd0LnJldHVybilcblxuXG5cbigqIEluIHRoZSBmdW5jdGlvbnMgYmVsb3csIHRoZSBmaXJzdCByb3cgb3Igc2V0IG9mIGFyZ3VtZW50cyBjb21lcyBmcm9tIHRoZVxuICAgZnJhbWV3b3JrLCBieSBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgdGhlIHNlY29uZCByb3cgb3Igc2V0IChhZnRlciBcImZ1blwiKVxuICAgY29tZXMgZnJvbSB0aGUgc3RhdGUgbWFjaGluZSAoaHR0cC9hZiwgaDIsIHdlYnNvY2tldC9hZiwgb2NhbWwtdGxzLCBldGMuKSAqKVxuXG4oKiBUaGlzIGVycm9yIGhhbmRsZXIgYWN0dWFsbHkgKmlzKiBhIG1pZGRsZXdhcmUsIGJ1dCBpdCBpcyBqdXN0IG9uZSBwYXRod2F5IGZvclxuICAgcmVhY2hpbmcgdGhlIGNlbnRyYWxpemVkIGVycm9yIGhhbmRsZXIgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIHNvIGl0IGlzIGJ1aWx0XG4gICBpbnRvIHRoZSBmcmFtZXdvcmsuICopXG5cbmxldCBhcHBcbiAgICB1c2VyJ3NfZXJyb3JfaGFuZGxlciA9XG4gICAgZnVuIGVycm9yIC0+XG5cbiAgcmVzcG9uZF93aXRoX29wdGlvbiAoZnVuICgpIC0+IHVzZXInc19lcnJvcl9oYW5kbGVyIGVycm9yKVxuXG5cblxubGV0IGRlZmF1bHRfcmVzcG9uc2UgPSBmdW5jdGlvblxuICB8IGBTZXJ2ZXIgLT5cbiAgICBNZXNzYWdlLnJlc3BvbnNlIH5zdGF0dXM6YEludGVybmFsX1NlcnZlcl9FcnJvciBTdHJlYW0uZW1wdHkgU3RyZWFtLm51bGxcbiAgfCBgQ2xpZW50IC0+XG4gICAgTWVzc2FnZS5yZXNwb25zZSB+c3RhdHVzOmBCYWRfUmVxdWVzdCBTdHJlYW0uZW1wdHkgU3RyZWFtLm51bGxcblxubGV0IGh0dHBhZlxuICAgIHVzZXInc19lcnJvcl9oYW5kbGVyID1cbiAgICBmdW4gY2xpZW50X2FkZHJlc3MgP3JlcXVlc3QgZXJyb3Igc3RhcnRfcmVzcG9uc2UgLT5cblxuICBpZ25vcmUgKHJlcXVlc3QgOiBIdHRwYWYuUmVxdWVzdC50IG9wdGlvbik7XG4gICgqIFRPRE8gTEFURVIgU2hvdWxkIGZhY3RvciBvdXQgdGhlIHJlcXVlc3QgdHJhbnNsYXRpb24gZnVuY3Rpb24gYW5kIHVzZSBpdCB0b1xuICAgICBwYXJ0aWFsbHkgcmVjb3ZlciB0aGUgcmVxdWVzdCBpbmZvLiAqKVxuXG4gIGxldCBjb25kaXRpb24sIHNldmVyaXR5LCBjYXVzZWRfYnkgPVxuICAgIG1hdGNoIGVycm9yIHdpdGhcbiAgICB8IGBFeG4gZXhuIC0+XG4gICAgICBgRXhuIGV4bixcbiAgICAgIGBFcnJvcixcbiAgICAgIGBTZXJ2ZXJcblxuICAgIHwgYEJhZF9yZXF1ZXN0XG4gICAgfCBgQmFkX2dhdGV3YXkgLT5cbiAgICAgIGBTdHJpbmcgXCJCYWQgcmVxdWVzdFwiLFxuICAgICAgYFdhcm5pbmcsXG4gICAgICBgQ2xpZW50XG5cbiAgICB8IGBJbnRlcm5hbF9zZXJ2ZXJfZXJyb3IgLT5cbiAgICAgIGBTdHJpbmcgXCJDb250ZW50LUxlbmd0aCBtaXNzaW5nIG9yIG5lZ2F0aXZlXCIsXG4gICAgICBgRXJyb3IsXG4gICAgICBgU2VydmVyXG4gIGluXG5cbiAgbGV0IGVycm9yID0ge1xuICAgIENhdGNoLmNvbmRpdGlvbjtcbiAgICBsYXllciA9IGBIVFRQO1xuICAgIGNhdXNlZF9ieTtcbiAgICByZXF1ZXN0ID0gTm9uZTtcbiAgICByZXNwb25zZSA9IE5vbmU7XG4gICAgY2xpZW50ID0gU29tZSAoQWRhcHQuYWRkcmVzc190b19zdHJpbmcgY2xpZW50X2FkZHJlc3MpO1xuICAgIHNldmVyaXR5O1xuICAgIHdpbGxfc2VuZF9yZXNwb25zZSA9IHRydWU7XG4gIH0gaW5cblxuICBMd3QuYXN5bmMgYmVnaW4gZnVuICgpIC0+XG4gICAgZG91YmxlX2ZhdWx0cyBiZWdpbiBmdW4gKCkgLT5cbiAgICAgIGxldCVsd3QgcmVzcG9uc2UgPSB1c2VyJ3NfZXJyb3JfaGFuZGxlciBlcnJvciBpblxuXG4gICAgICBsZXQgcmVzcG9uc2UgPVxuICAgICAgICBtYXRjaCByZXNwb25zZSB3aXRoXG4gICAgICAgIHwgU29tZSByZXNwb25zZSAtPiByZXNwb25zZVxuICAgICAgICB8IE5vbmUgLT4gZGVmYXVsdF9yZXNwb25zZSBjYXVzZWRfYnlcbiAgICAgIGluXG5cbiAgICAgIGxldCBoZWFkZXJzID0gSHR0cGFmLkhlYWRlcnMub2ZfbGlzdCAoTWVzc2FnZS5hbGxfaGVhZGVycyByZXNwb25zZSkgaW5cbiAgICAgIGxldCBib2R5ID0gc3RhcnRfcmVzcG9uc2UgaGVhZGVycyBpblxuXG4gICAgICBBZGFwdC5mb3J3YXJkX2JvZHkgcmVzcG9uc2UgYm9keTtcblxuICAgICAgTHd0LnJldHVybl91bml0XG4gICAgZW5kXG4gICAgICBMd3QucmV0dXJuXG4gIGVuZFxuXG5cblxubGV0IGgyXG4gICAgdXNlcidzX2Vycm9yX2hhbmRsZXIgPVxuICAgIGZ1biBjbGllbnRfYWRkcmVzcyA/cmVxdWVzdCBlcnJvciBzdGFydF9yZXNwb25zZSAtPlxuXG4gIGlnbm9yZSByZXF1ZXN0OyAoKiBUT0RPIFJlY292ZXIgc29tZXRoaW5nIGZyb20gdGhlIHJlcXVlc3QuICopXG5cbiAgbGV0IGNvbmRpdGlvbiwgc2V2ZXJpdHksIGNhdXNlZF9ieSA9XG4gICAgbWF0Y2ggZXJyb3Igd2l0aFxuICAgIHwgYEV4biBleG4gLT5cbiAgICAgIGBFeG4gZXhuLFxuICAgICAgYEVycm9yLFxuICAgICAgYFNlcnZlclxuXG4gICAgfCBgQmFkX3JlcXVlc3QgLT5cbiAgICAgIGBTdHJpbmcgXCJCYWQgcmVxdWVzdFwiLFxuICAgICAgYFdhcm5pbmcsXG4gICAgICBgQ2xpZW50XG5cbiAgICB8IGBJbnRlcm5hbF9zZXJ2ZXJfZXJyb3IgLT5cbiAgICAgIGBTdHJpbmcgXCJDb250ZW50LUxlbmd0aCBtaXNzaW5nIG9yIG5lZ2F0aXZlXCIsXG4gICAgICBgRXJyb3IsXG4gICAgICBgU2VydmVyXG4gICAgICAoKiBUT0RPIExBVEVSIFdoZW4gZG9lcyBIMiByYWlzZSBgSW50ZXJuYWxfc2VydmVyX2Vycm9yPyAqKVxuICBpblxuXG4gIGxldCBlcnJvciA9IHtcbiAgICBDYXRjaC5jb25kaXRpb247XG4gICAgbGF5ZXIgPSBgSFRUUDI7XG4gICAgY2F1c2VkX2J5O1xuICAgIHJlcXVlc3QgPSBOb25lO1xuICAgIHJlc3BvbnNlID0gTm9uZTtcbiAgICBjbGllbnQgPSBTb21lIChBZGFwdC5hZGRyZXNzX3RvX3N0cmluZyBjbGllbnRfYWRkcmVzcyk7XG4gICAgc2V2ZXJpdHk7XG4gICAgd2lsbF9zZW5kX3Jlc3BvbnNlID0gdHJ1ZTtcbiAgfSBpblxuXG4gIEx3dC5hc3luYyBiZWdpbiBmdW4gKCkgLT5cbiAgICBkb3VibGVfZmF1bHRzIGJlZ2luIGZ1biAoKSAtPlxuICAgICAgbGV0JWx3dCByZXNwb25zZSA9IHVzZXInc19lcnJvcl9oYW5kbGVyIGVycm9yIGluXG5cbiAgICAgIGxldCByZXNwb25zZSA9XG4gICAgICAgIG1hdGNoIHJlc3BvbnNlIHdpdGhcbiAgICAgICAgfCBTb21lIHJlc3BvbnNlIC0+IHJlc3BvbnNlXG4gICAgICAgIHwgTm9uZSAtPiBkZWZhdWx0X3Jlc3BvbnNlIGNhdXNlZF9ieVxuICAgICAgaW5cblxuICAgICAgbGV0IGhlYWRlcnMgPSBIMi5IZWFkZXJzLm9mX2xpc3QgKE1lc3NhZ2UuYWxsX2hlYWRlcnMgcmVzcG9uc2UpIGluXG4gICAgICBsZXQgYm9keSA9IHN0YXJ0X3Jlc3BvbnNlIGhlYWRlcnMgaW5cblxuICAgICAgQWRhcHQuZm9yd2FyZF9ib2R5X2gyIHJlc3BvbnNlIGJvZHk7XG5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgIGVuZFxuICAgICAgTHd0LnJldHVyblxuICBlbmRcblxuXG5cbigqIFRoZSBwcm90b2NvbCBzdGF0ZSBtYWNoaW5lcyAoaHR0cC9hZiwgZXRjLikgdHJ5IHRvIHBhc3MgYWxsIGVycm9ycyBnZW5lcmF0ZWRcbiAgIGluc2lkZSB0aGVpciByZXF1ZXN0IGhhbmRsZXJzIHRvIHRoZWlyIG93biBlcnJvciBoYW5kbGVycy4gSW4gYWRkaXRpb24sIGFsbFxuICAgdXNlciBjb2RlIHJ1biBieSBEcmVhbSBpcyB3cmFwcGVkIGluIEx3dC5jYXRjaCB0byBjYXRjaCBhbGwgdXNlciBlcnJvcnMuXG4gICBIb3dldmVyLCBTU0wgcHJvdG9jb2wgZXJyb3JzIGFyZSBub3Qgd3JhcHBlZCBpbiBhbnkgb2YgdGhlc2UsIHNvIHdlIGFkZCBhblxuICAgZWRkaXRpb25hbCB0b3AtbGV2ZWwgaGFuZGxlciB0byBjYXRjaCB0aGVtLiAqKVxubGV0IHRsc1xuICAgIHVzZXInc19lcnJvcl9oYW5kbGVyIGNsaWVudF9hZGRyZXNzIGVycm9yID1cblxuICBsZXQgZXJyb3IgPSB7XG4gICAgQ2F0Y2guY29uZGl0aW9uID0gYEV4biBlcnJvcjtcbiAgICBsYXllciA9IGBUTFM7XG4gICAgY2F1c2VkX2J5ID0gYENsaWVudDtcbiAgICByZXF1ZXN0ID0gTm9uZTtcbiAgICByZXNwb25zZSA9IE5vbmU7XG4gICAgY2xpZW50ID0gU29tZSAoQWRhcHQuYWRkcmVzc190b19zdHJpbmcgY2xpZW50X2FkZHJlc3MpO1xuICAgIHNldmVyaXR5ID0gYFdhcm5pbmc7XG4gICAgd2lsbF9zZW5kX3Jlc3BvbnNlID0gZmFsc2U7XG4gIH0gaW5cblxuICBMd3QuYXN5bmMgKGZ1biAoKSAtPlxuICAgIGRvdWJsZV9mYXVsdHNcbiAgICAgIChmdW4gKCkgLT4gTHd0Lm1hcCBpZ25vcmUgKHVzZXInc19lcnJvcl9oYW5kbGVyIGVycm9yKSlcbiAgICAgIEx3dC5yZXR1cm4pXG5cblxuXG5sZXQgd2Vic29ja2V0XG4gICAgdXNlcidzX2Vycm9yX2hhbmRsZXIgcmVxdWVzdCByZXNwb25zZSA9XG4gICAgZnVuIHNvY2tldCBlcnJvciAtPlxuXG4gICgqIE5vdGU6IGluIHRoaXMgZnVuY3Rpb24sIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGFyZSBmcm9tIHRoZSBvcmlnaW5hbCByZXF1ZXN0XG4gICAgIHRoYXQgbmVnb3RpYXRlZCB0aGUgd2Vic29ja2V0LiAqKVxuXG4gIFdlYnNvY2tldGFmLldzZC5jbG9zZSBzb2NrZXQ7XG5cbiAgKCogVGhlIG9ubHkgY29uc3RydWN0b3Igb2YgZXJyb3IgaXMgYEV4biwgc28gcHJlc3VtYWJseSB0aGVzZSBhcmUgc2VydmVyLXNpZGVcbiAgICAgZXJyb3JzLiBOb3Qgc3VyZSBpZiBhbnkgSS9PIGVycm9ycyBhcmUgcG9zc2libGUgaGVyZS4gKilcbiAgbGV0IGBFeG4gZXhuID0gZXJyb3IgaW5cblxuICBsZXQgZXJyb3IgPSB7XG4gICAgQ2F0Y2guY29uZGl0aW9uID0gYEV4biBleG47XG4gICAgbGF5ZXIgPSBgV2ViU29ja2V0O1xuICAgIGNhdXNlZF9ieSA9IGBTZXJ2ZXI7XG4gICAgcmVxdWVzdCA9IFNvbWUgcmVxdWVzdDtcbiAgICByZXNwb25zZSA9IFNvbWUgcmVzcG9uc2U7XG4gICAgY2xpZW50ID0gU29tZSAoSGVscGVycy5jbGllbnQgcmVxdWVzdCk7XG4gICAgc2V2ZXJpdHkgPSBgV2FybmluZzsgICAoKiBOb3Qgc3VyZSB3aGF0IHRoZXNlIGVycm9ycyBhcmUsIHlldC4gKilcbiAgICB3aWxsX3NlbmRfcmVzcG9uc2UgPSBmYWxzZTtcbiAgfSBpblxuXG4gIEx3dC5hc3luYyAoZnVuICgpIC0+XG4gICAgZG91YmxlX2ZhdWx0c1xuICAgICAgKGZ1biAoKSAtPiBMd3QubWFwIGlnbm9yZSAodXNlcidzX2Vycm9yX2hhbmRsZXIgZXJyb3IpKVxuICAgICAgTHd0LnJldHVybilcblxuXG5cbmxldCB3ZWJzb2NrZXRfaGFuZHNoYWtlXG4gICAgdXNlcidzX2Vycm9yX2hhbmRsZXIgPVxuICAgIGZ1biByZXF1ZXN0IHJlc3BvbnNlIGVycm9yX3N0cmluZyAtPlxuXG4gIGxldCBlcnJvciA9IHtcbiAgICBDYXRjaC5jb25kaXRpb24gPSBgU3RyaW5nIGVycm9yX3N0cmluZztcbiAgICBsYXllciA9IGBXZWJTb2NrZXQ7XG4gICAgY2F1c2VkX2J5ID0gYENsaWVudDtcbiAgICByZXF1ZXN0ID0gU29tZSByZXF1ZXN0O1xuICAgIHJlc3BvbnNlID0gU29tZSByZXNwb25zZTtcbiAgICBjbGllbnQgPSBTb21lIChIZWxwZXJzLmNsaWVudCByZXF1ZXN0KTtcbiAgICBzZXZlcml0eSA9IGBXYXJuaW5nO1xuICAgIHdpbGxfc2VuZF9yZXNwb25zZSA9IHRydWU7XG4gIH0gaW5cblxuICByZXNwb25kX3dpdGhfb3B0aW9uIChmdW4gKCkgLT4gdXNlcidzX2Vycm9yX2hhbmRsZXIgZXJyb3IpXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBEcmVhbSwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZFxuICAgZm9yIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9hYW50cm9uL2RyZWFtLlxuXG4gICBDb3B5cmlnaHQgMjAyMSBBbnRvbiBCYWNoaW4gKilcblxuXG5cbm1vZHVsZSBHbHV0ZW4gPSBEcmVhbV9nbHV0ZW4uR2x1dGVuXG5tb2R1bGUgR2x1dGVuX2x3dF91bml4ID0gRHJlYW1fZ2x1dGVuX2x3dF91bml4LkdsdXRlbl9sd3RfdW5peFxubW9kdWxlIEh0dHBhZiA9IERyZWFtX2h0dHBhZl8uSHR0cGFmXG5tb2R1bGUgSHR0cGFmX2x3dF91bml4ID0gRHJlYW1faHR0cGFmX19sd3RfdW5peC5IdHRwYWZfbHd0X3VuaXhcbm1vZHVsZSBIMiA9IERyZWFtX2gyLkgyXG5tb2R1bGUgSDJfbHd0X3VuaXggPSBEcmVhbV9oMl9sd3RfdW5peC5IMl9sd3RfdW5peFxubW9kdWxlIFdlYnNvY2tldGFmID0gRHJlYW1fd2Vic29ja2V0YWYuV2Vic29ja2V0YWZcblxubW9kdWxlIENhdGNoID0gRHJlYW1fX3NlcnZlci5DYXRjaFxubW9kdWxlIEhlbHBlcnMgPSBEcmVhbV9fc2VydmVyLkhlbHBlcnNcbm1vZHVsZSBMb2cgPSBEcmVhbV9fc2VydmVyLkxvZ1xubW9kdWxlIE1lc3NhZ2UgPSBEcmVhbV9wdXJlLk1lc3NhZ2Vcbm1vZHVsZSBNZXRob2QgPSBEcmVhbV9wdXJlLk1ldGhvZFxubW9kdWxlIFN0YXR1cyA9IERyZWFtX3B1cmUuU3RhdHVzXG5tb2R1bGUgU3RyZWFtID0gRHJlYW1fcHVyZS5TdHJlYW1cblxuXG5cbigqIFRPRE8gSW4gc2VyaW91cyBuZWVkIG9mIHJlZmFjdG9yaW5nIGJlY2F1c2Ugb2YgYWxsIHRoZSBkaWZmZXJlbnQgaGFuZGxlcnMuICopXG5cblxuXG5sZXQgdG9fZHJlYW1fbWV0aG9kIG1ldGhvZF8gPVxuICBIdHRwYWYuTWV0aG9kLnRvX3N0cmluZyBtZXRob2RfIHw+IE1ldGhvZC5zdHJpbmdfdG9fbWV0aG9kXG5cbmxldCB0b19odHRwYWZfc3RhdHVzIHN0YXR1cyA9XG4gIFN0YXR1cy5zdGF0dXNfdG9faW50IHN0YXR1cyB8PiBIdHRwYWYuU3RhdHVzLm9mX2NvZGVcblxubGV0IHRvX2gyX3N0YXR1cyBzdGF0dXMgPVxuICBTdGF0dXMuc3RhdHVzX3RvX2ludCBzdGF0dXMgfD4gSDIuU3RhdHVzLm9mX2NvZGVcblxubGV0IHNoYTEgcyA9XG4gIHNcbiAgfD4gRGlnZXN0aWYuU0hBMS5kaWdlc3Rfc3RyaW5nXG4gIHw+IERpZ2VzdGlmLlNIQTEudG9fcmF3X3N0cmluZ1xuXG5sZXQgd2Vic29ja2V0X2xvZyA9XG4gIExvZy5zdWJfbG9nIFwiZHJlYW0ud2Vic29ja2V0XCJcblxuXG5cbigqIFdyYXBzIHRoZSB1c2VyJ3MgRHJlYW0gaGFuZGxlciBpbiB0aGUga2luZCBvZiBoYW5kbGVyIGV4cGVjdGVkIGJ5IGh0dHAvYWYuXG4gICBUaGUgc2NoZW1lIGlzIHNpbXBsZTogd2FpdCBmb3IgaHR0cC9hZiBcIlJlcWQudFwicyAocGFydGlhbGx5IHBhcnNlZFxuICAgY29ubmVjdGlvbnMpLCBjb252ZXJ0IHRoZWlyIGZpZWxkcyB0byBEcmVhbS5yZXF1ZXN0LCBjYWxsIHRoZSB1c2VyJ3MgaGFuZGxlcixcbiAgIHdhaXQgZm9yIHRoZSBEcmVhbS5yZXNwb25zZSwgYW5kIHRoZW4gY29udmVydCBpdCB0byBhbiBodHRwL2FmIFJlc3BvbnNlIGFuZFxuICAgc25lZCBpdC5cblxuICAgSWYgdGhlIHVzZXIncyBoYW5kbGVyICh3cm9uZ2x5KSBsZWFrcyBhbnkgZXhjZXB0aW9ucyBvciByZWplY3Rpb25zLCB0aGV5IGFyZVxuICAgcGFzc2VkIHRvIGh0dHAvYWYgdG8gZW5kIHVwIGluIHRoZSBlcnJvciBoYW5kbGVyLiBUaGlzIGlzIGEgbG93LWxldmVsIGhhbmRsZXJcbiAgIHRoYXQgb3JkaW5hcmlseSBzaG91bGRuJ3QgYmUgcmVsaWVkIG9uIGJ5IHRoZSB1c2VyIC0gdGhpcyBpcyBqdXN0IG91ciBsYXN0XG4gICBjaGFuY2UgdG8gdGVsbCB0aGUgdXNlciB0aGF0IHNvbWV0aGluZyBpcyB3cm9uZyB3aXRoIHRoZWlyIGFwcC4gKilcbigqIFRPRE8gUmVuYW1lIGNvbm4gbGlrZSBpbiB0aGUgYm9keSBicmFuY2guICopXG5sZXQgd3JhcF9oYW5kbGVyXG4gICAgdGxzXG4gICAgKHVzZXInc19lcnJvcl9oYW5kbGVyIDogQ2F0Y2guZXJyb3JfaGFuZGxlcilcbiAgICAodXNlcidzX2RyZWFtX2hhbmRsZXIgOiBNZXNzYWdlLmhhbmRsZXIpID1cblxuICBsZXQgaHR0cGFmX3JlcXVlc3RfaGFuZGxlciA9IGZ1biBjbGllbnRfYWRkcmVzcyAoY29ubiA6IF8gR2x1dGVuLlJlcWQudCkgLT5cbiAgICBMb2cuc2V0X3VwX2V4Y2VwdGlvbl9ob29rICgpO1xuXG4gICAgbGV0IGNvbm4sIHVwZ3JhZGUgPSBjb25uLnJlcWQsIGNvbm4udXBncmFkZSBpblxuXG4gICAgKCogQ292ZXJ0IHRoZSBodHRwL2FmIHJlcXVlc3QgdG8gYSBEcmVhbSByZXF1ZXN0LiAqKVxuICAgIGxldCBodHRwYWZfcmVxdWVzdCA6IEh0dHBhZi5SZXF1ZXN0LnQgPVxuICAgICAgSHR0cGFmLlJlcWQucmVxdWVzdCBjb25uIGluXG5cbiAgICBsZXQgY2xpZW50ID1cbiAgICAgIEFkYXB0LmFkZHJlc3NfdG9fc3RyaW5nIGNsaWVudF9hZGRyZXNzIGluXG4gICAgbGV0IG1ldGhvZF8gPVxuICAgICAgdG9fZHJlYW1fbWV0aG9kIGh0dHBhZl9yZXF1ZXN0Lm1ldGggaW5cbiAgICBsZXQgdGFyZ2V0ID1cbiAgICAgIGh0dHBhZl9yZXF1ZXN0LnRhcmdldCBpblxuICAgIGxldCBoZWFkZXJzID1cbiAgICAgIEh0dHBhZi5IZWFkZXJzLnRvX2xpc3QgaHR0cGFmX3JlcXVlc3QuaGVhZGVycyBpblxuXG4gICAgbGV0IGJvZHkgPVxuICAgICAgSHR0cGFmLlJlcWQucmVxdWVzdF9ib2R5IGNvbm4gaW5cbiAgICAoKiBUT0RPIFJldmlldyBwZXItY2h1bmsgYWxsb2NhdGlvbnMuICopXG4gICAgKCogVE9ETyBTaG91bGQgdGhlIHN0cmVhbSBiZSBhdXRvLWNsb3NlZD8gSXQgZG9lc24ndCBldmVuIGhhdmUgYSBjbG9zZWRcbiAgICAgICBzdGF0ZS4gVGhlIHdob2xlIHRoaW5nIGlzIGp1c3QgYSB3cmFwcGVyIGZvciB3aGF0ZXZlciB0aGUgaHR0cC9hZlxuICAgICAgIGJlaGF2aW9yIGlzLiAqKVxuICAgIGxldCByZWFkIH5kYXRhIH5mbHVzaDpfIH5waW5nOl8gfnBvbmc6XyB+Y2xvc2UgfmV4bjpfID1cbiAgICAgIEh0dHBhZi5Cb2R5LlJlYWRlci5zY2hlZHVsZV9yZWFkXG4gICAgICAgIGJvZHlcbiAgICAgICAgfm9uX2VvZjooZnVuICgpIC0+IGNsb3NlIDEwMDApXG4gICAgICAgIH5vbl9yZWFkOihmdW4gYnVmZmVyIH5vZmYgfmxlbiAtPiBkYXRhIGJ1ZmZlciBvZmYgbGVuIHRydWUgZmFsc2UpXG4gICAgaW5cbiAgICBsZXQgY2xvc2UgX2NvZGUgPVxuICAgICAgSHR0cGFmLkJvZHkuUmVhZGVyLmNsb3NlIGJvZHkgaW5cbiAgICBsZXQgYm9keSA9XG4gICAgICBTdHJlYW0ucmVhZGVyIH5yZWFkIH5jbG9zZSB+YWJvcnQ6Y2xvc2UgaW5cbiAgICBsZXQgYm9keSA9XG4gICAgICBTdHJlYW0uc3RyZWFtIGJvZHkgU3RyZWFtLm5vX3dyaXRlciBpblxuXG4gICAgbGV0IHJlcXVlc3QgOiBNZXNzYWdlLnJlcXVlc3QgPVxuICAgICAgSGVscGVycy5yZXF1ZXN0IH5jbGllbnQgfm1ldGhvZF8gfnRhcmdldCB+dGxzIH5oZWFkZXJzIGJvZHkgaW5cblxuICAgICgqIENhbGwgdGhlIHVzZXIncyBoYW5kbGVyLiBJZiBpdCByYWlzZXMgYW4gZXhjZXB0aW9uIG9yIHJldHVybnMgYSBwcm9taXNlXG4gICAgICAgdGhhdCByZWplY3RzIHdpdGggYW4gZXhjZXB0aW9uLCBwYXNzIHRoZSBleGNlcHRpb24gdXAgdG8gSHR0cGFmLiBUaGlzXG4gICAgICAgd2lsbCBjYXVzZSBpdCB0byBjYWxsIGl0cyAobG93LWxldmVsKSBlcnJvciBoYW5kbGVyIHdpdGggdmFyaWFuZCBgRXhuIF8uXG4gICAgICAgQSB3ZWxsLWJlaGF2ZWQgRHJlYW0gYXBwIHNob3VsZCBjYXRjaCBhbGwgb2YgaXRzIG93biBleGNlcHRpb25zIGFuZFxuICAgICAgIHJlamVjdGlvbnMgaW4gb25lIG9mIGl0cyB0b3AtbGV2ZWwgbWlkZGxld2FyZXMuXG5cbiAgICAgICBXZSBkb24ndCB0cnkgdG8gbG9nIGV4Y2VwdGlvbnMgaGVyZSBiZWNhdXNlIHRoZSBiZWhhdmlvciBpcyBub3RcbiAgICAgICBjdXN0b21pemFibGUgaGVyZS4gVGhlIGhhbmRsZXIgaXRzZWxmIGlzIGN1c3RvbWl6YWJsZSAodG8gY2F0Y2ggYWxsKVxuICAgICAgIGV4Y2VwdGlvbnMsIGFuZCB0aGUgZXJyb3IgY2FsbGJhY2sgdGhhdCBnZXRzIGxlYWtlZCBleGNlcHRpb25zIGlzIGFsc29cbiAgICAgICBjdXN0b21pemFibGUuICopXG4gICAgTHd0LmFzeW5jIGJlZ2luIGZ1biAoKSAtPlxuICAgICAgTHd0LmNhdGNoIGJlZ2luIGZ1biAoKSAtPlxuICAgICAgICAoKiBEbyB0aGUgYmlnIGNhbGwuICopXG4gICAgICAgIGxldCVsd3QgcmVzcG9uc2UgPSB1c2VyJ3NfZHJlYW1faGFuZGxlciByZXF1ZXN0IGluXG5cbiAgICAgICAgKCogRXh0cmFjdCB0aGUgRHJlYW0gcmVzcG9uc2UncyBoZWFkZXJzLiAqKVxuXG4gICAgICAgICgqIFRoaXMgaXMgdGhlIGRlZmF1bHQgZnVuY3Rpb24gdGhhdCB0cmFuc2xhdGVzIHRoZSBEcmVhbSByZXNwb25zZSB0byBhblxuICAgICAgICAgICBodHRwL2FmIHJlc3BvbnNlIGFuZCBzZW5kcyBpdC4gV2UgcHJlLWRlZmluZSB0aGUgZnVuY3Rpb24sIGhvd2V2ZXIsXG4gICAgICAgICAgIGJlY2F1c2UgaXQgaXMgY2FsbGVkIGZyb20gdHdvIHBsYWNlczpcblxuICAgICAgICAgICAxLiBVcG9uIGEgbm9ybWFsIHJlc3BvbnNlLCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHVuY29uZGl0aW9uYWxseS5cbiAgICAgICAgICAgMi4gVXBvbiBmYWlsdXJlIHRvIGVzdGFibGlzaCBhIFdlYlNvY2tldCwgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCB0b1xuICAgICAgICAgICAgICB0cmFuc21pdCB0aGUgcmVzdWx0aW5nIGVycm9yIHJlc3BvbnNlLiAqKVxuICAgICAgICBsZXQgZm9yd2FyZF9yZXNwb25zZSByZXNwb25zZSA9XG4gICAgICAgICAgTWVzc2FnZS5zZXRfY29udGVudF9sZW5ndGhfaGVhZGVycyByZXNwb25zZTtcblxuICAgICAgICAgIGxldCBoZWFkZXJzID1cbiAgICAgICAgICAgIEh0dHBhZi5IZWFkZXJzLm9mX2xpc3QgKE1lc3NhZ2UuYWxsX2hlYWRlcnMgcmVzcG9uc2UpIGluXG5cbiAgICAgICAgICBsZXQgc3RhdHVzID1cbiAgICAgICAgICAgIHRvX2h0dHBhZl9zdGF0dXMgKE1lc3NhZ2Uuc3RhdHVzIHJlc3BvbnNlKSBpblxuXG4gICAgICAgICAgbGV0IGh0dHBhZl9yZXNwb25zZSA9XG4gICAgICAgICAgICBIdHRwYWYuUmVzcG9uc2UuY3JlYXRlIH5oZWFkZXJzIHN0YXR1cyBpblxuICAgICAgICAgIGxldCBib2R5ID1cbiAgICAgICAgICAgIEh0dHBhZi5SZXFkLnJlc3BvbmRfd2l0aF9zdHJlYW1pbmcgY29ubiBodHRwYWZfcmVzcG9uc2UgaW5cblxuICAgICAgICAgIEFkYXB0LmZvcndhcmRfYm9keSByZXNwb25zZSBib2R5O1xuXG4gICAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgICAgIGluXG5cbiAgICAgICAgbWF0Y2ggTWVzc2FnZS5nZXRfd2Vic29ja2V0IHJlc3BvbnNlIHdpdGhcbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgZm9yd2FyZF9yZXNwb25zZSByZXNwb25zZVxuICAgICAgICB8IFNvbWUgKGNsaWVudF9zdHJlYW0sIF9zZXJ2ZXJfc3RyZWFtKSAtPlxuICAgICAgICAgIGxldCBlcnJvcl9oYW5kbGVyID1cbiAgICAgICAgICAgIEVycm9yX2hhbmRsZXIud2Vic29ja2V0IHVzZXInc19lcnJvcl9oYW5kbGVyIHJlcXVlc3QgcmVzcG9uc2UgaW5cblxuICAgICAgICAgIGxldCBwcm9jZWVkICgpID1cbiAgICAgICAgICAgIFdlYnNvY2tldGFmLlNlcnZlcl9jb25uZWN0aW9uLmNyZWF0ZV93ZWJzb2NrZXRcbiAgICAgICAgICAgICAgfmVycm9yX2hhbmRsZXJcbiAgICAgICAgICAgICAgKERyZWFtX2h0dHBhZi5XZWJzb2NrZXQud2Vic29ja2V0X2hhbmRsZXIgY2xpZW50X3N0cmVhbSlcbiAgICAgICAgICAgIHw+IEdsdXRlbi5tYWtlIChtb2R1bGUgV2Vic29ja2V0YWYuU2VydmVyX2Nvbm5lY3Rpb24pXG4gICAgICAgICAgICB8PiB1cGdyYWRlXG4gICAgICAgICAgaW5cblxuICAgICAgICAgIGxldCBoZWFkZXJzID1cbiAgICAgICAgICAgIEh0dHBhZi5IZWFkZXJzLm9mX2xpc3QgKE1lc3NhZ2UuYWxsX2hlYWRlcnMgcmVzcG9uc2UpIGluXG5cbiAgICAgICAgICBXZWJzb2NrZXRhZi5IYW5kc2hha2UucmVzcG9uZF93aXRoX3VwZ3JhZGUgfmhlYWRlcnMgfnNoYTEgY29ubiBwcm9jZWVkXG4gICAgICAgICAgfD4gZnVuY3Rpb25cbiAgICAgICAgICB8IE9rICgpIC0+IEx3dC5yZXR1cm5fdW5pdFxuICAgICAgICAgIHwgRXJyb3IgZXJyb3Jfc3RyaW5nIC0+XG4gICAgICAgICAgICBsZXQlbHd0IHJlc3BvbnNlID1cbiAgICAgICAgICAgICAgRXJyb3JfaGFuZGxlci53ZWJzb2NrZXRfaGFuZHNoYWtlXG4gICAgICAgICAgICAgICAgdXNlcidzX2Vycm9yX2hhbmRsZXIgcmVxdWVzdCByZXNwb25zZSBlcnJvcl9zdHJpbmdcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBmb3J3YXJkX3Jlc3BvbnNlIHJlc3BvbnNlXG4gICAgICBlbmRcbiAgICAgIEBAIGZ1biBleG4gLT5cbiAgICAgICAgKCogVE9ETyBUaGVyZSB3YXMgc29tZXRoaW5nIGluIHRoZSBmb3JrIGNoYW5nZWxvZ3MgYWJvdXQgbm90IHJlcXVpcmluZ1xuICAgICAgICAgICByZXBvcnQgZXhuLiBJcyBpdCByZWxldmFudCB0byB0aGlzPyAqKVxuICAgICAgICBIdHRwYWYuUmVxZC5yZXBvcnRfZXhuIGNvbm4gZXhuO1xuICAgICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICBlbmRcbiAgaW5cblxuICBodHRwYWZfcmVxdWVzdF9oYW5kbGVyXG5cblxuXG4oKiBUT0RPIEZhY3RvciBvdXQgd2hhdCBpcyBpbiBjb21tb24gYmV0d2VlbiB0aGUgaHR0cC9hZiBhbmQgaDIgaGFuZGxlcnMuICopXG5sZXQgd3JhcF9oYW5kbGVyX2gyXG4gICAgdGxzXG4gICAgKF91c2VyJ3NfZXJyb3JfaGFuZGxlciA6IENhdGNoLmVycm9yX2hhbmRsZXIpXG4gICAgKHVzZXInc19kcmVhbV9oYW5kbGVyIDogTWVzc2FnZS5oYW5kbGVyKSA9XG5cbiAgbGV0IGh0dHBhZl9yZXF1ZXN0X2hhbmRsZXIgPSBmdW4gY2xpZW50X2FkZHJlc3MgKGNvbm4gOiBIMi5SZXFkLnQpIC0+XG4gICAgTG9nLnNldF91cF9leGNlcHRpb25faG9vayAoKTtcblxuICAgICgqIENvdmVydCB0aGUgaDIgcmVxdWVzdCB0byBhIERyZWFtIHJlcXVlc3QuICopXG4gICAgbGV0IGh0dHBhZl9yZXF1ZXN0IDogSDIuUmVxdWVzdC50ID1cbiAgICAgIEgyLlJlcWQucmVxdWVzdCBjb25uIGluXG5cbiAgICBsZXQgY2xpZW50ID1cbiAgICAgIEFkYXB0LmFkZHJlc3NfdG9fc3RyaW5nIGNsaWVudF9hZGRyZXNzIGluXG4gICAgbGV0IG1ldGhvZF8gPVxuICAgICAgdG9fZHJlYW1fbWV0aG9kIGh0dHBhZl9yZXF1ZXN0Lm1ldGggaW5cbiAgICBsZXQgdGFyZ2V0ID1cbiAgICAgIGh0dHBhZl9yZXF1ZXN0LnRhcmdldCBpblxuICAgIGxldCBoZWFkZXJzID1cbiAgICAgIEgyLkhlYWRlcnMudG9fbGlzdCBodHRwYWZfcmVxdWVzdC5oZWFkZXJzIGluXG5cbiAgICBsZXQgYm9keSA9XG4gICAgICBIMi5SZXFkLnJlcXVlc3RfYm9keSBjb25uIGluXG4gICAgbGV0IHJlYWQgfmRhdGEgfmZsdXNoOl8gfnBpbmc6XyB+cG9uZzpfIH5jbG9zZSB+ZXhuOl8gPVxuICAgICAgSDIuQm9keS5SZWFkZXIuc2NoZWR1bGVfcmVhZFxuICAgICAgICBib2R5XG4gICAgICAgIH5vbl9lb2Y6KGZ1biAoKSAtPiBjbG9zZSAxMDAwKVxuICAgICAgICB+b25fcmVhZDooZnVuIGJ1ZmZlciB+b2ZmIH5sZW4gLT4gZGF0YSBidWZmZXIgb2ZmIGxlbiB0cnVlIGZhbHNlKVxuICAgIGluXG4gICAgbGV0IGNsb3NlIF9jb2RlID1cbiAgICAgIEgyLkJvZHkuUmVhZGVyLmNsb3NlIGJvZHkgaW5cbiAgICBsZXQgYm9keSA9XG4gICAgICBTdHJlYW0ucmVhZGVyIH5yZWFkIH5jbG9zZSB+YWJvcnQ6Y2xvc2UgaW5cbiAgICBsZXQgYm9keSA9XG4gICAgICBTdHJlYW0uc3RyZWFtIGJvZHkgU3RyZWFtLm5vX3dyaXRlciBpblxuXG4gICAgbGV0IHJlcXVlc3QgOiBNZXNzYWdlLnJlcXVlc3QgPVxuICAgICAgSGVscGVycy5yZXF1ZXN0IH5jbGllbnQgfm1ldGhvZF8gfnRhcmdldCB+dGxzIH5oZWFkZXJzIGJvZHkgaW5cblxuICAgICgqIENhbGwgdGhlIHVzZXIncyBoYW5kbGVyLiBJZiBpdCByYWlzZXMgYW4gZXhjZXB0aW9uIG9yIHJldHVybnMgYSBwcm9taXNlXG4gICAgICAgdGhhdCByZWplY3RzIHdpdGggYW4gZXhjZXB0aW9uLCBwYXNzIHRoZSBleGNlcHRpb24gdXAgdG8gSHR0cGFmLiBUaGlzXG4gICAgICAgd2lsbCBjYXVzZSBpdCB0byBjYWxsIGl0cyAobG93LWxldmVsKSBlcnJvciBoYW5kbGVyIHdpdGggdmFyaWFuZCBgRXhuIF8uXG4gICAgICAgQSB3ZWxsLWJlaGF2ZWQgRHJlYW0gYXBwIHNob3VsZCBjYXRjaCBhbGwgb2YgaXRzIG93biBleGNlcHRpb25zIGFuZFxuICAgICAgIHJlamVjdGlvbnMgaW4gb25lIG9mIGl0cyB0b3AtbGV2ZWwgbWlkZGxld2FyZXMuXG5cbiAgICAgICBXZSBkb24ndCB0cnkgdG8gbG9nIGV4Y2VwdGlvbnMgaGVyZSBiZWNhdXNlIHRoZSBiZWhhdmlvciBpcyBub3RcbiAgICAgICBjdXN0b21pemFibGUgaGVyZS4gVGhlIGhhbmRsZXIgaXRzZWxmIGlzIGN1c3RvbWl6YWJsZSAodG8gY2F0Y2ggYWxsKVxuICAgICAgIGV4Y2VwdGlvbnMsIGFuZCB0aGUgZXJyb3IgY2FsbGJhY2sgdGhhdCBnZXRzIGxlYWtlZCBleGNlcHRpb25zIGlzIGFsc29cbiAgICAgICBjdXN0b21pemFibGUuICopXG4gICAgTHd0LmFzeW5jIGJlZ2luIGZ1biAoKSAtPlxuICAgICAgTHd0LmNhdGNoIGJlZ2luIGZ1biAoKSAtPlxuICAgICAgICAoKiBEbyB0aGUgYmlnIGNhbGwuICopXG4gICAgICAgIGxldCVsd3QgcmVzcG9uc2UgPSB1c2VyJ3NfZHJlYW1faGFuZGxlciByZXF1ZXN0IGluXG5cbiAgICAgICAgKCogRXh0cmFjdCB0aGUgRHJlYW0gcmVzcG9uc2UncyBoZWFkZXJzLiAqKVxuXG4gICAgICAgIGxldCBmb3J3YXJkX3Jlc3BvbnNlIHJlc3BvbnNlID1cbiAgICAgICAgICBNZXNzYWdlLmRyb3BfY29udGVudF9sZW5ndGhfaGVhZGVycyByZXNwb25zZTtcbiAgICAgICAgICBNZXNzYWdlLmxvd2VyY2FzZV9oZWFkZXJzIHJlc3BvbnNlO1xuICAgICAgICAgIGxldCBoZWFkZXJzID1cbiAgICAgICAgICAgIEgyLkhlYWRlcnMub2ZfbGlzdCAoTWVzc2FnZS5hbGxfaGVhZGVycyByZXNwb25zZSkgaW5cbiAgICAgICAgICBsZXQgc3RhdHVzID1cbiAgICAgICAgICAgIHRvX2gyX3N0YXR1cyAoTWVzc2FnZS5zdGF0dXMgcmVzcG9uc2UpIGluXG4gICAgICAgICAgbGV0IGgyX3Jlc3BvbnNlID1cbiAgICAgICAgICAgIEgyLlJlc3BvbnNlLmNyZWF0ZSB+aGVhZGVycyBzdGF0dXMgaW5cbiAgICAgICAgICBsZXQgYm9keSA9XG4gICAgICAgICAgICBIMi5SZXFkLnJlc3BvbmRfd2l0aF9zdHJlYW1pbmcgY29ubiBoMl9yZXNwb25zZSBpblxuXG4gICAgICAgICAgQWRhcHQuZm9yd2FyZF9ib2R5X2gyIHJlc3BvbnNlIGJvZHk7XG5cbiAgICAgICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICAgICAgaW5cblxuICAgICAgICBtYXRjaCBNZXNzYWdlLmdldF93ZWJzb2NrZXQgcmVzcG9uc2Ugd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBmb3J3YXJkX3Jlc3BvbnNlIHJlc3BvbnNlXG4gICAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICgqIFRPRE8gRE9DIEgyIGFwcGVhcnMgbm90IHRvIHN1cHBvcnQgV2ViU29ja2V0IHVwZ3JhZGUgYXQgcHJlc2VudC5cbiAgICAgICAgICAgUkZDIDg0NDEuICopXG4gICAgICAgICgqIFRPRE8gRE9DIERvIHdlIG5lZWQgYSBDT05ORUNUIG1ldGhvZD8gRG8gdXNlcnMgbmVlZCB0byBiZSBpbmZvcm1lZCBvZlxuICAgICAgICAgICB0aGlzPyAqKVxuICAgICAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgICAgZW5kXG4gICAgICBAQCBmdW4gZXhuIC0+XG4gICAgICAgICgqIFRPRE8gTEFURVIgVGhlcmUgd2FzIHNvbWV0aGluZyBpbiB0aGUgZm9yayBjaGFuZ2Vsb2dzIGFib3V0IG5vdFxuICAgICAgICAgICByZXF1aXJpbmcgcmVwb3J0X2V4bi4gSXMgaXQgcmVsZXZhbnQgdG8gdGhpcz8gKilcbiAgICAgICAgSDIuUmVxZC5yZXBvcnRfZXhuIGNvbm4gZXhuO1xuICAgICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICBlbmRcbiAgaW5cblxuICBodHRwYWZfcmVxdWVzdF9oYW5kbGVyXG5cblxuXG5sZXQgbG9nID1cbiAgRXJyb3JfaGFuZGxlci5sb2dcblxuXG5cbnR5cGUgdGxzX2xpYnJhcnkgPSB7XG4gIGNyZWF0ZV9oYW5kbGVyIDpcbiAgICBjZXJ0aWZpY2F0ZV9maWxlOnN0cmluZyAtPlxuICAgIGtleV9maWxlOnN0cmluZyAtPlxuICAgIGhhbmRsZXI6TWVzc2FnZS5oYW5kbGVyIC0+XG4gICAgZXJyb3JfaGFuZGxlcjpDYXRjaC5lcnJvcl9oYW5kbGVyIC0+XG4gICAgICBVbml4LnNvY2thZGRyIC0+XG4gICAgICBMd3RfdW5peC5maWxlX2Rlc2NyIC0+XG4gICAgICAgIHVuaXQgTHd0LnQ7XG59XG5cbmxldCBub190bHMgPSB7XG4gIGNyZWF0ZV9oYW5kbGVyID0gYmVnaW4gZnVuXG4gICAgICB+Y2VydGlmaWNhdGVfZmlsZTpfIH5rZXlfZmlsZTpfXG4gICAgICB+aGFuZGxlclxuICAgICAgfmVycm9yX2hhbmRsZXIgLT5cbiAgICBIdHRwYWZfbHd0X3VuaXguU2VydmVyLmNyZWF0ZV9jb25uZWN0aW9uX2hhbmRsZXJcbiAgICAgID9jb25maWc6Tm9uZVxuICAgICAgfnJlcXVlc3RfaGFuZGxlcjood3JhcF9oYW5kbGVyIGZhbHNlIGVycm9yX2hhbmRsZXIgaGFuZGxlcilcbiAgICAgIH5lcnJvcl9oYW5kbGVyOihFcnJvcl9oYW5kbGVyLmh0dHBhZiBlcnJvcl9oYW5kbGVyKVxuICBlbmQ7XG59XG5cbmxldCBvcGVuc3NsID0ge1xuICBjcmVhdGVfaGFuZGxlciA9IGJlZ2luIGZ1blxuICAgICAgfmNlcnRpZmljYXRlX2ZpbGUgfmtleV9maWxlXG4gICAgICB+aGFuZGxlclxuICAgICAgfmVycm9yX2hhbmRsZXIgLT5cblxuICAgIGxldCBodHRwYWZfaGFuZGxlciA9XG4gICAgICBIdHRwYWZfbHd0X3VuaXguU2VydmVyLlNTTC5jcmVhdGVfY29ubmVjdGlvbl9oYW5kbGVyXG4gICAgICAgID9jb25maWc6Tm9uZVxuICAgICAgfnJlcXVlc3RfaGFuZGxlcjood3JhcF9oYW5kbGVyIHRydWUgZXJyb3JfaGFuZGxlciBoYW5kbGVyKVxuICAgICAgfmVycm9yX2hhbmRsZXI6KEVycm9yX2hhbmRsZXIuaHR0cGFmIGVycm9yX2hhbmRsZXIpXG4gICAgaW5cblxuICAgIGxldCBoMl9oYW5kbGVyID1cbiAgICAgIEgyX2x3dF91bml4LlNlcnZlci5TU0wuY3JlYXRlX2Nvbm5lY3Rpb25faGFuZGxlclxuICAgICAgICA/Y29uZmlnOk5vbmVcbiAgICAgIH5yZXF1ZXN0X2hhbmRsZXI6KHdyYXBfaGFuZGxlcl9oMiB0cnVlIGVycm9yX2hhbmRsZXIgaGFuZGxlcilcbiAgICAgIH5lcnJvcl9oYW5kbGVyOihFcnJvcl9oYW5kbGVyLmgyIGVycm9yX2hhbmRsZXIpXG4gICAgaW5cblxuICAgIGxldCBwZXJmb3JtX3Rsc19oYW5kc2hha2UgPVxuICAgICAgR2x1dGVuX2x3dF91bml4LlNlcnZlci5TU0wuY3JlYXRlX2RlZmF1bHRcbiAgICAgICAgfmFscG5fcHJvdG9jb2xzOltcImgyXCI7IFwiaHR0cC8xLjFcIl1cbiAgICAgICAgfmNlcnRmaWxlOmNlcnRpZmljYXRlX2ZpbGVcbiAgICAgICAgfmtleWZpbGU6a2V5X2ZpbGVcbiAgICBpblxuXG4gICAgZnVuIGNsaWVudF9hZGRyZXNzIHVuaXhfc29ja2V0IC0+XG4gICAgICBsZXQlbHd0IHRsc19lbmRwb2ludCA9IHBlcmZvcm1fdGxzX2hhbmRzaGFrZSBjbGllbnRfYWRkcmVzcyB1bml4X3NvY2tldCBpblxuICAgICAgKCogVE9ETyBMQVRFUiBUaGlzIHBhcnQgd2l0aCBnZXR0aW5nIHRoZSBuZWdvdGlhdGVkIHByb3RvY29sIGJlbG9uZ3MgaW5cbiAgICAgICAgIEdsdXRlbi4gUmlnaHQgbm93LCB3ZSd2ZSBwaWNrZWQgdXAgYSBoYXJkIGRlcCBvbiBPcGVuU1NMLiAqKVxuICAgICAgKCogU2VlIGFsc28gaHR0cHM6Ly9naXRodWIuY29tL2FubW9udGVpcm8vb2NhbWwtaDIvYmxvYi82NmQ5MmYxNjk0YjQ4OGVhNjM4YWE1MDczYzc5NmUxNjRkNWZiZDllL2V4YW1wbGVzL2FscG4vdW5peC9hbHBuX3NlcnZlcl9zc2wubWwjTDU3ICopXG4gICAgICBtYXRjaCBMd3Rfc3NsLnNzbF9zb2NrZXQgdGxzX2VuZHBvaW50IHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICAgIHwgU29tZSB0bHNfc29ja2V0IC0+XG4gICAgICAgIG1hdGNoIFNzbC5nZXRfbmVnb3RpYXRlZF9hbHBuX3Byb3RvY29sIHRsc19zb2NrZXQgd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAoKiBOb3QgMTAwJSBjb25maXJtZWQsIGJ1dCBpdCBhcHBlYXJzIHRoYXQgYXQgbGVhc3QgQ2hyb21pdW0gZG9lcyBub3RcbiAgICAgICAgICAgICBzZW5kIGFuIEFMUE4gcHJvdG9jb2wgbGlzdCB3aGVuIGF0dGVtcHRpbmcgdG8gZXN0YWJsaXNoIGEgc2VjdXJlXG4gICAgICAgICAgICAgV2ViU29ja2V0IGNvbm5lY3Rpb24gKHByZXN1bWFibHksIGl0IGFzc3VtZXMgSFRUUC8xLjE7IFJGQyA4NDQxIGlzXG4gICAgICAgICAgICAgbm90IGltcGxlbWVudGVkKS4gVGhpcyBpcyBwYXJ0aWFsbHkgZ29vZCwgYmVjYXVzZSBoMiBkb2VzIG5vdCBzZWVtXG4gICAgICAgICAgICAgdG8gaW1wbGVtZW50IFJGQyA4NDQxLCBlaXRoZXIuIFNvLCB0byBzdXBwb3J0IHdzczovLyBpbiB0aGVcbiAgICAgICAgICAgICBwcmVzZW5jZSBvZiBBTFBOLCBoYW5kbGUgQUxQTiBmYWlsdXJlIGJ5IGp1c3QgY29udGludWluZyB3aXRoXG4gICAgICAgICAgICAgSFRUUC8xLjEuIE9uY2UgdGhlcmUgaXMgSFRUUC8yIFdlYlNvY2tldCBzdXBwb3J0LCB0aGUgd2ViXG4gICAgICAgICAgICAgYXBwbGljYXRpb24gd2lsbCBuZWVkIHRvIHJlc3BvbmQgdG8gdGhlIENPTk5FQ1QgbWV0aG9kLiAqKVxuICAgICAgICAgICgqIFRPRE8gRE9DIFVzZXIgZ3VpZGFuY2Ugb24gcmVzcG9uZGluZyB0byBib3RoIEdFVCBhbmQgQ09OTkVDVCBpblxuICAgICAgICAgICAgIFdlYlNvY2tldCBoYW5kbGVycy4gKilcbiAgICAgICAgICBodHRwYWZfaGFuZGxlciBjbGllbnRfYWRkcmVzcyB0bHNfZW5kcG9pbnRcbiAgICAgICAgfCBTb21lIFwiaHR0cC8xLjFcIiAtPlxuICAgICAgICAgIGh0dHBhZl9oYW5kbGVyIGNsaWVudF9hZGRyZXNzIHRsc19lbmRwb2ludFxuICAgICAgICB8IFNvbWUgXCJoMlwiIC0+XG4gICAgICAgICAgaDJfaGFuZGxlciBjbGllbnRfYWRkcmVzcyB0bHNfZW5kcG9pbnRcbiAgICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgICBhc3NlcnQgZmFsc2VcbiAgZW5kO1xufVxuXG4oKiBUT0RPIExBVEVSIEFkZCBBTFBOICsgSFRUUC8yLjAgd2l0aCBvY2FtbC10bHMsIHRvby4gKilcbmxldCBvY2FtbF90bHMgPSB7XG4gIGNyZWF0ZV9oYW5kbGVyID0gZnVuXG4gICAgICB+Y2VydGlmaWNhdGVfZmlsZSB+a2V5X2ZpbGVcbiAgICAgIH5oYW5kbGVyXG4gICAgICB+ZXJyb3JfaGFuZGxlciAtPlxuICAgIEh0dHBhZl9sd3RfdW5peC5TZXJ2ZXIuVExTLmNyZWF0ZV9jb25uZWN0aW9uX2hhbmRsZXJfd2l0aF9kZWZhdWx0XG4gICAgICB+Y2VydGZpbGU6Y2VydGlmaWNhdGVfZmlsZSB+a2V5ZmlsZTprZXlfZmlsZVxuICAgICAgP2NvbmZpZzpOb25lXG4gICAgICB+cmVxdWVzdF9oYW5kbGVyOih3cmFwX2hhbmRsZXIgdHJ1ZSBlcnJvcl9oYW5kbGVyIGhhbmRsZXIpXG4gICAgICB+ZXJyb3JfaGFuZGxlcjooRXJyb3JfaGFuZGxlci5odHRwYWYgZXJyb3JfaGFuZGxlcilcbn1cblxuXG5cbmxldCBjaGVja19oZWFkZXJzX21pZGRsZXdhcmUgbmV4dF9oYW5kbGVyIHJlcXVlc3QgPVxuICBsZXQlbHd0IHJlc3BvbnNlID0gbmV4dF9oYW5kbGVyIHJlcXVlc3QgaW5cbiAgbGV0IGludmFsaWRfaGVhZGVyc19leGlzdCA9XG4gICAgTWVzc2FnZS5hbGxfaGVhZGVycyByZXNwb25zZVxuICAgIHw+IExpc3QuZXhpc3RzIChmdW4gKG5hbWUsIF8pIC0+IFN0cmluZy50cmltIG5hbWUgPSBcIlwiKVxuICBpblxuICBpZiBpbnZhbGlkX2hlYWRlcnNfZXhpc3QgdGhlblxuICAgIGxvZy53YXJuaW5nIChmdW4gbG9nIC0+XG4gICAgICBsb2cgfnJlcXVlc3QgXCJBIHJlc3BvbnNlIGhlYWRlciBpcyBlbXB0eSBvciBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcIik7XG4gIEx3dC5yZXR1cm4gcmVzcG9uc2VcblxubGV0IGJ1aWx0X2luX21pZGRsZXdhcmUgZXJyb3JfaGFuZGxlciA9XG4gIE1lc3NhZ2UucGlwZWxpbmUgW1xuICAgIGNoZWNrX2hlYWRlcnNfbWlkZGxld2FyZTtcbiAgICBDYXRjaC5jYXRjaCAoRXJyb3JfaGFuZGxlci5hcHAgZXJyb3JfaGFuZGxlcik7XG4gIF1cblxubGV0IHNlcnZlX3dpdGhfZGV0YWlsc1xuICAgIGNhbGxlcl9mdW5jdGlvbl9mb3JfZXJyb3JfbWVzc2FnZXNcbiAgICB0bHNfbGlicmFyeVxuICAgIH5pbnRlcmZhY2VcbiAgICB+bmV0d29ya1xuICAgIH5zdG9wXG4gICAgfmVycm9yX2hhbmRsZXJcbiAgICB+Y2VydGlmaWNhdGVfZmlsZVxuICAgIH5rZXlfZmlsZVxuICAgIH5idWlsdGluc1xuICAgIHVzZXInc19kcmVhbV9oYW5kbGVyID1cblxuICAoKiBUT0RPIERPQyAqKVxuICAoKiBodHRwczovL2xldHNlbmNyeXB0Lm9yZy9kb2NzL2NlcnRpZmljYXRlcy1mb3ItbG9jYWxob3N0LyAqKVxuXG4gIGxldCB1c2VyJ3NfZHJlYW1faGFuZGxlciA9XG4gICAgaWYgYnVpbHRpbnMgdGhlblxuICAgICAgYnVpbHRfaW5fbWlkZGxld2FyZSBlcnJvcl9oYW5kbGVyIHVzZXInc19kcmVhbV9oYW5kbGVyXG4gICAgZWxzZVxuICAgICAgdXNlcidzX2RyZWFtX2hhbmRsZXJcbiAgaW5cblxuICAoKiBDcmVhdGUgdGhlIHdyYXBwZWQgaHR0cGFmIG9yIGgyIGhhbmRsZXIgZnJvbSB0aGUgdXNlcidzIERyZWFtIGhhbmRsZXIuICopXG4gIGxldCBodHRwYWZfY29ubmVjdGlvbl9oYW5kbGVyID1cbiAgICB0bHNfbGlicmFyeS5jcmVhdGVfaGFuZGxlclxuICAgICAgfmNlcnRpZmljYXRlX2ZpbGVcbiAgICAgIH5rZXlfZmlsZVxuICAgICAgfmhhbmRsZXI6dXNlcidzX2RyZWFtX2hhbmRsZXJcbiAgICAgIH5lcnJvcl9oYW5kbGVyXG4gIGluXG5cbiAgKCogVE9ETyBTaG91bGQgcHJvYmFibHkgbW92ZSBvdXQgdG8gdGhlIFRMUyBsaWJyYXJ5IG9wdGlvbnMuICopXG4gIGxldCB0bHNfZXJyb3JfaGFuZGxlciA9IEVycm9yX2hhbmRsZXIudGxzIGVycm9yX2hhbmRsZXIgaW5cblxuICAoKiBTb21lIHBhcnRzIG9mIHRoZSB2YXJpb3VzIEhUVFAgc2VydmVycyB0aGF0IGFyZSB1bmRlciBoZWF2eSBkZXZlbG9wbWVudFxuICAgICAoICpjb3VnaCogR2x1dGVuIFNTTC9UTFMgYXQgdGhlIG1vbWVudCkgbGVhayBleGNlcHRpb25zIG91dCBvZiB0aGVcbiAgICAgdG9wLWxldmVsIGhhbmRsZXIgaW5zdGVhZCBvZiBwYXNzaW5nIHRoZW0gdG8gdGhlIGVycm9yIGhhbmRsZXIgdGhhdCB3ZVxuICAgICBzcGVjaWZpZWQgYWJvdmUgd2l0aCB+ZXJyb3JfaGFuZGxlci4gU28sIHRvIHdvcmsgYXJvdW5kIHRoYXQsIHdlIHBhc3MgdGhlXG4gICAgIGVycm9ycyBtYW51YWxseS4gU2luY2Ugd2UgZG9uJ3QgZXZlbiBoYXZlIHJlcXVlc3Qgb3IgcmVzcG9uc2Ugb2JqZWN0cyBhdFxuICAgICB0aGlzIHBvaW50LCB3ZSBzaW1wbHkgaWdub3JlIHRoZSBEcmVhbS5yZXNwb25zZSB0aGF0IHRoZSBlcnJvciBoYW5kbGVyXG4gICAgIGdlbmVyYXRlcy4gV2UgY2FsbCBpdCBmb3IgYW55IGxvZ2dpbmcgdGhhdCBpdCBtYXkgZG8sIGFuZCB0byBzd2FsbG93IHRoZVxuICAgICBlcnJvci4gT3RoZXJ3aXNlLCBpdCB3aWxsIGdvIHRvICFMd3QuYXN5bmNfZXhjZXB0aW9uX2hvb2suICopXG4gICgqIFRPRE8gU1NMIGFsZXJ0cyBmb2xsb3cgdGhpcyBwYXRod2F5IGludG8gdGhlIGxvZyBhdCBFUlJPUiBsZXZlbCwgd2hpY2ggaXNcbiAgICAgcXVlc3Rpb25hYmxlIC0gSSB1bmRlcnN0YW5kIHRoYXQgbWVhbnMgY2xpZW50cyBjYW4gY2F1c2UgRVJST1IgbGV2ZWwgbG9nXG4gICAgIG1lc3NhZ2VzIHRvIGJlIHdyaXR0ZW4gaW50byB0aGUgbG9nIGF0IHdpbGwuIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHRoZVxuICAgICBleGNlcHRpb24gc2hvdWxkIGJlIGZvcm1hdHRlZCBhbmQgcGFzc2VkIGFzIGBCYWRfcmVxdWVzdCwgb3IgdGhlcmUgc2hvdWxkXG4gICAgIGJlIHBhdHRlcm4gbWF0Y2hpbmcgb24gdGhlIGV4Y2VwdGlvbiAoYnV0IHRoYXQgbWlnaHQgaW50cm9kdWNlIGRlcGVuZGVuY3lcbiAgICAgY291cGxpbmcpLCBvciB0aGUgdXBzdHJlYW0gc2hvdWxkIGJlIHBhdGNoZWQgdG8gZGlzdGluZ3Vpc2ggdGhlIGVycm9ycyBpblxuICAgICBzb21lIHVzZWZ1bCB3YXkuICopXG4gIGxldCBodHRwYWZfY29ubmVjdGlvbl9oYW5kbGVyIGNsaWVudF9hZGRyZXNzIHNvY2tldCA9XG4gICAgTHd0LmNhdGNoXG4gICAgICAoZnVuICgpIC0+XG4gICAgICAgIGh0dHBhZl9jb25uZWN0aW9uX2hhbmRsZXIgY2xpZW50X2FkZHJlc3Mgc29ja2V0KVxuICAgICAgKGZ1biBleG4gLT5cbiAgICAgICAgdGxzX2Vycm9yX2hhbmRsZXIgY2xpZW50X2FkZHJlc3MgZXhuO1xuICAgICAgICBMd3QucmV0dXJuX3VuaXQpXG4gIGluXG5cbiAgKCogTG9vayB1cCB0aGUgbG93LWxldmVsIGFkZHJlc3MgY29ycmVzcG9uZGluZyB0byB0aGUgaW50ZXJmYWNlLiBIb3BlZnVsbHksXG4gICAgIHRoaXMgaXMgYSBsb2NhbCBpbnRlcmZhY2UuICopXG4gIGxldCVsd3QgbGlzdGVuX2FkZHJlc3MgPVxuICAgIG1hdGNoIG5ldHdvcmsgd2l0aFxuICAgIHwgYFVuaXggcGF0aCAtPlxuICAgICAgTHd0LnJldHVybiAoTHd0X3VuaXguQUREUl9VTklYIHBhdGgpXG4gICAgfCBgSW5ldCBwb3J0IC0+XG4gICAgICBsZXQlbHd0IGFkZHJlc3NlcyA9XG4gICAgICAgIEx3dF91bml4LmdldGFkZHJpbmZvIGludGVyZmFjZSAoc3RyaW5nX29mX2ludCBwb3J0KSBbXSBpblxuICAgICAgbWF0Y2ggYWRkcmVzc2VzIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgUHJpbnRmLmtzcHJpbnRmIGZhaWx3aXRoIFwiRHJlYW0uJXM6IG5vIGludGVyZmFjZSB3aXRoIGFkZHJlc3MgJXNcIlxuICAgICAgICAgIGNhbGxlcl9mdW5jdGlvbl9mb3JfZXJyb3JfbWVzc2FnZXMgaW50ZXJmYWNlXG4gICAgICB8IGFkZHJlc3M6Ol8gLT5cbiAgICAgICAgTHd0LnJldHVybiBMd3RfdW5peC4oYWRkcmVzcy5haV9hZGRyKVxuICBpblxuXG4gICgqIEJyaW5nIHVwIHRoZSBIVFRQIHNlcnZlci4gV2FpdCBmb3IgdGhlIHNlcnZlciB0byBhY3R1YWxseSBnZXQgc3RhcnRlZC5cbiAgICAgVGhlbiwgd2FpdCBmb3IgdGhlIH5zdG9wIHByb21pc2UuIElmIHRoZSB+c3RvcCBwcm9taXNlIGV2ZXIgcmVzb2x2ZXMsIHN0b3BcbiAgICAgdGhlIHNlcnZlci4gKilcbiAgbGV0JWx3dCBzZXJ2ZXIgPVxuICAgIEx3dF9pby5lc3RhYmxpc2hfc2VydmVyX3dpdGhfY2xpZW50X3NvY2tldFxuICAgICAgbGlzdGVuX2FkZHJlc3NcbiAgICAgIGh0dHBhZl9jb25uZWN0aW9uX2hhbmRsZXIgaW5cblxuICBsZXQlbHd0ICgpID0gc3RvcCBpblxuICBMd3RfaW8uc2h1dGRvd25fc2VydmVyIHNlcnZlclxuXG5cblxubGV0IGlzX2xvY2FsaG9zdCBpbnRlcmZhY2UgPVxuICBpbnRlcmZhY2UgPSBcImxvY2FsaG9zdFwiIHx8IGludGVyZmFjZSA9IFwiMTI3LjAuMC4xXCJcblxubGV0IHNlcnZlX3dpdGhfbWF5YmVfaHR0cHNcbiAgICBjYWxsZXJfZnVuY3Rpb25fZm9yX2Vycm9yX21lc3NhZ2VzXG4gICAgfmludGVyZmFjZVxuICAgIH5uZXR3b3JrXG4gICAgfnN0b3BcbiAgICB+ZXJyb3JfaGFuZGxlclxuICAgIH50bHNcbiAgICA/Y2VydGlmaWNhdGVfZmlsZSA/a2V5X2ZpbGVcbiAgICA/Y2VydGlmaWNhdGVfc3RyaW5nID9rZXlfc3RyaW5nXG4gICAgfmJ1aWx0aW5zXG4gICAgdXNlcidzX2RyZWFtX2hhbmRsZXIgPVxuXG4gIHRyeSVsd3RcbiAgICAoKiBUaGlzIGNoZWNrIHdpbGwgYXQgbGVhc3QgY2F0Y2ggc2VjcmV0cyBsaWtlIFwiZm9vXCIgd2hlbiB1c2VkIG9uIGEgcHVibGljXG4gICAgICAgaW50ZXJmYWNlLiAqKVxuICAgICgqIGlmIG5vdCAoaXNfbG9jYWxob3N0IGludGVyZmFjZSkgdGhlblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBzZWNyZXQgPCAzMiB0aGVuIGJlZ2luXG4gICAgICAgIGxvZy53YXJuaW5nIChmdW4gbG9nIC0+IGxvZyBcIlVzaW5nIGEgc2hvcnQga2V5IG9uIGEgcHVibGljIGludGVyZmFjZVwiKTtcbiAgICAgICAgbG9nLndhcm5pbmcgKGZ1biBsb2cgLT5cbiAgICAgICAgICBsb2cgXCJDb25zaWRlciB1c2luZyBEcmVhbS50b19iYXNlNjR1cmwgKERyZWFtLnJhbmRvbSAzMilcIik7XG4gICAgZW5kOyAqKVxuICAgICgqIFRPRE8gTWFrZSBzdXJlIHRoZXJlIGlzIGEgc2ltaWxhciBjaGVjayBpbiBjaXBoZXIubWwgbm93LkhwYWNrICopXG5cbiAgICBtYXRjaCB0bHMgd2l0aFxuICAgIHwgYE5vIC0+XG4gICAgICBzZXJ2ZV93aXRoX2RldGFpbHNcbiAgICAgICAgY2FsbGVyX2Z1bmN0aW9uX2Zvcl9lcnJvcl9tZXNzYWdlc1xuICAgICAgICBub190bHNcbiAgICAgICAgfmludGVyZmFjZVxuICAgICAgICB+bmV0d29ya1xuICAgICAgICB+c3RvcFxuICAgICAgICB+ZXJyb3JfaGFuZGxlclxuICAgICAgICB+Y2VydGlmaWNhdGVfZmlsZTpcIlwiXG4gICAgICAgIH5rZXlfZmlsZTpcIlwiXG4gICAgICAgIH5idWlsdGluc1xuICAgICAgICB1c2VyJ3NfZHJlYW1faGFuZGxlclxuXG4gICAgfCBgT3BlblNTTCB8IGBPQ2FtbF9UTFMgYXMgdGxzX2xpYnJhcnkgLT5cbiAgICAgICgqIFRPRE8gV3JpdGluZyB0ZW1wb3JhcnkgZmlsZXMgaXMgZXh0cmVtZWx5IHF1ZXN0aW9uYWJsZSBmb3IgYW55dGhpbmdcbiAgICAgICAgIGV4Y2VwdCB0aGUgZmFrZSBsb2NhbGhvc3QgY2VydGlmaWNhdGUuIFRoaXMgbmVlZHMgbG91ZCB3YXJuaW5ncy4gSUlSQ1xuICAgICAgICAgdGhlIFNTTCBiaW5kaW5nIGFscmVhZHkgc3VwcG9ydHMgaW4tbWVtb3J5IGNlcnRpZmljYXRlcy4gRG9lcyBUTFM/IEluXG4gICAgICAgICBhbnkgY2FzZSwgdGhpcyB3b3VsZCBuZWVkIHVwc3RyZWFtIHdvcmsuICopXG4gICAgICBsZXQgY2VydGlmaWNhdGVfYW5kX2tleSA9XG4gICAgICAgIG1hdGNoIGNlcnRpZmljYXRlX2ZpbGUsIGtleV9maWxlLCBjZXJ0aWZpY2F0ZV9zdHJpbmcsIGtleV9zdHJpbmcgd2l0aFxuICAgICAgICB8IE5vbmUsIE5vbmUsIE5vbmUsIE5vbmUgLT5cbiAgICAgICAgICAoKiBVc2UgdGhlIGJ1aWx0LWluIGRldmVsb3BtZW50IGNlcnRpZmljYXRlLiBIb3dldmVyLCBpZiB0aGUgaW50ZXJmYWNlXG4gICAgICAgICAgICBpcyBub3QgYSBsb29wYmFjayBpbnRlcmZhY2UsIHdyaXRlIGEgd2FybmluZy4gKilcbiAgICAgICAgICBpZiBub3QgKGlzX2xvY2FsaG9zdCBpbnRlcmZhY2UpIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGxvZy53YXJuaW5nIChmdW4gbG9nIC0+XG4gICAgICAgICAgICAgIGxvZyBcIlVzaW5nIGEgZGV2ZWxvcG1lbnQgU1NMIGNlcnRpZmljYXRlIG9uIGEgcHVibGljIGludGVyZmFjZVwiKTtcbiAgICAgICAgICAgIGxvZy53YXJuaW5nIChmdW4gbG9nIC0+XG4gICAgICAgICAgICAgIGxvZyBcIlNlZSBhcmd1bWVudHMgfmNlcnRpZmljYXRlX2ZpbGUgYW5kIH5rZXlfZmlsZVwiKTtcbiAgICAgICAgICBlbmQ7XG5cbiAgICAgICAgICBgTWVtb3J5IChcbiAgICAgICAgICAgIERyZWFtX19jZXJ0aWZpY2F0ZS5sb2NhbGhvc3RfY2VydGlmaWNhdGUsXG4gICAgICAgICAgICBEcmVhbV9fY2VydGlmaWNhdGUubG9jYWxob3N0X2NlcnRpZmljYXRlX2tleSxcbiAgICAgICAgICAgIGBTaWxlbnRcbiAgICAgICAgICApXG5cbiAgICAgICAgfCBTb21lIGNlcnRpZmljYXRlX2ZpbGUsIFNvbWUga2V5X2ZpbGUsIE5vbmUsIE5vbmUgLT5cbiAgICAgICAgICBgRmlsZSAoY2VydGlmaWNhdGVfZmlsZSwga2V5X2ZpbGUpXG5cbiAgICAgICAgfCBOb25lLCBOb25lLCBTb21lIGNlcnRpZmljYXRlX3N0cmluZywgU29tZSBrZXlfc3RyaW5nIC0+XG4gICAgICAgICAgKCogVGhpcyBpcyBsaWtlbHkgYSBub24tZGV2ZWxvcG1lbnQgaW4tbWVtb3J5IGNlcnRpZmljYXRlLCBhbmQgaXRcbiAgICAgICAgICAgICBzZWVtcyByZWFzb25hYmxlIHRvIHdhcm4gdGhhdCB3ZSBhcmUgZ29pbmcgdG8gd3JpdGUgaXQgdG8gYVxuICAgICAgICAgICAgIHRlbXBvcmFyeSBmaWxlLCB3aXRoIHNlY3VyaXR5IGltcGxpY2F0aW9ucy4gKilcbiAgICAgICAgICBsb2cud2FybmluZyAoZnVuIGxvZyAtPlxuICAgICAgICAgICAgbG9nIFwiSW4tbWVtb3J5IGNlcnRpZmljYXRlcyB3aWxsIGJlIHdyaXR0ZW4gdG8gdGVtcG9yYXJ5IGZpbGVzXCIpO1xuXG4gICAgICAgICAgKCogU2hvdyB3aGVyZSB0aGUgY2VydGlmaWNhdGUgaXMgd3JpdHRlbiBzbyB0aGF0IHRoZSB1c2VyIGNhbiBnZXQgcmlkXG4gICAgICAgICAgICAgb2YgaXQsIGlmIG5lY2Vzc2FyeS4gSW4gcGFydGljdWxhciwgdGhlIGtleSBmaWxlIHNob3VsZCBiZSByZW1vdmVkXG4gICAgICAgICAgICAgdXNpbmcgc3JtLiBUaGlzIHdob2xlIHNjaGVtZSBpcyBqdXN0IGNvbXBsZXRlbHkgaW5zZWN1cmUsIGJlY2F1c2VcbiAgICAgICAgICAgICB0aGUgc2VydmVyIGl0c2VsZiBkb2VzIG5vdCB1c2UgYW4gZXF1aXZhbGVudCBvZiBzcm0gdG8gZ2V0IHJpZCBvZlxuICAgICAgICAgICAgIHRoZSB0ZW1wb3JhcnkgZmlsZS4gVXBkc3RyZWFtIHN1cHBvcnQgaXMgcmVhbGx5IG5lY2Vzc2FyeSBoZXJlLiAqKVxuICAgICAgICAgIGBNZW1vcnkgKGNlcnRpZmljYXRlX3N0cmluZywga2V5X3N0cmluZywgYFZlcmJvc2UpXG5cbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnRcbiAgICAgICAgICAgIFwiTXVzdCBzcGVjaWZ5IGV4YWN0bHkgb25lIHBhaXIgb2YgY2VydGlmaWNhdGUgYW5kIGtleVwiKVxuICAgICAgaW5cblxuICAgICAgbGV0IHRsc19saWJyYXJ5ID1cbiAgICAgICAgbWF0Y2ggdGxzX2xpYnJhcnkgd2l0aFxuICAgICAgICB8IGBPcGVuU1NMIC0+IG9wZW5zc2xcbiAgICAgICAgfCBgT0NhbWxfVExTIC0+IG9jYW1sX3Rsc1xuICAgICAgaW5cblxuICAgICAgbWF0Y2ggY2VydGlmaWNhdGVfYW5kX2tleSB3aXRoXG4gICAgICB8IGBGaWxlIChjZXJ0aWZpY2F0ZV9maWxlLCBrZXlfZmlsZSkgLT5cbiAgICAgICAgc2VydmVfd2l0aF9kZXRhaWxzXG4gICAgICAgICAgY2FsbGVyX2Z1bmN0aW9uX2Zvcl9lcnJvcl9tZXNzYWdlc1xuICAgICAgICAgIHRsc19saWJyYXJ5XG4gICAgICAgICAgfmludGVyZmFjZVxuICAgICAgICAgIH5uZXR3b3JrXG4gICAgICAgICAgfnN0b3BcbiAgICAgICAgICB+ZXJyb3JfaGFuZGxlclxuICAgICAgICAgIH5jZXJ0aWZpY2F0ZV9maWxlXG4gICAgICAgICAgfmtleV9maWxlXG4gICAgICAgICAgfmJ1aWx0aW5zXG4gICAgICAgICAgdXNlcidzX2RyZWFtX2hhbmRsZXJcblxuICAgICAgfCBgTWVtb3J5IChjZXJ0aWZpY2F0ZV9zdHJpbmcsIGtleV9zdHJpbmcsIHZlcmJvc2Vfb3Jfc2lsZW50KSAtPlxuICAgICAgICBMd3RfaW8ud2l0aF90ZW1wX2ZpbGUgYmVnaW4gZnVuIChjZXJ0aWZpY2F0ZV9maWxlLCBjZXJ0aWZpY2F0ZV9zdHJlYW0pIC0+XG4gICAgICAgIEx3dF9pby53aXRoX3RlbXBfZmlsZSBiZWdpbiBmdW4gKGtleV9maWxlLCBrZXlfc3RyZWFtKSAtPlxuXG4gICAgICAgIGlmIHZlcmJvc2Vfb3Jfc2lsZW50IDw+IGBTaWxlbnQgdGhlbiBiZWdpblxuICAgICAgICAgIGxvZy53YXJuaW5nIChmdW4gbG9nIC0+XG4gICAgICAgICAgICBsb2cgXCJXcml0aW5nIGNlcnRpZmljYXRlIHRvICVzXCIgY2VydGlmaWNhdGVfZmlsZSk7XG4gICAgICAgICAgbG9nLndhcm5pbmcgKGZ1biBsb2cgLT5cbiAgICAgICAgICAgIGxvZyBcIldyaXRpbmcga2V5IHRvICVzXCIga2V5X2ZpbGUpO1xuICAgICAgICBlbmQ7XG5cbiAgICAgICAgbGV0JWx3dCAoKSA9IEx3dF9pby53cml0ZSBjZXJ0aWZpY2F0ZV9zdHJlYW0gY2VydGlmaWNhdGVfc3RyaW5nIGluXG4gICAgICAgIGxldCVsd3QgKCkgPSBMd3RfaW8ud3JpdGUga2V5X3N0cmVhbSBrZXlfc3RyaW5nIGluXG4gICAgICAgIGxldCVsd3QgKCkgPSBMd3RfaW8uY2xvc2UgY2VydGlmaWNhdGVfc3RyZWFtIGluXG4gICAgICAgIGxldCVsd3QgKCkgPSBMd3RfaW8uY2xvc2Uga2V5X3N0cmVhbSBpblxuXG4gICAgICAgIHNlcnZlX3dpdGhfZGV0YWlsc1xuICAgICAgICAgIGNhbGxlcl9mdW5jdGlvbl9mb3JfZXJyb3JfbWVzc2FnZXNcbiAgICAgICAgICB0bHNfbGlicmFyeVxuICAgICAgICAgIH5pbnRlcmZhY2VcbiAgICAgICAgICB+bmV0d29ya1xuICAgICAgICAgIH5zdG9wXG4gICAgICAgICAgfmVycm9yX2hhbmRsZXJcbiAgICAgICAgICB+Y2VydGlmaWNhdGVfZmlsZVxuICAgICAgICAgIH5rZXlfZmlsZVxuICAgICAgICAgIH5idWlsdGluc1xuICAgICAgICAgIHVzZXInc19kcmVhbV9oYW5kbGVyXG5cbiAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuXG4gIHdpdGggZXhuIC0+XG4gICAgbGV0IGJhY2t0cmFjZSA9IFByaW50ZXhjLmdldF9iYWNrdHJhY2UgKCkgaW5cbiAgICBsb2cuZXJyb3IgKGZ1biBsb2cgLT5cbiAgICAgIGxvZyBcIkRyZWFtLiVzOiBleGNlcHRpb24gJXNcIlxuICAgICAgICBjYWxsZXJfZnVuY3Rpb25fZm9yX2Vycm9yX21lc3NhZ2VzIChQcmludGV4Yy50b19zdHJpbmcgZXhuKSk7XG4gICAgYmFja3RyYWNlIHw+IExvZy5pdGVyX2JhY2t0cmFjZSAoZnVuIGxpbmUgLT5cbiAgICAgIGxvZy5lcnJvciAoZnVuIGxvZyAtPiBsb2cgXCIlc1wiIGxpbmUpKTtcbiAgICByYWlzZSBleG5cblxuXG5cbmxldCBkZWZhdWx0X2ludGVyZmFjZSA9IFwibG9jYWxob3N0XCJcbmxldCBkZWZhdWx0X3BvcnQgPSA4MDgwXG5sZXQgbmV2ZXIgPSBmc3QgKEx3dC53YWl0ICgpKVxuXG5sZXQgbmV0d29yayB+cG9ydCB+c29ja2V0X3BhdGggPVxuICBtYXRjaCBzb2NrZXRfcGF0aCB3aXRoXG4gIHwgTm9uZSAtPiBgSW5ldCBwb3J0XG4gIHwgU29tZSBwYXRoIC0+IGBVbml4IHBhdGhcblxubGV0IHNlcnZlXG4gICAgPyhpbnRlcmZhY2UgPSBkZWZhdWx0X2ludGVyZmFjZSlcbiAgICA/KHBvcnQgPSBkZWZhdWx0X3BvcnQpXG4gICAgP3NvY2tldF9wYXRoXG4gICAgPyhzdG9wID0gbmV2ZXIpXG4gICAgPyhlcnJvcl9oYW5kbGVyID0gRXJyb3JfaGFuZGxlci5kZWZhdWx0KVxuICAgID8odGxzID0gZmFsc2UpXG4gICAgP2NlcnRpZmljYXRlX2ZpbGVcbiAgICA/a2V5X2ZpbGVcbiAgICA/KGJ1aWx0aW5zID0gdHJ1ZSlcbiAgICB1c2VyJ3NfZHJlYW1faGFuZGxlciA9XG5cbiAgc2VydmVfd2l0aF9tYXliZV9odHRwc1xuICAgIFwic2VydmVcIlxuICAgIH5pbnRlcmZhY2VcbiAgICB+bmV0d29yazoobmV0d29yayB+cG9ydCB+c29ja2V0X3BhdGgpXG4gICAgfnN0b3BcbiAgICB+ZXJyb3JfaGFuZGxlclxuICAgIH50bHM6KGlmIHRscyB0aGVuIGBPcGVuU1NMIGVsc2UgYE5vKVxuICAgID9jZXJ0aWZpY2F0ZV9maWxlXG4gICAgP2tleV9maWxlXG4gICAgP2NlcnRpZmljYXRlX3N0cmluZzpOb25lXG4gICAgP2tleV9zdHJpbmc6Tm9uZVxuICAgIH5idWlsdGluc1xuICAgIHVzZXInc19kcmVhbV9oYW5kbGVyXG5cblxuXG5sZXQgcnVuXG4gICAgPyhpbnRlcmZhY2UgPSBkZWZhdWx0X2ludGVyZmFjZSlcbiAgICA/KHBvcnQgPSBkZWZhdWx0X3BvcnQpXG4gICAgP3NvY2tldF9wYXRoXG4gICAgPyhzdG9wID0gbmV2ZXIpXG4gICAgPyhlcnJvcl9oYW5kbGVyID0gRXJyb3JfaGFuZGxlci5kZWZhdWx0KVxuICAgID8odGxzID0gZmFsc2UpXG4gICAgP2NlcnRpZmljYXRlX2ZpbGVcbiAgICA/a2V5X2ZpbGVcbiAgICA/KGJ1aWx0aW5zID0gdHJ1ZSlcbiAgICA/KGdyZWV0aW5nID0gdHJ1ZSlcbiAgICA/YWRqdXN0X3Rlcm1pbmFsXG4gICAgdXNlcidzX2RyZWFtX2hhbmRsZXIgPVxuXG4gIGxldCAoKSA9IGlmIFN5cy51bml4IHRoZW5cbiAgICBTeXMuKHNldF9zaWduYWwgc2lncGlwZSBTaWduYWxfaWdub3JlKVxuICBpblxuXG4gIGxldCBsb2cgPSBMb2cuY29udmVuaWVuY2VfbG9nIGluXG5cbiAgKCogVGhpcyBzaG91bGQgYmUgcmVtb3ZlZCwgdG9nZXRoZXIgd2l0aCB+YWRqdXN0X3Rlcm1pbmFsLCBhZnRlciBhIGZld1xuICAgICByZWxlYXNlcy4gVGhlIHdhcm5pbmcgaXMgcHJlc2VudCBzaW5jZSAxLjAuMH5hbHBoYTcuICopXG4gIGlmIGFkanVzdF90ZXJtaW5hbCA8PiBOb25lIHRoZW4gYmVnaW5cbiAgICBFcnJvcl9oYW5kbGVyLmxvZy53YXJuaW5nIChmdW4gbG9nIC0+XG4gICAgICBsb2cgXCJEcmVhbS5ydW46IH5hZGp1c3RfdGVybWluYWwgaXMgZGVwcmVjYXRlZFwiKVxuICBlbmQ7XG5cbiAgaWYgZ3JlZXRpbmcgdGhlbiBiZWdpblxuICAgIGxldCBzY2hlbWUgPVxuICAgICAgaWYgdGxzIHRoZW5cbiAgICAgICAgXCJodHRwc1wiXG4gICAgICBlbHNlXG4gICAgICAgIFwiaHR0cFwiXG4gICAgaW5cblxuICAgIGJlZ2luIG1hdGNoIGludGVyZmFjZSwgc29ja2V0X3BhdGggd2l0aFxuICAgIHwgXywgU29tZSBwYXRoIC0+XG4gICAgICBsb2cgXCJSdW5uaW5nIG9uICVzXCIgcGF0aFxuICAgIHwgKFwibG9jYWxob3N0XCIgfCBcIjEyNy4wLjAuMVwiKSwgTm9uZSAtPlxuICAgICAgbG9nIFwiUnVubmluZyBhdCAlczovL2xvY2FsaG9zdDolaVwiIHNjaGVtZSBwb3J0XG4gICAgfCBfIC0+XG4gICAgICBsb2cgXCJSdW5uaW5nIG9uICVzOiVpICglczovL2xvY2FsaG9zdDolaSlcIiBpbnRlcmZhY2UgcG9ydCBzY2hlbWUgcG9ydFxuICAgIGVuZDtcbiAgICBsb2cgXCJUeXBlIEN0cmwrQyB0byBzdG9wXCJcbiAgZW5kO1xuXG4gIEx3dF9tYWluLnJ1biBiZWdpblxuICAgIHNlcnZlX3dpdGhfbWF5YmVfaHR0cHNcbiAgICAgIFwicnVuXCJcbiAgICAgIH5pbnRlcmZhY2VcbiAgICAgIH5uZXR3b3JrOihuZXR3b3JrIH5wb3J0IH5zb2NrZXRfcGF0aClcbiAgICAgIH5zdG9wXG4gICAgICB+ZXJyb3JfaGFuZGxlclxuICAgICAgfnRsczooaWYgdGxzIHRoZW4gYE9wZW5TU0wgZWxzZSBgTm8pXG4gICAgICA/Y2VydGlmaWNhdGVfZmlsZSA/a2V5X2ZpbGVcbiAgICAgID9jZXJ0aWZpY2F0ZV9zdHJpbmc6Tm9uZSA/a2V5X3N0cmluZzpOb25lXG4gICAgICB+YnVpbHRpbnNcbiAgICAgIHVzZXInc19kcmVhbV9oYW5kbGVyXG4gIGVuZFxuIl19
