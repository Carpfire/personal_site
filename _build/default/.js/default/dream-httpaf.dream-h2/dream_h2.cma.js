// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Dream_h2
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Dream_h2 = [0];
   runtime.caml_register_global(0, Dream_h2, "Dream_h2");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Util
//# unitInfo: Requires: Stdlib, Stdlib__Int32
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib = global_data.Stdlib;
   function test_bit_int32(x, i){
    return 1 - caml_call2(Stdlib_Int32[17], x & 1 << i, 0);
   }
   function test_bit(x, i){return 0 !== (x & 1 << i) ? 1 : 0;}
   function set_bit(x, i){return x | 1 << i;}
   function set_bit_int32(x, i){return x | 1 << i;}
   function clear_bit(x, i){return x & caml_call1(Stdlib[21], 1 << i);}
   function clear_bit_int32(x, i){
    return x & caml_call1(Stdlib_Int32[11], 1 << i);
   }
   var
    Dream_h2_Util =
      [0,
       test_bit_int32,
       test_bit,
       set_bit,
       set_bit_int32,
       clear_bit,
       clear_bit_int32];
   runtime.caml_register_global(6, Dream_h2_Util, "Dream_h2__Util");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Stream_identifier
//# unitInfo: Requires: Stdlib__Int32
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_mod = runtime.caml_mod;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Int32 = global_data.Stdlib__Int32,
    symbol = Stdlib_Int32[17];
   function symbol$0(s1, s2){
    return caml_call2(Stdlib_Int32[15], s1, s2) <= 0 ? 1 : 0;
   }
   function symbol$1(s1, s2){
    return 0 < caml_call2(Stdlib_Int32[15], s1, s2) ? 1 : 0;
   }
   function symbol$2(s1, s2){
    return 0 <= caml_call2(Stdlib_Int32[15], s1, s2) ? 1 : 0;
   }
   var connection = Stdlib_Int32[1];
   function is_connection(id){
    return caml_call2(Stdlib_Int32[17], id, connection);
   }
   function is_request(id){return caml_call2(symbol, caml_mod(id, 2), 1);}
   function is_pushed(n){
    return runtime.caml_notequal(n, 0)
            ? caml_call2(symbol, caml_mod(n, 2), 0)
            : 0;
   }
   var
    max_stream_id = Stdlib_Int32[9],
    Dream_h2_Stream_identifier =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       connection,
       is_connection,
       is_request,
       is_pushed,
       max_stream_id];
   runtime.caml_register_global
    (6, Dream_h2_Stream_identifier, "Dream_h2__Stream_identifier");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Error_code
//# unitInfo: Requires: Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_lessthan = runtime.caml_lessthan,
    caml_notequal = runtime.caml_notequal;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    _b_ = [0, [2, 0, 0], "%s"],
    cst_NO_ERROR_0x0 = "NO_ERROR (0x0)",
    cst_PROTOCOL_ERROR_0x1 = "PROTOCOL_ERROR (0x1)",
    cst_INTERNAL_ERROR_0x2 = "INTERNAL_ERROR (0x2)",
    cst_FLOW_CONTROL_ERROR_0x3 = "FLOW_CONTROL_ERROR (0x3)",
    cst_SETTINGS_TIMEOUT_0x4 = "SETTINGS_TIMEOUT (0x4)",
    cst_STREAM_CLOSED_0x5 = "STREAM_CLOSED (0x5)",
    cst_FRAME_SIZE_ERROR_0x6 = "FRAME_SIZE_ERROR (0x6)",
    cst_REFUSED_STREAM_0x7 = "REFUSED_STREAM (0x7)",
    cst_CANCEL_0x8 = "CANCEL (0x8)",
    cst_COMPRESSION_ERROR_0x9 = "COMPRESSION_ERROR (0x9)",
    cst_CONNECT_ERROR_0xa = "CONNECT_ERROR (0xa)",
    cst_ENHANCE_YOUR_CALM_0xb = "ENHANCE_YOUR_CALM (0xb)",
    cst_INADEQUATE_SECURITY_0xc = "INADEQUATE_SECURITY (0xc)",
    cst_HTTP_1_1_REQUIRED_0xd = "HTTP_1_1_REQUIRED (0xd)",
    _a_ =
      [0,
       [11, "UNKNOWN_ERROR (0x", [5, 6, 0, 0, [12, 41, 0]]],
       "UNKNOWN_ERROR (0x%lx)"];
   function serialize(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return 0;
       case 1:
        return 1;
       case 2:
        return 2;
       case 3:
        return 3;
       case 4:
        return 4;
       case 5:
        return 5;
       case 6:
        return 6;
       case 7:
        return 7;
       case 8:
        return 8;
       case 9:
        return 9;
       case 10:
        return 10;
       case 11:
        return 11;
       case 12:
        return 12;
       default: return 13;
     }
    var id = param[1];
    return id;
   }
   function parse(id){
    if(caml_lessthan(id, 7))
     if(caml_lessthan(id, 3)){
      if(! caml_notequal(id, 0)) return 0;
      if(! caml_notequal(id, 1)) return 1;
      if(! caml_notequal(id, 2)) return 2;
     }
     else if(caml_lessthan(id, 5)){
      if(! caml_notequal(id, 3)) return 3;
      if(! caml_notequal(id, 4)) return 4;
     }
     else{
      if(! caml_notequal(id, 5)) return 5;
      if(! caml_notequal(id, 6)) return 6;
     }
    else if(caml_lessthan(id, 10)){
     if(! caml_notequal(id, 7)) return 7;
     if(! caml_notequal(id, 8)) return 8;
     if(! caml_notequal(id, 9)) return 9;
    }
    else if(caml_lessthan(id, 12)){
     if(! caml_notequal(id, 10)) return 10;
     if(! caml_notequal(id, 11)) return 11;
    }
    else{
     if(! caml_notequal(id, 12)) return 12;
     if(! caml_notequal(id, 13)) return 13;
    }
    return [0, id];
   }
   function to_string(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return cst_NO_ERROR_0x0;
       case 1:
        return cst_PROTOCOL_ERROR_0x1;
       case 2:
        return cst_INTERNAL_ERROR_0x2;
       case 3:
        return cst_FLOW_CONTROL_ERROR_0x3;
       case 4:
        return cst_SETTINGS_TIMEOUT_0x4;
       case 5:
        return cst_STREAM_CLOSED_0x5;
       case 6:
        return cst_FRAME_SIZE_ERROR_0x6;
       case 7:
        return cst_REFUSED_STREAM_0x7;
       case 8:
        return cst_CANCEL_0x8;
       case 9:
        return cst_COMPRESSION_ERROR_0x9;
       case 10:
        return cst_CONNECT_ERROR_0xa;
       case 11:
        return cst_ENHANCE_YOUR_CALM_0xb;
       case 12:
        return cst_INADEQUATE_SECURITY_0xc;
       default: return cst_HTTP_1_1_REQUIRED_0xd;
     }
    var id = param[1];
    return caml_call2(Stdlib_Format[141], _a_, id);
   }
   function pp_hum(formatter, t){
    var _c_ = to_string(t);
    return caml_call3(Stdlib_Format[137], formatter, _b_, _c_);
   }
   var Dream_h2_Error_code = [0, serialize, parse, to_string, pp_hum];
   runtime.caml_register_global
    (50, Dream_h2_Error_code, "Dream_h2__Error_code");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Error
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "";
   function message(param){
    if(0 !== param[0]) return cst;
    var msg = param[2];
    return msg;
   }
   var Dream_h2_Error = [0, message];
   runtime.caml_register_global(1, Dream_h2_Error, "Dream_h2__Error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Settings
//# unitInfo: Requires: Angstrom, Base64, Dream_h2__Util, Faraday, Stdlib__Format, Stdlib__Int32, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_notequal = runtime.caml_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    key = "MAX_HEADER_LIST_SIZE",
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_List = global_data.Stdlib__List,
    Faraday = global_data.Faraday,
    Base64 = global_data.Base64,
    Angstrom = global_data.Angstrom,
    Dream_h2_Util = global_data.Dream_h2__Util,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    max_window_size = Stdlib_Int32[9],
    cst_HEADER_TABLE_SIZE = "HEADER_TABLE_SIZE",
    cst_ENABLE_PUSH = "ENABLE_PUSH",
    cst_MAX_CONCURRENT_STREAMS = "MAX_CONCURRENT_STREAMS",
    cst_INITIAL_WINDOW_SIZE = "INITIAL_WINDOW_SIZE",
    cst_MAX_FRAME_SIZE = "MAX_FRAME_SIZE",
    _h_ =
      [0,
       [18,
        [1, [0, 0, cst]],
        [12, 40, [3, 0, [12, 32, [7, 0, 0, 0, [12, 41, [17, 0, 0]]]]]]],
       "@[(%S %Ld)@]"],
    _i_ = [0, [18, [1, [0, 0, cst]], [12, 40, 0]], "@[("],
    _j_ = [0, [12, 41, [17, 0, 0]], ")@]"],
    _g_ = [0, 0],
    _d_ = [1, [0, 1, "SETTINGS_ENABLE_PUSH must be 0 or 1"]],
    _b_ = [1, [0, 1, "Server must not try to enable SETTINGS_ENABLE_PUSH"]],
    _c_ = [0, 0],
    _e_ =
      [0,
       [11, "Window size must be less than or equal to ", [5, 0, 0, 0, 0]],
       "Window size must be less than or equal to %ld"],
    _f_ = [1, [0, 1, "Max frame size must be in the 16384 - 16777215 range"]],
    _a_ = [0, 0],
    default_initial_window_size = 65535;
   function is_window_overflow(n){return caml_call2(Dream_h2_Util[1], n, 31);}
   var
    WindowSize =
      [0, default_initial_window_size, max_window_size, is_window_overflow],
    octets_per_setting = 6;
   function serialize_key(param){
    switch(param[0]){
      case 0:
       return 1;
      case 1:
       return 2;
      case 2:
       return 3;
      case 3:
       return 4;
      case 4:
       return 5;
      default: return 6;
    }
   }
   function check_value(is_client, param){
    switch(param[0]){
      case 1:
       var v = param[1];
       if(0 !== v && 1 !== v) return _d_;
       if(is_client && 1 === v) return _b_;
       return _c_;
      case 3:
       var v$0 = param[1];
       if(caml_call1(WindowSize[3], v$0))
        return [1, [0, 3, caml_call2(Stdlib_Format[140], _e_, WindowSize[2])]];
       break;
      case 4:
       var v$1 = param[1];
       if(16384 <= v$1 && 16777215 >= v$1) break;
       return _f_;
    }
    return _a_;
   }
   function check_settings_list(opt, settings){
    if(opt) var sth = opt[1], is_client = sth; else var is_client = 0;
    var param = settings;
    for(;;){
     if(! param) return _g_;
     var xs = param[2], x = param[1], err = check_value(is_client, x);
     if(0 !== err[0]) return err;
     var param = xs;
    }
   }
   var default$0 = [0, 4096, 1, Stdlib_Int32[9], WindowSize[1], 16384, 0];
   function settings_for_the_connection(settings){
    var
     settings_list =
       settings[5] !== default$0[5] ? [0, [4, settings[5]], 0] : 0,
     settings_list$0 =
       caml_notequal(settings[3], default$0[3])
        ? [0, [2, settings[3]], settings_list]
        : settings_list,
     settings_list$1 =
       caml_notequal(settings[4], default$0[4])
        ? [0, [3, settings[4]], settings_list$0]
        : settings_list$0;
    if(settings[2] !== default$0[2])
     var
      _w_ = settings[2] ? 1 : 0,
      settings_list$2 = [0, [1, _w_], settings_list$1];
    else
     var settings_list$2 = settings_list$1;
    return settings_list$2;
   }
   function parse_settings_payload(num_settings){
    function parse_inner(acc, remaining){
     if(0 < remaining){
      var
       _q_ = function(acc){return parse_inner(acc, remaining - 1 | 0);},
       _r_ = Angstrom[32][5],
       _s_ = Angstrom[32][7],
       _t_ =
         function(k, v){
          var switcher = k - 1 | 0;
          if(5 < switcher >>> 0) return acc;
          switch(switcher){
            case 0:
             return [0, [0, v], acc];
            case 1:
             return [0, [1, v], acc];
            case 2:
             return [0, [2, v], acc];
            case 3:
             return [0, [3, v], acc];
            case 4:
             return [0, [4, v], acc];
            default: return [0, [5, v], acc];
          }
         },
       _u_ = caml_call3(Angstrom[61], _t_, _s_, _r_);
      return caml_call2(Angstrom[53], _u_, _q_);
     }
     var _v_ = caml_call1(Stdlib_List[10], acc);
     return caml_call1(Angstrom[51], _v_);
    }
    return parse_inner(0, num_settings);
   }
   function write_settings_payload(t, settings_list){
    function _o_(setting){
     var _p_ = serialize_key(setting);
     caml_call2(Faraday[9][1], t, _p_);
     switch(setting[0]){
       case 2:
       case 3:
        var value$0 = setting[1];
        return caml_call2(Faraday[9][2], t, value$0);
       default:
        var value = setting[1]; return caml_call2(Faraday[9][2], t, value);
     }
    }
    return caml_call2(Stdlib_List[18], _o_, settings_list);
   }
   function of_settings_list(settings){
    function _n_(acc, item){
     switch(item[0]){
       case 0:
        var x = item[1];
        return [0, x, acc[2], acc[3], acc[4], acc[5], acc[6]];
       case 1:
        var x$0 = item[1];
        return [0, acc[1], 1 === x$0 ? 1 : 0, acc[3], acc[4], acc[5], acc[6]];
       case 2:
        var x$1 = item[1];
        return [0, acc[1], acc[2], x$1, acc[4], acc[5], acc[6]];
       case 3:
        var new_val = item[1];
        return [0, acc[1], acc[2], acc[3], new_val, acc[5], acc[6]];
       case 4:
        var x$2 = item[1];
        return [0, acc[1], acc[2], acc[3], acc[4], x$2, acc[6]];
       default:
        var x$3 = item[1];
        return [0, acc[1], acc[2], acc[3], acc[4], acc[5], [0, x$3]];
     }
    }
    return caml_call3(Stdlib_List[26], _n_, default$0, settings);
   }
   function of_base64(encoded){
    var match = caml_call5(Base64[8], 0, [0, Base64[2]], 0, 0, encoded);
    if(0 !== match[0]){var msg = match[1][2]; return [1, msg];}
    var
     settings_payload = match[1],
     settings_payload_length =
       runtime.caml_ml_string_length(settings_payload) / 6 | 0,
     _m_ = parse_settings_payload(settings_payload_length),
     e = caml_call3(Angstrom[75], 1, _m_, settings_payload);
    if(0 !== e[0]) return e;
    var settings = e[1];
    return [0, of_settings_list(settings)];
   }
   function to_base64(t){
    var
     settings = settings_for_the_connection(t),
     _l_ = caml_call1(Stdlib_List[1], settings) * 6 | 0,
     faraday = caml_call1(Faraday[1], _l_);
    write_settings_payload(faraday, settings);
    var
     settings_hex = caml_call1(Faraday[25], faraday),
     match = caml_call5(Base64[9], 0, [0, Base64[2]], 0, 0, settings_hex);
    if(0 === match[0]){var r = match[1]; return [0, r];}
    var msg = match[1][2];
    return [1, msg];
   }
   function pp_hum(formatter, t){
    function pp_elem(formatter, setting){
     switch(setting[0]){
       case 0:
        var
         v = setting[1],
         value = caml_int64_of_int32(v),
         key$0 = cst_HEADER_TABLE_SIZE;
        break;
       case 1:
        var
         v$0 = setting[1],
         value = caml_int64_of_int32(v$0),
         key$0 = cst_ENABLE_PUSH;
        break;
       case 2:
        var
         v$1 = setting[1],
         value = caml_int64_of_int32(v$1),
         key$0 = cst_MAX_CONCURRENT_STREAMS;
        break;
       case 3:
        var
         v$2 = setting[1],
         value = caml_int64_of_int32(v$2),
         key$0 = cst_INITIAL_WINDOW_SIZE;
        break;
       case 4:
        var
         v$3 = setting[1],
         value = caml_int64_of_int32(v$3),
         key$0 = cst_MAX_FRAME_SIZE;
        break;
       default:
        var
         v$4 = setting[1],
         value$0 = caml_int64_of_int32(v$4),
         value = value$0,
         key$0 = key;
     }
     return caml_call4(Stdlib_Format[137], formatter, _h_, key$0, value);
    }
    caml_call2(Stdlib_Format[137], formatter, _i_);
    var _k_ = settings_for_the_connection(t);
    caml_call4(Stdlib_Format[130], 0, pp_elem, formatter, _k_);
    return caml_call2(Stdlib_Format[137], formatter, _j_);
   }
   var
    Dream_h2_Settings =
      [0,
       WindowSize,
       octets_per_setting,
       serialize_key,
       check_value,
       check_settings_list,
       default$0,
       settings_for_the_connection,
       parse_settings_payload,
       write_settings_payload,
       of_settings_list,
       of_base64,
       to_base64,
       pp_hum];
   runtime.caml_register_global(24, Dream_h2_Settings, "Dream_h2__Settings");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Config
//# unitInfo: Requires: Dream_h2__Settings
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Dream_h2_Settings = global_data.Dream_h2__Settings,
    default$0 =
      [0,
       Dream_h2_Settings[6][5],
       4096,
       4096,
       1,
       Dream_h2_Settings[6][3],
       134217728];
   function to_settings(param){
    var
     initial_window_size = param[6],
     max_concurrent_streams = param[5],
     enable_server_push = param[4],
     read_buffer_size = param[1],
     _a_ = Dream_h2_Settings[6];
    return [0,
            _a_[1],
            enable_server_push,
            max_concurrent_streams,
            initial_window_size,
            read_buffer_size,
            _a_[6]];
   }
   var Dream_h2_Config = [0, default$0, to_settings];
   runtime.caml_register_global(2, Dream_h2_Config, "Dream_h2__Config");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Flags
//# unitInfo: Requires: Dream_h2__Util
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_h2_Util = global_data.Dream_h2__Util,
    default_flags = 0;
   function test_end_stream(x){return caml_call2(Dream_h2_Util[2], x, 0);}
   function set_end_stream(x){return caml_call2(Dream_h2_Util[3], x, 0);}
   function clear_end_stream(x){return caml_call2(Dream_h2_Util[5], x, 0);}
   function test_ack(x){return caml_call2(Dream_h2_Util[2], x, 0);}
   function set_ack(x){return caml_call2(Dream_h2_Util[3], x, 0);}
   function test_end_header(x){return caml_call2(Dream_h2_Util[2], x, 2);}
   function set_end_header(x){return caml_call2(Dream_h2_Util[3], x, 2);}
   function test_padded(x){return caml_call2(Dream_h2_Util[2], x, 3);}
   function set_padded(x){return caml_call2(Dream_h2_Util[3], x, 3);}
   function test_priority(x){return caml_call2(Dream_h2_Util[2], x, 5);}
   function set_priority(x){return caml_call2(Dream_h2_Util[3], x, 5);}
   var
    Dream_h2_Flags =
      [0,
       default_flags,
       test_end_stream,
       set_end_stream,
       clear_end_stream,
       test_ack,
       set_ack,
       test_end_header,
       set_end_header,
       test_padded,
       set_padded,
       test_priority,
       set_priority];
   runtime.caml_register_global(1, Dream_h2_Flags, "Dream_h2__Flags");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Priority
//# unitInfo: Requires: Dream_h2__Util, Stdlib__Int32
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    default_priority = [0, 0, 0, 16],
    highest_priority = [0, 0, 0, 256],
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Dream_h2_Util = global_data.Dream_h2__Util;
   function test_exclusive(n){return caml_call2(Dream_h2_Util[1], n, 31);}
   function set_exclusive(n){return caml_call2(Dream_h2_Util[4], n, 31);}
   function clear_exclusive(n){return caml_call2(Dream_h2_Util[6], n, 31);}
   function equal(p1, p2){
    var _a_ = p1[3] === p2[3] ? 1 : 0;
    if(_a_)
     var
      _b_ = caml_call2(Stdlib_Int32[17], p1[2], p2[2]),
      _c_ = _b_ ? p1[1] === p2[1] ? 1 : 0 : _b_;
    else
     var _c_ = _a_;
    return _c_;
   }
   var
    Dream_h2_Priority =
      [0,
       default_priority,
       highest_priority,
       test_exclusive,
       set_exclusive,
       clear_exclusive,
       equal];
   runtime.caml_register_global(4, Dream_h2_Priority, "Dream_h2__Priority");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Frame
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    connection_preface = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n";
   function serialize(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return 0;
       case 1:
        return 1;
       case 2:
        return 2;
       case 3:
        return 3;
       case 4:
        return 4;
       case 5:
        return 5;
       case 6:
        return 6;
       case 7:
        return 7;
       case 8:
        return 8;
       default: return 9;
     }
    var x = param[1];
    return x;
   }
   function parse(x){
    if(9 < x >>> 0) return [0, x];
    switch(x){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      case 3:
       return 3;
      case 4:
       return 4;
      case 5:
       return 5;
      case 6:
       return 6;
      case 7:
       return 7;
      case 8:
       return 8;
      default: return 9;
    }
   }
   var
    FrameType = [0, serialize, parse],
    Dream_h2_Frame = [0, connection_preface, FrameType];
   runtime.caml_register_global(1, Dream_h2_Frame, "Dream_h2__Frame");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Headers
//# unitInfo: Requires: Dream_httpaf___Httpaf, Stdlib, Stdlib__Buffer, Stdlib__Format, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$7 = "",
    cst$8 = "\r\n",
    cst$9 = ":",
    cst_authority$1 = ":authority",
    cst_method$1 = ":method",
    cst_path$1 = ":path",
    cst_scheme$0 = ":scheme",
    cst_connection$1 = "connection",
    cst_host$1 = "host",
    cst_https = "https",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$4 = ": ",
    cst$5 = cst$8,
    cst$6 = cst$8,
    cst$2 = cst$7,
    cst$3 = cst$7,
    cst$1 = cst$9,
    cst$0 = cst$9,
    cst = cst$9,
    reserved_request =
      [0,
       cst_method$1,
       [0, cst_scheme$0, [0, cst_authority$1, [0, cst_path$1, 0]]]],
    reserved_response = [0, ":status", 0],
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Stdlib = global_data.Stdlib,
    _d_ =
      [0,
       [18,
        [1, [0, 0, cst$7]],
        [12, 40, [3, 0, [12, 32, [3, 0, [12, 41, [17, 0, 0]]]]]]],
       "@[(%S %S)@]"],
    _e_ = [0, [18, [1, [0, 0, cst$7]], [12, 40, 0]], "@[("],
    _f_ = [0, [12, 41, [17, 0, 0]], ")@]"],
    cst_host$0 = cst_host$1,
    cst_connection$0 = cst_connection$1,
    cst_host = cst_host$1,
    _b_ = [0, [0, cst_scheme$0, cst_https], 0],
    cst_path$0 = cst_path$1,
    cst_method$0 = cst_method$1,
    cst_authority$0 = cst_authority$1,
    _c_ = [1, "Missing `Host` header field"],
    cst_http2_settings = "http2-settings",
    cst_upgrade = "upgrade",
    cst_method = "method",
    cst_scheme = "scheme",
    cst_path = "path",
    cst_authority = cst_authority$1,
    _a_ = [0, 0],
    cst_connection = cst_connection$1,
    cst_TE = "TE",
    cst_Dream_h2_Headers_Local = "Dream_h2.Headers.Local",
    empty = 0;
   function of_rev_list(hs){
    function _Y_(param){
     var value = param[2], name = param[1];
     return [0, name, value, 0];
    }
    return caml_call2(Stdlib_List[20], _Y_, hs);
   }
   function of_list(t){return of_rev_list(caml_call1(Stdlib_List[10], t));}
   function to_rev_list(t){
    function _X_(param){
     var value = param[2], name = param[1];
     return [0, name, value];
    }
    return caml_call2(Stdlib_List[20], _X_, t);
   }
   function to_list(t){
    var _W_ = to_rev_list(t);
    return caml_call1(Stdlib_List[10], _W_);
   }
   function to_hpack_list(t){return caml_call1(Stdlib_List[10], t);}
   var Local = [248, cst_Dream_h2_Headers_Local, runtime.caml_fresh_oo_id(0)];
   function char_is_upper(c){
    var _U_ = 65 <= c ? 1 : 0, _V_ = _U_ ? c <= 90 ? 1 : 0 : _U_;
    return _V_;
   }
   function lower(c){return char_is_upper(c) ? c + 32 | 0 : c;}
   function equal(x, y){
    var
     len = caml_ml_string_length(x),
     _M_ = len === caml_ml_string_length(y) ? 1 : 0;
    if(_M_){
     try{
      var _P_ = len - 1 | 0, _O_ = 0;
      if(_P_ >= 0){
       var i = _O_;
       for(;;){
        var
         c1 = caml_string_unsafe_get(x, i),
         c2 = caml_string_unsafe_get(y, i);
        if(c1 !== c2){
         var _S_ = lower(c2);
         if(lower(c1) !== _S_) throw caml_maybe_attach_backtrace(Local, 1);
        }
        var _R_ = i + 1 | 0;
        if(_P_ === i) break;
        var i = _R_;
       }
      }
     }
     catch(_T_){
      var _N_ = caml_wrap_exception(_T_);
      if(_N_ === Local) return 0;
      throw caml_maybe_attach_backtrace(_N_, 0);
     }
     var _Q_ = 1;
    }
    else
     var _Q_ = _M_;
    return _Q_;
   }
   function is_lowercase(x){
    var len = caml_ml_string_length(x);
    try{
     var _J_ = len - 1 | 0, _I_ = 0;
     if(_J_ >= 0){
      var i = _I_;
      for(;;){
       var c1 = caml_string_unsafe_get(x, i);
       if(char_is_upper(c1)) throw caml_maybe_attach_backtrace(Local, 1);
       var _K_ = i + 1 | 0;
       if(_J_ === i) break;
       var i = _K_;
      }
     }
    }
    catch(_L_){
     var _H_ = caml_wrap_exception(_L_);
     if(_H_ === Local) return 0;
     throw caml_maybe_attach_backtrace(_H_, 0);
    }
    return 1;
   }
   var CI = [0, char_is_upper, lower, equal, is_lowercase];
   function mem(t, name){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var
      t$1 = t$0[2],
      name$0 = t$0[1][1],
      _G_ = caml_call2(CI[3], name, name$0);
     if(_G_) return _G_;
     var t$0 = t$1;
    }
   }
   function add(t, opt, name, value){
    if(opt) var sth = opt[1], sensitive = sth; else var sensitive = 0;
    return [0, [0, name, value, sensitive], t];
   }
   function add_list(t, ls){
    var _F_ = of_rev_list(ls);
    return caml_call2(Stdlib[37], _F_, t);
   }
   function add_multi(t, lss){
    var t$0 = t, lss$0 = lss;
    for(;;){
     if(! lss$0) return t$0;
     var
      lss$1 = lss$0[2],
      match = lss$0[1],
      vs = match[2],
      n = match[1],
      t$1 = t$0,
      vs$0 = vs;
     for(;;){
      if(! vs$0) break;
      var
       vs$1 = vs$0[2],
       v = vs$0[1],
       t$2 = [0, [0, n, v, 0], t$1],
       t$1 = t$2,
       vs$0 = vs$1;
     }
     var t$0 = t$1, lss$0 = lss$1;
    }
   }
   function add_unless_exists(t, opt, name, value){
    if(opt) var sth = opt[1], sensitive = sth; else var sensitive = 0;
    return mem(t, name) ? t : [0, [0, name, value, sensitive], t];
   }
   function replace(t, opt, name, value){
    if(opt) var sth = opt[1], sensitive = sth; else var sensitive = 0;
    function loop(t, n, nv, seen){
     var t$0 = t, seen$0 = seen;
     for(;;){
      if(! t$0){
       if(seen$0) return 0;
       throw caml_maybe_attach_backtrace(Local, 1);
      }
      var t$1 = t$0[2], nv$0 = t$0[1], n$0 = nv$0[1];
      if(! caml_call2(CI[3], n, n$0))
       return [0, nv$0, loop(t$1, n, nv, seen$0)];
      if(! seen$0) return [0, nv, loop(t$1, n, nv, 1)];
      var t$0 = t$1, seen$0 = 1;
     }
    }
    try{var _D_ = loop(t, name, [0, name, value, sensitive], 0); return _D_;}
    catch(_E_){
     var _C_ = caml_wrap_exception(_E_);
     if(_C_ === Local) return t;
     throw caml_maybe_attach_backtrace(_C_, 0);
    }
   }
   function remove(t, name){
    function loop(s, n, seen){
     var s$0 = s, seen$0 = seen;
     for(;;){
      if(! s$0){
       if(seen$0) return 0;
       throw caml_maybe_attach_backtrace(Local, 1);
      }
      var s$1 = s$0[2], nv = s$0[1], n$0 = nv[1];
      if(! caml_call2(CI[3], n, n$0)) return [0, nv, loop(s$1, n, seen$0)];
      var s$0 = s$1, seen$0 = 1;
     }
    }
    try{var _A_ = loop(t, name, 0); return _A_;}
    catch(_B_){
     var _z_ = caml_wrap_exception(_B_);
     if(_z_ === Local) return t;
     throw caml_maybe_attach_backtrace(_z_, 0);
    }
   }
   function get(t, name){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var t$1 = t$0[2], match = t$0[1], value = match[2], n = match[1];
     if(caml_call2(CI[3], name, n)) return [0, value];
     var t$0 = t$1;
    }
   }
   function get_exn(t, name){
    var t$0 = t;
    for(;;){
     if(! t$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var t$1 = t$0[2], match = t$0[1], value = match[2], n = match[1];
     if(caml_call2(CI[3], name, n)) return value;
     var t$0 = t$1;
    }
   }
   function get_pseudo(t, name){
    return get(t, caml_call2(Stdlib[28], cst, name));
   }
   function get_pseudo_exn(t, name){
    return get_exn(t, caml_call2(Stdlib[28], cst$0, name));
   }
   function get_multi(t, name){
    var t$0 = t, acc = 0;
    for(;;){
     if(! t$0) return acc;
     var t$1 = t$0[2], match = t$0[1], value = match[2], n = match[1];
     if(caml_call2(CI[3], name, n))
      var acc$0 = [0, value, acc], t$0 = t$1, acc = acc$0;
     else
      var t$0 = t$1;
    }
   }
   function get_multi_pseudo(t, name){
    return get_multi(t, caml_call2(Stdlib[28], cst$1, name));
   }
   function is_pseudo(name){
    return 58 === caml_string_unsafe_get(name, 0) ? 1 : 0;
   }
   var Pseudo = [0, reserved_request, reserved_response, is_pseudo];
   function iter(f, t){
    function _y_(param){
     var value = param[2], name = param[1];
     return caml_call2(f, name, value);
    }
    return caml_call2(Stdlib_List[18], _y_, t);
   }
   function fold(f, init, t){
    function _x_(acc, param){
     var value = param[2], name = param[1];
     return caml_call3(f, name, value, acc);
    }
    return caml_call3(Stdlib_List[26], _x_, init, t);
   }
   function exists(f, t){
    function _w_(param){
     var value = param[2], name = param[1];
     return caml_call2(f, name, value);
    }
    return caml_call2(Stdlib_List[34], _w_, t);
   }
   function valid_headers(opt, t){
    if(opt) var sth = opt[1], is_request = sth; else var is_request = 1;
    var match = get(t, cst_connection), match$0 = get(t, cst_TE);
    if(match) return 0;
    if(match$0){
     var value = match$0[1];
     if(caml_string_notequal(value, "trailers")) return 0;
    }
    var
     pseudo_ended = [0, 0],
     _p_ = to_hpack_list(t),
     invalid =
       exists
        (function(name, param){
          var
           is_pseudo = caml_call1(Pseudo[3], name),
           pseudo_did_end = pseudo_ended[1],
           _q_ = 1 - is_pseudo,
           _r_ = _q_ ? 1 - pseudo_did_end : _q_;
          if(_r_) pseudo_ended[1] = 1;
          var _s_ = 1 - caml_call1(CI[4], name);
          if(_s_)
           var _t_ = _s_;
          else{
           if(is_pseudo)
            var
             _u_ = is_request ? Pseudo[1] : Pseudo[2],
             _v_ = 1 - caml_call2(Stdlib_List[37], name, _u_);
           else
            var _v_ = is_pseudo;
           var _t_ = _v_ || (is_pseudo ? pseudo_did_end : is_pseudo);
          }
          return _t_;
         },
         _p_);
    return 1 - invalid;
   }
   function valid_request_headers(t){return valid_headers(0, t);}
   function valid_response_headers(t){return valid_headers(_a_, t);}
   function method_path_and_scheme_or_malf(t){
    var
     match = get_multi_pseudo(t, cst_method),
     match$0 = get_multi_pseudo(t, cst_scheme),
     match$1 = get_multi_pseudo(t, cst_path);
    a:
    if(match$0){
     var _o_ = match$0[1];
     if
      (caml_string_notequal(_o_, "http")
       && caml_string_notequal(_o_, cst_https))
      break a;
     if(! match$0[2] && match$1 && ! match$1[2]){
      var path$0 = match$1[1];
      if(0 === caml_ml_string_length(path$0)) return 659980059;
     }
    }
    if(match){
     var meth = match[1];
     if(caml_string_notequal(meth, "CONNECT")){
      if(! match[2] && match$0 && ! match$0[2] && match$1 && ! match$1[2]){
       var path = match$1[1], scheme = match$0[1];
       return valid_request_headers(t)
               ? [0, -991566628, [0, meth, path, scheme]]
               : 659980059;
      }
     }
     else if(! match[2]){
      if(! match$0 && ! match$1)
       return mem(t, cst_authority)
               ? [0, -991566628, [0, meth, cst$3, cst$2]]
               : 659980059;
      return 659980059;
     }
    }
    return 659980059;
   }
   function trailers_valid(t){
    var
     invalid =
       exists
        (function(name, param){
          var _n_ = 1 - caml_call1(CI[4], name);
          return _n_ ? _n_ : caml_call1(Pseudo[3], name);
         },
         t);
    return 1 - invalid;
   }
   function is_valid_h2c_connection(connection){
    var
     values = caml_call2(Stdlib_String[17], 44, connection),
     values$0 = caml_call2(Stdlib_List[20], Stdlib_String[24], values);
    function _l_(x){return caml_call2(CI[3], x, cst_upgrade);}
    var match = caml_call2(Stdlib_List[40], _l_, values$0);
    function _m_(x){return caml_call2(CI[3], x, cst_http2_settings);}
    var match$0 = caml_call2(Stdlib_List[40], _m_, values$0);
    if(match && match$0) return 1;
    return 0;
   }
   function of_http1(param){
    var
     headers = param[4],
     target = param[2],
     meth = param[1],
     match = caml_call2(Dream_httpaf_Httpaf[4][13], headers, cst_host);
    if(! match) return _c_;
    var
     host = match[1],
     _j_ =
       [0,
        [0, cst_authority$0, host],
        [0,
         [0, cst_method$0, caml_call1(Dream_httpaf_Httpaf[2][4], meth)],
         [0, [0, cst_path$0, target], _b_]]];
    function _k_(name, value, acc){
     if
      (!
       caml_call2(CI[3], name, cst_host$0)
       && ! caml_call2(CI[3], name, cst_connection$0)){
      var
       name$0 =
         caml_call1(CI[4], name) ? name : caml_call1(Stdlib_String[27], name);
      return [0, [0, name$0, value], acc];
     }
     return acc;
    }
    var headers$0 = caml_call3(Dream_httpaf_Httpaf[4][17], _k_, _j_, headers);
    return [0, of_rev_list(headers$0)];
   }
   function to_string(t){
    var b = caml_call1(Stdlib_Buffer[1], 128), _h_ = to_list(t);
    function _i_(param){
     var value = param[2], name = param[1];
     caml_call2(Stdlib_Buffer[16], b, name);
     caml_call2(Stdlib_Buffer[16], b, cst$4);
     caml_call2(Stdlib_Buffer[16], b, value);
     return caml_call2(Stdlib_Buffer[16], b, cst$5);
    }
    caml_call2(Stdlib_List[18], _i_, _h_);
    caml_call2(Stdlib_Buffer[16], b, cst$6);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function pp_hum(fmt, t){
    function pp_elem(fmt, param){
     var value = param[2], name = param[1];
     return caml_call4(Stdlib_Format[137], fmt, _d_, name, value);
    }
    caml_call2(Stdlib_Format[137], fmt, _e_);
    var _g_ = to_list(t);
    caml_call4(Stdlib_Format[130], 0, pp_elem, fmt, _g_);
    return caml_call2(Stdlib_Format[137], fmt, _f_);
   }
   var
    Dream_h2_Headers =
      [0,
       empty,
       of_rev_list,
       of_list,
       to_rev_list,
       to_list,
       to_hpack_list,
       Local,
       CI,
       mem,
       add,
       add_list,
       add_multi,
       add_unless_exists,
       replace,
       remove,
       get,
       get_exn,
       get_pseudo,
       get_pseudo_exn,
       get_multi,
       get_multi_pseudo,
       Pseudo,
       iter,
       fold,
       exists,
       valid_headers,
       valid_request_headers,
       valid_response_headers,
       method_path_and_scheme_or_malf,
       trailers_valid,
       is_valid_h2c_connection,
       of_http1,
       to_string,
       pp_hum];
   runtime.caml_register_global(41, Dream_h2_Headers, "Dream_h2__Headers");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Message
//# unitInfo: Requires: Dream_h2__Headers, Stdlib__Int64, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_h2_Headers = global_data.Dream_h2__Headers,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    cst_content_length = "content-length",
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _a_ = [0, 106380200, -99004555];
   function content_length_of_string(s){
    a:
    {
     try{var len = runtime.caml_int64_of_string(s);}catch(_d_){break a;}
     if(0 <= caml_call2(Stdlib_Int64[15], len, _b_))
      return [0, 332360020, len];
    }
    return _a_;
   }
   function body_length(headers){
    var match = caml_call2(Dream_h2_Headers[20], headers, cst_content_length);
    if(! match) return 785140586;
    var hd = match[1];
    if(! match[2]) return content_length_of_string(hd);
    var tl = match[2], _c_ = caml_call1(Stdlib_String[9], hd);
    return caml_call2(Stdlib_List[33], _c_, tl)
            ? content_length_of_string(hd)
            : 785140586;
   }
   var Dream_h2_Message = [0, content_length_of_string, body_length];
   runtime.caml_register_global(7, Dream_h2_Message, "Dream_h2__Message");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Optional_thunk
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    cst_Optional_thunk_this_functi =
      "Optional_thunk: this function is not representable as a some value";
   function none(param){return 0;}
   function some(f){
    if(f === none) caml_call1(Stdlib[2], cst_Optional_thunk_this_functi);
    return f;
   }
   function is_none(t){return t === none ? 1 : 0;}
   function is_some(t){return 1 - is_none(t);}
   function call_if_some(t){return caml_call1(t, 0);}
   function unchecked_value(t){return t;}
   var
    Dream_h2_Optional_thunk =
      [0, none, some, is_none, is_some, call_if_some, unchecked_value];
   runtime.caml_register_global
    (2, Dream_h2_Optional_thunk, "Dream_h2__Optional_thunk");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Request
//# unitInfo: Requires: Dream_h2__Headers, Dream_h2__Message, Dream_httpaf___Httpaf, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_h2_Headers = global_data.Dream_h2__Headers,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Stdlib_Format = global_data.Stdlib__Format,
    Dream_h2_Message = global_data.Dream_h2__Message,
    _a_ =
      [0,
       [11,
        '((method "',
        [15,
         [11,
          '") (target ',
          [3,
           0,
           [11,
            ") (scheme ",
            [3, 0, [11, ") (headers ", [15, [11, "))", 0]]]]]]]]],
       '((method "%a") (target %S) (scheme %S) (headers %a))'];
   function create(opt, scheme, meth, target){
    if(opt)
     var sth = opt[1], headers = sth;
    else
     var headers = Dream_h2_Headers[1];
    return [0, meth, target, scheme, headers];
   }
   function body_length(param){
    var headers = param[4];
    return caml_call1(Dream_h2_Message[2], headers);
   }
   function pp_hum(fmt, param){
    var
     headers = param[4],
     scheme = param[3],
     target = param[2],
     meth = param[1];
    return caml_call8
            (Stdlib_Format[137],
             fmt,
             _a_,
             Dream_httpaf_Httpaf[2][6],
             meth,
             target,
             scheme,
             Dream_h2_Headers[34],
             headers);
   }
   var Dream_h2_Request = [0, create, body_length, pp_hum];
   runtime.caml_register_global(5, Dream_h2_Request, "Dream_h2__Request");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Status
//# unitInfo: Requires: Dream_httpaf___Httpaf, Stdlib, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    _a_ = [0, [4, 12, 0, 0, 0], "%u"],
    cst_421 = "421",
    cst_Misdirected_Request = "Misdirected Request";
   function default_reason_phrase(t){
    return 391391247 === t
            ? cst_Misdirected_Request
            : caml_call1(Dream_httpaf_Httpaf[3][1], t);
   }
   function to_code(t){
    if(typeof t === "number" && 391391247 === t) return 421;
    return caml_call1(Dream_httpaf_Httpaf[3][2], t);
   }
   function unsafe_of_code(c){
    return 421 === c ? 391391247 : caml_call1(Dream_httpaf_Httpaf[3][4], c);
   }
   function of_code(c){
    return 421 === c ? 391391247 : caml_call1(Dream_httpaf_Httpaf[3][3], c);
   }
   function is_informational(t){
    if(typeof t === "number" && 391391247 === t) return 0;
    return caml_call1(Dream_httpaf_Httpaf[3][5], t);
   }
   function is_successful(t){
    if(typeof t === "number" && 391391247 === t) return 0;
    return caml_call1(Dream_httpaf_Httpaf[3][6], t);
   }
   function is_redirection(t){
    if(typeof t === "number" && 391391247 === t) return 0;
    return caml_call1(Dream_httpaf_Httpaf[3][7], t);
   }
   function is_client_error(t){
    if(typeof t === "number" && 391391247 === t) return 1;
    return caml_call1(Dream_httpaf_Httpaf[3][8], t);
   }
   function is_server_error(t){
    if(typeof t === "number" && 391391247 === t) return 0;
    return caml_call1(Dream_httpaf_Httpaf[3][9], t);
   }
   function is_error(t){
    if(typeof t === "number" && 391391247 === t) return 1;
    return caml_call1(Dream_httpaf_Httpaf[3][10], t);
   }
   function to_string(t){
    if(typeof t === "number" && 391391247 === t) return cst_421;
    return caml_call1(Dream_httpaf_Httpaf[3][11], t);
   }
   function of_string(x){return of_code(runtime.caml_int_of_string(x));}
   function pp_hum(fmt, t){
    var _b_ = to_code(t);
    return caml_call3(Stdlib_Format[137], fmt, _a_, _b_);
   }
   var
    Dream_h2_Status =
      [0,
       default_reason_phrase,
       to_code,
       unsafe_of_code,
       of_code,
       is_informational,
       is_successful,
       is_redirection,
       is_client_error,
       is_server_error,
       is_error,
       to_string,
       of_string,
       pp_hum];
   runtime.caml_register_global(5, Dream_h2_Status, "Dream_h2__Status");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Response
//# unitInfo: Requires: Dream_h2__Headers, Dream_h2__Message, Dream_h2__Status, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_h2_Status = global_data.Dream_h2__Status,
    Dream_h2_Headers = global_data.Dream_h2__Headers,
    Stdlib_Format = global_data.Stdlib__Format,
    Dream_h2_Message = global_data.Dream_h2__Message,
    cst_Non_standard_status_code = "Non-standard status code",
    _b_ =
      [0,
       [11,
        "((status ",
        [15,
         [11, ") (reason ", [3, 0, [11, ") (headers ", [15, [11, "))", 0]]]]]]],
       "((status %a) (reason %S) (headers %a))"],
    _a_ = [0, 332360020, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)];
   function create(opt, status){
    if(opt)
     var sth = opt[1], headers = sth;
    else
     var headers = Dream_h2_Headers[1];
    return [0, status, headers];
   }
   function body_length(request_method, param){
    var headers = param[2];
    return 801894688 === request_method
            ? _a_
            : caml_call1(Dream_h2_Message[2], headers);
   }
   function pp_hum(fmt, param){
    var
     headers = param[2],
     status = param[1],
     reason =
       typeof status === "number"
        ? caml_call1(Dream_h2_Status[1], status)
        : cst_Non_standard_status_code;
    return caml_call7
            (Stdlib_Format[137],
             fmt,
             _b_,
             Dream_h2_Status[13],
             status,
             reason,
             Dream_h2_Headers[34],
             headers);
   }
   var Dream_h2_Response = [0, create, body_length, pp_hum];
   runtime.caml_register_global(7, Dream_h2_Response, "Dream_h2__Response");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Serialize
//# unitInfo: Requires: Bigstringaf, Dream_h2__Config, Dream_h2__Error_code, Dream_h2__Flags, Dream_h2__Frame, Dream_h2__Headers, Dream_h2__Optional_thunk, Dream_h2__Priority, Dream_h2__Settings, Dream_h2__Status, Dream_h2__Stream_identifier, Dream_hpack__Hpack, Dream_httpaf___Httpaf, Faraday, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Faraday = global_data.Faraday,
    Dream_h2_Optional_thunk = global_data.Dream_h2__Optional_thunk,
    Stdlib = global_data.Stdlib,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Dream_h2_Priority = global_data.Dream_h2__Priority,
    Dream_h2_Status = global_data.Dream_h2__Status,
    Dream_hpack_Hpack = global_data.Dream_hpack__Hpack,
    Dream_h2_Headers = global_data.Dream_h2__Headers,
    Stdlib_List = global_data.Stdlib__List,
    Dream_h2_Flags = global_data.Dream_h2__Flags,
    Bigstringaf = global_data.Bigstringaf,
    Dream_h2_Stream_identifier = global_data.Dream_h2__Stream_identifier,
    Dream_h2_Config = global_data.Dream_h2__Config,
    Dream_h2_Frame = global_data.Dream_h2__Frame,
    Dream_h2_Error_code = global_data.Dream_h2__Error_code,
    Dream_h2_Settings = global_data.Dream_h2__Settings,
    cst_on_wakeup_writer_on_closed = "on_wakeup_writer on closed conn",
    cst_on_wakeup_only_one_callbac =
      "on_wakeup: only one callback can be registered at a time",
    _e_ = [0, 0],
    cst_status = ":status",
    _d_ = [0, 0],
    cst_method = ":method",
    cst_path = ":path",
    cst_scheme = ":scheme",
    _c_ = [0, 0],
    _b_ = [0, 0],
    _a_ = [0, 0];
   function write_uint24(t, n){
    function write_octet(t, o){return caml_call2(Faraday[8], t, o & 255);}
    write_octet(t, n >>> 16 | 0);
    write_octet(t, n >>> 8 | 0);
    return write_octet(t, n);
   }
   function write_frame_header(t, frame_header){
    var
     frame_type = frame_header[4],
     stream_id = frame_header[3],
     flags = frame_header[2],
     payload_length = frame_header[1];
    write_uint24(t, payload_length);
    var _al_ = caml_call1(Dream_h2_Frame[2][1], frame_type);
    caml_call2(Faraday[8], t, _al_);
    caml_call2(Faraday[8], t, flags);
    return caml_call2(Faraday[9][2], t, stream_id);
   }
   function write_frame_with_padding(t, info, frame_type, length, writer){
    if(0 === caml_call1(Bigstringaf[6], info[3]))
     var
      header = [0, length, info[1], info[2], frame_type],
      writer$0 = writer,
      header$0 = header;
    else
     var
      pad_length = caml_call1(Bigstringaf[6], info[3]),
      writer$1 =
        function(t){
         caml_call2(Faraday[8], t, pad_length);
         caml_call1(writer, t);
         return caml_call4(Faraday[11], t, _a_, [0, pad_length], info[3]);
        },
      _ak_ = info[2],
      header$1 =
        [0,
         (length + pad_length | 0) + 1 | 0,
         caml_call1(Dream_h2_Flags[10], info[1]),
         _ak_,
         frame_type],
      writer$0 = writer$1,
      header$0 = header$1;
    write_frame_header(t, header$0);
    return caml_call1(writer$0, t);
   }
   function write_data_frame(t, off, len, info, body){
    function writer(t){return caml_call4(Faraday[3], t, off, len, body);}
    if(len)
     var len$0 = len[1], length = len$0;
    else
     var length = caml_ml_string_length(body);
    return write_frame_with_padding(t, info, 0, length, writer);
   }
   function schedule_data_frame(t, info, off, len, bstr){
    function writer(t){return caml_call4(Faraday[11], t, off, len, bstr);}
    if(len)
     var len$0 = len[1], length = len$0;
    else
     var length = caml_call1(Bigstringaf[6], bstr);
    return write_frame_with_padding(t, info, 0, length, writer);
   }
   function write_priority(t, param){
    var
     weight = param[3],
     stream_dependency = param[2],
     exclusive = param[1],
     stream_dependency_id =
       exclusive
        ? caml_call1(Dream_h2_Priority[4], stream_dependency)
        : stream_dependency;
    caml_call2(Faraday[9][2], t, stream_dependency_id);
    return caml_call2(Faraday[8], t, weight - 1 | 0);
   }
   function bounded_schedule_iovecs(t, remaining, iovecs){
    var remaining$0 = remaining, iovecs$0 = iovecs;
    for(;;){
     if(0 !== remaining$0 && iovecs$0){
      var
       iovecs$1 = iovecs$0[2],
       match = iovecs$0[1],
       len = match[3],
       off = match[2],
       buffer = match[1];
      if(remaining$0 < len)
       return caml_call4(Faraday[11], t, [0, off], [0, remaining$0], buffer);
      caml_call4(Faraday[11], t, [0, off], [0, len], buffer);
      var
       remaining$1 = remaining$0 - len | 0,
       remaining$0 = remaining$1,
       iovecs$0 = iovecs$1;
      continue;
     }
     return 0;
    }
   }
   function write_headers_frame(t, info, priority, len, iovecs){
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(Dream_httpaf_Httpaf[8][2], iovecs);
    if(priority === Dream_h2_Priority[1]){
     var
      writer = function(t){return bounded_schedule_iovecs(t, len$1, iovecs);};
     return write_frame_with_padding(t, info, 1, len$1, writer);
    }
    var
     payload_length = len$1 + 5 | 0,
     _ah_ = info[4],
     _ai_ = info[3],
     _aj_ = info[2],
     info$0 = [0, caml_call1(Dream_h2_Flags[12], info[1]), _aj_, _ai_, _ah_];
    function writer$0(t){
     write_priority(t, priority);
     return bounded_schedule_iovecs(t, len$1, iovecs);
    }
    return write_frame_with_padding(t, info$0, 1, payload_length, writer$0);
   }
   function write_priority_frame(t, info, priority){
    var header = [0, 5, info[1], info[2], 2];
    write_frame_header(t, header);
    return write_priority(t, priority);
   }
   function write_rst_stream_frame(t, info, e){
    var header = [0, 4, info[1], info[2], 3];
    write_frame_header(t, header);
    var _ag_ = caml_call1(Dream_h2_Error_code[1], e);
    return caml_call2(Faraday[9][2], t, _ag_);
   }
   function write_settings_frame(t, info, settings){
    var
     _ae_ = info[2],
     _af_ = info[1],
     header = [0, caml_call1(Stdlib_List[1], settings) * 6 | 0, _af_, _ae_, 4];
    write_frame_header(t, header);
    return caml_call2(Dream_h2_Settings[9], t, settings);
   }
   function write_push_promise_frame(t, info, promised_id, len, iovecs){
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(Dream_httpaf_Httpaf[8][2], iovecs);
    var payload_length = 4 + len$1 | 0;
    function writer(t){
     caml_call2(Faraday[9][2], t, promised_id);
     return bounded_schedule_iovecs(t, len$1, iovecs);
    }
    return write_frame_with_padding(t, info, 5, payload_length, writer);
   }
   var default_ping_payload = caml_call1(Bigstringaf[1], 8), i = 0;
   for(;;){
    runtime.caml_ba_set_1(default_ping_payload, i, 0);
    var _f_ = i + 1 | 0;
    if(7 === i) break;
    var i = _f_;
   }
   function write_ping_frame(t, info, opt, payload){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    var header = [0, 8, info[1], info[2], 6];
    write_frame_header(t, header);
    return caml_call4(Faraday[11], t, [0, off], [0, 8], payload);
   }
   function write_go_away_frame(t, info, stream_id, error_code, debug_data){
    var
     debug_data_len = caml_call1(Bigstringaf[6], debug_data),
     header = [0, 8 + debug_data_len | 0, info[1], info[2], 7];
    write_frame_header(t, header);
    caml_call2(Faraday[9][2], t, stream_id);
    var _ad_ = caml_call1(Dream_h2_Error_code[1], error_code);
    caml_call2(Faraday[9][2], t, _ad_);
    return caml_call4(Faraday[11], t, _b_, [0, debug_data_len], debug_data);
   }
   function write_window_update_frame(t, info, window_size){
    var header = [0, 4, info[1], info[2], 8];
    write_frame_header(t, header);
    return caml_call2(Faraday[9][2], t, window_size);
   }
   function write_continuation_frame(t, info, len, iovecs){
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(Dream_httpaf_Httpaf[8][2], iovecs);
    var header = [0, len$1, info[1], info[2], 9];
    write_frame_header(t, header);
    return bounded_schedule_iovecs(t, len$1, iovecs);
   }
   function write_unknown_frame(t, code, info, payload){
    var
     payload_length = caml_call1(Bigstringaf[6], payload),
     header = [0, payload_length, info[1], info[2], [0, code]];
    write_frame_header(t, header);
    return caml_call4(Faraday[11], t, _c_, [0, payload_length], payload);
   }
   function write_connection_preface(t){
    return caml_call4(Faraday[3], t, 0, 0, Dream_h2_Frame[1]);
   }
   function create(buffer_size){
    var
     buffer = caml_call1(Bigstringaf[1], buffer_size),
     encoder = caml_call1(Faraday[2], buffer);
    return [0, buffer, encoder, 0, Dream_h2_Optional_thunk[1]];
   }
   function faraday(t){return t[2];}
   function make_frame_info(opt, _ac_, _ab_, stream_id){
    if(opt)
     var sth = opt[1], padding = sth;
    else
     var padding = Bigstringaf[2];
    if(_ac_)
     var sth$0 = _ac_[1], flags = sth$0;
    else
     var flags = Dream_h2_Flags[1];
    if(_ab_)
     var sth$1 = _ab_[1], max_frame_size = sth$1;
    else
     var max_frame_size = Dream_h2_Config[1][1];
    return [0, flags, stream_id, padding, max_frame_size];
   }
   function write_connection_preface$0(t, settings_list){
    write_connection_preface(t[2]);
    var frame_info = make_frame_info(0, 0, 0, Dream_h2_Stream_identifier[5]);
    return write_settings_frame(t[2], frame_info, settings_list);
   }
   function chunk_data_frames(opt, f, frame_info, total_length){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    var max_frame_payload = frame_info[4];
    if(max_frame_payload >= total_length)
     return caml_call3(f, off, total_length, frame_info);
    var off$0 = off, remaining = total_length;
    for(;;){
     if(max_frame_payload >= remaining)
      return caml_call3(f, off$0, remaining, frame_info);
     var
      ___ = frame_info[4],
      _$_ = frame_info[3],
      _aa_ = frame_info[2],
      frame_info$0 =
        [0, caml_call1(Dream_h2_Flags[4], frame_info[1]), _aa_, _$_, ___];
     caml_call3(f, off$0, max_frame_payload, frame_info$0);
     var
      remaining$0 = remaining - max_frame_payload | 0,
      off$1 = off$0 + max_frame_payload | 0,
      off$0 = off$1,
      remaining = remaining$0;
    }
   }
   function write_data(t, frame_info, off, len, str){
    var _Z_ = 1 - caml_call1(Faraday[20], t[2]);
    if(! _Z_) return _Z_;
    if(len)
     var len$0 = len[1], total_length = len$0;
    else
     var total_length = caml_ml_string_length(str);
    return chunk_data_frames
            (off,
             function(off, len, frame_info){
              return write_data_frame
                      (t[2], [0, off], [0, len], frame_info, str);
             },
             frame_info,
             total_length);
   }
   function schedule_data(t, frame_info, off, len, bstr){
    var _Y_ = 1 - caml_call1(Faraday[20], t[2]);
    if(! _Y_) return _Y_;
    if(len)
     var len$0 = len[1], total_length = len$0;
    else
     var total_length = caml_call1(Bigstringaf[6], bstr);
    return chunk_data_frames
            (off,
             function(off, len, frame_info){
              return schedule_data_frame
                      (t[2], frame_info, [0, off], [0, len], bstr);
             },
             frame_info,
             total_length);
   }
   function chunk_header_block_fragments
   (t, frame_info, opt, write_frame, faraday){
    if(opt) var sth = opt[1], has_priority = sth; else var has_priority = 0;
    var
     block_size = caml_call1(Faraday[14], faraday),
     total_length = has_priority ? block_size + 5 | 0 : block_size,
     max_frame_payload = frame_info[4];
    if(max_frame_payload >= total_length){
     var
      _U_ = frame_info[4],
      _V_ = frame_info[3],
      _W_ = frame_info[2],
      frame_info$2 =
        [0, caml_call1(Dream_h2_Flags[8], frame_info[1]), _W_, _V_, _U_],
      _X_ =
        function(iovecs){
         var len = caml_call1(Dream_httpaf_Httpaf[8][2], iovecs);
         caml_call4(write_frame, t[2], frame_info$2, [0, len], iovecs);
         return [0, 17724, len];
        };
     caml_call2(Faraday[24], faraday, _X_);
     return 0;
    }
    var
     headers_block_len =
       has_priority ? max_frame_payload - 5 | 0 : max_frame_payload;
    function _O_(iovecs){
     caml_call4(write_frame, t[2], frame_info, [0, headers_block_len], iovecs);
     return [0, 17724, headers_block_len];
    }
    caml_call2(Faraday[24], faraday, _O_);
    var
     remaining$1 = block_size - headers_block_len | 0,
     remaining = remaining$1;
    for(;;){
     if(max_frame_payload >= remaining){
      var
       _Q_ = frame_info[4],
       _R_ = frame_info[3],
       _S_ = frame_info[2],
       frame_info$1 =
         [0, caml_call1(Dream_h2_Flags[8], Dream_h2_Flags[1]), _S_, _R_, _Q_],
       _T_ =
         function(iovecs){
          write_continuation_frame(t[2], frame_info$1, [0, remaining], iovecs);
          return [0, 17724, remaining];
         };
      caml_call2(Faraday[24], faraday, _T_);
      return 0;
     }
     var
      frame_info$0 =
        [0, Dream_h2_Flags[1], frame_info[2], frame_info[3], frame_info[4]],
      _P_ =
        function(frame_info){
          return function(iovecs){
           write_continuation_frame
            (t[2], frame_info, [0, max_frame_payload], iovecs);
           return [0, 17724, max_frame_payload];};
         }
         (frame_info$0);
     caml_call2(Faraday[24], faraday, _P_);
     var
      remaining$0 = remaining - max_frame_payload | 0,
      remaining = remaining$0;
    }
   }
   function encode_headers(hpack_encoder, faraday, headers){
    var _M_ = caml_call1(Dream_h2_Headers[6], headers);
    function _N_(header){
     return caml_call3
             (Dream_hpack_Hpack[1][2], hpack_encoder, faraday, header);
    }
    return caml_call2(Stdlib_List[18], _N_, _M_);
   }
   function write_request_like_frame
   (t, hpack_encoder, write_frame, frame_info, request){
    var
     headers = request[4],
     scheme = request[3],
     target = request[2],
     meth = request[1],
     faraday = caml_call1(Faraday[1], 4096),
     _L_ = [0, cst_method, caml_call1(Dream_httpaf_Httpaf[2][4], meth), 0];
    caml_call3(Dream_hpack_Hpack[1][2], hpack_encoder, faraday, _L_);
    if(357830602 !== meth){
     caml_call3
      (Dream_hpack_Hpack[1][2],
       hpack_encoder,
       faraday,
       [0, cst_path, target, 0]);
     caml_call3
      (Dream_hpack_Hpack[1][2],
       hpack_encoder,
       faraday,
       [0, cst_scheme, scheme, 0]);
    }
    encode_headers(hpack_encoder, faraday, headers);
    return chunk_header_block_fragments
            (t, frame_info, 0, write_frame, faraday);
   }
   function write_request_headers
   (t, hpack_encoder, priority, frame_info, request){
    var _G_ = 1 - caml_call1(Faraday[20], t[2]);
    if(! _G_) return _G_;
    function write_frame(_H_){
     return function(_I_){
      return function(_J_, _K_){
       return write_headers_frame(_H_, _I_, priority, _J_, _K_);};};
    }
    return write_request_like_frame
            (t, hpack_encoder, write_frame, frame_info, request);
   }
   function write_push_promise
   (t, hpack_encoder, frame_info, promised_id, request){
    var _B_ = 1 - caml_call1(Faraday[20], t[2]);
    if(! _B_) return _B_;
    function write_frame(_C_){
     return function(_D_){
      return function(_E_, _F_){
       return write_push_promise_frame(_C_, _D_, promised_id, _E_, _F_);};};
    }
    return write_request_like_frame
            (t, hpack_encoder, write_frame, frame_info, request);
   }
   function write_response_headers(t, hpack_encoder, frame_info, response){
    var _u_ = 1 - caml_call1(Faraday[20], t[2]);
    if(! _u_) return _u_;
    var
     headers = response[2],
     status = response[1],
     faraday = caml_call1(Faraday[1], 4096),
     _v_ = [0, cst_status, caml_call1(Dream_h2_Status[11], status), 0];
    caml_call3(Dream_hpack_Hpack[1][2], hpack_encoder, faraday, _v_);
    encode_headers(hpack_encoder, faraday, headers);
    var _w_ = Dream_h2_Priority[1];
    return chunk_header_block_fragments
            (t,
             frame_info,
             _d_,
             function(_x_){
              return function(_y_){
               return function(_z_, _A_){
                return write_headers_frame(_x_, _y_, _w_, _z_, _A_);};};
             },
             faraday);
   }
   function write_response_trailers(t, hpack_encoder, frame_info, trailers){
    var _o_ = 1 - caml_call1(Faraday[20], t[2]);
    if(! _o_) return _o_;
    var faraday = caml_call1(Faraday[1], 4096);
    encode_headers(hpack_encoder, faraday, trailers);
    var _p_ = Dream_h2_Priority[1];
    return chunk_header_block_fragments
            (t,
             frame_info,
             _e_,
             function(_q_){
              return function(_r_){
               return function(_s_, _t_){
                return write_headers_frame(_q_, _r_, _p_, _s_, _t_);};};
             },
             faraday);
   }
   function write_rst_stream(t, frame_info, e){
    var _n_ = 1 - caml_call1(Faraday[20], t[2]);
    return _n_ ? write_rst_stream_frame(t[2], frame_info, e) : _n_;
   }
   function write_window_update(t, frame_info, n){
    var _m_ = 1 - caml_call1(Faraday[20], t[2]);
    return _m_ ? write_window_update_frame(t[2], frame_info, n) : _m_;
   }
   function schedule_iovecs(t, len, frame_info, iovecs){
    var _k_ = 1 - caml_call1(Faraday[20], t[2]);
    return _k_
            ? chunk_data_frames
              (0,
               function(off, len, frame_info){
                var
                 iovecs$0 = caml_call2(Dream_httpaf_Httpaf[8][4], iovecs, off);
                function _l_(t){
                 return bounded_schedule_iovecs(t, len, iovecs$0);
                }
                return write_frame_with_padding(t[2], frame_info, 0, len, _l_);
               },
               frame_info,
               len)
            : _k_;
   }
   function write_priority$0(t, frame_info, priority){
    var _j_ = 1 - caml_call1(Faraday[20], t[2]);
    return _j_ ? write_priority_frame(t[2], frame_info, priority) : _j_;
   }
   function write_settings(t, frame_info, settings){
    var _i_ = 1 - caml_call1(Faraday[20], t[2]);
    return _i_ ? write_settings_frame(t[2], frame_info, settings) : _i_;
   }
   function write_ping(t, frame_info, off, payload){
    var _h_ = 1 - caml_call1(Faraday[20], t[2]);
    return _h_ ? write_ping_frame(t[2], frame_info, off, payload) : _h_;
   }
   function write_go_away(t, frame_info, debug_data, last_stream_id, error){
    var _g_ = 1 - caml_call1(Faraday[20], t[2]);
    return _g_
            ? write_go_away_frame
              (t[2], frame_info, last_stream_id, error, debug_data)
            : _g_;
   }
   function on_wakeup_writer(t, k){
    return caml_call1(Faraday[20], t[2])
            ? caml_call1(Stdlib[2], cst_on_wakeup_writer_on_closed)
            : caml_call1
               (Dream_h2_Optional_thunk[4], t[4])
              ? caml_call1(Stdlib[2], cst_on_wakeup_only_one_callbac)
              : (t[4] = caml_call1(Dream_h2_Optional_thunk[2], k), 0);
   }
   function wakeup(t){
    var f = t[4];
    t[4] = Dream_h2_Optional_thunk[1];
    return caml_call1(Dream_h2_Optional_thunk[5], f);
   }
   function flush(t, f){return caml_call2(Faraday[16], t[2], f);}
   function unyield(t){return flush(t, function(param){return 0;});}
   function yield$0(t){return caml_call1(Faraday[15], t[2]);}
   function close(t){return caml_call1(Faraday[19], t[2]);}
   function close_and_drain(t){
    caml_call1(Faraday[19], t[2]);
    var drained = caml_call1(Faraday[22], t[2]);
    t[3] = t[3] + drained | 0;
    return 0;
   }
   function is_closed(t){return caml_call1(Faraday[20], t[2]);}
   function drained_bytes(t){return t[3];}
   function report_result(t, result){
    if(typeof result === "number") return close_and_drain(t);
    var len = result[2];
    return caml_call2(Faraday[21], t[2], len);
   }
   function next(t){
    var match = caml_call1(Faraday[23], t[2]);
    if(typeof match === "number")
     return 73271853 <= match ? 73271853 : [0, -611285096, t[3]];
    var iovecs = match[2];
    return [0, -477700929, iovecs];
   }
   var
    Writer =
      [0,
       create,
       faraday,
       make_frame_info,
       write_connection_preface$0,
       chunk_data_frames,
       write_data,
       schedule_data,
       chunk_header_block_fragments,
       encode_headers,
       write_request_like_frame,
       write_request_headers,
       write_push_promise,
       write_response_headers,
       write_response_trailers,
       write_rst_stream,
       write_window_update,
       schedule_iovecs,
       write_priority$0,
       write_settings,
       write_ping,
       write_go_away,
       on_wakeup_writer,
       wakeup,
       flush,
       unyield,
       yield$0,
       close,
       close_and_drain,
       is_closed,
       drained_bytes,
       report_result,
       next],
    Dream_h2_Serialize =
      [0,
       write_uint24,
       write_frame_header,
       write_frame_with_padding,
       write_data_frame,
       schedule_data_frame,
       write_priority,
       bounded_schedule_iovecs,
       write_headers_frame,
       write_priority_frame,
       write_rst_stream_frame,
       write_settings_frame,
       write_push_promise_frame,
       default_ping_payload,
       write_ping_frame,
       write_go_away_frame,
       write_window_update_frame,
       write_continuation_frame,
       write_unknown_frame,
       write_connection_preface,
       Writer];
   runtime.caml_register_global(27, Dream_h2_Serialize, "Dream_h2__Serialize");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Stream
//# unitInfo: Requires: Dream_h2__Serialize
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_h2_Serialize = global_data.Dream_h2__Serialize,
    initial_ttl = 10;
   function create(id, max_frame_size, writer, error_handler, on_close){
    return [0, id, writer, error_handler, 0, 0, max_frame_size, on_close];
   }
   function id(param){var id = param[1]; return id;}
   function is_idle(t){return typeof t[5] === "number" ? 1 : 0;}
   function is_open(t){
    var _b_ = t[5];
    if(typeof _b_ !== "number" && 1 === _b_[0] && 0 === _b_[1][0]) return 1;
    return 0;
   }
   function finish_stream(t, reason){
    var _a_ = t[5];
    a:
    {
     if(typeof _a_ !== "number" && 1 === _a_[0]){var active = 1; break a;}
     var active = 0;
    }
    var closed = [0, reason, initial_ttl];
    caml_call2(t[7], active, closed);
    t[5] = [2, closed];
    return 0;
   }
   function error_code(t){
    var match = t[4];
    if(typeof match === "number") return 0;
    if(0 === match[0]){var exn = match[1]; return [0, [0, 3458171, exn]];}
    var error = match[1];
    return [0, error];
   }
   function error_to_code(error, error_code){
    if(typeof error !== "number" && 3458171 === error[1]){var exn = error[2]; return [0, exn];}
    return [1, error, error_code];
   }
   function reset_stream(t, error_code){
    var frame_info = caml_call4(Dream_h2_Serialize[20][3], 0, 0, 0, t[1]);
    caml_call3(Dream_h2_Serialize[20][15], t[2], frame_info, error_code);
    return finish_stream(t, [0, error_code]);
   }
   var
    Dream_h2_Stream =
      [0,
       initial_ttl,
       create,
       id,
       is_idle,
       is_open,
       finish_stream,
       error_code,
       error_to_code,
       reset_stream];
   runtime.caml_register_global(1, Dream_h2_Stream, "Dream_h2__Stream");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Body
//# unitInfo: Requires: Bigstringaf, Dream_h2__Serialize, Dream_httpaf___Httpaf, Faraday, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Faraday = global_data.Faraday,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Dream_h2_Serialize = global_data.Dream_h2__Serialize,
    Bigstringaf = global_data.Bigstringaf,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    _a_ = [0, "src/vendor/h2/lib/body.ml", 77, 20],
    cst_Body_schedule_read_reader_ =
      "Body.schedule_read: reader already scheduled";
   function default_done_reading(param){return 0;}
   function default_on_eof(param){return 0;}
   function default_on_read(param, _g_, _f_){return 0;}
   function create(buffer, done_reading){
    return [0,
            caml_call1(Faraday[2], buffer),
            0,
            default_on_eof,
            default_on_read,
            [0, 0],
            done_reading];
   }
   function create_empty(param){
    var t = create(Bigstringaf[2], default_done_reading);
    caml_call1(Faraday[19], t[1]);
    return t;
   }
   var empty = create_empty(0);
   function is_closed(t){return caml_call1(Faraday[20], t[1]);}
   function unsafe_faraday(t){return t[1];}
   function do_execute_read$0(counter, t, on_eof, on_read){
    var match = caml_call1(Faraday[23], t[1]);
    if(typeof match === "number")
     return 73271853 <= match
             ? 0
             : (t
                [2]
               = 0,
               t[3] = default_on_eof,
               t[4] = default_on_read,
               caml_call1(on_eof, 0));
    var match$0 = match[2];
    if(! match$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var iovec = match$0[1];
    t[2] = 0;
    t[3] = default_on_eof;
    t[4] = default_on_read;
    var len = iovec[3], off = iovec[2], buffer = iovec[1];
    caml_call2(Faraday[21], t[1], len);
    caml_call3(on_read, buffer, off, len);
    caml_call1(t[6], len);
    if(counter >= 50) return caml_trampoline_return(execute_read$0, [0, t]);
    var counter$0 = counter + 1 | 0;
    return execute_read$0(counter$0, t);
   }
   function execute_read$0(counter, t){
    var _c_ = t[2];
    if(! _c_) return _c_;
    var _d_ = t[4], _e_ = t[3];
    if(counter >= 50)
     return caml_trampoline_return(do_execute_read$0, [0, t, _e_, _d_]);
    var counter$0 = counter + 1 | 0;
    return do_execute_read$0(counter$0, t, _e_, _d_);
   }
   function do_execute_read(t, on_eof, on_read){
    return caml_trampoline(do_execute_read$0(0, t, on_eof, on_read));
   }
   function execute_read(t){return caml_trampoline(execute_read$0(0, t));}
   function schedule_read(t, on_eof, on_read){
    if(t[2]) caml_call1(Stdlib[2], cst_Body_schedule_read_reader_);
    return is_closed(t)
            ? do_execute_read(t, on_eof, on_read)
            : (t[2] = 1, t[3] = on_eof, t[4] = on_read, 0);
   }
   function close(t){caml_call1(Faraday[19], t[1]); return execute_read(t);}
   function has_pending_output(t){return caml_call1(Faraday[13], t[1]);}
   var
    Reader =
      [0,
       default_done_reading,
       default_on_eof,
       default_on_read,
       create,
       create_empty,
       empty,
       is_closed,
       unsafe_faraday,
       do_execute_read,
       execute_read,
       schedule_read,
       close,
       has_pending_output];
   function create$0(buffer, writer){
    return [0, caml_call1(Faraday[2], buffer), [0, 0], writer];
   }
   function create_empty$0(writer){
    var t = create$0(Bigstringaf[2], writer);
    caml_call1(Faraday[19], t[1]);
    return t;
   }
   function ready_to_write(t){
    return caml_call1(Dream_h2_Serialize[20][23], t[3]);
   }
   function write_char(t, c){
    caml_call2(Faraday[7], t[1], c);
    return ready_to_write(t);
   }
   function write_string(t, off, len, s){
    caml_call4(Faraday[3], t[1], off, len, s);
    return ready_to_write(t);
   }
   function write_bigstring(t, off, len, b){
    caml_call4(Faraday[5], t[1], off, len, b);
    return ready_to_write(t);
   }
   function schedule_bigstring(t, off, len, b){
    caml_call4(Faraday[11], t[1], off, len, b);
    return ready_to_write(t);
   }
   function flush(t, kontinue){
    caml_call2(Faraday[16], t[1], kontinue);
    return ready_to_write(t);
   }
   function is_closed$0(t){return caml_call1(Faraday[20], t[1]);}
   function has_pending_output$0(t){return caml_call1(Faraday[13], t[1]);}
   function close$0(t){
    caml_call1(Dream_h2_Serialize[20][25], t[3]);
    caml_call1(Faraday[19], t[1]);
    return ready_to_write(t);
   }
   function unsafe_faraday$0(t){return t[1];}
   function transfer_to_writer
   (t, writer, max_frame_size, max_bytes, stream_id){
    var faraday = t[1], match = caml_call1(Faraday[23], faraday);
    if(typeof match === "number") return 0;
    var
     iovecs = match[2],
     buffered = t[2],
     iovecs$0 = caml_call2(Dream_httpaf_Httpaf[8][4], iovecs, buffered[1]),
     lengthv = caml_call1(Dream_httpaf_Httpaf[8][2], iovecs$0),
     writev_len = max_bytes < lengthv ? max_bytes : lengthv;
    buffered[1] = buffered[1] + writev_len | 0;
    var
     frame_info =
       caml_call4
        (Dream_h2_Serialize[20][3], 0, 0, [0, max_frame_size], stream_id);
    caml_call4
     (Dream_h2_Serialize[20][17], writer, writev_len, frame_info, iovecs$0);
    function _b_(param){
     caml_call2(Faraday[21], faraday, writev_len);
     buffered[1] = buffered[1] - writev_len | 0;
     return 0;
    }
    caml_call2(Dream_h2_Serialize[20][24], writer, _b_);
    return writev_len;
   }
   var
    Writer =
      [0,
       create$0,
       create_empty$0,
       ready_to_write,
       write_char,
       write_string,
       write_bigstring,
       schedule_bigstring,
       flush,
       is_closed$0,
       has_pending_output$0,
       close$0,
       unsafe_faraday$0,
       transfer_to_writer],
    Dream_h2_Body = [0, Reader, Writer];
   runtime.caml_register_global(8, Dream_h2_Body, "Dream_h2__Body");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Parse
//# unitInfo: Requires: Angstrom, Bigstringaf, Dream_h2__Error_code, Dream_h2__Flags, Dream_h2__Frame, Dream_h2__Priority, Dream_h2__Settings, Dream_h2__Stream_identifier, Dream_h2__Util, Stdlib, Stdlib__Int32, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_frame_payload$0 = "frame_payload",
    cst_src_vendor_h2_lib_parse_ml = "src/vendor/h2/lib/parse.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$1 = "",
    cst = ": ",
    cst$0 = " > ",
    Angstrom = global_data.Angstrom,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Bigstringaf = global_data.Bigstringaf,
    Dream_h2_Stream_identifier = global_data.Dream_h2__Stream_identifier,
    Dream_h2_Util = global_data.Dream_h2__Util,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Dream_h2_Flags = global_data.Dream_h2__Flags,
    Dream_h2_Settings = global_data.Dream_h2__Settings,
    Dream_h2_Priority = global_data.Dream_h2__Priority,
    Dream_h2_Frame = global_data.Dream_h2__Frame,
    Dream_h2_Error_code = global_data.Dream_h2__Error_code,
    _o_ = [0, cst_src_vendor_h2_lib_parse_ml, 638, 10],
    _n_ = [0, cst_src_vendor_h2_lib_parse_ml, 641, 10],
    cst_h2_Parse_Reader_unable_to_ = "h2.Parse.Reader.unable to start parser",
    _m_ = [0, cst_src_vendor_h2_lib_parse_ml, 627, 28],
    _l_ = [0, [0, -849522588, 6]],
    _k_ = [0, 0],
    _j_ = [1, [0, 106380200, [0, 1, "Invalid connection preface"]]],
    cst_frame_payload = cst_frame_payload$0,
    cst_CONTINUATION_must_be_assoc =
      "CONTINUATION must be associated with a stream",
    cst_Window_update_must_not_be_ = "Window update must not be 0",
    cst_WINDOW_UPDATE_payload_must =
      "WINDOW_UPDATE payload must be 4 octets in length",
    cst_GOAWAY_must_be_associated_ =
      "GOAWAY must be associated with stream id 0x0",
    cst_PING_payload_must_be_8_oct = "PING payload must be 8 octets in length",
    cst_PING_must_be_associated_wi =
      "PING must be associated with stream id 0x0",
    cst_PUSH_must_not_promise_stre = "PUSH must not promise stream id 0x0",
    cst_PUSH_must_be_associated_wi$0 =
      "PUSH must be associated with an even-numbered stream id",
    cst_PUSH_must_be_associated_wi = "PUSH must be associated with a stream",
    cst_SETTINGS_with_ACK_must_be_ = "SETTINGS with ACK must be empty",
    cst_SETTINGS_payload_size_must =
      "SETTINGS payload size must be a multiple of 6",
    cst_SETTINGS_must_be_associate =
      "SETTINGS must be associated with stream id 0x0",
    cst_RST_STREAM_payload_must_be =
      "RST_STREAM payload must be 4 octets in length",
    cst_RST_STREAM_must_be_associa =
      "RST_STREAM must be associated with a stream",
    cst_PRIORITY_must_be_associate =
      "PRIORITY must be associated with a stream",
    cst_HEADERS_must_be_associated =
      "HEADERS must be associated with a stream",
    cst_Data_frames_must_be_associ =
      "Data frames must be associated with a stream",
    cst_Padding_size_exceeds_paylo = "Padding size exceeds payload size",
    _a_ = [0, -1],
    cst_frame_header = "frame_header",
    cst_connection_preface = "connection preface";
   function skip_many(p){
    function _aR_(m){
     function _aS_(param){return param ? m : caml_call1(Angstrom[51], 0);}
     var _aT_ = caml_call1(Angstrom[51], 0);
     function _aU_(param){return 1;}
     var
      _aV_ = caml_call2(Angstrom[55], p, _aU_),
      _aW_ = caml_call2(Angstrom[47], _aV_, _aT_);
     return caml_call2(Angstrom[53], _aW_, _aS_);
    }
    return caml_call1(Angstrom[45], _aR_);
   }
   var default_frame_header = [0, 0, Dream_h2_Flags[1], -1, _a_];
   function connection_error(error_code, msg){return [1, [0, error_code, msg]];
   }
   function stream_error(error_code, stream_id){return [1, [1, stream_id, error_code]];
   }
   function parse_uint24(o1, o2, o3){return o1 << 16 | o2 << 8 | o3;}
   var
    frame_length =
      caml_call4
       (Angstrom[62], parse_uint24, Angstrom[30], Angstrom[30], Angstrom[30]),
    frame_type = caml_call2(Angstrom[60], Dream_h2_Frame[2][2], Angstrom[30]),
    flags = Angstrom[30];
   function parse_stream_identifier(n){return n & 2147483647;}
   var
    stream_identifier =
      caml_call2(Angstrom[60], parse_stream_identifier, Angstrom[32][5]),
    _b_ = Angstrom[50];
   function _c_(payload_length, frame_type, flags, stream_id){return [0, payload_length, flags, stream_id, frame_type];
   }
   var
    _d_ =
      caml_call5
       (Angstrom[63], _c_, frame_length, frame_type, flags, stream_identifier),
    _e_ = caml_call2(Angstrom[49], _d_, cst_frame_header),
    parse_frame_header = caml_call2(Angstrom[59], _e_, _b_);
   function parse_padded_payload(param, parser){
    var flags = param[2], payload_length = param[1];
    if(! caml_call1(Dream_h2_Flags[9], flags))
     return caml_call1(parser, payload_length);
    function _aM_(pad_length){
     if(payload_length <= pad_length){
      var
       _aN_ =
         function(param){
          return connection_error(1, cst_Padding_size_exceeds_paylo);
         },
       _aO_ = caml_call1(Angstrom[22], payload_length - 1 | 0);
      return caml_call2(Angstrom[55], _aO_, _aN_);
     }
     var
      relevant_length = (payload_length - 1 | 0) - pad_length | 0,
      _aP_ = caml_call1(Angstrom[22], pad_length),
      _aQ_ = caml_call1(parser, relevant_length);
     return caml_call2(Angstrom[59], _aQ_, _aP_);
    }
    return caml_call2(Angstrom[53], Angstrom[30], _aM_);
   }
   function parse_data_frame(frame_header){
    var stream_id = frame_header[3], payload_length = frame_header[1];
    if(caml_call1(Dream_h2_Stream_identifier[6], stream_id)){
     var
      _aI_ =
        function(param){
         return connection_error(1, cst_Data_frames_must_be_associ);
        },
      _aJ_ = caml_call1(Angstrom[22], payload_length);
     return caml_call2(Angstrom[55], _aJ_, _aI_);
    }
    function parse_data(length){
     var _aK_ = caml_call1(Angstrom[17], length);
     function _aL_(bs){return [0, [0, bs]];}
     return caml_call2(Angstrom[60], _aL_, _aK_);
    }
    return parse_padded_payload(frame_header, parse_data);
   }
   var _f_ = Angstrom[30], _g_ = Angstrom[32][5];
   function _h_(stream_dependency, weight){
    var e = caml_call1(Dream_h2_Priority[3], stream_dependency);
    return [0, e, stream_dependency & 2147483647, weight + 1 | 0];
   }
   var parse_priority = caml_call3(Angstrom[61], _h_, _g_, _f_);
   function parse_headers_frame(frame_header){
    var
     stream_id = frame_header[3],
     flags = frame_header[2],
     payload_length = frame_header[1];
    if(caml_call1(Dream_h2_Stream_identifier[6], stream_id)){
     var
      _aC_ =
        function(param){
         return connection_error(1, cst_HEADERS_must_be_associated);
        },
      _aD_ = caml_call1(Angstrom[22], payload_length);
     return caml_call2(Angstrom[55], _aD_, _aC_);
    }
    function parse_headers(length){
     if(caml_call1(Dream_h2_Flags[11], flags)){
      var
       _aE_ = caml_call1(Angstrom[17], length - 5 | 0),
       _aF_ = function(priority, headers){return [0, [1, priority, headers]];};
      return caml_call3(Angstrom[61], _aF_, parse_priority, _aE_);
     }
     var _aG_ = caml_call1(Angstrom[17], length);
     function _aH_(headers_block){
      return [0, [1, Dream_h2_Priority[1], headers_block]];
     }
     return caml_call2(Angstrom[60], _aH_, _aG_);
    }
    return parse_padded_payload(frame_header, parse_headers);
   }
   function parse_priority_frame(param){
    var stream_id = param[3], payload_length = param[1];
    if(caml_call1(Dream_h2_Stream_identifier[6], stream_id)){
     var
      _ax_ =
        function(param){
         return connection_error(1, cst_PRIORITY_must_be_associate);
        },
      _ay_ = caml_call1(Angstrom[22], payload_length);
     return caml_call2(Angstrom[55], _ay_, _ax_);
    }
    if(5 === payload_length){
     var _az_ = function(priority){return [0, [2, priority]];};
     return caml_call2(Angstrom[60], _az_, parse_priority);
    }
    function _aA_(param){return stream_error(6, stream_id);}
    var _aB_ = caml_call1(Angstrom[22], payload_length);
    return caml_call2(Angstrom[55], _aB_, _aA_);
   }
   var
    parse_error_code =
      caml_call2(Angstrom[60], Dream_h2_Error_code[2], Angstrom[32][5]);
   function parse_rst_stream_frame(param){
    var stream_id = param[3], payload_length = param[1];
    if(caml_call1(Dream_h2_Stream_identifier[6], stream_id)){
     var
      _as_ =
        function(param){
         return connection_error(1, cst_RST_STREAM_must_be_associa);
        },
      _at_ = caml_call1(Angstrom[22], payload_length);
     return caml_call2(Angstrom[55], _at_, _as_);
    }
    if(4 === payload_length){
     var _au_ = function(error_code){return [0, [3, error_code]];};
     return caml_call2(Angstrom[60], _au_, parse_error_code);
    }
    function _av_(param){
     return connection_error(6, cst_RST_STREAM_payload_must_be);
    }
    var _aw_ = caml_call1(Angstrom[22], payload_length);
    return caml_call2(Angstrom[55], _aw_, _av_);
   }
   function parse_settings_frame(param){
    var stream_id = param[3], flags = param[2], payload_length = param[1];
    if(! caml_call1(Dream_h2_Stream_identifier[6], stream_id)){
     var
      _aq_ =
        function(param){
         return connection_error(1, cst_SETTINGS_must_be_associate);
        },
      _ar_ = caml_call1(Angstrom[22], payload_length);
     return caml_call2(Angstrom[55], _ar_, _aq_);
    }
    if(0 !== (payload_length % 6 | 0)){
     var
      _ao_ =
        function(param){
         return connection_error(6, cst_SETTINGS_payload_size_must);
        },
      _ap_ = caml_call1(Angstrom[22], payload_length);
     return caml_call2(Angstrom[55], _ap_, _ao_);
    }
    if(caml_call1(Dream_h2_Flags[5], flags) && 0 !== payload_length){
     var
      _am_ =
        function(param){
         return connection_error(6, cst_SETTINGS_with_ACK_must_be_);
        },
      _an_ = caml_call1(Angstrom[22], payload_length);
     return caml_call2(Angstrom[55], _an_, _am_);
    }
    var num_settings = runtime.caml_div(payload_length, Dream_h2_Settings[2]);
    function _ak_(xs){return [0, [4, xs]];}
    var _al_ = caml_call1(Dream_h2_Settings[8], num_settings);
    return caml_call2(Angstrom[55], _al_, _ak_);
   }
   function parse_push_promise_frame(frame_header){
    var stream_id = frame_header[3], payload_length = frame_header[1];
    if(caml_call1(Dream_h2_Stream_identifier[6], stream_id)){
     var
      _ag_ =
        function(param){
         return connection_error(1, cst_PUSH_must_be_associated_wi);
        },
      _ah_ = caml_call1(Angstrom[22], payload_length);
     return caml_call2(Angstrom[55], _ah_, _ag_);
    }
    function parse_push_promise(length){
     var _ai_ = caml_call1(Angstrom[17], length - 4 | 0);
     function _aj_(promised_stream_id, fragment){
      return caml_call1(Dream_h2_Stream_identifier[6], promised_stream_id)
              ? connection_error(1, cst_PUSH_must_not_promise_stre)
              : caml_call1
                 (Dream_h2_Stream_identifier[7], promised_stream_id)
                ? connection_error(1, cst_PUSH_must_be_associated_wi$0)
                : [0, [5, promised_stream_id, fragment]];
     }
     return caml_call3(Angstrom[61], _aj_, stream_identifier, _ai_);
    }
    return parse_padded_payload(frame_header, parse_push_promise);
   }
   function parse_ping_frame(param){
    var stream_id = param[3], payload_length = param[1];
    if(! caml_call1(Dream_h2_Stream_identifier[6], stream_id)){
     var
      _ae_ =
        function(param){
         return connection_error(1, cst_PING_must_be_associated_wi);
        },
      _af_ = caml_call1(Angstrom[22], payload_length);
     return caml_call2(Angstrom[55], _af_, _ae_);
    }
    if(8 === payload_length){
     var
      _aa_ = caml_call1(Angstrom[17], payload_length),
      _ab_ = function(bs){return [0, [6, bs]];};
     return caml_call2(Angstrom[60], _ab_, _aa_);
    }
    function _ac_(param){
     return connection_error(6, cst_PING_payload_must_be_8_oct);
    }
    var _ad_ = caml_call1(Angstrom[22], payload_length);
    return caml_call2(Angstrom[55], _ad_, _ac_);
   }
   function parse_go_away_frame(param){
    var stream_id = param[3], payload_length = param[1];
    if(caml_call1(Dream_h2_Stream_identifier[6], stream_id)){
     var
      _Y_ = caml_call1(Angstrom[17], payload_length - 8 | 0),
      _Z_ =
        function(last_stream_id, err, debug_data){
         return [0, [7, last_stream_id, err, debug_data]];
        };
     return caml_call4
             (Angstrom[62], _Z_, stream_identifier, parse_error_code, _Y_);
    }
    function ___(param){
     return connection_error(1, cst_GOAWAY_must_be_associated_);
    }
    var _$_ = caml_call1(Angstrom[22], payload_length);
    return caml_call2(Angstrom[55], _$_, ___);
   }
   function parse_window_update_frame(param){
    var stream_id = param[3], payload_length = param[1];
    if(4 === payload_length){
     var
      _U_ = Angstrom[32][5],
      _V_ =
        function(uint){
         var window_size_increment = caml_call2(Dream_h2_Util[6], uint, 31);
         return caml_call2(Stdlib_Int32[17], window_size_increment, 0)
                 ? caml_call1
                    (Dream_h2_Stream_identifier[6], stream_id)
                   ? connection_error(1, cst_Window_update_must_not_be_)
                   : stream_error(1, stream_id)
                 : [0, [8, window_size_increment]];
        };
     return caml_call2(Angstrom[60], _V_, _U_);
    }
    function _W_(param){
     return connection_error(6, cst_WINDOW_UPDATE_payload_must);
    }
    var _X_ = caml_call1(Angstrom[22], payload_length);
    return caml_call2(Angstrom[55], _X_, _W_);
   }
   function parse_continuation_frame(param){
    var stream_id = param[3], payload_length = param[1];
    if(caml_call1(Dream_h2_Stream_identifier[6], stream_id)){
     var
      _Q_ =
        function(param){
         return connection_error(1, cst_CONTINUATION_must_be_assoc);
        },
      _R_ = caml_call1(Angstrom[22], payload_length);
     return caml_call2(Angstrom[55], _R_, _Q_);
    }
    var _S_ = caml_call1(Angstrom[17], payload_length);
    function _T_(block_fragment){return [0, [9, block_fragment]];}
    return caml_call2(Angstrom[60], _T_, _S_);
   }
   function parse_unknown_frame(typ, param){
    var
     payload_length = param[1],
     _O_ = caml_call1(Angstrom[17], payload_length);
    function _P_(bigstring){return [0, [10, typ, bigstring]];}
    return caml_call2(Angstrom[60], _P_, _O_);
   }
   function parse_frame_payload(frame_header){
    var frame_type = frame_header[4];
    if(typeof frame_type === "number")
     switch(frame_type){
       case 0:
        var _N_ = parse_data_frame(frame_header); break;
       case 1:
        var _N_ = parse_headers_frame(frame_header); break;
       case 2:
        var _N_ = parse_priority_frame(frame_header); break;
       case 3:
        var _N_ = parse_rst_stream_frame(frame_header); break;
       case 4:
        var _N_ = parse_settings_frame(frame_header); break;
       case 5:
        var _N_ = parse_push_promise_frame(frame_header); break;
       case 6:
        var _N_ = parse_ping_frame(frame_header); break;
       case 7:
        var _N_ = parse_go_away_frame(frame_header); break;
       case 8:
        var _N_ = parse_window_update_frame(frame_header); break;
       default: var _N_ = parse_continuation_frame(frame_header);
     }
    else
     var typ = frame_type[1], _N_ = parse_unknown_frame(typ, frame_header);
    return caml_call2(Angstrom[49], _N_, cst_frame_payload);
   }
   function parse_frame(parse_context){
    function _K_(frame_header){
     var payload_length = frame_header[1];
     parse_context[3] = 0;
     parse_context[1] = frame_header;
     var is_frame_size_error = parse_context[4] < payload_length ? 1 : 0;
     if(is_frame_size_error)
      parse_context[2] = parse_context[2] + payload_length | 0;
     var _L_ = parse_frame_payload(frame_header);
     function _M_(param){
      if(0 === param[0]){
       var frame_payload = param[1];
       return [0, [0, frame_header, frame_payload]];
      }
      var e = param[1];
      return [1, e];
     }
     return caml_call2(Angstrom[60], _M_, _L_);
    }
    return caml_call2(Angstrom[53], parse_frame_header, _K_);
   }
   var
    _i_ = caml_call1(Angstrom[8], Dream_h2_Frame[1]),
    connection_preface = caml_call2(Angstrom[49], _i_, cst_connection_preface);
   function create(parser, parse_context){
    return [0, parser, 0, 0, parse_context];
   }
   function create_parse_context(max_frame_size){
    return [0, default_frame_header, 0, 0, max_frame_size];
   }
   function settings_preface(parse_context){
    function _I_(param){
     if(0 === param[0]){
      var frame = param[1], match = frame[2];
      switch(match[0]){
        case 4:
         var settings_list = match[1]; return [0, [0, frame, settings_list]];
        case 7:
         var debug_data = match[3], error_code = match[2];
         return [1,
                 [0,
                  106380200,
                  [0, error_code, caml_call1(Bigstringaf[8], debug_data)]]];
        default: return _j_;
      }
     }
     var e = param[1];
     return [1, [0, 106380200, e]];
    }
    var _J_ = parse_frame(parse_context);
    return caml_call2(Angstrom[55], _J_, _I_);
   }
   function connection_preface_and_frames
   (max_frame_size, preface_parser, preface_handler, frame_handler){
    var parse_context = create_parse_context(max_frame_size);
    function _z_(error){
     if(0 !== error[0]) return caml_call1(Angstrom[51], error);
     var match = error[1], settings_list = match[2], frame = match[1];
     caml_call2(preface_handler, frame, settings_list);
     function _D_(param){return _k_;}
     var
      _E_ = Angstrom[50],
      _F_ = parse_frame(parse_context),
      _G_ = caml_call2(Angstrom[59], _F_, _E_),
      _H_ = skip_many(caml_call2(Angstrom[55], _G_, frame_handler));
     return caml_call2(Angstrom[55], _H_, _D_);
    }
    var
     _A_ = Angstrom[50],
     _B_ = caml_call1(preface_parser, parse_context),
     _C_ = caml_call2(Angstrom[59], _B_, _A_),
     parser = caml_call2(Angstrom[53], _C_, _z_);
    return create(parser, parse_context);
   }
   function client_frames(preface_handler, frame_handler){
    return function(_y_){
     return connection_preface_and_frames
             (_y_, settings_preface, preface_handler, frame_handler);};
   }
   function server_frames(max_frame_size, preface_handler, frame_handler){
    return connection_preface_and_frames
            (max_frame_size,
             function(parse_context){
              var _x_ = settings_preface(parse_context);
              return caml_call2(Angstrom[58], connection_preface, _x_);
             },
             preface_handler,
             frame_handler);
   }
   function is_closed(t){return t[3];}
   function transition(t, state){
    switch(state[0]){
      case 0:
       var match = state[1], continue$0 = match[2], committed = match[1];
       t[2] = 0 < t[4][2] ? _l_ : [1, continue$0];
       return committed;
      case 1:
       var match$0 = state[2], consumed = state[1];
       if(0 === match$0[0]){t[2] = 0; return consumed;}
       var error = match$0[1];
       t[2] = [0, error];
       return consumed;
      default:
       var msg = state[3], marks = state[2], consumed$0 = state[1];
       t[2] = [0, [0, -796721133, [0, marks, msg]]];
       return consumed$0;
    }
   }
   function start(t, state){
    switch(state[0]){
      case 0:
       var _w_ = state[1];
       if(0 === _w_[1]){
        var continue$0 = _w_[2];
        t[2] = [1, continue$0];
        return 0;
       }
       break;
      case 1:
       return caml_call1(Stdlib[2], cst_h2_Parse_Reader_unable_to_);
      default:
       if(0 === state[1]){
        var msg = state[3], marks = state[2];
        t[2] = [0, [0, -796721133, [0, marks, msg]]];
        return 0;
       }
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
   }
   function read_with_more(t, bs, off, len, more){
    var match = t[2];
    if(typeof match === "number"){
     start(t, caml_call1(Angstrom[77][1], t[1]));
     var consumed = read_with_more(t, bs, off, len, more);
    }
    else if(0 === match[0]){
     var parser_ctx = t[4], remaining_bytes = parser_ctx[2];
     if(0 < remaining_bytes){
      if(len > remaining_bytes)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
      var remaining_bytes$0 = remaining_bytes - len | 0;
      parser_ctx[2] = remaining_bytes$0;
      if(0 > remaining_bytes$0)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
      if(0 === remaining_bytes$0) t[2] = 0;
      var len$0 = len;
     }
     else
      var len$0 = 0;
     var consumed = len$0;
    }
    else
     var
      continue$0 = match[1],
      consumed = transition(t, caml_call4(continue$0, bs, off, len, more));
    if(! more) t[3] = 1;
    return consumed;
   }
   function force_close(t){t[3] = 1; return 0;}
   function fail_to_string(marks, err){
    var
     _u_ = caml_call2(Stdlib[28], cst, err),
     _v_ = caml_call2(Stdlib_String[7], cst$0, marks);
    return caml_call2(Stdlib[28], _v_, _u_);
   }
   function next_from_error(t, opt, error_code){
    if(opt) var sth = opt[1], msg = sth; else var msg = cst$1;
    if(t[4][1] === default_frame_header)
     return [0, 106380200, [0, error_code, msg]];
    var _q_ = t[4], _r_ = _q_[1], _t_ = _r_[4];
    a:
    {
     b:
     {
      var _s_ = _r_[3];
      if(typeof _t_ === "number")
       switch(_t_){case 1:case 4:case 5:case 9: break;default: break b;}
      if(typeof error_code === "number" && 6 === error_code) break a;
     }
     if(runtime.caml_notequal(_s_, 0)){
      if(_q_[3]) return t[3] ? -611285096 : 914388854;
      var stream_id = _r_[3];
      t[4][3] = 1;
      return [0, 106380200, [1, stream_id, error_code]];
     }
    }
    return [0, 106380200, [0, error_code, msg]];
   }
   function next(t){
    var match = t[2];
    if(typeof match !== "number" && 0 === match[0]){
     var error = match[1], _p_ = error[1];
     if(-796721133 !== _p_){
      if(106380200 <= _p_){var e = error[2]; return [0, 106380200, e];}
      var error_code$0 = error[2];
      return next_from_error(t, 0, error_code$0);
     }
     var match$0 = error[2], msg = match$0[2], marks = match$0[1];
     a:
     {
      if
       (marks
        &&
         !
         caml_string_notequal(marks[1], cst_frame_payload$0)
         && ! marks[2] && ! caml_string_notequal(msg, "not enough input")){var error_code = 6; break a;}
      var error_code = 1;
     }
     return next_from_error(t, [0, fail_to_string(marks, msg)], error_code);
    }
    return t[3]
            ? -611285096
            : typeof
              match
              === "number"
              ? t[3] ? -611285096 : 914388854
              : 914388854;
   }
   var
    Reader =
      [0,
       create,
       create_parse_context,
       settings_preface,
       connection_preface_and_frames,
       client_frames,
       server_frames,
       is_closed,
       transition,
       start,
       read_with_more,
       force_close,
       fail_to_string,
       next_from_error,
       next],
    Dream_h2_Parse =
      [0,
       skip_many,
       default_frame_header,
       connection_error,
       stream_error,
       parse_uint24,
       frame_length,
       frame_type,
       flags,
       parse_stream_identifier,
       stream_identifier,
       parse_frame_header,
       parse_padded_payload,
       parse_data_frame,
       parse_priority,
       parse_headers_frame,
       parse_priority_frame,
       parse_error_code,
       parse_rst_stream_frame,
       parse_settings_frame,
       parse_push_promise_frame,
       parse_ping_frame,
       parse_go_away_frame,
       parse_window_update_frame,
       parse_continuation_frame,
       parse_unknown_frame,
       parse_frame_payload,
       parse_frame,
       connection_preface,
       Reader];
   runtime.caml_register_global(52, Dream_h2_Parse, "Dream_h2__Parse");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Reqd
//# unitInfo: Requires: Bigstringaf, Dream_h2__Body, Dream_h2__Flags, Dream_h2__Headers, Dream_h2__Response, Dream_h2__Serialize, Dream_h2__Stream, Dream_h2__Stream_identifier, Dream_httpaf___Httpaf, Stdlib, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_h2_Reqd_response_exn_respo$1 =
      "h2.Reqd.response_exn: response has not started",
    cst_src_vendor_h2_lib_reqd_ml = "src/vendor/h2/lib/reqd.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Dream_h2_Flags = global_data.Dream_h2__Flags,
    Dream_h2_Serialize = global_data.Dream_h2__Serialize,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Dream_h2_Body = global_data.Dream_h2__Body,
    Bigstringaf = global_data.Bigstringaf,
    Dream_h2_Stream = global_data.Dream_h2__Stream,
    Dream_h2_Response = global_data.Dream_h2__Response,
    Stdlib = global_data.Stdlib,
    Dream_h2_Stream_identifier = global_data.Dream_h2__Stream_identifier,
    Dream_h2_Headers = global_data.Dream_h2__Headers,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    _r_ = [0, cst_src_vendor_h2_lib_reqd_ml, 517, 57],
    _q_ = [0, cst_src_vendor_h2_lib_reqd_ml, 521, 9],
    _p_ = [0, 0],
    _o_ = [0, cst_src_vendor_h2_lib_reqd_ml, 448, 11],
    _n_ = [0, 0],
    _m_ = [0, cst_src_vendor_h2_lib_reqd_ml, 373, 4],
    cst_h2_Reqd_report_exn_NYI = "h2.Reqd.report_exn: NYI",
    _l_ = [1, -315951818],
    cst_h2_Reqd_push_invalid_state =
      "h2.Reqd.push: invalid state, currently handling error",
    _j_ = [0, cst_src_vendor_h2_lib_reqd_ml, 323, 67],
    _k_ = [0, cst_src_vendor_h2_lib_reqd_ml, 327, 29],
    cst_h2_Reqd_respond_with_strea$1 =
      "h2.Reqd.respond_with_streaming: invalid state, currently handling error",
    _i_ = [0, cst_src_vendor_h2_lib_reqd_ml, 274, 16],
    _h_ = [0, cst_src_vendor_h2_lib_reqd_ml, 260, 67],
    cst_h2_Reqd_respond_with_strea$0 =
      "h2.Reqd.respond_with_streaming: response already started",
    cst_h2_Reqd_respond_with_strea =
      "h2.Reqd.respond_with_streaming: response already complete",
    cst_h2_Reqd_respond_with_bigst =
      "h2.Reqd.respond_with_bigstring: invalid state, currently handling error",
    cst_h2_Reqd_respond_with_strin =
      "h2.Reqd.respond_with_string: invalid state, currently handling error",
    _g_ = [0, cst_src_vendor_h2_lib_reqd_ml, 220, 16],
    _f_ = [0, cst_src_vendor_h2_lib_reqd_ml, 209, 67],
    cst_h2_Reqd_schedule_trailers_ =
      "h2.Reqd.schedule_trailers: response not started",
    cst_h2_Reqd_schedule_trailers_$1 =
      "h2.Reqd.schedule_trailers: trailers already scheduled",
    cst_h2_Reqd_schedule_trailers_$0 =
      "h2.Reqd.schedule_trailers: can only send trailers in Streaming mode",
    cst_h2_Reqd_schedule_trailers_$2 =
      "h2.Reqd.schedule_trailers: stream already closed",
    _e_ = [0, cst_src_vendor_h2_lib_reqd_ml, 193, 67],
    cst_h2_Reqd_respond_with_respo =
      "h2.Reqd.respond_with_*: response already sent",
    cst_h2_Reqd_respond_with_respo$0 =
      "h2.Reqd.respond_with_*: response already started",
    cst_h2_Reqd_respond_with_respo$1 =
      "h2.Reqd.respond_with_*: response already complete",
    _d_ = [0, cst_src_vendor_h2_lib_reqd_ml, 152, 16],
    cst_h2_Reqd_response_exn_respo = cst_h2_Reqd_response_exn_respo$1,
    cst_h2_Reqd_response_exn_respo$0 = cst_h2_Reqd_response_exn_respo$1,
    cst_h2_Reqd_request_body_Promi =
      "h2.Reqd.request_body: Promised requests must not include a request body",
    cst_h2_Reqd_request_body_Strea =
      "h2.Reqd.request_body: Stream already closed",
    _c_ = [0, cst_src_vendor_h2_lib_reqd_ml, 114, 4],
    _b_ = [0, cst_src_vendor_h2_lib_reqd_ml, 109, 16],
    _a_ = [0, cst_src_vendor_h2_lib_reqd_ml, 105, 4];
   function create_active_request(request, request_body){return [0, request, request_body, Stdlib_Int64[1]];
   }
   function create_active_stream
   (encoder, body_buffer_size, create_push_stream){
    return [0, body_buffer_size, encoder, 0, 0, 0, create_push_stream];
   }
   function request(t){
    var _as_ = t[5];
    a:
    if(typeof _as_ !== "number"){
     switch(_as_[0]){
       case 0:
        var request = _as_[1][1][1]; break;
       case 1:
        var _at_ = _as_[1];
        b:
        {
         if(0 === _at_[0]){
          var _au_ = _at_[1];
          if(typeof _au_ !== "number" && 1 === _au_[0]){var _av_ = _au_[1][1]; break b;}
          break a;
         }
         var _av_ = _at_[1][1];
        }
        var request = _av_;
        break;
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     }
     return request;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function request_body(t){
    var _ap_ = t[5];
    if(typeof _ap_ !== "number")
     switch(_ap_[0]){
       case 0:
        return caml_call1(Stdlib[2], cst_h2_Reqd_request_body_Promi);
       case 1:
        var _aq_ = _ap_[1];
        a:
        {
         if(0 === _aq_[0]){
          var _ar_ = _aq_[1];
          if(typeof _ar_ !== "number" && 1 === _ar_[0]){var request_body = _ar_[1][2]; break a;}
          break;
         }
         var request_body = _aq_[1][2];
        }
        return request_body;
       default: return caml_call1(Stdlib[2], cst_h2_Reqd_request_body_Strea);
     }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function response(t){
    var _am_ = t[5];
    a:
    if(typeof _am_ !== "number"){
     switch(_am_[0]){
       case 0:
        var response_state = _am_[1][2][3]; break;
       case 1:
        var _an_ = _am_[1];
        b:
        if(0 === _an_[0]){
         var _ao_ = _an_[1];
         c:
         {
          if(typeof _ao_ === "number"){if(0 === _ao_) break c;}
          else if(0 === _ao_[0]) break c;
          break b;
         }
         break a;
        }
        var response_state = _am_[2][3];
        break;
       default: return 0;
     }
     if(typeof response_state === "number") return 0;
     var
      response =
        0 === response_state[0] ? response_state[1] : response_state[1];
     return [0, response];
    }
    return 0;
   }
   function response_exn(t){
    var _aj_ = t[5];
    a:
    if(typeof _aj_ !== "number"){
     switch(_aj_[0]){
       case 0:
        var response_state = _aj_[1][2][3]; break;
       case 1:
        var _ak_ = _aj_[1];
        b:
        if(0 === _ak_[0]){
         var _al_ = _ak_[1];
         c:
         {
          if(typeof _al_ === "number"){if(0 === _al_) break c;}
          else if(0 === _al_[0]) break c;
          break b;
         }
         break a;
        }
        var response_state = _aj_[2][3];
        break;
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     }
     if(typeof response_state === "number")
      return caml_call1(Stdlib[2], cst_h2_Reqd_response_exn_respo$0);
     var
      response =
        0 === response_state[0] ? response_state[1] : response_state[1];
     return response;
    }
    return caml_call1(Stdlib[2], cst_h2_Reqd_response_exn_respo);
   }
   function send_fixed_response(t, s, response, data){
    var _af_ = s[3];
    if(typeof _af_ !== "number")
     switch(_af_[0]){
       case 0:
        return caml_call1(Stdlib[2], cst_h2_Reqd_respond_with_respo);
       case 1:
        return caml_call1(Stdlib[2], cst_h2_Reqd_respond_with_respo$0);
       default:
        return caml_call1(Stdlib[2], cst_h2_Reqd_respond_with_respo$1);
     }
    if(608227697 <= data[1])
     var
      b = data[2],
      len = caml_call1(Bigstringaf[6], b),
      iovec = [0, [0, 608227697, b], 0, len],
      length = len,
      iovec$0 = iovec;
    else
     var
      s$0 = data[2],
      length$0 = runtime.caml_ml_string_length(s$0),
      iovec$1 = [0, [0, -976970511, s$0], 0, length$0],
      length = length$0,
      iovec$0 = iovec$1;
    var
     should_send_data = 0 !== length ? 1 : 0,
     _ag_ = t[1],
     _ah_ = [0, t[6]],
     _ai_ =
       should_send_data
        ? Dream_h2_Flags[1]
        : caml_call1(Dream_h2_Flags[3], Dream_h2_Flags[1]),
     frame_info =
       caml_call4(Dream_h2_Serialize[20][3], 0, [0, _ai_], _ah_, _ag_);
    caml_call4(Dream_h2_Serialize[20][13], t[2], s[2], frame_info, response);
    s[3] = should_send_data ? [0, response, iovec$0] : [2, response];
    return caml_call1(Dream_h2_Serialize[20][23], t[2]);
   }
   function schedule_trailers(t, new_trailers){
    var _ac_ = t[5];
    if(typeof _ac_ !== "number")
     switch(_ac_[0]){
       case 0:
        return caml_call1(Stdlib[2], cst_h2_Reqd_schedule_trailers_);
       case 1:
        var _ad_ = _ac_[1];
        a:
        if(0 === _ad_[0]){
         var _ae_ = _ad_[1];
         b:
         {
          if(typeof _ae_ === "number"){if(0 === _ae_) break b;}
          else if(0 === _ae_[0]) break b;
          break a;
         }
         break;
        }
        var stream = _ac_[2], match = stream[3];
        if(typeof match !== "number" && 1 === match[0]){
         var
          old_trailers = match[3],
          response_body = match[2],
          response = match[1];
         if(runtime.caml_notequal(old_trailers, Dream_h2_Headers[1]))
          caml_call1(Stdlib[2], cst_h2_Reqd_schedule_trailers_$1);
         stream[3] = [1, response, response_body, new_trailers];
         return 0;
        }
        return caml_call1(Stdlib[2], cst_h2_Reqd_schedule_trailers_$0);
       default:
        return caml_call1(Stdlib[2], cst_h2_Reqd_schedule_trailers_$2);
     }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function unsafe_respond_with_data(t, response, data){
    var ___ = t[5];
    if(typeof ___ !== "number")
     switch(___[0]){
       case 0:
        var match = ___[1], stream = match[2], request_info = match[1];
        send_fixed_response(t, stream, response, data);
        var
         _$_ =
           function(param){t[5] = [1, [1, request_info], stream]; return 0;};
        return caml_call2(Dream_h2_Serialize[20][24], t[2], _$_);
       case 1:
        var _aa_ = ___[1];
        a:
        if(0 === _aa_[0]){
         var _ab_ = _aa_[1];
         b:
         {
          if(typeof _ab_ === "number"){if(0 === _ab_) break b;}
          else if(0 === _ab_[0]) break b;
          break a;
         }
         break;
        }
        var stream$0 = ___[2];
        return send_fixed_response(t, stream$0, response, data);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function respond_with_string(t, response, str){
    return typeof t[4] === "number"
            ? unsafe_respond_with_data(t, response, [0, -976970511, str])
            : caml_call1(Stdlib[2], cst_h2_Reqd_respond_with_strin);
   }
   function respond_with_bigstring(t, response, bstr){
    return typeof t[4] === "number"
            ? unsafe_respond_with_data(t, response, [0, 608227697, bstr])
            : caml_call1(Stdlib[2], cst_h2_Reqd_respond_with_bigst);
   }
   function send_streaming_response(flush_headers_immediately, t, s, response){
    var wait_for_first_flush = 1 - flush_headers_immediately, _Z_ = s[3];
    if(typeof _Z_ !== "number")
     return 1 === _Z_[0]
             ? caml_call1(Stdlib[2], cst_h2_Reqd_respond_with_strea$0)
             : caml_call1(Stdlib[2], cst_h2_Reqd_respond_with_strea);
    var
     frame_info = caml_call4(Dream_h2_Serialize[20][3], 0, 0, [0, t[6]], t[1]),
     response_body_buffer = caml_call1(Bigstringaf[1], s[1]),
     response_body =
       caml_call2(Dream_h2_Body[2][1], response_body_buffer, t[2]);
    caml_call4(Dream_h2_Serialize[20][13], t[2], s[2], frame_info, response);
    if(wait_for_first_flush) caml_call1(Dream_h2_Serialize[20][26], t[2]);
    s[3] = [1, response, response_body, Dream_h2_Headers[1]];
    caml_call1(Dream_h2_Serialize[20][23], t[2]);
    return response_body;
   }
   function unsafe_respond_with_streaming
   (t, flush_headers_immediately, response){
    var _V_ = t[5];
    if(typeof _V_ !== "number")
     switch(_V_[0]){
       case 0:
        var
         match = _V_[1],
         stream = match[2],
         request_info = match[1],
         response_body =
           send_streaming_response
            (flush_headers_immediately, t, stream, response),
         _W_ =
           function(param){t[5] = [1, [1, request_info], stream]; return 0;};
        caml_call2(Dream_h2_Serialize[20][24], t[2], _W_);
        return response_body;
       case 1:
        var _X_ = _V_[1];
        a:
        if(0 === _X_[0]){
         var _Y_ = _X_[1];
         b:
         {
          if(typeof _Y_ === "number"){if(0 === _Y_) break b;}
          else if(0 === _Y_[0]) break b;
          break a;
         }
         break;
        }
        var stream$0 = _V_[2];
        return send_streaming_response
                (flush_headers_immediately, t, stream$0, response);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   }
   function respond_with_streaming(t, opt, response){
    if(opt)
     var sth = opt[1], flush_headers_immediately = sth;
    else
     var flush_headers_immediately = 0;
    return typeof t[4] === "number"
            ? unsafe_respond_with_streaming
              (t, flush_headers_immediately, response)
            : caml_call1(Stdlib[2], cst_h2_Reqd_respond_with_strea$1);
   }
   function start_push_stream(t, s, request){
    var match = caml_call1(s[6], t[1]);
    if(0 === match[0]){
     var
      promised_reqd = match[1],
      frame_info =
        caml_call4(Dream_h2_Serialize[20][3], 0, 0, [0, t[6]], t[1]);
     caml_call5
      (Dream_h2_Serialize[20][12],
       t[2],
       s[2],
       frame_info,
       promised_reqd[1],
       request);
     var
      encoder = s[2],
      body_buffer_size = s[1],
      create_push_stream = s[6],
      request_info = create_active_request(request, Dream_h2_Body[1][6]),
      active_stream =
        create_active_stream(encoder, body_buffer_size, create_push_stream);
     promised_reqd[5] = [0, [0, request_info, active_stream]];
     caml_call1(Dream_h2_Serialize[20][23], t[2]);
     return [0, promised_reqd];
    }
    var e = match[1];
    return [1, e];
   }
   function unsafe_push(t, request){
    var _S_ = t[5];
    a:
    if(typeof _S_ !== "number"){
     if(1 !== _S_[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
     var _T_ = _S_[1];
     b:
     if(0 === _T_[0]){
      var _U_ = _T_[1];
      c:
      {
       if(typeof _U_ === "number"){if(0 === _U_) break c;}
       else if(0 === _U_[0]) break c;
       break b;
      }
      break a;
     }
     var stream = _S_[2];
     return start_push_stream(t, stream, request);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function push(t, request){
    return typeof t[4] === "number"
            ? caml_call1
               (Dream_h2_Stream_identifier[8], t[1])
              ? _l_
              : unsafe_push(t, request)
            : caml_call1(Stdlib[2], cst_h2_Reqd_push_invalid_state);
   }
   function report_error(request, t, s, error, error_code){
    var _P_ = s[3], _Q_ = t[4];
    a:
    {
     if(typeof _P_ === "number"){
      if(typeof _Q_ === "number"){
       t[4] = caml_call2(Dream_h2_Stream[8], error, error_code);
       var
        status = typeof error === "number" ? error : -732353682,
        _R_ =
          function(headers){
           var
            response = caml_call2(Dream_h2_Response[1], [0, headers], status);
           return unsafe_respond_with_streaming(t, 1, response);
          };
       return caml_call3(t[3], request, error, _R_);
      }
     }
     else
      switch(_P_[0]){
        case 0:
         if(typeof _Q_ === "number"){
          t[4] = caml_call2(Dream_h2_Stream[8], error, error_code);
          return caml_call2(Dream_h2_Stream[9], t, error_code);
         }
         break;
        case 1:
         if(typeof _Q_ === "number"){
          var response_body = _P_[2];
          caml_call1(Dream_h2_Body[2][11], response_body);
          t[4] = caml_call2(Dream_h2_Stream[8], error, error_code);
          return caml_call2(Dream_h2_Stream[9], t, error_code);
         }
         break;
        default: break a;
      }
     if(typeof _Q_ !== "number" && 0 === _Q_[0])
      return caml_call1(Stdlib[2], cst_h2_Reqd_report_exn_NYI);
    }
    return 0;
   }
   function report_error$0(t, exn, error_code){
    var _K_ = t[5];
    if(typeof _K_ !== "number")
     switch(_K_[0]){
       case 1:
        var _L_ = _K_[1];
        a:
        {
         if(0 === _L_[0]){
          var _M_ = _L_[1];
          if(typeof _M_ === "number"){
           if(1 === _M_){
            var stream = _K_[2];
            return report_error(0, t, stream, exn, error_code);
           }
          }
          else if(1 === _M_[0]){
           var _N_ = _M_[1], request_body = _N_[2], request = _N_[1];
           break a;
          }
          break;
         }
         var _O_ = _L_[1], request_body = _O_[2], request = _O_[1];
        }
        var stream$0 = _K_[2];
        caml_call1(Dream_h2_Body[1][12], request_body);
        return report_error([0, request], t, stream$0, exn, error_code);
       case 2:
        return 0;
     }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
   }
   function report_exn(t, exn){
    return report_error$0(t, [0, 3458171, exn], 2);
   }
   function try_with(t, f){
    try{caml_call1(f, 0); return _n_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     report_exn(t, exn);
     return [1, exn];
    }
   }
   var error_code = Dream_h2_Stream[7];
   function requires_output(t){
    var _H_ = t[5];
    if(typeof _H_ === "number") return 0;
    switch(_H_[0]){
      case 0:
       return 1;
      case 1:
       var _I_ = _H_[1];
       a:
       if(0 === _I_[0]){
        var _J_ = _I_[1];
        b:
        {
         if(typeof _J_ === "number"){if(0 === _J_) break b;}
         else if(0 === _J_[0]) break b;
         break a;
        }
        return 0;
       }
       var response_state = _H_[2][3];
       if(typeof response_state === "number") return 1;
       switch(response_state[0]){
         case 0:
          var len = response_state[2][3]; return 0 < len ? 1 : 0;
         case 1:
          return 1;
         default: return 0;
       }
      default: return 0;
    }
   }
   function flush_request_body(t){
    var _C_ = t[5];
    a:
    if(typeof _C_ !== "number" && 1 === _C_[0]){
     var _D_ = _C_[1];
     b:
     {
      if(0 === _D_[0]){
       var _E_ = _D_[1];
       if(typeof _E_ !== "number" && 0 !== _E_[0]){var request_body = _E_[1][2]; break b;}
       break a;
      }
      var request_body = _D_[1][2];
     }
     var _F_ = caml_call1(Dream_h2_Body[1][13], request_body);
     if(! _F_) return _F_;
     try{var _G_ = caml_call1(Dream_h2_Body[1][10], request_body); return _G_;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return report_exn(t, exn);
     }
    }
    return 0;
   }
   function write_buffer_data(writer, off, len, frame_info, buffer){
    if(608227697 <= buffer[1]){
     var bstr = buffer[2];
     return caml_call5
             (Dream_h2_Serialize[20][7],
              writer,
              frame_info,
              [0, off],
              [0, len],
              bstr);
    }
    var str = buffer[2];
    return caml_call5
            (Dream_h2_Serialize[20][6],
             writer,
             frame_info,
             [0, off],
             [0, len],
             str);
   }
   function close_stream(t){
    var match = t[4];
    if(typeof match !== "number"){
     if(0 === match[0]) return caml_call2(Dream_h2_Stream[9], t, 2);
     var code = match[2];
     return caml_call2(Dream_h2_Stream[9], t, code);
    }
    var _y_ = t[5];
    if(typeof _y_ !== "number" && 1 === _y_[0]){
     var _z_ = _y_[1];
     if(0 !== _z_[0]){
      var _B_ = function(param){return caml_call2(Dream_h2_Stream[6], t, 0);};
      return caml_call2(Dream_h2_Serialize[20][24], t[2], _B_);
     }
     var _A_ = _z_[1];
     a:
     {
      if(typeof _A_ === "number"){if(0 === _A_) break a;}
      else if(0 === _A_[0]) break a;
      return caml_call2(Dream_h2_Stream[9], t, 0);
     }
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
   }
   function flush_response_body(t, max_bytes){
    var match = t[5];
    if(typeof match !== "number" && 1 === match[0]){
     var stream = match[2], r = stream[3];
     if(typeof r !== "number")
      switch(r[0]){
        case 0:
         var iovec = r[2], len = iovec[3], off = iovec[2], buffer = iovec[1];
         if(0 < max_bytes){
          var
           is_partial_flush = max_bytes < len ? 1 : 0,
           flags =
             is_partial_flush
              ? Dream_h2_Flags[1]
              : caml_call1(Dream_h2_Flags[3], Dream_h2_Flags[1]),
           frame_info =
             caml_call4
              (Dream_h2_Serialize[20][3], 0, [0, flags], [0, t[6]], t[1]),
           len_to_write = is_partial_flush ? max_bytes : len;
          write_buffer_data(t[2], off, len_to_write, frame_info, buffer);
          r[2] = caml_call2(Dream_httpaf_Httpaf[8][3], iovec, len_to_write);
          if(1 - is_partial_flush) close_stream(t);
          return len_to_write;
         }
         break;
        case 1:
         var trailers = r[3], response_body = r[2], response = r[1];
         if(caml_call1(Dream_h2_Body[2][10], response_body) && 0 < max_bytes)
          return caml_call5
                  (Dream_h2_Body[2][13],
                   response_body,
                   t[2],
                   t[6],
                   max_bytes,
                   t[1]);
         if(! caml_call1(Dream_h2_Body[2][9], response_body)) return 0;
         var
          _v_ = t[1],
          _w_ = [0, t[6]],
          _x_ = [0, caml_call1(Dream_h2_Flags[3], Dream_h2_Flags[1])],
          frame_info$0 =
            caml_call4(Dream_h2_Serialize[20][3], 0, _x_, _w_, _v_);
         return trailers
                 ? (caml_call4
                    (Dream_h2_Serialize[20][14],
                     t[2],
                     stream[2],
                     frame_info$0,
                     trailers),
                   close_stream(t),
                   stream[3] = [2, response],
                   0)
                 : (caml_call5
                    (Dream_h2_Serialize[20][7],
                     t[2],
                     frame_info$0,
                     0,
                     _p_,
                     Bigstringaf[2]),
                   close_stream(t),
                   stream[3] = [2, response],
                   0);
      }
     return 0;
    }
    return 0;
   }
   function deliver_trailer_headers(t, headers){
    var _s_ = t[5];
    a:
    if(typeof _s_ !== "number" && 1 === _s_[0]){
     var _t_ = _s_[1];
     b:
     if(0 === _t_[0]){
      var _u_ = _t_[1];
      if(typeof _u_ === "number"){if(0 === _u_) break a;}
      else if(1 === _u_[0]) break b;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
     }
     var stream = _s_[2];
     stream[5] = [0, headers];
     return 0;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
   }
   var
    Dream_h2_Reqd =
      [0,
       create_active_request,
       create_active_stream,
       request,
       request_body,
       response,
       response_exn,
       send_fixed_response,
       schedule_trailers,
       unsafe_respond_with_data,
       respond_with_string,
       respond_with_bigstring,
       send_streaming_response,
       unsafe_respond_with_streaming,
       respond_with_streaming,
       start_push_stream,
       unsafe_push,
       push,
       report_error,
       report_error$0,
       report_exn,
       try_with,
       error_code,
       requires_output,
       flush_request_body,
       write_buffer_data,
       close_stream,
       flush_response_body,
       deliver_trailer_headers];
   runtime.caml_register_global(48, Dream_h2_Reqd, "Dream_h2__Reqd");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Scheduler
//# unitInfo: Requires: CamlinternalMod, Dream_h2__Priority, Dream_h2__Settings, Dream_h2__Stream_identifier, Psq, Stdlib, Stdlib__Format, Stdlib__Hashtbl, Stdlib__Int32, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Dream_h2_Settings = global_data.Dream_h2__Settings,
    Dream_h2_Stream_identifier = global_data.Dream_h2__Stream_identifier,
    Stdlib = global_data.Stdlib,
    Dream_h2_Priority = global_data.Dream_h2__Priority,
    CamlinternalMod = global_data.CamlinternalMod,
    Psq = global_data.Psq,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    equal = Dream_h2_Stream_identifier[1],
    _h_ =
      [0,
       [12,
        10,
        [2,
         0,
         [5,
          0,
          0,
          0,
          [11, ", ", [4, 0, 0, 0, [11, " -> [", [15, [12, 93, 0]]]]]]]],
       "\n%s%ld, %d -> [%a]"],
    _f_ = [0, 0, 1],
    _g_ = [0, 0, 0],
    _d_ = [0, 1],
    _e_ = [0, 1],
    _a_ = [0, [0]],
    _b_ = [0, "src/vendor/h2/lib/scheduler.ml", 110, 4],
    _c_ = [0, [0]];
   function hash(i, k){return caml_call2(Stdlib_Hashtbl[29], i, k);}
   var
    include = caml_call1(Stdlib_Hashtbl[27], [0, equal, hash]),
    create = include[1],
    clear = include[2],
    reset = include[3],
    copy = include[4],
    add = include[5],
    remove = include[6],
    find = include[7],
    find_all = include[9],
    replace = include[10],
    mem = include[11],
    iter = include[12],
    filter_map_inplace = include[13],
    fold = include[14],
    length = include[15],
    stats = include[16],
    to_seq = include[17],
    to_seq_keys = include[18],
    to_seq_values = include[19],
    add_seq = include[20],
    replace_seq = include[21],
    of_seq = include[22];
   function find_opt(h, key){
    try{var _S_ = [0, caml_call2(find, h, key)]; return _S_;}
    catch(_T_){
     var _R_ = caml_wrap_exception(_T_);
     if(_R_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_R_, 0);
    }
   }
   var
    StreamsTbl =
      [0,
       create,
       clear,
       reset,
       copy,
       add,
       remove,
       find,
       find_all,
       replace,
       mem,
       iter,
       filter_map_inplace,
       fold,
       length,
       stats,
       to_seq,
       to_seq_keys,
       to_seq_values,
       add_seq,
       replace_seq,
       of_seq,
       find_opt];
   function Make(Streamd){
    var PriorityTreeNode = caml_call2(CamlinternalMod[1], _b_, _a_);
    function compare(param){
     var t1 = param[3];
     return function(param){
      var t2 = param[3];
      return runtime.caml_int_compare(t1, t2);};
    }
    var
     PriorityQueue =
       caml_call1(caml_call1(Psq[1], [0, Stdlib_Int32[15]]), [0, compare]);
    caml_call3(CamlinternalMod[2], _c_, PriorityTreeNode, PriorityTreeNode);
    function make_root(opt, param){
     if(opt) var sth = opt[1], capacity = sth; else var capacity = 65536;
     var
      _N_ = caml_call2(StreamsTbl[1], _d_, 256),
      _O_ = Dream_h2_Settings[1][1],
      _P_ = Dream_h2_Settings[1][1],
      _Q_ = PriorityQueue[1];
     return [0,
             caml_call2(StreamsTbl[1], _e_, capacity),
             0,
             _Q_,
             _P_,
             _O_,
             _N_];
    }
    function create
    (parent, initial_send_window_size, initial_recv_window_size, descriptor){
     return [1,
             descriptor,
             0,
             0,
             Dream_h2_Priority[1],
             parent,
             PriorityQueue[1],
             initial_send_window_size,
             initial_recv_window_size];
    }
    function stream_id(param){
     if(0 === param[0]) return Dream_h2_Stream_identifier[5];
     var descriptor = param[1];
     return caml_call1(Streamd[1], descriptor);
    }
    function children(param){
     if(0 === param[0]){var children = param[3]; return children;}
     var children$0 = param[6];
     return children$0;
    }
    function remove_child(parent, id){
     if(0 === parent[0]){
      var children = parent[3];
      parent[3] = caml_call2(PriorityQueue[10], id, children);
      return 0;
     }
     var children$0 = parent[6];
     parent[6] = caml_call2(PriorityQueue[10], id, children$0);
     return 0;
    }
    function update_children(parent, updated_children){
     return 0 === parent[0]
             ? (parent[3] = updated_children, 0)
             : (parent[6] = updated_children, 0);
    }
    function set_parent(stream_node, exclusive, new_parent){
     var
      new_parent_node = new_parent[1],
      descriptor = stream_node[1],
      old_parent_node = stream_node[5][1],
      stream_id = caml_call1(Streamd[1], descriptor);
     remove_child(old_parent_node, stream_id);
     stream_node[5] = new_parent;
     var new_children = children(new_parent_node);
     if(exclusive){
      var
       _L_ = stream_node[6],
       _M_ =
         function(k, p_node, pq){
          p_node[5] = [0, stream_node];
          return caml_call3(PriorityQueue[8], k, p_node, pq);
         };
      stream_node[6] = caml_call3(PriorityQueue[26], _M_, _L_, new_children);
      var
       new_children$0 = caml_call2(PriorityQueue[2], stream_id, stream_node);
     }
     else
      var
       new_children$0 =
         caml_call3(PriorityQueue[8], stream_id, stream_node, new_children);
     return update_children(new_parent_node, new_children$0);
    }
    function would_create_cycle(new_parent, param){
     var
      descriptor = param[1],
      parent_node = new_parent[1],
      param$0 = parent_node;
     for(;;){
      if(0 === param$0[0]) return 0;
      var
       parent = param$0[5][1],
       _J_ = caml_call1(Streamd[1], descriptor),
       _K_ = stream_id(parent);
      if(caml_call2(Dream_h2_Stream_identifier[1], _K_, _J_)) return 1;
      var param$0 = parent;
     }
    }
    function reprioritize_stream(root, priority, stream_node){
     if(caml_call1(Dream_h2_Stream_identifier[6], priority[2]))
      var new_priority = priority, new_parent = [0, root];
     else{
      var match = caml_call2(StreamsTbl[22], root[1], priority[2]);
      if(match){
       var parent_stream = match[1];
       if(caml_call2(StreamsTbl[10], root[6], priority[2]))
        var new_priority = Dream_h2_Priority[1], new_parent = [0, root];
       else
        var new_priority = priority, new_parent = [0, parent_stream];
      }
      else
       var
        new_priority$0 = Dream_h2_Priority[1],
        new_parent$0 = [0, root],
        new_priority = new_priority$0,
        new_parent = new_parent$0;
     }
     var
      _E_ = 1 - caml_call2(Dream_h2_Priority[6], stream_node[4], new_priority);
     if(_E_){
      var
       stream_dependency = new_priority[2],
       exclusive = new_priority[1],
       current_parent_node = stream_node[5][1],
       current_parent_id = stream_id(current_parent_node),
       _F_ =
         1
         -
          caml_call2
           (Dream_h2_Stream_identifier[1],
            stream_dependency,
            current_parent_id),
       _G_ = _F_ || (exclusive !== stream_node[4][1] ? 1 : 0);
      if(_G_){
       var new_parent_stream = new_parent[1];
       if
        (0 !== new_parent_stream[0]
         && would_create_cycle(new_parent, stream_node)){
        set_parent(new_parent_stream, 0, stream_node[5]);
        var _I_ = new_parent_stream[4];
        new_parent_stream[4] = [0, _I_[1], current_parent_id, _I_[3]];
       }
       set_parent(stream_node, exclusive, new_parent);
      }
      stream_node[4] = new_priority;
      var _H_ = 0;
     }
     else
      var _H_ = _E_;
     return _H_;
    }
    function update_t(stream, n){
     var descriptor = stream[1], parent = stream[5][1];
     if(0 === parent[0])
      var t_last = parent[2], tlast_p = t_last;
     else
      var t_last$0 = parent[2], tlast_p = t_last$0;
     stream[3] = tlast_p + runtime.caml_div(n * 256 | 0, stream[4][3]) | 0;
     var id = caml_call1(Streamd[1], descriptor);
     remove_child(parent, id);
     var
      _D_ = children(parent),
      updated_children = caml_call3(PriorityQueue[8], id, stream, _D_);
     return update_children(parent, updated_children);
    }
    function update_t_last(p_node, t_last){
     return 0 === p_node[0]
             ? (p_node[2] = t_last, 0)
             : (p_node[2] = t_last, 0);
    }
    function add
    (t,
     priority,
     initial_send_window_size,
     initial_recv_window_size,
     descriptor){
     var
      stream =
        create
         ([0, t],
          initial_send_window_size,
          initial_recv_window_size,
          descriptor),
      stream_id = caml_call1(Streamd[1], descriptor);
     caml_call3(StreamsTbl[5], t[1], stream_id, stream);
     t[3] = caml_call3(PriorityQueue[8], stream_id, stream, t[3]);
     if(priority !== Dream_h2_Priority[1])
      reprioritize_stream(t, priority, stream);
     update_t(stream, 0);
     return stream;
    }
    function get_node(param, stream_id){
     return caml_call2(StreamsTbl[22], param[1], stream_id);
    }
    function find(t, stream_id){
     var match = get_node(t, stream_id);
     if(! match) return 0;
     var descriptor = match[1][1];
     return [0, descriptor];
    }
    function iter(param, f){
     var all_streams = param[1];
     function _C_(id, stream){return caml_call1(f, stream);}
     return caml_call2(StreamsTbl[11], _C_, all_streams);
    }
    function allowed_to_transmit(param, stream){
     var
      _A_ = 0 < caml_call2(Stdlib_Int32[15], param[4], 0) ? 1 : 0,
      _B_ = _A_ ? 0 < caml_call2(Stdlib_Int32[15], stream[7], 0) ? 1 : 0 : _A_;
     return _B_;
    }
    function allowed_to_receive(param, stream, size){
     var
      _y_ = caml_lessequal(size, param[5]),
      _z_ = _y_ ? caml_lessequal(size, stream[8]) : _y_;
     return _z_;
    }
    function write(root, stream_node){
     var
      descriptor = stream_node[1],
      allowed_bytes =
        allowed_to_transmit(root, stream_node)
         ? caml_call2(Stdlib[16], root[4], stream_node[7])
         : 0,
      written = caml_call2(Streamd[3], descriptor, allowed_bytes);
     root[4] = root[4] - written | 0;
     stream_node[7] = stream_node[7] - written | 0;
     return written;
    }
    function mark_for_removal(param, id, closed){
     return caml_call3(StreamsTbl[9], param[6], id, closed);
    }
    function implicitly_close_idle_stream(descriptor, max_seen_ids){
     function implicitly_close_stream(descriptor){
      var _x_ = caml_call1(Streamd[5], descriptor);
      return _x_ ? caml_call2(Streamd[4], descriptor, 0) : _x_;
     }
     var
      max_pushed_stream_id = max_seen_ids[2],
      max_client_stream_id = max_seen_ids[1],
      stream_id = caml_call1(Streamd[1], descriptor);
     if(caml_call1(Dream_h2_Stream_identifier[7], stream_id)){
      var _v_ = caml_lessthan(stream_id, max_client_stream_id);
      return _v_ ? implicitly_close_stream(descriptor) : _v_;
     }
     var _w_ = caml_lessthan(stream_id, max_pushed_stream_id);
     return _w_ ? implicitly_close_stream(descriptor) : _w_;
    }
    function flush(t, max_seen_ids){
     function schedule(p_node){
      if(0 === p_node[0]) return traverse(p_node);
      var
       descriptor = p_node[1],
       written = caml_call1(Streamd[2], descriptor) ? write(t, p_node) : 0;
      if(0 < written){
       var
        _t_ = caml_call1(Streamd[2], descriptor),
        subtree_is_active = _t_ || 1 - caml_call1(PriorityQueue[4], p_node[6]);
       return [0, written, subtree_is_active];
      }
      var
       match = traverse(p_node),
       subtree_is_active$0 = match[2],
       written$0 = match[1],
       _u_ = caml_call1(Streamd[2], descriptor),
       subtree_is_active$1 = _u_ || subtree_is_active$0;
      if(0 === written$0) return [0, written$0, subtree_is_active$1];
      if(subtree_is_active$1) update_t(p_node, written$0);
      return [0, written$0, subtree_is_active$1];
     }
     function traverse(p_node){
      var remaining_children$1 = children(p_node);
      if(caml_call1(PriorityQueue[4], remaining_children$1)) return _g_;
      var remaining_children = remaining_children$1;
      for(;;){
       var match = caml_call1(PriorityQueue[16], remaining_children);
       if(! match) return _f_;
       var
        _s_ = match[1],
        match$0 = _s_[1],
        i_node = match$0[2],
        remaining_children$0 = _s_[2],
        id = match$0[1];
       update_t_last(p_node, i_node[3]);
       var
        match$1 = schedule(i_node),
        subtree_is_active = match$1[2],
        written = match$1[1];
       if(1 - subtree_is_active){
        implicitly_close_idle_stream(i_node[1], max_seen_ids);
        remove_child(p_node, id);
       }
       if(0 !== written){
        if(subtree_is_active) update_t(i_node, written);
        return [0, written, subtree_is_active];
       }
       var remaining_children = remaining_children$0;
      }
     }
     schedule(t);
     var _q_ = t[6];
     function _r_(id, closed){
      return 0 === closed[2]
              ? (caml_call2
                 (StreamsTbl[6], t[6], id),
                caml_call2(StreamsTbl[6], t[1], id))
              : (closed[2] = closed[2] - 1 | 0, 0);
     }
     return caml_call2(StreamsTbl[11], _r_, _q_);
    }
    function check_flow(flow$0, growth, flow){
     var
      _n_ = 0 < caml_call2(Stdlib_Int32[15], flow$0, 0) ? 1 : 0,
      _o_ =
        (0 < caml_call2(Stdlib_Int32[15], flow, growth) ? 1 : 0) === _n_
         ? 1
         : 0,
      _p_ =
        _o_
         ? caml_call2
            (Stdlib_Int32[15], flow, Dream_h2_Settings[1][2])
           <= 0
           ? 1
           : 0
         : _o_;
     return _p_;
    }
    function add_flow(stream, growth){
     if(0 === stream[0]){
      var
       flow = stream[4],
       flow$0 = flow + growth | 0,
       valid_flow = check_flow(flow, growth, flow$0);
      if(valid_flow) stream[4] = flow$0;
      return valid_flow;
     }
     var
      flow$1 = stream[7],
      flow$2 = flow$1 + growth | 0,
      valid_flow$0 = check_flow(flow$1, growth, flow$2);
     if(valid_flow$0) stream[7] = flow$2;
     return valid_flow$0;
    }
    function add_inflow(stream, growth){
     if(0 === stream[0]){
      var
       inflow = stream[5],
       inflow$0 = inflow + growth | 0,
       valid_inflow = check_flow(inflow, growth, inflow$0);
      if(valid_inflow) stream[5] = inflow$0;
      return valid_inflow;
     }
     var
      inflow$1 = stream[8],
      inflow$2 = inflow$1 + growth | 0,
      valid_inflow$0 = check_flow(inflow$1, growth, inflow$2);
     if(valid_inflow$0) stream[8] = inflow$2;
     return valid_inflow$0;
    }
    function deduct_inflow(t, size){
     if(0 === t[0]){var inflow = t[5]; t[5] = inflow - size | 0; return 0;}
     var inflow$0 = t[8];
     t[8] = inflow$0 - size | 0;
     return 0;
    }
    function pp_hum(fmt, param){
     var children = param[3];
     function pp_hum_inner(level, fmt, t){
      function pp_binding(fmt, param){
       var
        match = param[2],
        id = param[1],
        t = match[3],
        children = match[6],
        _i_ = level + 1 | 0;
       function _j_(_l_, _m_){return pp_hum_inner(_i_, _l_, _m_);}
       var _k_ = caml_call2(Stdlib_String[1], level * 2 | 0, 32);
       return caml_call7
               (Stdlib_Format[137], fmt, _h_, _k_, id, t, _j_, children);
      }
      return caml_call4(PriorityQueue[32], 0, pp_binding, fmt, t);
     }
     return pp_hum_inner(0, fmt, children);
    }
    return [0,
            PriorityTreeNode,
            PriorityQueue,
            make_root,
            create,
            stream_id,
            children,
            remove_child,
            update_children,
            set_parent,
            would_create_cycle,
            reprioritize_stream,
            update_t,
            update_t_last,
            add,
            get_node,
            find,
            iter,
            allowed_to_transmit,
            allowed_to_receive,
            write,
            mark_for_removal,
            implicitly_close_idle_stream,
            flush,
            check_flow,
            add_flow,
            add_inflow,
            deduct_inflow,
            pp_hum];
   }
   var Dream_h2_Scheduler = [0, StreamsTbl, Make];
   runtime.caml_register_global(22, Dream_h2_Scheduler, "Dream_h2__Scheduler");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Server_connection
//# unitInfo: Requires: Angstrom, Bigstringaf, CamlinternalLazy, Dream_h2__Body, Dream_h2__Config, Dream_h2__Error, Dream_h2__Flags, Dream_h2__Headers, Dream_h2__Message, Dream_h2__Parse, Dream_h2__Priority, Dream_h2__Reqd, Dream_h2__Request, Dream_h2__Scheduler, Dream_h2__Serialize, Dream_h2__Settings, Dream_h2__Status, Dream_h2__Stream, Dream_h2__Stream_identifier, Dream_hpack__Hpack, Dream_httpaf___Httpaf, Faraday, Stdlib__Format, Stdlib__Int32, Stdlib__Int64, Stdlib__List, Stdlib__Printexc, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Window_size_for_stream_wou = "Window size for stream would exceed ",
    cst_Window_size_for_stream_wou$0 =
      "Window size for stream would exceed %ld",
    cst_src_vendor_h2_lib_server_c = "src/vendor/h2/lib/server_connection.ml",
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Dream_h2_Serialize = global_data.Dream_h2__Serialize,
    Dream_h2_Parse = global_data.Dream_h2__Parse,
    Dream_h2_Config = global_data.Dream_h2__Config,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Dream_h2_Headers = global_data.Dream_h2__Headers,
    Dream_h2_Settings = global_data.Dream_h2__Settings,
    Dream_h2_Error = global_data.Dream_h2__Error,
    Faraday = global_data.Faraday,
    Dream_h2_Priority = global_data.Dream_h2__Priority,
    Dream_h2_Reqd = global_data.Dream_h2__Reqd,
    Dream_h2_Body = global_data.Dream_h2__Body,
    Stdlib_List = global_data.Stdlib__List,
    Dream_hpack_Hpack = global_data.Dream_hpack__Hpack,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Dream_h2_Stream_identifier = global_data.Dream_h2__Stream_identifier,
    Dream_h2_Status = global_data.Dream_h2__Status,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Bigstringaf = global_data.Bigstringaf,
    Dream_h2_Flags = global_data.Dream_h2__Flags,
    Stdlib_Format = global_data.Stdlib__Format,
    Dream_h2_Stream = global_data.Dream_h2__Stream,
    Dream_h2_Message = global_data.Dream_h2__Message,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Assert_failure = global_data.Assert_failure,
    Angstrom = global_data.Angstrom,
    Dream_h2_Request = global_data.Dream_h2__Request,
    Dream_h2_Scheduler = global_data.Dream_h2__Scheduler,
    id = Dream_h2_Stream[3],
    is_idle = Dream_h2_Stream[4],
    finish_stream = Dream_h2_Stream[6],
    flush_write_body = Dream_h2_Reqd[27],
    requires_output = Dream_h2_Reqd[23],
    Scheduler =
      caml_call1
       (Dream_h2_Scheduler[2],
        [0, id, requires_output, flush_write_body, finish_stream, is_idle]),
    cst_connection = "connection",
    cst_http2_settings = "http2-settings",
    _m_ =
      [1,
       "A request that upgrades from HTTP/1.1 to HTTP/2 MUST include exactly one HTTP2-Settings header field and HTTP2-Settings as a connection option in the Connection header field."],
    _l_ =
      [0,
       "HEADERS or PUSH_PROMISE without the END_HEADERS flag set must be followed by a CONTINUATION frame for the same stream"],
    _k_ = [0, "Client cannot push"],
    _j_ =
      [0,
       [11, cst_Window_size_for_stream_wou, [5, 0, 0, 0, 0]],
       cst_Window_size_for_stream_wou$0],
    _i_ = [0, "Received unexpected SETTINGS frame with acknowledgement"],
    cst_Local = "Local",
    _h_ =
      [0,
       [11, cst_Window_size_for_stream_wou, [5, 0, 0, 0, 0]],
       cst_Window_size_for_stream_wou$0],
    _g_ = [0, cst_src_vendor_h2_lib_server_c, 567, 8],
    _f_ = [0, 1],
    _e_ = [0, 1],
    _d_ = [1, 510225313],
    _c_ = [1, -390842525],
    _b_ = [0, cst_src_vendor_h2_lib_server_c, 187, 4],
    _a_ = [0, cst_src_vendor_h2_lib_server_c, 161, 2];
   function is_closed(t){
    var _aT_ = caml_call1(Dream_h2_Parse[29][7], t[2]);
    return _aT_ ? caml_call1(Dream_h2_Serialize[20][29], t[3]) : _aT_;
   }
   function wakeup_writer(t){
    return caml_call1(Dream_h2_Serialize[20][23], t[3]);
   }
   function shutdown_reader(t){
    return caml_call1(Dream_h2_Parse[29][11], t[2]);
   }
   function shutdown_writer(t){
    caml_call1(Dream_h2_Serialize[20][27], t[3]);
    return wakeup_writer(t);
   }
   function shutdown(t){shutdown_reader(t); return shutdown_writer(t);}
   function was_closed_or_implicitly_close(t, stream_id){
    return caml_call1(Dream_h2_Stream_identifier[7], stream_id)
            ? caml_call2(Dream_h2_Stream_identifier[2], stream_id, t[9])
            : caml_call2(Dream_h2_Stream_identifier[2], stream_id, t[10]);
   }
   function report_error(t, param){
    if(0 === param[0]){
     var data = param[2], error = param[1], _aR_ = 1 - t[13];
     if(! _aR_) return _aR_;
     var
      debug_data =
        0 === caml_ml_string_length(data)
         ? Bigstringaf[2]
         : caml_call3(Bigstringaf[3], 0, caml_ml_string_length(data), data),
      frame_info =
        caml_call4
         (Dream_h2_Serialize[20][3], 0, 0, 0, Dream_h2_Stream_identifier[5]);
     caml_call5
      (Dream_h2_Serialize[20][21], t[3], frame_info, debug_data, t[9], error);
     var _aS_ = function(param){return shutdown(t);};
     caml_call2(Dream_h2_Serialize[20][24], t[3], _aS_);
     t[13] = 1;
     return wakeup_writer(t);
    }
    var
     error$0 = param[2],
     stream_id = param[1],
     match = caml_call2(Scheduler[16], t[7], stream_id);
    if(match){
     var reqd = match[1];
     caml_call2(Dream_h2_Stream[9], reqd, error$0);
    }
    else if(1 - was_closed_or_implicitly_close(t, stream_id)){
     var
      frame_info$0 = caml_call4(Dream_h2_Serialize[20][3], 0, 0, 0, stream_id);
     caml_call3(Dream_h2_Serialize[20][15], t[3], frame_info$0, error$0);
    }
    return wakeup_writer(t);
   }
   function report_connection_error(t, opt, error){
    if(opt) var sth = opt[1], reason = sth; else var reason = cst;
    return report_error(t, [0, error, reason]);
   }
   function report_stream_error(t, stream_id, error){return report_error(t, [1, stream_id, error]);
   }
   function set_error_and_handle(request, t, stream, error, error_code){
    if(0 !== request)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    caml_call3(Dream_h2_Reqd[19], stream, error, error_code);
    return wakeup_writer(t);
   }
   function report_exn(t, exn){
    var _aQ_ = 1 - is_closed(t);
    if(! _aQ_) return _aQ_;
    var reason = caml_call1(Stdlib_Printexc[1], exn);
    return report_connection_error(t, [0, reason], 2);
   }
   function on_close_stream(t, id, active, closed){
    if(active) t[8] = t[8] - 1 | 0;
    return caml_call3(Scheduler[21], t[7], id, closed);
   }
   function send_window_update(t, stream, n){
    function send_window_update_frame(stream_id, n){
     var valid_inflow = caml_call2(Scheduler[26], stream, n);
     if(! valid_inflow)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     var
      frame_info = caml_call4(Dream_h2_Serialize[20][3], 0, 0, 0, stream_id);
     return caml_call3(Dream_h2_Serialize[20][16], t[3], frame_info, n);
    }
    var _aP_ = 0 < caml_call2(Stdlib_Int32[15], n, 0) ? 1 : 0;
    if(! _aP_) return _aP_;
    var
     max_window_size = Dream_h2_Settings[1][2],
     stream_id = caml_call1(Scheduler[5], stream),
     n$0 = n;
    for(;;){
     if(! caml_greaterthan(n$0, max_window_size)){
      send_window_update_frame(stream_id, n$0);
      return wakeup_writer(t);
     }
     send_window_update_frame(stream_id, max_window_size);
     var n$1 = n$0 - max_window_size | 0, n$0 = n$1;
    }
   }
   function create_push_stream(t, parent_stream_id){
    var candidate_push_stream_id = t[10] + 2 | 0;
    if(! t[1][2]) return _d_;
    if
     (caml_call2
       (Dream_h2_Stream_identifier[3],
        candidate_push_stream_id,
        Dream_h2_Stream_identifier[9])){
     report_connection_error(t, 0, 0);
     return _c_;
    }
    t[10] = candidate_push_stream_id;
    function _aL_(_aN_, _aO_){
     return on_close_stream(t, candidate_push_stream_id, _aN_, _aO_);
    }
    var
     reqd =
       caml_call5
        (Dream_h2_Stream[2],
         candidate_push_stream_id,
         t[1][5],
         t[3],
         t[6],
         _aL_),
     _aM_ = Dream_h2_Priority[1];
    caml_call5
     (Scheduler[14],
      t[7],
      [0, _aM_[1], parent_stream_id, _aM_[3]],
      t[1][4],
      t[4][6],
      reqd);
    return [0, reqd];
   }
   function handle_headers(t, end_stream, stream, active_stream, headers){
    var reqd = stream[1];
    if(0 < caml_call2(Stdlib_Int32[15], t[8] + 1 | 0, t[4][5]))
     return 0 < t[12]
             ? report_stream_error(t, reqd[1], 7)
             : report_stream_error(t, reqd[1], 1);
    reqd[5] = [1, _e_, active_stream];
    t[8] = t[8] + 1 | 0;
    var match = caml_call1(Dream_h2_Headers[29], headers);
    if(typeof match === "number")
     return set_error_and_handle(0, t, reqd, -99004555, 1);
    var
     match$0 = match[2],
     scheme = match$0[3],
     path = match$0[2],
     meth = match$0[1],
     match$1 = caml_call1(Dream_h2_Message[2], headers);
    if(typeof match$1 !== "number" && 332360020 > match$1[1]){
     var e = match$1[2];
     return set_error_and_handle(0, t, reqd, e, 1);
    }
    var
     _aH_ = caml_call1(Dream_httpaf_Httpaf[2][5], meth),
     request =
       caml_call4(Dream_h2_Request[1], [0, headers], scheme, _aH_, path);
    if(end_stream)
     var request_body = Dream_h2_Body[1][6];
    else
     var
      _aI_ =
        function(len){
         var _aK_ = reqd[5];
         if(typeof _aK_ !== "number" && 1 === _aK_[0]){
          send_window_update(t, t[7], len);
          return send_window_update(t, stream, len);
         }
         return 0;
        },
      _aJ_ = caml_call1(Bigstringaf[1], t[4][2]),
      request_body = caml_call2(Dream_h2_Body[1][4], _aJ_, _aI_);
    var request_info = caml_call2(Dream_h2_Reqd[1], request, request_body);
    if(end_stream){
     reqd[5] = [1, [1, request_info], active_stream];
     caml_call1(Dream_h2_Body[1][12], request_body);
    }
    else
     reqd[5] = [1, [0, [1, request_info]], active_stream];
    caml_call1(t[5], reqd);
    return wakeup_writer(t);
   }
   function handle_headers_block
   (t, opt, stream, active_stream, partial_headers, flags, headers_block){
    if(opt) var sth = opt[1], is_trailers = sth; else var is_trailers = 0;
    var
     reqd = stream[1],
     end_headers = caml_call1(Dream_h2_Flags[7], flags),
     parse_state =
       caml_call2
        (Angstrom[76][2], partial_headers[1], [0, 608227697, headers_block]);
    if(! end_headers){partial_headers[1] = parse_state; return 0;}
    t[11] = 0;
    var parse_state$0 = caml_call2(Angstrom[76][2], parse_state, 3456156);
    switch(parse_state$0[0]){
      case 1:
       var match = parse_state$0[2];
       if(0 === match[0]){
        var headers = match[1];
        if(! is_trailers){
         t[9] = reqd[1];
         return handle_headers
                 (t, partial_headers[2], stream, active_stream, headers);
        }
        if(! caml_call1(Dream_h2_Headers[30], headers))
         return set_error_and_handle(0, t, reqd, -99004555, 1);
        caml_call2(Dream_h2_Reqd[28], reqd, headers);
        var request_body = caml_call1(Dream_h2_Reqd[4], reqd);
        return caml_call1(Dream_h2_Body[1][12], request_body);
       }
       break;
      case 2:
       var message = parse_state$0[3];
       return report_connection_error(t, [0, message], 9);
    }
    return report_connection_error(t, 0, 9);
   }
   function handle_trailer_headers(_aB_){
    return function(_aC_, _aD_, _aE_, _aF_, _aG_){
     return handle_headers_block(_aB_, _f_, _aC_, _aD_, _aE_, _aF_, _aG_);};
   }
   function open_stream(t, priority, stream_id){
    if(! caml_call2(Dream_h2_Stream_identifier[3], stream_id, t[9])){report_connection_error(t, 0, 1); return 0;}
    var match = caml_call2(Scheduler[15], t[7], stream_id);
    if(match){var stream = match[1]; stream[7] = t[1][4]; return [0, stream];}
    function _ay_(_az_, _aA_){
     return on_close_stream(t, stream_id, _az_, _aA_);
    }
    var
     reqd =
       caml_call5(Dream_h2_Stream[2], stream_id, t[1][5], t[3], t[6], _ay_),
     stream$0 =
       caml_call5(Scheduler[14], t[7], priority, t[1][4], t[4][6], reqd);
    return [0, stream$0];
   }
   function process_first_headers_block
   (t, frame_header, stream, headers_block){
    var
     reqd = stream[1],
     stream_id = frame_header[3],
     flags = frame_header[2],
     end_headers = caml_call1(Dream_h2_Flags[7], flags),
     headers_block_length = caml_call1(Bigstringaf[6], headers_block),
     initial_buffer_size =
       end_headers ? headers_block_length : 2 * headers_block_length | 0,
     _au_ = caml_call1(Dream_h2_Flags[2], flags),
     _av_ = caml_call1(Dream_hpack_Hpack[2][3], t[15]),
     partial_headers =
       [0, caml_call2(Angstrom[76][1], [0, initial_buffer_size], _av_), _au_];
    function _aw_(_ax_){return create_push_stream(t, _ax_);}
    var active_stream = caml_call3(Dream_h2_Reqd[2], t[14], t[4][3], _aw_);
    reqd[5] = [1, [0, [0, partial_headers]], active_stream];
    if(1 - end_headers) t[11] = [0, stream_id];
    return handle_headers_block
            (t,
             0,
             stream,
             active_stream,
             partial_headers,
             flags,
             headers_block);
   }
   function process_trailer_headers
   (t, stream, active_stream, frame_header, headers_block){
    var
     reqd = stream[1],
     stream_id = frame_header[3],
     flags = frame_header[2],
     end_stream = caml_call1(Dream_h2_Flags[2], flags);
    if(! end_stream) return set_error_and_handle(0, t, reqd, -99004555, 1);
    var
     _at_ = caml_call1(Dream_hpack_Hpack[2][3], t[15]),
     partial_headers = [0, caml_call2(Angstrom[76][1], 0, _at_), end_stream];
    active_stream[4] = [0, partial_headers];
    if(1 - caml_call1(Dream_h2_Flags[7], flags)) t[11] = [0, stream_id];
    return handle_trailer_headers(t)
            (stream, active_stream, partial_headers, flags, headers_block);
   }
   function process_headers_frame(t, param, priority, headers_block){
    var
     frame_header = param[1],
     stream_id = frame_header[3],
     stream_dependency = priority[2];
    if(! caml_call1(Dream_h2_Stream_identifier[7], stream_id))
     return report_connection_error(t, 0, 1);
    if
     (caml_call2(Dream_h2_Stream_identifier[1], stream_dependency, stream_id))
     return report_stream_error(t, stream_id, 1);
    var match = caml_call2(Scheduler[15], t[7], stream_id);
    if(! match){
     var match$1 = open_stream(t, priority, stream_id);
     if(! match$1) return 0;
     var reqd$1 = match$1[1];
     return process_first_headers_block
             (t, frame_header, reqd$1, headers_block);
    }
    var stream = match[1], reqd = stream[1], _ap_ = reqd[5];
    if(typeof _ap_ === "number"){
     var match$0 = open_stream(t, priority, stream_id);
     if(! match$0) return 0;
     var reqd$0 = match$0[1];
     return process_first_headers_block
             (t, frame_header, reqd$0, headers_block);
    }
    a:
    {
     switch(_ap_[0]){
       case 1:
        var _aq_ = _ap_[1];
        if(0 !== _aq_[0]) break a;
        var _ar_ = _aq_[1];
        b:
        {
         if(typeof _ar_ === "number"){if(0 === _ar_) break b;}
         else if(0 === _ar_[0]) break b;
         var active_stream = _ap_[2];
         process_trailer_headers
          (t, stream, active_stream, frame_header, headers_block);
         return caml_call2(Dream_h2_Stream[6], reqd, 0);
        }
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
       case 2:
        var _as_ = _ap_[1][1];
        if(typeof _as_ !== "number" && 0 !== _as_[0]) break a;
        break;
     }
     return report_connection_error(t, 0, 5);
    }
    return report_stream_error(t, stream_id, 5);
   }
   function process_data_frame(t, param, bstr){
    var
     frame_header = param[1],
     stream_id = frame_header[3],
     flags = frame_header[2],
     payload_length = frame_header[1];
    if(! caml_call1(Dream_h2_Stream_identifier[7], stream_id))
     return report_connection_error(t, 0, 1);
    caml_call2(Scheduler[27], t[7], payload_length);
    var match = caml_call2(Scheduler[15], t[7], stream_id);
    if(! match){
     var _ao_ = 1 - was_closed_or_implicitly_close(t, stream_id);
     return _ao_ ? report_connection_error(t, 0, 1) : _ao_;
    }
    var stream = match[1], descriptor = stream[1], _aj_ = descriptor[5];
    if(typeof _aj_ === "number") return report_connection_error(t, 0, 1);
    switch(_aj_[0]){
      case 1:
       var _ak_ = _aj_[1];
       if(0 === _ak_[0]){
        var match$0 = _ak_[1];
        if(typeof match$0 !== "number" && 0 !== match$0[0]){
         var
          active_stream = _aj_[2],
          request_info = match$0[1],
          request_body = caml_call1(Dream_h2_Reqd[4], descriptor),
          _al_ = caml_int64_of_int32(caml_call1(Bigstringaf[6], bstr));
         request_info[3] = caml_int64_add(request_info[3], _al_);
         var request = request_info[1];
         if(! caml_call3(Scheduler[19], t[7], stream, payload_length)){
          send_window_update(t, t[7], payload_length);
          return report_stream_error(t, stream_id, 3);
         }
         caml_call2(Scheduler[27], stream, payload_length);
         var match$1 = caml_call1(Dream_h2_Message[2], request[4]);
         if(typeof match$1 !== "number" && 332360020 === match$1[1]){
          var len = match$1[2];
          if(0 < caml_call2(Stdlib_Int64[15], request_info[3], len)){
           send_window_update(t, t[7], payload_length);
           return set_error_and_handle(0, t, descriptor, -99004555, 1);
          }
         }
         var end_stream = caml_call1(Dream_h2_Flags[2], flags);
         if(end_stream)
          if(caml_call1(Dream_h2_Reqd[23], descriptor))
           descriptor[5] = [1, [1, request_info], active_stream];
          else
           caml_call2(Dream_h2_Stream[6], descriptor, 0);
         var faraday = caml_call1(Dream_h2_Body[1][8], request_body);
         if(1 - caml_call1(Faraday[20], faraday)){
          caml_call4(Faraday[11], faraday, 0, 0, bstr);
          if(end_stream) caml_call1(Dream_h2_Body[1][12], request_body);
         }
         return caml_call1(Dream_h2_Reqd[24], descriptor);
        }
       }
       break;
      case 2:
       var _am_ = _aj_[1][1];
       if(typeof _am_ !== "number" && 1 !== _am_[0]){
        var _an_ = _am_[1];
        if(typeof _an_ !== "number") break;
        if(_an_) break;
        return send_window_update(t, t[7], payload_length);
       }
       break;
    }
    send_window_update(t, t[7], payload_length);
    return report_stream_error(t, stream_id, 5);
   }
   function process_priority_frame(t, param, priority){
    var
     frame_header = param[1],
     stream_id = frame_header[3],
     stream_dependency = priority[2];
    if(! caml_call1(Dream_h2_Stream_identifier[7], stream_id))
     return report_connection_error(t, 0, 1);
    if
     (caml_call2(Dream_h2_Stream_identifier[1], stream_id, stream_dependency))
     return report_stream_error(t, stream_id, 1);
    var match = caml_call2(Scheduler[15], t[7], stream_id);
    if(match){
     var stream = match[1];
     return caml_call3(Scheduler[11], t[7], priority, stream);
    }
    var _ae_ = 1 - was_closed_or_implicitly_close(t, stream_id);
    if(_ae_){
     var
      _af_ =
        function(_ah_, _ai_){
         return on_close_stream(t, stream_id, _ah_, _ai_);
        },
      reqd =
        caml_call5(Dream_h2_Stream[2], stream_id, t[1][5], t[3], t[6], _af_);
     caml_call5(Scheduler[14], t[7], priority, t[1][4], t[4][6], reqd);
     var _ag_ = 0;
    }
    else
     var _ag_ = _ae_;
    return _ag_;
   }
   function process_rst_stream_frame(t, param, error_code){
    var frame_header = param[1], stream_id = frame_header[3];
    if(! caml_call1(Dream_h2_Stream_identifier[7], stream_id))
     return report_connection_error(t, 0, 1);
    var match = caml_call2(Scheduler[16], t[7], stream_id);
    if(match){
     var reqd = match[1];
     return typeof reqd[5] === "number"
             ? report_connection_error(t, 0, 1)
             : caml_call2(Dream_h2_Stream[6], reqd, [1, error_code]);
    }
    var _ad_ = 1 - was_closed_or_implicitly_close(t, stream_id);
    return _ad_ ? report_connection_error(t, 0, 1) : _ad_;
   }
   function apply_settings_list(t, settings){
    var _W_ = t[1];
    function _X_(acc, item){
     switch(item[0]){
       case 0:
        var x = item[1];
        caml_call2(Dream_hpack_Hpack[1][3], t[14], x);
        return [0, x, acc[2], acc[3], acc[4], acc[5], acc[6]];
       case 1:
        var x$0 = item[1];
        return [0, acc[1], 1 === x$0 ? 1 : 0, acc[3], acc[4], acc[5], acc[6]];
       case 2:
        var x$1 = item[1];
        return [0, acc[1], acc[2], x$1, acc[4], acc[5], acc[6]];
       case 3:
        var
         new_val = item[1],
         old_val = acc[4],
         growth = new_val - old_val | 0,
         Local = [248, cst_Local, runtime.caml_fresh_oo_id(0)];
        try{
         var
          _Z_ =
            function(stream){
             var _ac_ = 1 - caml_call2(Scheduler[25], stream, growth);
             if(_ac_) throw caml_maybe_attach_backtrace(Local, 1);
             return _ac_;
            };
         caml_call2(Scheduler[17], t[7], _Z_);
        }
        catch(_ab_){
         var _Y_ = caml_wrap_exception(_ab_);
         if(_Y_ !== Local) throw caml_maybe_attach_backtrace(_Y_, 0);
         report_connection_error
          (t,
           [0, caml_call2(Stdlib_Format[140], _h_, Dream_h2_Settings[1][2])],
           3);
        }
        return [0, acc[1], acc[2], acc[3], new_val, acc[5], acc[6]];
       case 4:
        var
         x$2 = item[1],
         ___ =
           function(param){
            var
             descriptor = param[1],
             _$_ = caml_call1(Dream_h2_Reqd[23], descriptor),
             _aa_ = _$_ ? (descriptor[6] = x$2, 0) : _$_;
            return _aa_;
           };
        caml_call2(Scheduler[17], t[7], ___);
        return [0, acc[1], acc[2], acc[3], acc[4], x$2, acc[6]];
       default:
        var x$3 = item[1];
        return [0, acc[1], acc[2], acc[3], acc[4], acc[5], [0, x$3]];
     }
    }
    var new_settings = caml_call3(Stdlib_List[26], _X_, _W_, settings);
    t[1] = new_settings;
    return 0;
   }
   function write_settings_frame(t, ack, settings){
    var
     flags =
       ack
        ? caml_call1(Dream_h2_Flags[6], Dream_h2_Flags[1])
        : Dream_h2_Flags[1],
     frame_info =
       caml_call4
        (Dream_h2_Serialize[20][3],
         0,
         [0, flags],
         0,
         Dream_h2_Stream_identifier[5]);
    caml_call3(Dream_h2_Serialize[20][19], t[3], frame_info, settings);
    var _U_ = 1 - ack, _V_ = _U_ ? (t[12] = t[12] + 1 | 0, 0) : _U_;
    return _V_;
   }
   function process_settings_frame(t, param, settings){
    var frame_header = param[1], flags = frame_header[2];
    if(caml_call1(Dream_h2_Flags[5], flags)){
     t[12] = t[12] - 1 | 0;
     var _T_ = t[12] < 0 ? 1 : 0;
     return _T_ ? report_connection_error(t, _i_, 1) : _T_;
    }
    var match = caml_call2(Dream_h2_Settings[5], 0, settings);
    if(0 === match[0]){
     apply_settings_list(t, settings);
     write_settings_frame(t, 1, 0);
     return wakeup_writer(t);
    }
    var error = match[1];
    return report_error(t, error);
   }
   function process_ping_frame(t, param, payload){
    var
     frame_header = param[1],
     flags = frame_header[2],
     _Q_ = 1 - caml_call1(Dream_h2_Flags[5], flags);
    if(! _Q_) return _Q_;
    var
     _R_ = Dream_h2_Stream_identifier[5],
     _S_ = [0, caml_call1(Dream_h2_Flags[6], Dream_h2_Flags[1])],
     frame_info = caml_call4(Dream_h2_Serialize[20][3], 0, _S_, 0, _R_);
    caml_call4(Dream_h2_Serialize[20][20], t[3], frame_info, 0, payload);
    return wakeup_writer(t);
   }
   function process_goaway_frame(t, frame, param, data, error){
    var
     len = caml_call1(Bigstringaf[6], data),
     reason = 0 === len ? 0 : [0, caml_call3(Bigstringaf[7], data, 0, len)];
    return report_connection_error(t, reason, error);
   }
   function add_window_increment(t, stream, increment){
    var
     did_add = caml_call2(Scheduler[25], stream, increment),
     stream_id = caml_call1(Scheduler[5], stream);
    if(0 === stream[0])
     var flow = stream[4], new_flow = flow;
    else
     var flow$0 = stream[7], new_flow = flow$0;
    if(! did_add)
     return caml_call1(Dream_h2_Stream_identifier[6], stream_id)
             ? report_connection_error
               (t,
                [0,
                 caml_call2(Stdlib_Printf[4], _j_, Dream_h2_Settings[1][2])],
                3)
             : report_stream_error(t, stream_id, 3);
    var _P_ = 0 < caml_call2(Stdlib_Int32[15], new_flow, 0) ? 1 : 0;
    return _P_ ? wakeup_writer(t) : _P_;
   }
   function process_window_update_frame(t, param, window_increment){
    var frame_header = param[1], stream_id = frame_header[3];
    if(caml_call1(Dream_h2_Stream_identifier[6], stream_id))
     return add_window_increment(t, t[7], window_increment);
    var match = caml_call2(Scheduler[15], t[7], stream_id);
    if(match){
     var
      stream_node = match[1],
      descriptor = stream_node[1],
      _N_ = descriptor[5];
     return typeof _N_ === "number"
             ? report_connection_error(t, 0, 1)
             : 2
               === _N_[0]
               ? 0
               : add_window_increment(t, stream_node, window_increment);
    }
    var _O_ = 1 - was_closed_or_implicitly_close(t, stream_id);
    return _O_ ? report_connection_error(t, 0, 1) : _O_;
   }
   function process_continuation_frame(t, param, headers_block){
    var
     frame_header = param[1],
     stream_id = frame_header[3],
     flags = frame_header[2];
    if(! caml_call1(Dream_h2_Stream_identifier[7], stream_id))
     return report_connection_error(t, 0, 1);
    var match = caml_call2(Scheduler[15], t[7], stream_id);
    if(! match) return report_connection_error(t, 0, 1);
    var stream = match[1], descriptor = stream[1], _L_ = descriptor[5];
    if(typeof _L_ !== "number" && 1 === _L_[0]){
     var _M_ = _L_[1];
     if(0 === _M_[0]){
      var match$0 = _M_[1];
      if(typeof match$0 !== "number"){
       if(0 === match$0[0]){
        var active_stream = _L_[2], partial_headers = match$0[1];
        return handle_headers_block
                (t,
                 0,
                 stream,
                 active_stream,
                 partial_headers,
                 flags,
                 headers_block);
       }
       var active_stream$0 = _L_[2], match$1 = active_stream$0[4];
       if(match$1){
        var partial_headers$0 = match$1[1];
        return handle_trailer_headers(t)
                (stream,
                 active_stream$0,
                 partial_headers$0,
                 flags,
                 headers_block);
       }
      }
     }
    }
    return report_connection_error(t, 0, 1);
   }
   function default_error_handler(param, error, handle){
    if(typeof error === "number")
     var message = caml_call1(Dream_h2_Status[11], error);
    else
     var exn = error[2], message = caml_call1(Stdlib_Printexc[1], exn);
    var body = caml_call1(handle, Dream_h2_Headers[1]);
    caml_call4(Dream_h2_Body[2][5], body, 0, 0, message);
    return caml_call1(Dream_h2_Body[2][11], body);
   }
   function write_connection_preface(t){
    var settings = caml_call1(Dream_h2_Settings[7], t[1]), _J_ = t[1];
    t[1] =
     [0, _J_[1], _J_[2], _J_[3], Dream_h2_Settings[6][4], _J_[5], _J_[6]];
    write_settings_frame(t, 0, settings);
    var _K_ = caml_greaterthan(t[4][6], Dream_h2_Settings[6][4]);
    if(! _K_) return _K_;
    var diff = t[4][6] - Dream_h2_Settings[6][4] | 0;
    return send_window_update(t, t[7], diff);
   }
   function create_generic(h2c, config, error_handler, request_handler){
    var
     settings = caml_call1(Dream_h2_Config[2], config),
     writer = caml_call1(Dream_h2_Serialize[20][1], settings[5]),
     connection_preface_handler =
       function _I_(_G_, _H_){return _I_.fun(_G_, _H_);},
     frame_handler = function _F_(_E_){return _F_.fun(_E_);},
     t = [];
    caml_update_dummy
     (connection_preface_handler,
      function(recv_frame, settings_list){
       var _D_ = caml_obj_tag(t);
       a:
       if(250 === _D_)
        var t$0 = t[1];
       else{
        if(246 !== _D_ && 244 !== _D_){var t$0 = t; break a;}
        var t$0 = caml_call1(CamlinternalLazy[2], t);
       }
       if(1 - h2c) write_connection_preface(t$0);
       return process_settings_frame(t$0, recv_frame, settings_list);
      });
    caml_update_dummy
     (frame_handler,
      function(r){
       var _C_ = caml_obj_tag(t);
       a:
       if(250 === _C_)
        var t$0 = t[1];
       else{
        if(246 !== _C_ && 244 !== _C_){var t$0 = t; break a;}
        var t$0 = caml_call1(CamlinternalLazy[2], t);
       }
       if(0 !== r[0]){var e = r[1]; return report_error(t$0, e);}
       var
        frame = r[1],
        frame_payload = frame[2],
        frame_header = frame[1],
        match = t$0[11];
       a:
       if(match){
        var stream_id = match[1];
        if
         (caml_call2
           (Dream_h2_Stream_identifier[1], stream_id, frame_header[3])
          && 9 === frame_header[4])
         break a;
        return report_connection_error(t$0, _l_, 1);
       }
       switch(frame_payload[0]){
         case 0:
          var bs = frame_payload[1];
          return process_data_frame(t$0, frame, bs);
         case 1:
          var headers_block = frame_payload[2], priority = frame_payload[1];
          return process_headers_frame(t$0, frame, priority, headers_block);
         case 2:
          var priority$0 = frame_payload[1];
          return process_priority_frame(t$0, frame, priority$0);
         case 3:
          var error_code = frame_payload[1];
          return process_rst_stream_frame(t$0, frame, error_code);
         case 4:
          var settings = frame_payload[1];
          return process_settings_frame(t$0, frame, settings);
         case 5:
          return report_connection_error(t$0, _k_, 1);
         case 6:
          var data = frame_payload[1];
          return process_ping_frame(t$0, frame, data);
         case 7:
          var
           data$0 = frame_payload[3],
           error = frame_payload[2],
           last_stream_id = frame_payload[1];
          return process_goaway_frame
                  (t$0, frame, last_stream_id, data$0, error);
         case 8:
          var window_size = frame_payload[1];
          return process_window_update_frame(t$0, frame, window_size);
         case 9:
          var headers_block$0 = frame_payload[1];
          return process_continuation_frame(t$0, frame, headers_block$0);
         default: return 0;
       }
      });
    caml_update_dummy
     (t,
      [246,
       function(param){
        var
         _z_ = caml_call1(Dream_hpack_Hpack[2][1], settings[1]),
         _A_ = caml_call1(Dream_hpack_Hpack[1][1], settings[1]),
         _B_ = caml_call2(Scheduler[3], 0, 0);
        return [0,
                settings,
                caml_call3
                 (Dream_h2_Parse[29][6],
                  settings[5],
                  connection_preface_handler,
                  frame_handler),
                writer,
                config,
                request_handler,
                error_handler,
                _B_,
                0,
                0,
                0,
                0,
                0,
                0,
                _A_,
                _z_];
       }]);
    var _y_ = caml_obj_tag(t);
    if(250 === _y_) return t[1];
    if(246 !== _y_ && 244 !== _y_) return t;
    return caml_call1(CamlinternalLazy[2], t);
   }
   function create(opt, _x_, request_handler){
    if(opt)
     var sth = opt[1], config = sth;
    else
     var config = Dream_h2_Config[1];
    if(_x_)
     var sth$0 = _x_[1], error_handler = sth$0;
    else
     var error_handler = default_error_handler;
    return create_generic(0, config, error_handler, request_handler);
   }
   function handle_h2c_request(t, headers, request_body_iovecs){
    var match = open_stream(t, Dream_h2_Priority[1], 1);
    if(! match) return 0;
    var stream = match[1], reqd = stream[1];
    function _r_(_w_){return create_push_stream(t, _w_);}
    var active_stream = caml_call3(Dream_h2_Reqd[2], t[14], t[4][3], _r_);
    t[9] = reqd[1];
    var
     lengthv = caml_call1(Dream_httpaf_Httpaf[8][2], request_body_iovecs),
     end_stream = 0 === lengthv ? 1 : 0;
    handle_headers(t, end_stream, stream, active_stream, headers);
    var
     request = caml_call1(Dream_h2_Reqd[3], reqd),
     request_body = caml_call1(Dream_h2_Reqd[4], reqd),
     request_info = caml_call2(Dream_h2_Reqd[1], request, request_body);
    request_info[3] =
     caml_int64_add(request_info[3], caml_int64_of_int32(lengthv));
    reqd[5] = [1, [1, request_info], active_stream];
    var _s_ = 1 - end_stream;
    if(_s_){
     var
      faraday = caml_call1(Dream_h2_Body[1][8], request_body),
      _t_ = 1 - caml_call1(Faraday[20], faraday);
     if(_t_){
      var
       _u_ =
         function(param){
          var len = param[3], off = param[2], buffer = param[1];
          return caml_call4(Faraday[11], faraday, [0, off], [0, len], buffer);
         };
      caml_call2(Stdlib_List[18], _u_, request_body_iovecs);
      return caml_call1(Dream_h2_Body[1][12], request_body);
     }
     var _v_ = _t_;
    }
    else
     var _v_ = _s_;
    return _v_;
   }
   function create_h2c(opt, _o_, http_request, _n_, request_handler){
    if(opt)
     var sth = opt[1], config = sth;
    else
     var config = Dream_h2_Config[1];
    if(_o_)
     var sth$0 = _o_[1], error_handler = sth$0;
    else
     var error_handler = default_error_handler;
    if(_n_)
     var sth$1 = _n_[1], request_body = sth$1;
    else
     var request_body = 0;
    var
     headers = http_request[4],
     _p_ = caml_call2(Dream_httpaf_Httpaf[4][15], headers, cst_connection),
     _q_ = caml_call2(Dream_httpaf_Httpaf[4][15], headers, cst_http2_settings);
    if(_q_ && ! _q_[2] && _p_ && ! _p_[2]){
     var connection = _p_[1], settings = _q_[1];
     if(caml_call1(Dream_h2_Headers[31], connection)){
      var match = caml_call1(Dream_h2_Headers[32], http_request);
      if(0 !== match[0]){var msg$0 = match[1]; return [1, msg$0];}
      var
       h2_headers = match[1],
       match$0 = caml_call1(Dream_h2_Settings[11], settings);
      if(0 !== match$0[0]){var msg = match$0[1]; return [1, msg];}
      var
       upgrade_settings = match$0[1],
       settings_list = caml_call1(Dream_h2_Settings[7], upgrade_settings),
       match$1 = caml_call2(Dream_h2_Settings[5], 0, settings_list);
      if(0 === match$1[0]){
       var t = create_generic(1, config, error_handler, request_handler);
       apply_settings_list(t, settings_list);
       write_connection_preface(t);
       handle_h2c_request(t, h2_headers, request_body);
       return [0, t];
      }
      var error = match$1[1];
      return [1, caml_call1(Dream_h2_Error[1], error)];
     }
    }
    return _m_;
   }
   function next_read_operation(t){
    if(caml_call1(Dream_h2_Parse[29][7], t[2])) shutdown_reader(t);
    var operation = caml_call1(Dream_h2_Parse[29][14], t[2]);
    if(typeof operation === "number") return operation;
    var e = operation[2];
    report_error(t, e);
    return 0 === e[0] ? -611285096 : 914388854;
   }
   function read(t, bs, off, len){
    return caml_call5(Dream_h2_Parse[29][10], t[2], bs, off, len, 1);
   }
   function read_eof(t, bs, off, len){
    return caml_call5(Dream_h2_Parse[29][10], t[2], bs, off, len, 0);
   }
   function yield_reader(t, k){return caml_call1(k, 0);}
   function next_write_operation(t){
    caml_call2(Scheduler[23], t[7], [0, t[9], t[10]]);
    return caml_call1(Dream_h2_Serialize[20][32], t[3]);
   }
   function report_write_result(t, result){
    return caml_call2(Dream_h2_Serialize[20][31], t[3], result);
   }
   function yield_writer(t, k){
    return caml_call2(Dream_h2_Serialize[20][22], t[3], k);
   }
   var
    Dream_h2_Server_connection =
      [0,
       Scheduler,
       is_closed,
       wakeup_writer,
       shutdown_reader,
       shutdown_writer,
       shutdown,
       was_closed_or_implicitly_close,
       report_error,
       report_connection_error,
       report_stream_error,
       set_error_and_handle,
       report_exn,
       on_close_stream,
       send_window_update,
       create_push_stream,
       handle_headers,
       handle_headers_block,
       handle_trailer_headers,
       open_stream,
       process_first_headers_block,
       process_trailer_headers,
       process_headers_frame,
       process_data_frame,
       process_priority_frame,
       process_rst_stream_frame,
       apply_settings_list,
       write_settings_frame,
       process_settings_frame,
       process_ping_frame,
       process_goaway_frame,
       add_window_increment,
       process_window_update_frame,
       process_continuation_frame,
       default_error_handler,
       write_connection_preface,
       create_generic,
       create,
       handle_h2c_request,
       create_h2c,
       next_read_operation,
       read,
       read_eof,
       yield_reader,
       next_write_operation,
       report_write_result,
       yield_writer];
   runtime.caml_register_global
    (52, Dream_h2_Server_connection, "Dream_h2__Server_connection");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Respd
//# unitInfo: Requires: Bigstringaf, Dream_h2__Body, Dream_h2__Flags, Dream_h2__Serialize, Dream_h2__Stream, Stdlib, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_h2_Respd_response_exn_resp$1 =
      "h2.Respd.response_exn: response has not arrived",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Dream_h2_Body = global_data.Dream_h2__Body,
    Assert_failure = global_data.Assert_failure,
    Dream_h2_Flags = global_data.Dream_h2__Flags,
    Dream_h2_Serialize = global_data.Dream_h2__Serialize,
    Bigstringaf = global_data.Bigstringaf,
    Dream_h2_Stream = global_data.Dream_h2__Stream,
    Stdlib = global_data.Stdlib,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    _b_ = [0, "src/vendor/h2/lib/respd.ml", 188, 9],
    _a_ = [0, 0],
    cst_h2_Respd_response_exn_resp$0 = cst_h2_Respd_response_exn_resp$1,
    cst_h2_Respd_response_exn_stre =
      "h2.Respd.response_exn: stream already closed",
    cst_h2_Respd_response_exn_resp = cst_h2_Respd_response_exn_resp$1;
   function create_active_response(response, response_body){
    return [1, [0, response, response_body, Stdlib_Int64[1], 0]];
   }
   function response_body_exn(t){
    var _x_ = t[5];
    if(typeof _x_ !== "number")
     switch(_x_[0]){
       case 1:
        var _y_ = _x_[1];
        a:
        {
         b:
         {
          if(0 === _y_[0]){
           var _z_ = _y_[1];
           if(typeof _z_ !== "number" && 1 === _z_[0]){var response_body = _z_[1][2]; break b;}
           break a;
          }
          var _A_ = _y_[1];
          if(typeof _A_ !== "number" && 1 === _A_[0]){var response_body = _A_[1][2]; break b;}
          break a;
         }
         return response_body;
        }
        return caml_call1(Stdlib[2], cst_h2_Respd_response_exn_resp$0);
       case 2:
        return caml_call1(Stdlib[2], cst_h2_Respd_response_exn_stre);
     }
    return caml_call1(Stdlib[2], cst_h2_Respd_response_exn_resp);
   }
   function close_stream(t){
    var _w_ = t[5];
    if(typeof _w_ !== "number" && 1 === _w_[0])
     return 0 === _w_[1][0] ? 0 : caml_call2(Dream_h2_Stream[6], t, 0);
    return 0;
   }
   function report_error(t, response_body, error, error_code){
    if(typeof t[4] !== "number") return 0;
    if(response_body){
     var response_body$0 = response_body[1];
     caml_call1(Dream_h2_Body[1][12], response_body$0);
    }
    t[4] = caml_call2(Dream_h2_Stream[8], error, error_code);
    return caml_call1(t[3], error);
   }
   function report_error$0(t, error, error_code){
    var _r_ = t[5];
    a:
    if(typeof _r_ !== "number"){
     switch(_r_[0]){
       case 0:
        var _s_ = _r_[1];
        if(typeof _s_ !== "number" && 1 === _s_[0]){var s = _s_[1]; break;}
        return 0;
       case 1:
        var _t_ = _r_[1];
        b:
        {
         c:
         {
          if(0 === _t_[0]){
           var _u_ = _t_[1];
           if(typeof _u_ !== "number" && 0 !== _u_[0]){var response_body = _u_[1][2]; break c;}
           break b;
          }
          var _v_ = _t_[1];
          if(typeof _v_ !== "number" && 0 !== _v_[0]){var response_body = _v_[1][2]; break c;}
          break b;
         }
         var s$0 = _r_[2];
         caml_call1(Dream_h2_Body[2][11], s$0[2]);
         report_error(t, [0, response_body], error, error_code);
         return caml_call2(Dream_h2_Stream[9], t, error_code);
        }
        var s = _r_[2];
        break;
       default: break a;
     }
     caml_call1(Dream_h2_Body[2][11], s[2]);
     report_error(t, 0, error, error_code);
     return caml_call2(Dream_h2_Stream[9], t, error_code);
    }
    report_error(t, 0, error, error_code);
    return 0;
   }
   function requires_output(t){
    var _q_ = t[5];
    if(typeof _q_ === "number") return 1;
    switch(_q_[0]){
      case 0:
       return 0;
      case 1:
       return 0 === _q_[1][0] ? 1 : 0;
      default: return 0;
    }
   }
   function flush_request_body(t, max_bytes){
    var _m_ = t[5];
    if(typeof _m_ !== "number" && 1 === _m_[0]){
     var match = _m_[1];
     if(0 === match[0]){
      var s = _m_[2], request_body = s[2], active_state = match[1];
      if(caml_call1(Dream_h2_Body[2][10], request_body) && 0 < max_bytes)
       return caml_call5
               (Dream_h2_Body[2][13],
                request_body,
                t[2],
                t[6],
                max_bytes,
                t[1]);
      if(! caml_call1(Dream_h2_Body[2][9], request_body)) return 0;
      var
       _n_ = t[1],
       _o_ = [0, t[6]],
       _p_ = [0, caml_call1(Dream_h2_Flags[3], Dream_h2_Flags[1])],
       frame_info = caml_call4(Dream_h2_Serialize[20][3], 0, _p_, _o_, _n_);
      caml_call5
       (Dream_h2_Serialize[20][7], t[2], frame_info, 0, _a_, Bigstringaf[2]);
      t[5] = [1, [1, active_state], s];
      return 0;
     }
    }
    return 0;
   }
   function deliver_trailer_headers(t, headers){
    var _i_ = t[5];
    a:
    if(typeof _i_ !== "number" && 1 === _i_[0]){
     var _j_ = _i_[1];
     b:
     {
      if(0 === _j_[0]){
       var _k_ = _j_[1];
       if(typeof _k_ !== "number" && 0 !== _k_[0]) break b;
       break a;
      }
      var _l_ = _j_[1];
      if(typeof _l_ !== "number" && 0 !== _l_[0]) break b;
      break a;
     }
     var trailers_handler = _i_[2][4];
     return caml_call1(trailers_handler, headers);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function flush_response_body(t){
    var _c_ = t[5];
    a:
    if(typeof _c_ !== "number" && 1 === _c_[0]){
     var _d_ = _c_[1];
     b:
     {
      if(0 === _d_[0]){
       var _e_ = _d_[1];
       if(typeof _e_ !== "number" && 0 !== _e_[0]){var response_body = _e_[1][2]; break b;}
       break a;
      }
      var _h_ = _d_[1];
      if(typeof _h_ !== "number" && 0 !== _h_[0]){var response_body = _h_[1][2]; break b;}
      break a;
     }
     var _f_ = caml_call1(Dream_h2_Body[1][13], response_body);
     if(! _f_) return _f_;
     try{
      var _g_ = caml_call1(Dream_h2_Body[1][10], response_body);
      return _g_;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return report_error$0(t, [0, 3458171, exn], 2);
     }
    }
    return 0;
   }
   var
    Dream_h2_Respd =
      [0,
       create_active_response,
       response_body_exn,
       close_stream,
       report_error,
       report_error$0,
       requires_output,
       flush_request_body,
       deliver_trailer_headers,
       flush_response_body];
   runtime.caml_register_global(13, Dream_h2_Respd, "Dream_h2__Respd");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__Client_connection
//# unitInfo: Requires: Angstrom, Bigstringaf, CamlinternalLazy, Dream_h2__Body, Dream_h2__Config, Dream_h2__Flags, Dream_h2__Headers, Dream_h2__Message, Dream_h2__Parse, Dream_h2__Priority, Dream_h2__Request, Dream_h2__Respd, Dream_h2__Response, Dream_h2__Scheduler, Dream_h2__Serialize, Dream_h2__Settings, Dream_h2__Status, Dream_h2__Stream, Dream_h2__Stream_identifier, Dream_hpack__Hpack, Dream_httpaf___Httpaf, Faraday, Stdlib, Stdlib__Format, Stdlib__Int32, Stdlib__Int64, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst_Window_size_for_stream_wou = "Window size for stream would exceed ",
    cst_Window_size_for_stream_wou$0 =
      "Window size for stream would exceed %ld",
    cst_src_vendor_h2_lib_client_c = "src/vendor/h2/lib/client_connection.ml",
    cst_unexpected_eof = "unexpected eof",
    caml_greaterthan = runtime.caml_greaterthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$2,
    message$1 =
      "HEADERS frames containing trailers must set the END_STREAM flag",
    message$0 = "Pseudo-header fields must not appear in trailers",
    message = "HTTP/2 responses must include a single `:status` pseudo-header",
    cst$0 = cst$2,
    cst = cst$2,
    ok = [0, 0],
    Dream_h2_Serialize = global_data.Dream_h2__Serialize,
    Dream_h2_Parse = global_data.Dream_h2__Parse,
    Dream_h2_Respd = global_data.Dream_h2__Respd,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib = global_data.Stdlib,
    Dream_h2_Stream_identifier = global_data.Dream_h2__Stream_identifier,
    Dream_h2_Body = global_data.Dream_h2__Body,
    Dream_h2_Flags = global_data.Dream_h2__Flags,
    Dream_h2_Priority = global_data.Dream_h2__Priority,
    Dream_h2_Headers = global_data.Dream_h2__Headers,
    Assert_failure = global_data.Assert_failure,
    Dream_h2_Request = global_data.Dream_h2__Request,
    Dream_h2_Stream = global_data.Dream_h2__Stream,
    Dream_hpack_Hpack = global_data.Dream_hpack__Hpack,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Dream_h2_Config = global_data.Dream_h2__Config,
    Dream_h2_Settings = global_data.Dream_h2__Settings,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_List = global_data.Stdlib__List,
    Dream_h2_Message = global_data.Dream_h2__Message,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Faraday = global_data.Faraday,
    Angstrom = global_data.Angstrom,
    Dream_h2_Status = global_data.Dream_h2__Status,
    Dream_h2_Response = global_data.Dream_h2__Response,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Dream_h2_Scheduler = global_data.Dream_h2__Scheduler,
    Stdlib_Queue = global_data.Stdlib__Queue,
    id = Dream_h2_Stream[3],
    is_idle = Dream_h2_Stream[4],
    finish_stream = Dream_h2_Stream[6],
    flush_write_body = Dream_h2_Respd[7],
    requires_output = Dream_h2_Respd[6],
    Scheduler =
      caml_call1
       (Dream_h2_Scheduler[2],
        [0, id, requires_output, flush_write_body, finish_stream, is_idle]),
    Empty = Stdlib_Queue[1],
    create = Stdlib_Queue[2],
    add = Stdlib_Queue[3],
    push = Stdlib_Queue[4],
    take = Stdlib_Queue[5],
    pop = Stdlib_Queue[7],
    peek = Stdlib_Queue[8],
    peek_opt = Stdlib_Queue[9],
    top = Stdlib_Queue[10],
    clear = Stdlib_Queue[11],
    copy = Stdlib_Queue[12],
    is_empty = Stdlib_Queue[13],
    length = Stdlib_Queue[14],
    iter = Stdlib_Queue[15],
    fold = Stdlib_Queue[16],
    transfer = Stdlib_Queue[17],
    to_seq = Stdlib_Queue[18],
    add_seq = Stdlib_Queue[19],
    of_seq = Stdlib_Queue[20],
    _x_ = [1, 3448988],
    _w_ = [0, -522261659, cst_unexpected_eof],
    _y_ = [0, cst_unexpected_eof],
    cst_PING_payload_must_have_at_ =
      "PING payload must have at least 8 octets in length",
    _v_ = [0, 0],
    _u_ = [0, cst_src_vendor_h2_lib_client_c, 1349, 4],
    _t_ = [0, cst_src_vendor_h2_lib_client_c, 1350, 4],
    cst_http = "http",
    _s_ = [1, 0],
    _r_ =
      [0,
       "HEADERS or PUSH_PROMISE without the END_HEADERS flag set must be followed by a CONTINUATION frame for the same stream"],
    _q_ =
      [0,
       [11, cst_Window_size_for_stream_wou, [5, 0, 0, 0, 0]],
       cst_Window_size_for_stream_wou$0],
    _p_ = [0, "Unexpected PING acknowledgement"],
    _m_ =
      [0,
       "Received PUSH_PROMISE on a stream that is neither open nor half-closed (local)"],
    _o_ = [0, "Push is disabled for this connection"],
    _n_ = [0, "Illegal stream identifier promised by PUSH_PROMISE"],
    cst_Local = "Local",
    _l_ =
      [0,
       [11, cst_Window_size_for_stream_wou, [5, 0, 0, 0, 0]],
       cst_Window_size_for_stream_wou$0],
    _j_ = [0, "Received unexpected SETTINGS frame with acknowledgement"],
    _k_ = [0, 1],
    _i_ = [0, cst_src_vendor_h2_lib_client_c, 541, 6],
    _h_ = [0, 1],
    _e_ = [0, 1],
    _f_ = [0, 1],
    _g_ = [1, 1],
    _d_ = [0, cst_src_vendor_h2_lib_client_c, 387, 6],
    cst_status = "status",
    cst_authority = "authority",
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ = [1, 0],
    _a_ = [0, cst_src_vendor_h2_lib_client_c, 189, 4];
   function take_opt(t){
    return caml_call1(is_empty, t) ? 0 : [0, caml_call1(take, t)];
   }
   var
    Queue =
      [0,
       Empty,
       create,
       add,
       push,
       take,
       pop,
       peek,
       peek_opt,
       top,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       transfer,
       to_seq,
       add_seq,
       of_seq,
       take_opt];
   function default_push_handler(param){
    return [0, function(param, _bh_){return 0;}];
   }
   function is_closed(t){
    var _bg_ = caml_call1(Dream_h2_Parse[29][7], t[2]);
    return _bg_ ? caml_call1(Dream_h2_Serialize[20][29], t[3]) : _bg_;
   }
   function shutdown_reader(t){
    return caml_call1(Dream_h2_Parse[29][11], t[2]);
   }
   function flush_request_body(t){
    return caml_call2(Scheduler[23], t[5], [0, t[6], t[7]]);
   }
   function shutdown_writer(t){
    flush_request_body(t);
    caml_call1(Dream_h2_Serialize[20][27], t[3]);
    return caml_call1(Dream_h2_Serialize[20][23], t[3]);
   }
   function was_closed_or_implicitly_close(t, stream_id){
    return caml_call1(Dream_h2_Stream_identifier[7], stream_id)
            ? caml_call2(Dream_h2_Stream_identifier[2], stream_id, t[6])
            : caml_call2(Dream_h2_Stream_identifier[2], stream_id, t[7]);
   }
   function report_error(t, e){
    if(0 === e[0]){
     var data = e[2], error = e[1], _bd_ = 1 - t[10];
     if(! _bd_) return _bd_;
     var
      debug_data =
        0 === caml_ml_string_length(data)
         ? Bigstringaf[2]
         : caml_call3(Bigstringaf[3], 0, caml_ml_string_length(data), data),
      frame_info =
        caml_call4
         (Dream_h2_Serialize[20][3], 0, 0, 0, Dream_h2_Stream_identifier[5]),
      _be_ =
        caml_call2(Dream_h2_Stream_identifier[1], t[6], -1)
         ? Dream_h2_Stream_identifier[5]
         : t[6];
     caml_call5
      (Dream_h2_Serialize[20][21], t[3], frame_info, debug_data, _be_, error);
     t[10] = 1;
     if(0 !== error) caml_call1(t[13], [0, 122638209, [0, error, data]]);
     var
      _bf_ = function(param){shutdown_reader(t); return shutdown_writer(t);};
     caml_call2(Dream_h2_Serialize[20][24], t[3], _bf_);
     return caml_call1(Dream_h2_Serialize[20][23], t[3]);
    }
    var
     error$0 = e[2],
     stream_id = e[1],
     match = caml_call2(Scheduler[16], t[5], stream_id);
    if(match){
     var respd = match[1];
     caml_call3
      (Dream_h2_Respd[5], respd, [0, 122638209, [0, error$0, cst]], error$0);
    }
    else if(1 - was_closed_or_implicitly_close(t, stream_id)){
     var
      frame_info$0 = caml_call4(Dream_h2_Serialize[20][3], 0, 0, 0, stream_id);
     caml_call3(Dream_h2_Serialize[20][15], t[3], frame_info$0, error$0);
    }
    return caml_call1(Dream_h2_Serialize[20][23], t[3]);
   }
   function report_connection_error(t, opt, error){
    if(opt) var sth = opt[1], reason = sth; else var reason = cst$0;
    return report_error(t, [0, error, reason]);
   }
   function report_stream_error(t, stream_id, error){return report_error(t, [1, stream_id, error]);
   }
   function shutdown(t){return report_connection_error(t, 0, 0);}
   function set_error_and_handle(t, stream, error, error_code){
    caml_call3(Dream_h2_Respd[5], stream, error, error_code);
    return caml_call1(Dream_h2_Serialize[20][23], t[3]);
   }
   function report_exn(t, exn){
    var _bc_ = 1 - is_closed(t);
    if(! _bc_) return _bc_;
    var reason = caml_call1(Stdlib_Printexc[1], exn);
    return report_connection_error(t, [0, reason], 2);
   }
   function send_window_update(t, stream, n){
    function send_window_update_frame(stream_id, n){
     var valid_inflow = caml_call2(Scheduler[26], stream, n);
     if(! valid_inflow)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var
      frame_info = caml_call4(Dream_h2_Serialize[20][3], 0, 0, 0, stream_id);
     return caml_call3(Dream_h2_Serialize[20][16], t[3], frame_info, n);
    }
    var _bb_ = 0 < caml_call2(Stdlib_Int32[15], n, 0) ? 1 : 0;
    if(! _bb_) return _bb_;
    var
     max_window_size = Dream_h2_Settings[1][2],
     stream_id = caml_call1(Scheduler[5], stream),
     n$0 = n;
    for(;;){
     if(! caml_greaterthan(n$0, max_window_size)){
      send_window_update_frame(stream_id, n$0);
      return caml_call1(Dream_h2_Serialize[20][23], t[3]);
     }
     send_window_update_frame(stream_id, max_window_size);
     var n$1 = n$0 - max_window_size | 0, n$0 = n$1;
    }
   }
   function handle_push_promise_headers(t, respd, headers){
    var match = caml_call1(Dream_h2_Headers[29], headers);
    if(typeof match === "number") return report_stream_error(t, respd[1], 1);
    var
     match$0 = match[2],
     scheme = match$0[3],
     path = match$0[2],
     meth = match$0[1],
     meth$0 = caml_call1(Dream_httpaf_Httpaf[2][5], meth),
     match$1 = caml_call2(Dream_h2_Headers[18], headers, cst_authority),
     match$2 = caml_call1(Dream_h2_Message[2], headers);
    a:
    if(typeof meth$0 === "number"){
     if(336447078 <= meth$0){
      if(492530732 <= meth$0){
       if(801894688 !== meth$0 && 891112544 !== meth$0) break a;
      }
      else if(357830602 !== meth$0 && 492530731 > meth$0) break a;
     }
     else
      if(3546231 <= meth$0){
       if(3997359 !== meth$0 && 336447077 > meth$0) break a;
      }
      else if(-539883714 !== meth$0 && 3546230 > meth$0) break a;
     if
      (caml_call1(Dream_httpaf_Httpaf[2][2], meth$0)
       && caml_call1(Dream_httpaf_Httpaf[2][1], meth$0))
      break a;
     return report_stream_error(t, respd[1], 1);
    }
    a:
    {
     if(typeof match$2 !== "number"){
      var _a$_ = match$2[1];
      if(106380200 === _a$_) break a;
      if(332360020 === _a$_){
       var len = match$2[2];
       if(! caml_call2(Stdlib_Int64[17], len, _c_))
        return report_stream_error(t, respd[1], 1);
      }
     }
     if(match$1){
      var
       request =
         caml_call4(Dream_h2_Request[1], [0, headers], scheme, meth$0, path),
       match$3 = caml_call1(t[14], request);
      if(0 !== match$3[0]) return caml_call2(Dream_h2_Stream[9], respd, 8);
      var
       response_handler = match$3[1],
       request_body = caml_call1(Dream_h2_Body[2][2], t[3]);
      respd[5] =
       [1,
        _b_,
        [0,
         request,
         request_body,
         response_handler,
         function(_ba_){return 0;}]];
      return 0;
     }
    }
    return report_stream_error(t, respd[1], 1);
   }
   function handle_response_headers
   (t, stream, end_stream, active_request, headers){
    var
     respd = stream[1],
     match = caml_call2(Dream_h2_Headers[21], headers, cst_status);
    if(match && ! match[2]){
     var
      status = match[1],
      _a7_ = caml_call1(Dream_h2_Status[12], status),
      response = caml_call2(Dream_h2_Response[1], [0, headers], _a7_),
      match$0 = caml_call1(Dream_h2_Message[2], headers);
     if(typeof match$0 !== "number" && 332360020 > match$0[1])
      return set_error_and_handle(t, respd, [0, -349406259, response], 1);
     if(end_stream)
      var response_body = Dream_h2_Body[1][6];
     else
      var
       _a9_ =
         function(len){
          send_window_update(t, t[5], len);
          return send_window_update(t, stream, len);
         },
       _a__ = caml_call1(Bigstringaf[1], t[4][3]),
       response_body = caml_call2(Dream_h2_Body[1][4], _a__, _a9_);
     var
      new_response_state =
        caml_call2(Dream_h2_Respd[1], response, response_body),
      _a8_ =
        caml_call1(Dream_h2_Stream[5], respd)
         ? [0, new_response_state]
         : [1, new_response_state];
     respd[5] = [1, _a8_, active_request];
     caml_call2(active_request[3], response, response_body);
     return end_stream
             ? (caml_call1
                (Dream_h2_Body[1][12], response_body),
               caml_call1(Dream_h2_Respd[3], respd))
             : end_stream;
    }
    return set_error_and_handle(t, respd, [0, -522261659, message], 1);
   }
   function handle_headers(t, end_stream, stream, headers){
    var respd = stream[1];
    if(0 < caml_call2(Stdlib_Int32[15], t[8] + 1 | 0, t[4][5]))
     return 0 < t[11]
             ? report_stream_error(t, respd[1], 7)
             : report_stream_error(t, respd[1], 1);
    t[8] = t[8] + 1 | 0;
    var match = respd[5];
    if(typeof match !== "number")
     switch(match[0]){
       case 0:
        respd[5] = _e_; return handle_push_promise_headers(t, respd, headers);
       case 1:
        var active_request = match[2], active_state = match[1];
        respd[5] =
         0 === active_state[0]
          ? [1, _f_, active_request]
          : [1, _g_, active_request];
        return handle_response_headers
                (t, stream, end_stream, active_request, headers);
     }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
   }
   function handle_headers_block
   (t, opt, stream, partial_headers, flags, headers_block){
    if(opt) var sth = opt[1], is_trailers = sth; else var is_trailers = 0;
    var
     respd = stream[1],
     end_headers = caml_call1(Dream_h2_Flags[7], flags),
     parse_state =
       caml_call2
        (Angstrom[76][2], partial_headers[1], [0, 608227697, headers_block]);
    if(! end_headers){partial_headers[1] = parse_state; return 0;}
    t[9] = 0;
    var parse_state$0 = caml_call2(Angstrom[76][2], parse_state, 3456156);
    switch(parse_state$0[0]){
      case 1:
       var match = parse_state$0[2];
       if(0 === match[0]){
        var headers = match[1];
        if(! is_trailers){
         var end_stream = partial_headers[2];
         return handle_headers(t, end_stream, stream, headers);
        }
        if(! caml_call1(Dream_h2_Headers[30], headers))
         return set_error_and_handle(t, respd, [0, -522261659, message$0], 1);
        caml_call2(Dream_h2_Respd[8], respd, headers);
        var response_body = caml_call1(Dream_h2_Respd[2], respd);
        return caml_call1(Dream_h2_Body[1][12], response_body);
       }
       break;
      case 2:
       var message = parse_state$0[3];
       return report_connection_error(t, [0, message], 9);
    }
    return report_connection_error(t, 0, 9);
   }
   function handle_trailer_headers(_a2_){
    return function(_a3_, _a4_, _a5_, _a6_){
     return handle_headers_block(_a2_, _h_, _a3_, _a4_, _a5_, _a6_);};
   }
   function create_partial_headers(t, flags, headers_block){
    var
     end_headers = caml_call1(Dream_h2_Flags[7], flags),
     headers_block_length = caml_call1(Bigstringaf[6], headers_block),
     initial_buffer_size =
       end_headers ? headers_block_length : 2 * headers_block_length | 0,
     _a0_ = caml_call1(Dream_h2_Flags[2], flags),
     _a1_ = caml_call1(Dream_hpack_Hpack[2][3], t[16]);
    return [0,
            caml_call2(Angstrom[76][1], [0, initial_buffer_size], _a1_),
            _a0_];
   }
   function handle_first_response_bytes
   (t, stream, active_request, frame_header, headers_block){
    var
     descriptor = stream[1],
     stream_id = frame_header[3],
     flags = frame_header[2],
     partial_headers = create_partial_headers(t, flags, headers_block),
     remote_state = [0, partial_headers],
     _aZ_ =
       caml_call1(Dream_h2_Stream[5], descriptor)
        ? [1, [0, remote_state], active_request]
        : [1, [1, remote_state], active_request];
    descriptor[5] = _aZ_;
    if(1 - caml_call1(Dream_h2_Flags[7], flags)) t[9] = [0, stream_id];
    return handle_headers_block
            (t, 0, stream, partial_headers, flags, headers_block);
   }
   function process_trailer_headers
   (t, stream, active_response, frame_header, headers_block){
    var
     respd = stream[1],
     stream_id = frame_header[3],
     flags = frame_header[2],
     end_stream = caml_call1(Dream_h2_Flags[2], flags);
    if(! end_stream)
     return set_error_and_handle(t, respd, [0, -522261659, message$1], 1);
    var
     _aY_ = caml_call1(Dream_hpack_Hpack[2][3], t[16]),
     partial_headers = [0, caml_call2(Angstrom[76][1], 0, _aY_), end_stream];
    active_response[4] = [0, partial_headers];
    if(1 - caml_call1(Dream_h2_Flags[7], flags)) t[9] = [0, stream_id];
    return handle_trailer_headers(t)
            (stream, partial_headers, flags, headers_block);
   }
   function process_headers_frame(t, param, headers_block){
    var
     frame_header = param[1],
     stream_id = frame_header[3],
     match = caml_call2(Scheduler[15], t[5], stream_id);
    if(! match){
     var
      _aW_ = caml_call2(Dream_h2_Stream_identifier[4], stream_id, t[6]),
      _aX_ =
        _aW_ ? caml_call1(Dream_h2_Stream_identifier[7], stream_id) : _aW_;
     return _aX_ ? report_stream_error(t, stream_id, 5) : _aX_;
    }
    var stream = match[1], descriptor = stream[1], _aR_ = descriptor[5];
    if(typeof _aR_ === "number") return report_connection_error(t, 0, 1);
    switch(_aR_[0]){
      case 1:
       var _aS_ = _aR_[1];
       a:
       {
        b:
        {
         c:
         {
          if(0 === _aS_[0]){
           var _aT_ = _aS_[1];
           if(typeof _aT_ === "number"){if(0 === _aT_) break a;}
           else if(1 === _aT_[0]){var active_response = _aT_[1]; break c;}
           break b;
          }
          var _aU_ = _aS_[1];
          if(typeof _aU_ === "number"){if(0 === _aU_) break a;}
          else if(1 === _aU_[0]){var active_response = _aU_[1]; break c;}
          break b;
         }
         process_trailer_headers
          (t, stream, active_response, frame_header, headers_block);
         return caml_call2(Dream_h2_Stream[6], descriptor, 0);
        }
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
       }
       var active_request = _aR_[2];
       return handle_first_response_bytes
               (t, stream, active_request, frame_header, headers_block);
      case 2:
       var _aV_ = _aR_[1][1];
       if(typeof _aV_ !== "number" && 0 !== _aV_[0])
        return report_stream_error(t, stream_id, 5);
       break;
    }
    return report_connection_error(t, 0, 5);
   }
   function process_data_frame(t, param, bstr){
    var
     frame_header = param[1],
     stream_id = frame_header[3],
     flags = frame_header[2],
     payload_length = frame_header[1],
     match = caml_call2(Scheduler[15], t[5], stream_id);
    if(! match){
     var _aQ_ = 1 - was_closed_or_implicitly_close(t, stream_id);
     return _aQ_ ? report_connection_error(t, 0, 1) : _aQ_;
    }
    var stream = match[1], descriptor = stream[1], _aJ_ = descriptor[5];
    if(typeof _aJ_ === "number") return report_connection_error(t, 0, 1);
    switch(_aJ_[0]){
      case 1:
       var _aK_ = _aJ_[1];
       a:
       {
        if(0 === _aK_[0]){
         var _aL_ = _aK_[1];
         if(typeof _aL_ !== "number" && 0 !== _aL_[0]){var response_info = _aL_[1]; break a;}
         break;
        }
        var _aN_ = _aK_[1];
        if(typeof _aN_ !== "number" && 0 !== _aN_[0]){var response_info = _aN_[1]; break a;}
        break;
       }
       var
        response_body = response_info[2],
        response = response_info[1],
        response_body_bytes = response_info[3];
       response_info[3] =
        runtime.caml_int64_add
         (response_body_bytes,
          runtime.caml_int64_of_int32(caml_call1(Bigstringaf[6], bstr)));
       var
        allowed_to_receive =
          caml_call3(Scheduler[19], t[5], stream, payload_length);
       caml_call2(Scheduler[27], t[5], payload_length);
       if(! allowed_to_receive){
        send_window_update(t, t[5], payload_length);
        return report_stream_error(t, stream_id, 3);
       }
       caml_call2(Scheduler[27], stream, payload_length);
       var match$0 = caml_call1(Dream_h2_Message[2], response[2]);
       if(typeof match$0 !== "number" && 332360020 === match$0[1]){
        var len = match$0[2];
        if(0 < caml_call2(Stdlib_Int64[15], response_info[3], len)){
         send_window_update(t, t[5], payload_length);
         return set_error_and_handle
                 (t, descriptor, [0, -349406259, response], 1);
        }
       }
       var
        end_stream = caml_call1(Dream_h2_Flags[2], flags),
        faraday = caml_call1(Dream_h2_Body[1][8], response_body);
       if(1 - caml_call1(Faraday[20], faraday)){
        caml_call4(Faraday[11], faraday, 0, 0, bstr);
        if(end_stream) caml_call1(Dream_h2_Body[1][12], response_body);
       }
       caml_call1(Dream_h2_Respd[9], descriptor);
       var
        _aM_ =
          end_stream
           ? 1 - caml_call1(Dream_h2_Respd[6], descriptor)
           : end_stream;
       return _aM_ ? caml_call2(Dream_h2_Stream[6], descriptor, 0) : _aM_;
      case 2:
       var _aO_ = _aJ_[1][1];
       if(typeof _aO_ !== "number" && 1 !== _aO_[0]){
        var _aP_ = _aO_[1];
        if(typeof _aP_ !== "number") break;
        if(_aP_) break;
        return send_window_update(t, t[5], payload_length);
       }
       break;
    }
    send_window_update(t, t[5], payload_length);
    return report_stream_error(t, stream_id, 5);
   }
   function on_close_stream(t, id, active, closed){
    if(active) t[8] = t[8] - 1 | 0;
    return caml_call3(Scheduler[21], t[5], id, closed);
   }
   function process_priority_frame(t, param, priority){
    var
     frame_header = param[1],
     stream_id = frame_header[3],
     stream_dependency = priority[2];
    if
     (caml_call2(Dream_h2_Stream_identifier[1], stream_id, stream_dependency))
     return report_stream_error(t, stream_id, 1);
    var match = caml_call2(Scheduler[15], t[5], stream_id);
    if(! match) return 0;
    var stream = match[1];
    return caml_call3(Scheduler[11], t[5], priority, stream);
   }
   function process_rst_stream_frame(t, param, error_code){
    var
     frame_header = param[1],
     stream_id = frame_header[3],
     match = caml_call2(Scheduler[16], t[5], stream_id);
    if(! match){
     var _aI_ = 1 - was_closed_or_implicitly_close(t, stream_id);
     return _aI_ ? report_connection_error(t, 0, 1) : _aI_;
    }
    var respd = match[1], _aH_ = respd[5];
    if(typeof _aH_ === "number") return report_connection_error(t, 0, 1);
    switch(_aH_[0]){
      case 1:
       if(typeof error_code === "number" && ! error_code)
        return caml_call2(Dream_h2_Stream[6], respd, [1, error_code]);
       break;
      case 2:
       return 0;
    }
    caml_call2(Dream_h2_Stream[6], respd, [1, error_code]);
    return set_error_and_handle
            (t, respd, [0, 122638209, [0, error_code, cst$1]], error_code);
   }
   function process_settings_frame(t, param, settings){
    var frame_header = param[1], flags = frame_header[2];
    if(caml_call1(Dream_h2_Flags[5], flags)){
     t[11] = t[11] - 1 | 0;
     var _av_ = t[11] < 0 ? 1 : 0;
     return _av_ ? report_connection_error(t, _j_, 1) : _av_;
    }
    var match = caml_call2(Dream_h2_Settings[5], _k_, settings);
    if(0 === match[0]){
     var
      _aw_ = t[1],
      _ax_ =
        function(acc, item){
         switch(item[0]){
           case 0:
            var x = item[1];
            caml_call2(Dream_hpack_Hpack[1][3], t[15], x);
            return [0, x, acc[2], acc[3], acc[4], acc[5], acc[6]];
           case 1:
            var x$0 = item[1];
            return [0,
                    acc[1],
                    1 === x$0 ? 1 : 0,
                    acc[3],
                    acc[4],
                    acc[5],
                    acc[6]];
           case 2:
            var x$1 = item[1];
            return [0, acc[1], acc[2], x$1, acc[4], acc[5], acc[6]];
           case 3:
            var
             new_val = item[1],
             old_val = t[1][4],
             growth = new_val - old_val | 0,
             Local = [248, cst_Local, runtime.caml_fresh_oo_id(0)];
            try{
             var
              _aB_ =
                function(stream){
                 var _aG_ = 1 - caml_call2(Scheduler[25], stream, growth);
                 if(_aG_) throw caml_maybe_attach_backtrace(Local, 1);
                 return _aG_;
                };
             caml_call2(Scheduler[17], t[5], _aB_);
            }
            catch(_aF_){
             var _aA_ = caml_wrap_exception(_aF_);
             if(_aA_ !== Local) throw caml_maybe_attach_backtrace(_aA_, 0);
             report_connection_error
              (t,
               [0,
                caml_call2(Stdlib_Format[140], _l_, Dream_h2_Settings[1][2])],
               3);
            }
            return [0, acc[1], acc[2], acc[3], new_val, acc[5], acc[6]];
           case 4:
            var
             x$2 = item[1],
             _aC_ =
               function(param){
                var
                 descriptor = param[1],
                 _aD_ = caml_call1(Dream_h2_Respd[6], descriptor),
                 _aE_ = _aD_ ? (descriptor[6] = x$2, 0) : _aD_;
                return _aE_;
               };
            caml_call2(Scheduler[17], t[5], _aC_);
            return [0, acc[1], acc[2], acc[3], acc[4], x$2, acc[6]];
           default:
            var x$3 = item[1];
            return [0, acc[1], acc[2], acc[3], acc[4], acc[5], [0, x$3]];
         }
        },
      new_settings = caml_call3(Stdlib_List[26], _ax_, _aw_, settings);
     t[1] = new_settings;
     var
      _ay_ = Dream_h2_Stream_identifier[5],
      _az_ = [0, caml_call1(Dream_h2_Flags[6], Dream_h2_Flags[1])],
      frame_info = caml_call4(Dream_h2_Serialize[20][3], 0, _az_, 0, _ay_);
     caml_call3(Dream_h2_Serialize[20][19], t[3], frame_info, 0);
     t[11] = t[11] + 1 | 0;
     return caml_call1(Dream_h2_Serialize[20][23], t[3]);
    }
    var error = match[1];
    return report_error(t, error);
   }
   function reserve_stream(t, param, promised_stream_id, headers_block){
    var
     frame_header = param[1],
     stream_id = frame_header[3],
     flags = frame_header[2];
    function _ar_(_at_, _au_){
     return on_close_stream(t, promised_stream_id, _at_, _au_);
    }
    var
     respd =
       caml_call5
        (Dream_h2_Stream[2], promised_stream_id, t[1][5], t[3], t[13], _ar_),
     _as_ = Dream_h2_Priority[1],
     stream =
       caml_call5
        (Scheduler[14],
         t[5],
         [0, _as_[1], stream_id, _as_[3]],
         t[1][4],
         t[4][6],
         respd),
     partial_headers = create_partial_headers(t, flags, headers_block);
    respd[5] = [0, [0, partial_headers]];
    if(1 - caml_call1(Dream_h2_Flags[7], flags))
     t[9] = [0, promised_stream_id];
    return handle_headers_block
            (t, 0, stream, partial_headers, flags, headers_block);
   }
   function process_push_promise_frame
   (t, frame, promised_stream_id, headers_block){
    var frame_header = frame[1], stream_id = frame_header[3];
    if(! t[1][2]) return report_connection_error(t, _o_, 1);
    if(! caml_call2(Dream_h2_Stream_identifier[3], promised_stream_id, t[7]))
     return report_connection_error(t, _n_, 1);
    function send_connection_error(param){
     return report_connection_error(t, _m_, 1);
    }
    t[7] = promised_stream_id;
    var match = caml_call2(Scheduler[16], t[5], stream_id);
    if(! match) return send_connection_error(0);
    var respd = match[1], _aq_ = respd[5];
    if(typeof _aq_ !== "number" && 1 === _aq_[0])
     return reserve_stream(t, frame, promised_stream_id, headers_block);
    return send_connection_error(0);
   }
   function process_ping_frame(t, param, payload){
    var frame_header = param[1], flags = frame_header[2];
    if(! caml_call1(Dream_h2_Flags[5], flags)){
     var
      _ao_ = Dream_h2_Stream_identifier[5],
      _ap_ = [0, caml_call1(Dream_h2_Flags[6], Dream_h2_Flags[1])],
      frame_info = caml_call4(Dream_h2_Serialize[20][3], 0, _ap_, 0, _ao_);
     caml_call4(Dream_h2_Serialize[20][20], t[3], frame_info, 0, payload);
     return caml_call1(Dream_h2_Serialize[20][23], t[3]);
    }
    var match = caml_call1(Queue[20], t[12]);
    if(! match) return report_connection_error(t, _p_, 1);
    var callback = match[1];
    return caml_call1(callback, ok);
   }
   function process_goaway_frame(t, frame, param, data, error){
    var
     len = caml_call1(Bigstringaf[6], data),
     reason = 0 === len ? 0 : [0, caml_call3(Bigstringaf[7], data, 0, len)];
    return report_connection_error(t, reason, error);
   }
   function add_window_increment(t, stream, increment){
    var
     did_add = caml_call2(Scheduler[25], stream, increment),
     stream_id = caml_call1(Scheduler[5], stream);
    if(0 === stream[0])
     var flow = stream[4], new_flow = flow;
    else
     var flow$0 = stream[7], new_flow = flow$0;
    if(! did_add)
     return caml_call1(Dream_h2_Stream_identifier[6], stream_id)
             ? report_connection_error
               (t,
                [0,
                 caml_call2(Stdlib_Printf[4], _q_, Dream_h2_Settings[1][2])],
                3)
             : report_stream_error(t, stream_id, 3);
    var _an_ = 0 < caml_call2(Stdlib_Int32[15], new_flow, 0) ? 1 : 0;
    return _an_ ? caml_call1(Dream_h2_Serialize[20][23], t[3]) : _an_;
   }
   function process_window_update_frame(t, param, window_increment){
    var frame_header = param[1], stream_id = frame_header[3];
    if(caml_call1(Dream_h2_Stream_identifier[6], stream_id))
     return add_window_increment(t, t[5], window_increment);
    var match = caml_call2(Scheduler[15], t[5], stream_id);
    if(match){
     var
      stream_node = match[1],
      descriptor = stream_node[1],
      _al_ = descriptor[5];
     return typeof _al_ === "number"
             ? report_connection_error(t, 0, 1)
             : 2
               === _al_[0]
               ? 0
               : add_window_increment(t, stream_node, window_increment);
    }
    var _am_ = 1 - was_closed_or_implicitly_close(t, stream_id);
    return _am_ ? report_connection_error(t, 0, 1) : _am_;
   }
   function process_continuation_frame(t, param, headers_block){
    var
     frame_header = param[1],
     stream_id = frame_header[3],
     flags = frame_header[2],
     match = caml_call2(Scheduler[15], t[5], stream_id);
    if(! match) return report_connection_error(t, 0, 1);
    var stream = match[1], descriptor = stream[1], _af_ = descriptor[5];
    a:
    if(typeof _af_ !== "number" && 1 === _af_[0]){
     var _ag_ = _af_[1];
     b:
     {
      if(0 === _ag_[0]){
       var _ah_ = _ag_[1];
       if(typeof _ah_ === "number") break a;
       if(0 === _ah_[0]){var partial_headers = _ah_[1]; break b;}
       var _ai_ = _ah_[1][4];
       if(! _ai_) break a;
       var partial_headers$0 = _ai_[1];
      }
      else{
       var _aj_ = _ag_[1];
       if(typeof _aj_ === "number") break a;
       if(0 === _aj_[0]){var partial_headers = _aj_[1]; break b;}
       var _ak_ = _aj_[1][4];
       if(! _ak_) break a;
       var partial_headers$0 = _ak_[1];
      }
      return handle_trailer_headers(t)
              (stream, partial_headers$0, flags, headers_block);
     }
     return handle_headers_block
             (t, 0, stream, partial_headers, flags, headers_block);
    }
    return report_connection_error(t, 0, 1);
   }
   function create$0(opt, push_handler, error_handler, param){
    if(opt)
     var sth = opt[1], config = sth;
    else
     var config = Dream_h2_Config[1];
    if(push_handler)
     var push_handler$0 = push_handler[1], push_handler$1 = push_handler$0;
    else
     var push_handler$1 = default_push_handler;
    var
     _M_ = caml_call1(Dream_h2_Config[2], config),
     _R_ = config[4],
     _N_ = _M_[6],
     _O_ = _M_[5],
     _P_ = _M_[4],
     _Q_ = _M_[3],
     _S_ = _R_ ? push_handler$1 !== default_push_handler ? 1 : 0 : _R_,
     settings = [0, _M_[1], _S_, _Q_, _P_, _O_, _N_],
     connection_preface_handler =
       function _ae_(_ac_, _ad_){return _ae_.fun(_ac_, _ad_);},
     frame_handler = function _ab_(_aa_){return _ab_.fun(_aa_);},
     t = [];
    caml_update_dummy
     (connection_preface_handler,
      function(recv_frame, settings_list){
       var _$_ = caml_obj_tag(t);
       a:
       if(250 === _$_)
        var t$0 = t[1];
       else{
        if(246 !== _$_ && 244 !== _$_){var t$0 = t; break a;}
        var t$0 = caml_call1(CamlinternalLazy[2], t);
       }
       return process_settings_frame(t$0, recv_frame, settings_list);
      });
    caml_update_dummy
     (frame_handler,
      function(r){
       var ___ = caml_obj_tag(t);
       a:
       if(250 === ___)
        var t$0 = t[1];
       else{
        if(246 !== ___ && 244 !== ___){var t$0 = t; break a;}
        var t$0 = caml_call1(CamlinternalLazy[2], t);
       }
       if(0 !== r[0]){var e = r[1]; return report_error(t$0, e);}
       var
        frame = r[1],
        frame_payload = frame[2],
        frame_header = frame[1],
        match = t$0[9];
       a:
       if(match){
        var stream_id = match[1];
        if
         (caml_call2
           (Dream_h2_Stream_identifier[1], stream_id, frame_header[3])
          && 9 === frame_header[4])
         break a;
        return report_connection_error(t$0, _r_, 1);
       }
       switch(frame_payload[0]){
         case 0:
          var bs = frame_payload[1];
          return process_data_frame(t$0, frame, bs);
         case 1:
          var headers_block = frame_payload[2];
          return process_headers_frame(t$0, frame, headers_block);
         case 2:
          var priority = frame_payload[1];
          return process_priority_frame(t$0, frame, priority);
         case 3:
          var error_code = frame_payload[1];
          return process_rst_stream_frame(t$0, frame, error_code);
         case 4:
          var settings = frame_payload[1];
          return process_settings_frame(t$0, frame, settings);
         case 5:
          var bs$0 = frame_payload[2], promised_stream_id = frame_payload[1];
          return process_push_promise_frame
                  (t$0, frame, promised_stream_id, bs$0);
         case 6:
          var data = frame_payload[1];
          return process_ping_frame(t$0, frame, data);
         case 7:
          var
           data$0 = frame_payload[3],
           error = frame_payload[2],
           last_stream_id = frame_payload[1];
          return process_goaway_frame
                  (t$0, frame, last_stream_id, data$0, error);
         case 8:
          var window_size = frame_payload[1];
          return process_window_update_frame(t$0, frame, window_size);
         case 9:
          var headers_block$0 = frame_payload[1];
          return process_continuation_frame(t$0, frame, headers_block$0);
         default: return 0;
       }
      });
    caml_update_dummy
     (t,
      [246,
       function(param){
        var
         _V_ = caml_call1(Dream_hpack_Hpack[2][1], settings[1]),
         _W_ = caml_call1(Dream_hpack_Hpack[1][1], settings[1]),
         _X_ = caml_call1(Queue[2], 0),
         _Y_ = caml_call2(Scheduler[3], 0, 0),
         _Z_ = caml_call1(Dream_h2_Serialize[20][1], settings[5]);
        return [0,
                settings,
                caml_call3
                 (Dream_h2_Parse[29][5],
                  connection_preface_handler,
                  frame_handler,
                  settings[5]),
                _Z_,
                config,
                _Y_,
                -1,
                0,
                0,
                0,
                0,
                0,
                _X_,
                error_handler,
                push_handler$1,
                _W_,
                _V_];
       }]);
    var _T_ = caml_obj_tag(t);
    a:
    if(250 === _T_)
     var t$0 = t[1];
    else{
     if(246 !== _T_ && 244 !== _T_){var t$0 = t; break a;}
     var t$0 = caml_call1(CamlinternalLazy[2], t);
    }
    var settings$0 = caml_call1(Dream_h2_Settings[7], t$0[1]), _U_ = t$0[1];
    t$0[1] =
     [0, _U_[1], _U_[2], _U_[3], Dream_h2_Settings[6][4], _U_[5], _U_[6]];
    caml_call2(Dream_h2_Serialize[20][4], t$0[3], settings$0);
    if(caml_greaterthan(t$0[4][6], Dream_h2_Settings[6][4])){
     var diff = t$0[4][6] - Dream_h2_Settings[6][4] | 0;
     send_window_update(t$0, t$0[5], diff);
    }
    return t$0;
   }
   function create_and_add_stream(t, error_handler){
    var max_frame_size = t[1][5];
    t[6] = t[6] + 2 | 0;
    var stream_id = t[6];
    function _J_(_K_, _L_){return on_close_stream(t, stream_id, _K_, _L_);}
    var
     respd =
       caml_call5
        (Dream_h2_Stream[2],
         stream_id,
         max_frame_size,
         t[3],
         error_handler,
         _J_);
    caml_call5
     (Scheduler[14], t[5], Dream_h2_Priority[1], t[1][4], t[4][6], respd);
    return respd;
   }
   function create_h2c
   (config, push_handler, http_request, error_handler, param){
    var
     response_error_handler = param[2],
     response_handler = param[1],
     target = http_request[2],
     meth = http_request[1],
     match = caml_call1(Dream_h2_Headers[32], http_request);
    if(0 !== match[0]){var msg = match[1]; return [1, msg];}
    var
     headers = match[1],
     t = create$0(config, push_handler, error_handler, 0),
     respd = create_and_add_stream(t, response_error_handler);
    if(! caml_call2(Dream_h2_Stream_identifier[1], t[6], 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
    if(! caml_call2(Dream_h2_Stream_identifier[1], respd[1], 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
    var
     request =
       caml_call4(Dream_h2_Request[1], [0, headers], cst_http, meth, target);
    function _H_(_I_){return 0;}
    respd[5] =
     [1,
      _s_,
      [0,
       request,
       caml_call1(Dream_h2_Body[2][2], t[3]),
       response_handler,
       _H_]];
    caml_call1(Dream_h2_Serialize[20][23], t[3]);
    return [0, t];
   }
   function request(t, opt, _D_, request, error_handler, response_handler){
    if(opt)
     var sth = opt[1], flush_headers_immediately = sth;
    else
     var flush_headers_immediately = 0;
    if(_D_)
     var sth$0 = _D_[1], trailers_handler = sth$0;
    else
     var trailers_handler = function(_G_){return 0;};
    var
     max_frame_size = t[1][5],
     respd = create_and_add_stream(t, error_handler),
     _E_ = t[3],
     _F_ = caml_call1(Bigstringaf[1], max_frame_size),
     request_body = caml_call2(Dream_h2_Body[2][1], _F_, _E_),
     frame_info =
       caml_call4
        (Dream_h2_Serialize[20][3],
         0,
         [0, Dream_h2_Flags[1]],
         [0, t[1][5]],
         respd[1]);
    caml_call5
     (Dream_h2_Serialize[20][11],
      t[3],
      t[15],
      Dream_h2_Priority[1],
      frame_info,
      request);
    respd[5] =
     [1, _v_, [0, request, request_body, response_handler, trailers_handler]];
    if(1 - flush_headers_immediately)
     caml_call1(Dream_h2_Serialize[20][26], t[3]);
    caml_call1(Dream_h2_Serialize[20][23], t[3]);
    return request_body;
   }
   function ping(t, payload, opt, callback){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(payload){
     var payload$0 = payload[1];
     if((caml_call1(Bigstringaf[6], payload$0) - off | 0) < 8)
      caml_call1(Stdlib[2], cst_PING_payload_must_have_at_);
     var payload$1 = payload$0;
    }
    else
     var payload$1 = Dream_h2_Serialize[13];
    var
     frame_info =
       caml_call4
        (Dream_h2_Serialize[20][3], 0, 0, 0, Dream_h2_Stream_identifier[5]);
    caml_call2(Queue[3], callback, t[12]);
    caml_call4
     (Dream_h2_Serialize[20][20], t[3], frame_info, [0, off], payload$1);
    return caml_call1(Dream_h2_Serialize[20][23], t[3]);
   }
   function next_read_operation(t){
    if(caml_call1(Dream_h2_Parse[29][7], t[2])) shutdown_reader(t);
    var operation = caml_call1(Dream_h2_Parse[29][14], t[2]);
    if(typeof operation === "number") return operation;
    var e = operation[2];
    report_error(t, e);
    return 0 === e[0] ? -611285096 : 914388854;
   }
   function read(t, bs, off, len){
    return caml_call5(Dream_h2_Parse[29][10], t[2], bs, off, len, 1);
   }
   function unexpected_eof(t){
    function _z_(param){
     var descriptor = param[1], _C_ = descriptor[5];
     if(typeof _C_ !== "number" && 1 === _C_[0])
      return caml_call3(Dream_h2_Respd[5], descriptor, _w_, 1);
     return 0;
    }
    caml_call2(Scheduler[17], t[5], _z_);
    var _A_ = t[12];
    function _B_(f){return caml_call1(f, _x_);}
    caml_call2(Queue[14], _B_, _A_);
    return report_connection_error(t, _y_, 1);
   }
   function read_eof(t, bs, off, len){
    var
     bytes_read = caml_call5(Dream_h2_Parse[29][10], t[2], bs, off, len, 0);
    unexpected_eof(t);
    return bytes_read;
   }
   function yield_reader(t, k){return caml_call1(k, 0);}
   function next_write_operation(t){
    flush_request_body(t);
    return caml_call1(Dream_h2_Serialize[20][32], t[3]);
   }
   function yield_writer(t, k){
    return caml_call2(Dream_h2_Serialize[20][22], t[3], k);
   }
   function report_write_result(t, result){
    return caml_call2(Dream_h2_Serialize[20][31], t[3], result);
   }
   var
    Dream_h2_Client_connection =
      [0,
       Scheduler,
       Queue,
       default_push_handler,
       is_closed,
       shutdown_reader,
       flush_request_body,
       shutdown_writer,
       was_closed_or_implicitly_close,
       report_error,
       report_connection_error,
       report_stream_error,
       shutdown,
       set_error_and_handle,
       report_exn,
       send_window_update,
       handle_push_promise_headers,
       handle_response_headers,
       handle_headers,
       handle_headers_block,
       handle_trailer_headers,
       create_partial_headers,
       handle_first_response_bytes,
       process_trailer_headers,
       process_headers_frame,
       process_data_frame,
       on_close_stream,
       process_priority_frame,
       process_rst_stream_frame,
       process_settings_frame,
       reserve_stream,
       process_push_promise_frame,
       ok,
       process_ping_frame,
       process_goaway_frame,
       add_window_increment,
       process_window_update_frame,
       process_continuation_frame,
       create$0,
       create_and_add_stream,
       create_h2c,
       request,
       ping,
       next_read_operation,
       read,
       unexpected_eof,
       read_eof,
       yield_reader,
       next_write_operation,
       yield_writer,
       report_write_result];
   runtime.caml_register_global
    (76, Dream_h2_Client_connection, "Dream_h2__Client_connection");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Dream_h2__H2
//# unitInfo: Requires: Dream_h2__Body, Dream_h2__Client_connection, Dream_h2__Config, Dream_h2__Error_code, Dream_h2__Headers, Dream_h2__Reqd, Dream_h2__Request, Dream_h2__Response, Dream_h2__Server_connection, Dream_h2__Settings, Dream_h2__Status, Dream_httpaf___Httpaf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Dream_h2_Client_connection = global_data.Dream_h2__Client_connection,
    Dream_h2_Server_connection = global_data.Dream_h2__Server_connection,
    Dream_h2_Config = global_data.Dream_h2__Config,
    Dream_h2_Settings = global_data.Dream_h2__Settings,
    Dream_h2_Error_code = global_data.Dream_h2__Error_code,
    Dream_h2_Reqd = global_data.Dream_h2__Reqd,
    Dream_httpaf_Httpaf = global_data.Dream_httpaf___Httpaf,
    Dream_h2_Response = global_data.Dream_h2__Response,
    Dream_h2_Request = global_data.Dream_h2__Request,
    Dream_h2_Body = global_data.Dream_h2__Body,
    Dream_h2_Headers = global_data.Dream_h2__Headers,
    Dream_h2_Status = global_data.Dream_h2__Status,
    _a_ = Dream_h2_Body[2],
    _b_ = Dream_h2_Body[1],
    Dream_h2_H2 =
      [0,
       Dream_httpaf_Httpaf[2],
       [0,
        Dream_h2_Status[1],
        Dream_h2_Status[2],
        Dream_h2_Status[4],
        Dream_h2_Status[3],
        Dream_h2_Status[5],
        Dream_h2_Status[6],
        Dream_h2_Status[7],
        Dream_h2_Status[8],
        Dream_h2_Status[9],
        Dream_h2_Status[10],
        Dream_h2_Status[11],
        Dream_h2_Status[12],
        Dream_h2_Status[13]],
       [0,
        Dream_h2_Headers[1],
        Dream_h2_Headers[3],
        Dream_h2_Headers[2],
        Dream_h2_Headers[5],
        Dream_h2_Headers[4],
        Dream_h2_Headers[10],
        Dream_h2_Headers[13],
        Dream_h2_Headers[11],
        Dream_h2_Headers[12],
        Dream_h2_Headers[15],
        Dream_h2_Headers[14],
        Dream_h2_Headers[9],
        Dream_h2_Headers[16],
        Dream_h2_Headers[17],
        Dream_h2_Headers[20],
        Dream_h2_Headers[23],
        Dream_h2_Headers[24],
        Dream_h2_Headers[33],
        Dream_h2_Headers[34]],
       [0,
        [0, _b_[11], _b_[12], _b_[7]],
        [0, _a_[4], _a_[5], _a_[6], _a_[7], _a_[8], _a_[11], _a_[9]]],
       Dream_h2_Request,
       Dream_h2_Response,
       Dream_httpaf_Httpaf[8],
       [0,
        Dream_h2_Reqd[3],
        Dream_h2_Reqd[4],
        Dream_h2_Reqd[5],
        Dream_h2_Reqd[6],
        Dream_h2_Reqd[10],
        Dream_h2_Reqd[11],
        Dream_h2_Reqd[14],
        Dream_h2_Reqd[8],
        Dream_h2_Reqd[17],
        Dream_h2_Reqd[22],
        Dream_h2_Reqd[20],
        Dream_h2_Reqd[21]],
       [0, Dream_h2_Error_code[3], Dream_h2_Error_code[4]],
       [0,
        Dream_h2_Settings[6],
        Dream_h2_Settings[11],
        Dream_h2_Settings[12],
        Dream_h2_Settings[13]],
       Dream_h2_Config,
       [0,
        Dream_h2_Server_connection[37],
        Dream_h2_Server_connection[39],
        Dream_h2_Server_connection[40],
        Dream_h2_Server_connection[41],
        Dream_h2_Server_connection[42],
        Dream_h2_Server_connection[44],
        Dream_h2_Server_connection[45],
        Dream_h2_Server_connection[46],
        Dream_h2_Server_connection[43],
        Dream_h2_Server_connection[12],
        Dream_h2_Server_connection[2],
        Dream_h2_Server_connection[6]],
       [0,
        Dream_h2_Client_connection[38],
        Dream_h2_Client_connection[40],
        Dream_h2_Client_connection[41],
        Dream_h2_Client_connection[42],
        Dream_h2_Client_connection[12],
        Dream_h2_Client_connection[43],
        Dream_h2_Client_connection[44],
        Dream_h2_Client_connection[46],
        Dream_h2_Client_connection[48],
        Dream_h2_Client_connection[50],
        Dream_h2_Client_connection[49],
        Dream_h2_Client_connection[47],
        Dream_h2_Client_connection[14],
        Dream_h2_Client_connection[4]]];
   runtime.caml_register_global(12, Dream_h2_H2, "Dream_h2__H2");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJkcmVhbV9oMi5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsidGVzdF9iaXRfaW50MzIiLCJ4IiwiaSIsInRlc3RfYml0Iiwic2V0X2JpdCIsInNldF9iaXRfaW50MzIiLCJjbGVhcl9iaXQiLCJjbGVhcl9iaXRfaW50MzIiLCJzeW1ib2wiLCJzeW1ib2wkMCIsInMxIiwiczIiLCJzeW1ib2wkMSIsInN5bWJvbCQyIiwiY29ubmVjdGlvbiIsImlzX2Nvbm5lY3Rpb24iLCJpZCIsImlzX3JlcXVlc3QiLCJpc19wdXNoZWQiLCJuIiwibWF4X3N0cmVhbV9pZCIsInNlcmlhbGl6ZSIsInBhcnNlIiwidG9fc3RyaW5nIiwicHBfaHVtIiwiZm9ybWF0dGVyIiwidCIsIm1lc3NhZ2UiLCJtc2ciLCJrZXkiLCJtYXhfd2luZG93X3NpemUiLCJkZWZhdWx0X2luaXRpYWxfd2luZG93X3NpemUiLCJpc193aW5kb3dfb3ZlcmZsb3ciLCJvY3RldHNfcGVyX3NldHRpbmciLCJzZXJpYWxpemVfa2V5IiwiY2hlY2tfdmFsdWUiLCJpc19jbGllbnQiLCJ2IiwidiQwIiwidiQxIiwiY2hlY2tfc2V0dGluZ3NfbGlzdCIsIm9wdCIsInNldHRpbmdzIiwic3RoIiwieHMiLCJlcnIiLCJkZWZhdWx0JDAiLCJzZXR0aW5nc19mb3JfdGhlX2Nvbm5lY3Rpb24iLCJzZXR0aW5nc19saXN0Iiwic2V0dGluZ3NfbGlzdCQwIiwic2V0dGluZ3NfbGlzdCQxIiwic2V0dGluZ3NfbGlzdCQyIiwicGFyc2Vfc2V0dGluZ3NfcGF5bG9hZCIsIm51bV9zZXR0aW5ncyIsInBhcnNlX2lubmVyIiwiYWNjIiwicmVtYWluaW5nIiwiayIsIndyaXRlX3NldHRpbmdzX3BheWxvYWQiLCJzZXR0aW5nIiwidmFsdWUkMCIsInZhbHVlIiwib2Zfc2V0dGluZ3NfbGlzdCIsIml0ZW0iLCJ4JDAiLCJ4JDEiLCJuZXdfdmFsIiwieCQyIiwieCQzIiwib2ZfYmFzZTY0IiwiZW5jb2RlZCIsInNldHRpbmdzX3BheWxvYWQiLCJzZXR0aW5nc19wYXlsb2FkX2xlbmd0aCIsImUiLCJ0b19iYXNlNjQiLCJmYXJhZGF5Iiwic2V0dGluZ3NfaGV4IiwiciIsInBwX2VsZW0iLCJrZXkkMCIsInYkMiIsInYkMyIsInYkNCIsInRvX3NldHRpbmdzIiwiaW5pdGlhbF93aW5kb3dfc2l6ZSIsIm1heF9jb25jdXJyZW50X3N0cmVhbXMiLCJlbmFibGVfc2VydmVyX3B1c2giLCJyZWFkX2J1ZmZlcl9zaXplIiwiZGVmYXVsdF9mbGFncyIsInRlc3RfZW5kX3N0cmVhbSIsInNldF9lbmRfc3RyZWFtIiwiY2xlYXJfZW5kX3N0cmVhbSIsInRlc3RfYWNrIiwic2V0X2FjayIsInRlc3RfZW5kX2hlYWRlciIsInNldF9lbmRfaGVhZGVyIiwidGVzdF9wYWRkZWQiLCJzZXRfcGFkZGVkIiwidGVzdF9wcmlvcml0eSIsInNldF9wcmlvcml0eSIsImRlZmF1bHRfcHJpb3JpdHkiLCJoaWdoZXN0X3ByaW9yaXR5IiwidGVzdF9leGNsdXNpdmUiLCJzZXRfZXhjbHVzaXZlIiwiY2xlYXJfZXhjbHVzaXZlIiwiZXF1YWwiLCJwMSIsInAyIiwiY29ubmVjdGlvbl9wcmVmYWNlIiwicmVzZXJ2ZWRfcmVxdWVzdCIsInJlc2VydmVkX3Jlc3BvbnNlIiwiZW1wdHkiLCJvZl9yZXZfbGlzdCIsImhzIiwibmFtZSIsIm9mX2xpc3QiLCJ0b19yZXZfbGlzdCIsInRvX2xpc3QiLCJ0b19ocGFja19saXN0IiwiY2hhcl9pc191cHBlciIsImMiLCJsb3dlciIsInkiLCJsZW4iLCJjMSIsImMyIiwiaXNfbG93ZXJjYXNlIiwibWVtIiwidCQwIiwidCQxIiwibmFtZSQwIiwiYWRkIiwic2Vuc2l0aXZlIiwiYWRkX2xpc3QiLCJscyIsImFkZF9tdWx0aSIsImxzcyIsImxzcyQwIiwibHNzJDEiLCJ2cyIsInZzJDAiLCJ2cyQxIiwidCQyIiwiYWRkX3VubGVzc19leGlzdHMiLCJyZXBsYWNlIiwibG9vcCIsIm52Iiwic2VlbiIsInNlZW4kMCIsIm52JDAiLCJuJDAiLCJyZW1vdmUiLCJzIiwicyQwIiwicyQxIiwiZ2V0IiwiZ2V0X2V4biIsImdldF9wc2V1ZG8iLCJnZXRfcHNldWRvX2V4biIsImdldF9tdWx0aSIsImFjYyQwIiwiZ2V0X211bHRpX3BzZXVkbyIsImlzX3BzZXVkbyIsIml0ZXIiLCJmIiwiZm9sZCIsImluaXQiLCJleGlzdHMiLCJ2YWxpZF9oZWFkZXJzIiwicHNldWRvX2VuZGVkIiwiaW52YWxpZCIsInBzZXVkb19kaWRfZW5kIiwidmFsaWRfcmVxdWVzdF9oZWFkZXJzIiwidmFsaWRfcmVzcG9uc2VfaGVhZGVycyIsIm1ldGhvZF9wYXRoX2FuZF9zY2hlbWVfb3JfbWFsZiIsInBhdGgkMCIsIm1ldGgiLCJwYXRoIiwic2NoZW1lIiwidHJhaWxlcnNfdmFsaWQiLCJpc192YWxpZF9oMmNfY29ubmVjdGlvbiIsInZhbHVlcyIsInZhbHVlcyQwIiwib2ZfaHR0cDEiLCJoZWFkZXJzIiwidGFyZ2V0IiwiaG9zdCIsImhlYWRlcnMkMCIsImIiLCJmbXQiLCJjb250ZW50X2xlbmd0aF9vZl9zdHJpbmciLCJib2R5X2xlbmd0aCIsImhkIiwidGwiLCJub25lIiwic29tZSIsImlzX25vbmUiLCJpc19zb21lIiwiY2FsbF9pZl9zb21lIiwidW5jaGVja2VkX3ZhbHVlIiwiY3JlYXRlIiwiZGVmYXVsdF9yZWFzb25fcGhyYXNlIiwidG9fY29kZSIsInVuc2FmZV9vZl9jb2RlIiwib2ZfY29kZSIsImlzX2luZm9ybWF0aW9uYWwiLCJpc19zdWNjZXNzZnVsIiwiaXNfcmVkaXJlY3Rpb24iLCJpc19jbGllbnRfZXJyb3IiLCJpc19zZXJ2ZXJfZXJyb3IiLCJpc19lcnJvciIsIm9mX3N0cmluZyIsInN0YXR1cyIsInJlcXVlc3RfbWV0aG9kIiwicmVhc29uIiwid3JpdGVfdWludDI0Iiwid3JpdGVfb2N0ZXQiLCJvIiwid3JpdGVfZnJhbWVfaGVhZGVyIiwiZnJhbWVfaGVhZGVyIiwiZnJhbWVfdHlwZSIsInN0cmVhbV9pZCIsImZsYWdzIiwicGF5bG9hZF9sZW5ndGgiLCJ3cml0ZV9mcmFtZV93aXRoX3BhZGRpbmciLCJpbmZvIiwibGVuZ3RoIiwid3JpdGVyIiwiaGVhZGVyIiwid3JpdGVyJDAiLCJoZWFkZXIkMCIsInBhZF9sZW5ndGgiLCJ3cml0ZXIkMSIsImhlYWRlciQxIiwid3JpdGVfZGF0YV9mcmFtZSIsIm9mZiIsImJvZHkiLCJsZW4kMCIsInNjaGVkdWxlX2RhdGFfZnJhbWUiLCJic3RyIiwid3JpdGVfcHJpb3JpdHkiLCJ3ZWlnaHQiLCJzdHJlYW1fZGVwZW5kZW5jeSIsImV4Y2x1c2l2ZSIsInN0cmVhbV9kZXBlbmRlbmN5X2lkIiwiYm91bmRlZF9zY2hlZHVsZV9pb3ZlY3MiLCJpb3ZlY3MiLCJyZW1haW5pbmckMCIsImlvdmVjcyQwIiwiaW92ZWNzJDEiLCJidWZmZXIiLCJyZW1haW5pbmckMSIsIndyaXRlX2hlYWRlcnNfZnJhbWUiLCJwcmlvcml0eSIsImxlbiQxIiwiaW5mbyQwIiwid3JpdGVfcHJpb3JpdHlfZnJhbWUiLCJ3cml0ZV9yc3Rfc3RyZWFtX2ZyYW1lIiwid3JpdGVfc2V0dGluZ3NfZnJhbWUiLCJ3cml0ZV9wdXNoX3Byb21pc2VfZnJhbWUiLCJwcm9taXNlZF9pZCIsImRlZmF1bHRfcGluZ19wYXlsb2FkIiwid3JpdGVfcGluZ19mcmFtZSIsInBheWxvYWQiLCJ3cml0ZV9nb19hd2F5X2ZyYW1lIiwiZXJyb3JfY29kZSIsImRlYnVnX2RhdGEiLCJkZWJ1Z19kYXRhX2xlbiIsIndyaXRlX3dpbmRvd191cGRhdGVfZnJhbWUiLCJ3aW5kb3dfc2l6ZSIsIndyaXRlX2NvbnRpbnVhdGlvbl9mcmFtZSIsIndyaXRlX3Vua25vd25fZnJhbWUiLCJjb2RlIiwid3JpdGVfY29ubmVjdGlvbl9wcmVmYWNlIiwiYnVmZmVyX3NpemUiLCJlbmNvZGVyIiwibWFrZV9mcmFtZV9pbmZvIiwicGFkZGluZyIsInN0aCQwIiwic3RoJDEiLCJtYXhfZnJhbWVfc2l6ZSIsIndyaXRlX2Nvbm5lY3Rpb25fcHJlZmFjZSQwIiwiZnJhbWVfaW5mbyIsImNodW5rX2RhdGFfZnJhbWVzIiwidG90YWxfbGVuZ3RoIiwibWF4X2ZyYW1lX3BheWxvYWQiLCJvZmYkMCIsImZyYW1lX2luZm8kMCIsIm9mZiQxIiwid3JpdGVfZGF0YSIsInN0ciIsInNjaGVkdWxlX2RhdGEiLCJjaHVua19oZWFkZXJfYmxvY2tfZnJhZ21lbnRzIiwid3JpdGVfZnJhbWUiLCJoYXNfcHJpb3JpdHkiLCJibG9ja19zaXplIiwiZnJhbWVfaW5mbyQyIiwiaGVhZGVyc19ibG9ja19sZW4iLCJmcmFtZV9pbmZvJDEiLCJlbmNvZGVfaGVhZGVycyIsImhwYWNrX2VuY29kZXIiLCJ3cml0ZV9yZXF1ZXN0X2xpa2VfZnJhbWUiLCJyZXF1ZXN0Iiwid3JpdGVfcmVxdWVzdF9oZWFkZXJzIiwid3JpdGVfcHVzaF9wcm9taXNlIiwid3JpdGVfcmVzcG9uc2VfaGVhZGVycyIsInJlc3BvbnNlIiwid3JpdGVfcmVzcG9uc2VfdHJhaWxlcnMiLCJ0cmFpbGVycyIsIndyaXRlX3JzdF9zdHJlYW0iLCJ3cml0ZV93aW5kb3dfdXBkYXRlIiwic2NoZWR1bGVfaW92ZWNzIiwid3JpdGVfcHJpb3JpdHkkMCIsIndyaXRlX3NldHRpbmdzIiwid3JpdGVfcGluZyIsIndyaXRlX2dvX2F3YXkiLCJsYXN0X3N0cmVhbV9pZCIsImVycm9yIiwib25fd2FrZXVwX3dyaXRlciIsIndha2V1cCIsImZsdXNoIiwidW55aWVsZCIsInlpZWxkJDAiLCJjbG9zZSIsImNsb3NlX2FuZF9kcmFpbiIsImRyYWluZWQiLCJpc19jbG9zZWQiLCJkcmFpbmVkX2J5dGVzIiwicmVwb3J0X3Jlc3VsdCIsInJlc3VsdCIsIm5leHQiLCJpbml0aWFsX3R0bCIsImVycm9yX2hhbmRsZXIiLCJvbl9jbG9zZSIsImlzX2lkbGUiLCJpc19vcGVuIiwiZmluaXNoX3N0cmVhbSIsImFjdGl2ZSIsImNsb3NlZCIsImV4biIsImVycm9yX3RvX2NvZGUiLCJyZXNldF9zdHJlYW0iLCJkZWZhdWx0X2RvbmVfcmVhZGluZyIsImRlZmF1bHRfb25fZW9mIiwiZGVmYXVsdF9vbl9yZWFkIiwiZG9uZV9yZWFkaW5nIiwiY3JlYXRlX2VtcHR5IiwidW5zYWZlX2ZhcmFkYXkiLCJkb19leGVjdXRlX3JlYWQkMCIsIm9uX2VvZiIsIm9uX3JlYWQiLCJpb3ZlYyIsImV4ZWN1dGVfcmVhZCQwIiwiZG9fZXhlY3V0ZV9yZWFkIiwiZXhlY3V0ZV9yZWFkIiwic2NoZWR1bGVfcmVhZCIsImhhc19wZW5kaW5nX291dHB1dCIsImNyZWF0ZSQwIiwiY3JlYXRlX2VtcHR5JDAiLCJyZWFkeV90b193cml0ZSIsIndyaXRlX2NoYXIiLCJ3cml0ZV9zdHJpbmciLCJ3cml0ZV9iaWdzdHJpbmciLCJzY2hlZHVsZV9iaWdzdHJpbmciLCJrb250aW51ZSIsImlzX2Nsb3NlZCQwIiwiaGFzX3BlbmRpbmdfb3V0cHV0JDAiLCJjbG9zZSQwIiwidW5zYWZlX2ZhcmFkYXkkMCIsInRyYW5zZmVyX3RvX3dyaXRlciIsIm1heF9ieXRlcyIsImJ1ZmZlcmVkIiwibGVuZ3RodiIsIndyaXRldl9sZW4iLCJza2lwX21hbnkiLCJwIiwibSIsImRlZmF1bHRfZnJhbWVfaGVhZGVyIiwiY29ubmVjdGlvbl9lcnJvciIsInN0cmVhbV9lcnJvciIsInBhcnNlX3VpbnQyNCIsIm8xIiwibzIiLCJvMyIsImZyYW1lX2xlbmd0aCIsInBhcnNlX3N0cmVhbV9pZGVudGlmaWVyIiwic3RyZWFtX2lkZW50aWZpZXIiLCJwYXJzZV9mcmFtZV9oZWFkZXIiLCJwYXJzZV9wYWRkZWRfcGF5bG9hZCIsInBhcnNlciIsInJlbGV2YW50X2xlbmd0aCIsInBhcnNlX2RhdGFfZnJhbWUiLCJwYXJzZV9kYXRhIiwiYnMiLCJwYXJzZV9wcmlvcml0eSIsInBhcnNlX2hlYWRlcnNfZnJhbWUiLCJwYXJzZV9oZWFkZXJzIiwiaGVhZGVyc19ibG9jayIsInBhcnNlX3ByaW9yaXR5X2ZyYW1lIiwicGFyc2VfZXJyb3JfY29kZSIsInBhcnNlX3JzdF9zdHJlYW1fZnJhbWUiLCJwYXJzZV9zZXR0aW5nc19mcmFtZSIsInBhcnNlX3B1c2hfcHJvbWlzZV9mcmFtZSIsInBhcnNlX3B1c2hfcHJvbWlzZSIsInByb21pc2VkX3N0cmVhbV9pZCIsImZyYWdtZW50IiwicGFyc2VfcGluZ19mcmFtZSIsInBhcnNlX2dvX2F3YXlfZnJhbWUiLCJwYXJzZV93aW5kb3dfdXBkYXRlX2ZyYW1lIiwidWludCIsIndpbmRvd19zaXplX2luY3JlbWVudCIsInBhcnNlX2NvbnRpbnVhdGlvbl9mcmFtZSIsImJsb2NrX2ZyYWdtZW50IiwicGFyc2VfdW5rbm93bl9mcmFtZSIsInR5cCIsImJpZ3N0cmluZyIsInBhcnNlX2ZyYW1lX3BheWxvYWQiLCJwYXJzZV9mcmFtZSIsInBhcnNlX2NvbnRleHQiLCJpc19mcmFtZV9zaXplX2Vycm9yIiwiZnJhbWVfcGF5bG9hZCIsImNyZWF0ZV9wYXJzZV9jb250ZXh0Iiwic2V0dGluZ3NfcHJlZmFjZSIsImZyYW1lIiwiY29ubmVjdGlvbl9wcmVmYWNlX2FuZF9mcmFtZXMiLCJwcmVmYWNlX3BhcnNlciIsInByZWZhY2VfaGFuZGxlciIsImZyYW1lX2hhbmRsZXIiLCJjbGllbnRfZnJhbWVzIiwic2VydmVyX2ZyYW1lcyIsInRyYW5zaXRpb24iLCJzdGF0ZSIsImNvbnRpbnVlJDAiLCJjb21taXR0ZWQiLCJjb25zdW1lZCIsIm1hcmtzIiwiY29uc3VtZWQkMCIsInN0YXJ0IiwicmVhZF93aXRoX21vcmUiLCJtb3JlIiwicGFyc2VyX2N0eCIsInJlbWFpbmluZ19ieXRlcyIsInJlbWFpbmluZ19ieXRlcyQwIiwiZm9yY2VfY2xvc2UiLCJmYWlsX3RvX3N0cmluZyIsIm5leHRfZnJvbV9lcnJvciIsImVycm9yX2NvZGUkMCIsImNyZWF0ZV9hY3RpdmVfcmVxdWVzdCIsInJlcXVlc3RfYm9keSIsImNyZWF0ZV9hY3RpdmVfc3RyZWFtIiwiYm9keV9idWZmZXJfc2l6ZSIsImNyZWF0ZV9wdXNoX3N0cmVhbSIsInJlc3BvbnNlX3N0YXRlIiwicmVzcG9uc2VfZXhuIiwic2VuZF9maXhlZF9yZXNwb25zZSIsImRhdGEiLCJpb3ZlYyQwIiwibGVuZ3RoJDAiLCJpb3ZlYyQxIiwic2hvdWxkX3NlbmRfZGF0YSIsInNjaGVkdWxlX3RyYWlsZXJzIiwibmV3X3RyYWlsZXJzIiwic3RyZWFtIiwib2xkX3RyYWlsZXJzIiwicmVzcG9uc2VfYm9keSIsInVuc2FmZV9yZXNwb25kX3dpdGhfZGF0YSIsInJlcXVlc3RfaW5mbyIsInN0cmVhbSQwIiwicmVzcG9uZF93aXRoX3N0cmluZyIsInJlc3BvbmRfd2l0aF9iaWdzdHJpbmciLCJzZW5kX3N0cmVhbWluZ19yZXNwb25zZSIsImZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHkiLCJ3YWl0X2Zvcl9maXJzdF9mbHVzaCIsInJlc3BvbnNlX2JvZHlfYnVmZmVyIiwidW5zYWZlX3Jlc3BvbmRfd2l0aF9zdHJlYW1pbmciLCJyZXNwb25kX3dpdGhfc3RyZWFtaW5nIiwic3RhcnRfcHVzaF9zdHJlYW0iLCJwcm9taXNlZF9yZXFkIiwiYWN0aXZlX3N0cmVhbSIsInVuc2FmZV9wdXNoIiwicHVzaCIsInJlcG9ydF9lcnJvciIsInJlcG9ydF9lcnJvciQwIiwicmVwb3J0X2V4biIsInRyeV93aXRoIiwiZXhuJDAiLCJyZXF1aXJlc19vdXRwdXQiLCJmbHVzaF9yZXF1ZXN0X2JvZHkiLCJ3cml0ZV9idWZmZXJfZGF0YSIsImNsb3NlX3N0cmVhbSIsImZsdXNoX3Jlc3BvbnNlX2JvZHkiLCJpc19wYXJ0aWFsX2ZsdXNoIiwibGVuX3RvX3dyaXRlIiwiZGVsaXZlcl90cmFpbGVyX2hlYWRlcnMiLCJoYXNoIiwiZmluZF9vcHQiLCJoIiwiY29tcGFyZSIsInQxIiwidDIiLCJtYWtlX3Jvb3QiLCJjYXBhY2l0eSIsInBhcmVudCIsImluaXRpYWxfc2VuZF93aW5kb3dfc2l6ZSIsImluaXRpYWxfcmVjdl93aW5kb3dfc2l6ZSIsImRlc2NyaXB0b3IiLCJjaGlsZHJlbiIsImNoaWxkcmVuJDAiLCJyZW1vdmVfY2hpbGQiLCJ1cGRhdGVfY2hpbGRyZW4iLCJ1cGRhdGVkX2NoaWxkcmVuIiwic2V0X3BhcmVudCIsInN0cmVhbV9ub2RlIiwibmV3X3BhcmVudCIsIm5ld19wYXJlbnRfbm9kZSIsIm9sZF9wYXJlbnRfbm9kZSIsIm5ld19jaGlsZHJlbiIsInBfbm9kZSIsInBxIiwibmV3X2NoaWxkcmVuJDAiLCJ3b3VsZF9jcmVhdGVfY3ljbGUiLCJwYXJlbnRfbm9kZSIsInJlcHJpb3JpdGl6ZV9zdHJlYW0iLCJyb290IiwibmV3X3ByaW9yaXR5IiwicGFyZW50X3N0cmVhbSIsIm5ld19wcmlvcml0eSQwIiwibmV3X3BhcmVudCQwIiwiY3VycmVudF9wYXJlbnRfbm9kZSIsImN1cnJlbnRfcGFyZW50X2lkIiwibmV3X3BhcmVudF9zdHJlYW0iLCJ1cGRhdGVfdCIsInRfbGFzdCIsInRsYXN0X3AiLCJ0X2xhc3QkMCIsInVwZGF0ZV90X2xhc3QiLCJnZXRfbm9kZSIsInBhcmFtIiwiZmluZCIsImFsbF9zdHJlYW1zIiwiYWxsb3dlZF90b190cmFuc21pdCIsImFsbG93ZWRfdG9fcmVjZWl2ZSIsInNpemUiLCJ3cml0ZSIsImFsbG93ZWRfYnl0ZXMiLCJ3cml0dGVuIiwibWFya19mb3JfcmVtb3ZhbCIsImltcGxpY2l0bHlfY2xvc2VfaWRsZV9zdHJlYW0iLCJtYXhfc2Vlbl9pZHMiLCJpbXBsaWNpdGx5X2Nsb3NlX3N0cmVhbSIsIm1heF9wdXNoZWRfc3RyZWFtX2lkIiwibWF4X2NsaWVudF9zdHJlYW1faWQiLCJzY2hlZHVsZSIsInRyYXZlcnNlIiwic3VidHJlZV9pc19hY3RpdmUiLCJzdWJ0cmVlX2lzX2FjdGl2ZSQwIiwid3JpdHRlbiQwIiwic3VidHJlZV9pc19hY3RpdmUkMSIsInJlbWFpbmluZ19jaGlsZHJlbiQxIiwicmVtYWluaW5nX2NoaWxkcmVuIiwiaV9ub2RlIiwicmVtYWluaW5nX2NoaWxkcmVuJDAiLCJjaGVja19mbG93IiwiZmxvdyQwIiwiZ3Jvd3RoIiwiZmxvdyIsImFkZF9mbG93IiwidmFsaWRfZmxvdyIsImZsb3ckMSIsImZsb3ckMiIsInZhbGlkX2Zsb3ckMCIsImFkZF9pbmZsb3ciLCJpbmZsb3ciLCJpbmZsb3ckMCIsInZhbGlkX2luZmxvdyIsImluZmxvdyQxIiwiaW5mbG93JDIiLCJ2YWxpZF9pbmZsb3ckMCIsImRlZHVjdF9pbmZsb3ciLCJwcF9odW1faW5uZXIiLCJsZXZlbCIsInBwX2JpbmRpbmciLCJmbHVzaF93cml0ZV9ib2R5Iiwid2FrZXVwX3dyaXRlciIsInNodXRkb3duX3JlYWRlciIsInNodXRkb3duX3dyaXRlciIsInNodXRkb3duIiwid2FzX2Nsb3NlZF9vcl9pbXBsaWNpdGx5X2Nsb3NlIiwiZXJyb3IkMCIsInJlcWQiLCJyZXBvcnRfY29ubmVjdGlvbl9lcnJvciIsInJlcG9ydF9zdHJlYW1fZXJyb3IiLCJzZXRfZXJyb3JfYW5kX2hhbmRsZSIsIm9uX2Nsb3NlX3N0cmVhbSIsInNlbmRfd2luZG93X3VwZGF0ZSIsInNlbmRfd2luZG93X3VwZGF0ZV9mcmFtZSIsIm4kMSIsInBhcmVudF9zdHJlYW1faWQiLCJjYW5kaWRhdGVfcHVzaF9zdHJlYW1faWQiLCJoYW5kbGVfaGVhZGVycyIsImVuZF9zdHJlYW0iLCJoYW5kbGVfaGVhZGVyc19ibG9jayIsInBhcnRpYWxfaGVhZGVycyIsImlzX3RyYWlsZXJzIiwiZW5kX2hlYWRlcnMiLCJwYXJzZV9zdGF0ZSIsInBhcnNlX3N0YXRlJDAiLCJoYW5kbGVfdHJhaWxlcl9oZWFkZXJzIiwib3Blbl9zdHJlYW0iLCJwcm9jZXNzX2ZpcnN0X2hlYWRlcnNfYmxvY2siLCJoZWFkZXJzX2Jsb2NrX2xlbmd0aCIsImluaXRpYWxfYnVmZmVyX3NpemUiLCJwcm9jZXNzX3RyYWlsZXJfaGVhZGVycyIsInByb2Nlc3NfaGVhZGVyc19mcmFtZSIsInJlcWQkMSIsInJlcWQkMCIsInByb2Nlc3NfZGF0YV9mcmFtZSIsInByb2Nlc3NfcHJpb3JpdHlfZnJhbWUiLCJwcm9jZXNzX3JzdF9zdHJlYW1fZnJhbWUiLCJhcHBseV9zZXR0aW5nc19saXN0Iiwib2xkX3ZhbCIsIm5ld19zZXR0aW5ncyIsImFjayIsInByb2Nlc3Nfc2V0dGluZ3NfZnJhbWUiLCJwcm9jZXNzX3BpbmdfZnJhbWUiLCJwcm9jZXNzX2dvYXdheV9mcmFtZSIsImFkZF93aW5kb3dfaW5jcmVtZW50IiwiaW5jcmVtZW50IiwiZGlkX2FkZCIsIm5ld19mbG93IiwicHJvY2Vzc193aW5kb3dfdXBkYXRlX2ZyYW1lIiwid2luZG93X2luY3JlbWVudCIsInByb2Nlc3NfY29udGludWF0aW9uX2ZyYW1lIiwiYWN0aXZlX3N0cmVhbSQwIiwicGFydGlhbF9oZWFkZXJzJDAiLCJkZWZhdWx0X2Vycm9yX2hhbmRsZXIiLCJoYW5kbGUiLCJkaWZmIiwiY3JlYXRlX2dlbmVyaWMiLCJoMmMiLCJjb25maWciLCJyZXF1ZXN0X2hhbmRsZXIiLCJjb25uZWN0aW9uX3ByZWZhY2VfaGFuZGxlciIsInJlY3ZfZnJhbWUiLCJwcmlvcml0eSQwIiwiZGF0YSQwIiwiaGVhZGVyc19ibG9jayQwIiwiaGFuZGxlX2gyY19yZXF1ZXN0IiwicmVxdWVzdF9ib2R5X2lvdmVjcyIsImNyZWF0ZV9oMmMiLCJodHRwX3JlcXVlc3QiLCJtc2ckMCIsImgyX2hlYWRlcnMiLCJ1cGdyYWRlX3NldHRpbmdzIiwibmV4dF9yZWFkX29wZXJhdGlvbiIsIm9wZXJhdGlvbiIsInJlYWQiLCJyZWFkX2VvZiIsInlpZWxkX3JlYWRlciIsIm5leHRfd3JpdGVfb3BlcmF0aW9uIiwicmVwb3J0X3dyaXRlX3Jlc3VsdCIsInlpZWxkX3dyaXRlciIsImNyZWF0ZV9hY3RpdmVfcmVzcG9uc2UiLCJyZXNwb25zZV9ib2R5X2V4biIsInJlc3BvbnNlX2JvZHkkMCIsImFjdGl2ZV9zdGF0ZSIsInRyYWlsZXJzX2hhbmRsZXIiLCJtZXNzYWdlJDEiLCJtZXNzYWdlJDAiLCJvayIsInRha2Vfb3B0IiwiZGVmYXVsdF9wdXNoX2hhbmRsZXIiLCJyZXNwZCIsImhhbmRsZV9wdXNoX3Byb21pc2VfaGVhZGVycyIsIm1ldGgkMCIsInJlc3BvbnNlX2hhbmRsZXIiLCJoYW5kbGVfcmVzcG9uc2VfaGVhZGVycyIsImFjdGl2ZV9yZXF1ZXN0IiwibmV3X3Jlc3BvbnNlX3N0YXRlIiwiY3JlYXRlX3BhcnRpYWxfaGVhZGVycyIsImhhbmRsZV9maXJzdF9yZXNwb25zZV9ieXRlcyIsInJlbW90ZV9zdGF0ZSIsImFjdGl2ZV9yZXNwb25zZSIsInJlc3BvbnNlX2luZm8iLCJyZXNwb25zZV9ib2R5X2J5dGVzIiwicmVzZXJ2ZV9zdHJlYW0iLCJwcm9jZXNzX3B1c2hfcHJvbWlzZV9mcmFtZSIsInNlbmRfY29ubmVjdGlvbl9lcnJvciIsImNhbGxiYWNrIiwicHVzaF9oYW5kbGVyIiwicHVzaF9oYW5kbGVyJDAiLCJwdXNoX2hhbmRsZXIkMSIsImJzJDAiLCJzZXR0aW5ncyQwIiwiY3JlYXRlX2FuZF9hZGRfc3RyZWFtIiwicmVzcG9uc2VfZXJyb3JfaGFuZGxlciIsInBpbmciLCJwYXlsb2FkJDAiLCJwYXlsb2FkJDEiLCJ1bmV4cGVjdGVkX2VvZiIsImJ5dGVzX3JlYWQiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taDIvdXRpbC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS1oMi9zdHJlYW1faWRlbnRpZmllci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS1oMi9lcnJvcl9jb2RlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWgyL2Vycm9yLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWgyL3NldHRpbmdzLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWgyL2NvbmZpZy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS1oMi9mbGFncy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS1oMi9wcmlvcml0eS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS1oMi9mcmFtZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS1oMi9oZWFkZXJzLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWgyL21lc3NhZ2UubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taDIvb3B0aW9uYWxfdGh1bmsubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taDIvcmVxdWVzdC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS1oMi9zdGF0dXMubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taDIvcmVzcG9uc2UubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taDIvc2VyaWFsaXplLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWgyL3N0cmVhbS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RyZWFtLWh0dHBhZi9kcmVhbS1oMi9ib2R5Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWgyL3BhcnNlLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWgyL3JlcWQubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9kcmVhbS1odHRwYWYvZHJlYW0taDIvc2NoZWR1bGVyLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWgyL3NlcnZlcl9jb25uZWN0aW9uLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWgyL3Jlc3BkLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZHJlYW0taHR0cGFmL2RyZWFtLWgyL2NsaWVudF9jb25uZWN0aW9uLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7WUFnQ2FBLGVBQWVDLEdBQUVDO0lBQzVCLFdBQ0ksNkJBRnNCRCxTQUFFQztHQUVlO1lBRWhDQyxTQUFTRixHQUFFQyxHQUFJLGNBQU5ELFNBQUVDLFdBQXlCO1lBQ3BDRSxRQUFRSCxHQUFFQyxHQUFJLE9BQU5ELFNBQUVDLEVBQW1CO1lBRTdCRyxjQUFjSixHQUFFQyxHQUMzQixPQUR5QkQsU0FBRUMsRUFFRjtZQUVkSSxVQUFVTCxHQUFFQyxHQUFJLE9BQU5ELElBQWEsNEJBQVhDLEdBQXlCO1lBRXJDSyxnQkFBZ0JOLEdBQUVDO0lBQzdCLE9BRDJCRCxJQUVsQixrQ0FGb0JDO0dBRU07Ozs7T0FmeEJGO09BSUFHO09BQ0FDO09BRUFDO09BSUFDO09BRUFDOzs7RTs7Ozs7Ozs7O0c7Ozs7Ozs7O0lDVFRDO1lBQ1NDLFNBQU9DLElBQUdDO0lBQUssT0FBQSw2QkFBUkQsSUFBR0M7R0FBNkI7WUFDdkNDLFNBQU1GLElBQUdDO0lBQUssV0FBQSw2QkFBUkQsSUFBR0M7R0FBNEI7WUFDckNFLFNBQU9ILElBQUdDO0lBQUssWUFBQSw2QkFBUkQsSUFBR0M7R0FBNkI7T0FLaERHO1lBS1NDLGNBQWNDO0lBQUssb0NBQUxBLElBTHZCRjtHQUtxRDtZQUs1Q0csV0FBV0QsSUFBSyxPQUFBLFdBbEJ6QlIsUUFrQnlCLFNBQUxRLFdBQTJCO1lBTXRDRSxVQUFtQ0M7SUFBdkIsNkJBQXVCQTtjQUFLLFdBeEJqRFgsUUF3QmlELFNBQUxXOztHQUEwQjtHQUFqRDtJQUlyQkM7OztPQTVCQVo7T0FDU0M7T0FDQUc7T0FDQUM7T0FLVEM7T0FLU0M7T0FLQUU7T0FNQUM7T0FJVEU7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ29DQUM7SUFBWTs7O1FBQ0Q7O1FBQ007O1FBQ0E7O1FBQ0c7O1FBQ0Q7O1FBQ0g7O1FBQ0U7O1FBQ0Q7O1FBQ1A7O1FBQ1U7O1FBQ0o7O1FBQ0c7O1FBQ0c7Z0JBQ0Q7O1FBQ0hMO0lBQU0sT0FBTkE7R0FBUTtZQUUxQk0sTUFlQU47SUFmUSxpQkFlUkE7c0JBQUFBO3lCQUFBQSxRQWRRO3lCQWNSQSxRQWJRO3lCQWFSQSxRQVpROzsyQkFZUkE7eUJBQUFBLFFBWFE7eUJBV1JBLFFBVlE7Ozt5QkFVUkEsUUFUUTt5QkFTUkEsUUFSUTs7MEJBUVJBO3dCQUFBQSxRQVBRO3dCQU9SQSxRQU5RO3dCQU1SQSxRQUxROzswQkFLUkE7d0JBQUFBLFNBSlE7d0JBSVJBLFNBSFE7Ozt3QkFHUkEsU0FGUTt3QkFFUkEsU0FEUTs7SUFDRixXQUFOQTtHQUEwQjtZQUUxQk87SUFBWTs7O1FBQ0Q7O1FBQ007O1FBQ0E7O1FBQ0c7O1FBQ0Q7O1FBQ0g7O1FBQ0U7O1FBQ0Q7O1FBQ1A7O1FBQ1U7O1FBQ0o7O1FBQ0c7O1FBQ0c7Z0JBQ0Q7O1FBQ0hQO0lBQU0sT0FBQSxvQ0FBTkE7R0FBZ0Q7WUFFbEVRLE9BQU9DLFdBQVVDO0lBQWtDLFVBakJuREgsVUFpQmlCRztJQUFrQyxPQUFBLCtCQUE1Q0Q7R0FBeUQ7aUNBbkRoRUosV0FpQkFDLE9BaUJBQyxXQWlCQUM7Ozs7RTs7Ozs7OztZQzdHQUc7SUFBVSxtQkFBNEQ7UUFBL0JDO0lBQVEsT0FBUkE7R0FBaUM7NEJBQXhFRDs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQzJPSUU7Ozs7Ozs7O0lBMU9GQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBTEFDO1lBY0FDLG1CQUFtQmIsR0FBSSxPQUFBLDZCQUFKQSxPQUE0QjtHQXBCakM7SUFBQTtVQU1kWSw2QkFLQUQsaUJBU0FFO0lBaUJGQztZQUVBQztJQUFnQjs7T0FDSzs7T0FDTDs7T0FDVTs7T0FDSDs7T0FDTDtlQUNLOztHQUFHO1lBRTFCQyxZQUFhQztJOztXQUNGQztnQkFBQUEsV0FBQUEsR0FPVDtVQVJXRCxtQkFDRkMsR0FpQlQ7T0FJRzs7V0FDYUM7T0FBTyxHQUFBLDBCQUFQQTtRQUtsQixrQkFJUTs7O1dBR0tDO21CQUFBQSxtQkFBQUE7T0FPYjs7SUFJSzs7WUFHTEMsb0JBQXNCQyxLQUFtQkM7SUFDM0MsR0FEd0JELFNBQVlFLE1BQVpGLFFBQUFMLFlBQVlPLGNBQVpQO2dCQUFtQk07SUFDNUI7aUJBQ0w7S0FFQyxJQURGRSxlQUFMM0MsY0FHRTRDLE1BdkRKVixZQWlEc0JDLFdBR3BCbkM7Y0FHRTRDLFFBQWtCLE9BQWxCQTtpQkFIR0Q7O0dBS0k7R0FjYixJQURFRTtZQWFBQyw0QkFBNEJMO0lBQzlCO0tBQUlNO09BRDBCTixnQkFiNUJJLHVCQWE0Qko7S0FNMUJPO09BQ0MsY0FQeUJQLGFBYjVCSTtrQkFhNEJKLGNBQzFCTTtVQUFBQTtLQVVBRTtPQUNDLGNBWnlCUixhQWI1Qkk7a0JBYTRCSixjQU0xQk87VUFBQUE7T0FOMEJQLGdCQWI1Qkk7O1lBYTRCSjtNQWtCMUJTLGdDQVBBRDs7U0FPQUMsa0JBUEFEO0lBWUosT0FMSUM7R0FLUztZQUVYQyx1QkFBdUJDO0lBQ3pCLFNBQ1FDLFlBQVlDLEtBQUlDO0tBSXRCLE9BSnNCQTtNQU9wQjtzQkFrQlFELEtBQVEsT0F6QlpELFlBeUJJQyxLQXpCWUMsbUJBeUI0Qjs7OztrQkFqQnpDQyxHQUFHcEI7VUFDTCxlQURFb0I7aUNBVFgsT0FDb0JGOzs7YUFVRixlQUZKbEIsSUFSTWtCOzthQVdGLGVBSEpsQixJQVJNa0I7O2FBWUYsZUFKSmxCLElBUk1rQjs7YUFhRixlQUxKbEIsSUFSTWtCOzthQWNGLGVBTkpsQixJQVJNa0I7cUJBZUYsZUFQSmxCLElBUk1rQjs7U0FzQk47T0FmVixNQUFBO01Ba0JJLE9BQUE7O0tBcEJNLFVBQUEsNEJBTE1BO0tBS04sT0FBQTtJQW9Cc0M7SUFFcEQsT0EzQlFELGVBRmlCRDtHQTZCRTtZQUV6QkssdUJBQXVCaEMsR0FBRXNCO2lCQUdwQlc7S0FLZ0IsVUEzSnJCekIsY0FzSkt5QjtLQUtGLDBCQVJvQmpDO1lBR2xCaUM7OztZQU9xQkMsVUFQckJEO1FBUUEsT0FBQSwwQkFYa0JqQyxHQVVHa0M7O1lBRUxDLFFBVGhCRixZQWFrQixPQUFBLDBCQWhCQWpDLEdBWUZtQzs7SUFJc0I7SUFmN0MsT0FBQSxpQ0FEMkJiO0dBaUJaO1lBRWJjLGlCQUFpQnBCO2lCQUVYYSxLQUFTUTtLQUNaLE9BRFlBOztZQUVNOUQsSUFGTjhEO1FBRVcsV0FBTDlELEdBRmZzRCxRQUFBQSxRQUFBQSxRQUFBQSxRQUFBQTs7WUFHVVMsTUFIREQ7UUFHTSxXQUhmUixjQUdVUyxhQUhWVCxRQUFBQSxRQUFBQSxRQUFBQTs7WUFJb0JVLE1BSlhGO1FBSWdCLFdBSnpCUixRQUFBQSxRQUlvQlUsS0FKcEJWLFFBQUFBLFFBQUFBOztZQUtpQlcsVUFMUkg7UUFLbUIsV0FMNUJSLFFBQUFBLFFBQUFBLFFBS2lCVyxTQUxqQlgsUUFBQUE7O1lBTVlZLE1BTkhKO1FBTVEsV0FOakJSLFFBQUFBLFFBQUFBLFFBQUFBLFFBTVlZLEtBTlpaOztZQU9pQmEsTUFQUkw7UUFPYSxXQVB0QlIsUUFBQUEsUUFBQUEsUUFBQUEsUUFBQUEsWUFPaUJhOztJQUErQztJQVJ4RSxPQUFBLGlDQXpGRXRCLFdBd0ZpQko7R0FXVDtZQUVSMkIsVUFBVUM7SUFDTixZQUFBLCtDQURNQTsyQkFjRTFDLG1CQUFRLFdBQVJBO0lBTFA7S0FQRjJDO0tBQ0NDO3FDQURERDtLQU9FLE1BeEVMbkIsdUJBa0VJb0I7S0FVRkMsSUFOQyxpQ0FMQUY7YUFXREUsTUFBZ0IsT0FBaEJBO1FBREcvQixXQUNIK0I7SUFEZSxXQXpCakJYLGlCQXlCS3BCO0dBRXdCO1lBRTdCZ0MsVUFBVWhEO0lBQ1o7S0FBSWdCLFdBekdGSyw0QkF3R1VyQjtLQUVrQixNQUFBLDJCQUQxQmdCO0tBQ0FpQyxVQUFVO0lBbERaakIsdUJBa0RFaUIsU0FEQWpDO0lBR2U7S0FBZmtDLGVBQWUsd0JBRmZEO0tBR0UsUUFBQSwrQ0FERkM7MkJBRUNDLGNBQUssV0FBTEE7UUFDU2pEO0lBQVEsV0FBUkE7R0FBaUI7WUFFN0JKLE9BQU9DLFdBQVVDO0lBQ25CLFNBQUlvRCxRQUFRckQsV0FBVWtDO0tBQ3BCLE9BRG9CQTs7O1NBR0F0QixJQUhBc0I7U0FDWEUsUUFFcUMsb0JBQTFCeEI7U0FGaEIwQzs7OztTQUdXekMsTUFKS3FCO1NBQ1hFLFFBRzBCLG9CQUFwQnZCO1NBSFh5Qzs7OztTQUlxQnhDLE1BTExvQjtTQUNYRSxRQUkrQyxvQkFBL0J0QjtTQUpyQndDOzs7O1NBS2tCQyxNQU5GckI7U0FDWEUsUUFLeUMsb0JBQTVCbUI7U0FMbEJEOzs7O1NBTWFFLE1BUEd0QjtTQUNYRSxRQU0rQixvQkFBdkJvQjtTQU5iRjs7O1FBTytDO1NBQTdCRyxNQVJGdkI7U0FDWEMsVUFPMEMsb0JBQTdCc0I7U0FQYnJCLFFBQUFEO1NBQUxtQixRQUFBbEQ7O0tBU0osT0FBQSwrQkFWVUosZ0JBQ05zRCxPQUFLbEI7SUFTd0M7SUFFbkQsK0JBYlNwQztJQWM4QixVQS9IckNzQiw0QkFpSGlCckI7SUFjbkIsa0NBYklvRCxTQURLckQ7SUFjVCxPQUFBLCtCQWRTQTtHQWVxQjs7Ozs7T0E3TjVCUTtPQUVBQztPQVFBQztPQWlEQUs7T0FxQkFNO09BYUFDO09BeUJBSztPQStCQU07T0FtQkFJO09BYUFPO09BZ0JBSztPQVNBbEQ7OztFOzs7Ozs7OztHQ3RPRjs7OztJQURFc0I7Ozs7Ozs7O1lBaUNBcUM7O0tBR0VDO0tBREFDO0tBRUFDO0tBSEFDOztJQU9KOztZQUpJRDtZQUZBRDtZQUNBRDtZQUZBRzs7OzZCQWxDRnpDLFdBaUNBcUM7OztFOzs7Ozs7Ozs7Rzs7Ozs7Ozs7SUN0Q0FLO1lBS0FDLGdCQUFnQnhGLEdBQUksT0FBQSw2QkFBSkEsTUFBZ0I7WUFDaEN5RixlQUFlekYsR0FBSSxPQUFBLDZCQUFKQSxNQUFlO1lBQzlCMEYsaUJBQWlCMUYsR0FBSSxPQUFBLDZCQUFKQSxNQUFpQjtZQUtsQzJGLFNBQVMzRixHQUFJLE9BQUEsNkJBQUpBLE1BQWdCO1lBQ3pCNEYsUUFBUTVGLEdBQUksT0FBQSw2QkFBSkEsTUFBZTtZQU12QjZGLGdCQUFnQjdGLEdBQUksT0FBQSw2QkFBSkEsTUFBZ0I7WUFDaEM4RixlQUFlOUYsR0FBSSxPQUFBLDZCQUFKQSxNQUFlO1lBSzlCK0YsWUFBWS9GLEdBQUksT0FBQSw2QkFBSkEsTUFBZ0I7WUFDNUJnRyxXQUFXaEcsR0FBSSxPQUFBLDZCQUFKQSxNQUFlO1lBSzFCaUcsY0FBY2pHLEdBQUksT0FBQSw2QkFBSkEsTUFBZ0I7WUFDOUJrRyxhQUFhbEcsR0FBSSxPQUFBLDZCQUFKQSxNQUFlOzs7O09BaEM1QnVGO09BS0FDO09BQ0FDO09BQ0FDO09BS0FDO09BQ0FDO09BTUFDO09BQ0FDO09BS0FDO09BQ0FDO09BS0FDO09BQ0FDOzs7RTs7Ozs7Ozs7O0c7Ozs7Ozs7SUMzQkFDO0lBTUFDOzs7WUFhQUMsZUFBZW5GLEdBQUksT0FBQSw2QkFBSkEsT0FBdUI7WUFDdENvRixjQUFjcEYsR0FBSSxPQUFBLDZCQUFKQSxPQUFzQjtZQUNwQ3FGLGdCQUFnQnJGLEdBQUksT0FBQSw2QkFBSkEsT0FBd0I7WUFFeENzRixNQUFNQyxJQUFHQztJQUNYLFVBRFFELFVBQUdDOztLQUVSO01BQUEsTUFBQSw2QkFGS0QsT0FBR0M7TUFFUixZQUZLRCxVQUFHQzs7OztHQUdtQjs7OztPQTFCNUJQO09BTUFDO09BYUFDO09BQ0FDO09BQ0FDO09BRUFDOzs7RTs7Ozs7Ozs7SUNuQ0FHO1lBa0RFdkY7SUFBWTs7O1FBQ0o7O1FBQ0c7O1FBQ0M7O1FBQ0M7O1FBQ0Q7O1FBQ0c7O1FBQ1A7O1FBQ0U7O1FBQ007Z0JBQ0E7O1FBQ1JwQjtJQUFLLE9BQUxBO0dBQU07WUFFZHFCLE1BV0FyQjtJQVhRLE9BV1JBLFNBQUssV0FBTEE7V0FBQUE7O09BVks7O09BQ0E7O09BQ0E7O09BQ0E7O09BQ0E7O09BQ0E7O09BQ0E7O09BQ0E7O09BQ0E7ZUFDQTs7R0FDUztHQXhFRDtJQUFBLGdCQWdEYm9CLFdBYUFDO3lCQS9ERnNGOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7SUNxSUVDOzs7O0lBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF0SEZDO1lBRUFDLFlBQVlDOztLQUNMLElBQVlwRCxrQkFBTnFEO0tBQWdCLFdBQWhCQSxNQUFNckQ7SUFBNkM7SUFBbEUsT0FBQSxpQ0FEY29EO0dBQ3VEO1lBRW5FRSxRQUFRekYsR0FBSSxPQUhac0YsWUFHd0IsNEJBQWhCdEYsSUFBNEI7WUFDcEMwRixZQUFZMUY7O0tBQWEsSUFBYW1DLGtCQUFOcUQ7S0FBb0IsV0FBcEJBLE1BQU1yRDtJQUEwQjtJQUFoRCxPQUFBLGlDQUFKbkM7R0FBc0Q7WUFDbEUyRixRQUFRM0Y7SUFBYSxVQURyQjBGLFlBQ1ExRjtJQUFhLE9BQUE7R0FBZTtZQUNwQzRGLGNBQWM1RixHQUFJLE9BQUEsNEJBQUpBLEdBQWM7R0FFaEM7WUFHTTZGLGNBQWNDO0lBQUksZ0JBQUpBLHVCQUFBQTs7R0FBMEI7WUFDeENDLE1BQU1ELEdBQUksT0FEVkQsY0FDTUMsS0FBQUEsYUFBQUEsRUFBeUM7WUFFL0NmLE1BQU14RyxHQUFFeUg7SUFDVjtLQUFJQyw0QkFESTFIO1dBQ0owSCxRQUNKLHNCQUZVRDs7O2dCQUNOQzs7V0FJRnpIOzs7U0FDTTBILDRCQU5BM0gsR0FLTkM7U0FFTTJILDRCQVBFSCxHQUtSeEg7V0FDTTBILE9BQ0FDO1NBQ21DLFVBVnpDSixNQVNNSTtZQVROSixNQVFNRyxhQUVpRCxNQUFBOztrQkFIdkQxSDttQkFBQUE7WUFBQUE7Ozs7Ozt3QkFPbUI7Ozs7Ozs7O0dBQUs7WUFFeEI0SCxhQUFhN0g7SUFDZixJQUFJMEgsNEJBRFcxSDtJQUVmO2VBREkwSDs7VUFFRnpIOztXQUNNMEgsNEJBSk8zSCxHQUdiQztPQUVLLEdBdEJMcUgsY0FxQk1LLEtBQ3FCLE1BQUE7aUJBRjNCMUg7a0JBQUFBO1dBQUFBOzs7Ozs7dUJBTW1COzs7SUFEYjtHQUNrQjtHQTNCbEIsYUFDTnFILGVBQ0FFLE9BRUFoQixPQWNBcUI7WUFZRUMsSUFBSXJHLEdBQUV3RjtJQUNaLElBRFVjLE1BQUF0RztJQUNWO1VBRFVzRyxLQUdIO0tBRHdCO01BRnJCQyxNQUFBRDtNQUVDRSxTQUZERjtNQUVxQixNQUFBLGtCQUZuQmQsTUFFRGdCO0tBQW9CLFFBQUE7U0FGckJGLE1BQUFDOztHQUdFO1lBR1ZFLElBQUl6RyxHQUFJZSxLQUFtQnlFLE1BQUtyRDtJQUFRLEdBQWhDcEIsU0FBWUUsTUFBWkYsUUFBQTJGLFlBQVl6RixjQUFaeUY7SUFBZ0MsZUFBYmxCLE1BQUtyRCxPQUF4QnVFLFlBQUoxRztHQUFtRTtZQUN2RTJHLFNBQVMzRyxHQUFFNEc7SUFBSyxVQS9DaEJ0QixZQStDV3NCO0lBQUssT0FBQSw0QkFBUDVHO0dBQXlCO1lBRWxDNkcsVUFDaUI3RyxHQUFFOEc7SUFDbkIsSUFDYVIsTUFGSXRHLEdBQUUrRyxRQUFBRDtJQUNuQjtVQURtQkMsT0FDRSxPQUNSVDs7TUFGTVUsUUFBQUQ7Y0FBQUE7TUFFRkU7TUFBRnhIO01BRkU4RyxNQUVKRDtNQUFJWSxPQUFBRDtLQUNqQjtXQURpQkM7TUFJSjtPQUpJQyxPQUFBRDtPQUdmdkcsSUFIZXVHO09BQUpFLGNBQUUzSCxHQUdia0IsT0FMZTRGO09BQUFBLE1BRUphO09BQUlGLE9BQUFDOztTQUFKYixNQUZJQyxLQUFFUSxRQUFBQzs7R0FDK0M7WUFTbEVLLGtCQUFrQnJILEdBQUllLEtBQW1CeUUsTUFBS3JEO0lBQ2hELEdBRHdCcEIsU0FBWUUsTUFBWkYsUUFBQTJGLFlBQVl6RixjQUFaeUY7SUFDckIsT0FyQkdMLElBb0JjckcsR0FBdUJ3RixRQUF2QnhGLFlBQXVCd0YsTUFBS3JELE9BQXhCdUUsWUFBSjFHO0dBQ3FDO1lBRXZEc0gsUUFBUXRILEdBQUllLEtBQW1CeUUsTUFBS3JEO0lBQ3RDLEdBRGNwQixTQUFZRSxNQUFaRixRQUFBMkYsWUFBWXpGLGNBQVp5RjthQUNOYSxLQUFLdkgsR0FBRVAsR0FBRStILElBQUdDO0tBQ2xCLElBRFduQixNQUFBdEcsR0FBTzBILFNBQUFEO0tBQ2xCO1dBRFduQjtPQUVILEdBRlVvQixRQUV3QjtPQUFqQixNQUFBOztVQUNNbkIsTUFIcEJELFFBR1RxQixPQUhTckIsUUFHQ3NCLE1BQVZEO01BQ0csS0FBQSxrQkFKUWxJLEdBR0RtSTtPQUdMLFdBSExELE1BSElKLEtBR3lCaEIsS0FIbEI5RyxHQUFFK0gsSUFBR0U7V0FBQUEsUUFLd0IsV0FMM0JGLElBQVRELEtBR3lCaEIsS0FIbEI5RyxHQUFFK0g7VUFBSmxCLE1BR29CQyxLQUhibUI7O0lBTVk7SUFFaEMsSUFBSSxVQVJJSCxLQURFdkgsR0FBdUJ3RixVQUFBQSxNQUFLckQsT0FBeEJ1RSxnQkFTVjs7O3VCQUEyRCxPQVRyRDFHOzs7R0FTc0Q7WUFFOUQ2SCxPQUFPN0gsR0FBRXdGO2FBQ0grQixLQUFLTyxHQUFFckksR0FBRWdJO0tBQ2YsSUFEV00sTUFBQUQsR0FBSUosU0FBQUQ7S0FDZjtXQURXTTtPQUVILEdBRk9MLFFBRTJCO09BQWpCLE1BQUE7O1VBQ01NLE1BSHBCRCxRQUdUUCxLQUhTTyxRQUdDSCxNQUFWSjtNQUNHLEtBQUEsa0JBSlEvSCxHQUdEbUksTUFDZ0MsV0FEMUNKLElBSElELEtBR3lCUyxLQUhsQnZJLEdBQUVpSTtVQUFKSyxNQUdvQkMsS0FIaEJOOztJQUlrRDtJQUVuRSxJQUFJLFVBTklILEtBREN2SCxHQUFFd0YsVUFPUDs7O3VCQUFnQyxPQVAzQnhGOzs7R0FPNEI7WUFFbkNpSSxJQUNXakksR0FBRXdGO0lBQWYsSUFBYWMsTUFBQXRHO0lBQ1g7VUFEV3NHLEtBRUg7U0FGR0MsTUFBQUQsZ0JBQUFBLFFBR0luRSxrQkFBSjFDO0tBQ04sR0FBQSxrQkFKUStGLE1BR0YvRixJQUNhLFdBRFQwQztTQUhKbUUsTUFBQUM7O0dBTUY7WUFFVDJCLFFBQ1dsSSxHQUREd0Y7SUFDWixJQUFhYyxNQUFBdEc7SUFDWDtVQURXc0csS0FFSCxNQUFBO1NBRkdDLE1BQUFELGdCQUFBQSxRQUdHbkUsa0JBQUgxQztLQUEwQixHQUFBLGtCQUozQitGLE1BSUMvRixJQUErQyxPQUE1QzBDO1NBSEhtRSxNQUFBQzs7R0FLUDtZQUVKNEIsV0FBV25JLEdBQUV3RjtJQUFPLE9BakJwQnlDLElBaUJXakksR0FBZSw0QkFBYndGO0dBQXlCO1lBQ3RDNEMsZUFBZXBJLEdBQUV3RjtJQUFPLE9BVHhCMEMsUUFTZWxJLEdBQW1CLDhCQUFqQndGO0dBQTZCO1lBRTlDNkMsVUFDV3JJLEdBREN3RjtJQUNkLElBQWFjLE1BQUF0RyxHQUFFNkI7SUFDYjtVQURXeUUsS0FFSCxPQUZLekU7U0FBRjBFLE1BQUFELGdCQUFBQSxRQUdHbkUsa0JBQUgxQztLQUNOLEdBQUEsa0JBTE8rRixNQUlEL0Y7TUFDdUIsSUFKckI2SSxZQUdDbkcsT0FIRE4sTUFBRnlFLE1BQUFDLEtBQUUxRSxNQUFBeUc7O1VBQUZoQyxNQUFBQzs7R0FNSjtZQUVQZ0MsaUJBQWlCdkksR0FBRXdGO0lBQU8sT0FUMUI2QyxVQVNpQnJJLEdBQXFCLDhCQUFuQndGO0dBQStCO1lBT2hEZ0QsVUFBVWhEO0lBQU8scUNBQVBBO0dBQWtEO0dBTGxELGlCQUNWTCxrQkFDQUMsbUJBR0FvRDtZQUdGQyxLQUFNQyxHQUFFMUk7O0tBQWMsSUFBYW1DLGtCQUFOcUQ7S0FBb0IsT0FBQSxXQUEzQ2tELEdBQXVCbEQsTUFBTXJEO0lBQTJCO0lBQWxELE9BQUEsaUNBQUpuQztHQUF3RDtZQUVoRTJJLEtBQU1ELEdBQUdFLE1BQUs1STtpQkFDSTZCO0tBQUwsSUFBaUJNLGtCQUFOcUQ7S0FBb0IsT0FBQSxXQUR0Q2tELEdBQ2tCbEQsTUFBTXJELE9BQVpOO0lBQTJDO0lBQS9ELE9BQUEsaUNBRFcrRyxNQUFLNUk7R0FDc0Q7WUFFcEU2SSxPQUFRSCxHQUFFMUk7O0tBQWdCLElBQWFtQyxrQkFBTnFEO0tBQW9CLE9BQUEsV0FBN0NrRCxHQUF5QmxELE1BQU1yRDtJQUEyQjtJQUFwRCxPQUFBLGlDQUFKbkM7R0FBMEQ7WUFFcEU4SSxjQUFnQi9ILEtBQW1CZjtJQUNyQyxHQURrQmUsU0FBYUUsTUFBYkYsUUFBQXhCLGFBQWEwQixjQUFiMUI7SUFDWixJQUFBLFFBL0NKMEksSUE4Q21Dakksb0JBQ1gsVUEvQ3hCaUksSUE4Q21Dakk7Y0FVbkM7O1NBQ1FtQztLQUFXLEdBQUEscUJBQVhBLG9CQUtSOztJQUVtQjtLQUFmNEc7S0FrQ0EsTUEvS0puRCxjQTJIbUM1RjtLQW1CL0JnSjtPQXJCSkg7a0JBdUJZckQ7VUFDTjtXQUFJZ0QsWUFBWSxzQkFEVmhEO1dBRUZ5RCxpQkFMTkY7V0FNRSxVQUZJUDsyQkFDQVM7a0JBTE5GO1VBWVcsY0FBQSxrQkFUSHZEO1VBU0c7OztjQVJMZ0Q7O21CQXRCTWpKO3VCQXdDRiw0QkFuQkZpRzs7c0JBQ0ZnRDtXQWtCSSxrQkFsQkpBLFlBQ0FTLGlCQURBVDs7VUFRSztTQXFCb0I7O0lBR25DLFdBbkNJUTtHQW1DTztZQUVYRSxzQkFBc0JsSixHQUFJLE9BeEQxQjhJLGlCQXdEc0I5SSxHQUFtQjtZQUN6Q21KLHVCQUF1Qm5KLEdBQUksT0F6RDNCOEksbUJBeUR1QjlJLEdBQXFDO1lBRTVEb0osK0JBQW9DcEo7SUFDdEM7S0FDSSxRQTlFRnVJLGlCQTRFb0N2STtLQUdsQyxVQS9FRnVJLGlCQTRFb0N2STtLQUlsQyxVQWhGRnVJLGlCQTRFb0N2STs7Ozs7Ozs7O1VBTVBxSjtlQUFZLHNCQUFaQSxTQUs3Qjs7OztTQUtFQzs2QkFBQUE7O1dBZ0JzQkMsbUJBQVpDO09BQ1QsT0FwQ0hOLHNCQUdvQ2xKO3FDQWdCbENzSixNQWdCc0JDLE1BQVpDOzs7OztNQTVCVjtPQTBCQyxPQWxMQ25ELElBb0pnQ3JHO3FDQWdCbENzSjs7TUFlcUI7OztJQUdsQjtHQUFVO1lBRWZHLGVBQWV6SjtJQUVmO0tBREVnSjtPQWxHRkg7a0JBb0dVckQ7VUFNRCxjQUFBLGtCQU5DQTtVQU1ELHlDQU5DQTtTQVdlO1NBZFZ4RjtJQWlCakIsV0FoQklnSjtHQWdCTztZQUVUVSx3QkFBd0J0SztJQUMxQjtLQUFJdUssU0FBUyxrQ0FEYXZLO0tBRXRCd0ssV0FBUywrQ0FEVEQ7aUJBU21CcEwsR0FBSyxPQUFBLGtCQUFMQSxnQkFBeUI7SUFBNUMsWUFBQSxpQ0FSQXFMO2lCQVNtQnJMLEdBQUssT0FBQSxrQkFBTEEsdUJBQWdDO0lBQW5ELGNBQUEsaUNBVEFxTDt5QkFXZ0I7SUFDYjtHQUFLO1lBRVZDO0lBRUk7S0FGT0M7S0FBOEJDO0tBQU5UO0tBRS9CLFFBQUEsdUNBRk9RO2dCQXNDSDtJQVJGO0tBM0JERTtLQTJCQzs7NkJBM0JEQTs7MkJBNEJjLHNDQS9CZ0JWOzZCQUFNUztpQkFTN0J2RSxNQUFLckQsT0FBTU47S0FDakI7O09BQUcsa0JBREcyRDtZQUNxQixrQkFEckJBO01BaUJDO09BSkRnQjtTQUlDLGtCQWpCRGhCLFFBQUFBLE9BaUJxQyw4QkFqQnJDQTtNQW1CSixlQU5JZ0IsUUFiS3JFLFFBQU1OOztLQVdmLE9BWGVBO0lBbUJLO0lBcEIxQixJQURFb0ksWUFDRixpREFSU0g7SUFxQ1gsV0F4U0F4RSxZQTBRSTJFOztZQWlDSnBLLFVBQVVHO0lBQ1osSUFBSWtLLElBQUksbUNBT04sTUE5U0F2RSxRQXNTVTNGOztLQUdWLElBQVltQyxrQkFBTnFEO0tBQ0gsOEJBSEQwRSxHQUVJMUU7S0FFSCw4QkFKRDBFO0tBS0MsOEJBTERBLEdBRVUvSDtLQUdULE9BQUEsOEJBTEQrSDtJQU00QjtJQUxoQztJQU9BLDhCQVJJQTtJQVFKLE9BQUEsNkJBUklBO0dBU2E7WUFFZnBLLE9BQU9xSyxLQUFJbks7SUFDYixTQUFJb0QsUUFBUStHO1NBQVdoSSxrQkFBTnFEO0tBQWUsT0FBQSwrQkFBcEIyRSxVQUFLM0UsTUFBTXJEOztJQUN2QiwrQkFGU2dJO0lBR3dCLFVBclQvQnhFLFFBa1RXM0Y7SUFHYixrQ0FGSW9ELFNBREsrRztJQUdULE9BQUEsK0JBSFNBO0dBSWU7Ozs7T0E3VHRCOUU7T0FFQUM7T0FHQUc7T0FDQUM7T0FDQUM7T0FDQUM7OztPQWtDSVM7T0FNSkk7T0FDQUU7T0FFQUU7T0FXQVE7T0FHQUM7T0FXQU87T0FTQUk7T0FTQUM7T0FRQUM7T0FDQUM7T0FFQUM7T0FTQUU7O09BVUFFO09BRUFFO09BR0FFO09BRUFDO09Bd0RBSTtPQUNBQztPQUVBQztPQW9DQUs7T0FtQkFDO09BZ0JBRztPQXdDQWhLO09BWUFDOzs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7O1lDblVBc0sseUJBQXlCdEM7SUFDM0I7O0tBQUEsSUFBTSxJQUNKN0IsTUFESSw2QkFEcUI2QjtLQUVoQixRQUFBLDZCQUFUN0I7TUFBc0Msc0JBQXRDQTs7SUFDcUI7R0FBbUI7WUFFeENvRSxZQUFZUDtJQUNSLFlBQUEsaUNBRFFBO2dCQUVOO1FBQ0pRO21CQUFPLE9BUlRGLHlCQVFFRTtJQUljLElBSFZDLGVBR1UsTUFBQSw2QkFKZEQ7SUFJQyxPQUFBLGlDQUhHQztjQVROSCx5QkFRRUU7O0dBTVc7OEJBZGJGLDBCQUtBQzs7O0U7Ozs7Ozs7OztHOzs7Ozs7Ozs7O1lDUEFHLFlBQXNDLFNBQUU7WUFFeENDLEtBQUsvQjtJQUNQLEdBRE9BLE1BRkw4QixNQUtBO0lBQUEsT0FISzlCO0dBS047WUFFQ2dDLFFBQVExSyxHQUFJLE9BQUpBLE1BVFJ3SyxhQVNxQjtZQUNyQkcsUUFBUTNLLEdBQUksV0FEWjBLLFFBQ1ExSyxHQUFtQjtZQUMzQjRLLGFBQWE1SyxHQUFJLE9BQUEsV0FBSkEsTUFBUTtZQUNyQjZLLGdCQUFnQjdLLEdBQUksT0FBSkEsRUFBSzs7O1VBWnJCd0ssTUFFQUMsTUFPQUMsU0FDQUMsU0FDQUMsY0FDQUM7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ0pBQyxPQUFTL0osS0FBMEJ5SSxRQUFPRixNQUFLUztJQUNqRCxHQURXaEo7U0FBVUUsTUFBVkYsUUFBQStJLFVBQVU3STs7U0FBVjZJO0lBQ1gsV0FENENSLE1BQUtTLFFBQVpQLFFBQTFCTTtHQUNzQjtZQUUvQk87UUFBY1A7SUFBZSxPQUFBLGdDQUFmQTs7WUFFZGhLLE9BQU9xSzs7S0FBNEJMO0tBQVJOO0tBQVJPO0tBQU5UO0lBQ2YsT0FBQTs7YUFEU2E7OzthQUFNYjthQUFNUzthQUFRUDs7YUFBUU07OzhCQUxuQ2dCLFFBR0FULGFBRUF2Szs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7WUM2QkFpTCxzQkFFQS9LO0lBRndCLHFCQUV4QkE7O2NBQWdDLHNDQUFoQ0E7R0FBcUU7WUFFckVnTCxRQUVBaEw7SUFGVSxVQUVWQSxnQ0FBQUEsR0FEd0I7SUFDQyxPQUFBLHNDQUF6QkE7R0FBZ0Q7WUFFaERpTCxlQUVBbkY7SUFGaUIsZUFFakJBLGdCQUFNLHNDQUFOQTtHQUEwQztZQUUxQ29GLFFBRUFwRjtJQUZVLGVBRVZBLGdCQUFNLHNDQUFOQTtHQUFtQztZQUVuQ3FGLGlCQUVBbkw7SUFGbUIsVUFFbkJBLGdDQUFBQSxHQUR3QjtJQUNDLE9BQUEsc0NBQXpCQTtHQUF5RDtZQUV6RG9MLGNBRUFwTDtJQUZnQixVQUVoQkEsZ0NBQUFBLEdBRHdCO0lBQ0MsT0FBQSxzQ0FBekJBO0dBQXNEO1lBRXREcUwsZUFFQXJMO0lBRmlCLFVBRWpCQSxnQ0FBQUEsR0FEd0I7SUFDQyxPQUFBLHNDQUF6QkE7R0FBdUQ7WUFFdkRzTCxnQkFFQXRMO0lBRmtCLFVBRWxCQSxnQ0FBQUEsR0FEd0I7SUFDQyxPQUFBLHNDQUF6QkE7R0FBd0Q7WUFFeER1TCxnQkFFQXZMO0lBRmtCLFVBRWxCQSxnQ0FBQUEsR0FEd0I7SUFDQyxPQUFBLHNDQUF6QkE7R0FBd0Q7WUFFeER3TCxTQUVBeEw7SUFGVyxVQUVYQSxnQ0FBQUEsR0FEd0I7SUFDQyxPQUFBLHVDQUF6QkE7R0FBaUQ7WUFFakRILFVBRUFHO0lBRlksVUFFWkEsZ0NBQUFBLEdBRHdCO0lBQ0MsT0FBQSx1Q0FBekJBO0dBQWtEO1lBRWxEeUwsVUFBVWxOLEdBQUksT0FoQ2QyTSxRQWdDc0IsMkJBQVozTSxJQUE2QjtZQUN2Q3VCLE9BQU9xSyxLQUFJbks7SUFBNEIsVUF6Q3ZDZ0wsUUF5Q1doTDtJQUE0QixPQUFBLCtCQUFoQ21LO0dBQTJDOzs7O09BN0NsRFk7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQTNMO09BSUE0TDtPQUNBM0w7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUMvRUFnTCxPQUFTL0osS0FBeUIySztJQUFTLEdBQWxDM0s7U0FBVUUsTUFBVkYsUUFBQStJLFVBQVU3STs7U0FBVjZJO0lBQWtDLFdBQVQ0QixRQUF6QjVCO0dBQXFEO1lBRTlETyxZQUFhc0I7UUFBaUI3QjtJQUNoQyxxQkFEZTZCOztjQUdjLGdDQUhHN0I7O1lBSzlCaEssT0FBT3FLOztLQUFjTDtLQUFSNEI7S0FDWEU7Y0FEV0Y7VUFHbUIsK0JBSG5CQTs7SUFNZixPQUFBOzthQU5TdkI7OzthQUFNdUI7YUFDWEU7O2FBRG1COUI7OytCQVByQmdCLFFBRUFULGFBS0F2Szs7O0U7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDSkErTCxhQUFhN0wsR0FBRVA7SUFDakIsU0FBSXFNLFlBQVk5TCxHQUFFK0wsR0FBSSxPQUF0Qix1QkFBZ0IvTCxHQUFFK0wsU0FBK0I7SUFBN0NELFlBRFc5TCxHQUFFUDtJQUNicU0sWUFEVzlMLEdBQUVQO0lBR2pCLE9BRklxTSxZQURXOUwsR0FBRVA7R0FJRjtZQUVidU0sbUJBQW1CaE0sR0FBRWlNO0lBQ3ZCO0tBQThDQyxhQUR2QkQ7S0FDWUUsWUFEWkY7S0FDS0csUUFETEg7S0FDakJJLGlCQURpQko7SUFOckJKLGFBTW1CN0wsR0FDZnFNO0lBRVEsV0FBQSxpQ0FGZ0NIO0lBRTlDLHVCQUhxQmxNO0lBSXJCLHVCQUpxQkEsR0FDT29NO0lBRzVCLE9BQUEsMEJBSnFCcE0sR0FDY21NO0dBSVI7WUFFekJHLHlCQUF5QnRNLEdBQUV1TSxNQUFLTCxZQUFXTSxRQUFPQztJQUNwRCxTQUNLLDJCQUZ3QkY7S0FLdkI7TUFERUcsYUFKcUNGLFFBQWhCRCxTQUFBQSxTQUFLTDtNQUN0QlMsV0FEd0NGO01BQ2hERyxXQUdJRjs7S0FTYTtNQUFiRyxhQUFhLDJCQWJRTjtNQUNqQk87aUJBYUk5TTtTQUNWLHVCQURVQSxHQURSNk07U0FHRixXQWhCOENKLFFBY3BDek07d0NBQUFBLFlBRFI2TSxhQWJxQk47UUFpQmlDO2FBakJqQ0E7TUFDekJROztVQUR5Q1AsU0FhckNLO1NBUVEsK0JBckJhTjs7U0FBS0w7TUFDdEJTLFdBQUFHO01BQVJGLFdBQUFHO0lBUkZmLG1CQU95QmhNLEdBQ3ZCNE07SUEyQkosT0FBQSxXQTNCWUQsVUFEZTNNO0dBNkJuQjtZQUVOZ04saUJBQWlCaE4sR0FBR2lOLEtBQUtoSCxLQUFJc0csTUFBS1c7YUFDaENULE9BQU96TSxHQUFJLE9BQWYsdUJBQVdBLEdBRFdpTixLQUFLaEgsS0FBU2lILE1BQ1E7SUFDNUMsR0FGMkJqSDtTQUVNa0gsUUFGTmxILFFBRXZCdUcsU0FBNkJXOztTQUE3QlgsK0JBRmdDVTtJQUdwQyxPQWxDRVoseUJBK0JpQnRNLEdBQVl1TSxTQUUzQkMsUUFEQUM7R0FFOEM7WUFFaERXLG9CQUFvQnBOLEdBQUV1TSxNQUFNVSxLQUFLaEgsS0FBSW9IO2FBQ25DWixPQUFPek0sR0FBSSxPQUFmLHdCQUFXQSxHQURtQmlOLEtBQUtoSCxLQUFJb0gsTUFDVztJQUNsRCxHQUZtQ3BIO1NBR2JrSCxRQUhhbEgsUUFFL0J1RyxTQUNrQlc7O1NBRGxCWCxTQUN1QywyQkFISmE7SUFLdkMsT0F6Q0VmLHlCQW9Db0J0TSxHQUFFdU0sU0FFcEJDLFFBREFDO0dBSThDO1lBRWhEYSxlQUFldE47SUFDakI7S0FENER1TjtLQUFuQkM7S0FBcEJDO0tBQ2pCQztPQURpQkQ7VUFHZCxpQ0FIa0NEO1VBQUFBO0lBTXpDLDBCQU5pQnhOLEdBQ2IwTjtJQUtKLE9BQUEsdUJBTmlCMU4sR0FBMkN1Tjs7WUFlMURJLHdCQUNXM04sR0FBRThCLFdBQVU4TDtJQUF6QixJQUdJQyxjQUhXL0wsV0FBVWdNLFdBQUFGO0lBQ3ZCO2NBRUVDLGVBSHFCQzs7T0FBQUMsV0FBQUQ7ZUFBQUE7T0FHVzdIO09BQUxnSDtPQUFkZTtTQUFiSCxjQUFnQzVIO09BRTNCLE9BQUEsd0JBTElqRyxPQUdrQmlOLFVBQTNCWSxjQUFhRztNQUlYLHdCQVBPaE8sT0FHa0JpTixVQUFLaEgsTUFBbkIrSDs7T0FIRkMsY0FHWEosY0FBZ0M1SDtPQUFoQzRILGNBSFdJO09BQVVILFdBQUFDOzs7S0FFTDs7R0FRSDtZQUVmRyxvQkFBb0JsTyxHQUFFdU0sTUFBTTRCLFVBQVVsSSxLQUFJMkg7SUFDNUMsR0FEd0MzSDtTQUNWa0gsUUFEVWxILFFBQ3BDbUksUUFBMEJqQjs7U0FBMUJpQixRQUErQyxzQ0FEUFI7T0FBZE87O01BTXhCMUIsa0JBQU96TSxHQUFJLE9BbkJmMk4sd0JBbUJXM04sR0FMVG9PLE9BRHdDUixRQU1VO0tBQ3BELE9BOUVBdEIseUJBdUVvQnRNLEdBQUV1TSxTQUNwQjZCLE9BS0UzQjs7SUFNSjtLQUFJSixpQkFYRitCO1lBRG9CN0I7WUFBQUE7WUFBQUE7S0FhbEI4QixhQUE0QiwrQkFiVjlCO2FBY2xCSSxTQUFPM007S0ExQ1hzTixlQTBDV3ROLEdBZGlCbU87S0FjNUIsT0EzQkFSLHdCQTJCVzNOLEdBYlRvTyxPQUR3Q1I7SUFnQkg7SUFFdkMsT0F6RkF0Qix5QkF1RW9CdE0sR0FhaEJxTyxXQURBaEMsZ0JBRUFNO0dBSTBEO1lBRTlEMkIscUJBQXFCdE8sR0FBRXVNLE1BQUs0QjtJQUU1QixJQURFekIsZ0JBRHFCSCxTQUFBQTtJQWxHdkJQLG1CQWtHcUJoTSxHQUNuQjBNO0lBVUosT0EzREVZLGVBZ0RxQnROLEdBQU9tTztHQVlMO1lBRXZCSSx1QkFBdUJ2TyxHQUFFdU0sTUFBS3hKO0lBRTlCLElBREUySixnQkFEdUJILFNBQUFBO0lBaEh6QlAsbUJBZ0h1QmhNLEdBQ3JCME07SUFZYyxXQUFBLG1DQWJjM0o7SUFhZCxPQUFBLDBCQWJPL0M7R0FhaUI7WUFFeEN3TyxxQkFBcUJ4TyxHQUFFdU0sTUFBS3ZMO0lBQzlCO1lBRHlCdUw7WUFBQUE7S0FDckJHLGFBUWlCLDJCQVRTMUw7SUEvSDVCZ0wsbUJBK0hxQmhNLEdBQ25CME07SUFZSixPQUFBLGlDQWJ1QjFNLEdBQU9nQjtHQWNZO1lBRXhDeU4seUJBQXlCek8sR0FBRXVNLE1BQU1tQyxhQUFhekksS0FBSTJIO0lBQ3BELEdBRGdEM0g7U0FDbEJrSCxRQURrQmxILFFBQzVDbUksUUFBMEJqQjs7U0FBMUJpQixRQUErQyxzQ0FEQ1I7UUFFaER2QixxQkFEQStCO2FBUUEzQixPQUFPek07S0FDVCwwQkFEU0EsR0FUd0IwTztLQVNuQyxPQXZGRWYsd0JBdUZTM04sR0FSUG9PLE9BRGdEUjtJQVdiO0lBRXZDLE9BckpFdEIseUJBd0l5QnRNLEdBQUV1TSxTQUV6QkYsZ0JBT0FJO0dBSTZEO0dBTXRELElBQVBrQyx1QkFBTywrQkFDWG5ROztJQUNFLHNCQUZFbVEsc0JBQ0puUTtJQUNFLFVBREZBO2FBQUFBO1FBQUFBOztZQUtFb1EsaUJBQWlCNU8sR0FBRXVNLE1BQU94TCxLQUFTOE47SUFJckMsR0FKNEI5TixTQUFNRSxNQUFORixRQUFBa00sTUFBTWhNLGNBQU5nTTtJQU0xQixJQURFUCxnQkFMaUJILFNBQUFBO0lBeEtuQlAsbUJBd0tpQmhNLEdBS2YwTTtJQU9KLE9BQUEsd0JBWm1CMU0sT0FBU2lOLGNBQVM0QjtHQWFnQjtZQUVuREMsb0JBQW9COU8sR0FBRXVNLE1BQUtKLFdBQVU0QyxZQUFXQztJQUNsRDtLQUFJQyxpQkFBaUIsMkJBRDZCRDtLQUU5Q3RDLGlCQURBdUMsb0JBRG9CMUMsU0FBQUE7SUF2THRCUCxtQkF1TG9CaE0sR0FFbEIwTTtJQVlKLDBCQWRzQjFNLEdBQU9tTTtJQWVYLFdBQUEsbUNBZnFCNEM7SUFldkMsMEJBZnNCL087SUFldEIsT0FBQSx3QkFmc0JBLFlBQ2xCaVAsaUJBRDhDRDtHQWdCUTtZQUV4REUsMEJBQTBCbFAsR0FBRXVNLE1BQUs0QztJQUVqQyxJQURFekMsZ0JBRDBCSCxTQUFBQTtJQXpNNUJQLG1CQXlNMEJoTSxHQUN4QjBNO0lBYUosT0FBQSwwQkFkNEIxTSxHQUFPbVA7R0FlTjtZQUUzQkMseUJBQXlCcFAsR0FBRXVNLE1BQU10RyxLQUFJMkg7SUFDdkMsR0FEbUMzSDtTQUNMa0gsUUFES2xILFFBQy9CbUksUUFBMEJqQjs7U0FBMUJpQixRQUErQyxzQ0FEWlI7SUFHckMsSUFERWxCLGFBREEwQixPQUR5QjdCLFNBQUFBO0lBMU4zQlAsbUJBME55QmhNLEdBRXZCME07SUFPSixPQWxLRWlCLHdCQXlKeUIzTixHQUN2Qm9PLE9BRG1DUjtHQVVGO1lBRW5DeUIsb0JBQW9CclAsR0FBR3NQLE1BQUsvQyxNQUFLc0M7SUFDbkM7S0FBSXhDLGlCQUFpQiwyQkFEY3dDO0tBRS9CbkMsYUFEQUwsZ0JBRDBCRSxTQUFBQSxhQUFMK0M7SUF0T3ZCdEQsbUJBc09vQmhNLEdBRWxCME07SUFPSixPQUFBLHdCQVRzQjFNLFlBQ2xCcU0saUJBRCtCd0M7R0FVb0I7WUFFckRVLHlCQUF5QnZQO0lBTzNCLE9BQUEsdUJBUDJCQTtHQU9ZO1lBaUJuQzhLLE9BQU8wRTtJQUNUO0tBQUl4QixTQUFTLDJCQURKd0I7S0FFTEMsVUFBVSx1QkFEVnpCO0lBRUosV0FGSUEsUUFDQXlCO0dBQ2dFO1lBRWxFeE0sUUFBUWpELEdBQUksT0FBSkEsS0FBYTtZQUVyQjBQLGdCQUNFM08saUJBR0ZvTDtJQUVGLEdBTElwTDtTQUFVRSxNQUFWRixRQUFBNE8sVUFBVTFPOztTQUFWME87SUFLSjtTQUpZQyxpQkFBUnhELFFBQVF3RDs7U0FBUnhEO0lBSUo7U0FIcUJ5RCxpQkFBakJDLGlCQUFpQkQ7O1NBQWpCQztJQUdKLFdBSkkxRCxPQUVGRCxXQUhFd0QsU0FFQUc7R0FHNkQ7WUFFL0RDLDJCQUF5Qi9QLEdBQUVzQjtJQXZDN0JpTyx5QkF1QzJCdlA7SUFFVixJQUFiZ1EsYUFWRk47SUFjRixPQWhLQWxCLHFCQTBKMkJ4TyxNQUV2QmdRLFlBRnlCMU87R0FNMEI7WUFFckQyTyxrQkFBb0JsUCxLQUFVMkgsR0FBRXNILFlBQVdFO0lBQzdDLEdBRHNCblAsU0FBTUUsTUFBTkYsUUFBQWtNLE1BQU1oTSxjQUFOZ007SUFDdEIsSUFBTWtELG9CQUQ0Qkg7T0FDNUJHLHFCQUR1Q0Q7S0FrQnhDLE9BQUEsV0FsQjJCeEgsR0FBVnVFLEtBQXVCaUQsY0FBWEY7UUFJbEJJLFFBSk1uRCxLQUlGbkwsWUFKeUJvTztJQUt6QztRQUpFQyxxQkFHY3JPO3dCQUpZNEcsR0FJaEIwSCxPQUFJdE8sV0FKY2tPO0tBVzFCO1lBWDBCQTtZQUFBQTthQUFBQTtNQVV4Qks7WUFDd0IsOEJBWEFMO0tBYTVCLFdBYjBCdEgsR0FJaEIwSCxPQUhWRCxtQkFTSUU7O01BTlV4QyxjQUFBL0wsWUFIZHFPO01BR1VHLFFBQUFGLFFBSFZEO01BR1VDLFFBQUFFO01BQUl4TyxZQUFBK0w7O0dBY29CO1lBRXRDMEMsV0FBV3ZRLEdBQUVnUSxZQUFZL0MsS0FBS2hILEtBQUl1SztJQUM3QixjQUFBLHdCQURNeFE7Y0FDTjtPQUR5QmlHO1NBSVJrSCxRQUpRbEgsUUFHMUJpSyxlQUNrQi9DOztTQURsQitDLHFDQUg4Qk07SUFNbEMsT0ExQkFQO2FBb0J5QmhEO3NCQVVkQSxLQUFLaEgsS0FBSStKO2NBQ2hCLE9BMVJOaEQ7dUJBK1FhaE4sVUFVQWlOLFVBQUtoSCxNQUFJK0osWUFWY1E7YUFXcUI7YUFYMUNSO2FBR1RFO0dBUW9EO1lBRXhETyxjQUFjelEsR0FBRWdRLFlBQVkvQyxLQUFLaEgsS0FBSW9IO0lBQ2hDLGNBQUEsd0JBRFNyTjtjQUNUO09BRDRCaUc7U0FJWGtILFFBSldsSCxRQUc3QmlLLGVBQ2tCL0M7O1NBRGxCK0MsZUFDdUMsMkJBSk43QztJQU1yQyxPQXZDQTRDO2FBaUM0QmhEO3NCQVVqQkEsS0FBS2hILEtBQUkrSjtjQUNoQixPQWxTTjVDO3VCQXVSZ0JwTixNQVVNZ1EsZ0JBQVQvQyxVQUFLaEgsTUFWcUJvSDthQVdzQjthQVgzQzJDO2FBR1pFO0dBUXdEO1lBSTVEUTtJQUNBMVEsR0FDQWdRLFlBQ0VqUCxLQUNBNFAsYUFFRjFOO0lBRUYsR0FMSWxDLFNBQWVFLE1BQWZGLFFBQUE2UCxlQUFlM1AsY0FBZjJQO0lBS2E7S0FBYkMsYUFBYSx3QkFGZjVOO0tBR0VpTixlQU5BVSxlQUtBQyxxQkFBQUE7S0FTRVYsb0JBZkpIO09BZUlHLHFCQVJGRDtLQXVEQTtZQTlERkY7WUFBQUE7WUFBQUE7TUE2REljO1lBQ3dCLDhCQTlENUJkOztpQkFpRWtDcEM7U0FDbkIsSUFBTjNILE1BQU0sc0NBRG1CMkg7U0FFN0IsV0FqRUgrQyxhQUhGM1EsTUE4REk4USxrQkFLSzdLLE1BRHlCMkg7U0FHN0Isa0JBRkkzSDtRQUVHO0tBSFYsd0JBN0RGaEQ7S0E2REU7OztLQS9DRThOO09BakJGSCxlQWNFVCw0QkFBQUE7aUJBTzhCdkM7S0FDN0IsV0FyQkgrQyxhQUhGM1EsTUFDQWdRLGdCQWtCSWUsb0JBSThCbkQ7S0FFN0Isa0JBTkRtRDtJQU1zQjtJQUZ4Qix3QkFsQkY5Tjs7S0FxQmFnTCxjQW5CWDRDLGFBWUVFO0tBT1NqUCxZQUFBbU07SUFDWDtRQVhFa0MscUJBVVNyTztNQXVCUDthQWhETmtPO2FBQUFBO2FBQUFBO09BK0NRZ0I7YUFDK0I7O2tCQUdEcEQ7VUE1S3hDd0IseUJBd0hFcFAsTUFnRFFnUixrQkF0QktsUCxZQTBCeUI4TDtVQU03QixrQkFoQ0k5TDtTQWdDUztNQU5oQix3QkEvQ05tQjtNQStDTTs7S0FmZTtNQUFib047K0JBcENSTCxlQUFBQSxlQUFBQTs7aUJBb0NRQTtVLGdCQUU4QnBDO1dBL0p4Q3dCO2FBd0hFcFAsTUFxQ1FnUSxnQkFyQkpHLG9CQXVCa0N2QztXQU03QixrQkE3Qkx1QyxtQkE2QjBCOztVQVJ0QkU7S0FFRix3QkFsQ05wTjs7TUFxQmE0SyxjQUFBL0wsWUFWVHFPO01BVVNyTyxZQUFBK0w7O0dBMkNDO1lBRWRvRCxlQUFlQyxlQUFjak8sU0FBUTZHO0lBR3JDLFVBQUEsZ0NBSHFDQTtpQkFFaEM0QztLQUFVLE9BQUE7dUNBRkF3RSxlQUFjak8sU0FFeEJ5SjtJQUFrRTtJQUN2RSxPQUFBO0dBQStCO1lBRS9CeUU7SUFBeUJuUixHQUFFa1IsZUFBZVAsYUFBWVgsWUFBV29CO0lBQ25FO0tBQW9DdEgsVUFEK0JzSDtLQUN2QzVILFNBRHVDNEg7S0FDL0NySCxTQUQrQ3FIO0tBQzdEOUgsT0FENkQ4SDtLQUUvRG5PLFVBQVU7S0FJWixzQkFDVSxzQ0FOTnFHO0lBRU4sb0NBSDZCNEgsZUFFekJqTztxQkFERXFHO0tBYUo7O09BZDJCNEg7T0FFekJqTztxQkFEZ0I4RztLQWlCbEI7O09BbEIyQm1IO09BRXpCak87dUJBRHdCdUc7O0lBTjFCeUgsZUFLMkJDLGVBRXpCak8sU0FEZ0M2RztJQXFCcEMsT0FuR0U0RzthQTZFeUIxUSxHQUE2QmdRLGVBQVpXLGFBRXhDMU47R0FxQjBEO1lBRTVEb087SUFBc0JyUixHQUFFa1IsZUFBZS9DLFVBQVM2QixZQUFXb0I7SUFDdEQsY0FBQSx3QkFEaUJwUjtjQUNqQjthQUVEMlE7S0FBYztNQUFsQjtPLE9BNVdGekMsOEJBeVd5Q0M7O0lBSXZDLE9BN0JBZ0Q7YUF5QnNCblIsR0FBRWtSLGVBR3BCUCxhQUg0Q1gsWUFBV29CO0dBSWE7WUFFeEVFO0lBQW1CdFIsR0FBRWtSLGVBQWNsQixZQUFZdEIsYUFBWTBDO0lBQ3RELGNBQUEsd0JBRGNwUjtjQUNkO2FBRUQyUTtLQUFjO01BQWxCO08sT0FqVEZsQyxtQ0E4U2lEQzs7SUFJL0MsT0FuQ0F5QzthQStCbUJuUixHQUFFa1IsZUFHakJQLGFBSCtCWCxZQUF3Qm9CO0dBSWE7WUFFeEVHLHVCQUF1QnZSLEdBQUVrUixlQUFjbEIsWUFBV3dCO0lBQzdDLGNBQUEsd0JBRGtCeFI7Y0FDbEI7SUFHUztLQURTOEosVUFIMkIwSDtLQUc1QzlGLFNBSDRDOEY7S0FJOUN2TyxVQUFVO0tBU1osc0JBQ1UsZ0NBWE55STtJQU9OLG9DQVZ5QndGLGVBSXJCak87SUE5Q0pnTyxlQTBDeUJDLGVBSXJCak8sU0FEbUI2Rzs7SUFjdkIsT0FuSUE0RzthQWtIdUIxUTthQUFnQmdROzs7Y0FxQnhCO2U7Z0IsT0ExWWpCOUI7O2FBeVhNakw7R0FtQk07WUFFVndPLHdCQUF3QnpSLEdBQUVrUixlQUFjbEIsWUFBVzBCO0lBQzlDLGNBQUEsd0JBRG1CMVI7Y0FDbkI7SUFFUyxJQUFWaUQsVUFBVTtJQXRFZGdPLGVBbUUwQkMsZUFHdEJqTyxTQUgrQ3lPOztJQVFuRCxPQW5KQWhCO2FBMkl3QjFRO2FBQWdCZ1E7OztjQVl6QjtlO2dCLE9BMVpqQjlCOzthQWlaTWpMO0dBV007WUFFVjBPLGlCQUFpQjNSLEdBQUVnUSxZQUFXak47SUFDekIsY0FBQSx3QkFEWS9DO2lCQTVYbkJ1Tyx1QkE0WG1Cdk8sTUFBRWdRLFlBQVdqTjtHQUVrQjtZQUVoRDZPLG9CQUFvQjVSLEdBQUVnUSxZQUFXdlE7SUFDNUIsY0FBQSx3QkFEZU87aUJBdlN0QmtQLDBCQXVTc0JsUCxNQUFFZ1EsWUFBV3ZRO0dBRWtCO1lBRW5Eb1MsZ0JBQWdCN1IsR0FBR2lHLEtBQUkrSixZQUFXcEM7SUFDN0IsY0FBQSx3QkFEVzVOOztjQW5OaEJpUTs7d0JBdU4wQ2hELEtBQUtoSCxLQUFJK0o7Z0JBTS9CO2lCQVBEbEMsV0FPQyxzQ0FWY0YsUUFJUVg7NkJBRC9Cak47aUJBQWlCLE9BdGI5QjJOLHdCQXNiYTNOLEdBQ29DaUcsS0FENUI2SDs7Z0JBT2YsT0F2Zk54Qix5QkE2ZWtCdE0sTUFJbUNnUSxlQUFKL0o7ZUFNSTtlQVY1QitKO2VBQUovSjs7R0FVaUM7WUFFcEQ2TCxpQkFBZTlSLEdBQUVnUSxZQUFXN0I7SUFDdkIsY0FBQSx3QkFEVW5PO2lCQTlaakJzTyxxQkE4WmlCdE8sTUFBRWdRLFlBQVc3QjtHQUV5QjtZQUVyRDRELGVBQWUvUixHQUFFZ1EsWUFBV2hQO0lBQ3ZCLGNBQUEsd0JBRFVoQjtpQkFyWWpCd08scUJBcVlpQnhPLE1BQUVnUSxZQUFXaFA7R0FFeUI7WUFFckRnUixXQUFXaFMsR0FBRWdRLFlBQVkvQyxLQUFJNEI7SUFDeEIsY0FBQSx3QkFETTdPO2lCQWhXYjRPLGlCQWdXYTVPLE1BQUVnUSxZQUFZL0MsS0FBSTRCO0dBRXdCO1lBRXJEb0QsY0FBY2pTLEdBQUVnUSxZQUFZaEIsWUFBWWtELGdCQUFlQztJQUNsRCxjQUFBLHdCQURTblM7O2NBclZoQjhPO2VBcVZnQjlPLE1BQUVnUSxZQUF3QmtDLGdCQUFlQyxPQUEzQm5EOztHQUc0QztZQUV4RW9ELGlCQUFpQnBTLEdBQUUrQjtJQUNyQixPQUFHLHdCQURnQi9CO2NBRWQ7Y0FDRzs0Q0FIV0E7Z0JBSWQ7aUJBSmNBLE9BS0YsdUNBTEkrQjtHQUtpQjtZQUVwQ3NRLE9BQU9yUztJQUNULElBQUkwSSxJQURLMUk7SUFBQUE7SUFHVCxPQUFBLHVDQUZJMEk7R0FFeUI7WUFFM0I0SixNQUFNdFMsR0FBRTBJLEdBQUksT0FBQSx3QkFBTjFJLE1BQUUwSSxHQUFxQjtZQUU3QjZKLFFBQVF2UyxHQUdWLE9BTEVzUyxNQUVRdFMsbUJBR1MsU0FBRSxHQUFDO1lBRXBCd1MsUUFBTXhTLEdBQUksK0JBQUpBLE1BQTJCO1lBQ2pDeVMsTUFBTXpTLEdBQUksK0JBQUpBLE1BQTJCO1lBRWpDMFMsZ0JBQWdCMVM7SUFDbEIsd0JBRGtCQTtJQUVKLElBQVYyUyxVQUFVLHdCQUZJM1M7SUFBQUEsT0FBQUEsT0FFZDJTOztHQUN3QztZQUUxQ0MsVUFBVTVTLEdBQUksK0JBQUpBLE1BQStCO1lBQ3pDNlMsY0FBYzdTLEdBQUksT0FBSkEsS0FBbUI7WUFFakM4UyxjQUFjOVMsR0FBRStTO0lBQ2xCLFVBRGtCQSxxQkFFTCxPQVZYTCxnQkFRYzFTO1FBR1ZpRyxNQUhZOE07SUFHTCxPQUFBLHdCQUhHL1MsTUFHVmlHO0dBQTBCO1lBRTlCK00sS0FBS2hUO0lBQ0QsWUFBQSx3QkFEQ0E7OzJEQUFBQTtRQUlHNE47SUFBVSx1QkFBVkE7R0FBdUI7R0E3VHJCO0lBQUE7O09BZVY5QztPQUtBN0g7T0FFQXlNO09BUUFLO09BUUFFO09Bb0JBTTtPQWFBRTtPQWVBQztPQXdFQU87T0FLQUU7T0F5QkFFO09BTUFDO09BTUFDO09BeUJBRTtPQWdCQUU7T0FJQUM7T0FJQUM7T0FZQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FLQUc7T0FPQUM7T0FLQUM7T0FFQUM7T0FLQUM7T0FDQUM7T0FFQUM7T0FLQUU7T0FDQUM7T0FFQUM7T0FLQUU7OztPQTFqQkZuSDtPQU1BRztPQU9BTTtPQStCQVU7T0FLQUk7T0FPQUU7T0FlQUs7T0FhQU87T0FvQkFJO09BY0FDO09BZUFDO09BZ0JBQztPQW1CRUU7T0FNRkM7T0FlQUU7T0FrQkFJO09BaUJBRTtPQVlBQztPQVlBRTs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7SUMvS0EwRDtZQUVBbkksT0FBT3hMLElBQUl3USxnQkFBZXJELFFBQU95RyxlQUFjQztJQUNqRCxXQURTN1QsSUFBbUJtTixRQUFPeUcscUJBQXRCcEQsZ0JBQW9DcUQ7R0FVaEQ7WUFFQzdULGNBQUtBLGVBQVUsT0FBVkE7WUFDTDhULFFBQVFwVCxHQUFJLGNBQUpBLDBCQUFnRDtZQUN4RHFULFFBQVFyVDtJQUFJLFVBQUpBO21FQUE2QztJQUFZO0dBQUs7WUFFdEVzVCxjQUFjdFQsR0FBRTRMO0lBQ2xCLFVBRGdCNUw7OztxREFDWnVUO1NBQUFBOztJQUNTLElBQVRDLGFBRmM1SCxRQWxCaEJxSDtJQXFCRixXQUhnQmpULE1BQ1p1VCxRQUNBQztJQUZZeFQsV0FFWndUOztHQUVvQjtZQUV0QnpFLFdBQVcvTztJQUNiLFlBRGFBO2tDQUlDOzJCQUZSeVQsZ0JBQU8sd0JBQVBBO1FBQ0l0QjtJQUFjLFdBQWRBO0dBQ1E7WUFFaEJ1QixjQUFjdkIsT0FBTXBEO0lBQ3RCLFVBRGdCb0Qsa0NBQUFBLGNBRVRzQixNQUZTdEIsVUFFRixXQUFQc0I7SUFDVSxXQUhEdEIsT0FBTXBEO0dBRytCO1lBRW5ENEUsYUFBYTNULEdBQUUrTztJQUNBLElBQWJpQixhQUFhLCtDQURGaFE7SUFFZix1Q0FGZUEsTUFDWGdRLFlBRGFqQjtJQUdELE9BcEJkdUUsY0FpQmF0VCxPQUFFK087R0FHcUI7Ozs7T0F0Q3BDa0U7T0FFQW5JO09BWUF4TDtPQUNBOFQ7T0FDQUM7T0FFQUM7T0FNQXZFO09BTUEyRTtPQUtBQzs7O0U7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7OztZQzdHRUMsNEJBQXFELFNBQUU7WUFDdkRDLHNCQUFnRCxTQUFFO1lBQ2xEQyxpQ0FBOEQsU0FBRTtZQUVoRWhKLE9BQU9rRCxRQUFRK0Y7SUFDakI7WUFBWSx1QkFESC9GOztZQUhQNkY7WUFDQUM7O1lBRWVDO0dBT2hCO1lBRUNDO0lBQ00sSUFBSmhVLElBVkY4Syx1QkFKQThJO0lBZUYsd0JBREk1VDtJQUNKLE9BRElBO0dBRUg7R0FFUyxJQUFScUYsUUFMQTJPO1lBTUFwQixVQUFVNVMsR0FBSSwrQkFBSkEsTUFBK0I7WUFDekNpVSxlQUFlalUsR0FBSSxPQUFKQSxLQUFhO1lBRXhCa1UsMkJBQWdCbFUsR0FBRW1VLFFBQU9DO0lBQ3pCLFlBQUEsd0JBRGdCcFU7Ozs7Z0JBQUFBOzs7ZUFBQUEsT0FyQnBCNlQ7ZUFxQm9CN1QsT0FwQnBCOFQ7ZUEyQkEsV0FQc0JLOzs7S0FRUixNQUFBO1FBQ0xFO0lBVFdyVTtJQUFBQSxPQXJCcEI2VDtJQXFCb0I3VCxPQXBCcEI4VDtRQWlDZ0M3TixNQUp2Qm9PLFVBSWtCcEgsTUFKbEJvSCxVQUlIckcsU0FKR3FHO0lBS1Qsd0JBZG9CclUsTUFhWWlHO0lBRWhDLFdBZjZCbU8sU0FhdkJwRyxRQUFxQmYsS0FBS2hIO0lBS2hDLFdBbEJvQmpHLE1BYVlpRztJQUtoQyxrQkFBQSxPQUFBLHVCQUdBcU8sb0JBckJvQnRVOztJQWtCcEIsT0FHQXNVLDBCQXJCb0J0VTtHQW1CTjtZQUVkc1Usd0JBQWF0VTtJQUNmLFVBRGVBOztjQUFBQSxZQUFBQTs7bUNBckJUa1UsdUJBcUJTbFU7O1dBckJUa1UsNkJBcUJTbFU7R0FDOEM7WUF0QnZEdVUsZ0JBQWdCdlUsR0FBRW1VLFFBQU9DO0ksdUJBQXpCRixxQkFBZ0JsVSxHQUFFbVUsUUFBT0M7O1lBcUI3QkksYUFBYXhVLEcsdUJBQWJzVSxrQkFBYXRVO1lBR2J5VSxjQUFjelUsR0FBR21VLFFBQVFDO0lBQzNCLEdBRGdCcFUsTUFFWDtJQUNGLE9BOUJENFMsVUEyQmM1UztjQXhCVnVVLGdCQXdCVXZVLEdBQUdtVSxRQUFRQztlQUFYcFUsVUFBQUEsT0FBR21VLFFBQUhuVSxPQUFXb1U7R0FRSjtZQUVyQjNCLE1BQU16UyxHQUNSLHdCQURRQSxPQUNSLE9BZEV3VSxhQWFNeFUsR0FFTTtZQUVaMFUsbUJBQW1CMVUsR0FBSSwrQkFBSkEsTUFBd0M7R0F0RWpEOzs7T0FVVjRUO09BQ0FDO09BQ0FDO09BRUFoSjtPQVNBa0o7T0FLQTNPO09BQ0F1TjtPQUNBcUI7T0FFSU07T0FxQkpDO09BR0FDO09BVUFoQztPQUlBaUM7WUFZQUMsU0FBTzNHLFFBQVF2QjtJQUNqQixXQUFZLHVCQURIdUIsaUJBQVF2QjtHQUN3RDtZQUV2RW1JLGVBQWNuSTtJQUNSLElBQUp6TSxJQUpGMlUseUJBR2NsSTtJQUVoQix3QkFESXpNO0lBQ0osT0FESUE7R0FFSDtZQUVDNlUsZUFBZTdVO0lBQUksOENBQUpBO0dBQW9DO1lBRW5EOFUsV0FBVzlVLEdBQUU4RjtJQUNmLHVCQURhOUYsTUFBRThGO0lBQ2YsT0FIRStPLGVBRVc3VTtHQUVHO1lBRWQrVSxhQUFhL1UsR0FBR2lOLEtBQUtoSCxLQUFJNkI7SUFDM0IsdUJBRGU5SCxNQUFHaU4sS0FBS2hILEtBQUk2QjtJQUMzQixPQVBFK00sZUFNYTdVO0dBRUM7WUFFZGdWLGdCQUFnQmhWLEdBQUdpTixLQUFLaEgsS0FBSWlFO0lBQzlCLHVCQURrQmxLLE1BQUdpTixLQUFLaEgsS0FBSWlFO0lBQzlCLE9BWEUySyxlQVVnQjdVO0dBRUY7WUFFZGlWLG1CQUFtQmpWLEdBQUdpTixLQUFLaEgsS0FBS2lFO0lBQ2xDLHdCQURxQmxLLE1BQUdpTixLQUFLaEgsS0FBS2lFO0lBQ2xDLE9BZkUySyxlQWNtQjdVO0dBRUw7WUFFZHNTLE1BQU10UyxHQUFFa1Y7SUFDVix3QkFEUWxWLE1BQUVrVjtJQUNWLE9BbkJFTCxlQWtCTTdVO0dBRVE7WUFFZG1WLFlBQVVuVixHQUFJLCtCQUFKQSxNQUErQjtZQUN6Q29WLHFCQUFtQnBWLEdBQUksK0JBQUpBLE1BQXdDO1lBRTNEcVYsUUFBTXJWO0lBQ1IsdUNBRFFBO0lBRVIsd0JBRlFBO0lBRVIsT0EzQkU2VSxlQXlCTTdVO0dBR1E7WUFFZHNWLGlCQUFldFYsR0FBSSxPQUFKQSxLQUFhO1lBRTVCdVY7SUFBbUJ2VixHQUFFeU0sUUFBUXFELGdCQUFnQjBGLFdBQVVySjtJQUN6RCxJQUFJbEosVUFEaUJqRCxNQUVmLFFBQUEsd0JBREZpRDtrQ0FFaUI7SUFFbkI7S0FEUTJLO0tBQ0o2SCxXQUxlelY7S0FNZjhOLFdBQVMsc0NBRkxGLFFBQ0o2SDtLQUVBQyxVQUFVLHNDQURWNUg7S0FFQTZILGFBUnlDSCxZQU96Q0UsVUFQeUNGLFlBT3pDRTtJQUZBRCxjQUFBQSxjQUdBRTtJQUVhO0tBQWIzRjtPQUFhOzhDQVZZRixpQkFBMEIzRDtJQVd2RDtrQ0FYcUJNLFFBUWpCa0osWUFFQTNGLFlBSkFsQzs7S0FPRix3QkFaQTdLLFNBT0UwUztLQUhBRixjQUFBQSxjQUdBRTs7SUFNZ0M7SUFGcEMsdUNBWnFCbEo7SUFZckIsT0FKSWtKO0dBT007R0FoRUE7SUFBQTs7T0FTVmhCO09BR0FDO09BS0FDO09BRUFDO09BSUFDO09BSUFDO09BSUFDO09BSUEzQztPQUlBNkM7T0FDQUM7T0FFQUM7T0FLQUM7T0FFQUM7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ3RIRkssVUFBVUM7a0JBQ0hDOzBCQUNvQyxlQURwQ0EsSUFHSSw0QkFBUztLQUZNLFdBQUE7MEJBQVYsU0FBSTtLQUFwQjtNQUFBLE9BQUEseUJBRlVEO01BRVYsT0FBQTtLQUEyQyxPQUFBO0lBRXZCO0lBSGxCLE9BQUE7R0FHbUI7R0FHdkIsSUFERUU7WUFnQkFDLGlCQUFpQmpILFlBQVc3TyxLQUM5QixlQURtQjZPLFlBQVc3TztHQUNpQjtZQUU3QytWLGFBQWFsSCxZQUFXNUMsV0FDMUIsZUFEMEJBLFdBQVg0QztHQUNrQztZQUUvQ21ILGFBQWFDLElBQUdDLElBQUdDLElBQUssT0FBWEYsV0FBR0MsVUFBR0MsR0FBc0M7R0FNM0Q7SUFKRUM7TUFJRjtzQkFORUo7SUFRQWhLLGFBS0Y7SUFFRUU7WUFNQW1LLHdCQUF3QjlXLEdBTTFCLE9BTjBCQSxlQU1rQjtHQUV0QjtJQUFwQitXO01BQW9CLHlCQVJwQkQ7SUFRb0I7Z0JBSWZsSyxnQkFBZUgsWUFBV0UsT0FBTUQsV0FDbEMsV0FERUUsZ0JBQTBCRCxPQUFNRCxXQUFqQkQ7R0FDcUM7R0FGM0Q7SUFBQTtNQUFBOzJCQTlCRW9LLGNBTUFwSyxZQU9BRSxPQWNBb0s7SUFHRixNQUFBO0lBREVDLHFCQUNGO1lBZ0JFQyw0QkFBd0RDO1FBQVh2SyxrQkFBdEJDO0lBQ3RCLEtBQUEsOEJBRDRDRDtLQTJCMUMsT0FBQSxXQTNCcUR1SyxRQUFqQ3RLO2tCQUdMUTtLQVdsQixHQWR1QlIsa0JBR0xRO01BaUJoQjs7O1VBQ0EsT0EzRUZtSjtTQTJFb0U7T0FEbEUsT0FBQSx5QkFwQnFCM0o7TUFvQlksT0FBQTs7S0FNUDtNQUR0QnVLLG1CQXpCaUJ2SywwQkFHTFE7TUF1QlUsT0FBQSx5QkF2QlZBO01BdUJoQixPQUFBLFdBMUJzRDhKLFFBeUJsREM7S0FDc0IsT0FBQTtJQUFrQjtJQXZCaEMsT0FBQTs7WUEwQmRDLGlCQUFpQjVLO1FBQUdFLFlBQUhGLGlCQUFvQkksaUJBQXBCSjtJQUNoQixHQUFBLDBDQURtQkU7S0FRcEI7OztTQUNBLE9BNUZBNko7UUE4RmdEO01BSGhELE9BQUEseUJBUnFDM0o7S0FRVixPQUFBOztJQUszQixTQUFJeUssV0FBV3RLO0tBQ3VCLFdBQUEseUJBRHZCQTttQkFDSHVLLElBQU0sZUFBTkEsS0FBd0I7S0FBRSxPQUFBO0lBQXVCO0lBRTdELE9BN0NBTCxxQkE2QmlCekssY0FhYjZLOzs7Z0JBT0N0SixtQkFBa0JEO0lBQ1osSUFBSnhLLElBQUksaUNBRE55SztJQUVGLFdBREl6SyxHQURGeUssZ0NBQWtCRDtHQVVuQjtHQVhOLElBREV5SixpQkFDRjtZQWVFQyxvQkFBb0JoTDtJQUN0QjtLQUE0QkUsWUFETkY7S0FDaUJHLFFBRGpCSDtLQUNoQkksaUJBRGdCSjtJQUVuQixHQUFBLDBDQUR5QkU7S0FRMUI7OztTQUNBLE9BL0hBNko7UUErSHlFO01BRHpFLE9BQUEseUJBUkkzSjtLQVF1QixPQUFBOzthQUd2QjZLLGNBQWMxSztLQUNoQixHQUFHLCtCQVpnQ0o7TUFtQi9CO09BQUEsT0FBQSx5QkFSWUk7dUJBSVAyQixVQUFTckUsU0FBVyxlQUFwQnFFLFVBQVNyRSxVQUFpRDtNQUkvRCxPQUFBLCtCQXBDTmtOOztLQXlDTSxXQUFBLHlCQWJZeEs7bUJBV1AySztNQUNGLHFDQURFQTtLQUMyRDtLQUNoRSxPQUFBO0lBQXVCO0lBRTdCLE9BMUZBVCxxQkErRG9CekssY0FZaEJpTDtHQWUyQztZQUUvQ0U7UUFBNkNqTCxzQkFBdEJFO0lBQ3RCLEdBQUEsMENBRDRDRjtLQU83Qzs7O1NBQ0EsT0ExSkE2SjtRQTBKMEU7TUFEMUUsT0FBQSx5QkFQdUIzSjtLQU9JLE9BQUE7O2FBUEpBO3lCQWVWOEIsVUFBWSxlQUFaQSxXQUF3QzsyQ0E1RHJENkk7O3lCQTJEcUMsT0E3SnJDZixnQkErSTZDOUosV0FjNkI7SUFBMUUsV0FBQSx5QkFkdUJFO0lBY0ksT0FBQTs7R0FHUjtJQUFuQmdMO01BQW1CO1lBRW5CQztRQUErQ25MLHNCQUF0QkU7SUFDeEIsR0FBQSwwQ0FEOENGO0tBUS9DOzs7U0FDQSxPQTlLQTZKO1FBOEs0RTtNQUQ1RSxPQUFBLHlCQVJ5QjNKO0tBUUUsT0FBQTs7YUFSRkE7eUJBbUJaMEMsWUFBYyxlQUFkQSxhQUE2QztLQXJCdkMsT0FBQSwrQkFBbkJzSTs7O0tBa0JBLE9BckxBckI7SUF1TGlEO0lBSGpELFdBQUEseUJBZnlCM0o7SUFlRSxPQUFBOztZQU0zQmtMO1FBQTZDcEwsc0JBQVdDLGtCQUFqQ0M7SUFDbEIsS0FBQSwwQ0FEd0NGO0tBTzdDOzs7U0FDQSxPQWxNQTZKO1FBb01rRDtNQUhsRCxPQUFBLHlCQVB1QjNKO0tBT0ksT0FBQTs7Y0FQSkE7S0FpQnZCOzs7U0FDQSxPQTVNQTJKO1FBOE1pRDtNQUhqRCxPQUFBLHlCQWpCdUIzSjtLQWlCSSxPQUFBOztPQUlyQiw4QkFyQmtERCxnQkFBakNDO0tBMkJ2Qjs7O1NBQ0EsT0F0TkEySjtRQXNOaUU7TUFEakUsT0FBQSx5QkEzQnVCM0o7S0EyQkksT0FBQTs7UUFHdkIxSyxnQ0E5Qm1CMEs7SUErQnZCLGNBQXFEbkwsSUFDckQsZUFEcURBLEtBQy9CO0lBRHRCLFdBQUEsaUNBRElTO0lBQzZDLE9BQUE7O1lBR2pENlYseUJBQXlCdkw7SUFDM0IsSUFBNEJFLFlBRERGLGlCQUNyQkksaUJBRHFCSjtJQUV4QixHQUFBLDBDQUR5QkU7S0FRMUI7OztTQUNBLE9BdE9BNko7UUFzT3NFO01BRHRFLE9BQUEseUJBUkkzSjtLQVF1QixPQUFBOzthQUd2Qm9MLG1CQUFtQmpMO0tBaUNuQixXQUFBLHlCQWpDbUJBO21CQUVka0wsb0JBQW1CQztNQUNyQixPQUFHLDBDQURERDtnQkExT1QxQjtnQkFvUGU7aURBVk4wQjtrQkExT1QxQjswQkEwT1MwQixvQkFBbUJDO0tBeUJxQztLQU03RCxPQUFBLCtCQXRPSm5CO0lBc09pQztJQUVqQyxPQXJOQUUscUJBc0t5QnpLLGNBWXJCd0w7R0FtQ2dEO1lBRXBERztRQUF5Q3pMLHNCQUF0QkU7SUFDZCxLQUFBLDBDQURvQ0Y7S0FRekM7OztTQUNBLE9BdFJBNko7UUFzUjJFO01BRDNFLE9BQUEseUJBUm1CM0o7S0FRUSxPQUFBOzthQVJSQTtLQWtCb0I7TUFBQSxPQUFBLHlCQWxCcEJBO3NCQWtCTjBLLElBQU0sZUFBTkEsS0FBd0I7S0FBRSxPQUFBOzs7S0FEdkMsT0E5UkFmO0lBOFJ5RTtJQUR6RSxXQUFBLHlCQWhCbUIzSjtJQWdCUSxPQUFBOztZQUkzQndMO1FBQTRDMUwsc0JBQXRCRTtJQUNqQixHQUFBLDBDQUR1Q0Y7S0FpQjFDO01BQUEsTUFBQSx5QkFqQm9CRTs7aUJBYWY2RixnQkFBZS9RLEtBQUk2TjtTQUNyQixlQURFa0QsZ0JBQWUvUSxLQUFJNk47UUFDOEI7S0FHdEQsT0FBQTtpQ0EvUUZ3SCxtQkFnSUFhOzs7S0FzSUEsT0F6U0FyQjtJQTJTZ0Q7SUFIaEQsVUFBQSx5QkFQc0IzSjtJQU9LLE9BQUE7O1lBWTNCeUw7UUFBNEIzTCxzQkFBaUJFO0lBSS9DLFNBSitDQTs7OztpQkFZdEMwTDtTQU0wQixJQUF4QkMsd0JBQXdCLDZCQU4xQkQ7U0FPQyxPQUFBLDZCQURDQzttQkFTQztvREEzQmtCN0w7cUJBcFQ1QjZKO3FCQUdBQyxnQkFpVDRCOUo7MkJBa0JuQjZMO1FBWThDO0tBbEJyRCxPQUFBOzs7S0FMRixPQTNUQWhDO0lBNlRvRDtJQUhwRCxVQUFBLHlCQU42QzNKO0lBTWxCLE9BQUE7O1lBMkIzQjRMO1FBQWlEOUwsc0JBQXRCRTtJQUMxQixHQUFBLDBDQURnREY7S0FRakQ7OztTQUNBLE9BOVZBNko7UUFnV2lEO01BSGpELE1BQUEseUJBUjJCM0o7S0FRQSxPQUFBOztJQU96QixVQUFBLHlCQWZ5QkE7aUJBY3BCNkwsZ0JBQWtCLGVBQWxCQSxpQkFBd0Q7SUFDN0QsT0FBQTs7WUFFRkMsb0JBQW9CQztJQUdwQjtLQUgwQi9MO0tBRzFCLE1BQUEseUJBSDBCQTtpQkFFckJnTSxXQUFhLGdCQUZFRCxLQUVmQyxZQUFnRDtJQUNyRCxPQUFBOztZQUVBQyxvQkFBb0JyTTtRQUFHQyxhQUFIRDtjQUFHQztZQUFBQTs7a0JBeFJ2QjJLLGlCQXdSb0I1Szs7a0JBdFBwQmdMLG9CQXNQb0JoTDs7a0JBek5wQm1MLHFCQXlOb0JuTDs7a0JBdE1wQnFMLHVCQXNNb0JyTDs7a0JBakxwQnNMLHFCQWlMb0J0TDs7a0JBL0lwQnVMLHlCQStJb0J2TDs7a0JBOUZwQjJMLGlCQThGb0IzTDs7a0JBMUVwQjRMLG9CQTBFb0I1TDs7a0JBdkRwQjZMLDBCQXVEb0I3TDswQkF0QnBCZ00seUJBc0JvQmhNOzs7U0FZVm1NLE1BWmFsTSxxQkFMdkJpTSxvQkFpQlVDLEtBWlVuTTtJQUN0QixPQUFBOztZQWNFc00sWUFBWUM7aUJBQ2F2TTtLQUFKLElBQU9JLGlCQUFISjtLQURidU07S0FBQUEsbUJBQ2F2TTtTQWF2QndNLHNCQWRVRCxtQkFDZ0JuTTtLQWM5QixHQURJb007TUFkVUQsbUJBQUFBLG1CQUNnQm5NO0tBc0I1QixVQXRDQWlNLG9CQWdCeUJyTTs7TUFtQnpCO1dBQ1F5TTtPQUFpQixlQXBCQXpNLGNBb0JqQnlNOztVQUNHM1Y7TUFBSyxXQUFMQTtLQUFhO0tBQ3hCLE9BQUE7SUFBa0M7SUF0QmIsT0FBQSx5QkF0VnJCMFQ7R0E0V2tDO0dBUXBDO0lBQUEsTUFBQTtJQUxFdlIscUJBS0Y7WUF3Q0k0RixPQUFPNkwsUUFBTzZCO0lBQ2hCLFdBRFM3QixjQUFPNkI7R0FDZ0Q7WUFFOURHLHFCQUFxQjdJO0lBQ3ZCLFdBcmRBaUcsNEJBb2R1QmpHO0dBS3RCO1lBRUM4SSxpQkFBaUJKO0lBS25CO0tBQThCO1VBQ3pCSywwQkFBQUE7OzthQUFrQ3ZYLDBCQUNyQyxlQURHdVgsT0FBa0N2WDs7YUFFYTBOLHVCQUFaRDtTQVV0Qzs7O3NCQVZzQ0EsWUFZRSwyQkFaVUM7aUJBbUJsRDs7O1NBR01qTTtLQUFLLDBCQUFMQTtJQUFxQjtJQXpCN0IsVUF0RkF3VixZQWlGbUJDO0lBS1csT0FBQTtHQXlCRDtZQUUzQk07SUFDQ2hKLGdCQUNEaUosZ0JBQ0FDLGlCQUNBQztJQUVrQixJQUFoQlQsZ0JBN0NGRyxxQkF3Q0M3STtpQkFjQ3FDO0tBUHlDLFNBT3pDQSxVQUFvQixPQUFBLHlCQUFwQkE7aUJBQUFBLFVBTlc3USwwQkFBUHVYO0tBQ0osV0FQRkcsaUJBTU1ILE9BQU92WDtLQUNYLG9CQUljLFdBQUs7S0FEUjs7TUFBQSxNQTlIZmlYLFlBdUhJQztNQU9XLE1BQUE7TUFBWCxNQTlnQko1QyxVQThnQmMsOEJBVFpxRDtLQVVNLE9BQUE7SUFDNEI7SUFQUztLQUFBO0tBQTNDLE1BQUEsV0FOQUYsZ0JBSUVQO0tBRUYsTUFBQTtLQURFN0IsU0FDRjtJQVNGLE9BM0RFN0wsT0FpREU2TCxRQURBNkI7R0FXdUI7WUFFekJVLGNBQWNGLGlCQUFnQkM7SUFDaEM7S0FBQSxPQXBCRUg7bUJBaENBRixrQkFtRGNJLGlCQUFnQkM7R0FRakI7WUFFYkUsY0FBZXJKLGdCQUFla0osaUJBQWdCQztJQUNoRCxPQTlCRUg7YUE2QmVoSjtzQkFHVjBJO2NBU29CLFVBekV6QkksaUJBZ0VLSjtjQVNvQixPQUFBLHlCQWhJM0J0VDthQWdJeUQ7YUFaekI4VDthQUFnQkM7R0FjakM7WUFFYnJHLFVBQVU1UyxHQUFJLE9BQUpBLEtBQVk7WUFFdEJvWixXQUFXcFosR0FBRXFaO0lBQ2YsT0FEZUE7O21CQUFBQSxVQVdRQyx1QkFBWEM7T0FYQ3ZaLFdBQUFBLG9CQVdVc1o7T0FRckIsT0FSVUM7O3FCQVhHRixVQUtQRyxXQUxPSDs0QkFBRnJaLFVBSVgsT0FDTXdaO1dBQWdCckg7T0FMWG5TLFdBS1dtUztPQUV0QixPQUZNcUg7O1dBR2lCdFosTUFSVm1aLFVBUUdJLFFBUkhKLFVBUVBLLGFBUk9MO09BQUZyWiwrQkFRS3laLE9BQU92WjtPQUV2QixPQUZNd1o7O0dBV0c7WUFFVEMsTUFBTTNaLEdBQUVxWjtJQUNWLE9BRFVBOztpQkFBQUE7O1lBSWlCQztRQUpuQnRaLFdBSW1Cc1o7Ozs7O09BRlosT0FBQTs7Z0JBRkxEO1lBR1FuWixNQUhSbVosVUFHQ0ksUUFIREo7UUFBRnJaLCtCQUdHeVosT0FBT3ZaOzs7O0lBRU0sTUFBQTtHQUFZO1lBRTlCMFosZUFBZTVaLEdBQUUrVyxJQUFJOUosS0FBS2hILEtBQUk0VDtJQUNwQyxZQURxQjdaOztLQVBuQjJaLE1BT21CM1osR0FxQlQsNEJBckJTQTtTQUNqQndaLFdBREVJLGVBQWU1WixHQUFFK1csSUFBSTlKLEtBQUtoSCxLQUFJNFQ7OztLQUtoQyxJQURJQyxhQUphOVosTUFLYitaLGtCQURBRDtLQUdKLE9BRklDO1NBTHdCOVQsTUFLeEI4VDtPQUlGLE1BQUE7VUFDSUMsb0JBTEZELGtCQUx3QjlUO01BSXhCNlQsZ0JBTUVFO2FBQUFBO09BRUosTUFBQTtlQUZJQSxtQkFWV2hhO1VBQVdtTixRQUFBbEg7OztVQUFBa0g7U0FDNUJxTSxXQUQ0QnJNOzs7O01BdUJwQm1NO01BdEJSRSxXQTdCRkosV0E0Qm1CcFosR0F1QmdCLFdBQXpCc1osWUF2Qld2QyxJQUFJOUosS0FBS2hILEtBQUk0VDtJQXlCcEMsS0F6Qm9DQSxNQUFmN1o7SUEwQnJCLE9BekJJd1o7R0F5Qkk7WUFFTlMsWUFBWWphLEdBQUFBLG1CQUFvQjtZQUNoQ2thLGVBQWVULE9BQU10WTtJQUFNO0tBQTRCLE1BQUEsNEJBQWxDQTtLQUFNLE1BQUEsb0NBQVpzWTtJQUF3QyxPQUFBO0dBQVU7WUFFakVVLGdCQUFnQm5hLEdBQUllLEtBQVVnTztJQUNoQyxHQURzQmhPLFNBQU1FLE1BQU5GLFFBQUFiLE1BQU1lLGNBQU5mO09BQUpGLFlBcm1CbEIrVjtLQXVtQkssMEJBRjJCaEgsWUFBVjdPO2NBQUpGOzs7Ozs7OztnQkFBYytPLGlDQUFBQTs7O3dCQUFkL087VUF5QkttTTtNQXpCTG5NO01BMkJkLDBCQUZtQm1NLFdBekJTNEM7OztJQW9CNUIsMEJBcEI0QkEsWUFBVjdPO0dBMkJnQztZQUVwRDhTLEtBQUtoVDtJQUNQLFlBRE9BOztLQUdMLElBREttUyxrQkFDTCxNQURLQTs7K0JBRUlwUCxJQUZKb1AsVUFFUyxzQkFBTHBQO1VBQ0txWCxlQUhUakk7TUFHdUIsT0FsQzVCZ0ksZ0JBNkJLbmEsTUFLU29hOzttQkFIVGpJLFVBSVlqUyxrQkFBUHVaOzs7O1FBQUFBOzs7OEJBQUFBO2NBQUFBLG1DQUFPdlosOEJBQ1g2TztVQUFBQTs7S0FXSixPQS9DRm9MLGdCQTZCS25hLE9BL0JMa2EsZUFxQ1VULE9BQU92WixPQUNYNk87O1dBUEQvTzs7Ozs7Z0JBQUFBOztHQXFCd0M7R0E1T25DO0lBQUE7O09Bc0NWOEs7T0FHQTZOO09BT0FDO09BZ0NBRTtPQW1CQUk7T0FVQUM7T0FnQkF2RztPQUVBd0c7T0FxQkFPO09BT0lDO09BNEJKSztPQUNBQztPQUVBQztPQTZCQW5IOzs7T0F4b0JGNEM7T0FNQUc7T0FnQkFDO09BR0FDO09BR0FDO09BRUFJO09BTUFwSztPQU9BRTtPQU1BbUs7T0FRQUM7T0FFQUM7T0FpQkFDO09BNkJBRztPQWtCQUc7T0FnQkFDO09BNkJBRztPQWlCQUM7T0FFQUM7T0FxQkFDO09Ba0NBQztPQWlEQUk7T0FvQkFDO09BbUJBQztPQWlDQUc7T0FpQkFFO09BS0FHO09BZUFDO09BMEJBclQ7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUN6WEFtVixzQkFBc0JqSixTQUFRa0osY0FDaEMsV0FEd0JsSixTQUFRa0o7R0FDMEI7WUFFeERDO0lBQXFCOUssU0FBUStLLGtCQUFpQkM7SUFDaEQsV0FEK0JELGtCQUFSL0ssa0JBQXlCZ0w7R0FPL0M7WUFFQ3JKLFFBQVNwUjtJQUNYLFdBRFdBOzs7OztZQUlzQm9SOzs7Ozs7Ozs7Ozs7WUFBQUE7OztRQUduQixNQUFBOztLQURaLE9BRitCQTs7SUFEL0IsTUFBQTtHQUl3QjtZQUV4QmtKLGFBQWN0YTtJQUNoQixXQURnQkE7Ozs7UUFZZCxPQUFBOzs7Ozs7OzREQVA0QnNhOzs7YUFBQUE7O1FBRzVCLE9BSDRCQTtnQkFTaEIsT0FBQTs7SUFYWixNQUFBO0dBV2tFO1lBRWxFOUksU0FBVXhSO0lBQ1osV0FEWUE7Ozs7O1lBS0owYTs7Ozs7Ozs7Ozs7Ozs7WUFBQUE7O2dCQU1NOztLQUpaLFVBRk1BLDZCQUdPO0tBRGI7TUFFY2xKO2NBSlJrSixvQkFBQUEsb0JBQUFBO0tBS0osV0FEWWxKOztJQVBpRDtHQVMvQztZQUVoQm1KLGFBQWMzYTtJQUNoQixXQURnQkE7Ozs7O1lBTVIwYTs7Ozs7Ozs7Ozs7Ozs7WUFBQUE7OztRQU1NLE1BQUE7O0tBSlosVUFGTUE7TUFHTyxPQUFBO0tBRGI7TUFFY2xKO2NBSlJrSixvQkFBQUEsb0JBQUFBO0tBS0osT0FEWWxKOztJQVBkLE9BQUE7R0FTd0I7WUFFeEJvSixvQkFBcUI1YSxHQUFPOEgsR0FBRTBKLFVBQVNxSjtJQUN6QyxXQUQ4Qi9TOzs7O1FBa0NqQixPQUFBOztRQURJLE9BQUE7O1FBRUQsT0FBQTs7b0JBbkN5QitTO0tBVXpCO01BREMzUSxJQVR3QjJRO01BVS9CNVUsTUFBTSwyQkFEQ2lFO01BRVBtSywyQkFGT25LLE9BQ1BqRTtNQVBHdUcsU0FPSHZHO01BUEo2VSxVQVFJekc7O0tBTEo7TUFEUXRNLE1BTDJCOFM7TUFHNUJFLFdBR1AsOEJBRFFoVDtNQUZSaVQsOEJBRVFqVCxTQUZEZ1Q7TUFBQXZPLFNBQUF1TztNQUFQRCxVQUFBRTtJQWNnQjtLQUhoQkMseUJBWE96TztZQUhVeE07S0FpQkQsV0FqQkNBOztPQWNqQmliOztVQU9lO0tBTmZqTDtPQUNGO0lBUUYsdUNBeEJxQmhRLE1BQU84SCxNQWV4QmtJLFlBZjBCd0I7SUFBRjFKLE9BY3hCbVQsdUJBZDBCekosVUFHMUJzSixlQUgwQnRKO2tEQUFUeFI7R0FtQ3FEO1lBRTFFa2Isa0JBQW1CbGIsR0FBT21iO0lBQzVCLFdBRHFCbmI7Ozs7UUFJTCxPQUFBOzs7Ozs7Ozs7Ozs7OztRQUVkLElBRCtEb2Isa0JBQy9ELFFBRCtEQTs7O1VBRWJDO1VBQTFCQztVQUFWOUo7U0FDVCxHQUFBLHNCQUQ2QzZKO1VBRTNDO1NBSndERCxnQkFFakQ1SixVQUFVOEosZUFQRUg7OztRQWF4QixPQUFBOztRQVZVLE9BQUE7O0lBRG1ELE1BQUE7R0FZVztZQUUxRUkseUJBQTBCdmIsR0FBT3dSLFVBQVNxSjtJQUM1QyxVQUQ0QjdhOzs7OzRCQUtGb2IsbUJBQWRJO1FBMURWWixvQkFxRDBCNWEsR0FLRm9iLFFBTFM1SixVQUFTcUo7OzsyQkFBaEI3YSxlQUtoQndiLGVBQWNKLGtCQU82QjtRQUQvQixPQUFBLHVDQVhJcGI7Ozs7Ozs7Ozs7Ozs7O1lBR3FDeWI7UUFDL0QsT0F6REFiLG9CQXFEMEI1YSxHQUdxQ3liLFVBSDlCakssVUFBU3FKOztRQWE5QixNQUFBOztJQVhtRCxNQUFBO0dBV3ZDO1lBRXhCYSxvQkFBcUIxYixHQUFPd1IsVUFBU2hCO0lBQ3ZDLGNBRHVCeFE7Y0FmckJ1Yix5QkFlcUJ2YixHQUFPd1IsMEJBQVNoQjtjQUlyQztHQUN3RTtZQUV4RW1MLHVCQUF3QjNiLEdBQU93UixVQUFTbkU7SUFDMUMsY0FEMEJyTjtjQXRCeEJ1Yix5QkFzQndCdmIsR0FBT3dSLHlCQUFTbkU7Y0FJeEM7R0FDMkU7WUFFM0V1Tyx3QkFBeUJDLDJCQUEyQjdiLEdBQU84SCxHQUFFMEo7SUFDL0QsSUFBSXNLLDJCQUR1QkQsMkJBRTNCLE1BRjZEL1Q7OztlQWtCM0Q7ZUFFQTtJQWZFO0tBREVrSSxhQUNGLGdEQUxrRGhRLE9BQUFBO0tBT2hEK2IsdUJBQXVCLDJCQVBnQ2pVO0tBUXZEd1Q7T0FDRixnQ0FGRVMsc0JBUGdEL2I7SUFXcEQsdUNBWG9EQSxNQUFPOEgsTUFJdkRrSSxZQUp5RHdCO09BQzNEc0ssc0JBVzJCLHVDQVp1QjliO0lBQU84SCxXQUFFMEosVUFRekQ4SjtJQU9KLHVDQWZvRHRiO0lBZXBELE9BUElzYjtHQVlnRTtZQUVwRVU7SUFBK0JoYyxHQUFRNmIsMkJBQTBCcks7SUFDbkUsVUFEaUN4Ujs7OztRQU83Qjs7U0FGc0JvYjtTQUFkSTtTQUNORjtXQTVCSk07YUFzQnVDQywyQkFBUjdiLEdBS1BvYixRQUx5QzVKOzsyQkFBbEN4UixlQUtyQndiLGVBQWNKLGtCQVM2QjtRQURyRCx1Q0FiK0JwYjtRQWEvQixPQVBJc2I7Ozs7Ozs7Ozs7Ozs7O1lBSDJERztRQUMvRCxPQTFCQUc7aUJBc0J1Q0MsMkJBQVI3YixHQUdnQ3liLFVBSEVqSzs7UUFnQnJELE1BQUE7O0lBZG1ELE1BQUE7R0FjdkM7WUFFeEJ5Syx1QkFBd0JqYyxHQUFTZSxLQUFtQ3lRO0lBRXRFLEdBRm1DelE7U0FBNEJFLE1BQTVCRixRQUFBOGEsNEJBQTRCNWE7O1NBQTVCNGE7a0JBQVQ3YjtjQWxCeEJnYztlQWtCd0JoYyxHQUFTNmIsMkJBQW1Dcks7Y0FNcEU7R0FDMkU7WUFFM0UwSyxrQkFBbUJsYyxHQUFPOEgsR0FBRXNKO0lBQ3hCLFlBQUEsV0FEc0J0SixNQUFQOUg7O0tBSWpCO01BRkNtYztNQUNDbk07UUFDRixnREFKaUJoUSxPQUFBQTtLQU1uQjs7T0FObUJBO09BQU84SDtPQUd0QmtJO09BRERtTTtPQUZ5Qi9LO0tBZVQ7TUFIYjNCLFVBWm9CM0g7TUFZWDBTLG1CQVpXMVM7TUFZTzJTLHFCQVpQM1M7TUFldEIwVCxlQWxOSm5CLHNCQW1NNEJqSjtNQWdCeEJnTDtRQWhOSjdCLHFCQTRNTTlLLFNBQVMrSyxrQkFBa0JDO0tBVjlCMEIsMkJBYUNYLGNBQ0FZO0tBWUosdUNBNUJtQnBjO0tBNkJuQixXQTNCR21jOztRQTRCR3BaO0lBQ04sV0FETUE7R0FDcUU7WUFLM0VzWixZQUFhcmMsR0FBT29SO0lBQ3RCLFVBRGVwUjs7OztNQU1ZLE1BQUE7Ozs7Ozs7Ozs7Ozs7U0FIc0NvYjtLQUMvRCxPQXhDQWMsa0JBb0NhbGMsR0FHa0RvYixRQUgzQ2hLOztJQUUyQyxNQUFBO0dBSTFCO1lBRXJDa0wsS0FBTXRjLEdBQU9vUjtJQUNmLGNBRFFwUjtjQUdIOytDQUhHQTs7Z0JBUk5xYyxZQVFNcmMsR0FBT29SO2NBVVI7R0FBZ0U7WUFFckVtTCxhQUFlbkwsU0FBU3BSLEdBQU84SCxHQUFHcUssT0FBZXBEO0lBQ25ELFVBRGlDakgsWUFBUDlIOzs7OztPQUFBQSxPQUdSLCtCQUhrQm1TLE9BQWVwRDs7UUFJN0NyRCxnQkFKOEJ5RyxxQkFBQUE7O21CQVNFckk7V0FDbkI7WUFBWDBILFdBQVcscUNBRG1CMUgsVUFMaEM0QjtXQU9GLE9BOUZGc1EsOEJBbUZ3QmhjLE1BVWxCd1I7VUFDb0U7T0FGM0MsT0FBQSxXQVRQeFIsTUFBVG9SLFNBQW1CZTs7Ozs7OztVQUFWblMsT0FvQlIsK0JBcEJrQm1TLE9BQWVwRDtVQXFCakQsT0FBQSwrQkFyQndCL08sR0FBeUIrTzs7Ozs7Y0FZckN1TTtVQUNaLGlDQURZQTtVQVpZdGIsT0FjUiwrQkFka0JtUyxPQUFlcEQ7VUFlakQsT0FBQSwrQkFmd0IvTyxHQUF5QitPOzs7Ozs7TUEwQmpELE9BQUE7O0lBQ3FEO0dBQUU7WUFFdkR5TixlQUFjeGMsR0FBT3lULEtBQUkxRTtJQUMzQixVQURnQi9POzs7Ozs7Ozs7OztnQkFJWW9iO1lBQVcsT0FqQ3JDbUIsZ0JBNkJjdmMsR0FJWW9iLFFBSkwzSCxLQUFJMUU7Ozs7NkJBTVl1TCx1QkFBVGxKOzs7OzsyQkFBU2tKLHVCQUFUbEo7O1lBRXhCcUs7UUFDSixpQ0FIcUNuQjtRQUdyQyxPQXRDQWlDLGlCQW1DNEJuTCxVQU5kcFIsR0FRVnliLFVBUmlCaEksS0FBSTFFOztRQVdiOztJQVJaLE1BQUE7R0FRYztZQUVkME4sV0FBV3pjLEdBQUV5VDtJQUFNLE9BYm5CK0ksZUFhV3hjLGdCQUFFeVQ7R0FBd0Q7WUFFckVpSixTQUFTMWMsR0FBRTBJO0lBQ2IsSUFDRSxXQUZXQSxPQUVYO1VBR0FpVTtTQUFBbEosMEJBQUFrSjtLQVBBRixXQUVTemMsR0FLVHlUO0tBRUEsV0FGQUE7O0dBRVM7T0FFVDFFO1lBR0E2TixnQkFBaUI1YztJQUNuQixVQURtQkE7Z0NBRVQ7OztPQUNNOzs7Ozs7Ozs7Ozs7UUFDMEM7O1dBR2xEMGE7T0FLTixVQUxNQSw2QkFTTztPQUpiLE9BTE1BOztjQU9jelUsTUFQZHlVLGlDQU9jelU7O1VBQ0g7a0JBRkQ7O2VBSUo7O0dBQUs7WUFFakI0VyxtQkFBb0I3YztJQUN0QixVQURzQkE7Ozs7Ozs7O3VEQUdRc2E7OztVQUFBQTs7S0FHekIsVUFBQSxpQ0FIeUJBO0tBR3pCLFVBQUE7S0FDRSxJQUNDLFVBQUEsaUNBTHNCQSxlQUt0Qjs7V0FBMkNxQztVQUFBbEosMEJBQUFrSjtNQUFPLE9BekN4REYsV0FpQ29CemMsR0FRNkJ5VDs7O0lBQzVDO0dBQUU7WUFFUHFKLGtCQUFrQnJRLFFBQVFRLEtBQUtoSCxLQUFJK0osWUFBV2hDO0lBQ2hELGdCQURnREE7U0FHbkNYLE9BSG1DVztLQUczQixPQUFBOztjQUhEdkI7Y0FBaUJ1RDtrQkFBVC9DO2tCQUFLaEg7Y0FHcEJvSDs7UUFESG1ELE1BRnNDeEM7SUFFL0IsT0FBQTs7YUFGR3ZCO2FBQWlCdUQ7aUJBQVQvQztpQkFBS2hIO2FBRXZCdUs7R0FDZ0U7WUFFeEV1TSxhQUFjL2M7SUFDaEIsWUFEZ0JBOzt3QkFpQkwsT0FBQSwrQkFqQktBO1NBa0JOc1A7S0FBYSxPQUFBLCtCQWxCUHRQLEdBa0JOc1A7O2NBbEJNdFA7Ozs7Z0NBZXFCLE9BQUEsK0JBZnJCQSxNQWVvRDtNQUExQyxPQUFBLHVDQWZWQTs7Ozs7OztNQWFaLE9BQUEsK0JBYllBOzs7SUFnQlAsTUFBQTtHQUV3QztZQUUvQ2dkLG9CQUFxQmhkLEdBQVF3VjtJQUMvQixZQUR1QnhWOztLQUdyQixJQURpQ29iLG1CQTBDekJqWSxJQTFDeUJpWTtlQTBDekJqWTthQUFBQTs7YUFBV2tSLFFBQVhsUixNQUEwQjhDLE1BQWZvTyxVQUFVcEgsTUFBVm9ILFVBQUVyRyxTQUFGcUc7U0FDWixPQTdDc0JtQjtVQStDM0I7V0FESXlILG1CQTlDdUJ6SCxZQTRDS3ZQO1dBSTFCbUc7YUFGRjZROztnQkFLWTtXQUpaak47YUFNRjtpREFMSTVELFlBaERhcE0sT0FBQUE7V0F1RGZrZCxlQVRBRCxtQkE5Q3VCekgsWUE0Q0t2UDtVQXJFbEM2VyxrQkF5QnFCOWMsTUE0Q1FpTixLQVd2QmlRLGNBUkFsTixZQUhlaEM7VUFBYjdLLE9BYUssc0NBYk1rUixPQVdiNkk7aUJBVEFELGtCQWxFTkYsYUFvQnFCL2M7VUEwRFUsT0FIekJrZDs7OzthQW5EaUN4TCxXQXdDL0J2TyxNQXhDZ0JtWSxnQkF3Q2hCblksTUF4Q01xTyxXQXdDTnJPO1lBdkNILGlDQURtQm1ZLHNCQUpLOUY7OzttQkFJTDhGO21CQUpIdGI7bUJBQUFBO21CQUFRd1Y7bUJBQVJ4VjtTQWFYLEtBQUEsZ0NBVGNzYixnQkF1Q3BCO1NBeEJvQjtnQkFuQkh0YjtVQW1CRyxVQW5CSEE7VUFvQk4sVUFBTztVQUhkcVE7WUFDRjtTQUtGLE9BbkJtQ3FCO29CQXFCakM7O3FCQXpCZTFSO3FCQUVZb2I7cUJBZXpCL0s7cUJBYitCcUI7bUJBeEJ2Q3FMLGFBb0JxQi9jO21CQUVZb2IsZ0JBRW5CNUo7O29CQWtDUjs7cUJBdENleFI7cUJBaUJicVE7Ozs7bUJBckNSME0sYUFvQnFCL2M7bUJBRVlvYixnQkFFbkI1Sjs7O0tBd0RzQjs7SUFDL0I7R0FBQztZQUVOMkwsd0JBQXlCbmQsR0FBTzhKO0lBQ2xDLFVBRDJCOUo7Ozs7Ozs7OztNQUU0QixNQUFBOztTQUNKb2I7S0FBQUEsZ0JBSGpCdFI7OztJQU0zQixNQUFBO0dBQVk7Ozs7T0EvYWpCdVE7T0FHQUU7T0FTQW5KO09BU0FrSjtPQWdCQTlJO09BYUFtSjtPQWNBQztPQXFDQU07T0FnQkFLO09BZUFHO09BT0FDO09BT0FDO09Bc0JBSTtPQWtCQUM7T0FTQUM7T0FvQ0FHO09BUUFDO09BWUFDO09BNkJBQztPQWFBQztPQUVBQztPQVNBM047T0FHQTZOO09BbUJBQztPQVdBQztPQUtBQztPQW9CQUM7T0ErREFHOzs7RTs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUM5ZE1wWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFDQXFZLEtBQUs1ZSxHQUFFdUQsR0FBSSxPQUFBLCtCQUFOdkQsR0FBRXVELEdBQTJCOztpREFEbENnRCxPQUNBcVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFPS0MsU0FBU0MsR0FBRW5kO0lBQU0sSUFBSSxjQUFLLGlCQUFqQm1kLEdBQUVuZCxPQUFVOzs7MkJBQW9DOzs7R0FBSTtHQVp4RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BWUxrZDs7O2FBNEVIRTtTQUFzQkM7O1VBQXVCQztzQ0FBdkJELElBQXVCQzs7OztpRUFBN0NGOzthQVNORyxVQUFZM2M7S0FDZCxHQURjQSxTQUFXRSxNQUFYRixRQUFBNGMsV0FBVzFjLGNBQVgwYztLQU9XO01BQUEsTUFBQTs7OztLQUx2QjthQUVnQiwrQkFKSkE7Ozs7OztJQVFYO2FBRUQ3UztLQUNDOFMsUUFDQUMsMEJBQ0FDLDBCQUNEQztLQUVGO2FBRkVBOzs7O2FBSENIOzthQUNBQzthQUNBQztJQWlCQTthQUVEM1I7SyxtQkFDZ0I7U0FDUDRSO0tBQW1CLE9BQUEsdUJBQW5CQTs7YUFFVEM7Syx1QkFFYUEscUJBQWlCLE9BQWpCQTtTQURKQztLQUFpQixPQUFqQkE7O2FBR1RDLGFBQ0NOLFFBQU90ZTtLQUNWLFNBREdzZTtVQUVhSSxXQUZiSjtNQUFBQSxZQU9nQiw4QkFQVHRlLElBRU0wZTs7O1NBTUpDLGFBUlRMO0tBQUFBLFlBU2dCLDhCQVRUdGUsSUFRRTJlOztJQUN1QzthQUVqREUsZ0JBQ0NQLFFBQU9RO0tBQ1YsYUFER1I7Z0JBQUFBLFlBQU9RO2dCQUFQUixZQUFPUTtJQUdrQzthQUUxQ0MsV0FBV0MsYUFBYTdRLFdBQVU4UTtLQUNwQztNQUQ0Q0Msa0JBQVJEO01BQ3JCUixhQURGTztNQUM4Qkcsa0JBRDlCSDtNQUlUblMsWUFBWSx1QkFIRDRSO0tBbkJiRyxhQW1CeUNPLGlCQUd2Q3RTO0tBSlNtUyxpQkFBdUJDO0tBUWYsSUFBZkcsZUE5QkpWLFNBc0IwQ1E7S0FTMUMsR0FUd0IvUTs7YUFBYjZROztrQkFrQkF2YyxHQUFFNGMsUUFBcUJDO1VBQXJCRCxnQkFsQkZMO1VBb0JGLE9BQUEsNkJBRkV2YyxHQUFFNGMsUUFBcUJDO1NBRUs7TUFwQjVCTixpQkFpQlAsd0NBVEFJOztPQURGRyxpQkFxQkEsNkJBeEJBMVMsV0FKU21TOzs7O09BT1RPO1NBc0JHLDZCQXpCSDFTLFdBSlNtUyxhQVFQSTtLQXVCTixPQXJDRVAsZ0JBTTBDSyxpQkFPeENLOzthQTBCRkMsbUJBQW9CUDs7TUFBcUJSO01BUS9CZ0IsY0FSVVI7Z0JBUVZROzsyQkFOUTtNQUU2QjtPQUVwQm5CO09BRm9CLE1BQUEsdUJBSk5HO09BSWYsTUEvRDFCNVIsVUFpRTJCeVI7TUFGRCxHQUFBLHFEQUN4QjtvQkFDeUJBOzs7YUFLM0JvQixvQkFBb0JDLE1BQXdCOVEsVUFDbENtUTtLQUVQLEdBQUEsMENBSHlDblE7VUFFOUIrUSxlQUY4Qi9RLFVBRTFDb1EsaUJBRmtCVTs7TUFPaEIsWUFBQSwyQkFQZ0JBLFNBQXdCOVE7O1dBU25DZ1I7VUFFRiwyQkFYYUYsU0FBd0I5UTtZQUU5QitRLHFDQUFaWCxpQkFGa0JVOztZQUVOQyxlQUY4Qi9RLFVBRTFDb1EsaUJBT09ZOzs7T0FjTDtRQXJCVUM7UUFBWkMsbUJBRmtCSjtRQUVOQyxlQUFBRTtRQUFaYixhQUFBYzs7S0F3Qkc7Z0JBQUEsaUNBekJLZixnQkFDSVk7O01BNEJVO09BRmxCMVIsb0JBMUJRMFI7T0EwQm9CelIsWUExQnBCeVI7T0EyQkZJLHNCQTVCRmhCO09BNkJOaUIsb0JBcEdKcFQsVUFtR1ltVDtPQUllOzs7VUFBQTs7WUFMckI5UjtZQUVGK1I7T0FHdUIsY0FMTzlSLGNBM0J4QjZROztXQXFDQ2tCLG9CQXBDVGpCO09BcUNLO2VBRElpQjtZQWpEWFYsbUJBYUVQLFlBRFFEO1FBN0NWRCxXQWtGV21CLHNCQXJDRGxCO2tCQXFDQ2tCO1FBQUFBLG1DQVJQRDs7T0ExRUpsQixXQTZDVUMsYUEyQndCN1EsV0ExQmhDOFE7O01BRFFELGlCQUNJWTs7Ozs7OzthQTJEZE8sU0FDVXJFLFFBREkzYjtLQUNoQixJQUF1Q3NlLGFBQTNCM0MsV0FBbUJ3QyxTQUFuQnhDO0tBQ1osU0FEK0J3QztVQUdkOEIsU0FIYzlCLFdBQzNCK0IsVUFFYUQ7O1VBQ0pFLFdBSmtCaEMsV0FDM0IrQixVQUdTQztLQUpEeEUsWUFDUnVFLDJCQUZZbGdCLGFBQ0oyYjtLQU9ILElBQUw5YixLQUFLLHVCQVA4QnllO0tBNUhyQ0csYUE0SDZCTixRQU8zQnRlO0tBRTZDO01BQUEsTUF6SS9DMGUsU0FnSTZCSjtNQVMzQlEsbUJBQW1CLDZCQUZuQjllLElBUFE4YjtLQVVaLE9BMUhFK0MsZ0JBZ0g2QlAsUUFTM0JRO0lBQ21DO2FBRXJDeUIsY0FDQ2xCLFFBQU9lO0tBQ1YsYUFER2Y7Z0JBQUFBLFlBQU9lO2dCQUFQZixZQUFPZTtJQUdzQjthQUU5QmpaO0tBQ0F6RztLQUNDbU87S0FDQTBQO0tBQ0FDO0tBQ0RDO0tBR0E7TUFERTNDO1FBbkxGdFE7Y0E2S0E5SztVQUVDNmQ7VUFDQUM7VUFDREM7TUFTRTVSLFlBQVksdUJBVGQ0UjtLQVVGLDBCQWRFL2QsTUFhRW1NLFdBUEFpUDtLQU5GcGIsT0FlZSw2QkFGYm1NLFdBUEFpUCxRQU5GcGI7UUFDQ21PO01BbEZENlEsb0JBaUZBaGYsR0FDQ21PLFVBS0NpTjtLQTFCRnFFLFNBMEJFckU7S0FZSixPQVpJQTs7YUFlRjBFLFNBQXFCQyxPQUFNNVQ7S0FDN0IsT0FBQSwyQkFEdUI0VCxVQUFNNVQ7O2FBRzNCNlQsS0FBS2hnQixHQUFFbU07S0FDSCxZQUpKMlQsU0FHSzlmLEdBQUVtTTtpQkFHQztTQURPNFI7S0FBb0IsV0FBcEJBO0lBQ0g7YUFFWnRWLFlBQXNDQztTQUFuQnVYO2tCQUNBM2dCLElBQUk4YixRQUFVLE9BQUEsV0FESzFTLEdBQ2YwUyxRQUFrQjtLQUEzQyxPQUFBLGdDQURxQjZFOzthQUduQkMsb0JBQWdDSCxPQUFjM0U7O2dCQUNoRCw2QkFEa0MyRTtzQkFDQSw2QkFEYzNFOzs7YUFHOUMrRSxtQkFBK0JKLE9BQWMzRSxRQUFRZ0Y7S0FDdkQ7TUFBQSxNQUFBLGVBRHVEQSxNQUF0Qkw7TUFDakMsWUFBdUIsZUFEZ0NLLE1BQVJoRjtLQUN4Qjs7YUFFckJpRixNQUFrQnBCLE1BQ1JYO0tBQVo7TUFBZVAsYUFBSE87TUFPUmdDO1FBZEZKLG9CQU1rQmpCLE1BQ1JYO1dBU0wsdUJBVmFXLFNBQ1JYOztNQWVSaUMsVUFDRix1QkFoQmF4QyxZQU9YdUM7S0FSZ0JyQixVQUFBQSxVQWdCaEJzQjtLQWZRakMsaUJBQUFBLGlCQWVSaUM7S0FXSixPQVhJQTs7YUFhRkMsaUJBQTZCVCxPQUFNemdCLElBQUdrVTtLQUN4QyxPQUFBLDBCQUQrQnVNLFVBQU16Z0IsSUFBR2tVOzthQUd0Q2lOLDZCQUE2QjFDLFlBQVcyQztjQUN0Q0Msd0JBQXdCNUM7TUFDdkIsVUFBQSx1QkFEdUJBO01BQ3ZCLGFBTUQsdUJBUHdCQTtLQU9pQjtLQUU3QztNQUEwQjZDLHVCQVZnQkY7TUFVdENHLHVCQVZzQ0g7TUFXdEN2VSxZQUFZLHVCQVhlNFI7S0FZNUIsR0FBQSwwQ0FEQzVSO01BR0MsVUFBQSxjQUhEQSxXQURBMFU7TUFJQyxhQWJERix3QkFEMkI1Qzs7S0FnQnZCLFVBQUEsY0FMSjVSLFdBRHNCeVU7S0FNbEIsYUFmSkQsd0JBRDJCNUM7SUFpQlE7YUFrQnJDekwsTUFBTXRTLEdBQUUwZ0I7Y0FDRkksU0FJSm5DO00sU0FBQUEsV0FEQSxPQWtDQW9DLFNBakNBcEM7TUFFSztPQUZLWixhQUFWWTtPQUNJNEIsVUFDQyx1QkFGS3hDLGNBeEVac0MsTUFtRU1yZ0IsR0FLSjJlO01BV0EsT0FWSTRCO09BZUE7UUFBQSxNQUFBLHVCQWhCTXhDO1FBZUppRCwrQkFFSyw2QkFqQlhyQztPQW1CRSxXQWxCRTRCLFNBY0VTOztNQVE4QjtPQUFBLFFBVXBDRCxTQWpDQXBDO09BdUJlc0M7T0FBVEM7T0FFRixNQUFBLHVCQXpCTW5EO09Bd0JKb0QsNkJBRFNGO01BSWIsU0FKSUMsV0FLRyxXQUxIQSxXQUNBQztNQU9GLEdBUEVBLHFCQTFKUjFCLFNBa0lFZCxRQXVCTXVDO01BU0YsV0FURUEsV0FDQUM7O2NBU05KLFNBQ0NwQztNQTRCWSxJQTNCRnlDLHVCQXBTYnBELFNBbVNHVztTQTZCRyw2QkE1Qk95Qyx1QkErQlg7VUEvQldDLHFCQUFBRDtNQUNYO09BQU0sWUFBQSw4QkFES0M7bUJBeUJUOzs7O1FBdkJXQztRQUZGQztRQUVGamlCO09BMUpYdWdCLGNBdUpHbEIsUUFHWTJDO09BRXNCO1FBQUEsVUEzQy9CUixTQXlDU1E7UUFFRU47UUFjWFQ7Y0FkV1M7UUEvRWpCUCw2QkE2RWVhLFdBMUNQWjtRQXhQUnhDLGFBK1JHUyxRQUdRcmY7O2dCQWdCTGloQjtRQUVBLEdBaEJXUyxtQkF6S2pCdkIsU0F1S2U2QixRQWdCVGY7UUFHQSxXQUhBQSxTQWRXUzs7V0FKSksscUJBQUFFOztLQWdDVztLQXZFbEJULFNBREE5Z0I7ZUFBQUE7a0JBOEVEVixJQUFHa1U7TUFPTCxhQVBLQTtpQkFTSDtpQ0F2RkN4VCxNQThFRFY7Z0JBU0EsMEJBdkZDVSxNQThFRFY7aUJBQUdrVSxZQUFBQTtLQVc0QjtLQVhwQyxPQUFBO0lBWXVCO2FBS3ZCZ08sV0FBV0MsUUFBS0MsUUFBT0M7S0FFekI7Z0JBQWtDLDZCQUZyQkY7O2FBRWIsNkJBRnlCRSxNQUFQRDs7Ozs7V0FHZjsrQkFIc0JDOzs7Ozs7SUFHc0M7YUFFN0RDLFNBUU94RyxRQVBKc0c7S0FDTCxTQU1TdEc7TUFKSztPQURFdUcsT0FLUHZHO09BSkhxRyxTQURVRSxPQUZYRDtPQUlDRyxhQVZKTCxXQVFjRyxNQUZYRCxRQUdDRDtNQUVKLEdBRElJLFlBR0d6RyxZQUpIcUc7TUFHSixPQUZJSTs7S0FJUTtNQURGQyxTQUFIMUc7TUFDSDJHLFNBRE1ELFNBUFBKO01BU0NNLGVBZkpSLFdBYVVNLFFBUFBKLFFBUUNLO0tBRUosR0FESUMsY0FGRzVHLFlBQ0gyRztLQUdKLE9BRklDO0lBRU07YUFFVkMsV0FRTzdHLFFBUEpzRztLQUNMLFNBTVN0RztNQUpPO09BREE4RyxTQUtQOUc7T0FKSCtHLFdBRFVELFNBRlhSO09BSUNVLGVBeEJKWixXQXNCY1UsUUFGWFIsUUFHQ1M7TUFFSixHQURJQyxjQUdHaEgsWUFKSCtHO01BR0osT0FGSUM7O0tBSVU7TUFESkMsV0FBSGpIO01BQ0hrSCxXQURNRCxXQVBQWDtNQVNDYSxpQkE3QkpmLFdBMkJVYSxVQVBQWCxRQVFDWTtLQUVKLEdBRElDLGdCQUZHbkgsWUFDSGtIO0tBR0osT0FGSUM7SUFFUTthQUVaQyxjQUNDeGlCLEdBQUVvZ0I7S0FDTCxTQURHcGdCLFVBRWFraUIsU0FGYmxpQixNQUFBQSxPQUVha2lCLFNBRlg5QjtTQUtPK0IsV0FMVG5pQjtLQUFBQSxPQUtTbWlCLFdBTFAvQjs7SUFLdUU7YUFrQjFFdGdCLE9BQU9xSztTQWhCSTZUO2NBQ0x5RSxhQUFhQyxPQUFNdlksS0FBSW5LO2VBQ3pCMmlCLFdBQVd4WTtPQUFmOztRQUFvQjdLO1FBQXVCVTtRQUFWZ2U7UUFBakMsTUFEbUIwRTtPQVFmLHVCLE9BUkVEO09BS0YsVUFBQSw2QkFMZUM7T0FFakIsT0FBQTtvQ0FEYXZZLGVBQUs3SyxJQUF1QlUsUUFBVmdlOztNQVVqQyxPQUFBLGlDQVZJMkUsWUFEcUJ4WSxLQUFJbks7S0FXSTtLQUVuQyxPQWJReWlCLGdCQWVDdFksS0FoQkk2VDs7SUFoZjBCOzs7WUF3RXJDTjtZQVVBNVM7WUFzQkFxQjtZQUlBNlI7WUFJQUU7WUFZQUM7WUFNQUU7WUFpQ0FTO1lBV0FFO1lBNkRBUztZQWFBSTtZQU1BcFo7WUFzQkFxWjtZQUdBRTtZQUtBdlg7WUFHQXlYO1lBR0FDO1lBR0FFO1lBNkJBRztZQUdBQztZQW1DQW5PO1lBK0ZBa1A7WUFLQUk7WUFjQUs7WUFjQU87WUF3QkExaUI7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQzNnQkU4aUI7SUFDQWhHOzs7O2dCQUFBQSxpQkFEQWdHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUF3Q0poUSxVQUFVNVM7SUFBSSxXQUFBLGtDQUFKQTtJQUFJLHFEQUFKQTtHQUEwRDtZQUNwRTZpQixjQUFjN2lCO0lBQUksOENBQUpBO0dBQTBCO1lBQ3hDOGlCLGdCQUFnQjlpQjtJQUFJLDBDQUFKQTtHQUErQjtZQUUvQytpQixnQkFBZ0IvaUI7SUFDbEIsdUNBRGtCQTtJQUNsQixPQUpFNmlCLGNBR2dCN2lCO0dBRUg7WUFFYmdqQixTQUFTaGpCLEdBTlQ4aUIsZ0JBTVM5aUIsSUFDWCxPQUxFK2lCLGdCQUlTL2lCLEdBRU07WUFLZmlqQiwrQkFBZ0NqakIsR0FBRW1NO0lBQ3BDLE9BQUcsMENBRGlDQTt3REFBQUEsV0FBRm5NO3dEQUFFbU0sV0FBRm5NO0dBRzBCO1lBTTFEdWMsYUFBYXZjO0k7U0FDaUI2YSxpQkFBUDFJLDZCQURWblM7O0tBZ0JNO01BTGJnUDtvQ0FWd0I2TDs7V0FhckIsb0RBYnFCQSxPQUFBQTtNQWV4QjdLO1FBQWE7O0tBRWpCO21DQWxCV2hRLE1BZ0JQZ1EsWUFMQWhCLFlBWE9oUCxNQUNVbVM7Z0NBMEJuQixPQTNDSjZRLFNBZ0JhaGpCLEdBMkJDO0tBSFosdUNBeEJXQTtLQUFBQTtLQTZCWCxPQXBERjZpQixjQXVCYTdpQjs7SUErQk47S0FEaUJrakI7S0FBWC9XO0tBQ04sUUFBQSwwQkEvQk1uTSxNQThCQW1NOztTQUVOZ1g7S0FBUSwrQkFBUkEsTUFGaUJEOztnQkF2Q3hCRCwrQkFTYWpqQixHQThCQW1NO0tBU1E7TUFBYmtFLGVBQWEsK0NBVFJsRTtLQVVULHVDQXhDU25NLE1BdUNMcVEsY0FUZ0I2Uzs7SUFXeEIsT0FoRUFMLGNBdUJhN2lCOztZQTJDYm9qQix3QkFBd0JwakIsR0FBSWUsS0FBYW9SO0lBQzNDLEdBRDhCcFIsU0FBU0UsTUFBVEYsUUFBQTZLLFNBQVMzSyxjQUFUMks7SUFDZixPQTVDYjJRLGFBMkN3QnZjLE9BQWlCbVMsT0FBYnZHO0dBQ2tCO1lBRTlDeVgsb0JBQW9CcmpCLEdBQUVtTSxXQUFVZ0csT0FDbEMsT0EvQ0VvSyxhQThDb0J2YyxPQUFFbU0sV0FBVWdHO0dBQ2E7WUFFN0NtUixxQkFBc0JsUyxTQUFRcFIsR0FBRW9iLFFBQU9qSixPQUFNcEQ7SUFDL0MsU0FEd0JxQztLQUN4QixNQUFBO0lBQ0EsOEJBRmtDZ0ssUUFBT2pKLE9BQU1wRDtJQUUvQyxPQTFFRThULGNBd0U4QjdpQjtHQUdqQjtZQUVieWMsV0FBV3pjLEdBQUV5VDtJQUNSLGVBL0VMYixVQThFVzVTO2VBQ047SUFFUSxJQUFUNEwsU0FBUywrQkFIQTZIO0lBSWIsT0FmQTJQLHdCQVdXcGpCLE9BR1A0TDtHQUNzRDtZQUUxRDJYLGdCQUFnQnZqQixHQUFFVixJQUFJaVUsUUFBT0M7SUFDL0IsR0FEd0JELFFBQU52VCxPQUFBQTtJQVFsQixPQUFBLDBCQVJrQkEsTUFBRVYsSUFBV2tVO0dBUWU7WUFFNUNnUSxtQkFHQ3hqQixHQUFFb2IsUUFXVTNiO2FBVlhna0IseUJBQXlCdFgsV0FBVTFNO0tBQ2xCLElBQWYyaUIsZUFBZSwwQkFGaEJoSCxRQUNrQzNiO0tBRXJDLEtBREkyaUI7TUFDSixNQUFBO0tBQ2lCO01BQWJwUyxhQUFhLCtDQUhVN0Q7S0FJM0IsT0FBQSx1Q0FMQ25NLE1BSUdnUSxZQUhpQ3ZRO0lBSVc7bUJBRS9DLDZCQUlZQTs7SUFERztLQURaVztLQUNBK0wsWUFBWSx5QkFWYmlQO0tBV1V4VCxNQUFBbkk7SUFDWDtLQUFHLEtBQUEsaUJBRFFtSSxLQUZUeEg7TUFSRnFqQix5QkFTRXRYLFdBQ1N2RTtNQU9iLE9BbEhBaWIsY0FnR0M3aUI7O0tBQ0N5akIseUJBU0V0WCxXQURBL0w7S0FNSyxJQUpJc2pCLE1BQUE5YixNQUZUeEgscUJBRVN3SCxNQUFBOGI7O0dBUUc7WUFFaEJqSixtQkFBbUJ6YSxHQUFFMmpCO0lBQ1EsSUFBM0JDLDJCQURpQjVqQjtTQUFBQSxTQU9uQjtJQUN5QjtNQUFBOztRQVB2QjRqQjs7S0FwREZSLHdCQW1EbUJwakI7S0FnQm5COztJQWhCbUJBLFFBQ2pCNGpCO0lBMEJFO0ssT0E3REpMLGdCQWtDbUJ2akIsR0FDakI0akI7O0lBcUJBO0tBREVUO09BQ0Y7O1NBckJBUztTQURpQjVqQjtTQUFBQTtTQUFBQTs7O0lBbUNqQjs7TUFuQ2lCQTttQkFBRTJqQjtNQUFGM2pCO01BQUFBO01BcUJmbWpCO0lBd0JKLFdBeEJJQTtHQXdCRztZQUVQVSxlQUFlN2pCLEdBQUc4akIsWUFBVzFJLFFBQU9nQixlQUFjdFM7SUFDcEQsSUFBcUNxWixPQUROL0g7SUFRMUIsT0FBQSw2QkFSWXBiLGNBQUFBO2dCQUFBQTtlQS9GZnFqQixvQkErRmVyakIsR0FDb0JtakI7ZUFoR25DRSxvQkErRmVyakIsR0FDb0JtakI7SUFBQUEsbUJBREMvRztJQUFyQnBjLE9BQUFBO0lBZ0NULFlBQUEsaUNBaEM0QzhKOztLQXFDaEQsT0FqSUZ3Wix3QkE0RmV0akIsR0FDb0JtakI7SUE4QzFCOztLQVRhM1o7S0FBTkQ7S0FBTkQ7S0FTRCxVQUFBLGdDQS9DeUNROztTQWdEdkMvRztLQUFLLE9BNUloQnVnQix3QkE0RmV0akIsR0FDb0JtakIsTUErQ3hCcGdCOztJQUcyQjtLQUFBLE9BQUEsc0NBYjVCdUc7S0FZRjhIO09BQ0Ysb0NBbkQ0Q3RILFVBc0M1Qk4sY0FBTkQ7SUFlWixHQXJEY3VhO1NBcURWeEo7O0tBS0U7O2lCQUVNclU7U0FNSixXQWpFdUJrZDs7VUF4RW5DSyxtQkF1RWV4akIsR0FBQUEsTUE0RENpRztVQVFGLE9BM0lkdWQsbUJBdUVleGpCLEdBQWNvYixRQTREYm5WOztTQVU4QjtRQUFFO01BWnRDLE9BQUEsMkJBMURLakc7TUFxRFBzYSxlQUlBO0lBZWUsSUFBZmtCLGVBQWUsNkJBdEJmcEssU0FHQWtKO0lBb0JKLEdBekVjd0o7S0FDaUJYLGtCQXVFM0IzSCxlQXhFNEJZO0tBaUY5QixpQ0E1QkU5Qjs7O0tBcEQyQjZJLHNCQXVFM0IzSCxnQkF4RTRCWTtJQW9GaEMsV0FwRldwYyxNQUNvQm1qQjtJQW1GL0IsT0F4UEpOLGNBb0tlN2lCO0dBcUZNO1lBRXJCK2pCO0lBQ0EvakIsR0FDRWUsS0FDRnFhLFFBQ0FnQixlQUNBNEgsaUJBQ0E1WCxPQUNBK0s7SUFFRixHQVBJcFcsU0FBY0UsTUFBZEYsUUFBQWtqQixjQUFjaGpCLGNBQWRnakI7SUFPSjtLQUNxQ2QsT0FQbkMvSDtLQVFFOEksY0FBYyw4QkFMaEI5WDtLQVVFK1g7T0FDRjswQkFaQUgsbUNBRUE3TTtJQVlGLEtBUkkrTSxhQU5GRixxQkFXRUc7SUFmRm5rQjtJQXFCbUIsSUFBZm9rQixnQkFBZSw0QkFOakJEO0lBT0YsT0FESUM7O21CQUFBQTs7WUFFVXRhO1FBQ1osS0F2QkFtYTtTQURGamtCLE9BU21DbWpCO1NBK0IvQixPQWhJSlU7a0JBd0ZBN2pCLEdBSUFna0Isb0JBRkE1SSxRQUNBZ0IsZUFvQmN0Uzs7UUF1QkosS0FBQSxpQ0F2QklBO1NBaUNWLE9BNU9Kd1osd0JBb0xBdGpCLEdBU21DbWpCO1FBdUMvQiw4QkF2QytCQSxNQWNyQnJaO1FBMEJTLElBQWZ3USxlQUFlLDZCQXhDWTZJO1FBeUMvQixPQUFBLGlDQURJN0k7Ozs7V0FhTXJhLFVBekNWbWtCO09BMENGLE9BelBGaEIsd0JBMExBcGpCLE9BOERjQzs7SUFEWixPQXZQRm1qQix3QkEwTEFwakI7R0FnRThDO1lBRTlDcWtCO0k7SyxPQW5FQU47O1lBcUVBTyxZQUFZdGtCLEdBQUdtTyxVQUFTaEM7SUFDMUIsS0FBMEIsMENBREFBLFdBQVpuTSxPQTlQWm9qQix3QkE4UFlwakIsVUFTWjtJQVFNLFlBQUEsMEJBakJNQSxNQUFZbU07a0JBb0NqQmlQLG1CQUFBQSxZQXBDS3BiLFNBaURWLFdBYktvYjtJQVhEO0ssT0F0UU5tSSxnQkE2T1l2akIsR0FBWW1NOztJQW9CcEI7S0FERWdYO09BQ0YsK0JBcEJvQmhYLFdBQVpuTSxTQUFBQSxNQUFBQTtLQTJCTnliO09BQ0YsMEJBNUJRemIsTUFBR21PLFVBQUhuTyxTQUFBQSxTQW1CTm1qQjtJQWdCSixXQVJJMUg7R0FzQk87WUFFYjhJO0lBQTRCdmtCLEdBQUVpTSxjQUFhbVAsUUFBT2pFO0lBQ3BEO0tBQXFDZ00sT0FEUS9IO0tBRXZDalAsWUFGMEJGO0tBRVRHLFFBRlNIO0tBRzVCaVksY0FBYyw4QkFESzlYO0tBRW5Cb1ksdUJBQXVCLDJCQUp5QnJOO0tBS2hEc047T0FGQVAsY0FDQU0sMkJBQUFBO0tBY2EsT0FBQSw4QkFoQk1wWTtLQWVmLE9BQUEsb0NBakJzQnBNO0tBYTFCZ2tCO1dBRUUsZ0NBVkZTO0lBb0JBLG9CLE9BdlJGaEssbUJBOFA0QnphO0lBc0I1QixJQURFb2MsZ0JBQ0YsNkJBdEI0QnBjLE9BQUFBO0lBQ09takIsc0JBWWpDYSxtQkFRQTVIO1dBbEJBOEgsYUFIMEJsa0IsWUFFeEJtTTtJQTRCTixPQXRKRTRYO2FBd0g0Qi9qQjs7YUFBZW9iO2FBcUJ6Q2dCO2FBUkE0SDthQVhtQjVYO2FBRjZCK0s7R0FvQ3JDO1lBRWJ1TjtJQUF3QjFrQixHQUFFb2IsUUFBT2dCLGVBQWNuUSxjQUFha0w7SUFDOUQ7S0FBcUNnTSxPQURUL0g7S0FFdEJqUCxZQUYyQ0Y7S0FFMUJHLFFBRjBCSDtLQUc3QzZYLGFBQWEsOEJBRE0xWDtJQUV2QixLQURJMFgsWUFTRixPQTdWQVIsd0JBaVZ3QnRqQixHQUNXbWpCO0lBZXBCO0tBQUEsT0FBQSxvQ0FoQlNuakI7S0FjcEJna0Isc0JBRUUsc0NBYkpGO0lBSCtCMUgsdUJBYzdCNEg7V0FRVSw4QkFwQk81WCxRQUZHcE0sWUFFcEJtTTtJQXVCSixPQXBIQWtZLHVCQTJGd0Jya0I7YUFBRW9iLFFBQU9nQixlQWM3QjRILGlCQVppQjVYLE9BRnVDK0s7R0ErQjdDO1lBRWZ3TixzQkFBc0Iza0IsVUFBNkJtTyxVQUFTZ0o7SUFDOUQ7S0FENEJsTDtLQUN0QkUsWUFEc0JGO0tBRXRCdUIsb0JBRitDVztJQUczQixLQUFBLDBDQUZwQmhDO0tBU0osT0FsWUFpWCx3QkF3WHNCcGpCO0lBV0c7TUFBQSwwQ0FUckJ3TixtQkFEQXJCO0tBZUosT0FyWUFrWCxvQkFxWHNCcmpCLEdBQ2xCbU07SUFpQkUsWUFBQSwwQkFsQmdCbk0sTUFDbEJtTTs7S0FtQkssY0E5SVRtWSxZQTBIc0J0a0IsR0FBNkJtTyxVQUMvQ2hDO21CQXNCUTtTQUZIeVk7S0FDTCxPQTdGSkw7Y0F1RXNCdmtCLEdBQUlpTSxjQXFCakIyWSxRQXJCbUR6Tjs7SUF5QjFELElBREtpRSxtQkFBaUMrSCxPQUFqQy9ILFdBQ0wsT0FEc0MrSDs7S0FNN0IsY0F4SlhtQixZQTBIc0J0a0IsR0FBNkJtTyxVQUMvQ2hDO21CQWdDVTtTQUZIMFk7S0FDTCxPQXZHTk47Y0F1RXNCdmtCLEdBQUlpTSxjQStCZjRZLFFBL0JpRDFOOzs7Ozs7Ozs7Ozs7O2FBd0NWaUY7U0F6RWxEc0k7V0FpQ3NCMWtCLEdBd0Jmb2IsUUFnQjJDZ0IsZUF4Q3hCblEsY0FBa0NrTDtTQXlDeEQsT0FBQSwrQkFqQm9DZ007O1FBYXBDLE1BQUE7Ozs7OztLQWlDQSxPQTliSkMsd0JBd1hzQnBqQjs7SUEyRGxCLE9BaGJKcWpCLG9CQXFYc0JyakIsR0FDbEJtTTs7WUF1RUoyWSxtQkFBbUI5a0IsVUFBNEJxTjtJQUNqRDtLQUR5QnBCO0tBRU5FLFlBRk1GO0tBRW5CRyxRQUZtQkg7S0FpQm5CSSxpQkFqQm1CSjtJQUdsQixLQUFBLDBDQURZRTtLQVFqQixPQTFjQWlYLHdCQWdjbUJwakI7SUFrQm5CLDBCQWxCbUJBLE1BaUJmcU07SUFFRSxZQUFBLDBCQW5CYXJNLE1BRUZtTTs7S0FvSFIsZUExbUJUOFcsK0JBb2ZtQmpqQixHQUVGbU07bUJBbGNqQmlYLHdCQWdjbUJwakI7O0lBcUJqQixJQURLb2IsbUJBQVUyQyxhQUFWM0MsV0FDTCxPQURlMkM7aUNBc0ViLE9BMWhCSnFGLHdCQWdjbUJwakI7Ozs7Ozs7U0F1Qkk7VUFEd0JvYztVQUFmWjtVQUN4QmxCLGVBQWUsNkJBSE55RDtVQVFQLE9BQUEsb0JBQVEsMkJBNUI2QjFRO1NBc0JmbU8sa0JBSXhCLGVBSndCQTthQU94QnBLLFVBUHdCb0s7U0FRVixLQUFBLDBCQTlCSHhiLE1Bb0Jab2IsUUFISC9PO1VBdGJKbVgsbUJBcWFtQnhqQixHQUFBQSxNQWlCZnFNO1VBbUJFLE9BamVOZ1gsb0JBNmJtQnJqQixHQUVGbU07O1NBcUNYLDBCQW5CQ2lQLFFBSEgvTztTQXVCUSxjQUFBLGdDQVhKK0U7O2NBWU9uTDtVQUVGLE9BQUEsNkJBckJtQnVWLGlCQW1CakJ2VjtXQTljZnVkLG1CQXFhbUJ4akIsR0FBQUEsTUFpQmZxTTtXQThCSSxPQXplUmlYLHdCQTBibUJ0akIsR0FvQkYrZDs7O1NBa0NRLElBQWIrRixhQUFhLDhCQXBEckIxWDtTQXFESSxHQURJMFg7VUFTQyxHQUFBLDhCQTNDSS9GO1dBQUFBLHdCQUVldkMsZUFBZVk7O1dBK0NoQywrQkFqREUyQjtTQTJESyxJQUFWOWEsVUFBVSxnQ0F4RGRxWDtnQkF5RE8sd0JBREhyWDtVQUdGLHdCQUhFQSxlQS9FbUNvSzthQXNEbkN5VyxZQTZCaUIsaUNBNURyQnhKOztTQTREcUIsT0FBQSw4QkEvRFp5RDs7Ozs7Ozs7OztRQStFYixPQXhnQkp5RixtQkFxYW1CeGpCLEdBQUFBLE1BaUJmcU07Ozs7SUF0YkptWCxtQkFxYW1CeGpCLEdBQUFBLE1BaUJmcU07SUE4RkEsT0E1aUJKZ1gsb0JBNmJtQnJqQixHQUVGbU07O1lBNEhqQjRZLHVCQUF1Qi9rQixVQUE0Qm1PO0lBQ3JEO0tBRDZCbEM7S0FDdkJFLFlBRHVCRjtLQUV2QnVCLG9CQUYrQ1c7SUFHOUMsS0FBQSwwQ0FGRGhDO0tBU0osT0F4a0JBaVgsd0JBOGpCdUJwakI7SUFXRTtNQUFBLDBDQVZyQm1NLFdBQ0FxQjtLQWNKLE9BM2tCQTZWLG9CQTJqQnVCcmpCLEdBQ25CbU07SUFpQkUsWUFBQSwwQkFsQmlCbk0sTUFDbkJtTTs7U0FrQkdpUDtLQUFVLE9BQUEsMEJBbkJNcGIsTUFBNEJtTyxVQW1CNUNpTjs7SUFZRSxlQWpwQlQ2SCwrQkFrbkJ1QmpqQixHQUNuQm1NOztLQXNDSTtNQUFBOztTLE9BcGxCUm9YLGdCQTZpQnVCdmpCLEdBQ25CbU07O01BZ0NJZ1g7UUFDRiwrQkFqQ0ZoWCxXQURtQm5NLFNBQUFBLE1BQUFBO0tBMENqQiwwQkExQ2lCQSxNQUE0Qm1PLFVBQTVCbk8sU0FBQUEsU0FpQ2ZtakI7Ozs7O0lBU0Y7O1lBU042Qix5QkFBeUJobEIsVUFBNEIrTztJQUN2RCxJQUQrQjlDLHlCQUN6QkUsWUFEeUJGO0lBRXhCLEtBQUEsMENBRERFO0tBUUosT0ExbkJBaVgsd0JBaW5CeUJwakI7SUFXbkIsWUFBQSwwQkFYbUJBLE1BQ3JCbU07O1NBV0dnWDttQkFBQUE7ZUE3bkJQQyx3QkFpbkJ5QnBqQjtlQXFDSywrQkF6QnZCbWpCLFVBWjhDcFU7O0lBMEM1QyxlQS9zQlRrVSwrQkFxcUJ5QmpqQixHQUNyQm1NO2tCQWxuQkppWCx3QkFpbkJ5QnBqQjs7WUF1RHpCaWxCLG9CQUFvQmpsQixHQUFFZ0I7SUFDeEIsVUFEc0JoQjtpQkFTWjZCLEtBQWtCUTtLQUNyQixPQURxQkE7O1lBRU05RCxJQUZOOEQ7UUFPbkIsb0NBaEJhckMsT0FXWXpCO1FBTXpCLFdBTnlCQSxHQUZ4QnNELFFBQUFBLFFBQUFBLFFBQUFBLFFBQUFBOztZQVNVUyxNQVRRRDtRQVluQixXQVpDUixjQVNVUyxhQVRWVCxRQUFBQSxRQUFBQSxRQUFBQTs7WUFhb0JVLE1BYkZGO1FBYU8sV0FiekJSLFFBQUFBLFFBYW9CVSxLQWJwQlYsUUFBQUEsUUFBQUE7O1FBdUJEO1NBVGtCVyxVQWRDSDtTQXVCZjZpQixVQXZCSHJqQjtTQXdCRzZmLFNBVmNsZixVQVNkMGlCO1NBRVUseUJBQWQ7Ozs7cUJBR2E5SjthQU9DLGVBQUEsMEJBUERBLFFBSlRzRztzQkFXa0QsTUFBQTthQUF4QztZQUFtRDtTQVI5RCwwQkFwQ1UxaEI7Ozs7O1NBeHFCcEJvakI7V0F3cUJvQnBqQjtlQW9EUDs7O1FBSU4sV0EvQ0M2QixRQUFBQSxRQUFBQSxRQWNpQlcsU0FkakJYLFFBQUFBOztRQW9ERDtTQUphWSxNQWhETUo7U0FvRG5COztZQUNLO2FBQWUwYjthQUNiLE1BQUEsOEJBRGFBO2FBQ2IsY0FEYUEsZ0JBTFB0Yjs7V0FPMkI7UUFIeEMsMEJBN0RhekM7UUFrRWIsV0F6REM2QixRQUFBQSxRQUFBQSxRQUFBQSxRQWdEWVksS0FoRFpaOztZQTBEaUJhLE1BMURDTDtRQTBESSxXQTFEdEJSLFFBQUFBLFFBQUFBLFFBQUFBLFFBQUFBLFlBMERpQmE7O0lBQStDO0lBM0R4RSxJQURFeWlCLGVBQ0Ysc0NBUnNCbmtCO0lBQUZoQixPQU9sQm1sQjs7R0FnRXNCO1lBRXhCM1cscUJBQXFCeE8sR0FBR29sQixLQUFJcGtCO0lBQzlCO0tBQUlvTDtPQURzQmdaO1VBRUw7O0tBRWpCcFY7T0FBYTs7O2FBSGI1RDs7O0lBSUosdUNBTHVCcE0sTUFJbkJnUSxZQUowQmhQO2tCQUFKb2tCLGtCQUFIcGxCLFFBQUFBOztHQVN1QjtZQUU1Q3FsQix1QkFBdUJybEIsVUFBNEJnQjtJQUNyRCxJQUQ2QmlMLHlCQUN2QkcsUUFEdUJIO0lBSW5CLEdBQUEsOEJBSEpHO0tBRG1CcE0sUUFBQUE7ZUFBQUE7a0JBNXZCdkJvakIsd0JBNHZCdUJwakI7O0lBY2pCLFlBQUEsb0NBZDZDZ0I7O0tBcEZuRGlrQixvQkFvRnVCamxCLEdBQTRCZ0I7S0FYbkR3TixxQkFXdUJ4TztLQXdCckIsT0F0MUJGNmlCLGNBOHpCdUI3aUI7O1FBMEJmbVM7SUFBUyxPQWowQmpCb0ssYUF1eUJ1QnZjLEdBMEJmbVM7O1lBRVJtVCxtQkFBbUJ0bEIsVUFBNEI2TztJQUNqRDtLQUR5QjVDO0tBQ25CRyxRQURtQkg7S0FNbEIsVUFBQSw4QkFMREc7Y0FLQztJQWFNOztLQUFBLFVBQU87S0FOZDRELGFBQ0Y7SUFZRix1Q0ExQm1CaFEsTUFhZmdRLGVBYjJDbkI7SUEwQi9DLE9BcDNCQWdVLGNBMDFCbUI3aUI7O1lBNkJuQnVsQixxQkFBcUJ2bEIsR0FBRTZZLGNBQTBCZ0MsTUFBSzFJO0lBQ3hEO0tBR0lsTSxNQUZJLDJCQUYyQzRVO0tBQy9DalAsZUFHQTNGLGNBQVksMkJBSm1DNFUsU0FJL0M1VTtJQUlKLE9BN3pCRW1kLHdCQXF6QnFCcGpCLEdBQ25CNEwsUUFEb0R1RztHQVFqQjtZQUVyQ3FULHFCQUdDeGxCLEdBQUVvYixRQUFPcUs7SUFDWjtLQUNJQyxVQUFVLDBCQUZUdEssUUFBT3FLO0tBR1J0WixZQUFZLHlCQUhYaVA7SUFJTCxTQUpLQTtTQU1ZdUcsT0FOWnZHLFdBSUR1SyxXQUVhaEU7O1NBQ0pGLFNBUFJyRyxXQUlEdUssV0FHU2xFO0lBRWIsS0FQSWlFO0tBY0ksT0FBQSwwQ0FiSnZaO2VBcjBCRmlYO2dCQWswQkNwakI7O2lCQXFCRzs7ZUFwMUJKcWpCLG9CQSt6QkNyakIsR0FHQ21NO2tCQVFDLDZCQVBEd1o7aUJBeDRCRjlDLGNBbzRCQzdpQjtHQXlCNkQ7WUFFOUQ0bEIsNEJBQTRCNWxCLFVBQTRCNmxCO0lBQzFELElBRGtDNVoseUJBRTVCRSxZQUY0QkY7SUFRL0IsR0FBQSwwQ0FOR0U7S0FPRCxPQXZDSHFaLHFCQThCNEJ4bEIsR0FBQUEsTUFBNEI2bEI7SUFXbEQsWUFBQSwwQkFYc0I3bEIsTUFFeEJtTTs7S0FXRjtNQURLbVM7TUFBVVAsYUFBVk87TUFDTCxNQURlUDs7ZUF6MkJqQnFGLHdCQTYxQjRCcGpCOzs7O2lCQTlCNUJ3bEIscUJBOEI0QnhsQixHQVlyQnNlLGFBWmlEdUg7O0lBc0MvQyxjQXY3QlQ1QywrQkFpNUI0QmpqQixHQUV4Qm1NO2lCQS8xQkppWCx3QkE2MUI0QnBqQjs7WUE4QzVCOGxCLDJCQUEyQjlsQixVQUE0Qm1YO0lBQ3pEO0tBRGlDbEw7S0FDM0JFLFlBRDJCRjtLQUNWRyxRQURVSDtJQUUxQixLQUFBLDBDQURERTtLQVFKLE9BcDVCQWlYLHdCQTI0QjJCcGpCO0lBV3JCLFlBQUEsMEJBWHFCQSxNQUN2Qm1NO2dCQWlERixPQTc3QkZpWCx3QkEyNEIyQnBqQjtJQWF6QixJQURLb2IsbUJBQW9CMkMsYUFBcEIzQyxXQUNMLE1BRHlCMkM7Ozs7Ozs7WUFFd0IzQix3QkFBbEI0SDtRQUM3QixPQWp1QkpEO2lCQWt0QjJCL2pCOztpQkFZcEJvYjtpQkFFNENnQjtpQkFBbEI0SDtpQkFiWjVYO2lCQURrQytLOztXQXdCL0M0TyxvQ0FBQUE7O1lBQTBCQztRQUU5QixPQXpxQkozQix1QkErb0IyQnJrQjtpQkFZcEJvYjtpQkFZQzJLO2lCQUEwQkM7aUJBdkJiNVo7aUJBRGtDK0s7Ozs7O0lBMkNuRCxPQXQ3QkppTSx3QkEyNEIyQnBqQjs7WUFvRDNCaW1CLDZCQUFpQzlULE9BQU0rVDtJQUN6QyxVQURtQy9UO1NBQy9CbFMsVUFJQSxnQ0FMK0JrUzs7U0FHMUJzQixNQUgwQnRCLFVBQy9CbFMsVUFFWSwrQkFBUHdUO0lBSUUsSUFBUHZHLE9BQU8sV0FQOEJnWjtJQVF6QyxnQ0FESWhaLFlBTkFqTjtJQU9KLE9BQUEsaUNBRElpTjtHQUVrQjtZQUVwQnFDLHlCQUF5QnZQO0lBSTNCLElBQUlnQixXQUFXLGlDQUpZaEIsT0FRM0IsTUFSMkJBO0lBQUFBOztJQXpOekJ3TyxxQkF5TnlCeE8sTUFJdkJnQjtJQWtCRCxVQUFBLGlCQXRCd0JoQjtJQXNCeEIsVUFBQTtJQUdDLElBREVtbUIsT0F4QnFCbm1CO0lBNkJ6QixPQTU4QkF3akIsbUJBKzZCeUJ4akIsR0FBQUEsTUF3QnJCbW1CO0dBSytCO1lBRW5DQyxlQUFnQkMsS0FBS0MsUUFBUXBULGVBQWNxVDtJQUM3QztLQUFJdmxCLFdBQVcsK0JBRFFzbEI7S0FFbkI3WixTQUFTLHNDQURUekw7S0FFSXdsQjs7S0FVSnZOO0tBb0RBalo7O01BOURJd21CO2VBQTJCQyxZQUFXbmxCO09BQzVDLHVCQTZERXRCOzs7WUE3REVzRyxNQTZERnRHOzsyQ0E3REVzRyxNQTZERnRHO1lBN0RFc0csc0NBNkRGdEc7O2NBakVjcW1CLEtBL0JoQjlXLHlCQW1DSWpKO09BS1ksT0F0UGhCK2UsdUJBaVBJL2UsS0FENkJtZ0IsWUFBV25sQjtNQVNLOztNQUMvQzJYO2VBQWM5VjtPQUNoQix1QkFtREVuRDs7O1lBbkRFc0csTUFtREZ0Rzs7MkNBbkRFc0csTUFtREZ0RztZQW5ERXNHLHNDQW1ERnRHOztPQWxERixTQUZnQm1ELFVBR1JKLElBSFFJLE1BR0gsT0FwaUNib1osYUFraUNJalcsS0FFSXZEO09BRU47UUFERzhWLFFBSlcxVjtRQUlSdVYsZ0JBQUhHO1FBQXdCNU0sZUFBeEI0TTtRQUNILFFBSkV2Uzs7O1lBS0s2Rjs7VUFDd0I7MkNBRHhCQSxXQUZvQkY7bUJBQUFBOztRQVd6QixPQXJnQ0ptWCx3QkF1L0JJOWM7O2NBR0lvUzs7Y0FxQkczQixLQXJCSDJCO1VBcUJTLE9BL2tCakJvTSxtQkF1akJJeGUsS0FHQ3VTLE9BcUJNOUI7O2NBRmNJLGdCQW5CakJ1QixrQkFtQk92SyxXQW5CUHVLO1VBb0JGLE9BdHBCTmlNLHNCQStuQklyZSxLQUdDdVMsT0FtQlUxSyxVQUFVZ0o7O2NBR1Z1UCxhQXRCUGhPO1VBc0JtQixPQWxkM0JxTSx1QkF5Ykl6ZSxLQUdDdVMsT0FzQlU2Tjs7Y0FDQzNYLGFBdkJSMko7VUF1QnNCLE9BaGE5QnNNLHlCQXNZSTFlLEtBR0N1UyxPQXVCVzlKOztjQUNEL04sV0F4QlAwWDtVQXdCbUIsT0F0UjNCMk0sdUJBMlBJL2UsS0FHQ3VTLE9Bd0JVN1g7O1VBTVQsT0F4aENOb2lCLHdCQXUvQkk5Yzs7Y0FxQ091VSxPQWxDSG5DO1VBa0NXLE9BcFFuQjRNLG1CQStOSWhmLEtBR0N1UyxPQWtDTWdDOzs7V0FDMEI4TCxTQW5DN0JqTztXQW1Dc0J2RyxRQW5DdEJ1RztXQW1DTXhHLGlCQW5DTndHO1VBb0NGLE9Bek9ONk07bUJBa01JamYsS0FHQ3VTLE9BbUNTM0csZ0JBQXVCeVUsUUFBUHhVOztjQUVYaEQsY0FyQ1h1SjtVQXNDRixPQW5NTmtOLDRCQTBKSXRmLEtBR0N1UyxPQXFDYzFKOztjQUVBeVgsa0JBdkNYbE87VUF3Q0YsT0F2Sk5vTiwyQkE0R0l4ZixLQUdDdVMsT0F1Q2MrTjtrQkFRYjs7TUFBSTs7TUFDUjVtQjs7O1FBb0JpQztTQUFBLE1BQUEsb0NBcEZqQ2dCO1NBbUZpQyxNQUFBLG9DQW5GakNBO1NBNEVZLE1BQUE7UUFWWjtnQkFsRUFBO2dCQW9FSTs7a0JBcEVKQTtrQkFFSXdsQjtrQkFVSnZOO2dCQVhBeE07Z0JBRm1CNlo7Z0JBQXNCQztnQkFBZHJUOzs7Ozs7Ozs7OzsyQkFpRTNCbFQ7MkJBQUFBO21DQXVCSixPQXZCSUE7SUF1QkosT0FBQSxnQ0F2QklBO0dBdUJRO1lBRVY4SyxPQUNFL0osVUFFRndsQjtJQUdGLEdBTEl4bEI7U0FBU0UsTUFBVEYsUUFBQXVsQixTQUFTcmxCOztTQUFUcWxCO0lBS0o7U0FKb0IxVyxnQkFBaEJzRCxnQkFBZ0J0RDs7U0FBaEJzRCxnQkF0SUYrUztJQTBJRixPQWhHRUcsa0JBMkZFRSxRQUNBcFQsZUFDRnFUO0dBRzhEO1lBRTlETSxtQkFBbUI3bUIsR0FBRThKLFNBQVFnZDtJQUt6QixZQWwxQkp4QyxZQTYwQm1CdGtCO2dCQXVDWDtRQWpDSG9iLG1CQUFpQytILE9BQWpDL0g7SUFLRCxrQixPQW5pQ0pYLG1CQXdoQ21CemE7SUFRakIsSUFERW9jLGdCQUNGLDZCQVJpQnBjLE9BQUFBO0lBQUFBLE9BTW1CbWpCO0lBUXhCO0tBQVZ6TixVQUFVLHNDQWRlb1I7S0FlekJoRCxtQkFEQXBPO0lBdi9CSm1PLGVBeStCbUI3akIsR0FlZjhqQixZQVRDMUksUUFDRGdCLGVBUGlCdFM7SUFpQlA7S0FBVnNILFVBQVUsNkJBWHdCK1I7S0FZbEM3SSxlQUFlLDZCQVptQjZJO0tBYWxDM0gsZUFBZSw2QkFGZnBLLFNBQ0FrSjtJQUNBa0I7S0FFSyxlQUZMQSxpQkFFeUMsb0JBUHpDOUY7SUFSa0N5TixrQkFhbEMzSCxlQVpBWTtrQkFRQTBIOztLQWVZO01BQVY3Z0IsVUFBVSxnQ0FaWnFYO01BYUssVUFBQSx3QkFESHJYOzs7OztVQUlBLElBQWlDZ0QsZ0JBQUxnSCxnQkFBckJlO1VBQ0osT0FBQSx3QkFMSC9LLGFBSTRCZ0ssVUFBS2hILE1BQTFCK0g7U0FDZ0Q7TUFGekQsaUNBakN5QjhZO01BaUN6QixPQUFBLGlDQWZBeE07Ozs7OztJQWFLO0dBUUM7WUFnQlZ5TSxXQUNFaG1CLFVBRURpbUIsbUJBRURUO0ksR0FKRXhsQjtTQUFTRSxNQUFURixRQUFBdWxCLFNBQVNybEI7O1NBQVRxbEI7SUFNSjtTQUxvQjFXLGdCQUFoQnNELGdCQUFnQnREOztTQUFoQnNELGdCQXJNRitTO0lBME1GO1NBSG1CcFcsZ0JBQWZ5SyxlQUFleks7O1NBQWZ5SztJQUdKO0tBQU14USxVQUpIa2Q7S0FjcUMsTUFBQSx1Q0FWbENsZDtLQVVGLE1BQUEsdUNBVkVBOztTQVlZMUsscUJBQWQ0QjtLQUFnQyxHQUFBLGlDQUFsQjVCO01BWVQsWUFBQSxpQ0E1Qk40bkI7NkJBOERPQyxrQkFBTyxXQUFQQTtNQWhDQztPQURKQztPQUNJLFVBQUEsa0NBZFBsbUI7K0JBNkNRZCxrQkFBTyxXQUFQQTtNQTVCSjtPQUZDaW5CO09BQ0M3bEIsZ0JBQ0YsaUNBRkM2bEI7T0FJSSxVQUFBLG9DQUhIN2xCOztPQU1BLElBREV0QixJQWpNVm9tQixrQkEwSkVFLFFBQ0FwVCxlQUdGcVQ7T0EvZEF0QixvQkFrZ0JVamxCLEdBTEZzQjtPQTNOUmlPLHlCQWdPVXZQO09BL0ZWNm1CLG1CQStGVTdtQixHQVJMa25CLFlBNUJINU07T0EwREksV0F0Qkl0YTs7VUF1QkVtUztNQUFTLFdBQU0sOEJBQWZBOzs7SUFJWjs7WUFLQWlWLG9CQUFvQnBuQjtJQUN0QixHQUFHLGtDQURtQkEsT0Ezd0NwQjhpQixnQkEyd0NvQjlpQjtJQUVoQixJQUNKcW5CLFlBREksbUNBRmdCcm5CO2NBR3BCcW5CLHdCQUFpQyxPQUFqQ0E7UUFDT3RrQixJQURQc2tCO0lBeHZDQTlLLGFBcXZDb0J2YyxHQUliK0M7aUJBQUFBO0dBWUM7WUFFUnVrQixLQUFLdG5CLEdBQUUrVyxJQUFJOUosS0FBS2hIO0lBQU0sT0FBQSxtQ0FBakJqRyxNQUFFK1csSUFBSTlKLEtBQUtoSDtHQUE0RDtZQUU1RXNoQixTQUFTdm5CLEdBQUUrVyxJQUFJOUosS0FBS2hIO0lBQ3RCLE9BQUEsbUNBRFdqRyxNQUFFK1csSUFBSTlKLEtBQUtoSDtHQUM4QjtZQVFsRHVoQixhQUFheG5CLEdBQUcrQixHQUFJLE9BQUEsV0FBSkEsTUFBUTtZQUV4QjBsQixxQkFBcUJ6bkI7SUFDdkIsMEJBRHVCQSxVQUFBQSxNQUFBQTtrREFBQUE7R0FFSDtZQUVsQjBuQixvQkFBb0IxbkIsR0FBRStTO0lBQVMsT0FBQSx1Q0FBWC9TLE1BQUUrUztHQUE2QztZQUNuRTRVLGFBQWEzbkIsR0FBRStCO0lBQUksT0FBQSx1Q0FBTi9CLE1BQUUrQjtHQUFzQzs7Ozs7T0FqekNyRDZRO09BQ0FpUTtPQUNBQztPQUVBQztPQUlBQztPQU9BQztPQVNBMUc7T0EyQ0E2RztPQUdBQztPQUdBQztPQUtBN0c7T0FNQThHO09BVUFDO09Bd0JBL0k7T0ErQ0FvSjtPQXVGQUU7T0FtRUFNO09BRUFDO09BbURBQztPQXNDQUc7T0FpQ0FDO09Bd0VBRztPQThIQUM7T0FtREFDO09BdURBQztPQXlFQXpXO09BV0E2VztPQTRCQUM7T0E2QkFDO09BVUFDO09BOEJBSTtPQThDQUU7T0FvREFHO09BV0ExVztPQStCQTZXO09BMEZBdGI7T0FRQStiO09BdURBRTtPQXdFQUs7T0FrQkFFO09BRUFDO09BU0FDO09BRUFDO09BSUFDO09BQ0FDOzs7O0U7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQzV6Q0FDLHVCQUF1QnBXLFVBQVM4SjtJQUNsQyxlQUR5QjlKLFVBQVM4SjtHQU0vQjtZQUVEdU0sa0JBQW1CN25CO0lBQ3JCLFVBRHFCQTs7Ozs7Ozs7Ozs7MkRBS1NzYjs7OzswREFBQUE7OztTQUc1QixPQUg0QkE7O1FBSzVCLE9BQUE7O1FBQ1ksT0FBQTs7SUFSWixPQUFBO0dBUW1FO1lBRW5FeUIsYUFBYy9jO0lBRWhCLFVBRmdCQTs7a0NBS2QsK0JBTGNBO0lBVVQ7R0FBRTtZQUVQdWMsYUFBZXZjLEdBQVFzYixlQUFlbkosT0FBZXBEO0lBQ3ZELFVBRGlCL08sbUJBV2Y7T0FYdUJzYjtTQUloQndNLGtCQUpnQnhNO0tBSUMsaUNBQWpCd007O0lBSlE5bkIsT0FNQywrQkFOc0JtUyxPQUFlcEQ7SUFPckQsT0FBQSxXQVBlL08sTUFBdUJtUztHQVdwQztZQUVGcUssZUFBY3hjLEdBQU9tUyxPQUFNcEQ7SUFDN0IsVUFEZ0IvTzs7Ozs7O3dEQVNVOEg7UUFPeEI7Ozs7Ozs7OzsyREFiNEJ3VDs7OzswREFBQUE7OzthQUV4QnZUO1NBQ0osaUNBRElBO1NBbEJKd1UsYUFhY3ZjLE9BR2NzYixnQkFIUG5KLE9BQU1wRDtTQU8zQixPQUFBLCtCQVBjL08sR0FBYStPOztZQVNIakg7Ozs7S0FDeEIsaUNBRHdCQTtLQXRCeEJ5VSxhQWFjdmMsTUFBT21TLE9BQU1wRDtLQVczQixPQUFBLCtCQVhjL08sR0FBYStPOztJQWIzQndOLGFBYWN2YyxNQUFPbVMsT0FBTXBEO0lBbUJwQjtHQUFrQztZQUV6QzZOLGdCQUFpQjVjO0lBQ25CLFVBRG1CQTtnQ0FFVDs7O09BQ007OztlQUdGOztHQUFLO1lBRWpCNmMsbUJBQW9CN2MsR0FBUXdWO0lBQzlCLFVBRHNCeFY7Ozs7VUFFTzhILFlBQUd3UyxlQUFIeFMsTUFBZGlnQjtTQUNWLGlDQUQyQnpOLHFCQUZGOUU7OztnQkFFRThFO2dCQUZWdGE7Z0JBQUFBO2dCQUFRd1Y7Z0JBQVJ4VjtNQVdaLEtBQUEsZ0NBVHNCc2EsZUEwQjVCO01BUm9CO2FBcEJGdGE7T0FvQkUsVUFwQkZBO09BcUJQLFVBQU87T0FIZGdRLGFBQ0Y7TUFLRjttQ0F4QmtCaFEsTUFrQmRnUTtNQWxCY2hRLGVBRVArbkIsZUFBY2pnQjtNQXdCekI7OztJQUdHO0dBQUM7WUFFTnFWLHdCQUF5Qm5kLEdBQU84SjtJQUNsQyxVQUQyQjlKOzs7Ozs7Ozs7Ozs7Ozs7U0FJbkJnb0I7S0FDTixPQUFBLFdBRE1BLGtCQUowQmxlOztJQU0zQixNQUFBO0dBQVk7WUFFakJrVCxvQkFBcUJoZDtJQUN2QixVQUR1QkE7Ozs7Ozs7O3VEQUdPc2I7Ozs7c0RBQUFBOzs7S0FHekIsVUFBQSxpQ0FIeUJBO0tBR3pCLFVBQUE7S0FDRTtNQUNDLFVBQUEsaUNBTHNCQTtNQUt0Qjs7V0FDRnFCO1VBQUFsSiwwQkFBQWtKO01BQU8sT0E3RVhILGVBb0VxQnhjLGdCQVNqQnlUOzs7SUFDQztHQUFFOzs7O09BNUhQbVU7T0FRQUM7T0FhQTlLO09BWUFSO09BYUFDO09BcUJBSTtPQVFBQztPQStCQU07T0FRQUg7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lDNFNJaUw7O0lBOURJQztJQXpGSmpvQjs7O0lBc3FCSmtvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF6OEJJdkY7SUFDQWhHOzs7O2dCQUFBQSxpQkFEQWdHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBT0Z3RixTQUFTcG9CO0lBQUksT0FBTSxxQkFBVkEsYUFBdUQsaUJBQXZEQTtHQUErRDtHQUgvRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQUdUb29CO1lBOEJGQztJQUFxRCxpQ0FBZSxTQUFFO0dBQUM7WUFDdkV6VixVQUFVNVM7SUFBSSxXQUFBLGtDQUFKQTtJQUFJLHFEQUFKQTtHQUEwRDtZQUNwRThpQixnQkFBZ0I5aUI7SUFBSSwwQ0FBSkE7R0FBK0I7WUFFL0M2YyxtQkFBbUI3YztJQUNyQixPQUEwQiwwQkFETEEsVUFBQUEsTUFBQUE7R0FDa0Q7WUFFckUraUIsZ0JBQWdCL2lCO0lBSGhCNmMsbUJBR2dCN2M7SUFFbEIsdUNBRmtCQTtrREFBQUE7R0FHSTtZQUtwQmlqQiwrQkFBZ0NqakIsR0FBRW1NO0lBQ3BDLE9BQUcsMENBRGlDQTt3REFBQUEsV0FBRm5NO3dEQUFFbU0sV0FBRm5NO0dBRzBCO1lBRTFEdWMsYUFLRXZjLEdBQUUrQztJQUNKLFNBRElBO1NBRTRCOFgsT0FGNUI5WCxNQUVxQm9QLFFBRnJCcFAsaUJBQUYvQzs7S0FpQm1CO01BTGJnUDtvQ0FWd0I2TDs7V0FhckIsb0RBYnFCQSxPQUFBQTtNQWV4QjdLO1FBQWE7O01BT1U7UUFBQSwwQ0F4QjdCaFE7O1dBQUFBO0tBbUJFO21DQW5CRkEsTUFpQk1nUSxZQUxBaEIsa0JBVmlCbUQ7S0FGdkJuUztjQUV1Qm1TLE9BNEJoQixXQTlCUG5TLDBCQUV1Qm1TLE9BQU8wSTs7NkJBekJoQ2lJLGdCQXVCRTlpQixJQUhGLE9BZkEraUIsZ0JBa0JFL2lCLEdBa0NpQjtLQUhmLHVDQS9CRkE7bURBQUFBOztJQXFDTztLQURpQmtqQixVQXBDdEJuZ0I7S0FvQ1dvSixZQXBDWHBKO0tBcUNLLFFBQUEsMEJBckNQL0MsTUFvQ2FtTTs7U0FFTm1jO0tBQ0w7MEJBREtBLDBCQUZpQnBGLGdCQUFBQTs7Z0JBOUMxQkQsK0JBVUVqakIsR0FvQ2FtTTtLQVVRO01BQWJrRSxlQUFhLCtDQVZSbEU7S0FXVCx1Q0EvQ0puTSxNQThDUXFRLGNBVmdCNlM7O2tEQXBDeEJsakI7R0FnRHNCO1lBRXhCb2pCLHdCQUF3QnBqQixHQUFJZSxLQUFhb1I7SUFDM0MsR0FEOEJwUixTQUFTRSxNQUFURixRQUFBNkssU0FBUzNLLGNBQVQySztJQUNmLE9BeERiMlEsYUF1RHdCdmMsT0FBaUJtUyxPQUFidkc7R0FDa0I7WUFFOUN5WCxvQkFBb0JyakIsR0FBRW1NLFdBQVVnRyxPQUNsQyxPQTNERW9LLGFBMERvQnZjLE9BQUVtTSxXQUFVZ0c7R0FDYTtZQUU3QzZRLFNBQVNoakIsR0FLWCxPQVhFb2pCLHdCQU1TcGpCLFNBS2lDO1lBRTFDc2pCLHFCQUFxQnRqQixHQUFFb2IsUUFBT2pKLE9BQU1wRDtJQUN0Qyw4QkFEeUJxTSxRQUFPakosT0FBTXBEO2tEQUFmL087R0FFRDtZQUVwQnljLFdBQVd6YyxHQUFFeVQ7SUFDUixlQTVGTGIsVUEyRlc1UztlQUNOO0lBRVEsSUFBVDRMLFNBQVMsK0JBSEE2SDtJQUliLE9BckJBMlAsd0JBaUJXcGpCLE9BR1A0TDtHQUNzRDtZQUUxRDRYLG1CQUdDeGpCLEdBQUVvYixRQVdVM2I7YUFWWGdrQix5QkFBeUJ0WCxXQUFVMU07S0FDbEIsSUFBZjJpQixlQUFlLDBCQUZoQmhILFFBQ2tDM2I7S0FFckMsS0FESTJpQjtNQUNKLE1BQUE7S0FDaUI7TUFBYnBTLGFBQWEsK0NBSFU3RDtLQUkzQixPQUFBLHVDQUxDbk0sTUFJR2dRLFlBSGlDdlE7SUFJVzttQkFFL0MsNkJBSVlBOztJQURHO0tBRFpXO0tBQ0ErTCxZQUFZLHlCQVZiaVA7S0FXVXhULE1BQUFuSTtJQUNYO0tBQUcsS0FBQSxpQkFEUW1JLEtBRlR4SDtNQVJGcWpCLHlCQVNFdFgsV0FDU3ZFO29EQVhaNUg7O0tBQ0N5akIseUJBU0V0WCxXQURBL0w7S0FNSyxJQUpJc2pCLE1BQUE5YixNQUZUeEgscUJBRVN3SCxNQUFBOGI7O0dBUVU7WUFFdkI2RSw0QkFBNEJ2b0IsR0FBRXNvQixPQUFNeGU7SUFLaEMsWUFBQSxpQ0FMZ0NBO2tDQVdwQyxPQXZEQXVaLG9CQTRDNEJyakIsR0FBRXNvQjtJQWFuQjs7S0FEUzllO0tBQU5EO0tBQU5EO0tBQ0prZixTQUFPLHNDQURIbGY7S0FHQyxVQUFBLGlDQWYyQlE7S0FlYSxVQUFBLGdDQWZiQTs7Y0FhaEMwZTtxQkFBQUE7c0JBQUFBO3dCQUFBQSx3QkFBQUE7OzRCQUFBQSxzQkFBQUE7OztvQkFBQUE7c0JBQUFBLHNCQUFBQTs7NkJBQUFBLG9CQUFBQTtLQUsyQztPQUFyQixzQ0FMdEJBO1VBSzJDLHNDQUwzQ0E7O0tBTUYsT0EvREZuRixvQkE0QzRCcmpCLEdBQUVzb0I7Ozs7Ozs7O1dBb0JmcmlCO09BQWEsS0FBQSw2QkFBYkE7UUFpQmIsT0FqRkZvZCxvQkE0QzRCcmpCLEdBQUVzb0I7Ozs7TUE4Q2Q7T0FBVmxYO1NBQVUsb0NBOUNvQnRILFVBWWhCTixRQUNoQmdmLFFBRFVqZjtPQW1DTCxVQUFBLFdBL0NtQnZKLE9BOEN0Qm9SOzJCQXNCRixPQUFBLCtCQXBFMEJrWDtNQW1EUDtPQUhoQkc7T0FHQ25PLGVBQWUsZ0NBbkRLdGE7TUFBRXNvQjs7OztTQThDeEJsWDtTQUtFa0o7U0FIRG1PO3dCOzs7O0lBSkwsT0F4RkZwRixvQkE0QzRCcmpCLEdBQUVzb0I7R0FvRW1CO1lBRWpESTtJQUF3QjFvQixHQUFFb2IsUUFBUTBJLFlBQVc2RSxnQkFBZTdlO0lBQzlEO0tBQXFDd2UsUUFEVGxOO0tBT3RCLFFBQUEsaUNBUHdEdFI7O0tBU3BCO01BRHRDNEI7TUFDc0MsT0FBQSxnQ0FEdENBO01BQ0U4RixXQUFXLHFDQVQ2QzFIO01Ba0JyRCxVQUFBLGdDQWxCcURBOztNQW9CMUQsT0E1SEZ3WixxQkF3R3dCdGpCLEdBQ1dzb0IsdUJBUS9COVc7UUFUOEJzUztVQTBCNUJ4STs7TUFLRTs7a0JBRU1yVjtVQS9IZHVkLG1CQThGd0J4akIsR0FBQUEsTUFpQ1ZpRztVQUNKLE9BaElWdWQsbUJBOEZ3QnhqQixHQUFFb2IsUUFpQ1puVjtTQUUyQjtPQUpqQyxPQUFBLDJCQS9CZ0JqRztPQTBCbEJzYixnQkFJQTtLQVFGO01BREVzTjtRQUNGLDhCQTdCQXBYLFVBaUJFOEo7TUFnQk07UUFBQSwrQkF6Q3VCZ047ZUFvQzdCTTtlQUFBQTtLQXBDNkJOLHFCQURVSztLQThDM0MsV0E5QzJDQSxtQkFTekNuWCxVQWlCRThKO1lBMUI0QndJO2dCQW1EOUI7dUNBekJFeEk7ZUF5QkYsOEJBbEQrQmdOO2VBRER4RTs7SUFpRWxDLE9BektBUixxQkF3R3dCdGpCLEdBQ1dzb0IsdUJBNkQvQnJvQjtHQUdvRTtZQUV4RTRqQixlQUFlN2pCLEdBQUc4akIsWUFBVzFJLFFBQU90UjtJQUN0QyxJQUFxQ3dlLFFBRE5sTjtJQVExQixPQUFBLDZCQVJZcGIsY0FBQUE7Z0JBQUFBO2VBckxmcWpCLG9CQXFMZXJqQixHQUNvQnNvQjtlQXRMbkNqRixvQkFxTGVyakIsR0FDb0Jzb0I7SUFEcEJ0b0IsT0FBQUE7Z0JBQ29Cc29COzs7O1FBQUFBLGdCQWlDakMsT0EzS0ZDLDRCQXlJZXZvQixHQUNvQnNvQixPQURDeGU7O1lBbUNaNmUsMkJBQWRaO1FBbEN5Qk87ZUFrQ3pCUDtxQkFBY1k7cUJBQUFBO1FBS3RCLE9BM0dGRDtpQkFtRWUxb0IsR0FBY29iLFFBQVgwSSxZQW1DTTZFLGdCQW5DWTdlOztJQTJDbEMsTUFBQTtHQUFhO1lBRWZpYTtJQUNBL2pCLEdBQ0VlLEtBQ0ZxYSxRQUNBNEksaUJBQ0E1WCxPQUNBK0s7SUFFRixHQU5JcFcsU0FBY0UsTUFBZEYsUUFBQWtqQixjQUFjaGpCLGNBQWRnakI7SUFNSjtLQUNxQ3FFLFFBTm5DbE47S0FPRThJLGNBQWMsOEJBTGhCOVg7S0FVRStYO09BQ0Y7MEJBWkFILG1DQUVBN007SUFZRixLQVJJK00sYUFORkYscUJBV0VHO0lBZEZua0I7SUFvQm1CLElBQWZva0IsZ0JBQWUsNEJBTmpCRDtJQU9GLE9BRElDOzttQkFBQUE7O1lBRVV0YTtRQUNaLEtBdEJBbWE7YUF5Qk1ILGFBdkJSRTtTQXdCSSxPQXpFSkgsZUE4Q0E3akIsR0EwQlE4akIsWUF4QlIxSSxRQW9CY3RSOztRQU1KLEtBQUEsaUNBTklBO1NBaUJWLE9BaFFKd1oscUJBeU5BdGpCLEdBUW1Dc29CLHVCQThCM0JKO1FBUkosOEJBdEIrQkksT0FjckJ4ZTtRQVNVLElBQWhCd1IsZ0JBQWdCLDhCQXZCV2dOO1FBd0IvQixPQUFBLGlDQURJaE47Ozs7V0FjTXJiLFVBekJWbWtCO09BMEJGLE9BcFJGaEIsd0JBc09BcGpCLE9BNkNjQzs7SUFEWixPQWxSRm1qQix3QkFzT0FwakI7R0ErQzhDO1lBRTlDcWtCO0k7SyxPQWxEQU47O1lBb0RBOEUsdUJBQXVCN29CLEdBQUVvTSxPQUFNK0s7SUFDakM7S0FBSStNLGNBQWMsOEJBRFM5WDtLQUV2Qm9ZLHVCQUF1QiwyQkFGTXJOO0tBRzdCc047T0FGQVAsY0FDQU0sMkJBQUFBO0tBYVcsT0FBQSw4QkFmWXBZO0tBY3JCLE9BQUEsb0NBZG1CcE07SUFXekI7WUFDSSxnQ0FUQXlrQjs7R0FhSDtZQUVDcUU7SUFDQTlvQixHQUNBb2IsUUFDQXVOLGdCQUNBMWMsY0FDQWtMO0lBRUY7S0FBd0I0RyxhQUx0QjNDO0tBTWlCalAsWUFKakJGO0tBSUlHLFFBSkpIO0tBS0UrWCxrQkEzQkY2RSx1QkFtQkE3b0IsR0FPSW9NLE9BSEorSztLQUtFNFIsbUJBREEvRTtLQUdFO09BQUEsK0JBTGtCakc7a0JBR3BCZ0wsZUFQRko7a0JBT0VJLGVBUEZKO0lBSXNCNUs7V0FRakIsOEJBUEQzUixRQVBKcE0sV0FPaUJtTTtJQVNuQixPQXZGRTRYO2FBdUVBL2pCLE1BQ0FvYixRQU9FNEksaUJBREU1WCxPQUhKK0s7R0FZK0Q7WUFFL0R1TjtJQUF3QjFrQixHQUFFb2IsUUFBTzROLGlCQUFnQi9jLGNBQWFrTDtJQUNoRTtLQUFxQ21SLFFBRFRsTjtLQUV0QmpQLFlBRjZDRjtLQUU1QkcsUUFGNEJIO0tBRy9DNlgsYUFBYSw4QkFETTFYO0lBRXZCLEtBREkwWDtLQVlGLE9BaFVBUixxQkFpVHdCdGpCLEdBQ1dzb0IsdUJBVy9CTDtJQU9XO0tBQUEsT0FBQSxvQ0FuQlNqb0I7S0FpQnBCZ2tCLHNCQUVFLHNDQWhCSkY7SUFIK0JrRix5QkFpQjdCaEY7V0FRVSw4QkF2Qk81WCxRQUZHcE0sV0FFcEJtTTtJQTBCSixPQW5FQWtZLHVCQXVDd0Jya0I7YUFBRW9iLFFBaUJ0QjRJLGlCQWZpQjVYLE9BRnlDK0s7R0E0Qks7WUFFbkV3TixzQkFBc0Iza0IsVUFBNEJtWDtJQUNwRDtLQUQ0QmxMO0tBQ3RCRSxZQURzQkY7S0FFdEIsUUFBQSwwQkFGa0JqTSxNQUNsQm1NOztLQVdDO01BQUEsT0FBQSwwQ0FYREEsV0FEa0JuTTtNQVlqQjtlQUFvQywwQ0FYckNtTTtLQVdxQyxjQXJXekNrWCxvQkF5VnNCcmpCLEdBQ2xCbU07O0lBY0osSUFES2lQLG1CQUFvQjJDLGFBQXBCM0MsV0FDTCxPQUR5QjJDO2lDQU12QixPQWhYRnFGLHdCQTRWc0JwakI7Ozs7Ozs7Ozs7Ozs7c0NBcUNNZ3BCOzs7OztxQ0FBQUE7OztTQW5FNUJ0RTtXQThCc0Ixa0IsR0FjakJvYixRQXVCdUI0TixpQkFyQ0YvYyxjQUF3QmtMO1NBd0NoRCxPQUFBLCtCQTFCdUI0Rzs7UUFtQnZCLE1BQUE7O1dBWjJENEs7T0FFM0QsT0F4RUZHO2dCQWlEc0I5b0IsR0FjakJvYixRQU93RHVOLGdCQXJCbkMxYyxjQUF3QmtMOzs7O1FBb0RoRCxPQTdZRmtNLG9CQXlWc0JyakIsR0FDbEJtTTs7O0lBOERGLE9BM1pGaVgsd0JBNFZzQnBqQjs7WUFpRXRCOGtCLG1CQUFtQjlrQixVQUE0QnFOO0lBQ2pEO0tBRHlCcEI7S0FFTkUsWUFGTUY7S0FFbkJHLFFBRm1CSDtLQUdyQkksaUJBSHFCSjtLQUluQixRQUFBLDBCQUplak0sTUFFRm1NOztLQW9IVixlQS9rQlA4VywrQkF5ZG1CampCLEdBRUZtTTttQkEvWmpCaVgsd0JBNlptQnBqQjs7SUFNbkIsSUFES29iLG1CQUFVMkMsYUFBVjNDLFdBQ0wsT0FEZTJDO2lDQXFGYixPQXZmRnFGLHdCQTZabUJwakI7Ozs7Ozs7OzJEQVFTaXBCOzs7OzBEQUFBQTs7O09BRzFCO1FBQXNCM04sZ0JBSEkyTjtRQUdwQnpYLFdBSG9CeVg7UUFHV0Msc0JBSFhEO09BQUFBO1FBT2pCO1VBSjRCQztVQUlKLDRCQUFRLDJCQWZJN2I7T0FtQmhDO1FBRFQ4UztVQUNTLDBCQW5CSW5nQixNQUtkb2IsUUFGSC9PO09BMEJBLDBCQTdCaUJyTSxNQUdqQnFNO09BMEJBLEtBWEk4VDtRQXhaTnFELG1CQXNZbUJ4akIsR0FBQUEsTUFHakJxTTtRQWlDRSxPQTliSmdYLG9CQTBabUJyakIsR0FFRm1NOztPQXFDYiwwQkFsQ0NpUCxRQUZIL087T0FxQ1EsY0FBQSxnQ0E3QkZtRjs7WUE4Qkt2TDtRQUVGLE9BQUEsNkJBbkNpQmdqQixrQkFpQ2ZoakI7U0EvYWJ1ZCxtQkFzWW1CeGpCLEdBQUFBLE1BR2pCcU07U0E0Q0ksT0EvYk5pWDtrQkFnWm1CdGpCLEdBS0orZCw0QkFNUHZNOzs7T0ErQ2U7UUFBYnNTLGFBQWEsOEJBeERuQjFYO1FBa0VNbkosVUFBVSxnQ0F6RElxWTtjQTBEWCx3QkFESHJZO1FBR0Ysd0JBSEVBLGVBcEVxQ29LO1dBMERyQ3lXLFlBY2lCLGlDQTdESHhJOztPQThEbEIsOEJBcEVTeUM7OztVQXFETCtGO2lCQWdCaUIsOEJBckVaL0Y7YUFxREwrRjtxQkEwQkYsK0JBL0VPL0Y7Ozs7Ozs7UUE4RmIsT0F6ZUZ5RixtQkFzWW1CeGpCLEdBQUFBLE1BR2pCcU07Ozs7SUF6WUZtWCxtQkFzWW1CeGpCLEdBQUFBLE1BR2pCcU07SUE0R0EsT0F6Z0JGZ1gsb0JBMFptQnJqQixHQUVGbU07O1lBNEhqQm9YLGdCQUFnQnZqQixHQUFFVixJQUFJaVUsUUFBT0M7SUFDL0IsR0FEd0JELFFBQU52VCxPQUFBQTtJQVFsQixPQUFBLDBCQVJrQkEsTUFBRVYsSUFBV2tVO0dBUWU7WUFFNUN1Uix1QkFBdUIva0IsVUFBNEJtTztJQUNyRDtLQUQ2QmxDO0tBQ3ZCRSxZQUR1QkY7S0FFdkJ1QixvQkFGK0NXO0lBRy9CO01BQUEsMENBRmhCaEMsV0FDQXFCO0tBTUosT0ExaUJBNlYsb0JBa2lCdUJyakIsR0FDbkJtTTtJQVNFLFlBQUEsMEJBVmlCbk0sTUFDbkJtTTtnQkE4QkY7UUFwQktpUDtJQUFVLE9BQUEsMEJBWE1wYixNQUE0Qm1PLFVBVzVDaU47O1lBc0JQNEoseUJBQXlCaGxCLFVBQTRCK087SUFDdkQ7S0FEK0I5QztLQUN6QkUsWUFEeUJGO0tBRXpCLFFBQUEsMEJBRnFCak0sTUFDckJtTTs7S0F3RUcsZUEzc0JQOFcsK0JBa29CeUJqakIsR0FDckJtTTttQkF2a0JKaVgsd0JBc2tCeUJwakI7O0lBSXpCLElBREtzb0Isa0JBQ0wsT0FES0E7aUNBUUgsT0FqbEJGbEYsd0JBc2tCeUJwakI7OztpQkFBNEIrTyw2QkFBQUE7UUFvQnhCLE9BQUEsK0JBakJ4QnVaLFdBSGdEdlo7OztPQTJDbkQ7O0lBaUJBLCtCQXpER3VaLFdBSGdEdlo7SUE0RG5ELE9Bcm5CRnVVO2FBeWpCeUJ0akIsR0FHcEJzb0IsMEJBSGdEdloscUJBQUFBOztZQXFGckRzVyx1QkFBdUJybEIsVUFBNEJnQjtJQUNyRCxJQUQ2QmlMLHlCQUV2QkcsUUFGdUJIO0lBS25CLEdBQUEsOEJBSEpHO0tBRm1CcE0sUUFBQUE7Z0JBQUFBO21CQTNwQnZCb2pCLHdCQTJwQnVCcGpCOztJQWdCakIsWUFBQSxzQ0FoQjZDZ0I7O0tBd0IvQzthQXhCbUJoQjs7aUJBeUJYNkIsS0FBa0JRO1NBQ3JCLE9BRHFCQTs7Z0JBRU05RCxJQUZOOEQ7WUFPbkIsb0NBaENZckMsT0EyQmF6QjtZQU16QixXQU55QkEsR0FGeEJzRCxRQUFBQSxRQUFBQSxRQUFBQSxRQUFBQTs7Z0JBU1VTLE1BVFFEO1lBWW5CO29CQVpDUjswQkFTVVM7b0JBVFZUO29CQUFBQTtvQkFBQUE7b0JBQUFBOztnQkFhb0JVLE1BYkZGO1lBYU8sV0FiekJSLFFBQUFBLFFBYW9CVSxLQWJwQlYsUUFBQUEsUUFBQUE7O1lBNkJZO2FBZktXLFVBZENIO2FBNEJmNmlCLFVBckRRbGxCO2FBc0RSMGhCLFNBZmNsZixVQWNkMGlCO2FBRVUseUJBQWQ7Ozs7eUJBR2E5SjtpQkFPQyxlQUFBLDBCQVBEQSxRQUpUc0c7MEJBV2tELE1BQUE7aUJBQXhDO2dCQUFtRDthQVI5RCwwQkF6RFMxaEI7Ozs7O2FBM3BCdkJvakI7ZUEycEJ1QnBqQjs7Z0JBeUVOOzs7WUFJTixXQXBEQzZCLFFBQUFBLFFBQUFBLFFBY2lCVyxTQWRqQlgsUUFBQUE7O1lBc0REO2FBRGFZLE1BckRNSjthQXNEbkI7O2dCQUNLO2lCQUFlMGI7aUJBQ2IsT0FBQSw4QkFEYUE7aUJBQ2IsZUFEYUEsZ0JBRlB0Yjs7ZUFJMkI7WUFIeEMsMEJBL0VZekM7WUFvRlosV0EzREM2QixRQUFBQSxRQUFBQSxRQUFBQSxRQXFEWVksS0FyRFpaOztnQkE0RGlCYSxNQTVEQ0w7WUE0REksV0E1RHRCUixRQUFBQSxRQUFBQSxRQUFBQSxRQUFBQSxZQTREaUJhOztRQUErQztNQTlEdEV5aUIsZUFDRix3Q0F4QitDbmtCO0tBQTVCaEIsT0F1QmpCbWxCO0tBcUVPOztNQUFBLFdBQU87TUFGZG5WLGFBQ0Y7S0FPRix1Q0FsR3FCaFEsTUEwRmpCZ1E7S0ExRmlCaFEsUUFBQUE7bURBQUFBOztRQXFHZm1TO0lBQVMsT0F2ekJqQm9LLGFBa3RCdUJ2YyxHQXFHZm1TOztZQUVSZ1gsZUFBZW5wQixVQUE0QjBYLG9CQUFtQlA7SUFDaEU7S0FEcUJsTDtLQUNGRSxZQURFRjtLQUNmRyxRQURlSDtJQVdqQjtLLE9BbFBGc1gsZ0JBdU9ldmpCLEdBQTRCMFg7O0lBTTNDO0tBREU0UTtPQUNGOzZCQU4yQzVRLG9CQUE1QjFYLFNBQUFBLE1BQUFBOztLQWlCYm9iO09BQ0Y7O1NBbEJlcGI7c0JBQ0VtTTtTQURGbk07U0FBQUE7U0FLYnNvQjtLQW9CQXRFLGtCQWxnQkY2RSx1QkF5ZWU3b0IsR0FDWG9NLE9BRDBEK0s7SUFLNURtUixtQkFvQkF0RTtXQUVHLDhCQTFCRDVYO0tBRFdwTSxXQUE0QjBYO0lBNkI3QyxPQTFqQkVxTTthQTZoQmUvakIsTUFpQmJvYixRQVFBNEksaUJBeEJFNVgsT0FEMEQrSzs7WUErQjlEaVM7SUFDQXBwQixHQUNBNlksT0FDQW5CLG9CQUNBUDtJQUVGLElBSktsTCxlQUFINE0sVUFJSTFNLFlBSkRGO1NBREhqTSxTQWdCQSxPQWx6QkFvakIsd0JBa3lCQXBqQjtJQW9CNkIsS0FBQSwwQ0FsQjdCMFgsb0JBRkExWDtLQTRCQSxPQTl6QkFvakIsd0JBa3lCQXBqQjthQWlDSXFwQjtLQUNGLE9BcDBCRmpHLHdCQWt5QkFwakI7SUF1QzRCO0lBdkM1QkEsT0FFQTBYO0lBd0NNLFlBQUEsMEJBMUNOMVgsTUFLSW1NO2dCQTJDRixPQWZFa2Q7SUFpQkYsSUFES2Ysa0JBQ0wsT0FES0E7O0tBR0gsT0FwRkphLGVBZ0NBbnBCLEdBQ0E2WSxPQUNBbkIsb0JBQ0FQO0lBa0RTLE9BcEJMa1M7O1lBd0JKL0QsbUJBQW1CdGxCLFVBQTRCNk87SUFDakQsSUFEeUI1Qyx5QkFDbkJHLFFBRG1CSDtJQU10QixLQUFBLDhCQUxHRztLQTJCTzs7TUFBQSxXQUFPO01BTmQ0RCxhQUNGO0tBWUYsdUNBbkNtQmhRLE1Bc0JmZ1EsZUF0QjJDbkI7bURBQTVCN087O0lBUWIsWUFBQSxzQkFSYUE7Z0JBWWpCLE9BdjJCRm9qQix3QkEyMUJtQnBqQjtRQVNac3BCO0lBQVksT0FBQSxXQUFaQSxVQVhQbkI7O1lBd0NBNUMscUJBQXFCdmxCLEdBQUU2WSxjQUEwQmdDLE1BQUsxSTtJQUN4RDtLQUdJbE0sTUFGSSwyQkFGMkM0VTtLQUMvQ2pQLGVBR0EzRixjQUFZLDJCQUptQzRVLFNBSS9DNVU7SUFJSixPQXo0QkVtZCx3QkFpNEJxQnBqQixHQUNuQjRMLFFBRG9EdUc7R0FRakI7WUFFckNxVCxxQkFHQ3hsQixHQUFFb2IsUUFBT3FLO0lBQ1o7S0FDSUMsVUFBVSwwQkFGVHRLLFFBQU9xSztLQUdSdFosWUFBWSx5QkFIWGlQO0lBSUwsU0FKS0E7U0FNWXVHLE9BTlp2RyxXQUlEdUssV0FFYWhFOztTQUNKRixTQVBSckcsV0FJRHVLLFdBR1NsRTtJQUViLEtBUElpRTtLQWNJLE9BQUEsMENBYkp2WjtlQWo1QkZpWDtnQkE4NEJDcGpCOztpQkFxQkc7O2VBaDZCSnFqQixvQkEyNEJDcmpCLEdBR0NtTTttQkFRQyw2QkFQRHdaO3lEQUpEM2xCO0dBeUI2RDtZQUU5RDRsQiw0QkFBNEI1bEIsVUFBNEI2bEI7SUFDMUQsSUFEa0M1Wix5QkFFNUJFLFlBRjRCRjtJQVEvQixHQUFBLDBDQU5HRTtLQU9ELE9BdkNIcVoscUJBOEI0QnhsQixHQUFBQSxNQUE0QjZsQjtJQVdsRCxZQUFBLDBCQVhzQjdsQixNQUV4Qm1NOztLQVdGO01BREttUztNQUFVUCxhQUFWTztNQUNMLE9BRGVQOztlQXI3QmpCcUYsd0JBeTZCNEJwakI7Ozs7aUJBOUI1QndsQixxQkE4QjRCeGxCLEdBWXJCc2UsYUFaaUR1SDs7SUFrQy9DLGVBdmdDVDVDLCtCQXErQjRCampCLEdBRXhCbU07a0JBMzZCSmlYLHdCQXk2QjRCcGpCOztZQTBDNUI4bEIsMkJBQTJCOWxCLFVBQTRCbVg7SUFDekQ7S0FEaUNsTDtLQUMzQkUsWUFEMkJGO0tBQ1ZHLFFBRFVIO0tBRTNCLFFBQUEsMEJBRnVCak0sTUFDdkJtTTtnQkFnQ0osT0FwL0JBaVgsd0JBbTlCMkJwakI7SUFJM0IsSUFES29iLG1CQUFvQjJDLGFBQXBCM0MsV0FDTCxPQUR5QjJDOzs7Ozs7Ozs7NkJBR0lpRzs7O1dBS3dCZ0M7Ozs7OzZCQUx4QmhDOzs7V0FLd0JnQzs7TUFJbkQsT0Ezc0JGM0IsdUJBNHJCMkJya0I7ZUFHdEJvYixRQVFnRDRLLG1CQVZoQzVaLE9BRGtDK0s7O0tBU3JELE9BdnZCRjRNO2NBOHVCMkIvakIsTUFHdEJvYixRQUd3QjRJLGlCQUxSNVgsT0FEa0MrSzs7SUEwQnJELE9BNytCRmlNLHdCQW05QjJCcGpCOztZQXNDM0IyVSxTQUFTNVQsS0FBMEJ3b0IsY0FBY3JXO0lBQ25ELEdBRFduUztTQUFTRSxNQUFURixRQUFBdWxCLFNBQVNybEI7O1NBQVRxbEI7SUFDWCxHQURxQ2lEO1NBRzVCQyxpQkFINEJELGlCQUNqQ0UsaUJBRUtEOztTQUZMQyxpQkFya0NGcEI7SUEya0NFO0tBQUEsTUFBQSwrQkFQTy9CO1dBQUFBOzs7OztpQkFDUG1ELG1CQXJrQ0ZwQjtLQTBrQ0VybkI7S0FRSXdsQjs7S0FLSnZOO0tBMENBalo7O01BL0NJd21CO2VBQTJCQyxZQUFXbmxCO09BQzVDLHVCQThDRXRCOzs7WUE5Q0VzRyxNQThDRnRHOzsyQ0E5Q0VzRyxNQThDRnRHO1lBOUNFc0csc0NBOENGdEc7O09BM0NGLE9BaFhBcWxCLHVCQTZXSS9lLEtBRDZCbWdCLFlBQVdubEI7TUFJSzs7TUFDL0MyWDtlQUFjOVY7T0FDaEIsdUJBeUNFbkQ7OztZQXpDRXNHLE1BeUNGdEc7OzJDQXpDRXNHLE1BeUNGdEc7WUF6Q0VzRyxzQ0F5Q0Z0Rzs7T0F4Q0YsU0FGZ0JtRCxVQUdSSixJQUhRSSxNQUdILE9BdGtDYm9aLGFBb2tDSWpXLEtBRUl2RDtPQUVOO1FBREc4VixRQUpXMVY7UUFJUnVWLGdCQUFIRztRQUF3QjVNLGVBQXhCNE07UUFDSCxRQUpFdlM7OztZQUtLNkY7O1VBQ3dCOzJDQUR4QkEsV0FGb0JGO21CQUFBQTs7UUFXekIsT0EzaENKbVgsd0JBNmdDSTljOztjQUdJb1M7O2NBcUJHM0IsS0FyQkgyQjtVQXFCUyxPQXhvQmpCb00sbUJBZ25CSXhlLEtBR0N1UyxPQXFCTTlCOztjQUZlSSxnQkFuQmxCdUI7VUFvQkYsT0F4c0JOaU0sc0JBaXJCSXJlLEtBR0N1UyxPQW1CcUIxQjs7Y0FHWGhKLFdBdEJQdUs7VUFzQm1CLE9BamdCM0JxTSx1QkF3ZUl6ZSxLQUdDdVMsT0FzQlUxSzs7Y0FDQ1ksYUF2QlIySjtVQXVCc0IsT0FqZTlCc00seUJBdWNJMWUsS0FHQ3VTLE9BdUJXOUo7O2NBQ0QvTixXQXhCUDBYO1VBd0JtQixPQTdZM0IyTSx1QkFrWEkvZSxLQUdDdVMsT0F3QlU3WDs7Y0FDd0Iwb0IsT0F6Qi9CaFIsa0JBeUJXaEIscUJBekJYZ0I7VUEwQkYsT0F6UU4wUTttQkE0T0k5aUIsS0FHQ3VTLE9BeUJjbkIsb0JBQW9CZ1M7O2NBRTVCN08sT0EzQkhuQztVQTJCVyxPQWhObkI0TSxtQkFrTEloZixLQUdDdVMsT0EyQk1nQzs7O1dBQzBCOEwsU0E1QjdCak87V0E0QnNCdkcsUUE1QnRCdUc7V0E0Qk14RyxpQkE1Qk53RztVQTZCRixPQTVLTjZNO21CQTRJSWpmLEtBR0N1UyxPQTRCUzNHLGdCQUF1QnlVLFFBQVB4VTs7Y0FFWGhELGNBOUJYdUo7VUErQkYsT0F0SU5rTiw0QkFvR0l0ZixLQUdDdVMsT0E4QmMxSjs7Y0FFQXlYLGtCQWhDWGxPO1VBaUNGLE9BOUZOb04sMkJBMERJeGYsS0FHQ3VTLE9BZ0NjK047a0JBS2I7O01BQUk7O01BQ1I1bUI7OztRQTRCaUM7U0FBQSxNQUFBLG9DQW5GakNnQjtTQWtGaUMsTUFBQSxvQ0FsRmpDQTtTQW9Fa0IsTUFBQTtTQVVkLE1BQUE7U0FGTyxNQUFBLHNDQTVFWEE7UUF5REE7Z0JBekRBQTtnQkF3RUk7O2tCQWhFQXdsQjtrQkFLSnZOO2tCQWJBalk7O2dCQU5Pc2xCOzs7Ozs7Ozs7Z0JBQXdDcFQ7Z0JBQy9DdVc7Ozs7MkJBNERBenBCOzs7U0ErQkFzRyxNQS9CQXRHOzt3Q0ErQkFzRyxNQS9CQXRHO1NBK0JBc0csc0NBL0JBdEc7O0lBbUNXLElBQVgycEIsYUFBVyxpQ0FKWHJqQixTQWlCSixNQWpCSUE7SUFBQUE7O0lBc0JKLHNDQXRCSUEsUUFJQXFqQjtJQTBCQSxHQUFBLGlCQTlCQXJqQjtLQWlDQyxJQURFNmYsT0FoQ0g3ZjtLQTlqQ0ZrZCxtQkE4akNFbGQsS0FBQUEsUUFnQ0c2Zjs7SUFNUCxPQXRDSTdmO0dBc0NIO1lBRUNzakIsc0JBQXNCNXBCLEdBQUdrVDtJQUMzQixJQUFJcEQsaUJBRG9COVA7SUFBQUEsT0FBQUE7UUFHcEJtTSxZQUhvQm5NO0lBVXBCLHVCLE9BNW1CRnVqQixnQkFrbUJzQnZqQixHQUdwQm1NO0lBRUY7S0FERW1jO09BQ0Y7O1NBRkVuYztTQUZBMkQ7U0FEb0I5UDtTQUFHa1Q7O0lBY3pCO3FCQWRzQmxULDRCQUFBQSxTQUFBQSxTQUlwQnNvQjtJQWlCSixPQWpCSUE7R0FpQkM7WUFJSHZCO0lBQ0NULFFBQ0FpRCxjQUNBdkMsY0FDQTlUO0lBR0g7S0FGcUIyVztLQUFsQnBCO0tBRUcxZSxTQUpIaWQ7S0FJMEIxZCxPQUoxQjBkO0tBS0csUUFBQSxpQ0FMSEE7MkJBd0NLOW1CLGdCQUFPLFdBQVBBO0lBOUJFO0tBSkw0SjtLQUlDOUosSUExS0oyVSxTQThKQzJSLFFBQ0FpRCxjQUVBclc7S0FVR29WLFFBdkNKc0Isc0JBc0NJNXBCLEdBUmU2cEI7SUFVUSxLQUFBLDBDQUZ2QjdwQjtLQUVKLE1BQUE7SUFDMkIsS0FBQSwwQ0FGdkJzb0I7S0FFSixNQUFBO0lBQ2M7S0FBVmxYO09BQVUsb0NBUlh0SCxvQkFGd0JSLE1BQXZCUztJQWlCSixrQjtJQVZJdWU7Ozs7T0FHQWxYO09Bb0JtQixnQ0F4Qm5CcFI7T0FSSHlvQjs7SUFvQ0QsdUNBNUJJem9CO0lBNkJKLFdBN0JJQTs7WUFnQ0pvUixRQUNBcFIsR0FDRWUsVUFFRnFRLFNBQ0M4QixlQUNBdVY7SUFFSCxHQU5JMW5CO1NBQTRCRSxNQUE1QkYsUUFBQThhLDRCQUE0QjVhOztTQUE1QjRhO0lBTUo7U0FMdUJqTSxnQkFBbkJvWSxtQkFBbUJwWTs7U0FBbkJvWSxpQztJQU1RO0tBRFJsWSxpQkFQRjlQO0tBUUVzb0IsUUEvRUZzQixzQkF1RUE1cEIsR0FJQ2tUO0tBS0gsTUFURWxUO0tBVW1CLE1BQUEsMkJBSGpCOFA7S0FFQXdLLGVBQ0Y7S0FFRXRLO09BQ0Y7Ozs7YUFiQWhRO1NBUUVzb0I7SUFVSjs7TUFsQkV0b0I7TUFBQUE7O01BWUVnUTtNQVRGb0I7SUFLRWtYO2tCQUxGbFgsU0FNRWtKLGNBSkRtTyxrQkFIQ1Q7V0FEQW5NO0tBNkJrQyx1Q0E5QnBDN2I7SUErQkYsdUNBL0JFQTtJQStCRixPQXRCSXNhO0dBMkJRO1lBTVZ3UCxLQUFLOXBCLEdBQUc2TyxTQUFVOU4sS0FBU3VvQjtJQUM3QixHQURvQnZvQixTQUFNRSxNQUFORixRQUFBa00sTUFBTWhNLGNBQU5nTTtJQUNwQixHQURVNEI7U0FJRGtiLFlBSkNsYjtTQUtILDJCQURFa2IsYUFKVzljO01BTVg7U0FMTCtjLFlBR0tEOzs7U0FITEM7SUFjYTtLQUFiaGE7T0FBYTs7SUFDakIscUJBaEI2QnNaLFVBQXRCdHBCO0lBaUJQO2tDQWpCT0EsTUFlSGdRLGdCQWZnQi9DLE1BQ2hCK2M7a0RBREdocUI7R0FrQmU7WUFFcEJvbkIsb0JBQW9CcG5CO0lBQ3RCLEdBQUcsa0NBRG1CQSxPQTMwQ3BCOGlCLGdCQTIwQ29COWlCO0lBRWhCLElBQ0pxbkIsWUFESSxtQ0FGZ0JybkI7Y0FHcEJxbkIsd0JBQWlDLE9BQWpDQTtRQUNPdGtCLElBRFBza0I7SUE1ekNBOUssYUF5ekNvQnZjLEdBSWIrQztpQkFBQUE7R0FZQztZQUVSdWtCLEtBQUt0bkIsR0FBRStXLElBQUk5SixLQUFLaEg7SUFBTSxPQUFBLG1DQUFqQmpHLE1BQUUrVyxJQUFJOUosS0FBS2hIO0dBQTREO1lBRTVFZ2tCLGVBQWVqcUI7SUFDakI7S0FDSyxJQUFlK2QsdUJBQ2hCLE1BRGdCQTs7TUFJZCxPQUFBLDhCQUpjQTtLQUVrQjtJQUtoQjtJQVJ0QiwwQkFEaUIvZDtjQUFBQTtpQkFXRDBJLEdBQUssT0FBQSxXQUFMQSxRQUFtQjtJQUFuQztJQUFBLE9BanlDRTBhLHdCQXN4Q2VwakI7R0FZK0M7WUFFOUR1bkIsU0FBU3ZuQixHQUFFK1csSUFBSTlKLEtBQUtoSDtJQUNMO0tBQWJpa0IsYUFBYSxtQ0FETmxxQixNQUFFK1csSUFBSTlKLEtBQUtoSDtJQWRwQmdrQixlQWNTanFCO0lBRVgsT0FESWtxQjtHQUVNO1lBUVIxQyxhQUFheG5CLEdBQUcrQixHQUFJLE9BQUEsV0FBSkEsTUFBUTtZQUV4QjBsQixxQkFBcUJ6bkI7SUF4M0NyQjZjLG1CQXczQ3FCN2M7a0RBQUFBO0dBRUg7WUFFbEIybkIsYUFBYTNuQixHQUFFK0I7SUFBSSxPQUFBLHVDQUFOL0IsTUFBRStCO0dBQXNDO1lBQ3JEMmxCLG9CQUFvQjFuQixHQUFFK1M7SUFBUyxPQUFBLHVDQUFYL1MsTUFBRStTO0dBQTZDOzs7Ozs7T0FqNENuRXNWO09BQ0F6VjtPQUNBa1E7T0FFQWpHO09BR0FrRztPQVFBRTtPQUtBMUc7T0F1REE2RztPQUdBQztPQUdBTDtPQU9BTTtPQUlBN0c7T0FNQStHO09Bd0JBK0U7T0FzRUFHO09BbUVBN0U7T0E2Q0FFO09Ba0RBTTtPQUVBd0U7T0FrQkFDO09BbUJBcEU7T0E4QkFDO09BaUVBRztPQThIQXZCO09BVUF3QjtPQWlDQUM7T0FxRkFLO09BdUdBOEQ7T0ErQkFDO09Bd0RBakI7T0FFQTdDO09Bc0NBQztPQVVBQztPQThCQUk7T0EwQ0FFO09Bc0NBblI7T0FvSUFpVjtPQXlCQTdDO09BNkNBM1Y7T0EyQ0EwWTtPQW9CQTFDO09Ba0JBRTtPQUVBMkM7T0FjQTFDO09BV0FDO09BRUFDO09BSUFFO09BQ0FEOzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAxOSBBbnTDs25pbyBOdW5vIE1vbnRlaXJvXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXNcbiAqICBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiAgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiAgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqICBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbmxldFtAaW5saW5lXSB0ZXN0X2JpdF9pbnQzMiB4IGkgPVxuICBsZXQgb3BlbiBJbnQzMiBpblxuICBub3QgKGVxdWFsIChsb2dhbmQgeCAoc2hpZnRfbGVmdCAxbCBpKSkgMGwpXG5cbmxldFtAaW5saW5lXSB0ZXN0X2JpdCB4IGkgPSB4IGxhbmQgKDEgbHNsIGkpIDw+IDBcbmxldFtAaW5saW5lXSBzZXRfYml0IHggaSA9IHggbG9yICgxIGxzbCBpKVxuXG5sZXRbQGlubGluZV0gc2V0X2JpdF9pbnQzMiB4IGkgPVxuICBsZXQgb3BlbiBJbnQzMiBpblxuICBsb2dvciB4IChzaGlmdF9sZWZ0IDFsIGkpXG5cbmxldFtAaW5saW5lXSBjbGVhcl9iaXQgeCBpID0geCBsYW5kIGxub3QgKDEgbHNsIGkpXG5cbmxldFtAaW5saW5lXSBjbGVhcl9iaXRfaW50MzIgeCBpID1cbiAgbGV0IG9wZW4gSW50MzIgaW5cbiAgbG9nYW5kIHggKGxvZ25vdCAoc2hpZnRfbGVmdCAxbCBpKSlcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAxOSBBbnTDs25pbyBOdW5vIE1vbnRlaXJvXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXNcbiAqICBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiAgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiAgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqICBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbigqIEZyb20gUkZDNzU0MMKnNS4xLjE6XG4gKiAgIFN0cmVhbXMgYXJlIGlkZW50aWZpZWQgd2l0aCBhbiB1bnNpZ25lZCAzMS1iaXQgaW50ZWdlci4gKilcbnR5cGUgdCA9IGludDMyXG5cbmxldCAoID09PSApID0gSW50MzIuZXF1YWxcbmxldFtAaW5saW5lXSAoIDw9ICkgczEgczIgPSBJbnQzMi5jb21wYXJlIHMxIHMyIDw9IDBcbmxldFtAaW5saW5lXSAoID4gKSBzMSBzMiA9IEludDMyLmNvbXBhcmUgczEgczIgPiAwXG5sZXRbQGlubGluZV0gKCA+PSApIHMxIHMyID0gSW50MzIuY29tcGFyZSBzMSBzMiA+PSAwXG5cbigqIEZyb20gUkZDNzU0MMKnNS4xLjE6XG4gKiAgIEEgc3RyZWFtIGlkZW50aWZpZXIgb2YgemVybyAoMHgwKSBpcyB1c2VkIGZvciBjb25uZWN0aW9uIGNvbnRyb2wgbWVzc2FnZXM7XG4gKiAgIHRoZSBzdHJlYW0gaWRlbnRpZmllciBvZiB6ZXJvIGNhbm5vdCBiZSB1c2VkIHRvIGVzdGFibGlzaCBhIG5ldyBzdHJlYW0uICopXG5sZXQgY29ubmVjdGlvbiA9IEludDMyLnplcm9cblxuKCogRnJvbSBSRkM3NTQwwqc1LjEuMTpcbiAqICAgQSBzdHJlYW0gaWRlbnRpZmllciBvZiB6ZXJvICgweDApIGlzIHVzZWQgZm9yIGNvbm5lY3Rpb24gY29udHJvbCBtZXNzYWdlcztcbiAqICAgdGhlIHN0cmVhbSBpZGVudGlmaWVyIG9mIHplcm8gY2Fubm90IGJlIHVzZWQgdG8gZXN0YWJsaXNoIGEgbmV3IHN0cmVhbS4gKilcbmxldFtAaW5saW5lXSBpc19jb25uZWN0aW9uIGlkID0gSW50MzIuZXF1YWwgaWQgY29ubmVjdGlvblxuXG4oKiBGcm9tIFJGQzc1NDDCpzUuMS4xOlxuICogICBTdHJlYW1zIGluaXRpYXRlZCBieSBhIGNsaWVudCBNVVNUIHVzZSBvZGQtbnVtYmVyZWQgc3RyZWFtXG4gKiAgIGlkZW50aWZpZXJzIFsuLi5dLiAqKVxubGV0W0BpbmxpbmVdIGlzX3JlcXVlc3QgaWQgPSBJbnQzMi5yZW0gaWQgMmwgPT09IDFsXG5cbigqIEZyb20gUkZDNzU0MMKnNS4xLjE6XG4gKiAgIFN0cmVhbXMgaW5pdGlhdGVkIGJ5IFsuLi5dIHRoZSBzZXJ2ZXIgTVVTVCB1c2UgZXZlbi1udW1iZXJlZCBzdHJlYW1cbiAqICAgaWRlbnRpZmllcnMuIEEgc3RyZWFtIGlkZW50aWZpZXIgb2YgemVybyAoMHgwKSBpcyB1c2VkIGZvciBjb25uZWN0aW9uXG4gKiAgIGNvbnRyb2wgbWVzc2FnZXMgWy4uLl0uICopXG5sZXRbQGlubGluZV0gaXNfcHVzaGVkID0gZnVuY3Rpb24gMGwgLT4gZmFsc2UgfCBuIC0+IEludDMyLnJlbSBuIDJsID09PSAwbFxuXG4oKiBGcm9tIFJGQzc1NDDCpzUuMS4xOlxuICogICBTdHJlYW1zIGFyZSBpZGVudGlmaWVkIHdpdGggYW4gdW5zaWduZWQgMzEtYml0IGludGVnZXIuICopXG5sZXQgbWF4X3N0cmVhbV9pZCA9IEludDMyLm1heF9pbnRcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAxOSBBbnTDs25pbyBOdW5vIE1vbnRlaXJvXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXNcbiAqICBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiAgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiAgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqICBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbnR5cGUgdCA9XG4gICgqIEZyb20gUkZDNzU0MMKnNzpcbiAgICogICBOT19FUlJPUiAoMHgwKTogVGhlIGFzc29jaWF0ZWQgY29uZGl0aW9uIGlzIG5vdCBhIHJlc3VsdCBvZiBhblxuICAgKiAgIGVycm9yLiAqKVxuICB8IE5vRXJyb3JcbiAgKCogRnJvbSBSRkM3NTQwwqc3OlxuICAgKiAgIFBST1RPQ09MX0VSUk9SICgweDEpOiBUaGUgZW5kcG9pbnQgZGV0ZWN0ZWQgYW4gdW5zcGVjaWZpYyBwcm90b2NvbFxuICAgKiAgIGVycm9yLiBUaGlzIGVycm9yIGlzIGZvciB1c2Ugd2hlbiBhIG1vcmUgc3BlY2lmaWMgZXJyb3IgY29kZSBpcyBub3RcbiAgICogICBhdmFpbGFibGUuICopXG4gIHwgUHJvdG9jb2xFcnJvclxuICAoKiBGcm9tIFJGQzc1NDDCpzc6XG4gICAqICAgSU5URVJOQUxfRVJST1IgKDB4Mik6IFRoZSBlbmRwb2ludCBlbmNvdW50ZXJlZCBhbiB1bmV4cGVjdGVkIGludGVybmFsXG4gICAqICAgZXJyb3IuICopXG4gIHwgSW50ZXJuYWxFcnJvclxuICAoKiBGcm9tIFJGQzc1NDDCpzc6XG4gICAqICAgRkxPV19DT05UUk9MX0VSUk9SICgweDMpOiBUaGUgZW5kcG9pbnQgZGV0ZWN0ZWQgdGhhdCBpdHMgcGVlciB2aW9sYXRlZFxuICAgKiAgIHRoZSBmbG93LWNvbnRyb2wgcHJvdG9jb2wuICopXG4gIHwgRmxvd0NvbnRyb2xFcnJvclxuICAoKiBGcm9tIFJGQzc1NDDCpzc6XG4gICAqICAgU0VUVElOR1NfVElNRU9VVCAoMHg0KTogVGhlIGVuZHBvaW50IHNlbnQgYSBTRVRUSU5HUyBmcmFtZSBidXQgZGlkIG5vdFxuICAgKiAgIHJlY2VpdmUgYSByZXNwb25zZSBpbiBhIHRpbWVseSBtYW5uZXIuICopXG4gIHwgU2V0dGluZ3NUaW1lb3V0XG4gICgqIEZyb20gUkZDNzU0MMKnNzpcbiAgICogICBTVFJFQU1fQ0xPU0VEICgweDUpOiBUaGUgZW5kcG9pbnQgcmVjZWl2ZWQgYSBmcmFtZSBhZnRlciBhIHN0cmVhbSB3YXNcbiAgICogICBoYWxmLWNsb3NlZC4gKilcbiAgfCBTdHJlYW1DbG9zZWRcbiAgKCogRnJvbSBSRkM3NTQwwqc3OlxuICAgKiAgIEZSQU1FX1NJWkVfRVJST1IgKDB4Nik6IFRoZSBlbmRwb2ludCByZWNlaXZlZCBhIGZyYW1lIHdpdGggYW4gaW52YWxpZFxuICAgKiAgIHNpemUuICopXG4gIHwgRnJhbWVTaXplRXJyb3JcbiAgKCogRnJvbSBSRkM3NTQwwqc3OlxuICAgKiAgIFJFRlVTRURfU1RSRUFNICgweDcpOiBUaGUgZW5kcG9pbnQgcmVmdXNlZCB0aGUgc3RyZWFtIHByaW9yIHRvXG4gICAqICAgcGVyZm9ybWluZyBhbnkgYXBwbGljYXRpb24gcHJvY2Vzc2luZyAoc2VlIFNlY3Rpb24gOC4xLjQgZm9yXG4gICAqICAgZGV0YWlscykuICopXG4gIHwgUmVmdXNlZFN0cmVhbVxuICAoKiBGcm9tIFJGQzc1NDDCpzc6XG4gICAqICAgQ0FOQ0VMICgweDgpOiBVc2VkIGJ5IHRoZSBlbmRwb2ludCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBzdHJlYW0gaXMgbm9cbiAgICogICBsb25nZXIgbmVlZGVkLiAqKVxuICB8IENhbmNlbFxuICAoKiBGcm9tIFJGQzc1NDDCpzc6XG4gICAqICAgQ09NUFJFU1NJT05fRVJST1IgKDB4OSk6IFRoZSBlbmRwb2ludCBpcyB1bmFibGUgdG8gbWFpbnRhaW4gdGhlIGhlYWRlclxuICAgKiAgIGNvbXByZXNzaW9uIGNvbnRleHQgZm9yIHRoZSBjb25uZWN0aW9uLiAqKVxuICB8IENvbXByZXNzaW9uRXJyb3JcbiAgKCogRnJvbSBSRkM3NTQwwqc3OlxuICAgKiAgIENPTk5FQ1RfRVJST1IgKDB4YSk6IFRoZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkIGluIHJlc3BvbnNlIHRvIGFcbiAgICogICBDT05ORUNUIHJlcXVlc3QgKFNlY3Rpb24gOC4zKSB3YXMgcmVzZXQgb3IgYWJub3JtYWxseSBjbG9zZWQuICopXG4gIHwgQ29ubmVjdEVycm9yXG4gICgqIEZyb20gUkZDNzU0MMKnNzpcbiAgICogICBFTkhBTkNFX1lPVVJfQ0FMTSAoMHhiKTogVGhlIGVuZHBvaW50IGRldGVjdGVkIHRoYXQgaXRzIHBlZXIgaXNcbiAgICogICBleGhpYml0aW5nIGEgYmVoYXZpb3IgdGhhdCBtaWdodCBiZSBnZW5lcmF0aW5nIGV4Y2Vzc2l2ZSBsb2FkLiAqKVxuICB8IEVuaGFuY2VZb3VyQ2FsbVxuICAoKiBGcm9tIFJGQzc1NDDCpzc6XG4gICAqICAgSU5BREVRVUFURV9TRUNVUklUWSAoMHhjKTogVGhlIHVuZGVybHlpbmcgdHJhbnNwb3J0IGhhcyBwcm9wZXJ0aWVzXG4gICAqICAgdGhhdCBkbyBub3QgbWVldCBtaW5pbXVtIHNlY3VyaXR5IHJlcXVpcmVtZW50cyAoc2VlIFNlY3Rpb24gOS4yKS4gKilcbiAgfCBJbmFkZXF1YXRlU2VjdXJpdHlcbiAgKCogRnJvbSBSRkM3NTQwwqc3OlxuICAgKiAgIEhUVFBfMV8xX1JFUVVJUkVEICgweGQpOiBUaGUgZW5kcG9pbnQgcmVxdWlyZXMgdGhhdCBIVFRQLzEuMSBiZSB1c2VkXG4gICAqICAgaW5zdGVhZCBvZiBIVFRQLzIuICopXG4gIHwgSFRUUF8xXzFfUmVxdWlyZWRcbiAgKCogRnJvbSBSRkM3NTQwwqc3OlxuICAgKiAgIFVua25vd24gb3IgdW5zdXBwb3J0ZWQgZXJyb3IgY29kZXMgTVVTVCBOT1QgdHJpZ2dlciBhbnkgc3BlY2lhbFxuICAgKiAgIGJlaGF2aW9yLiBUaGVzZSBNQVkgYmUgdHJlYXRlZCBieSBhbiBpbXBsZW1lbnRhdGlvbiBhcyBiZWluZ1xuICAgKiAgIGVxdWl2YWxlbnQgdG8gSU5URVJOQUxfRVJST1IuICopXG4gIHwgVW5rbm93bkVycm9yX2NvZGUgb2YgaW50MzJcblxuKCogRnJvbSBSRkM3NTQwwqc3OlxuICogICBFcnJvciBjb2RlcyBhcmUgMzItYml0IGZpZWxkcyB0aGF0IGFyZSB1c2VkIGluIFJTVF9TVFJFQU0gYW5kIEdPQVdBWVxuICogICBmcmFtZXMgdG8gY29udmV5IHRoZSByZWFzb25zIGZvciB0aGUgc3RyZWFtIG9yIGNvbm5lY3Rpb24gZXJyb3IuICopXG5sZXQgc2VyaWFsaXplID0gZnVuY3Rpb25cbiAgfCBOb0Vycm9yIC0+IDB4MGxcbiAgfCBQcm90b2NvbEVycm9yIC0+IDB4MWxcbiAgfCBJbnRlcm5hbEVycm9yIC0+IDB4MmxcbiAgfCBGbG93Q29udHJvbEVycm9yIC0+IDB4M2xcbiAgfCBTZXR0aW5nc1RpbWVvdXQgLT4gMHg0bFxuICB8IFN0cmVhbUNsb3NlZCAtPiAweDVsXG4gIHwgRnJhbWVTaXplRXJyb3IgLT4gMHg2bFxuICB8IFJlZnVzZWRTdHJlYW0gLT4gMHg3bFxuICB8IENhbmNlbCAtPiAweDhsXG4gIHwgQ29tcHJlc3Npb25FcnJvciAtPiAweDlsXG4gIHwgQ29ubmVjdEVycm9yIC0+IDB4YWxcbiAgfCBFbmhhbmNlWW91ckNhbG0gLT4gMHhibFxuICB8IEluYWRlcXVhdGVTZWN1cml0eSAtPiAweGNsXG4gIHwgSFRUUF8xXzFfUmVxdWlyZWQgLT4gMHhkbFxuICB8IFVua25vd25FcnJvcl9jb2RlIGlkIC0+IGlkXG5cbmxldCBwYXJzZSA9IGZ1bmN0aW9uXG4gIHwgMHgwbCAtPiBOb0Vycm9yXG4gIHwgMHgxbCAtPiBQcm90b2NvbEVycm9yXG4gIHwgMHgybCAtPiBJbnRlcm5hbEVycm9yXG4gIHwgMHgzbCAtPiBGbG93Q29udHJvbEVycm9yXG4gIHwgMHg0bCAtPiBTZXR0aW5nc1RpbWVvdXRcbiAgfCAweDVsIC0+IFN0cmVhbUNsb3NlZFxuICB8IDB4NmwgLT4gRnJhbWVTaXplRXJyb3JcbiAgfCAweDdsIC0+IFJlZnVzZWRTdHJlYW1cbiAgfCAweDhsIC0+IENhbmNlbFxuICB8IDB4OWwgLT4gQ29tcHJlc3Npb25FcnJvclxuICB8IDB4YWwgLT4gQ29ubmVjdEVycm9yXG4gIHwgMHhibCAtPiBFbmhhbmNlWW91ckNhbG1cbiAgfCAweGNsIC0+IEluYWRlcXVhdGVTZWN1cml0eVxuICB8IDB4ZGwgLT4gSFRUUF8xXzFfUmVxdWlyZWRcbiAgfCBpZCAtPiBVbmtub3duRXJyb3JfY29kZSBpZFxuXG5sZXQgdG9fc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBOb0Vycm9yIC0+IFwiTk9fRVJST1IgKDB4MClcIlxuICB8IFByb3RvY29sRXJyb3IgLT4gXCJQUk9UT0NPTF9FUlJPUiAoMHgxKVwiXG4gIHwgSW50ZXJuYWxFcnJvciAtPiBcIklOVEVSTkFMX0VSUk9SICgweDIpXCJcbiAgfCBGbG93Q29udHJvbEVycm9yIC0+IFwiRkxPV19DT05UUk9MX0VSUk9SICgweDMpXCJcbiAgfCBTZXR0aW5nc1RpbWVvdXQgLT4gXCJTRVRUSU5HU19USU1FT1VUICgweDQpXCJcbiAgfCBTdHJlYW1DbG9zZWQgLT4gXCJTVFJFQU1fQ0xPU0VEICgweDUpXCJcbiAgfCBGcmFtZVNpemVFcnJvciAtPiBcIkZSQU1FX1NJWkVfRVJST1IgKDB4NilcIlxuICB8IFJlZnVzZWRTdHJlYW0gLT4gXCJSRUZVU0VEX1NUUkVBTSAoMHg3KVwiXG4gIHwgQ2FuY2VsIC0+IFwiQ0FOQ0VMICgweDgpXCJcbiAgfCBDb21wcmVzc2lvbkVycm9yIC0+IFwiQ09NUFJFU1NJT05fRVJST1IgKDB4OSlcIlxuICB8IENvbm5lY3RFcnJvciAtPiBcIkNPTk5FQ1RfRVJST1IgKDB4YSlcIlxuICB8IEVuaGFuY2VZb3VyQ2FsbSAtPiBcIkVOSEFOQ0VfWU9VUl9DQUxNICgweGIpXCJcbiAgfCBJbmFkZXF1YXRlU2VjdXJpdHkgLT4gXCJJTkFERVFVQVRFX1NFQ1VSSVRZICgweGMpXCJcbiAgfCBIVFRQXzFfMV9SZXF1aXJlZCAtPiBcIkhUVFBfMV8xX1JFUVVJUkVEICgweGQpXCJcbiAgfCBVbmtub3duRXJyb3JfY29kZSBpZCAtPiBGb3JtYXQuYXNwcmludGYgXCJVTktOT1dOX0VSUk9SICgweCVseClcIiBpZFxuXG5sZXQgcHBfaHVtIGZvcm1hdHRlciB0ID0gRm9ybWF0LmZwcmludGYgZm9ybWF0dGVyIFwiJXNcIiAodG9fc3RyaW5nIHQpXG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIDIwMTkgQW50w7NuaW8gTnVubyBNb250ZWlyb1xuICpcbiAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzXG4gKiAgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqICBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiAgQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG4oKiBGcm9tIFJGQzc1NDDCpzUuNDpcbiAqICAgSFRUUC8yIGZyYW1pbmcgcGVybWl0cyB0d28gY2xhc3NlcyBvZiBlcnJvcjpcbiAqXG4gKiAgIC0gQW4gZXJyb3IgY29uZGl0aW9uIHRoYXQgcmVuZGVycyB0aGUgZW50aXJlIGNvbm5lY3Rpb24gdW51c2FibGUgaXMgYVxuICogICAgIGNvbm5lY3Rpb24gZXJyb3IuXG4gKiAgIC0gQW4gZXJyb3IgaW4gYW4gaW5kaXZpZHVhbCBzdHJlYW0gaXMgYSBzdHJlYW0gZXJyb3IuICopXG50eXBlIHQgPVxuICB8IENvbm5lY3Rpb25FcnJvciBvZiBFcnJvcl9jb2RlLnQgKiBzdHJpbmdcbiAgfCBTdHJlYW1FcnJvciBvZiBTdHJlYW1faWRlbnRpZmllci50ICogRXJyb3JfY29kZS50XG5cbmxldCBtZXNzYWdlID0gZnVuY3Rpb24gQ29ubmVjdGlvbkVycm9yIChfLCBtc2cpIC0+IG1zZyB8IFN0cmVhbUVycm9yIF8gLT4gXCJcIlxuIiwiKCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE5LTIwMjAgQW50w7NuaW8gTnVubyBNb250ZWlyb1xuICpcbiAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzXG4gKiAgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqICBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiAgQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG5tb2R1bGUgV2luZG93U2l6ZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQzMlxuXG4gICgqIEZyb20gUkZDNzU0MMKnNi45LjI6XG4gICAqICAgV2hlbiBhbiBIVFRQLzIgY29ubmVjdGlvbiBpcyBmaXJzdCBlc3RhYmxpc2hlZCwgbmV3IHN0cmVhbXMgYXJlIGNyZWF0ZWRcbiAgICogICB3aXRoIGFuIGluaXRpYWwgZmxvdy1jb250cm9sIHdpbmRvdyBzaXplIG9mIDY1LDUzNSBvY3RldHMuICopXG4gIGxldCBkZWZhdWx0X2luaXRpYWxfd2luZG93X3NpemUgPSA2NTUzNWxcblxuICAoKiBGcm9tIFJGQzc1NDDCpzYuOTpcbiAgICogICBUaGUgbGVnYWwgcmFuZ2UgZm9yIHRoZSBpbmNyZW1lbnQgdG8gdGhlIGZsb3ctY29udHJvbCB3aW5kb3cgaXMgMSB0b1xuICAgKiAgIDJeMzEtMSAoMiwxNDcsNDgzLDY0Nykgb2N0ZXRzLiAqKVxuICBsZXQgbWF4X3dpbmRvd19zaXplID0gSW50MzIubWF4X2ludFxuXG4gICgqIElkZWFsbHkgYG5gIGhlcmUgd291bGQgYmUgYW4gdW5zaWduZWQgMzItYml0IGludGVnZXIsIGJ1dCBPQ2FtbCBkb2Vzbid0XG4gICAqIHN1cHBvcnQgdGhlbS4gV2UgYXZvaWQgaW50cm9kdWNpbmcgYSBuZXcgZGVwZW5kZW5jeSBvbiBhbiB1bnNpZ25lZCBpbnRlZ2VyXG4gICAqIGxpYnJhcnkgYnkgbGV0dGluZyBpdCBvdmVyZmxvdyBhdCBwYXJzZSB0aW1lIGFuZCBjaGVja2luZyBpZiBiaXQgMzEgaXMgc2V0XG4gICAqIGhlcmUsIHNpbmNlICogYFdpbmRvdy5tYXhfd2luZG93X3NpemVgIGlzIG5ldmVyIGFsbG93ZWQgdG8gYmUgYWJvdmVcbiAgICogMl4zMS0xIChzZWUgYG1heF93aW5kb3dfc2l6ZWAgYWJvdmUpLlxuICAgKiBTZWUgaHR0cDovL2NhbWwuaW5yaWEuZnIvcHViL21sLWFyY2hpdmVzL2NhbWwtbGlzdC8yMDA0LzA3L2YxYzQ4MzA2OGNjNjIwNzVjOTE2ZjdhZDdkNjQwY2UwLmZyLmh0bWxcbiAgICogZm9yIG1vcmUgaW5mby4gKilcbiAgbGV0IGlzX3dpbmRvd19vdmVyZmxvdyBuID0gVXRpbC50ZXN0X2JpdF9pbnQzMiBuIDMxXG5lbmRcblxudHlwZSBzZXR0aW5nID1cbiAgfCBIZWFkZXJUYWJsZVNpemUgb2YgaW50XG4gIHwgRW5hYmxlUHVzaCBvZiBpbnRcbiAgfCBNYXhDb25jdXJyZW50U3RyZWFtcyBvZiBpbnQzMlxuICB8IEluaXRpYWxXaW5kb3dTaXplIG9mIGludDMyXG4gIHwgTWF4RnJhbWVTaXplICgqIHRoaXMgbWVhbnMgcGF5bG9hZCBzaXplICopIG9mIGludFxuICB8IE1heEhlYWRlckxpc3RTaXplIG9mIGludFxuXG50eXBlIHNldHRpbmdzX2xpc3QgPSBzZXR0aW5nIGxpc3RcblxuKCogRnJvbSBSRkM3NTQwwqc2LjUuMTpcbiAqICAgVGhlIHBheWxvYWQgb2YgYSBTRVRUSU5HUyBmcmFtZSBjb25zaXN0cyBvZiB6ZXJvIG9yIG1vcmUgcGFyYW1ldGVycyxcbiAqICAgZWFjaCBjb25zaXN0aW5nIG9mIGFuIHVuc2lnbmVkIDE2LWJpdCBzZXR0aW5nIGlkZW50aWZpZXIgYW5kIGFuXG4gKiAgIHVuc2lnbmVkIDMyLWJpdCB2YWx1ZS4gKilcbmxldCBvY3RldHNfcGVyX3NldHRpbmcgPSA2XG5cbmxldCBzZXJpYWxpemVfa2V5ID0gZnVuY3Rpb25cbiAgfCBIZWFkZXJUYWJsZVNpemUgXyAtPiAweDFcbiAgfCBFbmFibGVQdXNoIF8gLT4gMHgyXG4gIHwgTWF4Q29uY3VycmVudFN0cmVhbXMgXyAtPiAweDNcbiAgfCBJbml0aWFsV2luZG93U2l6ZSBfIC0+IDB4NFxuICB8IE1heEZyYW1lU2l6ZSBfIC0+IDB4NVxuICB8IE1heEhlYWRlckxpc3RTaXplIF8gLT4gMHg2XG5cbmxldCBjaGVja192YWx1ZSB+aXNfY2xpZW50ID0gZnVuY3Rpb25cbiAgfCBFbmFibGVQdXNoIHYgLT5cbiAgICBpZiB2IDw+IDAgJiYgdiA8PiAxXG4gICAgdGhlblxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjUuMlxuICAgICAgICogICBUaGUgaW5pdGlhbCB2YWx1ZSBpcyAxLCB3aGljaCBpbmRpY2F0ZXMgdGhhdCBzZXJ2ZXIgcHVzaCBpc1xuICAgICAgICogICBwZXJtaXR0ZWQuIEFueSB2YWx1ZSBvdGhlciB0aGFuIDAgb3IgMSBNVVNUIGJlIHRyZWF0ZWQgYXMgYVxuICAgICAgICogICBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgICAgRXJyb3JcbiAgICAgICAgRXJyb3IuKFxuICAgICAgICAgIENvbm5lY3Rpb25FcnJvciAoUHJvdG9jb2xFcnJvciwgXCJTRVRUSU5HU19FTkFCTEVfUFVTSCBtdXN0IGJlIDAgb3IgMVwiKSlcbiAgICBlbHNlIGlmIGlzX2NsaWVudCAmJiB2ID0gMVxuICAgIHRoZW5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnOC4yOlxuICAgICAgICogICBDbGllbnRzIE1VU1QgcmVqZWN0IGFueSBhdHRlbXB0IHRvIGNoYW5nZSB0aGVcbiAgICAgICAqICAgU0VUVElOR1NfRU5BQkxFX1BVU0ggc2V0dGluZyB0byBhIHZhbHVlIG90aGVyIHRoYW4gMCBieVxuICAgICAgICogICB0cmVhdGluZyB0aGUgbWVzc2FnZSBhcyBhIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mXG4gICAgICAgKiAgIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgICBFcnJvclxuICAgICAgICBFcnJvci4oXG4gICAgICAgICAgQ29ubmVjdGlvbkVycm9yXG4gICAgICAgICAgICAoUHJvdG9jb2xFcnJvciwgXCJTZXJ2ZXIgbXVzdCBub3QgdHJ5IHRvIGVuYWJsZSBTRVRUSU5HU19FTkFCTEVfUFVTSFwiKSlcbiAgICBlbHNlIE9rICgpXG4gIHwgSW5pdGlhbFdpbmRvd1NpemUgdiB3aGVuIFdpbmRvd1NpemUuaXNfd2luZG93X292ZXJmbG93IHYgLT5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNS4yXG4gICAgICogICBWYWx1ZXMgYWJvdmUgdGhlIG1heGltdW0gZmxvdy1jb250cm9sIHdpbmRvdyBzaXplIG9mIDJeMzEtMSBNVVNUIGJlXG4gICAgICogICB0cmVhdGVkIGFzIGEgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZVxuICAgICAqICAgRkxPV19DT05UUk9MX0VSUk9SLiAqKVxuICAgIEVycm9yXG4gICAgICBFcnJvci4oXG4gICAgICAgIENvbm5lY3Rpb25FcnJvclxuICAgICAgICAgICggRmxvd0NvbnRyb2xFcnJvclxuICAgICAgICAgICwgRm9ybWF0LnNwcmludGZcbiAgICAgICAgICAgICAgXCJXaW5kb3cgc2l6ZSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlbGRcIlxuICAgICAgICAgICAgICBXaW5kb3dTaXplLm1heF93aW5kb3dfc2l6ZSApKVxuICB8IE1heEZyYW1lU2l6ZSB2IHdoZW4gdiA8IDE2Mzg0IHx8IHYgPiAxNjc3NzIxNSAtPlxuICAgICgqIEZyb20gUkZDNzU0MMKnNi41LjJcbiAgICAgKiAgIFRoZSBpbml0aWFsIHZhbHVlIGlzIDIxNCAoMTYsMzg0KSBvY3RldHMuIFRoZSB2YWx1ZSBhZHZlcnRpc2VkIGJ5IGFuXG4gICAgICogICBlbmRwb2ludCBNVVNUIGJlIGJldHdlZW4gdGhpcyBpbml0aWFsIHZhbHVlIGFuZCB0aGUgbWF4aW11bSBhbGxvd2VkXG4gICAgICogICBmcmFtZSBzaXplICgyMjQtMSBvciAxNiw3NzcsMjE1IG9jdGV0cyksIGluY2x1c2l2ZS4gVmFsdWVzIG91dHNpZGVcbiAgICAgKiAgIHRoaXMgcmFuZ2UgTVVTVCBiZSB0cmVhdGVkIGFzIGEgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvbiA1LjQuMSkgb2ZcbiAgICAgKiAgIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgRXJyb3JcbiAgICAgIEVycm9yLihcbiAgICAgICAgQ29ubmVjdGlvbkVycm9yXG4gICAgICAgICAgKFByb3RvY29sRXJyb3IsIFwiTWF4IGZyYW1lIHNpemUgbXVzdCBiZSBpbiB0aGUgMTYzODQgLSAxNjc3NzIxNSByYW5nZVwiKSlcbiAgfCBfIC0+IE9rICgpXG5cbigqIENoZWNrIGluY29taW5nIHNldHRpbmdzIGFuZCByZXBvcnQgYW4gZXJyb3IgaWYgYW55LiAqKVxubGV0IGNoZWNrX3NldHRpbmdzX2xpc3QgPyhpc19jbGllbnQgPSBmYWxzZSkgc2V0dGluZ3MgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gT2sgKClcbiAgICB8IHggOjogeHMgLT5cbiAgICAgIChtYXRjaCBjaGVja192YWx1ZSB+aXNfY2xpZW50IHggd2l0aFxuICAgICAgfCBPayAoKSAtPiBsb29wIHhzXG4gICAgICB8IEVycm9yIF8gYXMgZXJyIC0+IGVycilcbiAgaW5cbiAgbG9vcCBzZXR0aW5nc1xuXG50eXBlIHQgPVxuICB7IGhlYWRlcl90YWJsZV9zaXplIDogaW50XG4gIDsgZW5hYmxlX3B1c2ggOiBib29sXG4gIDsgbWF4X2NvbmN1cnJlbnRfc3RyZWFtcyA6IGludDMyXG4gIDsgKCogSW5kaWNhdGVzIHRoZSBhbW91bnQgdG9rZW5zIHRoZSBwZWVyIGFsbG93cyBhbiBIMiBlbmRwb2ludCB0byBzZW5kLiAqKVxuICAgIGluaXRpYWxfd2luZG93X3NpemUgOiBXaW5kb3dTaXplLnRcbiAgOyBtYXhfZnJhbWVfc2l6ZSA6IGludFxuICA7IG1heF9oZWFkZXJfbGlzdF9zaXplIDogaW50IG9wdGlvblxuICB9XG5cbigqIEZyb20gUkZDNzU0MMKnMTEuMyAqKVxubGV0IGRlZmF1bHQgPVxuICB7IGhlYWRlcl90YWJsZV9zaXplID0gMHgxMDAwXG4gIDsgZW5hYmxlX3B1c2ggPVxuICAgICAgdHJ1ZVxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjUuMjpcbiAgICAgICAqICAgU0VUVElOR1NfTUFYX0NPTkNVUlJFTlRfU1RSRUFNUyAoMHgzKTogWy4uLl0gSW5pdGlhbGx5LCB0aGVyZSBpcyBub1xuICAgICAgICogICBsaW1pdCB0byB0aGlzIHZhbHVlLiAqKVxuICA7IG1heF9jb25jdXJyZW50X3N0cmVhbXMgPSBJbnQzMi5tYXhfaW50XG4gIDsgaW5pdGlhbF93aW5kb3dfc2l6ZSA9IFdpbmRvd1NpemUuZGVmYXVsdF9pbml0aWFsX3dpbmRvd19zaXplXG4gIDsgbWF4X2ZyYW1lX3NpemUgPSAweDQwMDBcbiAgOyBtYXhfaGVhZGVyX2xpc3Rfc2l6ZSA9IE5vbmVcbiAgfVxuXG5sZXQgc2V0dGluZ3NfZm9yX3RoZV9jb25uZWN0aW9uIHNldHRpbmdzID1cbiAgbGV0IHNldHRpbmdzX2xpc3QgPVxuICAgIGlmIHNldHRpbmdzLm1heF9mcmFtZV9zaXplIDw+IGRlZmF1bHQubWF4X2ZyYW1lX3NpemVcbiAgICB0aGVuIFsgTWF4RnJhbWVTaXplIHNldHRpbmdzLm1heF9mcmFtZV9zaXplIF1cbiAgICBlbHNlIFtdXG4gIGluXG4gIGxldCBzZXR0aW5nc19saXN0ID1cbiAgICBpZiBzZXR0aW5ncy5tYXhfY29uY3VycmVudF9zdHJlYW1zIDw+IGRlZmF1bHQubWF4X2NvbmN1cnJlbnRfc3RyZWFtc1xuICAgIHRoZW4gTWF4Q29uY3VycmVudFN0cmVhbXMgc2V0dGluZ3MubWF4X2NvbmN1cnJlbnRfc3RyZWFtcyA6OiBzZXR0aW5nc19saXN0XG4gICAgZWxzZSBzZXR0aW5nc19saXN0XG4gIGluXG4gIGxldCBzZXR0aW5nc19saXN0ID1cbiAgICBpZiBzZXR0aW5ncy5pbml0aWFsX3dpbmRvd19zaXplIDw+IGRlZmF1bHQuaW5pdGlhbF93aW5kb3dfc2l6ZVxuICAgIHRoZW5cbiAgICAgICgqIEZJWE1FOiBkb24ndCBjb252ZXJ0ICopXG4gICAgICBJbml0aWFsV2luZG93U2l6ZSBzZXR0aW5ncy5pbml0aWFsX3dpbmRvd19zaXplIDo6IHNldHRpbmdzX2xpc3RcbiAgICBlbHNlIHNldHRpbmdzX2xpc3RcbiAgaW5cbiAgbGV0IHNldHRpbmdzX2xpc3QgPVxuICAgIGlmIHNldHRpbmdzLmVuYWJsZV9wdXNoIDw+IGRlZmF1bHQuZW5hYmxlX3B1c2hcbiAgICB0aGVuIEVuYWJsZVB1c2ggKGlmIHNldHRpbmdzLmVuYWJsZV9wdXNoIHRoZW4gMSBlbHNlIDApIDo6IHNldHRpbmdzX2xpc3RcbiAgICBlbHNlIHNldHRpbmdzX2xpc3RcbiAgaW5cbiAgc2V0dGluZ3NfbGlzdFxuXG5sZXQgcGFyc2Vfc2V0dGluZ3NfcGF5bG9hZCBudW1fc2V0dGluZ3MgPVxuICBsZXQgb3BlbiBBbmdzdHJvbSBpblxuICBsZXQgcmVjIHBhcnNlX2lubmVyIGFjYyByZW1haW5pbmcgPVxuICAgICgqIEZyb20gUkZDNzU0MMKnNi41LjM6XG4gICAgICogICBUaGUgdmFsdWVzIGluIHRoZSBTRVRUSU5HUyBmcmFtZSBNVVNUIGJlIHByb2Nlc3NlZCBpbiB0aGUgb3JkZXJcbiAgICAgKiAgIHRoZXkgYXBwZWFyLCB3aXRoIG5vIG90aGVyIGZyYW1lIHByb2Nlc3NpbmcgYmV0d2VlbiB2YWx1ZXMuICopXG4gICAgaWYgcmVtYWluaW5nIDw9IDBcbiAgICB0aGVuIHJldHVybiAoTGlzdC5yZXYgYWNjKVxuICAgIGVsc2VcbiAgICAgIGxpZnQyXG4gICAgICAgIChmdW4gayAodiA6IGludDMyKSAtPlxuICAgICAgICAgICBtYXRjaCBrIHdpdGhcbiAgICAgICAgICAgfCAweDEgLT4gSGVhZGVyVGFibGVTaXplIChJbnQzMi50b19pbnQgdikgOjogYWNjXG4gICAgICAgICAgIHwgMHgyIC0+IEVuYWJsZVB1c2ggKEludDMyLnRvX2ludCB2KSA6OiBhY2NcbiAgICAgICAgICAgfCAweDMgLT4gTWF4Q29uY3VycmVudFN0cmVhbXMgdiA6OiBhY2NcbiAgICAgICAgICAgfCAweDQgLT4gSW5pdGlhbFdpbmRvd1NpemUgdiA6OiBhY2NcbiAgICAgICAgICAgfCAweDUgLT4gTWF4RnJhbWVTaXplIChJbnQzMi50b19pbnQgdikgOjogYWNjXG4gICAgICAgICAgIHwgMHg2IC0+IE1heEhlYWRlckxpc3RTaXplIChJbnQzMi50b19pbnQgdikgOjogYWNjXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICgqIE5vdGU6IFRoaXMgaWdub3JlcyB1bmtub3duIHNldHRpbmdzLlxuICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICogRnJvbSBSRkM3NTQwwqc2LjUuMzpcbiAgICAgICAgICAgICAgKiAgIFVuc3VwcG9ydGVkIHBhcmFtZXRlcnMgTVVTVCBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgICAqKVxuICAgICAgICAgICAgIGFjYylcbiAgICAgICAgQkUuYW55X3VpbnQxNlxuICAgICAgICBCRS5hbnlfaW50MzJcbiAgICAgID4+PSBmdW4gYWNjJyAtPiBwYXJzZV9pbm5lciBhY2MnIChyZW1haW5pbmcgLSAxKVxuICBpblxuICBwYXJzZV9pbm5lciBbXSBudW1fc2V0dGluZ3NcblxubGV0IHdyaXRlX3NldHRpbmdzX3BheWxvYWQgdCBzZXR0aW5nc19saXN0ID1cbiAgbGV0IG9wZW4gRmFyYWRheSBpblxuICBMaXN0Lml0ZXJcbiAgICAoZnVuIHNldHRpbmcgLT5cbiAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNS4xOlxuICAgICAgICAqICAgVGhlIHBheWxvYWQgb2YgYSBTRVRUSU5HUyBmcmFtZSBjb25zaXN0cyBvZiB6ZXJvIG9yIG1vcmUgcGFyYW1ldGVycyxcbiAgICAgICAgKiAgIGVhY2ggY29uc2lzdGluZyBvZiBhbiB1bnNpZ25lZCAxNi1iaXQgc2V0dGluZyBpZGVudGlmaWVyIGFuZCBhblxuICAgICAgICAqICAgdW5zaWduZWQgMzItYml0IHZhbHVlLiAqKVxuICAgICAgIEJFLndyaXRlX3VpbnQxNiB0IChzZXJpYWxpemVfa2V5IHNldHRpbmcpO1xuICAgICAgIG1hdGNoIHNldHRpbmcgd2l0aFxuICAgICAgIHwgTWF4Q29uY3VycmVudFN0cmVhbXMgdmFsdWUgfCBJbml0aWFsV2luZG93U2l6ZSB2YWx1ZSAtPlxuICAgICAgICAgQkUud3JpdGVfdWludDMyIHQgdmFsdWVcbiAgICAgICB8IEhlYWRlclRhYmxlU2l6ZSB2YWx1ZVxuICAgICAgIHwgRW5hYmxlUHVzaCB2YWx1ZVxuICAgICAgIHwgTWF4RnJhbWVTaXplIHZhbHVlXG4gICAgICAgfCBNYXhIZWFkZXJMaXN0U2l6ZSB2YWx1ZSAtPlxuICAgICAgICAgQkUud3JpdGVfdWludDMyIHQgKEludDMyLm9mX2ludCB2YWx1ZSkpXG4gICAgc2V0dGluZ3NfbGlzdFxuXG5sZXQgb2Zfc2V0dGluZ3NfbGlzdCBzZXR0aW5ncyA9XG4gIExpc3QuZm9sZF9sZWZ0XG4gICAgKGZ1biAoYWNjIDogdCkgaXRlbSAtPlxuICAgICAgIG1hdGNoIGl0ZW0gd2l0aFxuICAgICAgIHwgSGVhZGVyVGFibGVTaXplIHggLT4geyBhY2Mgd2l0aCBoZWFkZXJfdGFibGVfc2l6ZSA9IHggfVxuICAgICAgIHwgRW5hYmxlUHVzaCB4IC0+IHsgYWNjIHdpdGggZW5hYmxlX3B1c2ggPSB4ID0gMSB9XG4gICAgICAgfCBNYXhDb25jdXJyZW50U3RyZWFtcyB4IC0+IHsgYWNjIHdpdGggbWF4X2NvbmN1cnJlbnRfc3RyZWFtcyA9IHggfVxuICAgICAgIHwgSW5pdGlhbFdpbmRvd1NpemUgbmV3X3ZhbCAtPiB7IGFjYyB3aXRoIGluaXRpYWxfd2luZG93X3NpemUgPSBuZXdfdmFsIH1cbiAgICAgICB8IE1heEZyYW1lU2l6ZSB4IC0+IHsgYWNjIHdpdGggbWF4X2ZyYW1lX3NpemUgPSB4IH1cbiAgICAgICB8IE1heEhlYWRlckxpc3RTaXplIHggLT4geyBhY2Mgd2l0aCBtYXhfaGVhZGVyX2xpc3Rfc2l6ZSA9IFNvbWUgeCB9KVxuICAgIGRlZmF1bHRcbiAgICBzZXR0aW5nc1xuXG5sZXQgb2ZfYmFzZTY0IGVuY29kZWQgPVxuICBtYXRjaCBCYXNlNjQuZGVjb2RlIH5hbHBoYWJldDpCYXNlNjQudXJpX3NhZmVfYWxwaGFiZXQgZW5jb2RlZCB3aXRoXG4gIHwgT2sgc2V0dGluZ3NfcGF5bG9hZCAtPlxuICAgIGxldCBzZXR0aW5nc19wYXlsb2FkX2xlbmd0aCA9XG4gICAgICBTdHJpbmcubGVuZ3RoIHNldHRpbmdzX3BheWxvYWQgLyBvY3RldHNfcGVyX3NldHRpbmdcbiAgICBpblxuICAgIChtYXRjaFxuICAgICAgIEFuZ3N0cm9tLnBhcnNlX3N0cmluZ1xuICAgICAgICAgfmNvbnN1bWU6QWxsXG4gICAgICAgICAocGFyc2Vfc2V0dGluZ3NfcGF5bG9hZCBzZXR0aW5nc19wYXlsb2FkX2xlbmd0aClcbiAgICAgICAgIHNldHRpbmdzX3BheWxvYWRcbiAgICAgd2l0aFxuICAgIHwgT2sgc2V0dGluZ3MgLT4gT2sgKG9mX3NldHRpbmdzX2xpc3Qgc2V0dGluZ3MpXG4gICAgfCBFcnJvciBfIGFzIGUgLT4gZSlcbiAgfCBFcnJvciAoYE1zZyBtc2cpIC0+IEVycm9yIG1zZ1xuXG5sZXQgdG9fYmFzZTY0IHQgPVxuICBsZXQgc2V0dGluZ3MgPSBzZXR0aW5nc19mb3JfdGhlX2Nvbm5lY3Rpb24gdCBpblxuICBsZXQgZmFyYWRheSA9IEZhcmFkYXkuY3JlYXRlIChMaXN0Lmxlbmd0aCBzZXR0aW5ncyAqIDYpIGluXG4gIHdyaXRlX3NldHRpbmdzX3BheWxvYWQgZmFyYWRheSBzZXR0aW5ncztcbiAgbGV0IHNldHRpbmdzX2hleCA9IEZhcmFkYXkuc2VyaWFsaXplX3RvX3N0cmluZyBmYXJhZGF5IGluXG4gIG1hdGNoIEJhc2U2NC5lbmNvZGUgfmFscGhhYmV0OkJhc2U2NC51cmlfc2FmZV9hbHBoYWJldCBzZXR0aW5nc19oZXggd2l0aFxuICB8IE9rIHIgLT4gT2sgclxuICB8IEVycm9yIChgTXNnIG1zZykgLT4gRXJyb3IgbXNnXG5cbmxldCBwcF9odW0gZm9ybWF0dGVyIHQgPVxuICBsZXQgcHBfZWxlbSBmb3JtYXR0ZXIgc2V0dGluZyA9XG4gICAgbGV0IGtleSwgdmFsdWUgPVxuICAgICAgbWF0Y2ggc2V0dGluZyB3aXRoXG4gICAgICB8IEhlYWRlclRhYmxlU2l6ZSB2IC0+IFwiSEVBREVSX1RBQkxFX1NJWkVcIiwgSW50NjQub2ZfaW50IHZcbiAgICAgIHwgRW5hYmxlUHVzaCB2IC0+IFwiRU5BQkxFX1BVU0hcIiwgSW50NjQub2ZfaW50IHZcbiAgICAgIHwgTWF4Q29uY3VycmVudFN0cmVhbXMgdiAtPiBcIk1BWF9DT05DVVJSRU5UX1NUUkVBTVNcIiwgSW50NjQub2ZfaW50MzIgdlxuICAgICAgfCBJbml0aWFsV2luZG93U2l6ZSB2IC0+IFwiSU5JVElBTF9XSU5ET1dfU0laRVwiLCBJbnQ2NC5vZl9pbnQzMiB2XG4gICAgICB8IE1heEZyYW1lU2l6ZSB2IC0+IFwiTUFYX0ZSQU1FX1NJWkVcIiwgSW50NjQub2ZfaW50IHZcbiAgICAgIHwgTWF4SGVhZGVyTGlzdFNpemUgdiAtPiBcIk1BWF9IRUFERVJfTElTVF9TSVpFXCIsIEludDY0Lm9mX2ludCB2XG4gICAgaW5cbiAgICBGb3JtYXQuZnByaW50ZiBmb3JtYXR0ZXIgXCJAWyglUyAlTGQpQF1cIiBrZXkgdmFsdWVcbiAgaW5cbiAgRm9ybWF0LmZwcmludGYgZm9ybWF0dGVyIFwiQFsoXCI7XG4gIEZvcm1hdC5wcF9wcmludF9saXN0IHBwX2VsZW0gZm9ybWF0dGVyIChzZXR0aW5nc19mb3JfdGhlX2Nvbm5lY3Rpb24gdCk7XG4gIEZvcm1hdC5mcHJpbnRmIGZvcm1hdHRlciBcIilAXVwiXG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuICogIENvcHlyaWdodCAoYykgMjAxOSBBbnRvbmlvIE4uIE1vbnRlaXJvLlxuICpcbiAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqICBhcmUgbWV0OlxuICpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIG5vciB0aGUgbmFtZXMgb2YgaGlzIGNvbnRyaWJ1dG9yc1xuICogICAgIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogICAgIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICogIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICogIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAqICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICogIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICogIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAqICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAqICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxuKCogVE9ETzogYWRkIGEgY29uZmlnIG9wdGlvbiBmb3IgYFJlcWRgIHRvIGZsdXNoIG1heCBieXRlcyBhdCBhIHRpbWU/ICopXG50eXBlIHQgPVxuICB7IHJlYWRfYnVmZmVyX3NpemUgOiBpbnRcbiAgOyByZXF1ZXN0X2JvZHlfYnVmZmVyX3NpemUgOiBpbnRcbiAgOyByZXNwb25zZV9ib2R5X2J1ZmZlcl9zaXplIDogaW50XG4gIDsgZW5hYmxlX3NlcnZlcl9wdXNoIDogYm9vbFxuICA7IG1heF9jb25jdXJyZW50X3N0cmVhbXMgOiBpbnQzMlxuICA7IGluaXRpYWxfd2luZG93X3NpemUgOiBpbnQzMlxuICB9XG5cbmxldCBkZWZhdWx0ID1cbiAgeyAoKiBUaGlzIGlzIGVmZmVjdGl2ZWx5IE1BWF9GUkFNRV9TSVpFLCBiZWNhdXNlIHRoZSBwYXJzZXIgY29tbWl0cyB0aGUgZnJhbWVcbiAgICAgKiBoZWFkZXIgdG8gcHJldmVudCBiYWNrdHJhY2tpbmcsIHRoZXJlZm9yZSB0aGUgZW50aXJlIHBheWxvYWQgY2FuIGZpdCB0aGVcbiAgICAgKiByZWFkIGJ1ZmZlci4gVGhlIGRlZmF1bHQgaXMgMTYzODQsIGFuZCBjYW4ndCBiZSBsb3dlciB0aGFuIHRoYXQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBoMiBkb2VzIG5vdCBjaGVjayB0aGF0IE1BWF9GUkFNRV9TSVpFIGlzIGxvd2VyIHRoYW4gMTYzODRcbiAgICAgKiBvY3RldHMuIEluIHRoZSBjYXNlIHRoYXQgYSBsb3dlciB2YWx1ZSB0aGFuIHBlcm1pdHRlZCBpcyBzZXQsIHBlZXJzIHdpbGxcbiAgICAgKiByZWplY3QgdGhlIHNldHRpbmcgYW5kIGNsb3NlIHRoZSBjb25uZWN0aW9uIHdpdGggYSBQUk9UT0NPTF9FUlJPUi5cbiAgICAgKlxuICAgICAqIEZyb20gUkZDNzU0MMKnNi41LjI6XG4gICAgICogICBTRVRUSU5HU19NQVhfRlJBTUVfU0laRSAoMHg1KTogSW5kaWNhdGVzIHRoZSBzaXplIG9mIHRoZSBsYXJnZXN0IGZyYW1lXG4gICAgICogICBwYXlsb2FkIHRoYXQgdGhlIHNlbmRlciBpcyB3aWxsaW5nIHRvIHJlY2VpdmUsIGluIG9jdGV0cy5cbiAgICAgKiAgIFRoZSBpbml0aWFsIHZhbHVlIGlzIDJeMTQgKDE2LDM4NCkgb2N0ZXRzLiBUaGUgdmFsdWUgYWR2ZXJ0aXNlZCBieSBhblxuICAgICAqICAgZW5kcG9pbnQgTVVTVCBiZSBiZXR3ZWVuIHRoaXMgaW5pdGlhbCB2YWx1ZSBhbmQgdGhlIG1heGltdW0gYWxsb3dlZFxuICAgICAqICAgZnJhbWUgc2l6ZSAoMl4yNC0xIG9yIDE2LDc3NywyMTUgb2N0ZXRzKSwgaW5jbHVzaXZlLiAqKVxuICAgIHJlYWRfYnVmZmVyX3NpemUgPSBTZXR0aW5ncy5kZWZhdWx0Lm1heF9mcmFtZV9zaXplXG4gIDsgKCogQnVmZmVyIHNpemUgZm9yIHJlcXVlc3QgYm9kaWVzICopIHJlcXVlc3RfYm9keV9idWZmZXJfc2l6ZSA9IDB4MTAwMFxuICA7ICgqIEJ1ZmZlciBzaXplIGZvciByZXNwb25zZSBib2RpZXMgKikgcmVzcG9uc2VfYm9keV9idWZmZXJfc2l6ZSA9IDB4MTAwMFxuICA7IGVuYWJsZV9zZXJ2ZXJfcHVzaCA9IHRydWVcbiAgOyAoKiBGcm9tIFJGQzc1NDDCpzYuNS4yOlxuICAgICAqICAgSW5kaWNhdGVzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IHN0cmVhbXMgdGhhdCB0aGUgc2VuZGVyXG4gICAgICogICB3aWxsIGFsbG93LiBUaGlzIGxpbWl0IGlzIGRpcmVjdGlvbmFsOiBpdCBhcHBsaWVzIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgKiAgIHN0cmVhbXMgdGhhdCB0aGUgc2VuZGVyIHBlcm1pdHMgdGhlIHJlY2VpdmVyIHRvIGNyZWF0ZS4gKilcbiAgICBtYXhfY29uY3VycmVudF9zdHJlYW1zID0gU2V0dGluZ3MuZGVmYXVsdC5tYXhfY29uY3VycmVudF9zdHJlYW1zXG4gIDsgKCogSW5kaWNhdGVzIHRoZSBpbml0aWFsIHdpbmRvdyBzaXplIHdoZW4gcmVjZWl2aW5nIGRhdGEgZnJvbSByZW1vdGVcbiAgICAgKiBzdHJlYW1zLiBJbiBvdGhlciB3b3JkcywgcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIG9jdGV0cyB0aGF0IHRoZSBIMlxuICAgICAqIGVuZHBvaW50IGlzIHdpbGxpbmcgdG8gcmVjZWl2ZSBmcm9tIHRoZSBwZWVyLiBDYW5ub3QgYmUgbG93ZXIgdGhhblxuICAgICAqIDY1NTM1ICh0aGUgZGVmYXVsdCBhcyBwZXIgdGhlIHNwZWMpLiBUaGUgZGVmYXVsdCBpbiBIMiBpcyAyXjI3LCBvclxuICAgICAqIDEyOCBNaUIuICopXG4gICAgKCogVE9ETyhhbm1vbnRlaXJvKTogdmFsaWRhdGUgdGhlIGRlZmF1bHQgc29tZXdoZXJlLiAqKVxuICAgIGluaXRpYWxfd2luZG93X3NpemUgPSBJbnQzMi5zaGlmdF9sZWZ0IDFsIDI3XG4gIH1cblxubGV0IHRvX3NldHRpbmdzXG4gICAgeyByZWFkX2J1ZmZlcl9zaXplXG4gICAgOyBtYXhfY29uY3VycmVudF9zdHJlYW1zXG4gICAgOyBpbml0aWFsX3dpbmRvd19zaXplXG4gICAgOyBlbmFibGVfc2VydmVyX3B1c2hcbiAgICA7IF9cbiAgICB9XG4gID1cbiAgeyBTZXR0aW5ncy5kZWZhdWx0IHdpdGhcbiAgICBtYXhfZnJhbWVfc2l6ZSA9IHJlYWRfYnVmZmVyX3NpemVcbiAgOyBtYXhfY29uY3VycmVudF9zdHJlYW1zXG4gIDsgaW5pdGlhbF93aW5kb3dfc2l6ZVxuICA7IGVuYWJsZV9wdXNoID0gZW5hYmxlX3NlcnZlcl9wdXNoXG4gIH1cbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAxOSBBbnTDs25pbyBOdW5vIE1vbnRlaXJvXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXNcbiAqICBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiAgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiAgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqICBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbm9wZW4gVXRpbFxuXG50eXBlIHQgPSBpbnRcblxuKCogRnJvbSBSRkM3NTQwwqc2LjI6XG4gKiAgIEZsYWdzIHRoYXQgaGF2ZSBubyBkZWZpbmVkIHNlbWFudGljcyBmb3IgYSBwYXJ0aWN1bGFyIGZyYW1lIHR5cGUgTVVTVCBiZVxuICogICBpZ25vcmVkIGFuZCBNVVNUIGJlIGxlZnQgdW5zZXQgKDB4MCkgd2hlbiBzZW5kaW5nLiAqKVxubGV0IGRlZmF1bHRfZmxhZ3MgPSAweDBcblxuKCogRnJvbSBSRkM3NTQwwqc2LjI6XG4gKiAgIEVORF9TVFJFQU0gKDB4MSk6IFdoZW4gc2V0LCBiaXQgMCBpbmRpY2F0ZXMgdGhhdCB0aGUgaGVhZGVyIGJsb2NrIChTZWN0aW9uXG4gKiAgIDQuMykgaXMgdGhlIGxhc3QgdGhhdCB0aGUgZW5kcG9pbnQgd2lsbCBzZW5kIGZvciB0aGUgaWRlbnRpZmllZCBzdHJlYW0uICopXG5sZXQgdGVzdF9lbmRfc3RyZWFtIHggPSB0ZXN0X2JpdCB4IDBcbmxldCBzZXRfZW5kX3N0cmVhbSB4ID0gc2V0X2JpdCB4IDBcbmxldCBjbGVhcl9lbmRfc3RyZWFtIHggPSBjbGVhcl9iaXQgeCAwXG5cbigqIEZyb20gUkZDNzU0MMKnNi43OlxuICogICBBQ0sgKDB4MSk6IFdoZW4gc2V0LCBiaXQgMCBpbmRpY2F0ZXMgdGhhdCB0aGlzIFBJTkcgZnJhbWUgaXMgYSBQSU5HXG4gKiAgIHJlc3BvbnNlLiAqKVxubGV0IHRlc3RfYWNrIHggPSB0ZXN0X2JpdCB4IDBcbmxldCBzZXRfYWNrIHggPSBzZXRfYml0IHggMFxuXG4oKiBGcm9tIFJGQzc1NDDCpzYuMjpcbiAqICAgRU5EX0hFQURFUlMgKDB4NCk6IFdoZW4gc2V0LCBiaXQgMiBpbmRpY2F0ZXMgdGhhdCB0aGlzIGZyYW1lIGNvbnRhaW5zIGFuXG4gKiAgIGVudGlyZSBoZWFkZXIgYmxvY2sgKFNlY3Rpb24gNC4zKSBhbmQgaXMgbm90IGZvbGxvd2VkIGJ5IGFueSBDT05USU5VQVRJT05cbiAqICAgZnJhbWVzLiAqKVxubGV0IHRlc3RfZW5kX2hlYWRlciB4ID0gdGVzdF9iaXQgeCAyXG5sZXQgc2V0X2VuZF9oZWFkZXIgeCA9IHNldF9iaXQgeCAyXG5cbigqIEZyb20gUkZDNzU0MMKnNi4yOlxuICogICBQQURERUQgKDB4OCk6IFdoZW4gc2V0LCBiaXQgMyBpbmRpY2F0ZXMgdGhhdCB0aGUgUGFkIExlbmd0aCBmaWVsZCBhbmQgYW55XG4gKiAgIHBhZGRpbmcgdGhhdCBpdCBkZXNjcmliZXMgYXJlIHByZXNlbnQuICopXG5sZXQgdGVzdF9wYWRkZWQgeCA9IHRlc3RfYml0IHggM1xubGV0IHNldF9wYWRkZWQgeCA9IHNldF9iaXQgeCAzXG5cbigqIEZyb20gUkZDNzU0MMKnNi4yOlxuICogICBQUklPUklUWSAoMHgyMCk6IFdoZW4gc2V0LCBiaXQgNSBpbmRpY2F0ZXMgdGhhdCB0aGUgRXhjbHVzaXZlIEZsYWcgKEUpLFxuICogICBTdHJlYW0gRGVwZW5kZW5jeSwgYW5kIFdlaWdodCBmaWVsZHMgYXJlIHByZXNlbnQ7IHNlZSBTZWN0aW9uIDUuMy4gKilcbmxldCB0ZXN0X3ByaW9yaXR5IHggPSB0ZXN0X2JpdCB4IDVcbmxldCBzZXRfcHJpb3JpdHkgeCA9IHNldF9iaXQgeCA1XG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIDIwMTkgQW50w7NuaW8gTnVubyBNb250ZWlyb1xuICpcbiAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzXG4gKiAgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqICBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiAgQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG5vcGVuIFV0aWxcblxudHlwZSB0ID1cbiAgeyBleGNsdXNpdmUgOiBib29sXG4gIDsgc3RyZWFtX2RlcGVuZGVuY3kgOiBTdHJlYW1faWRlbnRpZmllci50XG4gIDsgd2VpZ2h0IDogaW50XG4gIH1cblxuKCogRnJvbSBSRkM3NTQwwqc1LjMuNTpcbiAqICAgQWxsIHN0cmVhbXMgYXJlIGluaXRpYWxseSBhc3NpZ25lZCBhIG5vbi1leGNsdXNpdmUgZGVwZW5kZW5jeSBvbiBzdHJlYW1cbiAqICAgMHgwLiBQdXNoZWQgc3RyZWFtcyAoU2VjdGlvbiA4LjIpIGluaXRpYWxseSBkZXBlbmQgb24gdGhlaXIgYXNzb2NpYXRlZFxuICogICBzdHJlYW0uIEluIGJvdGggY2FzZXMsIHN0cmVhbXMgYXJlIGFzc2lnbmVkIGEgZGVmYXVsdCB3ZWlnaHQgb2YgMTYuICopXG5sZXQgZGVmYXVsdF9wcmlvcml0eSA9XG4gIHsgZXhjbHVzaXZlID0gZmFsc2U7IHN0cmVhbV9kZXBlbmRlbmN5ID0gMGw7IHdlaWdodCA9IDE2IH1cblxuKCogRnJvbSBSRkM3NTQwwqc1LjQuMTpcbiAqICAgQWxsIGRlcGVuZGVudCBzdHJlYW1zIGFyZSBhbGxvY2F0ZWQgYW4gaW50ZWdlciB3ZWlnaHQgYmV0d2VlbiAxIGFuZCAyNTZcbiAqICAgKGluY2x1c2l2ZSkuICopXG5sZXQgaGlnaGVzdF9wcmlvcml0eSA9XG4gIHsgZXhjbHVzaXZlID0gZmFsc2U7IHN0cmVhbV9kZXBlbmRlbmN5ID0gMGw7IHdlaWdodCA9IDI1NiB9XG5cbigqIC0tLSBFeGNsdXNpdmUgZmxhZyAtLS1cbiAqXG4gKiBGcm9tIFJGQzc1NDDCpzUuNC4xOlxuICogICArLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICB8RXwgICAgICAgICAgICAgICAgICBTdHJlYW0gRGVwZW5kZW5jeSAoMzEpICAgICAgICAgICAgICAgICAgICAgfFxuICogICArLSstLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogICB8ICAgV2VpZ2h0ICg4KSAgfFxuICogICArLSstLS0tLS0tLS0tLS0tK1xuICopXG5cbmxldCB0ZXN0X2V4Y2x1c2l2ZSBuID0gdGVzdF9iaXRfaW50MzIgbiAzMVxubGV0IHNldF9leGNsdXNpdmUgbiA9IHNldF9iaXRfaW50MzIgbiAzMVxubGV0IGNsZWFyX2V4Y2x1c2l2ZSBuID0gY2xlYXJfYml0X2ludDMyIG4gMzFcblxubGV0IGVxdWFsIHAxIHAyID1cbiAgcDEud2VpZ2h0ID0gcDIud2VpZ2h0XG4gICYmIEludDMyLmVxdWFsIHAxLnN0cmVhbV9kZXBlbmRlbmN5IHAyLnN0cmVhbV9kZXBlbmRlbmN5XG4gICYmIHAxLmV4Y2x1c2l2ZSA9IHAyLmV4Y2x1c2l2ZVxuIiwiKCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE5IEFudMOzbmlvIE51bm8gTW9udGVpcm9cbiAqXG4gKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpc1xuICogIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiAqICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiAgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqICBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiAqICBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxubGV0IGNvbm5lY3Rpb25fcHJlZmFjZSA9IFwiUFJJICogSFRUUC8yLjBcXHJcXG5cXHJcXG5TTVxcclxcblxcclxcblwiXG5cbm1vZHVsZSBGcmFtZVR5cGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuMTpcbiAgICAgKiAgIERBVEEgZnJhbWVzICh0eXBlPTB4MCkgY29udmV5IGFyYml0cmFyeSwgdmFyaWFibGUtbGVuZ3RoIHNlcXVlbmNlc1xuICAgICAqICAgb2Ygb2N0ZXRzIGFzc29jaWF0ZWQgd2l0aCBhIHN0cmVhbS4gKilcbiAgICB8IERhdGFcbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuMjpcbiAgICAgKiAgIFRoZSBIRUFERVJTIGZyYW1lICh0eXBlPTB4MSkgaXMgdXNlZCB0byBvcGVuIGEgc3RyZWFtIChTZWN0aW9uIDUuMSksXG4gICAgICogICBhbmQgYWRkaXRpb25hbGx5IGNhcnJpZXMgYSBoZWFkZXIgYmxvY2sgZnJhZ21lbnQuICopXG4gICAgfCBIZWFkZXJzXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2LjM6XG4gICAgICogICBUaGUgUFJJT1JJVFkgZnJhbWUgKHR5cGU9MHgyKSBzcGVjaWZpZXMgdGhlIHNlbmRlci1hZHZpc2VkIHByaW9yaXR5XG4gICAgICogICBvZiBhIHN0cmVhbSAoU2VjdGlvbiA1LjMpLiAqKVxuICAgIHwgUHJpb3JpdHlcbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNDpcbiAgICAgKiAgIFRoZSBSU1RfU1RSRUFNIGZyYW1lICh0eXBlPTB4MykgYWxsb3dzIGZvciBpbW1lZGlhdGUgdGVybWluYXRpb24gb2ZcbiAgICAgKiAgIGEgc3RyZWFtLiAqKVxuICAgIHwgUlNUU3RyZWFtXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2LjU6XG4gICAgICogICBUaGUgU0VUVElOR1MgZnJhbWUgKHR5cGU9MHg0KSBjb252ZXlzIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyB0aGF0XG4gICAgICogICBhZmZlY3QgaG93IGVuZHBvaW50cyBjb21tdW5pY2F0ZSwgc3VjaCBhcyBwcmVmZXJlbmNlcyBhbmRcbiAgICAgKiAgIGNvbnN0cmFpbnRzIG9uIHBlZXIgYmVoYXZpb3IuICopXG4gICAgfCBTZXR0aW5nc1xuICAgICgqIEZyb20gUkZDNzU0MMKnNi42OlxuICAgICAqICAgVGhlIFBVU0hfUFJPTUlTRSBmcmFtZSAodHlwZT0weDUpIGlzIHVzZWQgdG8gbm90aWZ5IHRoZSBwZWVyXG4gICAgICogICBlbmRwb2ludCBpbiBhZHZhbmNlIG9mIHN0cmVhbXMgdGhlIHNlbmRlciBpbnRlbmRzIHRvIGluaXRpYXRlLiAqKVxuICAgIHwgUHVzaFByb21pc2VcbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNzpcbiAgICAgKiAgIFRoZSBQSU5HIGZyYW1lICh0eXBlPTB4NikgaXMgYSBtZWNoYW5pc20gZm9yIG1lYXN1cmluZyBhIG1pbmltYWxcbiAgICAgKiAgIHJvdW5kLXRyaXAgdGltZSBmcm9tIHRoZSBzZW5kZXIsIGFzIHdlbGwgYXMgZGV0ZXJtaW5pbmcgd2hldGhlciBhblxuICAgICAqICAgaWRsZSBjb25uZWN0aW9uIGlzIHN0aWxsIGZ1bmN0aW9uYWwuICopXG4gICAgfCBQaW5nXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2Ljg6XG4gICAgICogICBUaGUgR09BV0FZIGZyYW1lICh0eXBlPTB4NykgaXMgdXNlZCB0byBpbml0aWF0ZSBzaHV0ZG93biBvZiBhXG4gICAgICogICBjb25uZWN0aW9uIG9yIHRvIHNpZ25hbCBzZXJpb3VzIGVycm9yIGNvbmRpdGlvbnMuICopXG4gICAgfCBHb0F3YXlcbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuOTpcbiAgICAgKiAgIFRoZSBXSU5ET1dfVVBEQVRFIGZyYW1lICh0eXBlPTB4OCkgaXMgdXNlZCB0byBpbXBsZW1lbnQgZmxvd1xuICAgICAqICAgY29udHJvbDsgWy4uLl0uICopXG4gICAgfCBXaW5kb3dVcGRhdGVcbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuMTA6XG4gICAgICogICBUaGUgQ09OVElOVUFUSU9OIGZyYW1lICh0eXBlPTB4OSkgaXMgdXNlZCB0byBjb250aW51ZSBhIHNlcXVlbmNlIG9mXG4gICAgICogICBoZWFkZXIgYmxvY2sgZnJhZ21lbnRzIChTZWN0aW9uIDQuMykuICopXG4gICAgfCBDb250aW51YXRpb25cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgKiAgIEZyYW1lcyBvZiB1bmtub3duIHR5cGVzIGFyZSBpZ25vcmVkLiAqKVxuICAgIHwgVW5rbm93biBvZiBpbnRcblxuICBsZXQgc2VyaWFsaXplID0gZnVuY3Rpb25cbiAgICB8IERhdGEgLT4gMFxuICAgIHwgSGVhZGVycyAtPiAxXG4gICAgfCBQcmlvcml0eSAtPiAyXG4gICAgfCBSU1RTdHJlYW0gLT4gM1xuICAgIHwgU2V0dGluZ3MgLT4gNFxuICAgIHwgUHVzaFByb21pc2UgLT4gNVxuICAgIHwgUGluZyAtPiA2XG4gICAgfCBHb0F3YXkgLT4gN1xuICAgIHwgV2luZG93VXBkYXRlIC0+IDhcbiAgICB8IENvbnRpbnVhdGlvbiAtPiA5XG4gICAgfCBVbmtub3duIHggLT4geFxuXG4gIGxldCBwYXJzZSA9IGZ1bmN0aW9uXG4gICAgfCAwIC0+IERhdGFcbiAgICB8IDEgLT4gSGVhZGVyc1xuICAgIHwgMiAtPiBQcmlvcml0eVxuICAgIHwgMyAtPiBSU1RTdHJlYW1cbiAgICB8IDQgLT4gU2V0dGluZ3NcbiAgICB8IDUgLT4gUHVzaFByb21pc2VcbiAgICB8IDYgLT4gUGluZ1xuICAgIHwgNyAtPiBHb0F3YXlcbiAgICB8IDggLT4gV2luZG93VXBkYXRlXG4gICAgfCA5IC0+IENvbnRpbnVhdGlvblxuICAgIHwgeCAtPiBVbmtub3duIHhcbmVuZFxuXG4oKiBGcm9tIFJGQzc1NDDCpzQuMTpcbiAqICAgVGhlIGZpZWxkcyBvZiB0aGUgZnJhbWUgaGVhZGVyIGFyZSBkZWZpbmVkIGFzOlxuICpcbiAqICAgICBMZW5ndGg6IFRoZSBsZW5ndGggb2YgdGhlIGZyYW1lIHBheWxvYWQgZXhwcmVzc2VkIGFzIGFuIHVuc2lnbmVkIDI0LWJpdFxuICogICAgICAgICAgICAgaW50ZWdlci4gWy4uLl1cbiAqXG4gKiAgICAgVHlwZTogVGhlIDgtYml0IHR5cGUgb2YgdGhlIGZyYW1lLiBbLi4uXVxuICpcbiAqICAgICBGbGFnczogQW4gOC1iaXQgZmllbGQgcmVzZXJ2ZWQgZm9yIGJvb2xlYW4gZmxhZ3Mgc3BlY2lmaWMgdG8gdGhlIGZyYW1lXG4gKiAgICAgICAgICAgIHR5cGUuIFsuLi5dXG4gKlxuICogICAgIFN0cmVhbSBJZGVudGlmaWVyOiBBIHN0cmVhbSBpZGVudGlmaWVyIChzZWUgU2VjdGlvbiA1LjEuMSkgZXhwcmVzc2VkIGFzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGFuIHVuc2lnbmVkIDMxLWJpdCBpbnRlZ2VyLiBbLi4uXSAqKVxudHlwZSBmcmFtZV9oZWFkZXIgPVxuICB7IHBheWxvYWRfbGVuZ3RoIDogaW50XG4gIDsgZmxhZ3MgOiBGbGFncy50XG4gIDsgc3RyZWFtX2lkIDogU3RyZWFtX2lkZW50aWZpZXIudFxuICA7IGZyYW1lX3R5cGUgOiBGcmFtZVR5cGUudFxuICB9XG5cbigqIEZyb20gUkZDNzU0MMKnNC4xOlxuICogICBUaGUgc3RydWN0dXJlIGFuZCBjb250ZW50IG9mIHRoZSBmcmFtZSBwYXlsb2FkIGlzIGRlcGVuZGVudCBlbnRpcmVseSBvblxuICogICB0aGUgZnJhbWUgdHlwZS4gKilcbnR5cGUgZnJhbWVfcGF5bG9hZCA9XG4gICgqIEZyb20gUkZDNzU0MMKnNi4xOlxuICAgKiAgIFRoZSBEQVRBIGZyYW1lIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgKlxuICAgKiAgIFsuLi5dXG4gICAqXG4gICAqICAgRGF0YTogQXBwbGljYXRpb24gZGF0YS4gVGhlIGFtb3VudCBvZiBkYXRhIGlzIHRoZSByZW1haW5kZXIgb2YgdGhlXG4gICAqICAgICAgICAgZnJhbWUgcGF5bG9hZCBhZnRlciBzdWJ0cmFjdGluZyB0aGUgbGVuZ3RoIG9mIHRoZSBvdGhlciBmaWVsZHNcbiAgICogICAgICAgICB0aGF0IGFyZSBwcmVzZW50LiAqKVxuICB8IERhdGEgb2YgQmlnc3RyaW5nYWYudFxuICAoKiBGcm9tIFJGQzc1NDDCpzYuMjpcbiAgICogICBUaGUgSEVBREVSUyBmcmFtZSBwYXlsb2FkIGhhcyB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICpcbiAgICogICAgRTogQSBzaW5nbGUtYml0IGZsYWcgaW5kaWNhdGluZyB0aGF0IHRoZSBzdHJlYW0gZGVwZW5kZW5jeSBpc1xuICAgKiAgICAgICBleGNsdXNpdmUgKHNlZSBTZWN0aW9uIDUuMykuIFsuLi5dXG4gICAqXG4gICAqICAgIFN0cmVhbSBEZXBlbmRlbmN5OiBBIDMxLWJpdCBzdHJlYW0gaWRlbnRpZmllciBmb3IgdGhlIHN0cmVhbSB0aGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHN0cmVhbSBkZXBlbmRzIG9uIChzZWUgU2VjdGlvbiA1LjMpLiBbLi4uXVxuICAgKlxuICAgKiAgICBXZWlnaHQ6IEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXIgcmVwcmVzZW50aW5nIGEgcHJpb3JpdHkgd2VpZ2h0IGZvclxuICAgKiAgICAgICAgICAgIHRoZSBzdHJlYW0gKHNlZSBTZWN0aW9uIDUuMykuIFsuLi5dIFRoaXMgZmllbGQgaXMgb25seVxuICAgKiAgICAgICAgICAgIHByZXNlbnQgaWYgdGhlIFBSSU9SSVRZIGZsYWcgaXMgc2V0LlxuICAgKlxuICAgKiAgICBIZWFkZXIgQmxvY2sgRnJhZ21lbnQ6IEEgaGVhZGVyIGJsb2NrIGZyYWdtZW50IChTZWN0aW9uIDQuMykuICopXG4gIHwgSGVhZGVycyBvZiBQcmlvcml0eS50ICogQmlnc3RyaW5nYWYudFxuICAoKiBGcm9tIFJGQzc1NDDCpzYuMzpcbiAgICogICBUaGUgcGF5bG9hZCBvZiBhIFBSSU9SSVRZIGZyYW1lIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgKlxuICAgKiAgIEU6IEEgc2luZ2xlLWJpdCBmbGFnIGluZGljYXRpbmcgdGhhdCB0aGUgc3RyZWFtIGRlcGVuZGVuY3kgaXNcbiAgICogICAgICBleGNsdXNpdmUgKHNlZSBTZWN0aW9uIDUuMykuXG4gICAqXG4gICAqICAgU3RyZWFtIERlcGVuZGVuY3k6IEEgMzEtYml0IHN0cmVhbSBpZGVudGlmaWVyIGZvciB0aGUgc3RyZWFtIHRoYXQgdGhpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0gZGVwZW5kcyBvbiAoc2VlIFNlY3Rpb24gNS4zKS5cbiAgICpcbiAgICogICBXZWlnaHQ6IEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXIgcmVwcmVzZW50aW5nIGEgcHJpb3JpdHkgd2VpZ2h0IGZvclxuICAgKiAgICAgICAgICAgdGhlIHN0cmVhbSAoc2VlIFNlY3Rpb24gNS4zKS4gWy4uLl0gKilcbiAgfCBQcmlvcml0eSBvZiBQcmlvcml0eS50XG4gICgqIEZyb20gUkZDNzU0MMKnNi40OlxuICAgKiAgIFRoZSBSU1RfU1RSRUFNIGZyYW1lIGNvbnRhaW5zIGEgc2luZ2xlIHVuc2lnbmVkLCAzMi1iaXQgaW50ZWdlclxuICAgKiAgIGlkZW50aWZ5aW5nIHRoZSBlcnJvciBjb2RlIChTZWN0aW9uIDcpLiBbLi4uXSAqKVxuICB8IFJTVFN0cmVhbSBvZiBFcnJvcl9jb2RlLnRcbiAgKCogRnJvbSBSRkM3NTQwwqc2LjU6XG4gICAqICAgVGhlIHBheWxvYWQgb2YgYSBTRVRUSU5HUyBmcmFtZSBjb25zaXN0cyBvZiB6ZXJvIG9yIG1vcmUgcGFyYW1ldGVycyxcbiAgICogICBlYWNoIGNvbnNpc3Rpbmcgb2YgYW4gdW5zaWduZWQgMTYtYml0IHNldHRpbmcgaWRlbnRpZmllciBhbmQgYW5cbiAgICogICB1bnNpZ25lZCAzMi1iaXQgdmFsdWUuICopXG4gIHwgU2V0dGluZ3Mgb2YgU2V0dGluZ3Muc2V0dGluZ3NfbGlzdFxuICAoKiBGcm9tIFJGQzc1NDDCpzYuNjpcbiAgICogICBUaGUgUFVTSF9QUk9NSVNFIGZyYW1lIGluY2x1ZGVzIHRoZSB1bnNpZ25lZCAzMS1iaXQgaWRlbnRpZmllciBvZiB0aGVcbiAgICogICBzdHJlYW0gdGhlIGVuZHBvaW50IHBsYW5zIHRvIGNyZWF0ZSBhbG9uZyB3aXRoIGEgc2V0IG9mIGhlYWRlcnMgdGhhdFxuICAgKiAgIHByb3ZpZGUgYWRkaXRpb25hbCBjb250ZXh0IGZvciB0aGUgc3RyZWFtLiAqKVxuICB8IFB1c2hQcm9taXNlIG9mIFN0cmVhbV9pZGVudGlmaWVyLnQgKiBCaWdzdHJpbmdhZi50XG4gICgqIEZyb20gUkZDNzU0MMKnNi43OlxuICAgKiAgIEluIGFkZGl0aW9uIHRvIHRoZSBmcmFtZSBoZWFkZXIsIFBJTkcgZnJhbWVzIE1VU1QgY29udGFpbiA4IG9jdGV0cyBvZlxuICAgKiAgIG9wYXF1ZSBkYXRhIGluIHRoZSBwYXlsb2FkLiBBIHNlbmRlciBjYW4gaW5jbHVkZSBhbnkgdmFsdWUgaXQgY2hvb3Nlc1xuICAgKiAgIGFuZCB1c2UgdGhvc2Ugb2N0ZXRzIGluIGFueSBmYXNoaW9uLiAqKVxuICB8IFBpbmcgb2YgQmlnc3RyaW5nYWYudFxuICAoKiBGcm9tIFJGQzc1NDDCpzYuODpcbiAgICogICBUaGUgbGFzdCBzdHJlYW0gaWRlbnRpZmllciBpbiB0aGUgR09BV0FZIGZyYW1lIGNvbnRhaW5zIHRoZVxuICAgKiAgIGhpZ2hlc3QtbnVtYmVyZWQgc3RyZWFtIGlkZW50aWZpZXIgZm9yIHdoaWNoIHRoZSBzZW5kZXIgb2YgdGhlIEdPQVdBWVxuICAgKiAgIGZyYW1lIG1pZ2h0IGhhdmUgdGFrZW4gc29tZSBhY3Rpb24gb24gb3IgbWlnaHQgeWV0IHRha2UgYWN0aW9uIG9uLlxuICAgKlxuICAgKiAgIFsuLi5dIFRoZSBHT0FXQVkgZnJhbWUgYWxzbyBjb250YWlucyBhIDMyLWJpdCBlcnJvciBjb2RlIChTZWN0aW9uIDcpXG4gICAqICAgdGhhdCBjb250YWlucyB0aGUgcmVhc29uIGZvciBjbG9zaW5nIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiAgIFsuLi5dIEVuZHBvaW50cyBNQVkgYXBwZW5kIG9wYXF1ZSBkYXRhIHRvIHRoZSBwYXlsb2FkIG9mIGFueSBHT0FXQVlcbiAgICogICBmcmFtZS4gKilcbiAgfCBHb0F3YXkgb2YgU3RyZWFtX2lkZW50aWZpZXIudCAqIEVycm9yX2NvZGUudCAqIEJpZ3N0cmluZ2FmLnRcbiAgKCogRnJvbSBSRkM3NTQwwqc2Ljk6XG4gICAqICAgVGhlIHBheWxvYWQgb2YgYSBXSU5ET1dfVVBEQVRFIGZyYW1lIGlzIG9uZSByZXNlcnZlZCBiaXQgcGx1cyBhblxuICAgKiAgIHVuc2lnbmVkIDMxLWJpdCBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG51bWJlciBvZiBvY3RldHMgdGhhdCB0aGVcbiAgICogICBzZW5kZXIgY2FuIHRyYW5zbWl0IGluIGFkZGl0aW9uIHRvIHRoZSBleGlzdGluZyBmbG93LWNvbnRyb2xcbiAgICogICB3aW5kb3cuICopXG4gIHwgV2luZG93VXBkYXRlIG9mIFNldHRpbmdzLldpbmRvd1NpemUudFxuICAoKiBGcm9tIFJGQzc1NDDCpzYuMTA6XG4gICAqICAgVGhlIENPTlRJTlVBVElPTiBmcmFtZSBwYXlsb2FkIGNvbnRhaW5zIGEgaGVhZGVyIGJsb2NrIGZyYWdtZW50XG4gICAqICAgKFNlY3Rpb24gNC4zKS4gKilcbiAgfCBDb250aW51YXRpb24gb2YgQmlnc3RyaW5nYWYudFxuICB8IFVua25vd24gb2YgaW50ICogQmlnc3RyaW5nYWYudFxuXG4oKiBGcm9tIFJGQzc1NDDCpzQuMTpcbiAqICAgQWxsIGZyYW1lcyBiZWdpbiB3aXRoIGEgZml4ZWQgOS1vY3RldCBoZWFkZXIgZm9sbG93ZWQgYnkgYSB2YXJpYWJsZS1sZW5ndGhcbiAqICAgcGF5bG9hZC4gKilcbnR5cGUgdCA9XG4gIHsgZnJhbWVfaGVhZGVyIDogZnJhbWVfaGVhZGVyXG4gIDsgZnJhbWVfcGF5bG9hZCA6IGZyYW1lX3BheWxvYWRcbiAgfVxuIiwiKCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE3IEluaGFiaXRlZCBUeXBlIExMQy5cbiAqICBDb3B5cmlnaHQgKGMpIDIwMTkgQW50b25pbyBOLiBNb250ZWlyby5cbiAqXG4gKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiAgYXJlIG1ldDpcbiAqXG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAqICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAqICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09OVFJJQlVUT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NcbiAqICBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAqICBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbiAqICBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gKiAgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAqICBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTilcbiAqICBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXG4gKiAgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOXG4gKiAgQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbm1vZHVsZSBIdHRwYWYgPSBEcmVhbV9odHRwYWZfLkh0dHBhZlxubW9kdWxlIEhwYWNrID0gRHJlYW1faHBhY2suSHBhY2tcblxudHlwZSBuYW1lID0gc3RyaW5nXG50eXBlIHZhbHVlID0gc3RyaW5nXG5cbnR5cGUgaGVhZGVyID0gSHBhY2suaGVhZGVyID1cbiAgeyBuYW1lIDogbmFtZVxuICA7IHZhbHVlIDogdmFsdWVcbiAgOyBzZW5zaXRpdmUgOiBib29sXG4gIH1cblxudHlwZSB0ID0gaGVhZGVyIGxpc3RcblxubGV0IGVtcHR5IDogdCA9IFtdXG5cbmxldCBvZl9yZXZfbGlzdCBocyA9XG4gIExpc3QubWFwIChmdW4gKG5hbWUsIHZhbHVlKSAtPiB7IG5hbWU7IHZhbHVlOyBzZW5zaXRpdmUgPSBmYWxzZSB9KSBoc1xuXG5sZXQgb2ZfbGlzdCB0ID0gb2ZfcmV2X2xpc3QgKExpc3QucmV2IHQpXG5sZXQgdG9fcmV2X2xpc3QgdCA9IExpc3QubWFwIChmdW4geyBuYW1lOyB2YWx1ZTsgXyB9IC0+IG5hbWUsIHZhbHVlKSB0XG5sZXQgdG9fbGlzdCB0ID0gTGlzdC5yZXYgKHRvX3Jldl9saXN0IHQpXG5sZXQgdG9faHBhY2tfbGlzdCB0ID0gTGlzdC5yZXYgdFxuXG5leGNlcHRpb24gTG9jYWxcblxubW9kdWxlIENJID0gc3RydWN0XG4gIGxldCBjaGFyX2lzX3VwcGVyIGMgPSBjID49IDB4NDEgJiYgYyA8PSAweDVhXG4gIGxldCBsb3dlciBjID0gaWYgY2hhcl9pc191cHBlciBjIHRoZW4gYyArIDMyIGVsc2UgY1xuXG4gIGxldCBlcXVhbCB4IHkgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHggaW5cbiAgICBsZW4gPSBTdHJpbmcubGVuZ3RoIHlcbiAgICAmJlxuICAgIG1hdGNoXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBsZXQgYzEgPSBDaGFyLmNvZGUgKFN0cmluZy51bnNhZmVfZ2V0IHggaSkgaW5cbiAgICAgICAgbGV0IGMyID0gQ2hhci5jb2RlIChTdHJpbmcudW5zYWZlX2dldCB5IGkpIGluXG4gICAgICAgIGlmIGMxID0gYzIgdGhlbiAoKSBlbHNlIGlmIGxvd2VyIGMxIDw+IGxvd2VyIGMyIHRoZW4gcmFpc2UgTG9jYWxcbiAgICAgIGRvbmVcbiAgICB3aXRoXG4gICAgfCAoKSAtPiB0cnVlXG4gICAgfCBleGNlcHRpb24gTG9jYWwgLT4gZmFsc2VcblxuICBsZXQgaXNfbG93ZXJjYXNlIHggPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHggaW5cbiAgICBtYXRjaFxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgbGV0IGMxID0gQ2hhci5jb2RlIChTdHJpbmcudW5zYWZlX2dldCB4IGkpIGluXG4gICAgICAgIGlmIGNoYXJfaXNfdXBwZXIgYzEgdGhlbiByYWlzZSBMb2NhbCBlbHNlICgpXG4gICAgICBkb25lXG4gICAgd2l0aFxuICAgIHwgKCkgLT4gdHJ1ZVxuICAgIHwgZXhjZXB0aW9uIExvY2FsIC0+IGZhbHNlXG5lbmRcblxubGV0IHJlYyBtZW0gdCBuYW1lID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgeyBuYW1lID0gbmFtZSc7IF8gfSA6OiB0JyAtPiBDSS5lcXVhbCBuYW1lIG5hbWUnIHx8IG1lbSB0JyBuYW1lXG4gIHwgXyAtPiBmYWxzZVxuXG4oKiBUT0RPOiBkbyB3ZSBuZWVkIHRvIGtlZXAgYSBsaXN0IG9mIG5ldmVyIGluZGV4ZWQgZmllbGRzPyAqKVxubGV0IGFkZCB0ID8oc2Vuc2l0aXZlID0gZmFsc2UpIG5hbWUgdmFsdWUgPSB7IG5hbWU7IHZhbHVlOyBzZW5zaXRpdmUgfSA6OiB0XG5sZXQgYWRkX2xpc3QgdCBscyA9IG9mX3Jldl9saXN0IGxzIEAgdCAoKiBYWFgoc2VsaW9wb3UpOiBkbyBiZXR0ZXIgaGVyZSAqKVxuXG5sZXQgYWRkX211bHRpID1cbiAgbGV0IHJlYyBsb29wX291dGVyIHQgbHNzID1cbiAgICBtYXRjaCBsc3Mgd2l0aCBbXSAtPiB0IHwgKG4sIHZzKSA6OiBsc3MnIC0+IGxvb3BfaW5uZXIgdCBuIHZzIGxzcydcbiAgYW5kIGxvb3BfaW5uZXIgdCBuIHZzIGxzcyA9XG4gICAgbWF0Y2ggdnMgd2l0aFxuICAgIHwgW10gLT4gbG9vcF9vdXRlciB0IGxzc1xuICAgIHwgdiA6OiB2cycgLT5cbiAgICAgIGxvb3BfaW5uZXIgKHsgbmFtZSA9IG47IHZhbHVlID0gdjsgc2Vuc2l0aXZlID0gZmFsc2UgfSA6OiB0KSBuIHZzJyBsc3NcbiAgaW5cbiAgbG9vcF9vdXRlclxuXG5sZXQgYWRkX3VubGVzc19leGlzdHMgdCA/KHNlbnNpdGl2ZSA9IGZhbHNlKSBuYW1lIHZhbHVlID1cbiAgaWYgbWVtIHQgbmFtZSB0aGVuIHQgZWxzZSB7IG5hbWU7IHZhbHVlOyBzZW5zaXRpdmUgfSA6OiB0XG5cbmxldCByZXBsYWNlIHQgPyhzZW5zaXRpdmUgPSBmYWxzZSkgbmFtZSB2YWx1ZSA9XG4gIGxldCByZWMgbG9vcCB0IG4gbnYgc2VlbiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBpZiBub3Qgc2VlbiB0aGVuIHJhaXNlIExvY2FsIGVsc2UgW11cbiAgICB8ICh7IG5hbWUgPSBuJzsgXyB9IGFzIG52JykgOjogdCAtPlxuICAgICAgaWYgQ0kuZXF1YWwgbiBuJ1xuICAgICAgdGhlbiBpZiBzZWVuIHRoZW4gbG9vcCB0IG4gbnYgdHJ1ZSBlbHNlIG52IDo6IGxvb3AgdCBuIG52IHRydWVcbiAgICAgIGVsc2UgbnYnIDo6IGxvb3AgdCBuIG52IHNlZW5cbiAgaW5cbiAgdHJ5IGxvb3AgdCBuYW1lIHsgbmFtZTsgdmFsdWU7IHNlbnNpdGl2ZSB9IGZhbHNlIHdpdGggTG9jYWwgLT4gdFxuXG5sZXQgcmVtb3ZlIHQgbmFtZSA9XG4gIGxldCByZWMgbG9vcCBzIG4gc2VlbiA9XG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBbXSAtPiBpZiBub3Qgc2VlbiB0aGVuIHJhaXNlIExvY2FsIGVsc2UgW11cbiAgICB8ICh7IG5hbWUgPSBuJzsgXyB9IGFzIG52JykgOjogcycgLT5cbiAgICAgIGlmIENJLmVxdWFsIG4gbicgdGhlbiBsb29wIHMnIG4gdHJ1ZSBlbHNlIG52JyA6OiBsb29wIHMnIG4gc2VlblxuICBpblxuICB0cnkgbG9vcCB0IG5hbWUgZmFsc2Ugd2l0aCBMb2NhbCAtPiB0XG5cbmxldCBnZXQgdCBuYW1lID1cbiAgbGV0IHJlYyBsb29wIHQgbiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB7IG5hbWUgPSBuJzsgdmFsdWU7IF8gfSA6OiB0JyAtPlxuICAgICAgaWYgQ0kuZXF1YWwgbiBuJyB0aGVuIFNvbWUgdmFsdWUgZWxzZSBsb29wIHQnIG5cbiAgaW5cbiAgbG9vcCB0IG5hbWVcblxubGV0IGdldF9leG4gdCBuYW1lID1cbiAgbGV0IHJlYyBsb29wIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgfCB7IG5hbWUgPSBuOyB2YWx1ZTsgXyB9IDo6IHQnIC0+IGlmIENJLmVxdWFsIG5hbWUgbiB0aGVuIHZhbHVlIGVsc2UgbG9vcCB0J1xuICBpblxuICBsb29wIHRcblxubGV0IGdldF9wc2V1ZG8gdCBuYW1lID0gZ2V0IHQgKFwiOlwiIF4gbmFtZSlcbmxldCBnZXRfcHNldWRvX2V4biB0IG5hbWUgPSBnZXRfZXhuIHQgKFwiOlwiIF4gbmFtZSlcblxubGV0IGdldF9tdWx0aSB0IG5hbWUgPVxuICBsZXQgcmVjIGxvb3AgdCBhY2MgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gYWNjXG4gICAgfCB7IG5hbWUgPSBuOyB2YWx1ZTsgXyB9IDo6IHQnIC0+XG4gICAgICBpZiBDSS5lcXVhbCBuYW1lIG4gdGhlbiBsb29wIHQnICh2YWx1ZSA6OiBhY2MpIGVsc2UgbG9vcCB0JyBhY2NcbiAgaW5cbiAgbG9vcCB0IFtdXG5cbmxldCBnZXRfbXVsdGlfcHNldWRvIHQgbmFtZSA9IGdldF9tdWx0aSB0IChcIjpcIiBeIG5hbWUpXG5cbm1vZHVsZSBQc2V1ZG8gPSBzdHJ1Y3RcbiAgbGV0IHJlc2VydmVkX3JlcXVlc3QgPSBbIFwiOm1ldGhvZFwiOyBcIjpzY2hlbWVcIjsgXCI6YXV0aG9yaXR5XCI7IFwiOnBhdGhcIiBdXG4gIGxldCByZXNlcnZlZF9yZXNwb25zZSA9IFsgXCI6c3RhdHVzXCIgXVxuXG4gICgqIDB4M0EgaXMgdGhlIGNoYXIgY29kZSBmb3IgYDpgICopXG4gIGxldCBpc19wc2V1ZG8gbmFtZSA9IENoYXIuY29kZSAoU3RyaW5nLnVuc2FmZV9nZXQgbmFtZSAwKSA9IDB4M0FcbmVuZFxuXG5sZXQgaXRlciB+ZiB0ID0gTGlzdC5pdGVyIChmdW4geyBuYW1lOyB2YWx1ZTsgXyB9IC0+IGYgbmFtZSB2YWx1ZSkgdFxuXG5sZXQgZm9sZCB+ZiB+aW5pdCB0ID1cbiAgTGlzdC5mb2xkX2xlZnQgKGZ1biBhY2MgeyBuYW1lOyB2YWx1ZTsgXyB9IC0+IGYgbmFtZSB2YWx1ZSBhY2MpIGluaXQgdFxuXG5sZXQgZXhpc3RzIH5mIHQgPSBMaXN0LmV4aXN0cyAoZnVuIHsgbmFtZTsgdmFsdWU7IF8gfSAtPiBmIG5hbWUgdmFsdWUpIHRcblxubGV0IHZhbGlkX2hlYWRlcnMgPyhpc19yZXF1ZXN0ID0gdHJ1ZSkgdCA9XG4gIG1hdGNoIGdldCB0IFwiY29ubmVjdGlvblwiLCBnZXQgdCBcIlRFXCIgd2l0aFxuICB8IFNvbWUgXywgXyAtPlxuICAgICgqIEZyb20gUkZDNzU0MMKnOC4xLjIuMjpcbiAgICAgKiAgIEhUVFAvMiBkb2VzIG5vdCB1c2UgdGhlIENvbm5lY3Rpb24gaGVhZGVyIGZpZWxkIHRvIGluZGljYXRlXG4gICAgICogICBjb25uZWN0aW9uLXNwZWNpZmljIGhlYWRlciBmaWVsZHM7IGluIHRoaXMgcHJvdG9jb2wsXG4gICAgICogICBjb25uZWN0aW9uLXNwZWNpZmljIG1ldGFkYXRhIGlzIGNvbnZleWVkIGJ5IG90aGVyIG1lYW5zLiBBbiBlbmRwb2ludFxuICAgICAqICAgTVVTVCBOT1QgZ2VuZXJhdGUgYW4gSFRUUC8yIG1lc3NhZ2UgY29udGFpbmluZyBjb25uZWN0aW9uLXNwZWNpZmljXG4gICAgICogICBoZWFkZXIgZmllbGRzOyBhbnkgbWVzc2FnZSBjb250YWluaW5nIGNvbm5lY3Rpb24tc3BlY2lmaWMgaGVhZGVyXG4gICAgICogICBmaWVsZHMgTVVTVCBiZSB0cmVhdGVkIGFzIG1hbGZvcm1lZCAoU2VjdGlvbiA4LjEuMi42KS4gKilcbiAgICBmYWxzZVxuICB8IF8sIFNvbWUgdmFsdWUgd2hlbiB2YWx1ZSA8PiBcInRyYWlsZXJzXCIgLT5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzguMS4yLjI6XG4gICAgICogICBUaGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyB0aGUgVEUgaGVhZGVyIGZpZWxkLCB3aGljaCBNQVkgYmVcbiAgICAgKiAgIHByZXNlbnQgaW4gYW4gSFRUUC8yIHJlcXVlc3Q7IHdoZW4gaXQgaXMsIGl0IE1VU1QgTk9UIGNvbnRhaW4gYW55XG4gICAgICogICB2YWx1ZSBvdGhlciB0aGFuIFwidHJhaWxlcnNcIi4gKilcbiAgICBmYWxzZVxuICB8IF8gLT5cbiAgICBsZXQgcHNldWRvX2VuZGVkID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IGludmFsaWQgPVxuICAgICAgZXhpc3RzXG4gICAgICAgIH5mOihmdW4gbmFtZSBfIC0+XG4gICAgICAgICAgbGV0IGlzX3BzZXVkbyA9IFBzZXVkby5pc19wc2V1ZG8gbmFtZSBpblxuICAgICAgICAgIGxldCBwc2V1ZG9fZGlkX2VuZCA9ICFwc2V1ZG9fZW5kZWQgaW5cbiAgICAgICAgICBpZiAobm90IGlzX3BzZXVkbykgJiYgbm90IHBzZXVkb19kaWRfZW5kIHRoZW4gcHNldWRvX2VuZGVkIDo9IHRydWU7XG4gICAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc4LjEuMjpcbiAgICAgICAgICAgKiAgIFsuLi5dIGhlYWRlciBmaWVsZCBuYW1lcyBNVVNUIGJlIGNvbnZlcnRlZCB0byBsb3dlcmNhc2VcbiAgICAgICAgICAgKiAgIHByaW9yIHRvIHRoZWlyIGVuY29kaW5nIGluIEhUVFAvMi4gQSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gICAgICAgICAgICogICBjb250YWluaW5nIHVwcGVyY2FzZSBoZWFkZXIgZmllbGQgbmFtZXMgTVVTVCBiZSB0cmVhdGVkIGFzXG4gICAgICAgICAgICogICBtYWxmb3JtZWQgKFNlY3Rpb24gOC4xLjIuNikuICopXG4gICAgICAgICAgKG5vdCBDSS4oaXNfbG93ZXJjYXNlIG5hbWUpKVxuICAgICAgICAgICgqIEZyb20gUkZDNzU0MMKnOC4xLjIuMTpcbiAgICAgICAgICAgKiAgIFBzZXVkby1oZWFkZXIgZmllbGRzIGFyZSBvbmx5IHZhbGlkIGluIHRoZSBjb250ZXh0IGluXG4gICAgICAgICAgICogICB3aGljaCB0aGV5IGFyZSBkZWZpbmVkLiBbLi4uXSBwc2V1ZG8taGVhZGVyIGZpZWxkcyBkZWZpbmVkXG4gICAgICAgICAgICogICBmb3IgcmVzcG9uc2VzIE1VU1QgTk9UIGFwcGVhciBpbiByZXF1ZXN0cy4gWy4uLl0gRW5kcG9pbnRzXG4gICAgICAgICAgICogICBNVVNUIHRyZWF0IGEgcmVxdWVzdCBvciByZXNwb25zZSB0aGF0IGNvbnRhaW5zIHVuZGVmaW5lZFxuICAgICAgICAgICAqICAgb3IgaW52YWxpZCBwc2V1ZG8taGVhZGVyIGZpZWxkcyBhcyBtYWxmb3JtZWQgKFNlY3Rpb25cbiAgICAgICAgICAgKiAgIDguMS4yLjYpLiAqKVxuICAgICAgICAgIHx8IChpc19wc2V1ZG9cbiAgICAgICAgICAgICAmJiBub3RcbiAgICAgICAgICAgICAgICAgIChMaXN0Lm1lbVxuICAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgKGlmIGlzX3JlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICB0aGVuIFBzZXVkby5yZXNlcnZlZF9yZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBQc2V1ZG8ucmVzZXJ2ZWRfcmVzcG9uc2UpKSlcbiAgICAgICAgICB8fCAoKiBGcm9tIFJGQzc1NDDCpzguMS4yLjE6XG4gICAgICAgICAgICAgICogICBBbGwgcHNldWRvLWhlYWRlciBmaWVsZHMgTVVTVCBhcHBlYXIgaW4gdGhlIGhlYWRlciBibG9ja1xuICAgICAgICAgICAgICAqICAgYmVmb3JlIHJlZ3VsYXIgaGVhZGVyIGZpZWxkcy4gQW55IHJlcXVlc3Qgb3IgcmVzcG9uc2UgdGhhdFxuICAgICAgICAgICAgICAqICAgY29udGFpbnMgYSBwc2V1ZG8taGVhZGVyIGZpZWxkIHRoYXQgYXBwZWFycyBpbiBhIGhlYWRlciBibG9ja1xuICAgICAgICAgICAgICAqICAgYWZ0ZXIgYSByZWd1bGFyIGhlYWRlciBmaWVsZCBNVVNUIGJlIHRyZWF0ZWQgYXMgbWFsZm9ybWVkXG4gICAgICAgICAgICAgICogICAoU2VjdGlvbiA4LjEuMi42KS4gKilcbiAgICAgICAgICAoaXNfcHNldWRvICYmIHBzZXVkb19kaWRfZW5kKSlcbiAgICAgICAgKHRvX2hwYWNrX2xpc3QgdClcbiAgICBpblxuICAgIG5vdCBpbnZhbGlkXG5cbmxldCB2YWxpZF9yZXF1ZXN0X2hlYWRlcnMgdCA9IHZhbGlkX2hlYWRlcnMgdFxubGV0IHZhbGlkX3Jlc3BvbnNlX2hlYWRlcnMgdCA9IHZhbGlkX2hlYWRlcnMgfmlzX3JlcXVlc3Q6ZmFsc2UgdFxuXG5sZXQgbWV0aG9kX3BhdGhfYW5kX3NjaGVtZV9vcl9tYWxmb3JtZWQgdCA9XG4gIG1hdGNoXG4gICAgKCBnZXRfbXVsdGlfcHNldWRvIHQgXCJtZXRob2RcIlxuICAgICwgZ2V0X211bHRpX3BzZXVkbyB0IFwic2NoZW1lXCJcbiAgICAsIGdldF9tdWx0aV9wc2V1ZG8gdCBcInBhdGhcIiApXG4gIHdpdGhcbiAgfCBfLCBbIChcImh0dHBcIiB8IFwiaHR0cHNcIikgXSwgWyBwYXRoIF0gd2hlbiBTdHJpbmcubGVuZ3RoIHBhdGggPSAwIC0+XG4gICAgKCogRnJvbSBSRkM3NTQwwqc4LjEuMi42OlxuICAgICAqICAgVGhpcyBwc2V1ZG8taGVhZGVyIGZpZWxkIE1VU1QgTk9UIGJlIGVtcHR5IGZvciBodHRwIG9yIGh0dHBzIFVSSXM7XG4gICAgICogICBodHRwIG9yIGh0dHBzIFVSSXMgdGhhdCBkbyBub3QgY29udGFpbiBhIHBhdGggY29tcG9uZW50IE1VU1QgaW5jbHVkZSBhXG4gICAgICogICB2YWx1ZSBvZiAnLycuICopXG4gICAgYE1hbGZvcm1lZFxuICAoKiBGcm9tIFJGQzc1NDDCpzguMS4yLjM6XG4gICAqICAgQWxsIEhUVFAvMiByZXF1ZXN0cyBNVVNUIGluY2x1ZGUgZXhhY3RseSBvbmUgdmFsaWQgdmFsdWUgZm9yIHRoZVxuICAgKiAgIDptZXRob2QsIDpzY2hlbWUsIGFuZCA6cGF0aCBwc2V1ZG8taGVhZGVyIGZpZWxkcywgdW5sZXNzIGl0IGlzIGFcbiAgICogICBDT05ORUNUIHJlcXVlc3QgKFNlY3Rpb24gOC4zKS4gKilcbiAgfCBbIChcIkNPTk5FQ1RcIiBhcyBtZXRoKSBdLCBbXSwgW10gLT5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzguMzpcbiAgICAgKiAgIFRoZSBIVFRQIGhlYWRlciBmaWVsZCBtYXBwaW5nIHdvcmtzIGFzIGRlZmluZWQgaW4gU2VjdGlvbiA4LjEuMi4zXG4gICAgICogICAoXCJSZXF1ZXN0IFBzZXVkby1IZWFkZXIgRmllbGRzXCIpLCB3aXRoIGEgZmV3IGRpZmZlcmVuY2VzLlxuICAgICAqICAgU3BlY2lmaWNhbGx5OlxuICAgICAqXG4gICAgICogICAgIC0gVGhlIDptZXRob2QgcHNldWRvLWhlYWRlciBmaWVsZCBpcyBzZXQgdG8gQ09OTkVDVC5cbiAgICAgKiAgICAgLSBUaGUgOnNjaGVtZSBhbmQgOnBhdGggcHNldWRvLWhlYWRlciBmaWVsZHMgTVVTVCBiZSBvbWl0dGVkLlxuICAgICAqICAgICAtIFRoZSA6YXV0aG9yaXR5IHBzZXVkby1oZWFkZXIgZmllbGQgY29udGFpbnMgdGhlIGhvc3QgYW5kIHBvcnQgdG9cbiAgICAgKiAgICAgICBjb25uZWN0IHRvIChlcXVpdmFsZW50IHRvIHRoZSBhdXRob3JpdHktZm9ybSBvZiB0aGUgcmVxdWVzdC10YXJnZXRcbiAgICAgKiAgICAgICBvZiBDT05ORUNUIHJlcXVlc3RzIChzZWUgW1JGQzcyMzBdLCBTZWN0aW9uIDUuMykpLlxuICAgICAqXG4gICAgICogICBBIENPTk5FQ1QgcmVxdWVzdCB0aGF0IGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlc2UgcmVzdHJpY3Rpb25zIGlzXG4gICAgICogICBtYWxmb3JtZWQgKFNlY3Rpb24gOC4xLjIuNikuICopXG4gICAgaWYgbWVtIHQgXCI6YXV0aG9yaXR5XCIgdGhlbiBgVmFsaWQgKG1ldGgsIFwiXCIsIFwiXCIpIGVsc2UgYE1hbGZvcm1lZFxuICB8IFsgXCJDT05ORUNUXCIgXSwgXywgXyAtPiBgTWFsZm9ybWVkXG4gIHwgWyBtZXRoIF0sIFsgc2NoZW1lIF0sIFsgcGF0aCBdIC0+XG4gICAgaWYgdmFsaWRfcmVxdWVzdF9oZWFkZXJzIHQgdGhlbiBgVmFsaWQgKG1ldGgsIHBhdGgsIHNjaGVtZSkgZWxzZSBgTWFsZm9ybWVkXG4gIHwgXyAtPiBgTWFsZm9ybWVkXG5cbmxldCB0cmFpbGVyc192YWxpZCB0ID1cbiAgbGV0IGludmFsaWQgPVxuICAgIGV4aXN0c1xuICAgICAgfmY6KGZ1biBuYW1lIF8gLT5cbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc4LjEuMjpcbiAgICAgICAgICogICBbLi4uXSBoZWFkZXIgZmllbGQgbmFtZXMgTVVTVCBiZSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIHByaW9yIHRvXG4gICAgICAgICAqICAgdGhlaXIgZW5jb2RpbmcgaW4gSFRUUC8yLiBBIHJlcXVlc3Qgb3IgcmVzcG9uc2UgY29udGFpbmluZ1xuICAgICAgICAgKiAgIHVwcGVyY2FzZSBoZWFkZXIgZmllbGQgbmFtZXMgTVVTVCBiZSB0cmVhdGVkIGFzIG1hbGZvcm1lZFxuICAgICAgICAgKiAgIChTZWN0aW9uIDguMS4yLjYpLiAqKVxuICAgICAgICAobm90IChDSS5pc19sb3dlcmNhc2UgbmFtZSkpXG4gICAgICAgIHx8ICgqIEZyb20gUkZDNzU0MMKnOC4xLjIuMTpcbiAgICAgICAgICAgICogICBQc2V1ZG8taGVhZGVyIGZpZWxkcyBNVVNUIE5PVCBhcHBlYXIgaW4gdHJhaWxlcnMuIEVuZHBvaW50c1xuICAgICAgICAgICAgKiAgIE1VU1QgdHJlYXQgYSByZXF1ZXN0IG9yIHJlc3BvbnNlIHRoYXQgY29udGFpbnMgdW5kZWZpbmVkIG9yXG4gICAgICAgICAgICAqICAgaW52YWxpZCBwc2V1ZG8taGVhZGVyIGZpZWxkcyBhcyBtYWxmb3JtZWQgKFNlY3Rpb24gOC4xLjIuNikuICopXG4gICAgICAgIFBzZXVkby5pc19wc2V1ZG8gbmFtZSlcbiAgICAgIHRcbiAgaW5cbiAgbm90IGludmFsaWRcblxubGV0IGlzX3ZhbGlkX2gyY19jb25uZWN0aW9uIGNvbm5lY3Rpb24gPVxuICBsZXQgdmFsdWVzID0gU3RyaW5nLnNwbGl0X29uX2NoYXIgJywnIGNvbm5lY3Rpb24gaW5cbiAgbGV0IHZhbHVlcyA9IExpc3QubWFwIFN0cmluZy50cmltIHZhbHVlcyBpblxuICAoKiBGcm9tIFJGQzc1NDDCpzMuMi4xOlxuICAgKiAgIFsuLi5dIFNpbmNlIHRoZSB1cGdyYWRlIGlzIG9ubHkgaW50ZW5kZWQgdG8gYXBwbHkgdG8gdGhlIGltbWVkaWF0ZVxuICAgKiAgIGNvbm5lY3Rpb24sIGEgY2xpZW50IHNlbmRpbmcgdGhlIEhUVFAyLVNldHRpbmdzIGhlYWRlciBmaWVsZCBNVVNUIGFsc29cbiAgICogICBzZW5kIEhUVFAyLVNldHRpbmdzIGFzIGEgY29ubmVjdGlvbiBvcHRpb24gaW4gdGhlIENvbm5lY3Rpb24gaGVhZGVyXG4gICAqICAgZmllbGQgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGZvcndhcmRlZCAoc2VlIFNlY3Rpb24gNi4xIG9mIFtSRkM3MjMwXSkuXG4gICAqKVxuICBtYXRjaFxuICAgICggTGlzdC5maW5kX29wdCAoZnVuIHggLT4gQ0kuZXF1YWwgeCBcInVwZ3JhZGVcIikgdmFsdWVzXG4gICAgLCBMaXN0LmZpbmRfb3B0IChmdW4geCAtPiBDSS5lcXVhbCB4IFwiaHR0cDItc2V0dGluZ3NcIikgdmFsdWVzIClcbiAgd2l0aFxuICB8IFNvbWUgXywgU29tZSBfIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBvZl9odHRwMSB7IEh0dHBhZi5SZXF1ZXN0LmhlYWRlcnM7IG1ldGg7IHRhcmdldDsgXyB9ID1cbiAgbGV0IG1vZHVsZSBIZWFkZXJzID0gSHR0cGFmLkhlYWRlcnMgaW5cbiAgbWF0Y2ggSGVhZGVycy5nZXQgaGVhZGVycyBcImhvc3RcIiB3aXRoXG4gIHwgU29tZSBob3N0IC0+XG4gICAgKCogRnJvbSBSRkM3NTQwwqc4LjEuMi4zOlxuICAgICAqICAgQ2xpZW50cyB0aGF0IGdlbmVyYXRlIEhUVFAvMiByZXF1ZXN0cyBkaXJlY3RseSBTSE9VTEQgdXNlIHRoZVxuICAgICAqICAgOmF1dGhvcml0eSBwc2V1ZG8taGVhZGVyIGZpZWxkIGluc3RlYWQgb2YgdGhlIEhvc3QgaGVhZGVyIGZpZWxkLiAqKVxuICAgIGxldCBoZWFkZXJzID1cbiAgICAgIEhlYWRlcnMuZm9sZFxuICAgICAgICB+ZjooZnVuIG5hbWUgdmFsdWUgYWNjIC0+XG4gICAgICAgICAgaWYgQ0kuZXF1YWwgbmFtZSBcImhvc3RcIiB8fCBDSS5lcXVhbCBuYW1lIFwiY29ubmVjdGlvblwiXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc4LjEuMi4yOlxuICAgICAgICAgICAgICogICBIVFRQLzIgZG9lcyBub3QgdXNlIHRoZSBDb25uZWN0aW9uIGhlYWRlciBmaWVsZCB0byBpbmRpY2F0ZVxuICAgICAgICAgICAgICogICBjb25uZWN0aW9uLXNwZWNpZmljIGhlYWRlciBmaWVsZHM7IGluIHRoaXMgcHJvdG9jb2wsXG4gICAgICAgICAgICAgKiAgIGNvbm5lY3Rpb24tc3BlY2lmaWMgbWV0YWRhdGEgaXMgY29udmV5ZWQgYnkgb3RoZXIgbWVhbnMuIEFuXG4gICAgICAgICAgICAgKiAgIGVuZHBvaW50IE1VU1QgTk9UIGdlbmVyYXRlIGFuIEhUVFAvMiBtZXNzYWdlIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAqICAgY29ubmVjdGlvbi1zcGVjaWZpYyBoZWFkZXIgZmllbGRzOyBhbnkgbWVzc2FnZSBjb250YWluaW5nXG4gICAgICAgICAgICAgKiAgIGNvbm5lY3Rpb24tc3BlY2lmaWMgaGVhZGVyIGZpZWxkcyBNVVNUIGJlIHRyZWF0ZWQgYXMgbWFsZm9ybWVkXG4gICAgICAgICAgICAgKiAgIChTZWN0aW9uIDguMS4yLjYpLiAqKVxuICAgICAgICAgICAgYWNjXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IG5hbWUgPVxuICAgICAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzguMS4yOlxuICAgICAgICAgICAgICAgKiAgIGhlYWRlciBmaWVsZCBuYW1lcyBNVVNUIGJlIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgcHJpb3IgdG9cbiAgICAgICAgICAgICAgICogICB0aGVpciBlbmNvZGluZyBpbiBIVFRQLzIuICopXG4gICAgICAgICAgICAgIGlmIENJLmlzX2xvd2VyY2FzZSBuYW1lIHRoZW4gbmFtZSBlbHNlIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgbmFtZVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIChuYW1lLCB2YWx1ZSkgOjogYWNjKVxuICAgICAgICB+aW5pdDpcbiAgICAgICAgICBbIFwiOmF1dGhvcml0eVwiLCBob3N0XG4gICAgICAgICAgOyBcIjptZXRob2RcIiwgSHR0cGFmLk1ldGhvZC50b19zdHJpbmcgbWV0aFxuICAgICAgICAgIDsgXCI6cGF0aFwiLCB0YXJnZXRcbiAgICAgICAgICA7IFwiOnNjaGVtZVwiLCBcImh0dHBzXCJcbiAgICAgICAgICBdXG4gICAgICAgIGhlYWRlcnNcbiAgICBpblxuICAgIE9rIChvZl9yZXZfbGlzdCBoZWFkZXJzKVxuICB8IE5vbmUgLT4gRXJyb3IgXCJNaXNzaW5nIGBIb3N0YCBoZWFkZXIgZmllbGRcIlxuXG5sZXQgdG9fc3RyaW5nIHQgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTI4IGluXG4gIExpc3QuaXRlclxuICAgIChmdW4gKG5hbWUsIHZhbHVlKSAtPlxuICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGIgbmFtZTtcbiAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBiIFwiOiBcIjtcbiAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBiIHZhbHVlO1xuICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJcXHJcXG5cIilcbiAgICAodG9fbGlzdCB0KTtcbiAgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIlxcclxcblwiO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG5sZXQgcHBfaHVtIGZtdCB0ID1cbiAgbGV0IHBwX2VsZW0gZm10IChuYW1lLCB2YWx1ZSkgPSBGb3JtYXQuZnByaW50ZiBmbXQgXCJAWyglUyAlUylAXVwiIG5hbWUgdmFsdWUgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiQFsoXCI7XG4gIEZvcm1hdC5wcF9wcmludF9saXN0IHBwX2VsZW0gZm10ICh0b19saXN0IHQpO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIpQF1cIlxuIiwiKCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE3IEluaGFiaXRlZCBUeXBlIExMQy5cbiAqICBDb3B5cmlnaHQgKGMpIDIwMTkgQW50b25pbyBOLiBNb250ZWlyby5cbiAqXG4gKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiAgYXJlIG1ldDpcbiAqXG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAqICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAqICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09OVFJJQlVUT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NcbiAqICBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAqICBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbiAqICBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gKiAgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAqICBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTilcbiAqICBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXG4gKiAgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOXG4gKiAgQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbigqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGZ1bmN0aW9uYWxpdHkgdGhhdCBhcHBsaWVzIHRvIGJvdGggcmVxdWVzdHMgYW5kXG4gKiByZXNwb25zZXMsIHdoaWNoIGFyZSBjb2xsZWN0aXZlbHkgcmVmZXJyZWQgdG8gaW4gdGhlIEhUVFAgMS4xIHNwZWNpZmljYXRpb25zXG4gKiBhcyAnbWVzc2FnZXMnLiAqKVxuXG5sZXQgY29udGVudF9sZW5ndGhfb2Zfc3RyaW5nIHMgPVxuICBtYXRjaCBJbnQ2NC5vZl9zdHJpbmcgcyB3aXRoXG4gIHwgbGVuIHdoZW4gSW50NjQuY29tcGFyZSBsZW4gMEwgPj0gMCAtPiBgRml4ZWQgbGVuXG4gIHwgXyB8IChleGNlcHRpb24gXykgLT4gYEVycm9yIGBCYWRfcmVxdWVzdFxuXG5sZXQgYm9keV9sZW5ndGggaGVhZGVycyA9XG4gIG1hdGNoIEhlYWRlcnMuZ2V0X211bHRpIGhlYWRlcnMgXCJjb250ZW50LWxlbmd0aFwiIHdpdGhcbiAgfCBbXSAtPiBgVW5rbm93blxuICB8IFsgeCBdIC0+IGNvbnRlbnRfbGVuZ3RoX29mX3N0cmluZyB4XG4gIHwgaGQgOjogdGwgLT5cbiAgICAoKiBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29udGVudC1sZW5ndGggaGVhZGVycyB3ZSByZXF1aXJlIHRoZW0gYWxsIHRvIGJlXG4gICAgICogZXhhY3RseSBlcXVhbC4gKilcbiAgICBpZiBMaXN0LmZvcl9hbGwgKFN0cmluZy5lcXVhbCBoZCkgdGxcbiAgICB0aGVuIGNvbnRlbnRfbGVuZ3RoX29mX3N0cmluZyBoZFxuICAgIGVsc2UgYFVua25vd25cbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAyMCBJbmhhYml0ZWQgVHlwZSBMTEMuXG4gKiAgQ29weXJpZ2h0IChjKSAyMDIwIEFudG9uaW8gTi4gTW9udGVpcm8uXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogIGFyZSBtZXQ6XG4gKlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gKiAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gKiAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gKiAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gKiAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gKiAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICogIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICogIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG50eXBlIHQgPSB1bml0IC0+IHVuaXRcblxubGV0IG5vbmUgPSBTeXMub3BhcXVlX2lkZW50aXR5IChmdW4gKCkgLT4gKCkpXG5cbmxldCBzb21lIGYgPVxuICBpZiBmID09IG5vbmVcbiAgdGhlblxuICAgIGZhaWx3aXRoXG4gICAgICBcIk9wdGlvbmFsX3RodW5rOiB0aGlzIGZ1bmN0aW9uIGlzIG5vdCByZXByZXNlbnRhYmxlIGFzIGEgc29tZSB2YWx1ZVwiO1xuICBmXG5cbmxldCBpc19ub25lIHQgPSB0ID09IG5vbmVcbmxldCBpc19zb21lIHQgPSBub3QgKGlzX25vbmUgdClcbmxldCBjYWxsX2lmX3NvbWUgdCA9IHQgKClcbmxldCB1bmNoZWNrZWRfdmFsdWUgdCA9IHRcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE5IEFudG9uaW8gTi4gTW9udGVpcm8uXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogIGFyZSBtZXQ6XG4gKlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gKiAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gKiAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gKiAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gKiAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gKiAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICogIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICogIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG5tb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcblxudHlwZSB0ID1cbiAgeyBtZXRoIDogSHR0cGFmLk1ldGhvZC50XG4gIDsgdGFyZ2V0IDogc3RyaW5nXG4gIDsgc2NoZW1lIDogc3RyaW5nXG4gIDsgaGVhZGVycyA6IEhlYWRlcnMudFxuICB9XG5cbigqIFRPRE86IGA6YXV0aG9yaXR5YCBwc2V1ZG8taGVhZGVyPyAqKVxubGV0IGNyZWF0ZSA/KGhlYWRlcnMgPSBIZWFkZXJzLmVtcHR5KSB+c2NoZW1lIG1ldGggdGFyZ2V0ID1cbiAgeyBtZXRoOyB0YXJnZXQ7IHNjaGVtZTsgaGVhZGVycyB9XG5cbmxldCBib2R5X2xlbmd0aCB7IGhlYWRlcnM7IF8gfSA9IE1lc3NhZ2UuYm9keV9sZW5ndGggaGVhZGVyc1xuXG5sZXQgcHBfaHVtIGZtdCB7IG1ldGg7IHRhcmdldDsgc2NoZW1lOyBoZWFkZXJzIH0gPVxuICBGb3JtYXQuZnByaW50ZlxuICAgIGZtdFxuICAgIFwiKChtZXRob2QgXFxcIiVhXFxcIikgKHRhcmdldCAlUykgKHNjaGVtZSAlUykgKGhlYWRlcnMgJWEpKVwiXG4gICAgSHR0cGFmLk1ldGhvZC5wcF9odW1cbiAgICBtZXRoXG4gICAgdGFyZ2V0XG4gICAgc2NoZW1lXG4gICAgSGVhZGVycy5wcF9odW1cbiAgICBoZWFkZXJzXG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuICogIENvcHlyaWdodCAoYykgMjAxOSBBbnRvbmlvIE4uIE1vbnRlaXJvLlxuICpcbiAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqICBhcmUgbWV0OlxuICpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIG5vciB0aGUgbmFtZXMgb2YgaGlzIGNvbnRyaWJ1dG9yc1xuICogICAgIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogICAgIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICogIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICogIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAqICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICogIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICogIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAqICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAqICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxubW9kdWxlIEh0dHBhZiA9IERyZWFtX2h0dHBhZl8uSHR0cGFmXG5cbigqIEZyb20gUkZDNzU0MMKnOC4xLjE6XG4gKiAgIEhUVFAvMiByZW1vdmVzIHN1cHBvcnQgZm9yIHRoZSAxMDEgKFN3aXRjaGluZyBQcm90b2NvbHMpIGluZm9ybWF0aW9uYWxcbiAqICAgc3RhdHVzIGNvZGUgKFtSRkM3MjMxXSwgU2VjdGlvbiA2LjIuMikuXG4gKlxuICogICBOb3RlOiBXaGlsZSB0aGUgYWJvdmUgaXMgdHJ1ZSwgd2UgZG9uJ3QgZW5mb3JjZSBpbiB0aGlzIGxpYnJhcnksIGFzIGl0XG4gKiAgIG1ha2VzIHVuaWZ5aW5nIHR5cGVzIHdpdGggaHR0cC9hZiBtdWNoIGVhc2llci4gYEgyLlN0YXR1cy50YCBpcywgdGh1cywgYVxuICogICBzdHJpY3Qgc3VwZXJzZXQgb2YgYEh0dHBhZi5TdGF0dXMudGAuICopXG5cbmluY2x1ZGUgKFxuICBIdHRwYWYuU3RhdHVzIDpcbiAgICBtb2R1bGUgdHlwZSBvZiBIdHRwYWYuU3RhdHVzXG4gICAgd2l0aCB0eXBlIGNsaWVudF9lcnJvciA6PSBIdHRwYWYuU3RhdHVzLmNsaWVudF9lcnJvclxuICAgICBhbmQgdHlwZSBzdGFuZGFyZCA6PSBIdHRwYWYuU3RhdHVzLnN0YW5kYXJkXG4gICAgIGFuZCB0eXBlIHQgOj0gSHR0cGFmLlN0YXR1cy50KVxuXG50eXBlIGNsaWVudF9lcnJvciA9XG4gIFsgSHR0cGFmLlN0YXR1cy5jbGllbnRfZXJyb3JcbiAgfCAoKiBGcm9tIFJGQzc1NDDCpzkuMS4yOlxuICAgICAqICAgVGhlIDQyMSAoTWlzZGlyZWN0ZWQgUmVxdWVzdCkgc3RhdHVzIGNvZGUgaW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3RcbiAgICAgKiAgIHdhcyBkaXJlY3RlZCBhdCBhIHNlcnZlciB0aGF0IGlzIG5vdCBhYmxlIHRvIHByb2R1Y2UgYSByZXNwb25zZS4gVGhpc1xuICAgICAqICAgY2FuIGJlIHNlbnQgYnkgYSBzZXJ2ZXIgdGhhdCBpcyBub3QgY29uZmlndXJlZCB0byBwcm9kdWNlIHJlc3BvbnNlc1xuICAgICAqICAgZm9yIHRoZSBjb21iaW5hdGlvbiBvZiBzY2hlbWUgYW5kIGF1dGhvcml0eSB0aGF0IGFyZSBpbmNsdWRlZCBpbiB0aGVcbiAgICAgKiAgIHJlcXVlc3QgVVJJLiAqKVxuICAgIGBNaXNkaXJlY3RlZF9yZXF1ZXN0XG4gIF1cblxudHlwZSBzdGFuZGFyZCA9XG4gIFsgSHR0cGFmLlN0YXR1cy5zdGFuZGFyZFxuICB8IGNsaWVudF9lcnJvclxuICBdXG5cbnR5cGUgdCA9XG4gIFsgc3RhbmRhcmRcbiAgfCBgQ29kZSBvZiBpbnRcbiAgXVxuXG4oKiBOb3RlOiBUaGUgdmFsdWUgZm9yIHJlYXNvbiBwaHJhc2VzIGlzIG5ldmVyIGFjdHVhbGx5IHNlcmlhbGl6ZWQgdG8gdGhlXG4gKiBpbnB1dCBvciBvdXRwdXQgY2hhbm5lbHMuXG4gKlxuICogRnJvbSBSRkM3NTQwwqc4LjEuMi40OlxuICogICBIVFRQLzIgZG9lcyBub3QgZGVmaW5lIGEgd2F5IHRvIGNhcnJ5IHRoZSB2ZXJzaW9uIG9yIHJlYXNvbiBwaHJhc2UgdGhhdCBpc1xuICogICBpbmNsdWRlZCBpbiBhbiBIVFRQLzEuMSBzdGF0dXMgbGluZS4gKilcbmxldCBkZWZhdWx0X3JlYXNvbl9waHJhc2UgPSBmdW5jdGlvblxuICB8IGBNaXNkaXJlY3RlZF9yZXF1ZXN0IC0+IFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFwiXG4gIHwgI0h0dHBhZi5TdGF0dXMuc3RhbmRhcmQgYXMgdCAtPiBIdHRwYWYuU3RhdHVzLmRlZmF1bHRfcmVhc29uX3BocmFzZSB0XG5cbmxldCB0b19jb2RlID0gZnVuY3Rpb25cbiAgfCBgTWlzZGlyZWN0ZWRfcmVxdWVzdCAtPiA0MjFcbiAgfCAjSHR0cGFmLlN0YXR1cy50IGFzIHQgLT4gSHR0cGFmLlN0YXR1cy50b19jb2RlIHRcblxubGV0IHVuc2FmZV9vZl9jb2RlID0gZnVuY3Rpb25cbiAgfCA0MjEgLT4gYE1pc2RpcmVjdGVkX3JlcXVlc3RcbiAgfCBjIC0+IChIdHRwYWYuU3RhdHVzLnVuc2FmZV9vZl9jb2RlIGMgOj4gdClcblxubGV0IG9mX2NvZGUgPSBmdW5jdGlvblxuICB8IDQyMSAtPiBgTWlzZGlyZWN0ZWRfcmVxdWVzdFxuICB8IGMgLT4gKEh0dHBhZi5TdGF0dXMub2ZfY29kZSBjIDo+IHQpXG5cbmxldCBpc19pbmZvcm1hdGlvbmFsID0gZnVuY3Rpb25cbiAgfCBgTWlzZGlyZWN0ZWRfcmVxdWVzdCAtPiBmYWxzZVxuICB8ICNIdHRwYWYuU3RhdHVzLnQgYXMgdCAtPiBIdHRwYWYuU3RhdHVzLmlzX2luZm9ybWF0aW9uYWwgdFxuXG5sZXQgaXNfc3VjY2Vzc2Z1bCA9IGZ1bmN0aW9uXG4gIHwgYE1pc2RpcmVjdGVkX3JlcXVlc3QgLT4gZmFsc2VcbiAgfCAjSHR0cGFmLlN0YXR1cy50IGFzIHQgLT4gSHR0cGFmLlN0YXR1cy5pc19zdWNjZXNzZnVsIHRcblxubGV0IGlzX3JlZGlyZWN0aW9uID0gZnVuY3Rpb25cbiAgfCBgTWlzZGlyZWN0ZWRfcmVxdWVzdCAtPiBmYWxzZVxuICB8ICNIdHRwYWYuU3RhdHVzLnQgYXMgdCAtPiBIdHRwYWYuU3RhdHVzLmlzX3JlZGlyZWN0aW9uIHRcblxubGV0IGlzX2NsaWVudF9lcnJvciA9IGZ1bmN0aW9uXG4gIHwgYE1pc2RpcmVjdGVkX3JlcXVlc3QgLT4gdHJ1ZVxuICB8ICNIdHRwYWYuU3RhdHVzLnQgYXMgdCAtPiBIdHRwYWYuU3RhdHVzLmlzX2NsaWVudF9lcnJvciB0XG5cbmxldCBpc19zZXJ2ZXJfZXJyb3IgPSBmdW5jdGlvblxuICB8IGBNaXNkaXJlY3RlZF9yZXF1ZXN0IC0+IGZhbHNlXG4gIHwgI0h0dHBhZi5TdGF0dXMudCBhcyB0IC0+IEh0dHBhZi5TdGF0dXMuaXNfc2VydmVyX2Vycm9yIHRcblxubGV0IGlzX2Vycm9yID0gZnVuY3Rpb25cbiAgfCBgTWlzZGlyZWN0ZWRfcmVxdWVzdCAtPiB0cnVlXG4gIHwgI0h0dHBhZi5TdGF0dXMudCBhcyB0IC0+IEh0dHBhZi5TdGF0dXMuaXNfZXJyb3IgdFxuXG5sZXQgdG9fc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBgTWlzZGlyZWN0ZWRfcmVxdWVzdCAtPiBcIjQyMVwiXG4gIHwgI0h0dHBhZi5TdGF0dXMudCBhcyB0IC0+IEh0dHBhZi5TdGF0dXMudG9fc3RyaW5nIHRcblxubGV0IG9mX3N0cmluZyB4ID0gb2ZfY29kZSAoaW50X29mX3N0cmluZyB4KVxubGV0IHBwX2h1bSBmbXQgdCA9IEZvcm1hdC5mcHJpbnRmIGZtdCBcIiV1XCIgKHRvX2NvZGUgdClcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE5IEFudG9uaW8gTi4gTW9udGVpcm8uXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogIGFyZSBtZXQ6XG4gKlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gKiAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gKiAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gKiAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gKiAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gKiAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICogIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICogIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG5tb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcblxudHlwZSB0ID1cbiAgeyBzdGF0dXMgOiBTdGF0dXMudFxuICA7IGhlYWRlcnMgOiBIZWFkZXJzLnRcbiAgfVxuXG4oKiBGcm9tIFJGQzc1NDDCpzguMS4yLjQ6XG4gKiAgIEhUVFAvMiBkb2VzIG5vdCBkZWZpbmUgYSB3YXkgdG8gY2FycnkgdGhlIHZlcnNpb24gb3IgcmVhc29uIHBocmFzZSB0aGF0XG4gKiAgIGlzIGluY2x1ZGVkIGluIGFuIEhUVFAvMS4xIHN0YXR1cyBsaW5lLiAqKVxubGV0IGNyZWF0ZSA/KGhlYWRlcnMgPSBIZWFkZXJzLmVtcHR5KSBzdGF0dXMgPSB7IHN0YXR1czsgaGVhZGVycyB9XG5cbmxldCBib2R5X2xlbmd0aCB+cmVxdWVzdF9tZXRob2QgeyBoZWFkZXJzOyBfIH0gPVxuICBtYXRjaCByZXF1ZXN0X21ldGhvZCB3aXRoXG4gIHwgYEhFQUQgLT4gYEZpeGVkIDBMXG4gIHwgI0h0dHBhZi5NZXRob2Quc3RhbmRhcmQgLT4gTWVzc2FnZS5ib2R5X2xlbmd0aCBoZWFkZXJzXG5cbmxldCBwcF9odW0gZm10IHsgc3RhdHVzOyBoZWFkZXJzIH0gPVxuICBsZXQgcmVhc29uID1cbiAgICBtYXRjaCBzdGF0dXMgd2l0aFxuICAgIHwgI1N0YXR1cy5zdGFuZGFyZCBhcyBzdGF0dXMgLT4gU3RhdHVzLmRlZmF1bHRfcmVhc29uX3BocmFzZSBzdGF0dXNcbiAgICB8IGBDb2RlIF8gLT4gXCJOb24tc3RhbmRhcmQgc3RhdHVzIGNvZGVcIlxuICBpblxuICBGb3JtYXQuZnByaW50ZlxuICAgIGZtdFxuICAgIFwiKChzdGF0dXMgJWEpIChyZWFzb24gJVMpIChoZWFkZXJzICVhKSlcIlxuICAgIFN0YXR1cy5wcF9odW1cbiAgICBzdGF0dXNcbiAgICByZWFzb25cbiAgICBIZWFkZXJzLnBwX2h1bVxuICAgIGhlYWRlcnNcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE5IEFudG9uaW8gTi4gTW9udGVpcm8uXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogIGFyZSBtZXQ6XG4gKlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gKiAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gKiAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gKiAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gKiAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gKiAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICogIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICogIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG5tb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcbm1vZHVsZSBIcGFjayA9IERyZWFtX2hwYWNrLkhwYWNrXG5cbm9wZW4gRmFyYWRheVxubW9kdWxlIElPVmVjID0gSHR0cGFmLklPVmVjXG5cbnR5cGUgZnJhbWVfaW5mbyA9XG4gIHsgZmxhZ3MgOiBGbGFncy50XG4gIDsgc3RyZWFtX2lkIDogU3RyZWFtX2lkZW50aWZpZXIudFxuICA7IHBhZGRpbmcgOiBCaWdzdHJpbmdhZi50XG4gIDsgbWF4X2ZyYW1lX3BheWxvYWQgOiBpbnRcbiAgfVxuXG5sZXQgd3JpdGVfdWludDI0IHQgbiA9XG4gIGxldCB3cml0ZV9vY3RldCB0IG8gPSB3cml0ZV91aW50OCB0IChvIGxhbmQgMHhmZikgaW5cbiAgd3JpdGVfb2N0ZXQgdCAobiBsc3IgMTYpO1xuICB3cml0ZV9vY3RldCB0IChuIGxzciA4KTtcbiAgd3JpdGVfb2N0ZXQgdCBuXG5cbmxldCB3cml0ZV9mcmFtZV9oZWFkZXIgdCBmcmFtZV9oZWFkZXIgPVxuICBsZXQgeyBGcmFtZS5wYXlsb2FkX2xlbmd0aDsgZmxhZ3M7IHN0cmVhbV9pZDsgZnJhbWVfdHlwZSB9ID0gZnJhbWVfaGVhZGVyIGluXG4gIHdyaXRlX3VpbnQyNCB0IHBheWxvYWRfbGVuZ3RoO1xuICB3cml0ZV91aW50OCB0IChGcmFtZS5GcmFtZVR5cGUuc2VyaWFsaXplIGZyYW1lX3R5cGUpO1xuICB3cml0ZV91aW50OCB0IGZsYWdzO1xuICBCRS53cml0ZV91aW50MzIgdCBzdHJlYW1faWRcblxubGV0IHdyaXRlX2ZyYW1lX3dpdGhfcGFkZGluZyB0IGluZm8gZnJhbWVfdHlwZSBsZW5ndGggd3JpdGVyID1cbiAgbGV0IGhlYWRlciwgd3JpdGVyID1cbiAgICBpZiBCaWdzdHJpbmdhZi5sZW5ndGggaW5mby5wYWRkaW5nID0gMFxuICAgIHRoZW5cbiAgICAgIGxldCBoZWFkZXIgPVxuICAgICAgICB7IEZyYW1lLnBheWxvYWRfbGVuZ3RoID0gbGVuZ3RoXG4gICAgICAgIDsgZmxhZ3MgPSBpbmZvLmZsYWdzXG4gICAgICAgIDsgc3RyZWFtX2lkID0gaW5mby5zdHJlYW1faWRcbiAgICAgICAgOyBmcmFtZV90eXBlXG4gICAgICAgIH1cbiAgICAgIGluXG4gICAgICBoZWFkZXIsIHdyaXRlclxuICAgIGVsc2VcbiAgICAgIGxldCBwYWRfbGVuZ3RoID0gQmlnc3RyaW5nYWYubGVuZ3RoIGluZm8ucGFkZGluZyBpblxuICAgICAgbGV0IHdyaXRlcicgdCA9XG4gICAgICAgIHdyaXRlX3VpbnQ4IHQgcGFkX2xlbmd0aDtcbiAgICAgICAgd3JpdGVyIHQ7XG4gICAgICAgIHNjaGVkdWxlX2JpZ3N0cmluZyB+b2ZmOjAgfmxlbjpwYWRfbGVuZ3RoIHQgaW5mby5wYWRkaW5nXG4gICAgICBpblxuICAgICAgbGV0IGhlYWRlciA9XG4gICAgICAgIHsgRnJhbWUucGF5bG9hZF9sZW5ndGggPSBsZW5ndGggKyBwYWRfbGVuZ3RoICsgMVxuICAgICAgICA7IGZsYWdzID0gRmxhZ3Muc2V0X3BhZGRlZCBpbmZvLmZsYWdzXG4gICAgICAgIDsgc3RyZWFtX2lkID0gaW5mby5zdHJlYW1faWRcbiAgICAgICAgOyBmcmFtZV90eXBlXG4gICAgICAgIH1cbiAgICAgIGluXG4gICAgICBoZWFkZXIsIHdyaXRlcidcbiAgaW5cbiAgd3JpdGVfZnJhbWVfaGVhZGVyIHQgaGVhZGVyO1xuICB3cml0ZXIgdFxuXG5sZXQgd3JpdGVfZGF0YV9mcmFtZSB0ID9vZmYgP2xlbiBpbmZvIGJvZHkgPVxuICBsZXQgd3JpdGVyIHQgPSB3cml0ZV9zdHJpbmcgdCA/b2ZmID9sZW4gYm9keSBpblxuICBsZXQgbGVuZ3RoID0gbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIGJvZHkgaW5cbiAgd3JpdGVfZnJhbWVfd2l0aF9wYWRkaW5nIHQgaW5mbyBEYXRhIGxlbmd0aCB3cml0ZXJcblxubGV0IHNjaGVkdWxlX2RhdGFfZnJhbWUgdCBpbmZvID9vZmYgP2xlbiBic3RyID1cbiAgbGV0IHdyaXRlciB0ID0gc2NoZWR1bGVfYmlnc3RyaW5nIHQgP29mZiA/bGVuIGJzdHIgaW5cbiAgbGV0IGxlbmd0aCA9XG4gICAgbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBCaWdzdHJpbmdhZi5sZW5ndGggYnN0clxuICBpblxuICB3cml0ZV9mcmFtZV93aXRoX3BhZGRpbmcgdCBpbmZvIERhdGEgbGVuZ3RoIHdyaXRlclxuXG5sZXQgd3JpdGVfcHJpb3JpdHkgdCB7IFByaW9yaXR5LmV4Y2x1c2l2ZTsgc3RyZWFtX2RlcGVuZGVuY3k7IHdlaWdodCB9ID1cbiAgbGV0IHN0cmVhbV9kZXBlbmRlbmN5X2lkID1cbiAgICBpZiBleGNsdXNpdmVcbiAgICB0aGVuIFByaW9yaXR5LnNldF9leGNsdXNpdmUgc3RyZWFtX2RlcGVuZGVuY3lcbiAgICBlbHNlIHN0cmVhbV9kZXBlbmRlbmN5XG4gIGluXG4gIEJFLndyaXRlX3VpbnQzMiB0IHN0cmVhbV9kZXBlbmRlbmN5X2lkO1xuICAoKiBGcm9tIFJGQzc1NDDCpzYuMzpcbiAgICogICBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyIHJlcHJlc2VudGluZyBhIHByaW9yaXR5IHdlaWdodCBmb3IgdGhlIHN0cmVhbVxuICAgKiAgIChzZWUgU2VjdGlvbiA1LjMpLiBBZGQgb25lIHRvIHRoZSB2YWx1ZSB0byBvYnRhaW4gYSB3ZWlnaHQgYmV0d2VlbiAxIGFuZFxuICAgKiAgIDI1Ni5cbiAgICpcbiAgICogTm90ZTogd2Ugc3RvcmUgcHJpb3JpdHkgd2l0aCB2YWx1ZXMgZnJvbSAxIHRvIDI1Niwgc28gZGVjcmVtZW50IGhlcmUuICopXG4gIHdyaXRlX3VpbnQ4IHQgKHdlaWdodCAtIDEpXG5cbmxldCBib3VuZGVkX3NjaGVkdWxlX2lvdmVjcyB0IH5sZW4gaW92ZWNzID1cbiAgbGV0IHJlYyBsb29wIHQgcmVtYWluaW5nIGlvdmVjcyA9XG4gICAgbWF0Y2ggcmVtYWluaW5nLCBpb3ZlY3Mgd2l0aFxuICAgIHwgMCwgXyB8IF8sIFtdIC0+ICgpXG4gICAgfCByZW1haW5pbmcsIHsgSU9WZWMuYnVmZmVyOyBvZmY7IGxlbiB9IDo6IHhzIC0+XG4gICAgICBpZiByZW1haW5pbmcgPCBsZW5cbiAgICAgIHRoZW4gc2NoZWR1bGVfYmlnc3RyaW5nIHQgfm9mZiB+bGVuOnJlbWFpbmluZyBidWZmZXJcbiAgICAgIGVsc2UgKFxuICAgICAgICBzY2hlZHVsZV9iaWdzdHJpbmcgdCB+b2ZmIH5sZW4gYnVmZmVyO1xuICAgICAgICBsb29wIHQgKHJlbWFpbmluZyAtIGxlbikgeHMpXG4gIGluXG4gIGxvb3AgdCBsZW4gaW92ZWNzXG5cbmxldCB3cml0ZV9oZWFkZXJzX2ZyYW1lIHQgaW5mbyB+cHJpb3JpdHkgP2xlbiBpb3ZlY3MgPVxuICBsZXQgbGVuID0gbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBJT1ZlYy5sZW5ndGh2IGlvdmVjcyBpblxuICBpZiBwcmlvcml0eSA9PSBQcmlvcml0eS5kZWZhdWx0X3ByaW9yaXR5XG4gIHRoZW5cbiAgICAoKiBTZWUgUkZDNzU0MMKnNi4zOlxuICAgICAqICAgSnVzdCB0aGUgSGVhZGVyIEJsb2NrIEZyYWdtZW50IGxlbmd0aCBpZiBubyBwcmlvcml0eS4gKilcbiAgICBsZXQgd3JpdGVyIHQgPSBib3VuZGVkX3NjaGVkdWxlX2lvdmVjcyB0IH5sZW4gaW92ZWNzIGluXG4gICAgd3JpdGVfZnJhbWVfd2l0aF9wYWRkaW5nIHQgaW5mbyBIZWFkZXJzIGxlbiB3cml0ZXJcbiAgZWxzZVxuICAgICgqIFNlZSBSRkM3NTQwwqc2LjI6XG4gICAgICogICBFeGNsdXNpdmUgQml0ICYgU3RyZWFtIERlcGVuZGVuY3kgKDQgb2N0ZXRzKSArIFdlaWdodCAoMSBvY3RldCkgK1xuICAgICAqICAgSGVhZGVyIEJsb2NrIEZyYWdtZW50IGxlbmd0aC4gKilcbiAgICBsZXQgcGF5bG9hZF9sZW5ndGggPSBsZW4gKyA1IGluXG4gICAgbGV0IGluZm8nID0geyBpbmZvIHdpdGggZmxhZ3MgPSBGbGFncy5zZXRfcHJpb3JpdHkgaW5mby5mbGFncyB9IGluXG4gICAgbGV0IHdyaXRlciB0ID1cbiAgICAgIHdyaXRlX3ByaW9yaXR5IHQgcHJpb3JpdHk7XG4gICAgICBib3VuZGVkX3NjaGVkdWxlX2lvdmVjcyB0IH5sZW4gaW92ZWNzXG4gICAgaW5cbiAgICB3cml0ZV9mcmFtZV93aXRoX3BhZGRpbmcgdCBpbmZvJyBIZWFkZXJzIHBheWxvYWRfbGVuZ3RoIHdyaXRlclxuXG5sZXQgd3JpdGVfcHJpb3JpdHlfZnJhbWUgdCBpbmZvIHByaW9yaXR5ID1cbiAgbGV0IGhlYWRlciA9XG4gICAgeyBGcmFtZS5mbGFncyA9IGluZm8uZmxhZ3NcbiAgICA7IHN0cmVhbV9pZCA9XG4gICAgICAgIGluZm8uc3RyZWFtX2lkXG4gICAgICAgICgqIFNlZSBSRkM3NTQwwqc2LjM6XG4gICAgICAgICAqICAgU3RyZWFtIERlcGVuZGVuY3kgKDQgb2N0ZXRzKSArIFdlaWdodCAoMSBvY3RldCkuICopXG4gICAgOyBwYXlsb2FkX2xlbmd0aCA9IDVcbiAgICA7IGZyYW1lX3R5cGUgPSBQcmlvcml0eVxuICAgIH1cbiAgaW5cbiAgd3JpdGVfZnJhbWVfaGVhZGVyIHQgaGVhZGVyO1xuICB3cml0ZV9wcmlvcml0eSB0IHByaW9yaXR5XG5cbmxldCB3cml0ZV9yc3Rfc3RyZWFtX2ZyYW1lIHQgaW5mbyBlID1cbiAgbGV0IGhlYWRlciA9XG4gICAgeyBGcmFtZS5mbGFncyA9IGluZm8uZmxhZ3NcbiAgICA7IHN0cmVhbV9pZCA9XG4gICAgICAgIGluZm8uc3RyZWFtX2lkXG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi40OlxuICAgICAgICAgKiAgIFRoZSBSU1RfU1RSRUFNIGZyYW1lIGNvbnRhaW5zIGEgc2luZ2xlIHVuc2lnbmVkLCAzMi1iaXQgaW50ZWdlclxuICAgICAgICAgKiAgIGlkZW50aWZ5aW5nIHRoZSBlcnJvciBjb2RlIChTZWN0aW9uIDcpLiAqKVxuICAgIDsgcGF5bG9hZF9sZW5ndGggPSA0XG4gICAgOyBmcmFtZV90eXBlID0gUlNUU3RyZWFtXG4gICAgfVxuICBpblxuICB3cml0ZV9mcmFtZV9oZWFkZXIgdCBoZWFkZXI7XG4gIEJFLndyaXRlX3VpbnQzMiB0IChFcnJvcl9jb2RlLnNlcmlhbGl6ZSBlKVxuXG5sZXQgd3JpdGVfc2V0dGluZ3NfZnJhbWUgdCBpbmZvIHNldHRpbmdzID1cbiAgbGV0IGhlYWRlciA9XG4gICAgeyBGcmFtZS5mbGFncyA9IGluZm8uZmxhZ3NcbiAgICA7IHN0cmVhbV9pZCA9XG4gICAgICAgIGluZm8uc3RyZWFtX2lkXG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi41LjE6XG4gICAgICAgICAqICAgVGhlIHBheWxvYWQgb2YgYSBTRVRUSU5HUyBmcmFtZSBjb25zaXN0cyBvZiB6ZXJvIG9yIG1vcmVcbiAgICAgICAgICogICBwYXJhbWV0ZXJzLCBlYWNoIGNvbnNpc3Rpbmcgb2YgYW4gdW5zaWduZWQgMTYtYml0IHNldHRpbmdcbiAgICAgICAgICogICBpZGVudGlmaWVyIGFuZCBhbiB1bnNpZ25lZCAzMi1iaXQgdmFsdWUuICopXG4gICAgOyBwYXlsb2FkX2xlbmd0aCA9IExpc3QubGVuZ3RoIHNldHRpbmdzICogNlxuICAgIDsgZnJhbWVfdHlwZSA9IFNldHRpbmdzXG4gICAgfVxuICBpblxuICB3cml0ZV9mcmFtZV9oZWFkZXIgdCBoZWFkZXI7XG4gIFNldHRpbmdzLndyaXRlX3NldHRpbmdzX3BheWxvYWQgdCBzZXR0aW5nc1xuXG5sZXQgd3JpdGVfcHVzaF9wcm9taXNlX2ZyYW1lIHQgaW5mbyB+cHJvbWlzZWRfaWQgP2xlbiBpb3ZlY3MgPVxuICBsZXQgbGVuID0gbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBJT1ZlYy5sZW5ndGh2IGlvdmVjcyBpblxuICBsZXQgcGF5bG9hZF9sZW5ndGggPVxuICAgICgqIEZyb20gUkZDNzU0MMKnNi42OlxuICAgICAqICAgVGhlIFBVU0hfUFJPTUlTRSBmcmFtZSBpbmNsdWRlcyB0aGUgdW5zaWduZWQgMzEtYml0IGlkZW50aWZpZXIgb2YgdGhlXG4gICAgICogICBzdHJlYW0gdGhlIGVuZHBvaW50IHBsYW5zIHRvIGNyZWF0ZSBhbG9uZyB3aXRoIGEgc2V0IG9mIGhlYWRlcnMgdGhhdFxuICAgICAqICAgcHJvdmlkZSBhZGRpdGlvbmFsIGNvbnRleHQgZm9yIHRoZSBzdHJlYW0uICopXG4gICAgNCArIGxlblxuICBpblxuICBsZXQgd3JpdGVyIHQgPVxuICAgIEJFLndyaXRlX3VpbnQzMiB0IHByb21pc2VkX2lkO1xuICAgIGJvdW5kZWRfc2NoZWR1bGVfaW92ZWNzIHQgfmxlbiBpb3ZlY3NcbiAgaW5cbiAgd3JpdGVfZnJhbWVfd2l0aF9wYWRkaW5nIHQgaW5mbyBQdXNoUHJvbWlzZSBwYXlsb2FkX2xlbmd0aCB3cml0ZXJcblxubGV0IGRlZmF1bHRfcGluZ19wYXlsb2FkID1cbiAgKCogRnJvbSBSRkM3NTQwwqc2Ljc6XG4gICAqICAgSW4gYWRkaXRpb24gdG8gdGhlIGZyYW1lIGhlYWRlciwgUElORyBmcmFtZXMgTVVTVCBjb250YWluIDggb2N0ZXRzIG9mXG4gICAqICAgb3BhcXVlIGRhdGEgaW4gdGhlIHBheWxvYWQuICopXG4gIGxldCBic3RyID0gQmlnc3RyaW5nYWYuY3JlYXRlIDggaW5cbiAgZm9yIGkgPSAwIHRvIDcgZG9cbiAgICBCaWdzdHJpbmdhZi51bnNhZmVfc2V0IGJzdHIgaSAnXFwwMDAnXG4gIGRvbmU7XG4gIGJzdHJcblxubGV0IHdyaXRlX3BpbmdfZnJhbWUgdCBpbmZvID8ob2ZmID0gMCkgcGF5bG9hZCA9XG4gICgqIEZyb20gUkZDNzU0MMKnNi43OlxuICAgKiAgIEluIGFkZGl0aW9uIHRvIHRoZSBmcmFtZSBoZWFkZXIsIFBJTkcgZnJhbWVzIE1VU1QgY29udGFpbiA4IG9jdGV0cyBvZlxuICAgKiAgIG9wYXF1ZSBkYXRhIGluIHRoZSBwYXlsb2FkLiAqKVxuICBsZXQgcGF5bG9hZF9sZW5ndGggPSA4IGluXG4gIGxldCBoZWFkZXIgPVxuICAgIHsgRnJhbWUuZmxhZ3MgPSBpbmZvLmZsYWdzXG4gICAgOyBzdHJlYW1faWQgPSBpbmZvLnN0cmVhbV9pZFxuICAgIDsgcGF5bG9hZF9sZW5ndGhcbiAgICA7IGZyYW1lX3R5cGUgPSBQaW5nXG4gICAgfVxuICBpblxuICB3cml0ZV9mcmFtZV9oZWFkZXIgdCBoZWFkZXI7XG4gIHNjaGVkdWxlX2JpZ3N0cmluZyB+b2ZmIH5sZW46cGF5bG9hZF9sZW5ndGggdCBwYXlsb2FkXG5cbmxldCB3cml0ZV9nb19hd2F5X2ZyYW1lIHQgaW5mbyBzdHJlYW1faWQgZXJyb3JfY29kZSBkZWJ1Z19kYXRhID1cbiAgbGV0IGRlYnVnX2RhdGFfbGVuID0gQmlnc3RyaW5nYWYubGVuZ3RoIGRlYnVnX2RhdGEgaW5cbiAgbGV0IGhlYWRlciA9XG4gICAgeyBGcmFtZS5mbGFncyA9IGluZm8uZmxhZ3NcbiAgICA7IHN0cmVhbV9pZCA9XG4gICAgICAgIGluZm8uc3RyZWFtX2lkXG4gICAgICAgICgqIFNlZSBSRkM3NTQwwqc2Ljg6XG4gICAgICAgICAqICAgTGFzdC1TdHJlYW0tSUQgKDQgb2N0ZXRzKSArIEVycm9yIENvZGUgKDQgb2N0ZXRzKSArIEFkZGl0aW9uYWxcbiAgICAgICAgICogICBEZWJ1ZyBEYXRhIChvcGFxdWUpICopXG4gICAgOyBwYXlsb2FkX2xlbmd0aCA9IDggKyBkZWJ1Z19kYXRhX2xlblxuICAgIDsgZnJhbWVfdHlwZSA9IEdvQXdheVxuICAgIH1cbiAgaW5cbiAgd3JpdGVfZnJhbWVfaGVhZGVyIHQgaGVhZGVyO1xuICBCRS53cml0ZV91aW50MzIgdCBzdHJlYW1faWQ7XG4gIEJFLndyaXRlX3VpbnQzMiB0IChFcnJvcl9jb2RlLnNlcmlhbGl6ZSBlcnJvcl9jb2RlKTtcbiAgc2NoZWR1bGVfYmlnc3RyaW5nIHQgfm9mZjowIH5sZW46ZGVidWdfZGF0YV9sZW4gZGVidWdfZGF0YVxuXG5sZXQgd3JpdGVfd2luZG93X3VwZGF0ZV9mcmFtZSB0IGluZm8gd2luZG93X3NpemUgPVxuICBsZXQgaGVhZGVyID1cbiAgICB7IEZyYW1lLmZsYWdzID0gaW5mby5mbGFnc1xuICAgIDsgc3RyZWFtX2lkID1cbiAgICAgICAgaW5mby5zdHJlYW1faWRcbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc2Ljk6XG4gICAgICAgICAqICAgVGhlIHBheWxvYWQgb2YgYSBXSU5ET1dfVVBEQVRFIGZyYW1lIGlzIG9uZSByZXNlcnZlZCBiaXQgcGx1cyBhblxuICAgICAgICAgKiAgIHVuc2lnbmVkIDMxLWJpdCBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG51bWJlciBvZiBvY3RldHMgdGhhdCB0aGVcbiAgICAgICAgICogICBzZW5kZXIgY2FuIHRyYW5zbWl0IGluIGFkZGl0aW9uIHRvIHRoZSBleGlzdGluZyBmbG93LWNvbnRyb2xcbiAgICAgICAgICogICB3aW5kb3cuICopXG4gICAgOyBwYXlsb2FkX2xlbmd0aCA9IDRcbiAgICA7IGZyYW1lX3R5cGUgPSBXaW5kb3dVcGRhdGVcbiAgICB9XG4gIGluXG4gIHdyaXRlX2ZyYW1lX2hlYWRlciB0IGhlYWRlcjtcbiAgQkUud3JpdGVfdWludDMyIHQgd2luZG93X3NpemVcblxubGV0IHdyaXRlX2NvbnRpbnVhdGlvbl9mcmFtZSB0IGluZm8gP2xlbiBpb3ZlY3MgPVxuICBsZXQgbGVuID0gbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBJT1ZlYy5sZW5ndGh2IGlvdmVjcyBpblxuICBsZXQgaGVhZGVyID1cbiAgICB7IEZyYW1lLmZsYWdzID0gaW5mby5mbGFnc1xuICAgIDsgc3RyZWFtX2lkID0gaW5mby5zdHJlYW1faWRcbiAgICA7IHBheWxvYWRfbGVuZ3RoID0gbGVuXG4gICAgOyBmcmFtZV90eXBlID0gQ29udGludWF0aW9uXG4gICAgfVxuICBpblxuICB3cml0ZV9mcmFtZV9oZWFkZXIgdCBoZWFkZXI7XG4gIGJvdW5kZWRfc2NoZWR1bGVfaW92ZWNzIHQgfmxlbiBpb3ZlY3NcblxubGV0IHdyaXRlX3Vua25vd25fZnJhbWUgdCB+Y29kZSBpbmZvIHBheWxvYWQgPVxuICBsZXQgcGF5bG9hZF9sZW5ndGggPSBCaWdzdHJpbmdhZi5sZW5ndGggcGF5bG9hZCBpblxuICBsZXQgaGVhZGVyID1cbiAgICB7IEZyYW1lLmZsYWdzID0gaW5mby5mbGFnc1xuICAgIDsgc3RyZWFtX2lkID0gaW5mby5zdHJlYW1faWRcbiAgICA7IHBheWxvYWRfbGVuZ3RoXG4gICAgOyBmcmFtZV90eXBlID0gVW5rbm93biBjb2RlXG4gICAgfVxuICBpblxuICB3cml0ZV9mcmFtZV9oZWFkZXIgdCBoZWFkZXI7XG4gIHNjaGVkdWxlX2JpZ3N0cmluZyB0IH5vZmY6MCB+bGVuOnBheWxvYWRfbGVuZ3RoIHBheWxvYWRcblxubGV0IHdyaXRlX2Nvbm5lY3Rpb25fcHJlZmFjZSB0ID1cbiAgKCogRnJvbSBSRkM3NTQwwqczLjU6XG4gICAqICAgSW4gSFRUUC8yLCBlYWNoIGVuZHBvaW50IGlzIHJlcXVpcmVkIHRvIHNlbmQgYSBjb25uZWN0aW9uIHByZWZhY2UgYXMgYVxuICAgKiAgIGZpbmFsIGNvbmZpcm1hdGlvbiBvZiB0aGUgcHJvdG9jb2wgaW4gdXNlIGFuZCB0byBlc3RhYmxpc2ggdGhlIGluaXRpYWxcbiAgICogICBzZXR0aW5ncyBmb3IgdGhlIEhUVFAvMiBjb25uZWN0aW9uLiBbLi4uXSBUaGUgY2xpZW50IGNvbm5lY3Rpb24gcHJlZmFjZVxuICAgKiAgIHN0YXJ0cyB3aXRoIGEgc2VxdWVuY2Ugb2YgMjQgb2N0ZXRzLCBbLi4uXSB0aGUgc3RyaW5nXG4gICAqICAgUFJJICogSFRUUC8yLjBcXHJcXG5cXHJcXG5TTVxcclxcblxcclxcbi4gKilcbiAgd3JpdGVfc3RyaW5nIHQgRnJhbWUuY29ubmVjdGlvbl9wcmVmYWNlXG5cbm1vZHVsZSBXcml0ZXIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGJ1ZmZlciA6IEJpZ3N0cmluZ2FmLnRcbiAgICAgICAgICAoKiBUaGUgYnVmZmVyIHRoYXQgdGhlIGVuY29kZXIgdXNlcyBmb3IgYnVmZmVyZWQgd3JpdGVzLiBNYW5hZ2VkIGJ5XG4gICAgICAgICAgICogdGhlIGNvbnRyb2wgbW9kdWxlIGZvciB0aGUgZW5jb2Rlci4gKilcbiAgICA7IGVuY29kZXIgOiBGYXJhZGF5LnRcbiAgICAgICAgICAoKiBUaGUgZW5jb2RlciB0aGF0IGhhbmRsZXMgZW5jb2RpbmcgZm9yIHdyaXRlcy4gVXNlcyB0aGUgW2J1ZmZlcl1cbiAgICAgICAgICAgKiByZWZlcmVuY2VkIGFib3ZlIGludGVybmFsbHkuICopXG4gICAgOyBtdXRhYmxlIGRyYWluZWRfYnl0ZXMgOiBpbnRcbiAgICAgICAgICAoKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgd2VyZSBub3Qgd3JpdHRlbiBkdWUgdG8gdGhlIG91dHB1dCBzdHJlYW1cbiAgICAgICAgICAgKiBiZWluZyBjbG9zZWQgYmVmb3JlIGFsbCBidWZmZXJlZCBvdXRwdXQgY291bGQgYmUgd3JpdHRlbi4gVXNlZnVsXG4gICAgICAgICAgICogZm9yIGRldGVjdGluZyBlcnJvciBjYXNlcy4gKilcbiAgICA7IG11dGFibGUgd2FrZXVwIDogT3B0aW9uYWxfdGh1bmsudFxuICAgIH1cblxuICBsZXQgY3JlYXRlIGJ1ZmZlcl9zaXplID1cbiAgICBsZXQgYnVmZmVyID0gQmlnc3RyaW5nYWYuY3JlYXRlIGJ1ZmZlcl9zaXplIGluXG4gICAgbGV0IGVuY29kZXIgPSBGYXJhZGF5Lm9mX2JpZ3N0cmluZyBidWZmZXIgaW5cbiAgICB7IGJ1ZmZlcjsgZW5jb2RlcjsgZHJhaW5lZF9ieXRlcyA9IDA7IHdha2V1cCA9IE9wdGlvbmFsX3RodW5rLm5vbmUgfVxuXG4gIGxldCBmYXJhZGF5IHQgPSB0LmVuY29kZXJcblxuICBsZXQgbWFrZV9mcmFtZV9pbmZvXG4gICAgICA/KHBhZGRpbmcgPSBCaWdzdHJpbmdhZi5lbXB0eSlcbiAgICAgID8oZmxhZ3MgPSBGbGFncy5kZWZhdWx0X2ZsYWdzKVxuICAgICAgPyhtYXhfZnJhbWVfc2l6ZSA9IENvbmZpZy5kZWZhdWx0LnJlYWRfYnVmZmVyX3NpemUpXG4gICAgICBzdHJlYW1faWRcbiAgICA9XG4gICAgeyBmbGFnczsgc3RyZWFtX2lkOyBwYWRkaW5nOyBtYXhfZnJhbWVfcGF5bG9hZCA9IG1heF9mcmFtZV9zaXplIH1cblxuICBsZXQgd3JpdGVfY29ubmVjdGlvbl9wcmVmYWNlIHQgc2V0dGluZ3NfbGlzdCA9XG4gICAgd3JpdGVfY29ubmVjdGlvbl9wcmVmYWNlIHQuZW5jb2RlcjtcbiAgICBsZXQgZnJhbWVfaW5mbyA9IG1ha2VfZnJhbWVfaW5mbyBTdHJlYW1faWRlbnRpZmllci5jb25uZWN0aW9uIGluXG4gICAgKCogRnJvbSBSRkM3NTQwwqczLjU6XG4gICAgICogICBUaGlzIHNlcXVlbmNlIE1VU1QgYmUgZm9sbG93ZWQgYnkgYSBTRVRUSU5HUyBmcmFtZSAoU2VjdGlvbiA2LjUpLFxuICAgICAqICAgd2hpY2ggTUFZIGJlIGVtcHR5LiAqKVxuICAgIHdyaXRlX3NldHRpbmdzX2ZyYW1lIHQuZW5jb2RlciBmcmFtZV9pbmZvIHNldHRpbmdzX2xpc3RcblxuICBsZXQgY2h1bmtfZGF0YV9mcmFtZXMgPyhvZmYgPSAwKSB+ZiBmcmFtZV9pbmZvIHRvdGFsX2xlbmd0aCA9XG4gICAgbGV0IHsgbWF4X2ZyYW1lX3BheWxvYWQ7IF8gfSA9IGZyYW1lX2luZm8gaW5cbiAgICBpZiBtYXhfZnJhbWVfcGF5bG9hZCA8IHRvdGFsX2xlbmd0aFxuICAgIHRoZW5cbiAgICAgIGxldCByZWMgbG9vcCB+b2ZmIHJlbWFpbmluZyA9XG4gICAgICAgIGlmIG1heF9mcmFtZV9wYXlsb2FkIDwgcmVtYWluaW5nXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgICgqIE5vdGU6IElmIHdlJ3JlIHNwbGl0dGluZyBkYXRhIGludG8gc2V2ZXJhbCBmcmFtZXMsIG9ubHkgdGhlIGxhc3RcbiAgICAgICAgICAgKiBvbmUgc2hvdWxkIGNvbnRhaW4gdGhlIEVORF9TVFJFQU0gZmxhZywgc28gdW5zZXQgaXQgaGVyZSBpZiBpdCdzXG4gICAgICAgICAgICogc2V0LiAqKVxuICAgICAgICAgIGxldCBmcmFtZV9pbmZvID1cbiAgICAgICAgICAgIHsgZnJhbWVfaW5mbyB3aXRoIGZsYWdzID0gRmxhZ3MuY2xlYXJfZW5kX3N0cmVhbSBmcmFtZV9pbmZvLmZsYWdzIH1cbiAgICAgICAgICBpblxuICAgICAgICAgIGYgfm9mZiB+bGVuOm1heF9mcmFtZV9wYXlsb2FkIGZyYW1lX2luZm87XG4gICAgICAgICAgbG9vcCB+b2ZmOihvZmYgKyBtYXhfZnJhbWVfcGF5bG9hZCkgKHJlbWFpbmluZyAtIG1heF9mcmFtZV9wYXlsb2FkKSlcbiAgICAgICAgZWxzZSBmIH5vZmYgfmxlbjpyZW1haW5pbmcgZnJhbWVfaW5mb1xuICAgICAgaW5cbiAgICAgIGxvb3Agfm9mZiB0b3RhbF9sZW5ndGhcbiAgICBlbHNlIGYgfm9mZiB+bGVuOnRvdGFsX2xlbmd0aCBmcmFtZV9pbmZvXG5cbiAgbGV0IHdyaXRlX2RhdGEgdCBmcmFtZV9pbmZvID9vZmYgP2xlbiBzdHIgPVxuICAgIGlmIG5vdCAoaXNfY2xvc2VkIHQuZW5jb2RlcilcbiAgICB0aGVuXG4gICAgICBsZXQgdG90YWxfbGVuZ3RoID1cbiAgICAgICAgbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHN0clxuICAgICAgaW5cbiAgICAgIGNodW5rX2RhdGFfZnJhbWVzXG4gICAgICAgIGZyYW1lX2luZm9cbiAgICAgICAgP29mZlxuICAgICAgICB0b3RhbF9sZW5ndGhcbiAgICAgICAgfmY6KGZ1biB+b2ZmIH5sZW4gZnJhbWVfaW5mbyAtPlxuICAgICAgICAgIHdyaXRlX2RhdGFfZnJhbWUgdC5lbmNvZGVyIGZyYW1lX2luZm8gfm9mZiB+bGVuIHN0cilcblxuICBsZXQgc2NoZWR1bGVfZGF0YSB0IGZyYW1lX2luZm8gP29mZiA/bGVuIGJzdHIgPVxuICAgIGlmIG5vdCAoaXNfY2xvc2VkIHQuZW5jb2RlcilcbiAgICB0aGVuXG4gICAgICBsZXQgdG90YWxfbGVuZ3RoID1cbiAgICAgICAgbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBCaWdzdHJpbmdhZi5sZW5ndGggYnN0clxuICAgICAgaW5cbiAgICAgIGNodW5rX2RhdGFfZnJhbWVzXG4gICAgICAgIGZyYW1lX2luZm9cbiAgICAgICAgP29mZlxuICAgICAgICB0b3RhbF9sZW5ndGhcbiAgICAgICAgfmY6KGZ1biB+b2ZmIH5sZW4gZnJhbWVfaW5mbyAtPlxuICAgICAgICAgIHNjaGVkdWxlX2RhdGFfZnJhbWUgdC5lbmNvZGVyIGZyYW1lX2luZm8gfm9mZiB+bGVuIGJzdHIpXG5cbiAgKCogQ2h1bmsgaGVhZGVyIGJsb2NrIGZyYWdtZW50cyBpbnRvIEhFQURFUlN8UFVTSF9QUk9NSVNFICsgQ09OVElOVUFUSU9OXG4gICAqIGZyYW1lcy4gKilcbiAgbGV0IGNodW5rX2hlYWRlcl9ibG9ja19mcmFnbWVudHNcbiAgICAgIHRcbiAgICAgIGZyYW1lX2luZm9cbiAgICAgID8oaGFzX3ByaW9yaXR5ID0gZmFsc2UpXG4gICAgICB+KHdyaXRlX2ZyYW1lIDpcbiAgICAgICAgIEZhcmFkYXkudCAtPiBmcmFtZV9pbmZvIC0+ID9sZW46aW50IC0+IEJpZ3N0cmluZ2FmLnQgaW92ZWMgbGlzdCAtPiB1bml0KVxuICAgICAgZmFyYWRheVxuICAgID1cbiAgICBsZXQgYmxvY2tfc2l6ZSA9IEZhcmFkYXkucGVuZGluZ19ieXRlcyBmYXJhZGF5IGluXG4gICAgbGV0IHRvdGFsX2xlbmd0aCA9XG4gICAgICBpZiBoYXNfcHJpb3JpdHlcbiAgICAgIHRoZW5cbiAgICAgICAgKCogU2VlIFJGQzc1NDDCpzYuMjogRXhjbHVzaXZlIEJpdCAmIFN0cmVhbSBEZXBlbmRlbmN5ICg0IG9jdGV0cykgK1xuICAgICAgICAgICBXZWlnaHQgKDEgb2N0ZXQpICsgSGVhZGVyIEJsb2NrIEZyYWdtZW50IGxlbmd0aC4gKilcbiAgICAgICAgYmxvY2tfc2l6ZSArIDVcbiAgICAgIGVsc2UgYmxvY2tfc2l6ZVxuICAgIGluXG4gICAgbGV0IHsgbWF4X2ZyYW1lX3BheWxvYWQ7IF8gfSA9IGZyYW1lX2luZm8gaW5cbiAgICBpZiBtYXhfZnJhbWVfcGF5bG9hZCA8IHRvdGFsX2xlbmd0aFxuICAgIHRoZW4gKFxuICAgICAgbGV0IGhlYWRlcnNfYmxvY2tfbGVuID1cbiAgICAgICAgaWYgaGFzX3ByaW9yaXR5IHRoZW4gbWF4X2ZyYW1lX3BheWxvYWQgLSA1IGVsc2UgbWF4X2ZyYW1lX3BheWxvYWRcbiAgICAgIGluXG4gICAgICBpZ25vcmVcbiAgICAgICAgKEZhcmFkYXkuc2VyaWFsaXplIGZhcmFkYXkgKGZ1biBpb3ZlY3MgLT5cbiAgICAgICAgICAgd3JpdGVfZnJhbWUgdC5lbmNvZGVyIGZyYW1lX2luZm8gfmxlbjpoZWFkZXJzX2Jsb2NrX2xlbiBpb3ZlY3M7XG4gICAgICAgICAgIGBPayBoZWFkZXJzX2Jsb2NrX2xlbikpO1xuICAgICAgbGV0IHJlYyBsb29wIHJlbWFpbmluZyA9XG4gICAgICAgIGlmIG1heF9mcmFtZV9wYXlsb2FkIDwgcmVtYWluaW5nXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgICgqIE5vdGU6IERvbid0IHJldXNlIGZsYWdzIGZyb20gZnJhbWUgaW5mbyBhcyBDT05USU5VQVRJT04gZnJhbWVzXG4gICAgICAgICAgICogb25seSBkZWZpbmUgRU5EX0hFQURFUlMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBGcm9tIFJGQzc1NDDCpzYuMTA6XG4gICAgICAgICAgICogICBUaGUgQ09OVElOVUFUSU9OIGZyYW1lIGRlZmluZXMgdGhlIGZvbGxvd2luZyBmbGFnOlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogICAgIEVORF9IRUFERVJTICgweDQpOiBXaGVuIHNldCwgYml0IDIgaW5kaWNhdGVzIHRoYXQgdGhpcyBmcmFtZVxuICAgICAgICAgICAqICAgICBlbmRzIGEgaGVhZGVyIGJsb2NrIChTZWN0aW9uIDQuMykuICopXG4gICAgICAgICAgbGV0IGZyYW1lX2luZm8gPSB7IGZyYW1lX2luZm8gd2l0aCBmbGFncyA9IEZsYWdzLmRlZmF1bHRfZmxhZ3MgfSBpblxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKEZhcmFkYXkuc2VyaWFsaXplIGZhcmFkYXkgKGZ1biBpb3ZlY3MgLT5cbiAgICAgICAgICAgICAgIHdyaXRlX2NvbnRpbnVhdGlvbl9mcmFtZVxuICAgICAgICAgICAgICAgICB0LmVuY29kZXJcbiAgICAgICAgICAgICAgICAgZnJhbWVfaW5mb1xuICAgICAgICAgICAgICAgICB+bGVuOm1heF9mcmFtZV9wYXlsb2FkXG4gICAgICAgICAgICAgICAgIGlvdmVjcztcbiAgICAgICAgICAgICAgIGBPayBtYXhfZnJhbWVfcGF5bG9hZCkpO1xuICAgICAgICAgIGxvb3AgKHJlbWFpbmluZyAtIG1heF9mcmFtZV9wYXlsb2FkKSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCBmcmFtZV9pbmZvID1cbiAgICAgICAgICAgIHsgZnJhbWVfaW5mbyB3aXRoIGZsYWdzID0gRmxhZ3MuKHNldF9lbmRfaGVhZGVyIGRlZmF1bHRfZmxhZ3MpIH1cbiAgICAgICAgICBpblxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKEZhcmFkYXkuc2VyaWFsaXplIGZhcmFkYXkgKGZ1biBpb3ZlY3MgLT5cbiAgICAgICAgICAgICAgIHdyaXRlX2NvbnRpbnVhdGlvbl9mcmFtZVxuICAgICAgICAgICAgICAgICB0LmVuY29kZXJcbiAgICAgICAgICAgICAgICAgZnJhbWVfaW5mb1xuICAgICAgICAgICAgICAgICB+bGVuOnJlbWFpbmluZ1xuICAgICAgICAgICAgICAgICBpb3ZlY3M7XG4gICAgICAgICAgICAgICBgT2sgcmVtYWluaW5nKSlcbiAgICAgIGluXG4gICAgICBsb29wIChibG9ja19zaXplIC0gaGVhZGVyc19ibG9ja19sZW4pKVxuICAgIGVsc2VcbiAgICAgIGxldCBmcmFtZV9pbmZvID1cbiAgICAgICAgeyBmcmFtZV9pbmZvIHdpdGggZmxhZ3MgPSBGbGFncy5zZXRfZW5kX2hlYWRlciBmcmFtZV9pbmZvLmZsYWdzIH1cbiAgICAgIGluXG4gICAgICBpZ25vcmVcbiAgICAgICAgKEZhcmFkYXkuc2VyaWFsaXplIGZhcmFkYXkgKGZ1biBpb3ZlY3MgLT5cbiAgICAgICAgICAgbGV0IGxlbiA9IElPVmVjLmxlbmd0aHYgaW92ZWNzIGluXG4gICAgICAgICAgIHdyaXRlX2ZyYW1lIHQuZW5jb2RlciBmcmFtZV9pbmZvIH5sZW4gaW92ZWNzO1xuICAgICAgICAgICBgT2sgbGVuKSlcblxuICBsZXQgZW5jb2RlX2hlYWRlcnMgaHBhY2tfZW5jb2RlciBmYXJhZGF5IGhlYWRlcnMgPVxuICAgIExpc3QuaXRlclxuICAgICAgKGZ1biBoZWFkZXIgLT4gSHBhY2suRW5jb2Rlci5lbmNvZGVfaGVhZGVyIGhwYWNrX2VuY29kZXIgZmFyYWRheSBoZWFkZXIpXG4gICAgICAoSGVhZGVycy50b19ocGFja19saXN0IGhlYWRlcnMpXG5cbiAgbGV0IHdyaXRlX3JlcXVlc3RfbGlrZV9mcmFtZSB0IGhwYWNrX2VuY29kZXIgfndyaXRlX2ZyYW1lIGZyYW1lX2luZm8gcmVxdWVzdCA9XG4gICAgbGV0IHsgUmVxdWVzdC5tZXRoOyB0YXJnZXQ7IHNjaGVtZTsgaGVhZGVycyB9ID0gcmVxdWVzdCBpblxuICAgIGxldCBmYXJhZGF5ID0gRmFyYWRheS5jcmVhdGUgMHgxMDAwIGluXG4gICAgSHBhY2suRW5jb2Rlci5lbmNvZGVfaGVhZGVyXG4gICAgICBocGFja19lbmNvZGVyXG4gICAgICBmYXJhZGF5XG4gICAgICB7IEhlYWRlcnMubmFtZSA9IFwiOm1ldGhvZFwiXG4gICAgICA7IHZhbHVlID0gSHR0cGFmLk1ldGhvZC50b19zdHJpbmcgbWV0aFxuICAgICAgOyBzZW5zaXRpdmUgPSBmYWxzZVxuICAgICAgfTtcbiAgICBpZiBtZXRoIDw+IGBDT05ORUNUXG4gICAgdGhlbiAoXG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzguMzpcbiAgICAgICAqICAgVGhlIDpzY2hlbWUgYW5kIDpwYXRoIHBzZXVkby1oZWFkZXIgZmllbGRzIE1VU1QgYmUgb21pdHRlZC4gKilcbiAgICAgIEhwYWNrLkVuY29kZXIuZW5jb2RlX2hlYWRlclxuICAgICAgICBocGFja19lbmNvZGVyXG4gICAgICAgIGZhcmFkYXlcbiAgICAgICAgeyBIZWFkZXJzLm5hbWUgPSBcIjpwYXRoXCI7IHZhbHVlID0gdGFyZ2V0OyBzZW5zaXRpdmUgPSBmYWxzZSB9O1xuICAgICAgSHBhY2suRW5jb2Rlci5lbmNvZGVfaGVhZGVyXG4gICAgICAgIGhwYWNrX2VuY29kZXJcbiAgICAgICAgZmFyYWRheVxuICAgICAgICB7IEhlYWRlcnMubmFtZSA9IFwiOnNjaGVtZVwiOyB2YWx1ZSA9IHNjaGVtZTsgc2Vuc2l0aXZlID0gZmFsc2UgfSk7XG4gICAgZW5jb2RlX2hlYWRlcnMgaHBhY2tfZW5jb2RlciBmYXJhZGF5IGhlYWRlcnM7XG4gICAgY2h1bmtfaGVhZGVyX2Jsb2NrX2ZyYWdtZW50cyB0IGZyYW1lX2luZm8gfndyaXRlX2ZyYW1lIGZhcmFkYXlcblxuICBsZXQgd3JpdGVfcmVxdWVzdF9oZWFkZXJzIHQgaHBhY2tfZW5jb2RlciB+cHJpb3JpdHkgZnJhbWVfaW5mbyByZXF1ZXN0ID1cbiAgICBpZiBub3QgKGlzX2Nsb3NlZCB0LmVuY29kZXIpXG4gICAgdGhlblxuICAgICAgbGV0IHdyaXRlX2ZyYW1lID0gd3JpdGVfaGVhZGVyc19mcmFtZSB+cHJpb3JpdHkgaW5cbiAgICAgIHdyaXRlX3JlcXVlc3RfbGlrZV9mcmFtZSB0IGhwYWNrX2VuY29kZXIgfndyaXRlX2ZyYW1lIGZyYW1lX2luZm8gcmVxdWVzdFxuXG4gIGxldCB3cml0ZV9wdXNoX3Byb21pc2UgdCBocGFja19lbmNvZGVyIGZyYW1lX2luZm8gfnByb21pc2VkX2lkIHJlcXVlc3QgPVxuICAgIGlmIG5vdCAoaXNfY2xvc2VkIHQuZW5jb2RlcilcbiAgICB0aGVuXG4gICAgICBsZXQgd3JpdGVfZnJhbWUgPSB3cml0ZV9wdXNoX3Byb21pc2VfZnJhbWUgfnByb21pc2VkX2lkIGluXG4gICAgICB3cml0ZV9yZXF1ZXN0X2xpa2VfZnJhbWUgdCBocGFja19lbmNvZGVyIH53cml0ZV9mcmFtZSBmcmFtZV9pbmZvIHJlcXVlc3RcblxuICBsZXQgd3JpdGVfcmVzcG9uc2VfaGVhZGVycyB0IGhwYWNrX2VuY29kZXIgZnJhbWVfaW5mbyByZXNwb25zZSA9XG4gICAgaWYgbm90IChpc19jbG9zZWQgdC5lbmNvZGVyKVxuICAgIHRoZW4gKFxuICAgICAgbGV0IHsgUmVzcG9uc2Uuc3RhdHVzOyBoZWFkZXJzOyBfIH0gPSByZXNwb25zZSBpblxuICAgICAgbGV0IGZhcmFkYXkgPSBGYXJhZGF5LmNyZWF0ZSAweDEwMDAgaW5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnOC4xLjIuNDpcbiAgICAgICAqICAgRm9yIEhUVFAvMiByZXNwb25zZXMsIGEgc2luZ2xlIDpzdGF0dXMgcHNldWRvLWhlYWRlciBmaWVsZCBpcyBkZWZpbmVkXG4gICAgICAgKiAgIHRoYXQgY2FycmllcyB0aGUgSFRUUCBzdGF0dXMgY29kZSBmaWVsZCAoc2VlIFtSRkM3MjMxXSwgU2VjdGlvbiA2KS5cbiAgICAgICAqICAgVGhpcyBwc2V1ZG8taGVhZGVyIGZpZWxkIE1VU1QgYmUgaW5jbHVkZWQgaW4gYWxsIHJlc3BvbnNlczsgb3RoZXJ3aXNlLFxuICAgICAgICogICB0aGUgcmVzcG9uc2UgaXMgbWFsZm9ybWVkIChTZWN0aW9uIDguMS4yLjYpLiAqKVxuICAgICAgSHBhY2suRW5jb2Rlci5lbmNvZGVfaGVhZGVyXG4gICAgICAgIGhwYWNrX2VuY29kZXJcbiAgICAgICAgZmFyYWRheVxuICAgICAgICB7IEhlYWRlcnMubmFtZSA9IFwiOnN0YXR1c1wiXG4gICAgICAgIDsgdmFsdWUgPSBTdGF0dXMudG9fc3RyaW5nIHN0YXR1c1xuICAgICAgICA7IHNlbnNpdGl2ZSA9IGZhbHNlXG4gICAgICAgIH07XG4gICAgICBlbmNvZGVfaGVhZGVycyBocGFja19lbmNvZGVyIGZhcmFkYXkgaGVhZGVycztcbiAgICAgIGNodW5rX2hlYWRlcl9ibG9ja19mcmFnbWVudHNcbiAgICAgICAgdFxuICAgICAgICBmcmFtZV9pbmZvXG4gICAgICAgIH53cml0ZV9mcmFtZTood3JpdGVfaGVhZGVyc19mcmFtZSB+cHJpb3JpdHk6UHJpb3JpdHkuZGVmYXVsdF9wcmlvcml0eSlcbiAgICAgICAgfmhhc19wcmlvcml0eTpmYWxzZVxuICAgICAgICBmYXJhZGF5KVxuXG4gIGxldCB3cml0ZV9yZXNwb25zZV90cmFpbGVycyB0IGhwYWNrX2VuY29kZXIgZnJhbWVfaW5mbyB0cmFpbGVycyA9XG4gICAgaWYgbm90IChpc19jbG9zZWQgdC5lbmNvZGVyKVxuICAgIHRoZW4gKFxuICAgICAgbGV0IGZhcmFkYXkgPSBGYXJhZGF5LmNyZWF0ZSAweDEwMDAgaW5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnOC4xOlxuICAgICAgICogIG9wdGlvbmFsbHksIG9uZSBIRUFERVJTIGZyYW1lLCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmVcbiAgICAgICAqICBDT05USU5VQVRJT04gZnJhbWVzIGNvbnRhaW5pbmcgdGhlIHRyYWlsZXItcGFydCwgaWYgcHJlc2VudCAoc2VlXG4gICAgICAgKiAgW1JGQzcyMzBdLCBTZWN0aW9uIDQuMS4yKS4gKilcbiAgICAgIGVuY29kZV9oZWFkZXJzIGhwYWNrX2VuY29kZXIgZmFyYWRheSB0cmFpbGVycztcbiAgICAgIGNodW5rX2hlYWRlcl9ibG9ja19mcmFnbWVudHNcbiAgICAgICAgdFxuICAgICAgICBmcmFtZV9pbmZvXG4gICAgICAgIH53cml0ZV9mcmFtZTood3JpdGVfaGVhZGVyc19mcmFtZSB+cHJpb3JpdHk6UHJpb3JpdHkuZGVmYXVsdF9wcmlvcml0eSlcbiAgICAgICAgfmhhc19wcmlvcml0eTpmYWxzZVxuICAgICAgICBmYXJhZGF5KVxuXG4gIGxldCB3cml0ZV9yc3Rfc3RyZWFtIHQgZnJhbWVfaW5mbyBlID1cbiAgICBpZiBub3QgKGlzX2Nsb3NlZCB0LmVuY29kZXIpXG4gICAgdGhlbiB3cml0ZV9yc3Rfc3RyZWFtX2ZyYW1lIHQuZW5jb2RlciBmcmFtZV9pbmZvIGVcblxuICBsZXQgd3JpdGVfd2luZG93X3VwZGF0ZSB0IGZyYW1lX2luZm8gbiA9XG4gICAgaWYgbm90IChpc19jbG9zZWQgdC5lbmNvZGVyKVxuICAgIHRoZW4gd3JpdGVfd2luZG93X3VwZGF0ZV9mcmFtZSB0LmVuY29kZXIgZnJhbWVfaW5mbyBuXG5cbiAgbGV0IHNjaGVkdWxlX2lvdmVjcyB0IH5sZW4gZnJhbWVfaW5mbyBpb3ZlY3MgPVxuICAgIGlmIG5vdCAoaXNfY2xvc2VkIHQuZW5jb2RlcilcbiAgICB0aGVuXG4gICAgICBsZXQgd3JpdGVyIHQgfmxlbiB+aW92ZWNzID0gYm91bmRlZF9zY2hlZHVsZV9pb3ZlY3MgdCB+bGVuIGlvdmVjcyBpblxuICAgICAgY2h1bmtfZGF0YV9mcmFtZXMgZnJhbWVfaW5mbyBsZW4gfmY6KGZ1biB+b2ZmIH5sZW4gZnJhbWVfaW5mbyAtPlxuICAgICAgICB3cml0ZV9mcmFtZV93aXRoX3BhZGRpbmdcbiAgICAgICAgICB0LmVuY29kZXJcbiAgICAgICAgICBmcmFtZV9pbmZvXG4gICAgICAgICAgRGF0YVxuICAgICAgICAgIGxlblxuICAgICAgICAgICh3cml0ZXIgfmlvdmVjczooSU9WZWMuc2hpZnR2IGlvdmVjcyBvZmYpIH5sZW4pKVxuXG4gIGxldCB3cml0ZV9wcmlvcml0eSB0IGZyYW1lX2luZm8gcHJpb3JpdHkgPVxuICAgIGlmIG5vdCAoaXNfY2xvc2VkIHQuZW5jb2RlcilcbiAgICB0aGVuIHdyaXRlX3ByaW9yaXR5X2ZyYW1lIHQuZW5jb2RlciBmcmFtZV9pbmZvIHByaW9yaXR5XG5cbiAgbGV0IHdyaXRlX3NldHRpbmdzIHQgZnJhbWVfaW5mbyBzZXR0aW5ncyA9XG4gICAgaWYgbm90IChpc19jbG9zZWQgdC5lbmNvZGVyKVxuICAgIHRoZW4gd3JpdGVfc2V0dGluZ3NfZnJhbWUgdC5lbmNvZGVyIGZyYW1lX2luZm8gc2V0dGluZ3NcblxuICBsZXQgd3JpdGVfcGluZyB0IGZyYW1lX2luZm8gP29mZiBwYXlsb2FkID1cbiAgICBpZiBub3QgKGlzX2Nsb3NlZCB0LmVuY29kZXIpXG4gICAgdGhlbiB3cml0ZV9waW5nX2ZyYW1lIHQuZW5jb2RlciBmcmFtZV9pbmZvID9vZmYgcGF5bG9hZFxuXG4gIGxldCB3cml0ZV9nb19hd2F5IHQgZnJhbWVfaW5mbyB+ZGVidWdfZGF0YSB+bGFzdF9zdHJlYW1faWQgZXJyb3IgPVxuICAgIGlmIG5vdCAoaXNfY2xvc2VkIHQuZW5jb2RlcilcbiAgICB0aGVuXG4gICAgICB3cml0ZV9nb19hd2F5X2ZyYW1lIHQuZW5jb2RlciBmcmFtZV9pbmZvIGxhc3Rfc3RyZWFtX2lkIGVycm9yIGRlYnVnX2RhdGFcblxuICBsZXQgb25fd2FrZXVwX3dyaXRlciB0IGsgPVxuICAgIGlmIEZhcmFkYXkuaXNfY2xvc2VkIHQuZW5jb2RlclxuICAgIHRoZW4gZmFpbHdpdGggXCJvbl93YWtldXBfd3JpdGVyIG9uIGNsb3NlZCBjb25uXCJcbiAgICBlbHNlIGlmIE9wdGlvbmFsX3RodW5rLmlzX3NvbWUgdC53YWtldXBcbiAgICB0aGVuIGZhaWx3aXRoIFwib25fd2FrZXVwOiBvbmx5IG9uZSBjYWxsYmFjayBjYW4gYmUgcmVnaXN0ZXJlZCBhdCBhIHRpbWVcIlxuICAgIGVsc2UgdC53YWtldXAgPC0gT3B0aW9uYWxfdGh1bmsuc29tZSBrXG5cbiAgbGV0IHdha2V1cCB0ID1cbiAgICBsZXQgZiA9IHQud2FrZXVwIGluXG4gICAgdC53YWtldXAgPC0gT3B0aW9uYWxfdGh1bmsubm9uZTtcbiAgICBPcHRpb25hbF90aHVuay5jYWxsX2lmX3NvbWUgZlxuXG4gIGxldCBmbHVzaCB0IGYgPSBmbHVzaCB0LmVuY29kZXIgZlxuXG4gIGxldCB1bnlpZWxkIHQgPVxuICAgICgqIEZhcmFkYXkgZG9lc24ndCBoYXZlIGEgZnVuY3Rpb24gdG8gdGFrZSB0aGUgc2VyaWFsaXplciBvdXQgb2YgYSB5aWVsZFxuICAgICAgIHN0YXRlLiBJbiB0aGUgbWVhbnRpbWUsIGBmbHVzaGAgZG9lcyBpdC4gKilcbiAgICBmbHVzaCB0IChmdW4gKCkgLT4gKCkpXG5cbiAgbGV0IHlpZWxkIHQgPSBGYXJhZGF5LnlpZWxkIHQuZW5jb2RlclxuICBsZXQgY2xvc2UgdCA9IEZhcmFkYXkuY2xvc2UgdC5lbmNvZGVyXG5cbiAgbGV0IGNsb3NlX2FuZF9kcmFpbiB0ID1cbiAgICBGYXJhZGF5LmNsb3NlIHQuZW5jb2RlcjtcbiAgICBsZXQgZHJhaW5lZCA9IEZhcmFkYXkuZHJhaW4gdC5lbmNvZGVyIGluXG4gICAgdC5kcmFpbmVkX2J5dGVzIDwtIHQuZHJhaW5lZF9ieXRlcyArIGRyYWluZWRcblxuICBsZXQgaXNfY2xvc2VkIHQgPSBGYXJhZGF5LmlzX2Nsb3NlZCB0LmVuY29kZXJcbiAgbGV0IGRyYWluZWRfYnl0ZXMgdCA9IHQuZHJhaW5lZF9ieXRlc1xuXG4gIGxldCByZXBvcnRfcmVzdWx0IHQgcmVzdWx0ID1cbiAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgIHwgYENsb3NlZCAtPiBjbG9zZV9hbmRfZHJhaW4gdFxuICAgIHwgYE9rIGxlbiAtPiBzaGlmdCB0LmVuY29kZXIgbGVuXG5cbiAgbGV0IG5leHQgdCA9XG4gICAgbWF0Y2ggRmFyYWRheS5vcGVyYXRpb24gdC5lbmNvZGVyIHdpdGhcbiAgICB8IGBDbG9zZSAtPiBgQ2xvc2UgKGRyYWluZWRfYnl0ZXMgdClcbiAgICB8IGBZaWVsZCAtPiBgWWllbGRcbiAgICB8IGBXcml0ZXYgaW92ZWNzIC0+IGBXcml0ZSBpb3ZlY3NcbmVuZFxuIiwiKCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE5IEFudMOzbmlvIE51bm8gTW9udGVpcm9cbiAqXG4gKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpc1xuICogIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiAqICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiAgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqICBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiAqICBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxubW9kdWxlIEhwYWNrID0gRHJlYW1faHBhY2suSHBhY2tcblxubW9kdWxlIEFCID0gQW5nc3Ryb20uQnVmZmVyZWRcbm1vZHVsZSBXcml0ZXIgPSBTZXJpYWxpemUuV3JpdGVyXG5cbnR5cGUgcGFydGlhbF9oZWFkZXJzID1cbiAgeyBtdXRhYmxlIHBhcnNlX3N0YXRlIDogKEhlYWRlcnMudCwgSHBhY2suZXJyb3IpIHJlc3VsdCBBQi5zdGF0ZVxuICA7IGVuZF9zdHJlYW0gOiBib29sXG4gIH1cblxudHlwZSAnYWN0aXZlX3BlZXIgcmVtb3RlX3N0YXRlID1cbiAgKCogQSBzdHJlYW0gaXMgaW4gdGhpcyBzdGF0ZSB3aGVuIGl0J3Mgd2FpdGluZyBmb3IgdGhlIHBlZXIgdG8gaW5pdGlhdGUgYVxuICAgKiByZXNwb25zZS4gSW4gcHJhY3RpY2UsIGl0IG9ubHkgbWF0dGVycyBmb3IgdGhlIGNsaWVudCBpbXBsZW1lbnRhdGlvbiwgd2hlblxuICAgKiBhIGNsaWVudCBoYXMgb3BlbmVkIGEgc3RyZWFtIGJ1dCBpcyBzdGlsbCB3YWl0aW5nIG9uIHRoZSBzZXJ2ZXIgdG8gc2VuZFxuICAgKiB0aGUgZmlyc3QgYnl0ZXMgb2YgdGhlIHJlc3BvbnNlLiAqKVxuICB8IFdhaXRpbmdGb3JQZWVyXG4gICgqIEEgUGFydGlhbEhlYWRlcnMgc3RhdGUgaXMgZW50ZXJlZCB3aGVuIHRoZSBlbmRwb2ludCBzZWVzIHRoZSBmaXJzdCBIRUFERVJTXG4gICAqIGZyYW1lIGZyb20gdGhlIHBlZXIgZm9yIGEgZ2l2ZW4gc3RyZWFtLiBJdHMgcGF5bG9hZCBpcyBhblxuICAgKiBBbmdzdHJvbS5CdWZmZXJlZCBwYXJzZSBzdGF0ZS4gKilcbiAgfCBQYXJ0aWFsSGVhZGVycyBvZiBwYXJ0aWFsX2hlYWRlcnNcbiAgKCogQSBzdHJlYW0gdHJhbnNpdGlvbnMgZnJvbSB0aGUgUGFydGlhbEhlYWRlcnMgc3RhdGUgdG8gdGhlIEZ1bGxIZWFkZXJzXG4gICAqIHN0YXRlIHdoZW4gdGhlIGVuZHBvaW50IGhhcyBmaW5pc2hlZCBwYXJzaW5nIGFsbCB0aGUgYnl0ZXMgaW4gYSBncm91cCBvZlxuICAgKiBIRUFERVIgLyBDT05USU5VQVRJT04gZnJhbWVzIHRoYXQgdGhlIHBlZXIgaGFzIHNlbnQuXG4gICAqIFRoaXMgc3RhdGUgZG9lc24ndCBjYXJyeSBhbnkgcGF5bG9hZCBiZWNhdXNlIHRoZSBzdHJlYW0gd2lsbCBpbW1lZGlhdGVseVxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBBY3RpdmVNZXNzYWdlIHN0YXRlIG9uY2UgdGhlIG1lc3NhZ2UgaGFzIGJlZW4gdmFsaWRhdGVkXG4gICAqIGFjY29yZGluZyB0byBSRkM3NTQwwqc4LjEuMi4gKilcbiAgfCBGdWxsSGVhZGVyc1xuICAoKiBUaGUgQWN0aXZlTWVzc2FnZSBzdGF0ZSBjYXJyaWVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHJlbW90ZVxuICAgKiBtZXNzYWdlIGJlaW5nIHByb2Nlc3NlZCBieSB0aGUgZW5kcG9pbnQuICopXG4gIHwgQWN0aXZlTWVzc2FnZSBvZiAnYWN0aXZlX3BlZXJcblxudHlwZSBjbG9zZWRfcmVhc29uID1cbiAgfCBGaW5pc2hlZFxuICAoKiBUT0RPOiB3ZSBjb3VsZCBhYmlkZSBieSB0aGUgZm9sbG93aW5nIGJ5IGVpdGhlciAxKSBoYXZpbmcgSS9PIHJ1bnRpbWVcbiAgICogc3VwcG9ydCBmb3IgdGltZXJzIG9yIDIpIGJ5IHNpbXBseSBjb3VudGluZyB0aGUgbnVtYmVyIG9mIGZyYW1lcyByZWNlaXZlZFxuICAgKiBhZnRlciB3ZSd2ZSBzZW50IGFuIFJTVF9TVFJFQU0/XG4gICAqXG4gICAqIEZyb20gUkZDNzU0MMKnNS40LjI6XG4gICAqICAgTm9ybWFsbHksIGFuIGVuZHBvaW50IFNIT1VMRCBOT1Qgc2VuZCBtb3JlIHRoYW4gb25lIFJTVF9TVFJFQU0gZnJhbWUgZm9yXG4gICAqICAgYW55IHN0cmVhbS4gSG93ZXZlciwgYW4gZW5kcG9pbnQgTUFZIHNlbmQgYWRkaXRpb25hbCBSU1RfU1RSRUFNIGZyYW1lc1xuICAgKiAgIGlmIGl0IHJlY2VpdmVzIGZyYW1lcyBvbiBhIGNsb3NlZCBzdHJlYW0gYWZ0ZXIgbW9yZSB0aGFuIGEgcm91bmQtdHJpcFxuICAgKiAgIHRpbWUuIFRoaXMgYmVoYXZpb3IgaXMgcGVybWl0dGVkIHRvIGRlYWwgd2l0aCBtaXNiZWhhdmluZ1xuICAgKiAgIGltcGxlbWVudGF0aW9ucy4gKilcbiAgfCBSZXNldEJ5VXMgb2YgRXJyb3JfY29kZS50XG4gICgqIFJlY2VpdmVkIGFuIFJTVF9TVFJFQU0gZnJhbWUgZnJvbSB0aGUgcGVlci4gKilcbiAgfCBSZXNldEJ5VGhlbSBvZiBFcnJvcl9jb2RlLnRcblxudHlwZSBjbG9zZWQgPVxuICB7IHJlYXNvbiA6IGNsb3NlZF9yZWFzb25cbiAgICAgICAgKCogV2hlbiBhIHN0cmVhbSBpcyBjbG9zZWQsIHdlIG1heSB3YW50IHRvIGtlZXAgaXQgYXJvdW5kIGluIHRoZSBoYXNoXG4gICAgICAgICAqIHRhYmxlIGZvciBhIHdoaWxlIChlLmcuIHRvIGtub3cgd2hldGhlciB0aGlzIHN0cmVhbSB3YXMgcmVzZXQgYnkgdGhlXG4gICAgICAgICAqIHBlZXIgLSBzb21lIGVycm9yIGhhbmRsaW5nIGNvZGUgZGVwZW5kcyBvbiB0aGF0KS4gV2Ugc3RhcnQgd2l0aCBhXG4gICAgICAgICAqIGRlZmF1bHQgdmFsdWUsIGFuZCBvbiBldmVyeSB3cml0ZXIgeWllbGQgd2UgZGVjcmVtZW50IGl0LiBJZiBpdFxuICAgICAgICAgKiByZWFjaGVzIDAsIHRoZSBzdHJlYW0gaXMgZmluYWxseSByZW1vdmVkIGZyb20gdGhlIGhhc2ggdGFibGUuICopXG4gIDsgbXV0YWJsZSB0dGwgOiBpbnRcbiAgfVxuXG50eXBlICgnb3BuLCAnaGFsZl9jbG9zZWQpIGFjdGl2ZV9zdGF0ZSA9XG4gIHwgT3BlbiBvZiAnb3BuIHJlbW90ZV9zdGF0ZVxuICB8IEhhbGZDbG9zZWQgb2YgJ2hhbGZfY2xvc2VkXG5cbnR5cGUgKCdhY3RpdmVfc3RhdGUsICdhY3RpdmUsICdyZXNlcnZlZCkgc3RhdGUgPVxuICB8IElkbGVcbiAgfCBSZXNlcnZlZCBvZiAncmVzZXJ2ZWRcbiAgfCBBY3RpdmUgb2YgJ2FjdGl2ZV9zdGF0ZSAqICdhY3RpdmVcbiAgfCBDbG9zZWQgb2YgY2xvc2VkXG4gIGNvbnN0cmFpbnQgJ2FjdGl2ZV9zdGF0ZSA9IChfLCBfKSBhY3RpdmVfc3RhdGVcblxudHlwZSAnYSBlcnJvcl9zdGF0dXMgPVxuICB8IE5vX2Vycm9yXG4gIHwgRXhuIG9mIGV4blxuICB8IE90aGVyIG9mXG4gICAgICB7IGVycm9yIDogJ2FcbiAgICAgIDsgY29kZSA6IEVycm9yX2NvZGUudFxuICAgICAgfVxuXG50eXBlICgnc3RhdGUsICdlcnJvciwgJ2Vycm9yX2hhbmRsZXIpIHQgPVxuICB7IGlkIDogU3RyZWFtX2lkZW50aWZpZXIudFxuICA7IHdyaXRlciA6IFNlcmlhbGl6ZS5Xcml0ZXIudFxuICA7IGVycm9yX2hhbmRsZXIgOiAnZXJyb3JfaGFuZGxlclxuICA7IG11dGFibGUgZXJyb3JfY29kZSA6ICdlcnJvciBlcnJvcl9zdGF0dXNcbiAgOyBtdXRhYmxlIHN0YXRlIDogJ3N0YXRlXG4gICAgICAgICgqIFRoZSBsYXJnZXN0IGZyYW1lIHBheWxvYWQgd2UncmUgYWxsb3dlZCB0byB3cml0ZS4gKilcbiAgOyBtdXRhYmxlIG1heF9mcmFtZV9zaXplIDogaW50XG4gIDsgb25fY2xvc2UgOiBhY3RpdmU6Ym9vbCAtPiBjbG9zZWQgLT4gdW5pdFxuICB9XG4gIGNvbnN0cmFpbnQgJ3N0YXRlID0gKF8sIF8sIF8pIHN0YXRlXG5cbmxldCBpbml0aWFsX3R0bCA9IDEwXG5cbmxldCBjcmVhdGUgaWQgfm1heF9mcmFtZV9zaXplIHdyaXRlciBlcnJvcl9oYW5kbGVyIG9uX2Nsb3NlID1cbiAgeyBpZFxuICA7IHdyaXRlclxuICA7IGVycm9yX2hhbmRsZXJcbiAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgKiAgIGlkbGU6IEFsbCBzdHJlYW1zIHN0YXJ0IGluIHRoZSBcImlkbGVcIiBzdGF0ZS4gKilcbiAgOyBzdGF0ZSA9IElkbGVcbiAgOyBlcnJvcl9jb2RlID0gTm9fZXJyb3JcbiAgOyBtYXhfZnJhbWVfc2l6ZVxuICA7IG9uX2Nsb3NlXG4gIH1cblxubGV0IGlkIHsgaWQ7IF8gfSA9IGlkXG5sZXQgaXNfaWRsZSB0ID0gbWF0Y2ggdC5zdGF0ZSB3aXRoIElkbGUgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcbmxldCBpc19vcGVuIHQgPSBtYXRjaCB0LnN0YXRlIHdpdGggQWN0aXZlIChPcGVuIF8sIF8pIC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbmxldCBmaW5pc2hfc3RyZWFtIHQgcmVhc29uID1cbiAgbGV0IGFjdGl2ZSA9IG1hdGNoIHQuc3RhdGUgd2l0aCBBY3RpdmUgXyAtPiB0cnVlIHwgXyAtPiBmYWxzZSBpblxuICBsZXQgY2xvc2VkID0geyByZWFzb247IHR0bCA9IGluaXRpYWxfdHRsIH0gaW5cbiAgdC5vbl9jbG9zZSB+YWN0aXZlIGNsb3NlZDtcbiAgdC5zdGF0ZSA8LSBDbG9zZWQgY2xvc2VkXG5cbmxldCBlcnJvcl9jb2RlIHQgPVxuICBtYXRjaCB0LmVycm9yX2NvZGUgd2l0aFxuICB8IEV4biBleG4gLT4gU29tZSAoYEV4biBleG4pXG4gIHwgT3RoZXIgeyBlcnJvcjsgXyB9IC0+IFNvbWUgZXJyb3JcbiAgfCBOb19lcnJvciAtPiBOb25lXG5cbmxldCBlcnJvcl90b19jb2RlIGVycm9yIGVycm9yX2NvZGUgPVxuICBtYXRjaCBlcnJvciB3aXRoXG4gIHwgYEV4biBleG4gLT4gRXhuIGV4blxuICB8IG90aGVyIC0+IE90aGVyIHsgZXJyb3IgPSBvdGhlcjsgY29kZSA9IGVycm9yX2NvZGUgfVxuXG5sZXQgcmVzZXRfc3RyZWFtIHQgZXJyb3JfY29kZSA9XG4gIGxldCBmcmFtZV9pbmZvID0gV3JpdGVyLm1ha2VfZnJhbWVfaW5mbyB0LmlkIGluXG4gIFdyaXRlci53cml0ZV9yc3Rfc3RyZWFtIHQud3JpdGVyIGZyYW1lX2luZm8gZXJyb3JfY29kZTtcbiAgZmluaXNoX3N0cmVhbSB0IChSZXNldEJ5VXMgZXJyb3JfY29kZSlcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE5IEFudG9uaW8gTi4gTW9udGVpcm8uXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogIGFyZSBtZXQ6XG4gKlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gKiAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gKiAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gKiAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gKiAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gKiAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICogIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICogIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG5tb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcblxubW9kdWxlIFJlYWRlciA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgZmFyYWRheSA6IEZhcmFkYXkudFxuICAgIDsgbXV0YWJsZSByZWFkX3NjaGVkdWxlZCA6IGJvb2xcbiAgICA7IG11dGFibGUgb25fZW9mIDogdW5pdCAtPiB1bml0XG4gICAgOyBtdXRhYmxlIG9uX3JlYWQgOiBCaWdzdHJpbmdhZi50IC0+IG9mZjppbnQgLT4gbGVuOmludCAtPiB1bml0XG4gICAgOyBidWZmZXJlZF9ieXRlcyA6IGludCByZWZcbiAgICA7IGRvbmVfcmVhZGluZyA6IGludCAtPiB1bml0XG4gICAgfVxuXG4gIGxldCBkZWZhdWx0X2RvbmVfcmVhZGluZyA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgKGZ1biBfIC0+ICgpKVxuICBsZXQgZGVmYXVsdF9vbl9lb2YgPSBTeXMub3BhcXVlX2lkZW50aXR5IChmdW4gKCkgLT4gKCkpXG4gIGxldCBkZWZhdWx0X29uX3JlYWQgPSBTeXMub3BhcXVlX2lkZW50aXR5IChmdW4gXyB+b2ZmOl8gfmxlbjpfIC0+ICgpKVxuXG4gIGxldCBjcmVhdGUgYnVmZmVyIH5kb25lX3JlYWRpbmcgPVxuICAgIHsgZmFyYWRheSA9IEZhcmFkYXkub2ZfYmlnc3RyaW5nIGJ1ZmZlclxuICAgIDsgcmVhZF9zY2hlZHVsZWQgPSBmYWxzZVxuICAgIDsgb25fZW9mID0gZGVmYXVsdF9vbl9lb2ZcbiAgICA7IG9uX3JlYWQgPSBkZWZhdWx0X29uX3JlYWRcbiAgICA7IGJ1ZmZlcmVkX2J5dGVzID0gcmVmIDBcbiAgICA7IGRvbmVfcmVhZGluZ1xuICAgIH1cblxuICBsZXQgY3JlYXRlX2VtcHR5ICgpID1cbiAgICBsZXQgdCA9IGNyZWF0ZSBCaWdzdHJpbmdhZi5lbXB0eSB+ZG9uZV9yZWFkaW5nOmRlZmF1bHRfZG9uZV9yZWFkaW5nIGluXG4gICAgRmFyYWRheS5jbG9zZSB0LmZhcmFkYXk7XG4gICAgdFxuXG4gIGxldCBlbXB0eSA9IGNyZWF0ZV9lbXB0eSAoKVxuICBsZXQgaXNfY2xvc2VkIHQgPSBGYXJhZGF5LmlzX2Nsb3NlZCB0LmZhcmFkYXlcbiAgbGV0IHVuc2FmZV9mYXJhZGF5IHQgPSB0LmZhcmFkYXlcblxuICBsZXQgcmVjIGRvX2V4ZWN1dGVfcmVhZCB0IG9uX2VvZiBvbl9yZWFkID1cbiAgICBtYXRjaCBGYXJhZGF5Lm9wZXJhdGlvbiB0LmZhcmFkYXkgd2l0aFxuICAgIHwgYFlpZWxkIC0+ICgpXG4gICAgfCBgQ2xvc2UgLT5cbiAgICAgIHQucmVhZF9zY2hlZHVsZWQgPC0gZmFsc2U7XG4gICAgICB0Lm9uX2VvZiA8LSBkZWZhdWx0X29uX2VvZjtcbiAgICAgIHQub25fcmVhZCA8LSBkZWZhdWx0X29uX3JlYWQ7XG4gICAgICBvbl9lb2YgKClcbiAgICB8IGBXcml0ZXYgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBgV3JpdGV2IChpb3ZlYyA6OiBfKSAtPlxuICAgICAgdC5yZWFkX3NjaGVkdWxlZCA8LSBmYWxzZTtcbiAgICAgIHQub25fZW9mIDwtIGRlZmF1bHRfb25fZW9mO1xuICAgICAgdC5vbl9yZWFkIDwtIGRlZmF1bHRfb25fcmVhZDtcbiAgICAgIGxldCB7IEh0dHBhZi5JT1ZlYy5idWZmZXI7IG9mZjsgbGVuIH0gPSBpb3ZlYyBpblxuICAgICAgRmFyYWRheS5zaGlmdCB0LmZhcmFkYXkgbGVuO1xuICAgICAgb25fcmVhZCBidWZmZXIgfm9mZiB+bGVuO1xuICAgICAgKCogQXBwbGljYXRpb24gaXMgZG9uZSByZWFkaW5nLCB3ZSBjYW4gZ2l2ZSBmbG93IGNvbnRyb2wgdG9rZW5zIGJhY2sgdG9cbiAgICAgICAgIHRoZSBwZWVyLiAqKVxuICAgICAgdC5kb25lX3JlYWRpbmcgbGVuO1xuICAgICAgZXhlY3V0ZV9yZWFkIHRcblxuICBhbmQgZXhlY3V0ZV9yZWFkIHQgPVxuICAgIGlmIHQucmVhZF9zY2hlZHVsZWQgdGhlbiBkb19leGVjdXRlX3JlYWQgdCB0Lm9uX2VvZiB0Lm9uX3JlYWRcblxuICBsZXQgc2NoZWR1bGVfcmVhZCB0IH5vbl9lb2Ygfm9uX3JlYWQgPVxuICAgIGlmIHQucmVhZF9zY2hlZHVsZWRcbiAgICB0aGVuIGZhaWx3aXRoIFwiQm9keS5zY2hlZHVsZV9yZWFkOiByZWFkZXIgYWxyZWFkeSBzY2hlZHVsZWRcIjtcbiAgICBpZiBpc19jbG9zZWQgdFxuICAgIHRoZW4gZG9fZXhlY3V0ZV9yZWFkIHQgb25fZW9mIG9uX3JlYWRcbiAgICBlbHNlIChcbiAgICAgIHQucmVhZF9zY2hlZHVsZWQgPC0gdHJ1ZTtcbiAgICAgIHQub25fZW9mIDwtIG9uX2VvZjtcbiAgICAgIHQub25fcmVhZCA8LSBvbl9yZWFkKVxuXG4gIGxldCBjbG9zZSB0ID1cbiAgICBGYXJhZGF5LmNsb3NlIHQuZmFyYWRheTtcbiAgICBleGVjdXRlX3JlYWQgdFxuXG4gIGxldCBoYXNfcGVuZGluZ19vdXRwdXQgdCA9IEZhcmFkYXkuaGFzX3BlbmRpbmdfb3V0cHV0IHQuZmFyYWRheVxuZW5kXG5cbm1vZHVsZSBXcml0ZXIgPSBzdHJ1Y3RcbiAgbW9kdWxlIFdyaXRlciA9IFNlcmlhbGl6ZS5Xcml0ZXJcblxuICB0eXBlIHQgPVxuICAgIHsgZmFyYWRheSA6IEZhcmFkYXkudFxuICAgIDsgYnVmZmVyZWRfYnl0ZXMgOiBpbnQgcmVmXG4gICAgOyB3cml0ZXIgOiBTZXJpYWxpemUuV3JpdGVyLnRcbiAgICB9XG5cbiAgbGV0IGNyZWF0ZSBidWZmZXIgfndyaXRlciA9XG4gICAgeyBmYXJhZGF5ID0gRmFyYWRheS5vZl9iaWdzdHJpbmcgYnVmZmVyOyBidWZmZXJlZF9ieXRlcyA9IHJlZiAwOyB3cml0ZXIgfVxuXG4gIGxldCBjcmVhdGVfZW1wdHkgfndyaXRlciA9XG4gICAgbGV0IHQgPSBjcmVhdGUgQmlnc3RyaW5nYWYuZW1wdHkgfndyaXRlciBpblxuICAgIEZhcmFkYXkuY2xvc2UgdC5mYXJhZGF5O1xuICAgIHRcblxuICBsZXQgcmVhZHlfdG9fd3JpdGUgdCA9IFNlcmlhbGl6ZS5Xcml0ZXIud2FrZXVwIHQud3JpdGVyXG5cbiAgbGV0IHdyaXRlX2NoYXIgdCBjID1cbiAgICBGYXJhZGF5LndyaXRlX2NoYXIgdC5mYXJhZGF5IGM7XG4gICAgcmVhZHlfdG9fd3JpdGUgdFxuXG4gIGxldCB3cml0ZV9zdHJpbmcgdCA/b2ZmID9sZW4gcyA9XG4gICAgRmFyYWRheS53cml0ZV9zdHJpbmcgP29mZiA/bGVuIHQuZmFyYWRheSBzO1xuICAgIHJlYWR5X3RvX3dyaXRlIHRcblxuICBsZXQgd3JpdGVfYmlnc3RyaW5nIHQgP29mZiA/bGVuIGIgPVxuICAgIEZhcmFkYXkud3JpdGVfYmlnc3RyaW5nID9vZmYgP2xlbiB0LmZhcmFkYXkgYjtcbiAgICByZWFkeV90b193cml0ZSB0XG5cbiAgbGV0IHNjaGVkdWxlX2JpZ3N0cmluZyB0ID9vZmYgP2xlbiAoYiA6IEJpZ3N0cmluZ2FmLnQpID1cbiAgICBGYXJhZGF5LnNjaGVkdWxlX2JpZ3N0cmluZyA/b2ZmID9sZW4gdC5mYXJhZGF5IGI7XG4gICAgcmVhZHlfdG9fd3JpdGUgdFxuXG4gIGxldCBmbHVzaCB0IGtvbnRpbnVlID1cbiAgICBGYXJhZGF5LmZsdXNoIHQuZmFyYWRheSBrb250aW51ZTtcbiAgICByZWFkeV90b193cml0ZSB0XG5cbiAgbGV0IGlzX2Nsb3NlZCB0ID0gRmFyYWRheS5pc19jbG9zZWQgdC5mYXJhZGF5XG4gIGxldCBoYXNfcGVuZGluZ19vdXRwdXQgdCA9IEZhcmFkYXkuaGFzX3BlbmRpbmdfb3V0cHV0IHQuZmFyYWRheVxuXG4gIGxldCBjbG9zZSB0ID1cbiAgICBTZXJpYWxpemUuV3JpdGVyLnVueWllbGQgdC53cml0ZXI7XG4gICAgRmFyYWRheS5jbG9zZSB0LmZhcmFkYXk7XG4gICAgcmVhZHlfdG9fd3JpdGUgdFxuXG4gIGxldCB1bnNhZmVfZmFyYWRheSB0ID0gdC5mYXJhZGF5XG5cbiAgbGV0IHRyYW5zZmVyX3RvX3dyaXRlciB0IHdyaXRlciB+bWF4X2ZyYW1lX3NpemUgfm1heF9ieXRlcyBzdHJlYW1faWQgPVxuICAgIGxldCBmYXJhZGF5ID0gdC5mYXJhZGF5IGluXG4gICAgbWF0Y2ggRmFyYWRheS5vcGVyYXRpb24gZmFyYWRheSB3aXRoXG4gICAgfCBgWWllbGQgfCBgQ2xvc2UgLT4gMFxuICAgIHwgYFdyaXRldiBpb3ZlY3MgLT5cbiAgICAgIGxldCBidWZmZXJlZCA9IHQuYnVmZmVyZWRfYnl0ZXMgaW5cbiAgICAgIGxldCBpb3ZlY3MgPSBIdHRwYWYuSU9WZWMuc2hpZnR2IGlvdmVjcyAhYnVmZmVyZWQgaW5cbiAgICAgIGxldCBsZW5ndGh2ID0gSHR0cGFmLklPVmVjLmxlbmd0aHYgaW92ZWNzIGluXG4gICAgICBsZXQgd3JpdGV2X2xlbiA9IGlmIG1heF9ieXRlcyA8IGxlbmd0aHYgdGhlbiBtYXhfYnl0ZXMgZWxzZSBsZW5ndGh2IGluXG4gICAgICBidWZmZXJlZCA6PSAhYnVmZmVyZWQgKyB3cml0ZXZfbGVuO1xuICAgICAgbGV0IGZyYW1lX2luZm8gPSBXcml0ZXIubWFrZV9mcmFtZV9pbmZvIH5tYXhfZnJhbWVfc2l6ZSBzdHJlYW1faWQgaW5cbiAgICAgIFdyaXRlci5zY2hlZHVsZV9pb3ZlY3Mgd3JpdGVyIGZyYW1lX2luZm8gfmxlbjp3cml0ZXZfbGVuIGlvdmVjcztcbiAgICAgIFdyaXRlci5mbHVzaCB3cml0ZXIgKGZ1biAoKSAtPlxuICAgICAgICBGYXJhZGF5LnNoaWZ0IGZhcmFkYXkgd3JpdGV2X2xlbjtcbiAgICAgICAgYnVmZmVyZWQgOj0gIWJ1ZmZlcmVkIC0gd3JpdGV2X2xlbik7XG4gICAgICB3cml0ZXZfbGVuXG5lbmRcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE5IEFudG9uaW8gTi4gTW9udGVpcm8uXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogIGFyZSBtZXQ6XG4gKlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gKiAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gKiAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gKiAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gKiAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gKiAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICogIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICogIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG5vcGVuIEFuZ3N0cm9tXG5cbigqIFdlIHVzZSB0aGUgdGFpbC1yZWN1cnNpdmUgdmFyaWFudCBvZiBgc2tpcF9tYW55YCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaW5oYWJpdGVkdHlwZS9hbmdzdHJvbS9wdWxsLzIxOSB0byBhdm9pZCBtZW1vcnkgbGVha3MgaW5cbiAqIGxvbmctcnVubmluZyBjb25uZWN0aW9ucy4gVGhlIG9yaWdpbmFsIGBza2lwX21hbnlgIGNhbiBidWlsZCB1cCBhIGxpc3Qgb2ZcbiAqIGVycm9yIGhhbmRsZXJzIHRoYXQgbWF5IG5ldmVyIGJlIHJlbGVhc2VkLiAqKVxubGV0IHNraXBfbWFueSBwID1cbiAgZml4IChmdW4gbSAtPlxuICAgIHAgPj58IChmdW4gXyAtPiB0cnVlKSA8fD4gcmV0dXJuIGZhbHNlID4+PSBmdW5jdGlvblxuICAgIHwgdHJ1ZSAtPiBtXG4gICAgfCBmYWxzZSAtPiByZXR1cm4gKCkpXG5cbmxldCBkZWZhdWx0X2ZyYW1lX2hlYWRlciA9XG4gIHsgRnJhbWUucGF5bG9hZF9sZW5ndGggPSAwXG4gIDsgZmxhZ3MgPSBGbGFncy5kZWZhdWx0X2ZsYWdzXG4gIDsgc3RyZWFtX2lkID0gLTFsXG4gIDsgZnJhbWVfdHlwZSA9IFVua25vd24gKC0xKVxuICB9XG5cbnR5cGUgcGFyc2VfY29udGV4dCA9XG4gIHsgbXV0YWJsZSBmcmFtZV9oZWFkZXIgOiBGcmFtZS5mcmFtZV9oZWFkZXJcbiAgOyBtdXRhYmxlIHJlbWFpbmluZ19ieXRlc190b19za2lwIDogaW50XG4gIDsgbXV0YWJsZSBkaWRfcmVwb3J0X3N0cmVhbV9lcnJvciA6IGJvb2xcbiAgOyAoKiBUT0RPOiBUaGlzIHNob3VsZCBjaGFuZ2UgYXMgbmV3IHNldHRpbmdzIGZyYW1lcyBhcnJpdmUsIGJ1dCB3ZSBkb24ndCB5ZXRcbiAgICAgKiByZXNpemUgdGhlIHJlYWQgYnVmZmVyLiAqKVxuICAgIG1heF9mcmFtZV9zaXplIDogaW50XG4gIH1cblxubGV0IGNvbm5lY3Rpb25fZXJyb3IgZXJyb3JfY29kZSBtc2cgPVxuICBFcnJvciBFcnJvci4oQ29ubmVjdGlvbkVycm9yIChlcnJvcl9jb2RlLCBtc2cpKVxuXG5sZXQgc3RyZWFtX2Vycm9yIGVycm9yX2NvZGUgc3RyZWFtX2lkID1cbiAgRXJyb3IgRXJyb3IuKFN0cmVhbUVycm9yIChzdHJlYW1faWQsIGVycm9yX2NvZGUpKVxuXG5sZXQgcGFyc2VfdWludDI0IG8xIG8yIG8zID0gKG8xIGxzbCAxNikgbG9yIChvMiBsc2wgOCkgbG9yIG8zXG5cbmxldCBmcmFtZV9sZW5ndGggPVxuICAoKiBGcm9tIFJGQzc1NDDCpzQuMTpcbiAgICogICBMZW5ndGg6IFRoZSBsZW5ndGggb2YgdGhlIGZyYW1lIHBheWxvYWQgZXhwcmVzc2VkIGFzIGFuIHVuc2lnbmVkIDI0LWJpdFxuICAgKiAgIGludGVnZXIuICopXG4gIGxpZnQzIHBhcnNlX3VpbnQyNCBhbnlfdWludDggYW55X3VpbnQ4IGFueV91aW50OFxuXG5sZXQgZnJhbWVfdHlwZSA9XG4gICgqIEZyb20gUkZDNzU0MMKnNC4xOlxuICAgKiAgIFR5cGU6IFRoZSA4LWJpdCB0eXBlIG9mIHRoZSBmcmFtZS4gVGhlIGZyYW1lIHR5cGUgZGV0ZXJtaW5lcyB0aGUgZm9ybWF0XG4gICAqICAgYW5kIHNlbWFudGljcyBvZiB0aGUgZnJhbWUuIEltcGxlbWVudGF0aW9ucyBNVVNUIGlnbm9yZSBhbmQgZGlzY2FyZCBhbnlcbiAgICogICBmcmFtZSB0aGF0IGhhcyBhIHR5cGUgdGhhdCBpcyB1bmtub3duLiAqKVxuICBsaWZ0IEZyYW1lLkZyYW1lVHlwZS5wYXJzZSBhbnlfdWludDhcblxubGV0IGZsYWdzID1cbiAgKCogRnJvbSBSRkM3NTQwwqc0LjE6XG4gICAqICAgRmxhZ3M6IEFuIDgtYml0IGZpZWxkIHJlc2VydmVkIGZvciBib29sZWFuIGZsYWdzIHNwZWNpZmljIHRvIHRoZSBmcmFtZVxuICAgKiAgIHR5cGUuICopXG4gIGFueV91aW50OFxuXG5sZXQgcGFyc2Vfc3RyZWFtX2lkZW50aWZpZXIgbiA9XG4gICgqIEZyb20gUkZDNzU0MMKnNC4xOlxuICAgKiAgIFN0cmVhbSBJZGVudGlmaWVyOiBBIHN0cmVhbSBpZGVudGlmaWVyIChzZWUgU2VjdGlvbiA1LjEuMSkgZXhwcmVzc2VkIGFzXG4gICAqICAgYW4gdW5zaWduZWQgMzEtYml0IGludGVnZXIuIFRoZSB2YWx1ZSAweDAgaXMgcmVzZXJ2ZWQgZm9yIGZyYW1lcyB0aGF0XG4gICAqICAgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29ubmVjdGlvbiBhcyBhIHdob2xlIGFzIG9wcG9zZWQgdG8gYW5cbiAgICogICBpbmRpdmlkdWFsIHN0cmVhbS4gKilcbiAgSW50MzIuKGxvZ2FuZCBuIChzdWIgKHNoaWZ0X2xlZnQgMWwgMzEpIDFsKSlcblxubGV0IHN0cmVhbV9pZGVudGlmaWVyID0gbGlmdCBwYXJzZV9zdHJlYW1faWRlbnRpZmllciBCRS5hbnlfaW50MzJcblxubGV0IHBhcnNlX2ZyYW1lX2hlYWRlciA9XG4gIGxpZnQ0XG4gICAgKGZ1biBwYXlsb2FkX2xlbmd0aCBmcmFtZV90eXBlIGZsYWdzIHN0cmVhbV9pZCAtPlxuICAgICAgIHsgRnJhbWUuZmxhZ3M7IHBheWxvYWRfbGVuZ3RoOyBzdHJlYW1faWQ7IGZyYW1lX3R5cGUgfSlcbiAgICBmcmFtZV9sZW5ndGhcbiAgICBmcmFtZV90eXBlXG4gICAgZmxhZ3NcbiAgICBzdHJlYW1faWRlbnRpZmllclxuICA8Pz4gXCJmcmFtZV9oZWFkZXJcIlxuICAoKiBUaGUgcGFyc2VyIGNvbW1pdHMgYWZ0ZXIgcGFyc2luZyB0aGUgZnJhbWUgaGVhZGVyIHNvIHRoYXQgdGhlIGVudGlyZVxuICAgKiB1bmRlcmx5aW5nIGJ1ZmZlciBjYW4gYmUgdXNlZCB0byBzdG9yZSB0aGUgcGF5bG9hZCBsZW5ndGguIFRoaXMgbWF0dGVyc1xuICAgKiBiZWNhdXNlIHRoZSBzaXplIG9mIHRoZSBidWZmZXIgdGhhdCBnZXRzIGFsbG9jYXRlZCBpcyB0aGUgbWF4aW11bSBmcmFtZVxuICAgKiBwYXlsb2FkIG5lZ290aWF0ZWQgYnkgdGhlIEhUVFAvMiBzZXR0aW5ncyBzeW5jaHJvbml6YXRpb24uIFRoZSA5IG9jdGV0c1xuICAgKiB0aGF0IG1ha2UgdXAgdGhlIGZyYW1lIGhlYWRlciBhcmUsIHRoZXJlZm9yZSwgdmVyeSBpbXBvcnRhbnQgaW4gb3JkZXIgZm9yXG4gICAqIGgyIG5vdCB0byByZXR1cm4gYSBGUkFNRV9TSVpFX0VSUk9SLiAqKVxuICA8KiBjb21taXRcblxubGV0IHBhcnNlX3BhZGRlZF9wYXlsb2FkIHsgRnJhbWUucGF5bG9hZF9sZW5ndGg7IGZsYWdzOyBfIH0gcGFyc2VyID1cbiAgaWYgRmxhZ3MudGVzdF9wYWRkZWQgZmxhZ3NcbiAgdGhlblxuICAgIGFueV91aW50OCA+Pj0gZnVuIHBhZF9sZW5ndGggLT5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuMTpcbiAgICAgKiAgIFBhZCBMZW5ndGg6IEFuIDgtYml0IGZpZWxkIGNvbnRhaW5pbmcgdGhlIGxlbmd0aCBvZiB0aGUgZnJhbWVcbiAgICAgKiAgIHBhZGRpbmcgaW4gdW5pdHMgb2Ygb2N0ZXRzLlxuICAgICAqXG4gICAgICogICBEYXRhOiBBcHBsaWNhdGlvbiBkYXRhLiBUaGUgYW1vdW50IG9mIGRhdGEgaXMgdGhlIHJlbWFpbmRlciBvZiB0aGVcbiAgICAgKiAgIGZyYW1lIHBheWxvYWQgYWZ0ZXIgc3VidHJhY3RpbmcgdGhlIGxlbmd0aCBvZiB0aGUgb3RoZXIgZmllbGRzIHRoYXRcbiAgICAgKiAgIGFyZSBwcmVzZW50LlxuICAgICAqXG4gICAgICogICBQYWRkaW5nOiBQYWRkaW5nIG9jdGV0cyB0aGF0IGNvbnRhaW4gbm8gYXBwbGljYXRpb24gc2VtYW50aWNcbiAgICAgKiAgIHZhbHVlLiAqKVxuICAgIGlmIHBhZF9sZW5ndGggPj0gcGF5bG9hZF9sZW5ndGhcbiAgICB0aGVuXG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuMTpcbiAgICAgICAqICAgSWYgdGhlIGxlbmd0aCBvZiB0aGUgcGFkZGluZyBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBmcmFtZSBwYXlsb2FkIG9yXG4gICAgICAgKiAgIGdyZWF0ZXIsIHRoZSByZWNpcGllbnQgTVVTVCB0cmVhdCB0aGlzIGFzIGEgY29ubmVjdGlvbiBlcnJvclxuICAgICAgICogICAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICAgIGFkdmFuY2UgKHBheWxvYWRfbGVuZ3RoIC0gMSkgPj58IGZ1biAoKSAtPlxuICAgICAgY29ubmVjdGlvbl9lcnJvciBQcm90b2NvbEVycm9yIFwiUGFkZGluZyBzaXplIGV4Y2VlZHMgcGF5bG9hZCBzaXplXCJcbiAgICBlbHNlXG4gICAgICAoKiBTdWJ0cmFjdCB0aGUgb2N0ZXQgdGhhdCBjb250YWlucyB0aGUgbGVuZ3RoIG9mIHBhZGRpbmcsIGFuZCB0aGVcbiAgICAgICAqIHBhZGRpbmcgb2N0ZXRzLiAqKVxuICAgICAgbGV0IHJlbGV2YW50X2xlbmd0aCA9IHBheWxvYWRfbGVuZ3RoIC0gMSAtIHBhZF9sZW5ndGggaW5cbiAgICAgIHBhcnNlciByZWxldmFudF9sZW5ndGggPCogYWR2YW5jZSBwYWRfbGVuZ3RoXG4gIGVsc2UgcGFyc2VyIHBheWxvYWRfbGVuZ3RoXG5cbmxldCBwYXJzZV9kYXRhX2ZyYW1lICh7IEZyYW1lLnN0cmVhbV9pZDsgcGF5bG9hZF9sZW5ndGg7IF8gfSBhcyBmcmFtZV9oZWFkZXIpID1cbiAgaWYgU3RyZWFtX2lkZW50aWZpZXIuaXNfY29ubmVjdGlvbiBzdHJlYW1faWRcbiAgdGhlblxuICAgICgqIEZyb20gUkZDNzU0MMKnNi4xOlxuICAgICAqICAgREFUQSBmcmFtZXMgTVVTVCBiZSBhc3NvY2lhdGVkIHdpdGggYSBzdHJlYW0uIElmIGEgREFUQSBmcmFtZSBpc1xuICAgICAqICAgcmVjZWl2ZWQgd2hvc2Ugc3RyZWFtIGlkZW50aWZpZXIgZmllbGQgaXMgMHgwLCB0aGUgcmVjaXBpZW50IE1VU1RcbiAgICAgKiAgIHJlc3BvbmQgd2l0aCBhIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGVcbiAgICAgKiAgIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgIGFkdmFuY2UgcGF5bG9hZF9sZW5ndGggPj58IGZ1biAoKSAtPlxuICAgIGNvbm5lY3Rpb25fZXJyb3JcbiAgICAgIFByb3RvY29sRXJyb3JcbiAgICAgIFwiRGF0YSBmcmFtZXMgbXVzdCBiZSBhc3NvY2lhdGVkIHdpdGggYSBzdHJlYW1cIlxuICBlbHNlXG4gICAgbGV0IHBhcnNlX2RhdGEgbGVuZ3RoID1cbiAgICAgIGxpZnQgKGZ1biBicyAtPiBPayAoRnJhbWUuRGF0YSBicykpICh0YWtlX2JpZ3N0cmluZyBsZW5ndGgpXG4gICAgaW5cbiAgICBwYXJzZV9wYWRkZWRfcGF5bG9hZCBmcmFtZV9oZWFkZXIgcGFyc2VfZGF0YVxuXG5sZXQgcGFyc2VfcHJpb3JpdHkgPVxuICBsaWZ0MlxuICAgIChmdW4gc3RyZWFtX2RlcGVuZGVuY3kgd2VpZ2h0IC0+XG4gICAgICAgbGV0IGUgPSBQcmlvcml0eS50ZXN0X2V4Y2x1c2l2ZSBzdHJlYW1fZGVwZW5kZW5jeSBpblxuICAgICAgIHsgUHJpb3JpdHkuZXhjbHVzaXZlID1cbiAgICAgICAgICAgZVxuICAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuMzpcbiAgICAgICAgICAgICogICBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyIHJlcHJlc2VudGluZyBhIHByaW9yaXR5IHdlaWdodCBmb3IgdGhlXG4gICAgICAgICAgICAqICAgc3RyZWFtIChzZWUgU2VjdGlvbiA1LjMpLiBBZGQgb25lIHRvIHRoZSB2YWx1ZSB0byBvYnRhaW4gYVxuICAgICAgICAgICAgKiAgIHdlaWdodCBiZXR3ZWVuIDEgYW5kIDI1Ni4gKilcbiAgICAgICA7IHdlaWdodCA9IHdlaWdodCArIDFcbiAgICAgICA7IHN0cmVhbV9kZXBlbmRlbmN5ID0gcGFyc2Vfc3RyZWFtX2lkZW50aWZpZXIgc3RyZWFtX2RlcGVuZGVuY3lcbiAgICAgICB9KVxuICAgIEJFLmFueV9pbnQzMlxuICAgIGFueV91aW50OFxuXG5sZXQgcGFyc2VfaGVhZGVyc19mcmFtZSBmcmFtZV9oZWFkZXIgPVxuICBsZXQgeyBGcmFtZS5wYXlsb2FkX2xlbmd0aDsgc3RyZWFtX2lkOyBmbGFnczsgXyB9ID0gZnJhbWVfaGVhZGVyIGluXG4gIGlmIFN0cmVhbV9pZGVudGlmaWVyLmlzX2Nvbm5lY3Rpb24gc3RyZWFtX2lkXG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuMjpcbiAgICAgKiAgIEhFQURFUlMgZnJhbWVzIE1VU1QgYmUgYXNzb2NpYXRlZCB3aXRoIGEgc3RyZWFtLiBJZiBhIEhFQURFUlMgZnJhbWUgaXNcbiAgICAgKiAgIHJlY2VpdmVkIHdob3NlIHN0cmVhbSBpZGVudGlmaWVyIGZpZWxkIGlzIDB4MCwgdGhlIHJlY2lwaWVudCBNVVNUXG4gICAgICogICByZXNwb25kIHdpdGggYSBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlXG4gICAgICogICBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICBhZHZhbmNlIHBheWxvYWRfbGVuZ3RoID4+fCBmdW4gKCkgLT5cbiAgICBjb25uZWN0aW9uX2Vycm9yIFByb3RvY29sRXJyb3IgXCJIRUFERVJTIG11c3QgYmUgYXNzb2NpYXRlZCB3aXRoIGEgc3RyZWFtXCJcbiAgZWxzZVxuICAgIGxldCBwYXJzZV9oZWFkZXJzIGxlbmd0aCA9XG4gICAgICBpZiBGbGFncy50ZXN0X3ByaW9yaXR5IGZsYWdzXG4gICAgICB0aGVuXG4gICAgICAgIGxpZnQyXG4gICAgICAgICAgKGZ1biBwcmlvcml0eSBoZWFkZXJzIC0+IE9rIChGcmFtZS5IZWFkZXJzIChwcmlvcml0eSwgaGVhZGVycykpKVxuICAgICAgICAgIHBhcnNlX3ByaW9yaXR5XG4gICAgICAgICAgKCogU2VlIFJGQzc1NDDCpzYuMzpcbiAgICAgICAgICAgKiAgIFN0cmVhbSBEZXBlbmRlbmN5ICg0IG9jdGV0cykgKyBXZWlnaHQgKDEgb2N0ZXQpLiAqKVxuICAgICAgICAgICh0YWtlX2JpZ3N0cmluZyAobGVuZ3RoIC0gNSkpXG4gICAgICBlbHNlXG4gICAgICAgIGxpZnRcbiAgICAgICAgICAoZnVuIGhlYWRlcnNfYmxvY2sgLT5cbiAgICAgICAgICAgICBPayAoRnJhbWUuSGVhZGVycyAoUHJpb3JpdHkuZGVmYXVsdF9wcmlvcml0eSwgaGVhZGVyc19ibG9jaykpKVxuICAgICAgICAgICh0YWtlX2JpZ3N0cmluZyBsZW5ndGgpXG4gICAgaW5cbiAgICBwYXJzZV9wYWRkZWRfcGF5bG9hZCBmcmFtZV9oZWFkZXIgcGFyc2VfaGVhZGVyc1xuXG5sZXQgcGFyc2VfcHJpb3JpdHlfZnJhbWUgeyBGcmFtZS5wYXlsb2FkX2xlbmd0aDsgc3RyZWFtX2lkOyBfIH0gPVxuICBpZiBTdHJlYW1faWRlbnRpZmllci5pc19jb25uZWN0aW9uIHN0cmVhbV9pZFxuICB0aGVuXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2LjM6XG4gICAgICogICBUaGUgUFJJT1JJVFkgZnJhbWUgYWx3YXlzIGlkZW50aWZpZXMgYSBzdHJlYW0uIElmIGEgUFJJT1JJVFkgZnJhbWUgaXNcbiAgICAgKiAgIHJlY2VpdmVkIHdpdGggYSBzdHJlYW0gaWRlbnRpZmllciBvZiAweDAsIHRoZSByZWNpcGllbnQgTVVTVCByZXNwb25kXG4gICAgICogICB3aXRoIGEgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICBhZHZhbmNlIHBheWxvYWRfbGVuZ3RoID4+fCBmdW4gKCkgLT5cbiAgICBjb25uZWN0aW9uX2Vycm9yIFByb3RvY29sRXJyb3IgXCJQUklPUklUWSBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBhIHN0cmVhbVwiXG4gIGVsc2UgaWYgcGF5bG9hZF9sZW5ndGggPD4gNVxuICB0aGVuXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2LjM6XG4gICAgICogICBBIFBSSU9SSVRZIGZyYW1lIHdpdGggYSBsZW5ndGggb3RoZXIgdGhhbiA1IG9jdGV0cyBNVVNUIGJlIHRyZWF0ZWQgYXNcbiAgICAgKiAgIGEgc3RyZWFtIGVycm9yIChTZWN0aW9uIDUuNC4yKSBvZiB0eXBlIEZSQU1FX1NJWkVfRVJST1IuICopXG4gICAgYWR2YW5jZSBwYXlsb2FkX2xlbmd0aCA+PnwgZnVuICgpIC0+IHN0cmVhbV9lcnJvciBGcmFtZVNpemVFcnJvciBzdHJlYW1faWRcbiAgZWxzZSBsaWZ0IChmdW4gcHJpb3JpdHkgLT4gT2sgKEZyYW1lLlByaW9yaXR5IHByaW9yaXR5KSkgcGFyc2VfcHJpb3JpdHlcblxubGV0IHBhcnNlX2Vycm9yX2NvZGUgPSBsaWZ0IEVycm9yX2NvZGUucGFyc2UgQkUuYW55X2ludDMyXG5cbmxldCBwYXJzZV9yc3Rfc3RyZWFtX2ZyYW1lIHsgRnJhbWUucGF5bG9hZF9sZW5ndGg7IHN0cmVhbV9pZDsgXyB9ID1cbiAgaWYgU3RyZWFtX2lkZW50aWZpZXIuaXNfY29ubmVjdGlvbiBzdHJlYW1faWRcbiAgdGhlblxuICAgICgqIEZyb20gUkZDNzU0MMKnNi40OlxuICAgICAqICAgUlNUX1NUUkVBTSBmcmFtZXMgTVVTVCBiZSBhc3NvY2lhdGVkIHdpdGggYSBzdHJlYW0uIElmIGEgUlNUX1NUUkVBTVxuICAgICAqICAgZnJhbWUgaXMgcmVjZWl2ZWQgd2l0aCBhIHN0cmVhbSBpZGVudGlmaWVyIG9mIDB4MCwgdGhlIHJlY2lwaWVudCBNVVNUXG4gICAgICogICB0cmVhdCB0aGlzIGFzIGEgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZVxuICAgICAqICAgUFJPVE9DT0xfRVJST1IuICopXG4gICAgYWR2YW5jZSBwYXlsb2FkX2xlbmd0aCA+PnwgZnVuICgpIC0+XG4gICAgY29ubmVjdGlvbl9lcnJvciBQcm90b2NvbEVycm9yIFwiUlNUX1NUUkVBTSBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBhIHN0cmVhbVwiXG4gIGVsc2UgaWYgcGF5bG9hZF9sZW5ndGggPD4gNFxuICB0aGVuXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2LjQ6XG4gICAgICogICBBIFJTVF9TVFJFQU0gZnJhbWUgd2l0aCBhIGxlbmd0aCBvdGhlciB0aGFuIDQgb2N0ZXRzIE1VU1QgYmUgdHJlYXRlZFxuICAgICAqICAgYXMgYSBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlIEZSQU1FX1NJWkVfRVJST1IuICopXG4gICAgYWR2YW5jZSBwYXlsb2FkX2xlbmd0aCA+PnwgZnVuICgpIC0+XG4gICAgY29ubmVjdGlvbl9lcnJvclxuICAgICAgRnJhbWVTaXplRXJyb3JcbiAgICAgIFwiUlNUX1NUUkVBTSBwYXlsb2FkIG11c3QgYmUgNCBvY3RldHMgaW4gbGVuZ3RoXCJcbiAgZWxzZSBsaWZ0IChmdW4gZXJyb3JfY29kZSAtPiBPayAoRnJhbWUuUlNUU3RyZWFtIGVycm9yX2NvZGUpKSBwYXJzZV9lcnJvcl9jb2RlXG5cbmxldCBwYXJzZV9zZXR0aW5nc19mcmFtZSB7IEZyYW1lLnBheWxvYWRfbGVuZ3RoOyBzdHJlYW1faWQ7IGZsYWdzOyBfIH0gPVxuICBpZiBub3QgKFN0cmVhbV9pZGVudGlmaWVyLmlzX2Nvbm5lY3Rpb24gc3RyZWFtX2lkKVxuICB0aGVuXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2LjU6XG4gICAgICogICBJZiBhbiBlbmRwb2ludCByZWNlaXZlcyBhIFNFVFRJTkdTIGZyYW1lIHdob3NlIHN0cmVhbSBpZGVudGlmaWVyIGZpZWxkXG4gICAgICogICBpcyBhbnl0aGluZyBvdGhlciB0aGFuIDB4MCwgdGhlIGVuZHBvaW50IE1VU1QgcmVzcG9uZCB3aXRoIGFcbiAgICAgKiAgIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgYWR2YW5jZSBwYXlsb2FkX2xlbmd0aCA+PnwgZnVuICgpIC0+XG4gICAgY29ubmVjdGlvbl9lcnJvclxuICAgICAgUHJvdG9jb2xFcnJvclxuICAgICAgXCJTRVRUSU5HUyBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBzdHJlYW0gaWQgMHgwXCJcbiAgZWxzZSBpZiBwYXlsb2FkX2xlbmd0aCBtb2QgNiA8PiAwXG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNTpcbiAgICAgKiAgIEEgU0VUVElOR1MgZnJhbWUgd2l0aCBhIGxlbmd0aCBvdGhlciB0aGFuIGEgbXVsdGlwbGUgb2YgNiBvY3RldHMgTVVTVFxuICAgICAqICAgYmUgdHJlYXRlZCBhcyBhIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGVcbiAgICAgKiAgIEZSQU1FX1NJWkVfRVJST1IuICopXG4gICAgYWR2YW5jZSBwYXlsb2FkX2xlbmd0aCA+PnwgZnVuICgpIC0+XG4gICAgY29ubmVjdGlvbl9lcnJvclxuICAgICAgRnJhbWVTaXplRXJyb3JcbiAgICAgIFwiU0VUVElOR1MgcGF5bG9hZCBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2XCJcbiAgZWxzZSBpZiBGbGFncy50ZXN0X2FjayBmbGFncyAmJiBwYXlsb2FkX2xlbmd0aCA8PiAwXG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNTpcbiAgICAgKiAgIFJlY2VpcHQgb2YgYSBTRVRUSU5HUyBmcmFtZSB3aXRoIHRoZSBBQ0sgZmxhZyBzZXQgYW5kIGEgbGVuZ3RoIGZpZWxkXG4gICAgICogICB2YWx1ZSBvdGhlciB0aGFuIDAgTVVTVCBiZSB0cmVhdGVkIGFzIGEgY29ubmVjdGlvbiBlcnJvclxuICAgICAqICAgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgRlJBTUVfU0laRV9FUlJPUi4gKilcbiAgICBhZHZhbmNlIHBheWxvYWRfbGVuZ3RoID4+fCBmdW4gKCkgLT5cbiAgICBjb25uZWN0aW9uX2Vycm9yIEZyYW1lU2l6ZUVycm9yIFwiU0VUVElOR1Mgd2l0aCBBQ0sgbXVzdCBiZSBlbXB0eVwiXG4gIGVsc2VcbiAgICBsZXQgbnVtX3NldHRpbmdzID0gcGF5bG9hZF9sZW5ndGggLyBTZXR0aW5ncy5vY3RldHNfcGVyX3NldHRpbmcgaW5cbiAgICBTZXR0aW5ncy5wYXJzZV9zZXR0aW5nc19wYXlsb2FkIG51bV9zZXR0aW5ncyA+PnwgZnVuIHhzIC0+XG4gICAgT2sgKEZyYW1lLlNldHRpbmdzIHhzKVxuXG5sZXQgcGFyc2VfcHVzaF9wcm9taXNlX2ZyYW1lIGZyYW1lX2hlYWRlciA9XG4gIGxldCB7IEZyYW1lLnBheWxvYWRfbGVuZ3RoOyBzdHJlYW1faWQ7IF8gfSA9IGZyYW1lX2hlYWRlciBpblxuICBpZiBTdHJlYW1faWRlbnRpZmllci5pc19jb25uZWN0aW9uIHN0cmVhbV9pZFxuICB0aGVuXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2LjY6XG4gICAgICogICBUaGUgc3RyZWFtIGlkZW50aWZpZXIgb2YgYSBQVVNIX1BST01JU0UgZnJhbWUgaW5kaWNhdGVzIHRoZVxuICAgICAqICAgc3RyZWFtIGl0IGlzIGFzc29jaWF0ZWQgd2l0aC4gSWYgdGhlIHN0cmVhbSBpZGVudGlmaWVyIGZpZWxkXG4gICAgICogICBzcGVjaWZpZXMgdGhlIHZhbHVlIDB4MCwgYSByZWNpcGllbnQgTVVTVCByZXNwb25kIHdpdGggYVxuICAgICAqICAgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICBhZHZhbmNlIHBheWxvYWRfbGVuZ3RoID4+fCBmdW4gKCkgLT5cbiAgICBjb25uZWN0aW9uX2Vycm9yIFByb3RvY29sRXJyb3IgXCJQVVNIIG11c3QgYmUgYXNzb2NpYXRlZCB3aXRoIGEgc3RyZWFtXCJcbiAgZWxzZVxuICAgIGxldCBwYXJzZV9wdXNoX3Byb21pc2UgbGVuZ3RoID1cbiAgICAgIGxpZnQyXG4gICAgICAgIChmdW4gcHJvbWlzZWRfc3RyZWFtX2lkIGZyYWdtZW50IC0+XG4gICAgICAgICAgIGlmIFN0cmVhbV9pZGVudGlmaWVyLmlzX2Nvbm5lY3Rpb24gcHJvbWlzZWRfc3RyZWFtX2lkXG4gICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNjpcbiAgICAgICAgICAgICAgKiAgIEEgcmVjZWl2ZXIgTVVTVCB0cmVhdCB0aGUgcmVjZWlwdCBvZiBhIFBVU0hfUFJPTUlTRSB0aGF0XG4gICAgICAgICAgICAgICogICBwcm9taXNlcyBhbiBpbGxlZ2FsIHN0cmVhbSBpZGVudGlmaWVyIChTZWN0aW9uIDUuMS4xKSBhcyBhXG4gICAgICAgICAgICAgICogICBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgICAgICAgICAgIGNvbm5lY3Rpb25fZXJyb3JcbiAgICAgICAgICAgICAgIFByb3RvY29sRXJyb3JcbiAgICAgICAgICAgICAgIFwiUFVTSCBtdXN0IG5vdCBwcm9taXNlIHN0cmVhbSBpZCAweDBcIlxuICAgICAgICAgICBlbHNlIGlmIFN0cmVhbV9pZGVudGlmaWVyLmlzX3JlcXVlc3QgcHJvbWlzZWRfc3RyZWFtX2lkXG4gICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNjpcbiAgICAgICAgICAgICAgKiAgIEEgcmVjZWl2ZXIgTVVTVCB0cmVhdCB0aGUgcmVjZWlwdCBvZiBhIFBVU0hfUFJPTUlTRSB0aGF0XG4gICAgICAgICAgICAgICogICBwcm9taXNlcyBhbiBpbGxlZ2FsIHN0cmVhbSBpZGVudGlmaWVyIChTZWN0aW9uIDUuMS4xKSBhcyBhXG4gICAgICAgICAgICAgICogICBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlIFBST1RPQ09MX0VSUk9SLlxuICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICogTm90ZTogQW4gb2RkLW51bWJlcmVkIHN0cmVhbSBpcyBhbiBpbnZhbGlkIHN0cmVhbSBpZGVudGlmaWVyIGZvclxuICAgICAgICAgICAgICAqIHRoZSBzZXJ2ZXIsIGFuZCBvbmx5IHRoZSBzZXJ2ZXIgY2FuIHNlbmQgUFVTSF9QUk9NSVNFIGZyYW1lczpcbiAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAqIEZyb20gUkZDNzU0MMKnOC4yLjE6XG4gICAgICAgICAgICAgICogICBQVVNIX1BST01JU0UgZnJhbWVzIE1VU1QgTk9UIGJlIHNlbnQgYnkgdGhlIGNsaWVudC4gKilcbiAgICAgICAgICAgICBjb25uZWN0aW9uX2Vycm9yXG4gICAgICAgICAgICAgICBQcm90b2NvbEVycm9yXG4gICAgICAgICAgICAgICBcIlBVU0ggbXVzdCBiZSBhc3NvY2lhdGVkIHdpdGggYW4gZXZlbi1udW1iZXJlZCBzdHJlYW0gaWRcIlxuICAgICAgICAgICBlbHNlIE9rIEZyYW1lLihQdXNoUHJvbWlzZSAocHJvbWlzZWRfc3RyZWFtX2lkLCBmcmFnbWVudCkpKVxuICAgICAgICBzdHJlYW1faWRlbnRpZmllclxuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNjpcbiAgICAgICAgICogICBUaGUgUFVTSF9QUk9NSVNFIGZyYW1lIGluY2x1ZGVzIHRoZSB1bnNpZ25lZCAzMS1iaXQgaWRlbnRpZmllciBvZlxuICAgICAgICAgKiAgIHRoZSBzdHJlYW0gdGhlIGVuZHBvaW50IHBsYW5zIHRvIGNyZWF0ZSBhbG9uZyB3aXRoIGEgc2V0IG9mXG4gICAgICAgICAqICAgaGVhZGVycyB0aGF0IHByb3ZpZGUgYWRkaXRpb25hbCBjb250ZXh0IGZvciB0aGUgc3RyZWFtLiAqKVxuICAgICAgICAodGFrZV9iaWdzdHJpbmcgKGxlbmd0aCAtIDQpKVxuICAgIGluXG4gICAgcGFyc2VfcGFkZGVkX3BheWxvYWQgZnJhbWVfaGVhZGVyIHBhcnNlX3B1c2hfcHJvbWlzZVxuXG5sZXQgcGFyc2VfcGluZ19mcmFtZSB7IEZyYW1lLnBheWxvYWRfbGVuZ3RoOyBzdHJlYW1faWQ7IF8gfSA9XG4gIGlmIG5vdCAoU3RyZWFtX2lkZW50aWZpZXIuaXNfY29ubmVjdGlvbiBzdHJlYW1faWQpXG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNzpcbiAgICAgKiAgIFBJTkcgZnJhbWVzIGFyZSBub3QgYXNzb2NpYXRlZCB3aXRoIGFueSBpbmRpdmlkdWFsIHN0cmVhbS4gSWYgYSBQSU5HXG4gICAgICogICBmcmFtZSBpcyByZWNlaXZlZCB3aXRoIGEgc3RyZWFtIGlkZW50aWZpZXIgZmllbGQgdmFsdWUgb3RoZXIgdGhhblxuICAgICAqICAgMHgwLCB0aGUgcmVjaXBpZW50IE1VU1QgcmVzcG9uZCB3aXRoIGEgY29ubmVjdGlvbiBlcnJvclxuICAgICAqICAgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgYWR2YW5jZSBwYXlsb2FkX2xlbmd0aCA+PnwgZnVuICgpIC0+XG4gICAgY29ubmVjdGlvbl9lcnJvciBQcm90b2NvbEVycm9yIFwiUElORyBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBzdHJlYW0gaWQgMHgwXCJcbiAgZWxzZSBpZiBwYXlsb2FkX2xlbmd0aCA8PiA4XG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNzpcbiAgICAgKiAgIFJlY2VpcHQgb2YgYSBQSU5HIGZyYW1lIHdpdGggYSBsZW5ndGggZmllbGQgdmFsdWUgb3RoZXIgdGhhbiA4IE1VU1RcbiAgICAgKiAgIGJlIHRyZWF0ZWQgYXMgYSBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlXG4gICAgICogICBGUkFNRV9TSVpFX0VSUk9SLiAqKVxuICAgIGFkdmFuY2UgcGF5bG9hZF9sZW5ndGggPj58IGZ1biAoKSAtPlxuICAgIGNvbm5lY3Rpb25fZXJyb3IgRnJhbWVTaXplRXJyb3IgXCJQSU5HIHBheWxvYWQgbXVzdCBiZSA4IG9jdGV0cyBpbiBsZW5ndGhcIlxuICBlbHNlIGxpZnQgKGZ1biBicyAtPiBPayAoRnJhbWUuUGluZyBicykpICh0YWtlX2JpZ3N0cmluZyBwYXlsb2FkX2xlbmd0aClcblxubGV0IHBhcnNlX2dvX2F3YXlfZnJhbWUgeyBGcmFtZS5wYXlsb2FkX2xlbmd0aDsgc3RyZWFtX2lkOyBfIH0gPVxuICBpZiBub3QgKFN0cmVhbV9pZGVudGlmaWVyLmlzX2Nvbm5lY3Rpb24gc3RyZWFtX2lkKVxuICB0aGVuXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2Ljg6XG4gICAgICogICBUaGUgR09BV0FZIGZyYW1lIGFwcGxpZXMgdG8gdGhlIGNvbm5lY3Rpb24sIG5vdCBhIHNwZWNpZmljIHN0cmVhbS4gQW5cbiAgICAgKiAgIGVuZHBvaW50IE1VU1QgdHJlYXQgYSBHT0FXQVkgZnJhbWUgd2l0aCBhIHN0cmVhbSBpZGVudGlmaWVyIG90aGVyIHRoYW5cbiAgICAgKiAgIDB4MCBhcyBhIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgYWR2YW5jZSBwYXlsb2FkX2xlbmd0aCA+PnwgZnVuICgpIC0+XG4gICAgY29ubmVjdGlvbl9lcnJvclxuICAgICAgUHJvdG9jb2xFcnJvclxuICAgICAgXCJHT0FXQVkgbXVzdCBiZSBhc3NvY2lhdGVkIHdpdGggc3RyZWFtIGlkIDB4MFwiXG4gIGVsc2VcbiAgICBsaWZ0M1xuICAgICAgKGZ1biBsYXN0X3N0cmVhbV9pZCBlcnIgZGVidWdfZGF0YSAtPlxuICAgICAgICAgT2sgKEZyYW1lLkdvQXdheSAobGFzdF9zdHJlYW1faWQsIGVyciwgZGVidWdfZGF0YSkpKVxuICAgICAgc3RyZWFtX2lkZW50aWZpZXJcbiAgICAgIHBhcnNlX2Vycm9yX2NvZGVcbiAgICAgICh0YWtlX2JpZ3N0cmluZyAocGF5bG9hZF9sZW5ndGggLSA4KSlcblxubGV0IHBhcnNlX3dpbmRvd191cGRhdGVfZnJhbWUgeyBGcmFtZS5zdHJlYW1faWQ7IHBheWxvYWRfbGVuZ3RoOyBfIH0gPVxuICAoKiBGcm9tIFJGQzc1NDDCpzYuOTpcbiAgICogICBBIFdJTkRPV19VUERBVEUgZnJhbWUgd2l0aCBhIGxlbmd0aCBvdGhlciB0aGFuIDQgb2N0ZXRzIE1VU1QgYmUgdHJlYXRlZFxuICAgKiAgIGFzIGEgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZSBGUkFNRV9TSVpFX0VSUk9SLiAqKVxuICBpZiBwYXlsb2FkX2xlbmd0aCA8PiA0XG4gIHRoZW5cbiAgICBhZHZhbmNlIHBheWxvYWRfbGVuZ3RoID4+fCBmdW4gKCkgLT5cbiAgICBjb25uZWN0aW9uX2Vycm9yXG4gICAgICBGcmFtZVNpemVFcnJvclxuICAgICAgXCJXSU5ET1dfVVBEQVRFIHBheWxvYWQgbXVzdCBiZSA0IG9jdGV0cyBpbiBsZW5ndGhcIlxuICBlbHNlXG4gICAgbGlmdFxuICAgICAgKGZ1biB1aW50IC0+XG4gICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuOTpcbiAgICAgICAgICAqICAgVGhlIGZyYW1lIHBheWxvYWQgb2YgYSBXSU5ET1dfVVBEQVRFIGZyYW1lIGlzIG9uZSByZXNlcnZlZCBiaXRcbiAgICAgICAgICAqICAgcGx1cyBhbiB1bnNpZ25lZCAzMS1iaXQgaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2Ygb2N0ZXRzXG4gICAgICAgICAgKiAgIHRoYXQgdGhlIHNlbmRlciBjYW4gdHJhbnNtaXQgaW4gYWRkaXRpb24gdG8gdGhlIGV4aXN0aW5nXG4gICAgICAgICAgKiAgIGZsb3ctY29udHJvbCB3aW5kb3cuICopXG4gICAgICAgICBsZXQgd2luZG93X3NpemVfaW5jcmVtZW50ID0gVXRpbC5jbGVhcl9iaXRfaW50MzIgdWludCAzMSBpblxuICAgICAgICAgaWYgSW50MzIuZXF1YWwgd2luZG93X3NpemVfaW5jcmVtZW50IDBsXG4gICAgICAgICB0aGVuXG4gICAgICAgICAgIGlmICgqIEZyb20gUkZDNzU0MMKnNi45OlxuICAgICAgICAgICAgICAgKiAgIEEgcmVjZWl2ZXIgTVVTVCB0cmVhdCB0aGUgcmVjZWlwdCBvZiBhIFdJTkRPV19VUERBVEUgZnJhbWVcbiAgICAgICAgICAgICAgICogICB3aXRoIGFuIGZsb3ctY29udHJvbCB3aW5kb3cgaW5jcmVtZW50IG9mIDAgYXMgYSBzdHJlYW0gZXJyb3JcbiAgICAgICAgICAgICAgICogICAoU2VjdGlvbiA1LjQuMikgb2YgdHlwZSBQUk9UT0NPTF9FUlJPUjsgZXJyb3JzIG9uIHRoZVxuICAgICAgICAgICAgICAgKiAgIGNvbm5lY3Rpb24gZmxvdy1jb250cm9sIHdpbmRvdyBNVVNUIGJlIHRyZWF0ZWQgYXMgYSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAqICAgZXJyb3IgKFNlY3Rpb24gNS40LjEpLiAqKVxuICAgICAgICAgICAgICBTdHJlYW1faWRlbnRpZmllci5pc19jb25uZWN0aW9uIHN0cmVhbV9pZFxuICAgICAgICAgICB0aGVuIGNvbm5lY3Rpb25fZXJyb3IgUHJvdG9jb2xFcnJvciBcIldpbmRvdyB1cGRhdGUgbXVzdCBub3QgYmUgMFwiXG4gICAgICAgICAgIGVsc2Ugc3RyZWFtX2Vycm9yIFByb3RvY29sRXJyb3Igc3RyZWFtX2lkXG4gICAgICAgICBlbHNlIE9rIChGcmFtZS5XaW5kb3dVcGRhdGUgd2luZG93X3NpemVfaW5jcmVtZW50KSlcbiAgICAgIEJFLmFueV9pbnQzMlxuXG5sZXQgcGFyc2VfY29udGludWF0aW9uX2ZyYW1lIHsgRnJhbWUucGF5bG9hZF9sZW5ndGg7IHN0cmVhbV9pZDsgXyB9ID1cbiAgaWYgU3RyZWFtX2lkZW50aWZpZXIuaXNfY29ubmVjdGlvbiBzdHJlYW1faWRcbiAgdGhlblxuICAgICgqIEZyb20gUkZDNzU0MMKnNi4xMDpcbiAgICAgKiAgIENPTlRJTlVBVElPTiBmcmFtZXMgTVVTVCBiZSBhc3NvY2lhdGVkIHdpdGggYSBzdHJlYW0uIElmIGFcbiAgICAgKiAgIENPTlRJTlVBVElPTiBmcmFtZSBpcyByZWNlaXZlZCB3aG9zZSBzdHJlYW0gaWRlbnRpZmllciBmaWVsZCBpcyAweDAsXG4gICAgICogICB0aGUgcmVjaXBpZW50IE1VU1QgcmVzcG9uZCB3aXRoIGEgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvbiA1LjQuMSkgb2ZcbiAgICAgKiAgIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgYWR2YW5jZSBwYXlsb2FkX2xlbmd0aCA+PnwgZnVuICgpIC0+XG4gICAgY29ubmVjdGlvbl9lcnJvclxuICAgICAgUHJvdG9jb2xFcnJvclxuICAgICAgXCJDT05USU5VQVRJT04gbXVzdCBiZSBhc3NvY2lhdGVkIHdpdGggYSBzdHJlYW1cIlxuICBlbHNlXG4gICAgbGlmdFxuICAgICAgKGZ1biBibG9ja19mcmFnbWVudCAtPiBPayAoRnJhbWUuQ29udGludWF0aW9uIGJsb2NrX2ZyYWdtZW50KSlcbiAgICAgICh0YWtlX2JpZ3N0cmluZyBwYXlsb2FkX2xlbmd0aClcblxubGV0IHBhcnNlX3Vua25vd25fZnJhbWUgdHlwIHsgRnJhbWUucGF5bG9hZF9sZW5ndGg7IF8gfSA9XG4gIGxpZnRcbiAgICAoZnVuIGJpZ3N0cmluZyAtPiBPayAoRnJhbWUuVW5rbm93biAodHlwLCBiaWdzdHJpbmcpKSlcbiAgICAodGFrZV9iaWdzdHJpbmcgcGF5bG9hZF9sZW5ndGgpXG5cbmxldCBwYXJzZV9mcmFtZV9wYXlsb2FkICh7IEZyYW1lLmZyYW1lX3R5cGU7IF8gfSBhcyBmcmFtZV9oZWFkZXIpID1cbiAgKG1hdGNoIGZyYW1lX3R5cGUgd2l0aFxuICAgIHwgRnJhbWUuRnJhbWVUeXBlLkRhdGEgLT4gcGFyc2VfZGF0YV9mcmFtZSBmcmFtZV9oZWFkZXJcbiAgICB8IEhlYWRlcnMgLT4gcGFyc2VfaGVhZGVyc19mcmFtZSBmcmFtZV9oZWFkZXJcbiAgICB8IFByaW9yaXR5IC0+IHBhcnNlX3ByaW9yaXR5X2ZyYW1lIGZyYW1lX2hlYWRlclxuICAgIHwgUlNUU3RyZWFtIC0+IHBhcnNlX3JzdF9zdHJlYW1fZnJhbWUgZnJhbWVfaGVhZGVyXG4gICAgfCBTZXR0aW5ncyAtPiBwYXJzZV9zZXR0aW5nc19mcmFtZSBmcmFtZV9oZWFkZXJcbiAgICB8IFB1c2hQcm9taXNlIC0+IHBhcnNlX3B1c2hfcHJvbWlzZV9mcmFtZSBmcmFtZV9oZWFkZXJcbiAgICB8IFBpbmcgLT4gcGFyc2VfcGluZ19mcmFtZSBmcmFtZV9oZWFkZXJcbiAgICB8IEdvQXdheSAtPiBwYXJzZV9nb19hd2F5X2ZyYW1lIGZyYW1lX2hlYWRlclxuICAgIHwgV2luZG93VXBkYXRlIC0+IHBhcnNlX3dpbmRvd191cGRhdGVfZnJhbWUgZnJhbWVfaGVhZGVyXG4gICAgfCBDb250aW51YXRpb24gLT4gcGFyc2VfY29udGludWF0aW9uX2ZyYW1lIGZyYW1lX2hlYWRlclxuICAgIHwgVW5rbm93biB0eXAgLT4gcGFyc2VfdW5rbm93bl9mcmFtZSB0eXAgZnJhbWVfaGVhZGVyKVxuICA8Pz4gXCJmcmFtZV9wYXlsb2FkXCJcblxubGV0IHBhcnNlX2ZyYW1lIHBhcnNlX2NvbnRleHQgPVxuICBwYXJzZV9mcmFtZV9oZWFkZXIgPj49IGZ1biAoeyBGcmFtZS5wYXlsb2FkX2xlbmd0aDsgXyB9IGFzIGZyYW1lX2hlYWRlcikgLT5cbiAgKCogSWYgd2UncmUgcGFyc2luZyBhIG5ldyBmcmFtZSwgd2UgZGlkbid0IHlldCBzZW5kIGEgc3RyZWFtIGVycm9yIG9uIGl0ICopXG4gIHBhcnNlX2NvbnRleHQuZGlkX3JlcG9ydF9zdHJlYW1fZXJyb3IgPC0gZmFsc2U7XG4gIHBhcnNlX2NvbnRleHQuZnJhbWVfaGVhZGVyIDwtIGZyYW1lX2hlYWRlcjtcbiAgKCogaDIgZG9lcyB1bmJ1ZmZlcmVkIHBhcnNpbmcgYW5kIHRoZSBiaWdhcnJheSB3ZSByZWFkIGlucHV0IGZyb20gaXNcbiAgICogYWxsb2NhdGVkIGJhc2VkIG9uIHRoZSBtYXhpbXVtIGZyYW1lIHBheWxvYWQgbmVnb3RpYXRlZCBieSBIVFRQLzJcbiAgICogY29tbXVuaWNhdGlvbi4gSWYgdGhlIHVuZGVybHlpbmcgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB3aGF0XG4gICAqIHRoZSBmcmFtZSBjYW4gZml0LCB3ZSB3YW50IHRvIHNraXAgdGhlIHJlbWFpbmluZyBpbnB1dCBhbmQgc2tpcCB0byB0aGVcbiAgICogbmV4dCBmcmFtZS5cbiAgICpcbiAgICogRnJvbSBSRkM3NTQwwqc1LjQuMjpcbiAgICogICBBIHN0cmVhbSBlcnJvciBpcyBhbiBlcnJvciByZWxhdGVkIHRvIGEgc3BlY2lmaWMgc3RyZWFtIHRoYXQgZG9lc1xuICAgKiAgIG5vdCBhZmZlY3QgcHJvY2Vzc2luZyBvZiBvdGhlciBzdHJlYW1zLiAqKVxuICBsZXQgaXNfZnJhbWVfc2l6ZV9lcnJvciA9IHBheWxvYWRfbGVuZ3RoID4gcGFyc2VfY29udGV4dC5tYXhfZnJhbWVfc2l6ZSBpblxuICBpZiBpc19mcmFtZV9zaXplX2Vycm9yXG4gIHRoZW5cbiAgICBwYXJzZV9jb250ZXh0LnJlbWFpbmluZ19ieXRlc190b19za2lwIDwtXG4gICAgICBwYXJzZV9jb250ZXh0LnJlbWFpbmluZ19ieXRlc190b19za2lwICsgcGF5bG9hZF9sZW5ndGg7XG4gIGxpZnRcbiAgICAoZnVuY3Rpb25cbiAgICAgICB8IE9rIGZyYW1lX3BheWxvYWQgLT4gT2sgeyBGcmFtZS5mcmFtZV9oZWFkZXI7IGZyYW1lX3BheWxvYWQgfVxuICAgICAgIHwgRXJyb3IgZSAtPiBFcnJvciBlKVxuICAgIChwYXJzZV9mcmFtZV9wYXlsb2FkIGZyYW1lX2hlYWRlcilcblxuKCogVGhpcyBpcyB0aGUgY2xpZW50IGNvbm5lY3Rpb24gcHJlZmFjZS4gKilcbmxldCBjb25uZWN0aW9uX3ByZWZhY2UgPVxuICAoKiBGcm9tIFJGQzc1NDDCpzMuNTpcbiAgICogICBJbiBIVFRQLzIsIGVhY2ggZW5kcG9pbnQgaXMgcmVxdWlyZWQgdG8gc2VuZCBhIGNvbm5lY3Rpb24gcHJlZmFjZSBhcyBhXG4gICAqICAgZmluYWwgY29uZmlybWF0aW9uIG9mIHRoZSBwcm90b2NvbCBpbiB1c2UgYW5kIHRvIGVzdGFibGlzaCB0aGUgaW5pdGlhbFxuICAgKiAgIHNldHRpbmdzIGZvciB0aGUgSFRUUC8yIGNvbm5lY3Rpb24uICopXG4gIHN0cmluZyBGcmFtZS5jb25uZWN0aW9uX3ByZWZhY2UgPD8+IFwiY29ubmVjdGlvbiBwcmVmYWNlXCJcblxubW9kdWxlIFJlYWRlciA9IHN0cnVjdFxuICBtb2R1bGUgQVUgPSBBbmdzdHJvbS5VbmJ1ZmZlcmVkXG5cbiAgdHlwZSBwYXJzZV9lcnJvciA9XG4gICAgKCogUGFyc2UgZXJyb3IgcmVwb3J0ZWQgYnkgQW5nc3Ryb20gKilcbiAgICBbIGBQYXJzZSBvZiBzdHJpbmcgbGlzdCAqIHN0cmluZ1xuICAgIHwgKCogRnVsbCBlcnJvciBpbmZvcm1hdGlvbiAqKVxuICAgICAgYEVycm9yIG9mIEVycm9yLnRcbiAgICB8ICgqIEp1c3QgdGhlIGVycm9yIGNvZGUsIG5lZWQgdG8gcHV6emxlIGJhY2sgY29ubmVjdGlvbiBvciBzdHJlYW0gaW5mbyAqKVxuICAgICAgYEVycm9yX2NvZGUgb2ZcbiAgICAgIEVycm9yX2NvZGUudFxuICAgIF1cblxuICB0eXBlICdlcnJvciBwYXJzZV9zdGF0ZSA9XG4gICAgfCBJbml0aWFsXG4gICAgfCBGYWlsIG9mICdlcnJvclxuICAgIHwgUGFydGlhbCBvZlxuICAgICAgICAoQmlnc3RyaW5nYWYudFxuICAgICAgICAgLT4gb2ZmOmludFxuICAgICAgICAgLT4gbGVuOmludFxuICAgICAgICAgLT4gQVUubW9yZVxuICAgICAgICAgLT4gKHVuaXQsICdlcnJvcikgcmVzdWx0IEFVLnN0YXRlKVxuXG4gIHR5cGUgJ2Vycm9yIHQgPVxuICAgIHsgcGFyc2VyIDogKHVuaXQsICdlcnJvcikgcmVzdWx0IEFuZ3N0cm9tLnRcbiAgICA7IG11dGFibGUgcGFyc2Vfc3RhdGUgOiAnZXJyb3IgcGFyc2Vfc3RhdGVcbiAgICAgICAgICAoKiBUaGUgc3RhdGUgb2YgdGhlIHBhcnNlIGZvciB0aGUgY3VycmVudCByZXF1ZXN0ICopXG4gICAgOyBtdXRhYmxlIGNsb3NlZCA6IGJvb2xcbiAgICAgICAgICAoKiBXaGV0aGVyIHRoZSBpbnB1dCBzb3VyY2UgaGFzIGxlZnQgdGhlIGJ1aWxkaW5nLCBpbmRpY2F0aW5nIHRoYXQgbm9cbiAgICAgICAgICAgKiBmdXJ0aGVyIGlucHV0IHdpbGwgYmUgcmVjZWl2ZWQuICopXG4gICAgOyBwYXJzZV9jb250ZXh0IDogcGFyc2VfY29udGV4dFxuICAgICgqIFRoZSBjdXJyZW50IHN0cmVhbSBpZGVudGlmaWVyIGJlaW5nIHByb2Nlc3NlZCwgaW4gb3JkZXIgdG8gZGlzY2VyblxuICAgICAqIHdoZXRoZXIgdGhlIGVycm9yIHRoYXQgbmVlZHMgdG8gYmUgYXNzZW1ibGVkIGlzIGEgc3RyZWFtIG9yXG4gICAgICogY29ubmVjdGlvbiBlcnJvci4gKilcbiAgICB9XG5cbiAgdHlwZSBmcmFtZSA9IHBhcnNlX2Vycm9yIHRcblxuICBsZXQgY3JlYXRlIHBhcnNlciBwYXJzZV9jb250ZXh0ID1cbiAgICB7IHBhcnNlcjsgcGFyc2Vfc3RhdGUgPSBJbml0aWFsOyBjbG9zZWQgPSBmYWxzZTsgcGFyc2VfY29udGV4dCB9XG5cbiAgbGV0IGNyZWF0ZV9wYXJzZV9jb250ZXh0IG1heF9mcmFtZV9zaXplID1cbiAgICB7IGZyYW1lX2hlYWRlciA9IGRlZmF1bHRfZnJhbWVfaGVhZGVyXG4gICAgOyByZW1haW5pbmdfYnl0ZXNfdG9fc2tpcCA9IDBcbiAgICA7IGRpZF9yZXBvcnRfc3RyZWFtX2Vycm9yID0gZmFsc2VcbiAgICA7IG1heF9mcmFtZV9zaXplXG4gICAgfVxuXG4gIGxldCBzZXR0aW5nc19wcmVmYWNlIHBhcnNlX2NvbnRleHQgPVxuICAgICgqIEZyb20gUkZDNzU0MMKnMy41OlxuICAgICAqICAgWy4uLl0gdGhlIGNvbm5lY3Rpb24gcHJlZmFjZSBzdGFydHMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICogICBQUkkgKiBIVFRQLzIuMFxcclxcblxcclxcblNNXFxyXFxuXFxyXFxuKS4gVGhpcyBzZXF1ZW5jZSBNVVNUIGJlIGZvbGxvd2VkIGJ5XG4gICAgICogICBhIFNFVFRJTkdTIGZyYW1lIChTZWN0aW9uIDYuNSksIHdoaWNoIE1BWSBiZSBlbXB0eS4gKilcbiAgICBwYXJzZV9mcmFtZSBwYXJzZV9jb250ZXh0ID4+fCBmdW5jdGlvblxuICAgIHwgT2sgKHsgZnJhbWVfcGF5bG9hZCA9IEZyYW1lLlNldHRpbmdzIHNldHRpbmdzX2xpc3Q7IF8gfSBhcyBmcmFtZSkgLT5cbiAgICAgIE9rIChmcmFtZSwgc2V0dGluZ3NfbGlzdClcbiAgICB8IE9rIHsgZnJhbWVfcGF5bG9hZCA9IEZyYW1lLkdvQXdheSAoXywgZXJyb3JfY29kZSwgZGVidWdfZGF0YSk7IF8gfSAtPlxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc5LjIuMTpcbiAgICAgICAqICAgQW4gZW5kcG9pbnQgTUFZIGltbWVkaWF0ZWx5IHRlcm1pbmF0ZSBhbiBIVFRQLzIgY29ubmVjdGlvbiB0aGF0IGRvZXNcbiAgICAgICAqICAgbm90IG1lZXQgdGhlc2UgVExTIHJlcXVpcmVtZW50cyB3aXRoIGEgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvblxuICAgICAgICogICA1LjQuMSkgb2YgdHlwZSBJTkFERVFVQVRFX1NFQ1VSSVRZLlxuICAgICAgICpcbiAgICAgICAqICAgTm90ZTogd2UgYXJlIGxpYmVyYWwgb24gcHVycG9zZSBpbiB0aGlzIGJyYW5jaCBpbnN0ZWFkIG9mIG9ubHlcbiAgICAgICAqICAgYWNjZXB0aW5nIGFuIGVycm9yIG9mIHR5cGUgYElOQURFUVVBVEVfU0VDVVJJVFlgLiBJZiBhbiBlbmRwb2ludCBpc1xuICAgICAgICogICBzZW5kaW5nIHVzIGEgYEdPQVdBWWAgZnJhbWUgd2UgcHJvYmFibHkgZGlkIHNvbWV0aGluZyB3cm9uZyBhbmRcbiAgICAgICAqICAgZGVzZXJ2ZSB0byBrbm93IHdoYXQgdGhhdCBpcy4gKilcbiAgICAgIEVycm9yXG4gICAgICAgIChgRXJyb3JcbiAgICAgICAgICBFcnJvci4oQ29ubmVjdGlvbkVycm9yIChlcnJvcl9jb2RlLCBCaWdzdHJpbmdhZi50b19zdHJpbmcgZGVidWdfZGF0YSkpKVxuICAgIHwgT2sgXyAtPlxuICAgICAgKCogRnJvbSBSRkM3NTQwwqczLjU6XG4gICAgICAgKiAgIENsaWVudHMgYW5kIHNlcnZlcnMgTVVTVCB0cmVhdCBhbiBpbnZhbGlkIGNvbm5lY3Rpb24gcHJlZmFjZSBhcyBhXG4gICAgICAgKiAgIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuIEEgR09BV0FZXG4gICAgICAgKiAgIGZyYW1lIChTZWN0aW9uIDYuOCkgTUFZIGJlIG9taXR0ZWQgaW4gdGhpcyBjYXNlLCBzaW5jZSBhbiBpbnZhbGlkXG4gICAgICAgKiAgIHByZWZhY2UgaW5kaWNhdGVzIHRoYXQgdGhlIHBlZXIgaXMgbm90IHVzaW5nIEhUVFAvMi4gKilcbiAgICAgIEVycm9yXG4gICAgICAgIChgRXJyb3JcbiAgICAgICAgICBFcnJvci4oQ29ubmVjdGlvbkVycm9yIChQcm90b2NvbEVycm9yLCBcIkludmFsaWQgY29ubmVjdGlvbiBwcmVmYWNlXCIpKSlcbiAgICB8IEVycm9yIGUgLT4gRXJyb3IgKGBFcnJvciBlKVxuXG4gIGxldCBjb25uZWN0aW9uX3ByZWZhY2VfYW5kX2ZyYW1lc1xuICAgICAgfm1heF9mcmFtZV9zaXplXG4gICAgICBwcmVmYWNlX3BhcnNlclxuICAgICAgcHJlZmFjZV9oYW5kbGVyXG4gICAgICBmcmFtZV9oYW5kbGVyXG4gICAgPVxuICAgIGxldCBwYXJzZV9jb250ZXh0ID0gY3JlYXRlX3BhcnNlX2NvbnRleHQgbWF4X2ZyYW1lX3NpemUgaW5cbiAgICBsZXQgcGFyc2VyID1cbiAgICAgIHByZWZhY2VfcGFyc2VyIHBhcnNlX2NvbnRleHQgPCogY29tbWl0ID4+PSBmdW5jdGlvblxuICAgICAgfCBPayAoZnJhbWUsIHNldHRpbmdzX2xpc3QpIC0+XG4gICAgICAgIHByZWZhY2VfaGFuZGxlciBmcmFtZSBzZXR0aW5nc19saXN0O1xuICAgICAgICAoKiBBZnRlciBoYXZpbmcgcmVjZWl2ZWQgYSB2YWxpZCBjb25uZWN0aW9uIHByZWZhY2UsIHdlIGNhbiBzdGFydFxuICAgICAgICAgKiByZWFkaW5nIG90aGVyIGZyYW1lcyBub3cuICopXG4gICAgICAgIHNraXBfbWFueSAocGFyc2VfZnJhbWUgcGFyc2VfY29udGV4dCA8KiBjb21taXQgPj58IGZyYW1lX2hhbmRsZXIpXG4gICAgICAgID4+fCBmdW4gKCkgLT4gT2sgKClcbiAgICAgIHwgRXJyb3IgXyBhcyBlcnJvciAtPiByZXR1cm4gZXJyb3JcbiAgICBpblxuICAgIGNyZWF0ZSBwYXJzZXIgcGFyc2VfY29udGV4dFxuXG4gIGxldCBjbGllbnRfZnJhbWVzIHByZWZhY2VfaGFuZGxlciBmcmFtZV9oYW5kbGVyID1cbiAgICBjb25uZWN0aW9uX3ByZWZhY2VfYW5kX2ZyYW1lc1xuICAgICAgKCogRnJvbSBSRkM3NTQwwqczLjU6XG4gICAgICAgKiAgIFRoZSBzZXJ2ZXIgY29ubmVjdGlvbiBwcmVmYWNlIGNvbnNpc3RzIG9mIGEgcG90ZW50aWFsbHkgZW1wdHlcbiAgICAgICAqICAgU0VUVElOR1MgZnJhbWUgKFNlY3Rpb24gNi41KSB0aGF0IE1VU1QgYmUgdGhlIGZpcnN0IGZyYW1lIHRoZSBzZXJ2ZXJcbiAgICAgICAqICAgc2VuZHMgaW4gdGhlIEhUVFAvMiBjb25uZWN0aW9uLiAqKVxuICAgICAgc2V0dGluZ3NfcHJlZmFjZVxuICAgICAgcHJlZmFjZV9oYW5kbGVyXG4gICAgICBmcmFtZV9oYW5kbGVyXG5cbiAgbGV0IHNlcnZlcl9mcmFtZXMgfm1heF9mcmFtZV9zaXplIHByZWZhY2VfaGFuZGxlciBmcmFtZV9oYW5kbGVyID1cbiAgICBjb25uZWN0aW9uX3ByZWZhY2VfYW5kX2ZyYW1lc1xuICAgICAgfm1heF9mcmFtZV9zaXplXG4gICAgICAoZnVuIHBhcnNlX2NvbnRleHQgLT5cbiAgICAgICAgICgqIEZyb20gUkZDNzU0MMKnMy41OlxuICAgICAgICAgICogICBUaGUgY2xpZW50IGNvbm5lY3Rpb24gcHJlZmFjZSBzdGFydHMgd2l0aCBhIHNlcXVlbmNlIG9mIDI0IG9jdGV0cyxcbiAgICAgICAgICAqICAgd2hpY2ggaW4gaGV4IG5vdGF0aW9uIGlzOlxuICAgICAgICAgICpcbiAgICAgICAgICAqICAgICAweDUwNTI0OTIwMmEyMDQ4NTQ1NDUwMmYzMjJlMzAwZDBhMGQwYTUzNGQwZDBhMGQwYVxuICAgICAgICAgICogICBUaGF0IGlzLCB0aGUgY29ubmVjdGlvbiBwcmVmYWNlIHN0YXJ0cyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAgICAqICAgUFJJICogSFRUUC8yLjBcXHJcXG5cXHJcXG5TTVxcclxcblxcclxcbikuIFRoaXMgc2VxdWVuY2UgTVVTVCBiZSBmb2xsb3dlZFxuICAgICAgICAgICogICBieSBhIFNFVFRJTkdTIGZyYW1lIChTZWN0aW9uIDYuNSksIHdoaWNoIE1BWSBiZSBlbXB0eS4gKilcbiAgICAgICAgIGNvbm5lY3Rpb25fcHJlZmFjZSAqPiBzZXR0aW5nc19wcmVmYWNlIHBhcnNlX2NvbnRleHQpXG4gICAgICBwcmVmYWNlX2hhbmRsZXJcbiAgICAgIGZyYW1lX2hhbmRsZXJcblxuICBsZXQgaXNfY2xvc2VkIHQgPSB0LmNsb3NlZFxuXG4gIGxldCB0cmFuc2l0aW9uIHQgc3RhdGUgPVxuICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICB8IEFVLkRvbmUgKGNvbnN1bWVkLCBPayAoKSkgLT5cbiAgICAgIHQucGFyc2Vfc3RhdGUgPC0gSW5pdGlhbDtcbiAgICAgIGNvbnN1bWVkXG4gICAgfCBEb25lIChjb25zdW1lZCwgRXJyb3IgZXJyb3IpIC0+XG4gICAgICB0LnBhcnNlX3N0YXRlIDwtIEZhaWwgZXJyb3I7XG4gICAgICBjb25zdW1lZFxuICAgIHwgRmFpbCAoY29uc3VtZWQsIG1hcmtzLCBtc2cpIC0+XG4gICAgICB0LnBhcnNlX3N0YXRlIDwtIEZhaWwgKGBQYXJzZSAobWFya3MsIG1zZykpO1xuICAgICAgY29uc3VtZWRcbiAgICB8IFBhcnRpYWwgeyBjb21taXR0ZWQ7IGNvbnRpbnVlIH0gLT5cbiAgICAgICgqIElmIHdlIGhhdmUgYnl0ZXMgdG8gc2tpcCBvdmVyIHRoZW4gaXQgbWVhbnMgd2UndmUgc3BvdHRlZCBhXG4gICAgICAgKiBGUkFNRV9TSVpFX0VSUk9SLCBhIGNhc2Ugd2hlcmUsIGR1ZSB0byBvdXIgdW5idWZmZXJlZCBwYXJzaW5nLCB0aGVcbiAgICAgICAqIHBheWxvYWQgbGVuZ3RoIGRlY2xhcmVkIGluIGEgZnJhbWUgaGVhZGVyIGlzIGxhcmdlciB0aGFuIHRoZVxuICAgICAgICogdW5kZXJseWluZyBidWZmZXIgY2FuIGZpdC4gKilcbiAgICAgIGlmIHQucGFyc2VfY29udGV4dC5yZW1haW5pbmdfYnl0ZXNfdG9fc2tpcCA+IDBcbiAgICAgIHRoZW4gdC5wYXJzZV9zdGF0ZSA8LSBGYWlsIChgRXJyb3JfY29kZSBFcnJvcl9jb2RlLkZyYW1lU2l6ZUVycm9yKVxuICAgICAgZWxzZSB0LnBhcnNlX3N0YXRlIDwtIFBhcnRpYWwgY29udGludWU7XG4gICAgICBjb21taXR0ZWRcblxuICBsZXQgc3RhcnQgdCBzdGF0ZSA9XG4gICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgIHwgQVUuRG9uZSBfIC0+IGZhaWx3aXRoIFwiaDIuUGFyc2UuUmVhZGVyLnVuYWJsZSB0byBzdGFydCBwYXJzZXJcIlxuICAgIHwgRmFpbCAoMCwgbWFya3MsIG1zZykgLT4gdC5wYXJzZV9zdGF0ZSA8LSBGYWlsIChgUGFyc2UgKG1hcmtzLCBtc2cpKVxuICAgIHwgUGFydGlhbCB7IGNvbW1pdHRlZCA9IDA7IGNvbnRpbnVlIH0gLT4gdC5wYXJzZV9zdGF0ZSA8LSBQYXJ0aWFsIGNvbnRpbnVlXG4gICAgfCBQYXJ0aWFsIF8gfCBGYWlsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgbGV0IHJlYyByZWFkX3dpdGhfbW9yZSB0IGJzIH5vZmYgfmxlbiBtb3JlID1cbiAgICBsZXQgY29uc3VtZWQgPVxuICAgICAgbWF0Y2ggdC5wYXJzZV9zdGF0ZSB3aXRoXG4gICAgICB8IEZhaWwgXyAtPlxuICAgICAgICBsZXQgcGFyc2VyX2N0eCA9IHQucGFyc2VfY29udGV4dCBpblxuICAgICAgICBsZXQgcmVtYWluaW5nX2J5dGVzID0gcGFyc2VyX2N0eC5yZW1haW5pbmdfYnl0ZXNfdG9fc2tpcCBpblxuICAgICAgICAoKiBKdXN0IHNraXAgaW5wdXQgaWYgd2UgbmVlZCB0byAqKVxuICAgICAgICBpZiByZW1haW5pbmdfYnl0ZXMgPiAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGFzc2VydCAocmVtYWluaW5nX2J5dGVzID49IGxlbik7XG4gICAgICAgICAgbGV0IHJlbWFpbmluZ19ieXRlcycgPSByZW1haW5pbmdfYnl0ZXMgLSBsZW4gaW5cbiAgICAgICAgICBwYXJzZXJfY3R4LnJlbWFpbmluZ19ieXRlc190b19za2lwIDwtIHJlbWFpbmluZ19ieXRlcyc7XG4gICAgICAgICAgYXNzZXJ0IChyZW1haW5pbmdfYnl0ZXMnID49IDApO1xuICAgICAgICAgIGlmIHJlbWFpbmluZ19ieXRlcycgPSAwXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgKCogUmVzZXQgdGhlIHBhcnNlciBzdGF0ZSB0byBgRG9uZWAgc28gdGhhdCB3ZSBjYW4gcmVhZCB0aGUgbmV4dFxuICAgICAgICAgICAgICogZnJhbWUgKGFmdGVyIHNraXBwaW5nIHRocm91Z2ggdGhlIGJhZCBpbnB1dCkgKilcbiAgICAgICAgICAgIHQucGFyc2Vfc3RhdGUgPC0gSW5pdGlhbDtcbiAgICAgICAgICBsZW4pXG4gICAgICAgIGVsc2UgMFxuICAgICAgfCBJbml0aWFsIC0+XG4gICAgICAgIHN0YXJ0IHQgKEFVLnBhcnNlIHQucGFyc2VyKTtcbiAgICAgICAgcmVhZF93aXRoX21vcmUgdCBicyB+b2ZmIH5sZW4gbW9yZVxuICAgICAgfCBQYXJ0aWFsIGNvbnRpbnVlIC0+IHRyYW5zaXRpb24gdCAoY29udGludWUgYnMgbW9yZSB+b2ZmIH5sZW4pXG4gICAgaW5cbiAgICAobWF0Y2ggbW9yZSB3aXRoIENvbXBsZXRlIC0+IHQuY2xvc2VkIDwtIHRydWUgfCBJbmNvbXBsZXRlIC0+ICgpKTtcbiAgICBjb25zdW1lZFxuXG4gIGxldCBmb3JjZV9jbG9zZSB0ID0gdC5jbG9zZWQgPC0gdHJ1ZVxuICBsZXQgZmFpbF90b19zdHJpbmcgbWFya3MgZXJyID0gU3RyaW5nLmNvbmNhdCBcIiA+IFwiIG1hcmtzIF4gXCI6IFwiIF4gZXJyXG5cbiAgbGV0IG5leHRfZnJvbV9lcnJvciB0ID8obXNnID0gXCJcIikgZXJyb3JfY29kZSA9XG4gICAgaWYgdC5wYXJzZV9jb250ZXh0LmZyYW1lX2hlYWRlciA9PSBkZWZhdWx0X2ZyYW1lX2hlYWRlclxuICAgIHRoZW4gYEVycm9yIEVycm9yLihDb25uZWN0aW9uRXJyb3IgKGVycm9yX2NvZGUsIG1zZykpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggdC5wYXJzZV9jb250ZXh0LCBlcnJvcl9jb2RlIHdpdGhcbiAgICAgIHwgKCB7IGZyYW1lX2hlYWRlciA9XG4gICAgICAgICAgICAgIHsgZnJhbWVfdHlwZSA9XG4gICAgICAgICAgICAgICAgICBIZWFkZXJzIHwgUHVzaFByb21pc2UgfCBDb250aW51YXRpb24gfCBTZXR0aW5ncyB8IFVua25vd24gX1xuICAgICAgICAgICAgICA7IF9cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIDsgX1xuICAgICAgICAgIH1cbiAgICAgICAgLCBFcnJvcl9jb2RlLkZyYW1lU2l6ZUVycm9yIClcbiAgICAgIHwgeyBmcmFtZV9oZWFkZXIgPSB7IEZyYW1lLnN0cmVhbV9pZCA9IDB4MGw7IF8gfTsgXyB9LCBfIC0+XG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNC4yOlxuICAgICAgICAgKiAgIEEgZnJhbWUgc2l6ZSBlcnJvciBpbiBhIGZyYW1lIHRoYXQgY291bGQgYWx0ZXIgdGhlIHN0YXRlIG9mIHRoZVxuICAgICAgICAgKiAgIGVudGlyZSBjb25uZWN0aW9uIE1VU1QgYmUgdHJlYXRlZCBhcyBhIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb25cbiAgICAgICAgICogICA1LjQuMSk7IHRoaXMgaW5jbHVkZXMgYW55IGZyYW1lIGNhcnJ5aW5nIGEgaGVhZGVyIGJsb2NrIChTZWN0aW9uXG4gICAgICAgICAqICAgNC4zKSAodGhhdCBpcywgSEVBREVSUywgUFVTSF9QUk9NSVNFLCBhbmQgQ09OVElOVUFUSU9OKSwgU0VUVElOR1MsXG4gICAgICAgICAqICAgYW5kIGFueSBmcmFtZSB3aXRoIGEgc3RyZWFtIGlkZW50aWZpZXIgb2YgMC4gKilcbiAgICAgICAgYEVycm9yIEVycm9yLihDb25uZWN0aW9uRXJyb3IgKGVycm9yX2NvZGUsIG1zZykpXG4gICAgICB8IHsgZGlkX3JlcG9ydF9zdHJlYW1fZXJyb3IgPSB0cnVlOyBfIH0sIF8gLT5cbiAgICAgICAgKCogSWYgdGhlIHBhcnNlciBpcyBpbiBhIGBGYWlsYCBzdGF0ZSBhbmQgd291bGQgcmVwb3J0IGEgc3RyZWFtIGVycm9yLFxuICAgICAgICAgKiBqdXN0IGlzc3VlIGEgYFJlYWRgIG9wZXJhdGlvbiBpZiB3ZSd2ZSBhbHJlYWR5IHJlcG9ydGVkIHRoYXQgZXJyb3IuICopXG4gICAgICAgIGlmIHQuY2xvc2VkIHRoZW4gYENsb3NlIGVsc2UgYFJlYWRcbiAgICAgIHwgeyBmcmFtZV9oZWFkZXIgPSB7IEZyYW1lLnN0cmVhbV9pZDsgXyB9OyBfIH0sIF8gLT5cbiAgICAgICAgdC5wYXJzZV9jb250ZXh0LmRpZF9yZXBvcnRfc3RyZWFtX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIGBFcnJvciBFcnJvci4oU3RyZWFtRXJyb3IgKHN0cmVhbV9pZCwgZXJyb3JfY29kZSkpXG5cbiAgbGV0IG5leHQgdCA9XG4gICAgbWF0Y2ggdC5wYXJzZV9zdGF0ZSB3aXRoXG4gICAgfCBGYWlsIGVycm9yIC0+XG4gICAgICAobWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgfCBgRXJyb3IgZSAtPiBgRXJyb3IgZVxuICAgICAgfCBgRXJyb3JfY29kZSBlcnJvcl9jb2RlIC0+IG5leHRfZnJvbV9lcnJvciB0IGVycm9yX2NvZGVcbiAgICAgIHwgYFBhcnNlIChtYXJrcywgbXNnKSAtPlxuICAgICAgICBsZXQgZXJyb3JfY29kZSA9XG4gICAgICAgICAgbWF0Y2ggbWFya3MsIG1zZyB3aXRoXG4gICAgICAgICAgfCBbIFwiZnJhbWVfcGF5bG9hZFwiIF0sIFwibm90IGVub3VnaCBpbnB1dFwiIC0+XG4gICAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzQuMjpcbiAgICAgICAgICAgICAqICAgQW4gZW5kcG9pbnQgTVVTVCBzZW5kIGFuIGVycm9yIGNvZGUgb2YgRlJBTUVfU0laRV9FUlJPUiBpZiBhXG4gICAgICAgICAgICAgKiAgIGZyYW1lIGV4Y2VlZHMgdGhlIHNpemUgZGVmaW5lZCBpbiBTRVRUSU5HU19NQVhfRlJBTUVfU0laRSxcbiAgICAgICAgICAgICAqICAgZXhjZWVkcyBhbnkgbGltaXQgZGVmaW5lZCBmb3IgdGhlIGZyYW1lIHR5cGUsIG9yIGlzIHRvbyBzbWFsbFxuICAgICAgICAgICAgICogICB0byBjb250YWluIG1hbmRhdG9yeSBmcmFtZSBkYXRhLiAqKVxuICAgICAgICAgICAgRXJyb3JfY29kZS5GcmFtZVNpemVFcnJvclxuICAgICAgICAgIHwgXyAtPiBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgICAgICAgaW5cbiAgICAgICAgbmV4dF9mcm9tX2Vycm9yIHQgfm1zZzooZmFpbF90b19zdHJpbmcgbWFya3MgbXNnKSBlcnJvcl9jb2RlKVxuICAgIHwgXyB3aGVuIHQuY2xvc2VkIC0+IGBDbG9zZVxuICAgIHwgUGFydGlhbCBfIC0+IGBSZWFkXG4gICAgfCBJbml0aWFsIC0+IGlmIHQuY2xvc2VkIHRoZW4gYENsb3NlIGVsc2UgYFJlYWRcbmVuZFxuIiwiKCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE3IEluaGFiaXRlZCBUeXBlIExMQy5cbiAqICBDb3B5cmlnaHQgKGMpIDIwMTkgQW50b25pbyBOLiBNb250ZWlyby5cbiAqXG4gKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiAgYXJlIG1ldDpcbiAqXG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAqICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAqICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09OVFJJQlVUT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NcbiAqICBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAqICBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbiAqICBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gKiAgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAqICBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTilcbiAqICBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXG4gKiAgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOXG4gKiAgQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbm1vZHVsZSBIcGFjayA9IERyZWFtX2hwYWNrLkhwYWNrXG5tb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcblxubW9kdWxlIFdyaXRlciA9IFNlcmlhbGl6ZS5Xcml0ZXJcblxudHlwZSBlcnJvciA9XG4gIFsgYEJhZF9yZXF1ZXN0XG4gIHwgYEludGVybmFsX3NlcnZlcl9lcnJvclxuICB8IGBFeG4gb2YgZXhuXG4gIF1cblxudHlwZSBlcnJvcl9oYW5kbGVyID1cbiAgP3JlcXVlc3Q6UmVxdWVzdC50IC0+IGVycm9yIC0+IChIZWFkZXJzLnQgLT4gQm9keS5Xcml0ZXIudCkgLT4gdW5pdFxuXG50eXBlIHJlc3BvbnNlX3N0YXRlID1cbiAgfCBXYWl0aW5nXG4gIHwgRml4ZWQgb2ZcbiAgICAgIHsgcmVzcG9uc2UgOiBSZXNwb25zZS50XG4gICAgICA7IG11dGFibGUgaW92ZWMgOlxuICAgICAgICAgIFsgYFN0cmluZyBvZiBzdHJpbmcgfCBgQmlnc3RyaW5nIG9mIEJpZ3N0cmluZ2FmLnQgXSBIdHRwYWYuSU9WZWMudFxuICAgICAgfVxuICB8IFN0cmVhbWluZyBvZlxuICAgICAgeyByZXNwb25zZSA6IFJlc3BvbnNlLnRcbiAgICAgIDsgcmVzcG9uc2VfYm9keSA6IEJvZHkuV3JpdGVyLnRcbiAgICAgIDsgdHJhaWxlcnMgOiBIZWFkZXJzLnRcbiAgICAgIH1cbiAgfCBDb21wbGV0ZSBvZiBSZXNwb25zZS50XG5cbnR5cGUgcmVxdWVzdF9pbmZvID1cbiAgeyByZXF1ZXN0IDogUmVxdWVzdC50XG4gIDsgcmVxdWVzdF9ib2R5IDogQm9keS5SZWFkZXIudFxuICA7IG11dGFibGUgcmVxdWVzdF9ib2R5X2J5dGVzIDogaW50NjRcbiAgfVxuXG50eXBlIGFjdGl2ZV9zdGF0ZSA9IChyZXF1ZXN0X2luZm8sIHJlcXVlc3RfaW5mbykgU3RyZWFtLmFjdGl2ZV9zdGF0ZVxuXG50eXBlIGFjdGl2ZV9zdHJlYW0gPVxuICB7IGJvZHlfYnVmZmVyX3NpemUgOiBpbnRcbiAgOyBlbmNvZGVyIDogSHBhY2suRW5jb2Rlci50XG4gIDsgbXV0YWJsZSByZXNwb25zZV9zdGF0ZSA6IHJlc3BvbnNlX3N0YXRlXG4gICAgICAgICgqIFdlJ3JlIG5vdCBkb2luZyBhbnl0aGluZyB3aXRoIHRoZXNlIHlldCwgd2UgY291bGQgcHJvYmFibHkgaGF2ZSBhXG4gICAgICAgICAqIGBSZXFkLnNjaGVkdWxlX3JlYWRfdHJhaWxlcnNgIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgY2FsbGVkIG9uY2VcbiAgICAgICAgICogdHJhaWxlciBoZWFkZXJzIGFyZSBlbWl0dGVkLiAqKVxuICA7IG11dGFibGUgdHJhaWxlcnNfcGFyc2VyIDogU3RyZWFtLnBhcnRpYWxfaGVhZGVycyBvcHRpb25cbiAgOyBtdXRhYmxlIHRyYWlsZXJzIDogSGVhZGVycy50IG9wdGlvblxuICA7IGNyZWF0ZV9wdXNoX3N0cmVhbSA6XG4gICAgICBTdHJlYW1faWRlbnRpZmllci50XG4gICAgICAtPiAodCwgWyBgUHVzaF9kaXNhYmxlZCB8IGBTdHJlYW1faWRzX2V4aGF1c3RlZCBdKSByZXN1bHRcbiAgfVxuXG5hbmQgc3RhdGUgPVxuICAoYWN0aXZlX3N0YXRlLCBhY3RpdmVfc3RyZWFtLCByZXF1ZXN0X2luZm8gKiBhY3RpdmVfc3RyZWFtKSBTdHJlYW0uc3RhdGVcblxuYW5kIHQgPSAoc3RhdGUsIGVycm9yLCBlcnJvcl9oYW5kbGVyKSBTdHJlYW0udFxuXG5sZXQgY3JlYXRlX2FjdGl2ZV9yZXF1ZXN0IHJlcXVlc3QgcmVxdWVzdF9ib2R5ID1cbiAgeyByZXF1ZXN0OyByZXF1ZXN0X2JvZHk7IHJlcXVlc3RfYm9keV9ieXRlcyA9IEludDY0Lnplcm8gfVxuXG5sZXQgY3JlYXRlX2FjdGl2ZV9zdHJlYW0gZW5jb2RlciBib2R5X2J1ZmZlcl9zaXplIGNyZWF0ZV9wdXNoX3N0cmVhbSA9XG4gIHsgYm9keV9idWZmZXJfc2l6ZVxuICA7IGVuY29kZXJcbiAgOyByZXNwb25zZV9zdGF0ZSA9IFdhaXRpbmdcbiAgOyB0cmFpbGVyc19wYXJzZXIgPSBOb25lXG4gIDsgdHJhaWxlcnMgPSBOb25lXG4gIDsgY3JlYXRlX3B1c2hfc3RyZWFtXG4gIH1cblxubGV0IHJlcXVlc3QgKHQgOiB0KSA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IElkbGUgfCBBY3RpdmUgKE9wZW4gKFdhaXRpbmdGb3JQZWVyIHwgUGFydGlhbEhlYWRlcnMgXyB8IEZ1bGxIZWFkZXJzKSwgXykgLT5cbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBBY3RpdmUgKChPcGVuIChBY3RpdmVNZXNzYWdlIHsgcmVxdWVzdDsgXyB9KSB8IEhhbGZDbG9zZWQgeyByZXF1ZXN0OyBfIH0pLCBfKVxuICB8IFJlc2VydmVkICh7IHJlcXVlc3Q7IF8gfSwgXykgLT5cbiAgICByZXF1ZXN0XG4gIHwgQ2xvc2VkIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCByZXF1ZXN0X2JvZHkgKHQgOiB0KSA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IElkbGUgfCBBY3RpdmUgKE9wZW4gKFdhaXRpbmdGb3JQZWVyIHwgUGFydGlhbEhlYWRlcnMgXyB8IEZ1bGxIZWFkZXJzKSwgXykgLT5cbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBBY3RpdmVcbiAgICAgICggKCBPcGVuIChBY3RpdmVNZXNzYWdlIHsgcmVxdWVzdF9ib2R5OyBfIH0pXG4gICAgICAgIHwgSGFsZkNsb3NlZCB7IHJlcXVlc3RfYm9keTsgXyB9IClcbiAgICAgICwgXyApIC0+XG4gICAgcmVxdWVzdF9ib2R5XG4gIHwgUmVzZXJ2ZWQgXyAtPlxuICAgICgqIEZyb20gUkZDNzU0MMKnOC4xOlxuICAgICAqICAgUHJvbWlzZWQgcmVxdWVzdHMgTVVTVCBOT1QgaW5jbHVkZSBhIHJlcXVlc3QgYm9keS4gKilcbiAgICBmYWlsd2l0aFxuICAgICAgXCJoMi5SZXFkLnJlcXVlc3RfYm9keTogUHJvbWlzZWQgcmVxdWVzdHMgbXVzdCBub3QgaW5jbHVkZSBhIHJlcXVlc3QgYm9keVwiXG4gIHwgQ2xvc2VkIF8gLT4gZmFpbHdpdGggXCJoMi5SZXFkLnJlcXVlc3RfYm9keTogU3RyZWFtIGFscmVhZHkgY2xvc2VkXCJcblxubGV0IHJlc3BvbnNlICh0IDogdCkgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBJZGxlIHwgQWN0aXZlIChPcGVuIChXYWl0aW5nRm9yUGVlciB8IFBhcnRpYWxIZWFkZXJzIF8pLCBfKSAtPiBOb25lXG4gIHwgQWN0aXZlXG4gICAgICAoIChPcGVuIChGdWxsSGVhZGVycyB8IEFjdGl2ZU1lc3NhZ2UgXykgfCBIYWxmQ2xvc2VkIF8pXG4gICAgICAsIHsgcmVzcG9uc2Vfc3RhdGU7IF8gfSApXG4gIHwgUmVzZXJ2ZWQgKF8sIHsgcmVzcG9uc2Vfc3RhdGU7IF8gfSkgLT5cbiAgICAobWF0Y2ggcmVzcG9uc2Vfc3RhdGUgd2l0aFxuICAgIHwgV2FpdGluZyAtPiBOb25lXG4gICAgfCBTdHJlYW1pbmcgeyByZXNwb25zZTsgXyB9IHwgRml4ZWQgeyByZXNwb25zZTsgXyB9IHwgQ29tcGxldGUgcmVzcG9uc2UgLT5cbiAgICAgIFNvbWUgcmVzcG9uc2UpXG4gIHwgQ2xvc2VkIF8gLT4gTm9uZVxuXG5sZXQgcmVzcG9uc2VfZXhuICh0IDogdCkgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBJZGxlIHwgQWN0aXZlIChPcGVuIChXYWl0aW5nRm9yUGVlciB8IFBhcnRpYWxIZWFkZXJzIF8pLCBfKSAtPlxuICAgIGZhaWx3aXRoIFwiaDIuUmVxZC5yZXNwb25zZV9leG46IHJlc3BvbnNlIGhhcyBub3Qgc3RhcnRlZFwiXG4gIHwgQWN0aXZlXG4gICAgICAoIChPcGVuIChGdWxsSGVhZGVycyB8IEFjdGl2ZU1lc3NhZ2UgXykgfCBIYWxmQ2xvc2VkIF8pXG4gICAgICAsIHsgcmVzcG9uc2Vfc3RhdGU7IF8gfSApXG4gIHwgUmVzZXJ2ZWQgKF8sIHsgcmVzcG9uc2Vfc3RhdGU7IF8gfSkgLT5cbiAgICAobWF0Y2ggcmVzcG9uc2Vfc3RhdGUgd2l0aFxuICAgIHwgV2FpdGluZyAtPiBmYWlsd2l0aCBcImgyLlJlcWQucmVzcG9uc2VfZXhuOiByZXNwb25zZSBoYXMgbm90IHN0YXJ0ZWRcIlxuICAgIHwgU3RyZWFtaW5nIHsgcmVzcG9uc2U7IF8gfSB8IEZpeGVkIHsgcmVzcG9uc2U7IF8gfSB8IENvbXBsZXRlIHJlc3BvbnNlIC0+XG4gICAgICByZXNwb25zZSlcbiAgfCBDbG9zZWQgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHNlbmRfZml4ZWRfcmVzcG9uc2UgKHQgOiB0KSBzIHJlc3BvbnNlIGRhdGEgPVxuICBtYXRjaCBzLnJlc3BvbnNlX3N0YXRlIHdpdGhcbiAgfCBXYWl0aW5nIC0+XG4gICAgbGV0IGlvdmVjLCBsZW5ndGggPVxuICAgICAgbWF0Y2ggZGF0YSB3aXRoXG4gICAgICB8IGBTdHJpbmcgcyAtPlxuICAgICAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgICAgIGxldCBpb3ZlYyA9IHsgSHR0cGFmLklPVmVjLmJ1ZmZlciA9IGBTdHJpbmcgczsgb2ZmID0gMDsgbGVuIH0gaW5cbiAgICAgICAgaW92ZWMsIGxlblxuICAgICAgfCBgQmlnc3RyaW5nIGIgLT5cbiAgICAgICAgbGV0IGxlbiA9IEJpZ3N0cmluZ2FmLmxlbmd0aCBiIGluXG4gICAgICAgIGxldCBpb3ZlYyA9IHsgSHR0cGFmLklPVmVjLmJ1ZmZlciA9IGBCaWdzdHJpbmcgYjsgb2ZmID0gMDsgbGVuIH0gaW5cbiAgICAgICAgaW92ZWMsIGxlblxuICAgIGluXG4gICAgbGV0IHNob3VsZF9zZW5kX2RhdGEgPSBsZW5ndGggPD4gMCBpblxuICAgIGxldCBmcmFtZV9pbmZvID1cbiAgICAgIFdyaXRlci5tYWtlX2ZyYW1lX2luZm9cbiAgICAgICAgfm1heF9mcmFtZV9zaXplOnQubWF4X2ZyYW1lX3NpemVcbiAgICAgICAgfmZsYWdzOlxuICAgICAgICAgIChpZiBzaG91bGRfc2VuZF9kYXRhXG4gICAgICAgICAgIHRoZW4gRmxhZ3MuZGVmYXVsdF9mbGFnc1xuICAgICAgICAgICBlbHNlIEZsYWdzLihzZXRfZW5kX3N0cmVhbSBkZWZhdWx0X2ZsYWdzKSlcbiAgICAgICAgdC5pZFxuICAgIGluXG4gICAgV3JpdGVyLndyaXRlX3Jlc3BvbnNlX2hlYWRlcnMgdC53cml0ZXIgcy5lbmNvZGVyIGZyYW1lX2luZm8gcmVzcG9uc2U7XG4gICAgKCogRnJvbSBSRkM3NTQwwqc4LjE6XG4gICAgICogICBBbiBIVFRQIHJlcXVlc3QvcmVzcG9uc2UgZXhjaGFuZ2UgZnVsbHkgY29uc3VtZXMgYSBzaW5nbGUgc3RyZWFtLlxuICAgICAqICAgWy4uLl0gQSByZXNwb25zZSBzdGFydHMgd2l0aCBhIEhFQURFUlMgZnJhbWUgYW5kIGVuZHMgd2l0aCBhIGZyYW1lXG4gICAgICogICBiZWFyaW5nIEVORF9TVFJFQU0sIHdoaWNoIHBsYWNlcyB0aGUgc3RyZWFtIGluIHRoZSBcImNsb3NlZFwiIHN0YXRlLiAqKVxuICAgIGlmIHNob3VsZF9zZW5kX2RhdGFcbiAgICB0aGVuIHMucmVzcG9uc2Vfc3RhdGUgPC0gRml4ZWQgeyByZXNwb25zZTsgaW92ZWMgfVxuICAgIGVsc2Ugcy5yZXNwb25zZV9zdGF0ZSA8LSBDb21wbGV0ZSByZXNwb25zZTtcbiAgICBXcml0ZXIud2FrZXVwIHQud3JpdGVyXG4gIHwgU3RyZWFtaW5nIF8gLT4gZmFpbHdpdGggXCJoMi5SZXFkLnJlc3BvbmRfd2l0aF8qOiByZXNwb25zZSBhbHJlYWR5IHN0YXJ0ZWRcIlxuICB8IEZpeGVkIF8gLT4gZmFpbHdpdGggXCJoMi5SZXFkLnJlc3BvbmRfd2l0aF8qOiByZXNwb25zZSBhbHJlYWR5IHNlbnRcIlxuICB8IENvbXBsZXRlIF8gLT4gZmFpbHdpdGggXCJoMi5SZXFkLnJlc3BvbmRfd2l0aF8qOiByZXNwb25zZSBhbHJlYWR5IGNvbXBsZXRlXCJcblxubGV0IHNjaGVkdWxlX3RyYWlsZXJzICh0IDogdCkgbmV3X3RyYWlsZXJzID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSWRsZSB8IEFjdGl2ZSAoT3BlbiAoV2FpdGluZ0ZvclBlZXIgfCBQYXJ0aWFsSGVhZGVycyBfKSwgXykgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ2xvc2VkIF8gLT4gZmFpbHdpdGggXCJoMi5SZXFkLnNjaGVkdWxlX3RyYWlsZXJzOiBzdHJlYW0gYWxyZWFkeSBjbG9zZWRcIlxuICB8IFJlc2VydmVkIF8gLT4gZmFpbHdpdGggXCJoMi5SZXFkLnNjaGVkdWxlX3RyYWlsZXJzOiByZXNwb25zZSBub3Qgc3RhcnRlZFwiXG4gIHwgQWN0aXZlICgoT3BlbiAoRnVsbEhlYWRlcnMgfCBBY3RpdmVNZXNzYWdlIF8pIHwgSGFsZkNsb3NlZCBfKSwgc3RyZWFtKSAtPlxuICAgIChtYXRjaCBzdHJlYW0ucmVzcG9uc2Vfc3RhdGUgd2l0aFxuICAgIHwgU3RyZWFtaW5nIHsgcmVzcG9uc2U7IHJlc3BvbnNlX2JvZHk7IHRyYWlsZXJzID0gb2xkX3RyYWlsZXJzIH0gLT5cbiAgICAgIGlmIG9sZF90cmFpbGVycyA8PiBIZWFkZXJzLmVtcHR5XG4gICAgICB0aGVuIGZhaWx3aXRoIFwiaDIuUmVxZC5zY2hlZHVsZV90cmFpbGVyczogdHJhaWxlcnMgYWxyZWFkeSBzY2hlZHVsZWRcIjtcbiAgICAgIHN0cmVhbS5yZXNwb25zZV9zdGF0ZSA8LVxuICAgICAgICBTdHJlYW1pbmcgeyByZXNwb25zZTsgcmVzcG9uc2VfYm9keTsgdHJhaWxlcnMgPSBuZXdfdHJhaWxlcnMgfVxuICAgIHwgXyAtPlxuICAgICAgZmFpbHdpdGhcbiAgICAgICAgXCJoMi5SZXFkLnNjaGVkdWxlX3RyYWlsZXJzOiBjYW4gb25seSBzZW5kIHRyYWlsZXJzIGluIFN0cmVhbWluZyBtb2RlXCIpXG5cbmxldCB1bnNhZmVfcmVzcG9uZF93aXRoX2RhdGEgKHQgOiB0KSByZXNwb25zZSBkYXRhID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSWRsZSB8IEFjdGl2ZSAoT3BlbiAoV2FpdGluZ0ZvclBlZXIgfCBQYXJ0aWFsSGVhZGVycyBfKSwgXykgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQWN0aXZlICgoT3BlbiAoRnVsbEhlYWRlcnMgfCBBY3RpdmVNZXNzYWdlIF8pIHwgSGFsZkNsb3NlZCBfKSwgc3RyZWFtKSAtPlxuICAgIHNlbmRfZml4ZWRfcmVzcG9uc2UgdCBzdHJlYW0gcmVzcG9uc2UgZGF0YVxuICB8IFJlc2VydmVkIChyZXF1ZXN0X2luZm8sIHN0cmVhbSkgLT5cbiAgICBzZW5kX2ZpeGVkX3Jlc3BvbnNlIHQgc3RyZWFtIHJlc3BvbnNlIGRhdGE7XG4gICAgKCogRnJvbSBSRkM3NTQwwqc4LjE6XG4gICAgICogICByZXNlcnZlZCAobG9jYWwpOiBbLi4uXSBJbiB0aGlzIHN0YXRlLCBvbmx5IHRoZSBmb2xsb3dpbmcgdHJhbnNpdGlvbnNcbiAgICAgKiAgIGFyZSBwb3NzaWJsZTogVGhlIGVuZHBvaW50IGNhbiBzZW5kIGEgSEVBREVSUyBmcmFtZS4gVGhpcyBjYXVzZXMgdGhlXG4gICAgICogICBzdHJlYW0gdG8gb3BlbiBpbiBhIFwiaGFsZi1jbG9zZWQgKHJlbW90ZSlcIiBzdGF0ZS4gKilcbiAgICBXcml0ZXIuZmx1c2ggdC53cml0ZXIgKGZ1biAoKSAtPlxuICAgICAgdC5zdGF0ZSA8LSBBY3RpdmUgKEhhbGZDbG9zZWQgcmVxdWVzdF9pbmZvLCBzdHJlYW0pKVxuICB8IENsb3NlZCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVzcG9uZF93aXRoX3N0cmluZyAodCA6IHQpIHJlc3BvbnNlIHN0ciA9XG4gIG1hdGNoIHQuZXJyb3JfY29kZSB3aXRoXG4gIHwgTm9fZXJyb3IgLT4gdW5zYWZlX3Jlc3BvbmRfd2l0aF9kYXRhIHQgcmVzcG9uc2UgKGBTdHJpbmcgc3RyKVxuICB8IF8gLT5cbiAgICBmYWlsd2l0aFxuICAgICAgXCJoMi5SZXFkLnJlc3BvbmRfd2l0aF9zdHJpbmc6IGludmFsaWQgc3RhdGUsIGN1cnJlbnRseSBoYW5kbGluZyBlcnJvclwiXG5cbmxldCByZXNwb25kX3dpdGhfYmlnc3RyaW5nICh0IDogdCkgcmVzcG9uc2UgYnN0ciA9XG4gIG1hdGNoIHQuZXJyb3JfY29kZSB3aXRoXG4gIHwgTm9fZXJyb3IgLT4gdW5zYWZlX3Jlc3BvbmRfd2l0aF9kYXRhIHQgcmVzcG9uc2UgKGBCaWdzdHJpbmcgYnN0cilcbiAgfCBfIC0+XG4gICAgZmFpbHdpdGhcbiAgICAgIFwiaDIuUmVxZC5yZXNwb25kX3dpdGhfYmlnc3RyaW5nOiBpbnZhbGlkIHN0YXRlLCBjdXJyZW50bHkgaGFuZGxpbmcgZXJyb3JcIlxuXG5sZXQgc2VuZF9zdHJlYW1pbmdfcmVzcG9uc2UgfmZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHkgKHQgOiB0KSBzIHJlc3BvbnNlID1cbiAgbGV0IHdhaXRfZm9yX2ZpcnN0X2ZsdXNoID0gbm90IGZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHkgaW5cbiAgbWF0Y2ggcy5yZXNwb25zZV9zdGF0ZSB3aXRoXG4gIHwgV2FpdGluZyAtPlxuICAgIGxldCBmcmFtZV9pbmZvID1cbiAgICAgIFdyaXRlci5tYWtlX2ZyYW1lX2luZm8gfm1heF9mcmFtZV9zaXplOnQubWF4X2ZyYW1lX3NpemUgdC5pZFxuICAgIGluXG4gICAgbGV0IHJlc3BvbnNlX2JvZHlfYnVmZmVyID0gQmlnc3RyaW5nYWYuY3JlYXRlIHMuYm9keV9idWZmZXJfc2l6ZSBpblxuICAgIGxldCByZXNwb25zZV9ib2R5ID1cbiAgICAgIEJvZHkuV3JpdGVyLmNyZWF0ZSByZXNwb25zZV9ib2R5X2J1ZmZlciB+d3JpdGVyOnQud3JpdGVyXG4gICAgaW5cbiAgICBXcml0ZXIud3JpdGVfcmVzcG9uc2VfaGVhZGVycyB0LndyaXRlciBzLmVuY29kZXIgZnJhbWVfaW5mbyByZXNwb25zZTtcbiAgICBpZiB3YWl0X2Zvcl9maXJzdF9mbHVzaCB0aGVuIFdyaXRlci55aWVsZCB0LndyaXRlcjtcbiAgICBzLnJlc3BvbnNlX3N0YXRlIDwtXG4gICAgICBTdHJlYW1pbmcgeyByZXNwb25zZTsgcmVzcG9uc2VfYm9keTsgdHJhaWxlcnMgPSBIZWFkZXJzLmVtcHR5IH07XG4gICAgV3JpdGVyLndha2V1cCB0LndyaXRlcjtcbiAgICByZXNwb25zZV9ib2R5XG4gIHwgU3RyZWFtaW5nIF8gLT5cbiAgICBmYWlsd2l0aCBcImgyLlJlcWQucmVzcG9uZF93aXRoX3N0cmVhbWluZzogcmVzcG9uc2UgYWxyZWFkeSBzdGFydGVkXCJcbiAgfCBGaXhlZCBfIHwgQ29tcGxldGUgXyAtPlxuICAgIGZhaWx3aXRoIFwiaDIuUmVxZC5yZXNwb25kX3dpdGhfc3RyZWFtaW5nOiByZXNwb25zZSBhbHJlYWR5IGNvbXBsZXRlXCJcblxubGV0IHVuc2FmZV9yZXNwb25kX3dpdGhfc3RyZWFtaW5nICh0IDogdCkgfmZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHkgcmVzcG9uc2UgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBJZGxlIHwgQWN0aXZlIChPcGVuIChXYWl0aW5nRm9yUGVlciB8IFBhcnRpYWxIZWFkZXJzIF8pLCBfKSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBBY3RpdmUgKChPcGVuIChGdWxsSGVhZGVycyB8IEFjdGl2ZU1lc3NhZ2UgXykgfCBIYWxmQ2xvc2VkIF8pLCBzdHJlYW0pIC0+XG4gICAgc2VuZF9zdHJlYW1pbmdfcmVzcG9uc2UgfmZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHkgdCBzdHJlYW0gcmVzcG9uc2VcbiAgfCBSZXNlcnZlZCAocmVxdWVzdF9pbmZvLCBzdHJlYW0pIC0+XG4gICAgbGV0IHJlc3BvbnNlX2JvZHkgPVxuICAgICAgc2VuZF9zdHJlYW1pbmdfcmVzcG9uc2UgfmZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHkgdCBzdHJlYW0gcmVzcG9uc2VcbiAgICBpblxuICAgICgqIEZyb20gUkZDNzU0MMKnOC4xOlxuICAgICAqICAgcmVzZXJ2ZWQgKGxvY2FsKTogWy4uLl0gSW4gdGhpcyBzdGF0ZSwgb25seSB0aGUgZm9sbG93aW5nIHRyYW5zaXRpb25zXG4gICAgICogICBhcmUgcG9zc2libGU6IFRoZSBlbmRwb2ludCBjYW4gc2VuZCBhIEhFQURFUlMgZnJhbWUuIFRoaXMgY2F1c2VzIHRoZVxuICAgICAqICAgc3RyZWFtIHRvIG9wZW4gaW4gYSBcImhhbGYtY2xvc2VkIChyZW1vdGUpXCIgc3RhdGUuICopXG4gICAgV3JpdGVyLmZsdXNoIHQud3JpdGVyIChmdW4gKCkgLT5cbiAgICAgIHQuc3RhdGUgPC0gQWN0aXZlIChIYWxmQ2xvc2VkIHJlcXVlc3RfaW5mbywgc3RyZWFtKSk7XG4gICAgcmVzcG9uc2VfYm9keVxuICB8IENsb3NlZCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVzcG9uZF93aXRoX3N0cmVhbWluZyAodCA6IHQpID8oZmx1c2hfaGVhZGVyc19pbW1lZGlhdGVseSA9IGZhbHNlKSByZXNwb25zZVxuICA9XG4gIG1hdGNoIHQuZXJyb3JfY29kZSB3aXRoXG4gIHwgTm9fZXJyb3IgLT5cbiAgICB1bnNhZmVfcmVzcG9uZF93aXRoX3N0cmVhbWluZyB+Zmx1c2hfaGVhZGVyc19pbW1lZGlhdGVseSB0IHJlc3BvbnNlXG4gIHwgXyAtPlxuICAgIGZhaWx3aXRoXG4gICAgICBcImgyLlJlcWQucmVzcG9uZF93aXRoX3N0cmVhbWluZzogaW52YWxpZCBzdGF0ZSwgY3VycmVudGx5IGhhbmRsaW5nIGVycm9yXCJcblxubGV0IHN0YXJ0X3B1c2hfc3RyZWFtICh0IDogdCkgcyByZXF1ZXN0ID1cbiAgbWF0Y2ggcy5jcmVhdGVfcHVzaF9zdHJlYW0gdC5pZCB3aXRoXG4gIHwgT2sgcHJvbWlzZWRfcmVxZCAtPlxuICAgIGxldCBmcmFtZV9pbmZvID1cbiAgICAgIFdyaXRlci5tYWtlX2ZyYW1lX2luZm8gfm1heF9mcmFtZV9zaXplOnQubWF4X2ZyYW1lX3NpemUgdC5pZFxuICAgIGluXG4gICAgV3JpdGVyLndyaXRlX3B1c2hfcHJvbWlzZVxuICAgICAgdC53cml0ZXJcbiAgICAgIHMuZW5jb2RlclxuICAgICAgZnJhbWVfaW5mb1xuICAgICAgfnByb21pc2VkX2lkOnByb21pc2VkX3JlcWQuaWRcbiAgICAgIHJlcXVlc3Q7XG4gICAgbGV0IHsgZW5jb2RlcjsgYm9keV9idWZmZXJfc2l6ZTsgY3JlYXRlX3B1c2hfc3RyZWFtOyBfIH0gPSBzIGluXG4gICAgKCogRnJvbSBSRkM3NTQwwqc4LjI6XG4gICAgICogICBQcm9taXNlZCByZXF1ZXN0cyBbLi4uXSBNVVNUIE5PVCBpbmNsdWRlIGEgcmVxdWVzdCBib2R5LiAqKVxuICAgIGxldCByZXF1ZXN0X2luZm8gPSBjcmVhdGVfYWN0aXZlX3JlcXVlc3QgcmVxdWVzdCBCb2R5LlJlYWRlci5lbXB0eSBpblxuICAgIGxldCBhY3RpdmVfc3RyZWFtID1cbiAgICAgIGNyZWF0ZV9hY3RpdmVfc3RyZWFtIGVuY29kZXIgYm9keV9idWZmZXJfc2l6ZSBjcmVhdGVfcHVzaF9zdHJlYW1cbiAgICBpblxuICAgICgqIEZyb20gUkZDNzU0MMKnOC4yLjE6XG4gICAgICogICBTZW5kaW5nIGEgUFVTSF9QUk9NSVNFIGZyYW1lIGNyZWF0ZXMgYSBuZXcgc3RyZWFtIGFuZCBwdXRzIHRoZSBzdHJlYW1cbiAgICAgKiAgIGludG8gdGhlIFwicmVzZXJ2ZWQgKGxvY2FsKVwiIHN0YXRlIGZvciB0aGUgc2VydmVyIGFuZCB0aGUgXCJyZXNlcnZlZFxuICAgICAqICAgKHJlbW90ZSlcIiBzdGF0ZSBmb3IgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHdlIGRvIHRoaXMgYmVmb3JlIGZsdXNoaW5nIHRoZSB3cml0ZXIgYmVjYXVzZSByZXF1ZXN0IGhhbmRsZXJzXG4gICAgICogbWlnaHQgaW1tZWRpYXRlbHkgY2FsbCBvbmUgb2YgdGhlIGByZXNwb25kX3dpdGhgIGZ1bmN0aW9ucyBhbmQgZXhwZWN0XG4gICAgICogdGhlIHN0cmVhbSB0byBiZSBpbiB0aGUgYFJlc2VydmVkYCBzdGF0ZS4gKilcbiAgICBwcm9taXNlZF9yZXFkLnN0YXRlIDwtIFJlc2VydmVkIChyZXF1ZXN0X2luZm8sIGFjdGl2ZV9zdHJlYW0pO1xuICAgIFdyaXRlci53YWtldXAgdC53cml0ZXI7XG4gICAgT2sgcHJvbWlzZWRfcmVxZFxuICB8IEVycm9yIGUgLT5cbiAgICBFcnJvciAoZSA6PiBbIGBQdXNoX2Rpc2FibGVkIHwgYFN0cmVhbV9jYW50X3B1c2ggfCBgU3RyZWFtX2lkc19leGhhdXN0ZWQgXSlcblxuKCogVE9ETzogV2UgY291bGQgZWFzaWx5IGFsbG93IHRoZSBwcmlvcml0eSBvZiB0aGUgUFVTSCByZXF1ZXN0IHRvIGJlXG4gKiBjb25maWd1cmFibGUuIFdlIHNob3VsZCBhbGxvdyB1c2VycyBvZiB0aGlzIEFQSSB0byBkZWZpbmUgdGhlIHdlaWdodCAobWF5YmVcbiAqIG5vdCBzdHJpY3RseSksIGRlcGVuZGVuY3kgb24gdGhlIGN1cnJlbnQgUmVxZCwgYW5kIGV4Y2x1c2l2aXR5ICopXG5sZXQgdW5zYWZlX3B1c2ggKHQgOiB0KSByZXF1ZXN0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSWRsZSB8IEFjdGl2ZSAoT3BlbiAoV2FpdGluZ0ZvclBlZXIgfCBQYXJ0aWFsSGVhZGVycyBfKSwgXykgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQWN0aXZlICgoT3BlbiAoRnVsbEhlYWRlcnMgfCBBY3RpdmVNZXNzYWdlIF8pIHwgSGFsZkNsb3NlZCBfKSwgc3RyZWFtKSAtPlxuICAgIHN0YXJ0X3B1c2hfc3RyZWFtIHQgc3RyZWFtIHJlcXVlc3RcbiAgKCogQWxyZWFkeSBjaGVja2VkIGluIGBwdXNoYCAqKVxuICB8IFJlc2VydmVkIF8gfCBDbG9zZWQgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHB1c2ggKHQgOiB0KSByZXF1ZXN0ID1cbiAgbWF0Y2ggdC5lcnJvcl9jb2RlIHdpdGhcbiAgfCBOb19lcnJvciAtPlxuICAgIGlmIFN0cmVhbV9pZGVudGlmaWVyLmlzX3B1c2hlZCB0LmlkXG4gICAgdGhlblxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjY6XG4gICAgICAgKiAgIFBVU0hfUFJPTUlTRSBmcmFtZXMgTVVTVCBvbmx5IGJlIHNlbnQgb24gYSBwZWVyLWluaXRpYXRlZCBzdHJlYW0gdGhhdFxuICAgICAgICogICBpcyBpbiBlaXRoZXIgdGhlIFwib3BlblwiIG9yIFwiaGFsZi1jbG9zZWQgKHJlbW90ZSlcIiBzdGF0ZS4gKilcbiAgICAgIEVycm9yIGBTdHJlYW1fY2FudF9wdXNoXG4gICAgZWxzZSB1bnNhZmVfcHVzaCB0IHJlcXVlc3RcbiAgfCBfIC0+IGZhaWx3aXRoIFwiaDIuUmVxZC5wdXNoOiBpbnZhbGlkIHN0YXRlLCBjdXJyZW50bHkgaGFuZGxpbmcgZXJyb3JcIlxuXG5sZXQgX3JlcG9ydF9lcnJvciA/cmVxdWVzdCAodCA6IHQpIHMgKGVycm9yIDogZXJyb3IpIGVycm9yX2NvZGUgPVxuICBtYXRjaCBzLnJlc3BvbnNlX3N0YXRlLCB0LmVycm9yX2NvZGUgd2l0aFxuICB8IFdhaXRpbmcsIE5vX2Vycm9yIC0+XG4gICAgdC5lcnJvcl9jb2RlIDwtIFN0cmVhbS5lcnJvcl90b19jb2RlIGVycm9yIGVycm9yX2NvZGU7XG4gICAgbGV0IHN0YXR1cyA9XG4gICAgICBtYXRjaCAoZXJyb3IgOj4gWyBlcnJvciB8IFN0YXR1cy5zdGFuZGFyZCBdKSB3aXRoXG4gICAgICB8IGBFeG4gXyAtPiBgSW50ZXJuYWxfc2VydmVyX2Vycm9yXG4gICAgICB8ICNTdGF0dXMuc3RhbmRhcmQgYXMgc3RhdHVzIC0+IHN0YXR1c1xuICAgIGluXG4gICAgdC5lcnJvcl9oYW5kbGVyID9yZXF1ZXN0IGVycm9yIChmdW4gaGVhZGVycyAtPlxuICAgICAgbGV0IHJlc3BvbnNlID0gUmVzcG9uc2UuY3JlYXRlIH5oZWFkZXJzIHN0YXR1cyBpblxuICAgICAgdW5zYWZlX3Jlc3BvbmRfd2l0aF9zdHJlYW1pbmcgfmZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHk6dHJ1ZSB0IHJlc3BvbnNlKVxuICB8IFN0cmVhbWluZyB7IHJlc3BvbnNlX2JvZHk7IF8gfSwgTm9fZXJyb3IgLT5cbiAgICBCb2R5LldyaXRlci5jbG9zZSByZXNwb25zZV9ib2R5O1xuICAgIHQuZXJyb3JfY29kZSA8LSBTdHJlYW0uZXJyb3JfdG9fY29kZSBlcnJvciBlcnJvcl9jb2RlO1xuICAgIFN0cmVhbS5yZXNldF9zdHJlYW0gdCBlcnJvcl9jb2RlXG4gIHwgRml4ZWQgXywgTm9fZXJyb3IgLT5cbiAgICAoKiBTdGlsbCBuZWVkIHRvIHNlbmQgYW4gUlNUX1NUUkVBTSBmcmFtZS4gU2V0IHQuZXJyb3JfY29kZSB3aXRoXG4gICAgICogYGVycm9yX2NvZGVgIGFuZCBgZmx1c2hfcmVzcG9uc2VfYm9keWAgYmVsb3cgd2lsbCByZXNldCB0aGUgc3RyZWFtIGFmdGVyXG4gICAgICogZmx1c2hpbmcgYW55IHJlbWFpbmluZyBib2R5IGJ5dGVzLiAqKVxuICAgIHQuZXJyb3JfY29kZSA8LSBTdHJlYW0uZXJyb3JfdG9fY29kZSBlcnJvciBlcnJvcl9jb2RlO1xuICAgIFN0cmVhbS5yZXNldF9zdHJlYW0gdCBlcnJvcl9jb2RlXG4gIHwgKFdhaXRpbmcgfCBGaXhlZCBfIHwgU3RyZWFtaW5nIF8pLCBFeG4gXyAtPlxuICAgICgqIFhYWChzZWxpb3BvdSk6IERlY2lkZSB3aGF0IHRvIGRvIGluIHRoaXMgdW5saWtlbHkgY2FzZS4gVGhlcmUgaXMgYW5cbiAgICAgKiBvdXRzdGFuZGluZyBjYWxsIHRvIHRoZSBbZXJyb3JfaGFuZGxlcl0sIGJ1dCBhbiBpbnRlcnZlbmluZyBleGNlcHRpb25cbiAgICAgKiBoYXMgYmVlbiByZXBvcnRlZCBhcyB3ZWxsLiAqKVxuICAgIGZhaWx3aXRoIFwiaDIuUmVxZC5yZXBvcnRfZXhuOiBOWUlcIlxuICB8IChXYWl0aW5nIHwgU3RyZWFtaW5nIF8gfCBGaXhlZCBfIHwgQ29tcGxldGUgXyksIF8gLT4gKClcblxubGV0IHJlcG9ydF9lcnJvciAodCA6IHQpIGV4biBlcnJvcl9jb2RlID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSWRsZSB8IFJlc2VydmVkIF8gfCBBY3RpdmUgKE9wZW4gKFdhaXRpbmdGb3JQZWVyIHwgUGFydGlhbEhlYWRlcnMgXyksIF8pIC0+XG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgQWN0aXZlIChPcGVuIEZ1bGxIZWFkZXJzLCBzdHJlYW0pIC0+IF9yZXBvcnRfZXJyb3IgdCBzdHJlYW0gZXhuIGVycm9yX2NvZGVcbiAgfCBBY3RpdmVcbiAgICAgICggKCBPcGVuIChBY3RpdmVNZXNzYWdlIHsgcmVxdWVzdDsgcmVxdWVzdF9ib2R5OyBfIH0pXG4gICAgICAgIHwgSGFsZkNsb3NlZCB7IHJlcXVlc3Q7IHJlcXVlc3RfYm9keTsgXyB9IClcbiAgICAgICwgc3RyZWFtICkgLT5cbiAgICBCb2R5LlJlYWRlci5jbG9zZSByZXF1ZXN0X2JvZHk7XG4gICAgX3JlcG9ydF9lcnJvciB0IHN0cmVhbSB+cmVxdWVzdCBleG4gZXJyb3JfY29kZVxuICB8IENsb3NlZCBfIC0+ICgpXG5cbmxldCByZXBvcnRfZXhuIHQgZXhuID0gcmVwb3J0X2Vycm9yIHQgKGBFeG4gZXhuKSBFcnJvcl9jb2RlLkludGVybmFsRXJyb3JcblxubGV0IHRyeV93aXRoIHQgZiA6ICh1bml0LCBleG4pIHJlc3VsdCA9XG4gIHRyeVxuICAgIGYgKCk7XG4gICAgT2sgKClcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIHJlcG9ydF9leG4gdCBleG47XG4gICAgRXJyb3IgZXhuXG5cbmxldCBlcnJvcl9jb2RlID0gU3RyZWFtLmVycm9yX2NvZGVcbigqIFByaXZhdGUgQVBJLCBub3QgZXhwb3NlZCB0byB0aGUgdXNlciB0aHJvdWdoIGgyLm1saSAqKVxuXG5sZXQgcmVxdWlyZXNfb3V0cHV0ICh0IDogdCkgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBJZGxlIC0+IGZhbHNlXG4gIHwgUmVzZXJ2ZWQgXyAtPiB0cnVlXG4gIHwgQWN0aXZlIChPcGVuIChXYWl0aW5nRm9yUGVlciB8IFBhcnRpYWxIZWFkZXJzIF8pLCBfKSAtPiBmYWxzZVxuICB8IEFjdGl2ZVxuICAgICAgKCAoT3BlbiAoRnVsbEhlYWRlcnMgfCBBY3RpdmVNZXNzYWdlIF8pIHwgSGFsZkNsb3NlZCBfKVxuICAgICAgLCB7IHJlc3BvbnNlX3N0YXRlOyBfIH0gKSAtPlxuICAgICgqIEZyb20gUkZDNzU0MMKnOC4xOlxuICAgICAqICAgQSBzZXJ2ZXIgY2FuIHNlbmQgYSBjb21wbGV0ZSByZXNwb25zZSBwcmlvciB0byB0aGUgY2xpZW50IHNlbmRpbmcgYW5cbiAgICAgKiAgIGVudGlyZSByZXF1ZXN0IGlmIHRoZSByZXNwb25zZSBkb2VzIG5vdCBkZXBlbmQgb24gYW55IHBvcnRpb24gb2YgdGhlXG4gICAgICogICByZXF1ZXN0IHRoYXQgaGFzIG5vdCBiZWVuIHNlbnQgYW5kIHJlY2VpdmVkLiAqKVxuICAgIChtYXRjaCByZXNwb25zZV9zdGF0ZSB3aXRoXG4gICAgfCBDb21wbGV0ZSBfIC0+IGZhbHNlXG4gICAgfCBGaXhlZCB7IGlvdmVjID0geyBsZW47IF8gfTsgXyB9IC0+IGxlbiA+IDBcbiAgICB8IFN0cmVhbWluZyBfIC0+IHRydWVcbiAgICB8IFdhaXRpbmcgLT4gdHJ1ZSlcbiAgfCBDbG9zZWQgXyAtPiBmYWxzZVxuXG5sZXQgZmx1c2hfcmVxdWVzdF9ib2R5ICh0IDogdCkgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBBY3RpdmVcbiAgICAgICggKCBPcGVuIChBY3RpdmVNZXNzYWdlIHsgcmVxdWVzdF9ib2R5OyBfIH0pXG4gICAgICAgIHwgSGFsZkNsb3NlZCB7IHJlcXVlc3RfYm9keTsgXyB9IClcbiAgICAgICwgXyApIC0+XG4gICAgaWYgQm9keS5SZWFkZXIuaGFzX3BlbmRpbmdfb3V0cHV0IHJlcXVlc3RfYm9keVxuICAgIHRoZW4gKFxuICAgICAgdHJ5IEJvZHkuUmVhZGVyLmV4ZWN1dGVfcmVhZCByZXF1ZXN0X2JvZHkgd2l0aCBleG4gLT4gcmVwb3J0X2V4biB0IGV4bilcbiAgfCBfIC0+ICgpXG5cbmxldCB3cml0ZV9idWZmZXJfZGF0YSB3cml0ZXIgfm9mZiB+bGVuIGZyYW1lX2luZm8gYnVmZmVyID1cbiAgbWF0Y2ggYnVmZmVyIHdpdGhcbiAgfCBgU3RyaW5nIHN0ciAtPiBXcml0ZXIud3JpdGVfZGF0YSB3cml0ZXIgfm9mZiB+bGVuIGZyYW1lX2luZm8gc3RyXG4gIHwgYEJpZ3N0cmluZyBic3RyIC0+IFdyaXRlci5zY2hlZHVsZV9kYXRhIHdyaXRlciB+b2ZmIH5sZW4gZnJhbWVfaW5mbyBic3RyXG5cbmxldCBjbG9zZV9zdHJlYW0gKHQgOiB0KSA9XG4gIG1hdGNoIHQuZXJyb3JfY29kZSB3aXRoXG4gIHwgTm9fZXJyb3IgLT5cbiAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgfCBBY3RpdmUgKE9wZW4gKEZ1bGxIZWFkZXJzIHwgQWN0aXZlTWVzc2FnZSBfKSwgXykgLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnOC4xOlxuICAgICAgICogICBBIHNlcnZlciBjYW4gc2VuZCBhIGNvbXBsZXRlIHJlc3BvbnNlIHByaW9yIHRvIHRoZSBjbGllbnQgc2VuZGluZyBhblxuICAgICAgICogICBlbnRpcmUgcmVxdWVzdCBpZiB0aGUgcmVzcG9uc2UgZG9lcyBub3QgZGVwZW5kIG9uIGFueSBwb3J0aW9uIG9mIHRoZVxuICAgICAgICogICByZXF1ZXN0IHRoYXQgaGFzIG5vdCBiZWVuIHNlbnQgYW5kIHJlY2VpdmVkLiBXaGVuIHRoaXMgaXMgdHJ1ZSwgYVxuICAgICAgICogICBzZXJ2ZXIgTUFZIHJlcXVlc3QgdGhhdCB0aGUgY2xpZW50IGFib3J0IHRyYW5zbWlzc2lvbiBvZiBhIHJlcXVlc3RcbiAgICAgICAqICAgd2l0aG91dCBlcnJvciBieSBzZW5kaW5nIGEgUlNUX1NUUkVBTSB3aXRoIGFuIGVycm9yIGNvZGUgb2YgTk9fRVJST1JcbiAgICAgICAqICAgYWZ0ZXIgc2VuZGluZyBhIGNvbXBsZXRlIHJlc3BvbnNlIChpLmUuLCBhIGZyYW1lIHdpdGggdGhlIEVORF9TVFJFQU1cbiAgICAgICAqICAgZmxhZykuICopXG4gICAgICBTdHJlYW0ucmVzZXRfc3RyZWFtIHQgRXJyb3JfY29kZS5Ob0Vycm9yXG4gICAgfCBBY3RpdmUgKEhhbGZDbG9zZWQgXywgXykgLT5cbiAgICAgIFdyaXRlci5mbHVzaCB0LndyaXRlciAoZnVuICgpIC0+IFN0cmVhbS5maW5pc2hfc3RyZWFtIHQgRmluaXNoZWQpXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgfCBFeG4gXyAtPiBTdHJlYW0ucmVzZXRfc3RyZWFtIHQgSW50ZXJuYWxFcnJvclxuICB8IE90aGVyIHsgY29kZTsgXyB9IC0+IFN0cmVhbS5yZXNldF9zdHJlYW0gdCBjb2RlXG5cbmxldCBmbHVzaF9yZXNwb25zZV9ib2R5ICh0IDogdCkgfm1heF9ieXRlcyA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IEFjdGl2ZSAoKE9wZW4gXyB8IEhhbGZDbG9zZWQgXyksIHN0cmVhbSkgLT5cbiAgICAobWF0Y2ggc3RyZWFtLnJlc3BvbnNlX3N0YXRlIHdpdGhcbiAgICB8IFN0cmVhbWluZyB7IHJlc3BvbnNlOyByZXNwb25zZV9ib2R5OyB0cmFpbGVycyB9IC0+XG4gICAgICBpZiBCb2R5LldyaXRlci5oYXNfcGVuZGluZ19vdXRwdXQgcmVzcG9uc2VfYm9keSAmJiBtYXhfYnl0ZXMgPiAwXG4gICAgICB0aGVuXG4gICAgICAgIEJvZHkuV3JpdGVyLnRyYW5zZmVyX3RvX3dyaXRlclxuICAgICAgICAgIHJlc3BvbnNlX2JvZHlcbiAgICAgICAgICB0LndyaXRlclxuICAgICAgICAgIH5tYXhfZnJhbWVfc2l6ZTp0Lm1heF9mcmFtZV9zaXplXG4gICAgICAgICAgfm1heF9ieXRlc1xuICAgICAgICAgIHQuaWRcbiAgICAgIGVsc2UgaWYgQm9keS5Xcml0ZXIuaXNfY2xvc2VkIHJlc3BvbnNlX2JvZHlcbiAgICAgIHRoZW4gKFxuICAgICAgICAoKiBubyBwZW5kaW5nIG91dHB1dCBhbmQgY2xvc2VkLCB3ZSBjYW4gZmluYWxpemUgdGhlIG1lc3NhZ2UgYW5kIGNsb3NlXG4gICAgICAgICAgIHRoZSBzdHJlYW0gKilcbiAgICAgICAgbGV0IGZyYW1lX2luZm8gPVxuICAgICAgICAgIFdyaXRlci5tYWtlX2ZyYW1lX2luZm9cbiAgICAgICAgICAgIH5tYXhfZnJhbWVfc2l6ZTp0Lm1heF9mcmFtZV9zaXplXG4gICAgICAgICAgICB+ZmxhZ3M6RmxhZ3MuKHNldF9lbmRfc3RyZWFtIGRlZmF1bHRfZmxhZ3MpXG4gICAgICAgICAgICB0LmlkXG4gICAgICAgIGluXG4gICAgICAgIG1hdGNoIHRyYWlsZXJzIHdpdGhcbiAgICAgICAgfCBfIDo6IF8gLT5cbiAgICAgICAgICBXcml0ZXIud3JpdGVfcmVzcG9uc2VfdHJhaWxlcnNcbiAgICAgICAgICAgIHQud3JpdGVyXG4gICAgICAgICAgICBzdHJlYW0uZW5jb2RlclxuICAgICAgICAgICAgZnJhbWVfaW5mb1xuICAgICAgICAgICAgdHJhaWxlcnM7XG4gICAgICAgICAgY2xvc2Vfc3RyZWFtIHQ7XG4gICAgICAgICAgc3RyZWFtLnJlc3BvbnNlX3N0YXRlIDwtIENvbXBsZXRlIHJlc3BvbnNlO1xuICAgICAgICAgIDBcbiAgICAgICAgfCBbXSAtPlxuICAgICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi45LjE6XG4gICAgICAgICAgICogICBGcmFtZXMgd2l0aCB6ZXJvIGxlbmd0aCB3aXRoIHRoZSBFTkRfU1RSRUFNIGZsYWcgc2V0ICh0aGF0IGlzLFxuICAgICAgICAgICAqICAgYW4gZW1wdHkgREFUQSBmcmFtZSkgTUFZIGJlIHNlbnQgaWYgdGhlcmUgaXMgbm8gYXZhaWxhYmxlIHNwYWNlXG4gICAgICAgICAgICogICBpbiBlaXRoZXIgZmxvdy1jb250cm9sIHdpbmRvdy4gKilcbiAgICAgICAgICBXcml0ZXIuc2NoZWR1bGVfZGF0YSB0LndyaXRlciBmcmFtZV9pbmZvIH5sZW46MCBCaWdzdHJpbmdhZi5lbXB0eTtcbiAgICAgICAgICBjbG9zZV9zdHJlYW0gdDtcbiAgICAgICAgICBzdHJlYW0ucmVzcG9uc2Vfc3RhdGUgPC0gQ29tcGxldGUgcmVzcG9uc2U7XG4gICAgICAgICAgMClcbiAgICAgIGVsc2UgKCogbm8gcGVuZGluZyBvdXRwdXQgYnV0IEJvZHkgaXMgc3RpbGwgb3BlbiAqKVxuICAgICAgICAwXG4gICAgfCBGaXhlZCAoeyBpb3ZlYyA9IHsgYnVmZmVyOyBvZmY7IGxlbiB9IGFzIGlvdmVjOyBfIH0gYXMgcilcbiAgICAgIHdoZW4gbWF4X2J5dGVzID4gMCAtPlxuICAgICAgbGV0IGlzX3BhcnRpYWxfZmx1c2ggPSBtYXhfYnl0ZXMgPCBsZW4gaW5cbiAgICAgIGxldCBmcmFtZV9pbmZvID1cbiAgICAgICAgbGV0IGZsYWdzID1cbiAgICAgICAgICBpZiBpc19wYXJ0aWFsX2ZsdXNoXG4gICAgICAgICAgdGhlbiBGbGFncy5kZWZhdWx0X2ZsYWdzXG4gICAgICAgICAgZWxzZSBGbGFncy4oc2V0X2VuZF9zdHJlYW0gZGVmYXVsdF9mbGFncylcbiAgICAgICAgaW5cbiAgICAgICAgV3JpdGVyLm1ha2VfZnJhbWVfaW5mbyB+bWF4X2ZyYW1lX3NpemU6dC5tYXhfZnJhbWVfc2l6ZSB+ZmxhZ3MgdC5pZFxuICAgICAgaW5cbiAgICAgIGxldCBsZW5fdG9fd3JpdGUgPSBpZiBpc19wYXJ0aWFsX2ZsdXNoIHRoZW4gbWF4X2J5dGVzIGVsc2UgbGVuIGluXG4gICAgICB3cml0ZV9idWZmZXJfZGF0YSB0LndyaXRlciB+b2ZmIH5sZW46bGVuX3RvX3dyaXRlIGZyYW1lX2luZm8gYnVmZmVyO1xuICAgICAgci5pb3ZlYyA8LSBIdHRwYWYuSU9WZWMuc2hpZnQgaW92ZWMgbGVuX3RvX3dyaXRlO1xuICAgICAgaWYgbm90IGlzX3BhcnRpYWxfZmx1c2ggdGhlbiBjbG9zZV9zdHJlYW0gdDtcbiAgICAgIGxlbl90b193cml0ZVxuICAgIHwgRml4ZWQgXyB8IFdhaXRpbmcgfCBDb21wbGV0ZSBfIC0+IDApXG4gIHwgXyAtPiAwXG5cbmxldCBkZWxpdmVyX3RyYWlsZXJfaGVhZGVycyAodCA6IHQpIGhlYWRlcnMgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBBY3RpdmUgKE9wZW4gKFBhcnRpYWxIZWFkZXJzIF8gfCBGdWxsSGVhZGVycyksIF8pIC0+IGFzc2VydCBmYWxzZVxuICB8IEFjdGl2ZSAoKE9wZW4gKEFjdGl2ZU1lc3NhZ2UgXykgfCBIYWxmQ2xvc2VkIF8pLCBzdHJlYW0pIC0+XG4gICAgKCogVE9ETzogY2FsbCB0aGUgc2NoZWR1bGVfdHJhaWxlcnMgY2FsbGJhY2sgKilcbiAgICBzdHJlYW0udHJhaWxlcnMgPC0gU29tZSBoZWFkZXJzXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAxOSBBbnTDs25pbyBOdW5vIE1vbnRlaXJvXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXNcbiAqICBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiAgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiAgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqICBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbm1vZHVsZSBTdHJlYW1zVGJsID0gc3RydWN0XG4gIGluY2x1ZGUgSGFzaHRibC5NYWtlU2VlZGVkIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IFN0cmVhbV9pZGVudGlmaWVyLnRcblxuICAgICAgbGV0IGVxdWFsID0gU3RyZWFtX2lkZW50aWZpZXIuKCA9PT0gKVxuICAgICAgbGV0IGhhc2ggaSBrID0gSGFzaHRibC5zZWVkZWRfaGFzaCBpIGtcblxuICAgICAgKCogUmVxdWlyZWQgZm9yIE9DYW1sID49IDUuMC4wLCBidXQgY2F1c2VzIGVycm9ycyBmb3Igb2xkZXIgY29tcGlsZXJzXG4gICAgICAgICBiZWNhdXNlIGl0IGlzIGFuIHVudXNlZCB2YWx1ZSBkZWNsYXJhdGlvbi4gKilcbiAgICAgIGxldFtAd2FybmluZyBcIi0zMlwiXSBzZWVkZWRfaGFzaCA9IGhhc2hcbiAgICBlbmQpXG5cbiAgbGV0W0BpbmxpbmVdIGZpbmRfb3B0IGgga2V5ID0gdHJ5IFNvbWUgKGZpbmQgaCBrZXkpIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTdHJlYW1EZXNjcmlwdG9yID0gc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBpZCA6IHQgLT4gU3RyZWFtX2lkZW50aWZpZXIudFxuICB2YWwgcmVxdWlyZXNfb3V0cHV0IDogdCAtPiBib29sXG4gIHZhbCBmbHVzaF93cml0ZV9ib2R5IDogdCAtPiBtYXhfYnl0ZXM6aW50IC0+IGludFxuICB2YWwgZmluaXNoX3N0cmVhbSA6IHQgLT4gU3RyZWFtLmNsb3NlZF9yZWFzb24gLT4gdW5pdFxuICB2YWwgaXNfaWRsZSA6IHQgLT4gYm9vbFxuZW5kXG5cbm1vZHVsZSBNYWtlIChTdHJlYW1kIDogU3RyZWFtRGVzY3JpcHRvcikgPSBzdHJ1Y3RcbiAgbW9kdWxlIHJlYyBQcmlvcml0eVRyZWVOb2RlIDogc2lnXG4gICAgdHlwZSByb290ID0gUm9vdFxuICAgIHR5cGUgbm9ucm9vdCA9IE5vblJvb3RcblxuICAgIHR5cGUgc3RyZWFtID0gbm9ucm9vdCBub2RlXG4gICAgYW5kIHBhcmVudCA9IFBhcmVudCA6IF8gbm9kZSAtPiBwYXJlbnRcblxuICAgIGFuZCBfIG5vZGUgPVxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc1LjMuMTpcbiAgICAgICAqICAgQSBzdHJlYW0gdGhhdCBpcyBub3QgZGVwZW5kZW50IG9uIGFueSBvdGhlciBzdHJlYW0gaXMgZ2l2ZW4gYSBzdHJlYW1cbiAgICAgICAqICAgZGVwZW5kZW5jeSBvZiAweDAuIEluIG90aGVyIHdvcmRzLCB0aGUgbm9uLWV4aXN0ZW50IHN0cmVhbSAwIGZvcm1zXG4gICAgICAgKiAgIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6XG4gICAgICAgKiAgIFdlIHVzZSBhIEdBRFQgYmVjYXVzZSB0aGUgcm9vdCBvZiB0aGUgdHJlZSBkb2Vzbid0IGhhdmUgYW5cbiAgICAgICAqICAgYXNzb2NpYXRlZCByZXF1ZXN0IGRlc2NyaXB0b3IuIEl0IGhhcyB0aGUgYWRkZWQgYWR2YW50YWdlIG9mXG4gICAgICAgKiAgIGFsbG93aW5nIHVzIHRvIGVuZm9yY2UgdGhhdCBhbGwgKG90aGVyKSBzdHJlYW1zIGluIHRoZSB0cmVlIGFyZVxuICAgICAgICogICBhc3NvY2lhdGVkIHdpdGggYSByZXF1ZXN0IGRlc2NyaXB0b3IuICopXG4gICAgICB8IENvbm5lY3Rpb24gOlxuICAgICAgICAgIHsgYWxsX3N0cmVhbXMgOiBzdHJlYW0gU3RyZWFtc1RibC50XG4gICAgICAgICAgOyBtdXRhYmxlIHRfbGFzdCA6IGludFxuICAgICAgICAgIDsgbXV0YWJsZSBjaGlsZHJlbiA6IFByaW9yaXR5UXVldWUudFxuICAgICAgICAgIDsgKCogQ29ubmVjdGlvbi1sZXZlbCBmbG93IGNvbnRyb2wgd2luZG93LlxuICAgICAgICAgICAgICogb3V0Ym91bmQgZmxvdyBjb250cm9sLCB3aGF0IHdlJ3JlIGFsbG93ZWQgdG8gc2VuZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGcm9tIFJGQzc1NDDCpzYuOS4xOlxuICAgICAgICAgICAgICogICBUd28gZmxvdy1jb250cm9sIHdpbmRvd3MgYXJlIGFwcGxpY2FibGU6IHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAqIGZsb3ctY29udHJvbCB3aW5kb3cgYW5kIHRoZSBjb25uZWN0aW9uIGZsb3ctY29udHJvbCB3aW5kb3cuICopXG4gICAgICAgICAgICBtdXRhYmxlIGZsb3cgOiBTZXR0aW5ncy5XaW5kb3dTaXplLnRcbiAgICAgICAgICA7ICgqIGluYm91bmQgZmxvdyBjb250cm9sLCB3aGF0IHRoZSBjbGllbnQgaXMgYWxsb3dlZCB0byBzZW5kLiAqKVxuICAgICAgICAgICAgbXV0YWJsZSBpbmZsb3cgOiBTZXR0aW5ncy5XaW5kb3dTaXplLnRcbiAgICAgICAgICA7IG11dGFibGUgbWFya2VkX2Zvcl9yZW1vdmFsIDogU3RyZWFtLmNsb3NlZCBTdHJlYW1zVGJsLnRcbiAgICAgICAgICB9XG4gICAgICAgICAgLT4gcm9vdCBub2RlXG4gICAgICB8IFN0cmVhbSA6XG4gICAgICAgICAgeyBkZXNjcmlwdG9yIDogU3RyZWFtZC50XG4gICAgICAgICAgOyBtdXRhYmxlIHRfbGFzdCA6IGludFxuICAgICAgICAgIDsgbXV0YWJsZSB0IDogaW50XG4gICAgICAgICAgOyBtdXRhYmxlIHByaW9yaXR5IDogUHJpb3JpdHkudFxuICAgICAgICAgIDsgbXV0YWJsZSBwYXJlbnQgOiBwYXJlbnRcbiAgICAgICAgICA7IG11dGFibGUgY2hpbGRyZW4gOiBQcmlvcml0eVF1ZXVlLnRcbiAgICAgICAgICA7ICgqIFN0cmVhbS1sZXZlbCBmbG93IGNvbnRyb2wgd2luZG93LiBTZWUgY29ubmVjdGlvbi1sZXZlbCBhYm92ZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGcm9tIFJGQzc1NDDCpzYuOS4xOlxuICAgICAgICAgICAgICogICBUd28gZmxvdy1jb250cm9sIHdpbmRvd3MgYXJlIGFwcGxpY2FibGU6IHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAqIGZsb3ctY29udHJvbCB3aW5kb3cgYW5kIHRoZSBjb25uZWN0aW9uIGZsb3ctY29udHJvbCB3aW5kb3cuICopXG4gICAgICAgICAgICBtdXRhYmxlIGZsb3cgOiBTZXR0aW5ncy5XaW5kb3dTaXplLnRcbiAgICAgICAgICA7IG11dGFibGUgaW5mbG93IDogU2V0dGluZ3MuV2luZG93U2l6ZS50XG4gICAgICAgICAgfVxuICAgICAgICAgIC0+IG5vbnJvb3Qgbm9kZVxuICBlbmQgPVxuICAgIFByaW9yaXR5VHJlZU5vZGVcblxuICBhbmQgUHJpb3JpdHlRdWV1ZSA6XG4gICAgKFBzcS5TIHdpdGggdHlwZSBrID0gSW50MzIudCBhbmQgdHlwZSBwID0gUHJpb3JpdHlUcmVlTm9kZS5zdHJlYW0pID1cbiAgICBQc3EuTWFrZVxuICAgICAgKEludDMyKVxuICAgICAgKHN0cnVjdFxuICAgICAgICBpbmNsdWRlIFByaW9yaXR5VHJlZU5vZGVcblxuICAgICAgICB0eXBlIHQgPSBzdHJlYW1cblxuICAgICAgICBsZXQgY29tcGFyZSAoU3RyZWFtIHsgdCA9IHQxOyBfIH0pIChTdHJlYW0geyB0ID0gdDI7IF8gfSkgPVxuICAgICAgICAgIGNvbXBhcmUgdDEgdDJcbiAgICAgIGVuZClcblxuICBpbmNsdWRlIFByaW9yaXR5VHJlZU5vZGVcblxuICB0eXBlIHQgPSByb290IG5vZGVcblxuICAoKiBUT0RPKGFubW9udGVpcm8pOiBjaGFuZ2UgYWNjb3JkaW5nIHRvIFNFVFRJTkdTX01BWF9DT05DVVJSRU5UX1NUUkVBTVM/ICopXG4gIGxldCBtYWtlX3Jvb3QgPyhjYXBhY2l0eSA9IDY1NTM2KSAoKSA9XG4gICAgQ29ubmVjdGlvblxuICAgICAgeyB0X2xhc3QgPSAwXG4gICAgICA7IGNoaWxkcmVuID0gUHJpb3JpdHlRdWV1ZS5lbXB0eVxuICAgICAgOyBhbGxfc3RyZWFtcyA9IFN0cmVhbXNUYmwuY3JlYXRlIH5yYW5kb206dHJ1ZSBjYXBhY2l0eVxuICAgICAgOyBmbG93ID0gU2V0dGluZ3MuV2luZG93U2l6ZS5kZWZhdWx0X2luaXRpYWxfd2luZG93X3NpemVcbiAgICAgIDsgaW5mbG93ID0gU2V0dGluZ3MuV2luZG93U2l6ZS5kZWZhdWx0X2luaXRpYWxfd2luZG93X3NpemVcbiAgICAgIDsgbWFya2VkX2Zvcl9yZW1vdmFsID0gU3RyZWFtc1RibC5jcmVhdGUgfnJhbmRvbTp0cnVlIDI1NlxuICAgICAgfVxuXG4gIGxldCBjcmVhdGVcbiAgICAgIH5wYXJlbnRcbiAgICAgIH5pbml0aWFsX3NlbmRfd2luZG93X3NpemVcbiAgICAgIH5pbml0aWFsX3JlY3Zfd2luZG93X3NpemVcbiAgICAgIGRlc2NyaXB0b3JcbiAgICA9XG4gICAgU3RyZWFtXG4gICAgICB7IGRlc2NyaXB0b3JcbiAgICAgIDsgdF9sYXN0ID0gMFxuICAgICAgOyB0ID0gMFxuICAgICAgOyAoKiBGcm9tIFJGQzc1NDDCpzUuMy41OlxuICAgICAgICAgKiAgIEFsbCBzdHJlYW1zIGFyZSBpbml0aWFsbHkgYXNzaWduZWQgYSBub24tZXhjbHVzaXZlIGRlcGVuZGVuY3kgb25cbiAgICAgICAgICogICBzdHJlYW0gMHgwLiBQdXNoZWQgc3RyZWFtcyAoU2VjdGlvbiA4LjIpIGluaXRpYWxseSBkZXBlbmQgb24gdGhlaXJcbiAgICAgICAgICogICBhc3NvY2lhdGVkIHN0cmVhbS4gSW4gYm90aCBjYXNlcywgc3RyZWFtcyBhcmUgYXNzaWduZWQgYSBkZWZhdWx0XG4gICAgICAgICAqICAgd2VpZ2h0IG9mIDE2LiAqKVxuICAgICAgICBwcmlvcml0eSA9IFByaW9yaXR5LmRlZmF1bHRfcHJpb3JpdHlcbiAgICAgIDsgcGFyZW50XG4gICAgICA7IGNoaWxkcmVuID0gUHJpb3JpdHlRdWV1ZS5lbXB0eVxuICAgICAgOyBmbG93ID0gaW5pdGlhbF9zZW5kX3dpbmRvd19zaXplXG4gICAgICA7IGluZmxvdyA9IGluaXRpYWxfcmVjdl93aW5kb3dfc2l6ZVxuICAgICAgfVxuXG4gIGxldCBzdHJlYW1faWQgOiB0eXBlIGEuIGEgbm9kZSAtPiBpbnQzMiA9IGZ1bmN0aW9uXG4gICAgfCBDb25uZWN0aW9uIF8gLT4gU3RyZWFtX2lkZW50aWZpZXIuY29ubmVjdGlvblxuICAgIHwgU3RyZWFtIHsgZGVzY3JpcHRvcjsgXyB9IC0+IFN0cmVhbWQuaWQgZGVzY3JpcHRvclxuXG4gIGxldCBjaGlsZHJlbiA6IHR5cGUgYS4gYSBub2RlIC0+IFByaW9yaXR5UXVldWUudCA9IGZ1bmN0aW9uXG4gICAgfCBTdHJlYW0geyBjaGlsZHJlbjsgXyB9IC0+IGNoaWxkcmVuXG4gICAgfCBDb25uZWN0aW9uIHsgY2hpbGRyZW47IF8gfSAtPiBjaGlsZHJlblxuXG4gIGxldCByZW1vdmVfY2hpbGQgOiB0eXBlIGEuIGEgbm9kZSAtPiBpbnQzMiAtPiB1bml0ID1cbiAgIGZ1biBwYXJlbnQgaWQgLT5cbiAgICBtYXRjaCBwYXJlbnQgd2l0aFxuICAgIHwgQ29ubmVjdGlvbiAoeyBjaGlsZHJlbjsgXyB9IGFzIG5vZGUpIC0+XG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMy4xOlxuICAgICAgICogICBBIHN0cmVhbSB0aGF0IGlzIG5vdCBkZXBlbmRlbnQgb24gYW55IG90aGVyIHN0cmVhbSBpcyBnaXZlbiBhIHN0cmVhbVxuICAgICAgICogICBkZXBlbmRlbmN5IG9mIDB4MC4gSW4gb3RoZXIgd29yZHMsIHRoZSBub24tZXhpc3RlbnQgc3RyZWFtIDAgZm9ybXNcbiAgICAgICAqICAgdGhlIHJvb3Qgb2YgdGhlIHRyZWUuICopXG4gICAgICBub2RlLmNoaWxkcmVuIDwtIFByaW9yaXR5UXVldWUucmVtb3ZlIGlkIGNoaWxkcmVuXG4gICAgfCBTdHJlYW0gKHsgY2hpbGRyZW47IF8gfSBhcyBub2RlKSAtPlxuICAgICAgbm9kZS5jaGlsZHJlbiA8LSBQcmlvcml0eVF1ZXVlLnJlbW92ZSBpZCBjaGlsZHJlblxuXG4gIGxldCB1cGRhdGVfY2hpbGRyZW4gOiB0eXBlIGEuIGEgbm9kZSAtPiBQcmlvcml0eVF1ZXVlLnQgLT4gdW5pdCA9XG4gICBmdW4gcGFyZW50IHVwZGF0ZWRfY2hpbGRyZW4gLT5cbiAgICBtYXRjaCBwYXJlbnQgd2l0aFxuICAgIHwgQ29ubmVjdGlvbiBzIC0+IHMuY2hpbGRyZW4gPC0gdXBkYXRlZF9jaGlsZHJlblxuICAgIHwgU3RyZWFtIHMgLT4gcy5jaGlsZHJlbiA8LSB1cGRhdGVkX2NoaWxkcmVuXG5cbiAgbGV0IHNldF9wYXJlbnQgc3RyZWFtX25vZGUgfmV4Y2x1c2l2ZSAoUGFyZW50IG5ld19wYXJlbnRfbm9kZSBhcyBuZXdfcGFyZW50KSA9XG4gICAgbGV0IChTdHJlYW0gKHsgZGVzY3JpcHRvcjsgcGFyZW50ID0gUGFyZW50IG9sZF9wYXJlbnRfbm9kZTsgXyB9IGFzIHN0cmVhbSkpID1cbiAgICAgIHN0cmVhbV9ub2RlXG4gICAgaW5cbiAgICBsZXQgc3RyZWFtX2lkID0gU3RyZWFtZC5pZCBkZXNjcmlwdG9yIGluXG4gICAgcmVtb3ZlX2NoaWxkIG9sZF9wYXJlbnRfbm9kZSBzdHJlYW1faWQ7XG4gICAgc3RyZWFtLnBhcmVudCA8LSBuZXdfcGFyZW50O1xuICAgIGxldCBuZXdfY2hpbGRyZW4gPVxuICAgICAgbGV0IG5ld19jaGlsZHJlbiA9IGNoaWxkcmVuIG5ld19wYXJlbnRfbm9kZSBpblxuICAgICAgaWYgZXhjbHVzaXZlXG4gICAgICB0aGVuIChcbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc1LjMuMzpcbiAgICAgICAgICogICBEZXBlbmRlbnQgc3RyZWFtcyBtb3ZlIHdpdGggdGhlaXIgcGFyZW50IHN0cmVhbSBpZiB0aGUgcGFyZW50IGlzXG4gICAgICAgICAqICAgcmVwcmlvcml0aXplZC4gU2V0dGluZyBhIGRlcGVuZGVuY3kgd2l0aCB0aGUgZXhjbHVzaXZlIGZsYWcgZm9yIGFcbiAgICAgICAgICogICByZXByaW9yaXRpemVkIHN0cmVhbSBjYXVzZXMgYWxsIHRoZSBkZXBlbmRlbmNpZXMgb2YgdGhlIG5ldyBwYXJlbnRcbiAgICAgICAgICogICBzdHJlYW0gdG8gYmVjb21lIGRlcGVuZGVudCBvbiB0aGUgcmVwcmlvcml0aXplZCBzdHJlYW0uICopXG4gICAgICAgIHN0cmVhbS5jaGlsZHJlbiA8LVxuICAgICAgICAgIFByaW9yaXR5UXVldWUuZm9sZFxuICAgICAgICAgICAgKGZ1biBrIChTdHJlYW0gcCBhcyBwX25vZGUpIHBxIC0+XG4gICAgICAgICAgICAgICBwLnBhcmVudCA8LSBQYXJlbnQgc3RyZWFtX25vZGU7XG4gICAgICAgICAgICAgICBQcmlvcml0eVF1ZXVlLmFkZCBrIHBfbm9kZSBwcSlcbiAgICAgICAgICAgIHN0cmVhbS5jaGlsZHJlblxuICAgICAgICAgICAgbmV3X2NoaWxkcmVuO1xuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMy4xOlxuICAgICAgICAgKiAgIEFuIGV4Y2x1c2l2ZSBmbGFnIGFsbG93cyBmb3IgdGhlIGluc2VydGlvbiBvZiBhIG5ldyBsZXZlbCBvZlxuICAgICAgICAgKiAgIGRlcGVuZGVuY2llcy4gVGhlIGV4Y2x1c2l2ZSBmbGFnIGNhdXNlcyB0aGUgc3RyZWFtIHRvIGJlY29tZSB0aGVcbiAgICAgICAgICogICBzb2xlIGRlcGVuZGVuY3kgb2YgaXRzIHBhcmVudCBzdHJlYW0sIGNhdXNpbmcgb3RoZXIgZGVwZW5kZW5jaWVzXG4gICAgICAgICAqICAgdG8gYmVjb21lIGRlcGVuZGVudCBvbiB0aGUgZXhjbHVzaXZlIHN0cmVhbS4gKilcbiAgICAgICAgUHJpb3JpdHlRdWV1ZS5zZyBzdHJlYW1faWQgc3RyZWFtX25vZGUpXG4gICAgICBlbHNlIFByaW9yaXR5UXVldWUuYWRkIHN0cmVhbV9pZCBzdHJlYW1fbm9kZSBuZXdfY2hpbGRyZW5cbiAgICBpblxuICAgIHVwZGF0ZV9jaGlsZHJlbiBuZXdfcGFyZW50X25vZGUgbmV3X2NoaWxkcmVuXG5cbiAgbGV0IHdvdWxkX2NyZWF0ZV9jeWNsZSB+bmV3X3BhcmVudCAoU3RyZWFtIHsgZGVzY3JpcHRvcjsgXyB9KSA9XG4gICAgbGV0IHJlYyBpbm5lciA6IHR5cGUgYS4gYSBub2RlIC0+IGJvb2wgPSBmdW5jdGlvblxuICAgICAgfCBDb25uZWN0aW9uIF8gLT4gZmFsc2VcbiAgICAgIHwgU3RyZWFtIHsgcGFyZW50ID0gUGFyZW50IHBhcmVudDsgXyB9XG4gICAgICAgIHdoZW4gU3RyZWFtX2lkZW50aWZpZXIuKHN0cmVhbV9pZCBwYXJlbnQgPT09IFN0cmVhbWQuaWQgZGVzY3JpcHRvcikgLT5cbiAgICAgICAgdHJ1ZVxuICAgICAgfCBTdHJlYW0geyBwYXJlbnQgPSBQYXJlbnQgcGFyZW50OyBfIH0gLT4gaW5uZXIgcGFyZW50XG4gICAgaW5cbiAgICBsZXQgKFBhcmVudCBwYXJlbnRfbm9kZSkgPSBuZXdfcGFyZW50IGluXG4gICAgaW5uZXIgcGFyZW50X25vZGVcblxuICBsZXQgcmVwcmlvcml0aXplX3N0cmVhbSAoQ29ubmVjdGlvbiByb290IGFzIHQpIH5wcmlvcml0eSBzdHJlYW1fbm9kZSA9XG4gICAgbGV0IChTdHJlYW0gc3RyZWFtKSA9IHN0cmVhbV9ub2RlIGluXG4gICAgbGV0IG5ld19wYXJlbnQsIG5ld19wcmlvcml0eSA9XG4gICAgICBpZiBTdHJlYW1faWRlbnRpZmllci5pc19jb25uZWN0aW9uIHByaW9yaXR5LlByaW9yaXR5LnN0cmVhbV9kZXBlbmRlbmN5XG4gICAgICB0aGVuIFBhcmVudCB0LCBwcmlvcml0eVxuICAgICAgZWxzZVxuICAgICAgICBtYXRjaFxuICAgICAgICAgIFN0cmVhbXNUYmwuZmluZF9vcHQgcm9vdC5hbGxfc3RyZWFtcyBwcmlvcml0eS5zdHJlYW1fZGVwZW5kZW5jeVxuICAgICAgICB3aXRoXG4gICAgICAgIHwgU29tZSBwYXJlbnRfc3RyZWFtIC0+XG4gICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgU3RyZWFtc1RibC5tZW0gcm9vdC5tYXJrZWRfZm9yX3JlbW92YWwgcHJpb3JpdHkuc3RyZWFtX2RlcGVuZGVuY3lcbiAgICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgICAgKCogQSBzdHJlYW0gdGhhdCBpcyBtYXJrZWQgZm9yIHJlbW92YWwgaXMgYWxzbyBub3QgcHJlc2VudCBpbiB0aGVcbiAgICAgICAgICAgICAgIHRyZWUgKilcbiAgICAgICAgICAgIFBhcmVudCB0LCBQcmlvcml0eS5kZWZhdWx0X3ByaW9yaXR5XG4gICAgICAgICAgfCBmYWxzZSAtPiBQYXJlbnQgcGFyZW50X3N0cmVhbSwgcHJpb3JpdHkpXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4zLjE6XG4gICAgICAgICAgICogICBBIGRlcGVuZGVuY3kgb24gYSBzdHJlYW0gdGhhdCBpcyBub3QgY3VycmVudGx5IGluIHRoZSB0cmVlIOKAlFxuICAgICAgICAgICAqICAgc3VjaCBhcyBhIHN0cmVhbSBpbiB0aGUgXCJpZGxlXCIgc3RhdGUg4oCUIHJlc3VsdHMgaW4gdGhhdCBzdHJlYW1cbiAgICAgICAgICAgKiAgIGJlaW5nIGdpdmVuIGEgZGVmYXVsdCBwcmlvcml0eSAoU2VjdGlvbiA1LjMuNSkuICopXG4gICAgICAgICAgUGFyZW50IHQsIFByaW9yaXR5LmRlZmF1bHRfcHJpb3JpdHlcbiAgICBpblxuICAgICgqIGJhaWwgZWFybHkgaWYgdHJ5aW5nIHRvIHNldCB0aGUgc2FtZSBwcmlvcml0eSAqKVxuICAgIGlmIG5vdCAoUHJpb3JpdHkuZXF1YWwgc3RyZWFtLnByaW9yaXR5IG5ld19wcmlvcml0eSlcbiAgICB0aGVuIChcbiAgICAgIGxldCB7IFByaW9yaXR5LnN0cmVhbV9kZXBlbmRlbmN5OyBleGNsdXNpdmU7IF8gfSA9IG5ld19wcmlvcml0eSBpblxuICAgICAgbGV0IChQYXJlbnQgY3VycmVudF9wYXJlbnRfbm9kZSkgPSBzdHJlYW0ucGFyZW50IGluXG4gICAgICBsZXQgY3VycmVudF9wYXJlbnRfaWQgPSBzdHJlYW1faWQgY3VycmVudF9wYXJlbnRfbm9kZSBpblxuICAgICAgKCogb25seSBuZWVkIHRvIHNldCBhIGRpZmZlcmVudCBwYXJlbnQgaWYgdGhlIHBhcmVudCBvciBleGNsdXNpdmUgc3RhdHVzXG4gICAgICAgKiBjaGFuZ2VkICopXG4gICAgICBpZiAobm90IFN0cmVhbV9pZGVudGlmaWVyLihzdHJlYW1fZGVwZW5kZW5jeSA9PT0gY3VycmVudF9wYXJlbnRfaWQpKVxuICAgICAgICAgfHwgZXhjbHVzaXZlIDw+IHN0cmVhbS5wcmlvcml0eS5leGNsdXNpdmVcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgKFBhcmVudCBuZXdfcGFyZW50X25vZGUpID0gbmV3X3BhcmVudCBpblxuICAgICAgICAobWF0Y2ggbmV3X3BhcmVudF9ub2RlIHdpdGhcbiAgICAgICAgfCBTdHJlYW0gbmV3X3BhcmVudF9zdHJlYW0gLT5cbiAgICAgICAgICBpZiB3b3VsZF9jcmVhdGVfY3ljbGUgfm5ld19wYXJlbnQgc3RyZWFtX25vZGVcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4zLjM6XG4gICAgICAgICAgICAgKiAgIElmIGEgc3RyZWFtIGlzIG1hZGUgZGVwZW5kZW50IG9uIG9uZSBvZiBpdHMgb3duIGRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgICAqICAgdGhlIGZvcm1lcmx5IGRlcGVuZGVudCBzdHJlYW0gaXMgZmlyc3QgbW92ZWQgdG8gYmUgZGVwZW5kZW50XG4gICAgICAgICAgICAgKiAgIG9uIHRoZSByZXByaW9yaXRpemVkIHN0cmVhbSdzIHByZXZpb3VzIHBhcmVudC4gVGhlIG1vdmVkXG4gICAgICAgICAgICAgKiAgIGRlcGVuZGVuY3kgcmV0YWlucyBpdHMgd2VpZ2h0LiAqKVxuICAgICAgICAgICAgc2V0X3BhcmVudCBuZXdfcGFyZW50X25vZGUgfmV4Y2x1c2l2ZTpmYWxzZSBzdHJlYW0ucGFyZW50O1xuICAgICAgICAgICAgbmV3X3BhcmVudF9zdHJlYW0ucHJpb3JpdHkgPC1cbiAgICAgICAgICAgICAgeyBuZXdfcGFyZW50X3N0cmVhbS5wcmlvcml0eSB3aXRoXG4gICAgICAgICAgICAgICAgc3RyZWFtX2RlcGVuZGVuY3kgPSBjdXJyZW50X3BhcmVudF9pZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICB8IENvbm5lY3Rpb24gXyAtPlxuICAgICAgICAgICgqIFRoZSByb290IG5vZGUgY2Fubm90IGJlIGRlcGVuZGVudCBvbiBhbnkgb3RoZXIgc3RyZWFtcywgc28gd2VcbiAgICAgICAgICAgKiBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IGl0IGNyZWF0aW5nIGN5Y2xlcy4gKilcbiAgICAgICAgICAoKSk7XG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4zLjE6XG4gICAgICAgICAqICAgV2hlbiBhc3NpZ25pbmcgYSBkZXBlbmRlbmN5IG9uIGFub3RoZXIgc3RyZWFtLCB0aGUgc3RyZWFtIGlzIGFkZGVkXG4gICAgICAgICAqICAgYXMgYSBuZXcgZGVwZW5kZW5jeSBvZiB0aGUgcGFyZW50IHN0cmVhbS4gKilcbiAgICAgICAgc2V0X3BhcmVudCBzdHJlYW1fbm9kZSB+ZXhjbHVzaXZlIG5ld19wYXJlbnQpO1xuICAgICAgc3RyZWFtLnByaW9yaXR5IDwtIG5ld19wcmlvcml0eSlcblxuICBsZXQgdXBkYXRlX3Qgbm9kZSBuID1cbiAgICBsZXQgKFN0cmVhbSAoeyBwYXJlbnQgPSBQYXJlbnQgcGFyZW50OyBkZXNjcmlwdG9yOyBfIH0gYXMgc3RyZWFtKSkgPSBub2RlIGluXG4gICAgbGV0IHRsYXN0X3AgPVxuICAgICAgbWF0Y2ggcGFyZW50IHdpdGhcbiAgICAgIHwgQ29ubmVjdGlvbiB7IHRfbGFzdDsgXyB9IC0+IHRfbGFzdFxuICAgICAgfCBTdHJlYW0geyB0X2xhc3Q7IF8gfSAtPiB0X2xhc3RcbiAgICBpblxuICAgIHN0cmVhbS50IDwtIHRsYXN0X3AgKyAobiAqIDI1NiAvIHN0cmVhbS5wcmlvcml0eS53ZWlnaHQpO1xuICAgIGxldCBpZCA9IFN0cmVhbWQuaWQgZGVzY3JpcHRvciBpblxuICAgIHJlbW92ZV9jaGlsZCBwYXJlbnQgaWQ7XG4gICAgbGV0IHVwZGF0ZWRfY2hpbGRyZW4gPSBQcmlvcml0eVF1ZXVlLmFkZCBpZCBub2RlIChjaGlsZHJlbiBwYXJlbnQpIGluXG4gICAgdXBkYXRlX2NoaWxkcmVuIHBhcmVudCB1cGRhdGVkX2NoaWxkcmVuXG5cbiAgbGV0IHVwZGF0ZV90X2xhc3QgOiB0eXBlIGEuIGEgbm9kZSAtPiBpbnQgLT4gdW5pdCA9XG4gICBmdW4gcF9ub2RlIHRfbGFzdCAtPlxuICAgIG1hdGNoIHBfbm9kZSB3aXRoXG4gICAgfCBDb25uZWN0aW9uIHAgLT4gcC50X2xhc3QgPC0gdF9sYXN0XG4gICAgfCBTdHJlYW0gcCAtPiBwLnRfbGFzdCA8LSB0X2xhc3RcblxuICBsZXQgYWRkXG4gICAgICAoQ29ubmVjdGlvbiByb290IGFzIHQpXG4gICAgICB+cHJpb3JpdHlcbiAgICAgIH5pbml0aWFsX3NlbmRfd2luZG93X3NpemVcbiAgICAgIH5pbml0aWFsX3JlY3Zfd2luZG93X3NpemVcbiAgICAgIGRlc2NyaXB0b3JcbiAgICA9XG4gICAgbGV0IHN0cmVhbSA9XG4gICAgICBjcmVhdGVcbiAgICAgICAgfnBhcmVudDooUGFyZW50IHQpXG4gICAgICAgIH5pbml0aWFsX3NlbmRfd2luZG93X3NpemVcbiAgICAgICAgfmluaXRpYWxfcmVjdl93aW5kb3dfc2l6ZVxuICAgICAgICBkZXNjcmlwdG9yXG4gICAgaW5cbiAgICBsZXQgc3RyZWFtX2lkID0gU3RyZWFtZC5pZCBkZXNjcmlwdG9yIGluXG4gICAgU3RyZWFtc1RibC5hZGQgcm9vdC5hbGxfc3RyZWFtcyBzdHJlYW1faWQgc3RyZWFtO1xuICAgIHJvb3QuY2hpbGRyZW4gPC0gUHJpb3JpdHlRdWV1ZS5hZGQgc3RyZWFtX2lkIHN0cmVhbSByb290LmNoaWxkcmVuO1xuICAgIGlmIHByaW9yaXR5ICE9IFByaW9yaXR5LmRlZmF1bHRfcHJpb3JpdHlcbiAgICB0aGVuIHJlcHJpb3JpdGl6ZV9zdHJlYW0gdCB+cHJpb3JpdHkgc3RyZWFtO1xuICAgIHVwZGF0ZV90IHN0cmVhbSAwO1xuICAgIHN0cmVhbVxuXG4gIGxldCBnZXRfbm9kZSAoQ29ubmVjdGlvbiByb290KSBzdHJlYW1faWQgPVxuICAgIFN0cmVhbXNUYmwuZmluZF9vcHQgcm9vdC5hbGxfc3RyZWFtcyBzdHJlYW1faWRcblxuICBsZXQgZmluZCB0IHN0cmVhbV9pZCA9XG4gICAgbWF0Y2ggZ2V0X25vZGUgdCBzdHJlYW1faWQgd2l0aFxuICAgIHwgU29tZSAoU3RyZWFtIHsgZGVzY3JpcHRvcjsgXyB9KSAtPiBTb21lIGRlc2NyaXB0b3JcbiAgICB8IE5vbmUgLT4gTm9uZVxuXG4gIGxldCBpdGVyIChDb25uZWN0aW9uIHsgYWxsX3N0cmVhbXM7IF8gfSkgfmYgPVxuICAgIFN0cmVhbXNUYmwuaXRlciAoZnVuIF9pZCBzdHJlYW0gLT4gZiBzdHJlYW0pIGFsbF9zdHJlYW1zXG5cbiAgbGV0IGFsbG93ZWRfdG9fdHJhbnNtaXQgKENvbm5lY3Rpb24gcm9vdCkgKFN0cmVhbSBzdHJlYW0pID1cbiAgICBJbnQzMi5jb21wYXJlIHJvb3QuZmxvdyAwbCA+IDAgJiYgSW50MzIuY29tcGFyZSBzdHJlYW0uZmxvdyAwbCA+IDBcblxuICBsZXQgYWxsb3dlZF90b19yZWNlaXZlIChDb25uZWN0aW9uIHJvb3QpIChTdHJlYW0gc3RyZWFtKSBzaXplID1cbiAgICBzaXplIDw9IHJvb3QuaW5mbG93ICYmIHNpemUgPD0gc3RyZWFtLmluZmxvd1xuXG4gIGxldCB3cml0ZSAoQ29ubmVjdGlvbiByb290IGFzIHQpIHN0cmVhbV9ub2RlID1cbiAgICBsZXQgKFN0cmVhbSAoeyBkZXNjcmlwdG9yOyBfIH0gYXMgc3RyZWFtKSkgPSBzdHJlYW1fbm9kZSBpblxuICAgICgqIEZyb20gUkZDNzU0MMKnNi45LjE6XG4gICAgICogICBUd28gZmxvdy1jb250cm9sIHdpbmRvd3MgYXJlIGFwcGxpY2FibGU6IHRoZSBzdHJlYW0gZmxvdy1jb250cm9sXG4gICAgICogICB3aW5kb3cgYW5kIHRoZSBjb25uZWN0aW9uIGZsb3ctY29udHJvbCB3aW5kb3cuIFRoZSBzZW5kZXIgTVVTVCBOT1RcbiAgICAgKiAgIHNlbmQgYSBmbG93LWNvbnRyb2xsZWQgZnJhbWUgd2l0aCBhIGxlbmd0aCB0aGF0IGV4Y2VlZHMgdGhlIHNwYWNlXG4gICAgICogICBhdmFpbGFibGUgaW4gZWl0aGVyIG9mIHRoZSBmbG93LWNvbnRyb2wgd2luZG93cyBhZHZlcnRpc2VkIGJ5IHRoZVxuICAgICAqICAgcmVjZWl2ZXIuICopXG4gICAgbGV0IGFsbG93ZWRfYnl0ZXMgPVxuICAgICAgaWYgYWxsb3dlZF90b190cmFuc21pdCB0IHN0cmVhbV9ub2RlXG4gICAgICB0aGVuIG1pbiByb290LmZsb3cgc3RyZWFtLmZsb3dcbiAgICAgIGVsc2VcbiAgICAgICAgKCogVGhlcmUgbWlnaHQgYmUgYSB6ZXJvLWxlbmd0aCBEQVRBIGZyYW1lICh3aXRoIHRoZSBlbmQgc3RyZWFtIGZsYWdcbiAgICAgICAgICAgc2V0KSB3YWl0aW5nIHRvIGJlIHNlbnQuICopXG4gICAgICAgIDBsXG4gICAgaW5cbiAgICBsZXQgd3JpdHRlbiA9XG4gICAgICBTdHJlYW1kLmZsdXNoX3dyaXRlX2JvZHlcbiAgICAgICAgfm1heF9ieXRlczooSW50MzIudG9faW50IGFsbG93ZWRfYnl0ZXMpXG4gICAgICAgIGRlc2NyaXB0b3JcbiAgICBpblxuICAgIGxldCB3cml0dGVuMzIgPSBJbnQzMi5vZl9pbnQgd3JpdHRlbiBpblxuICAgICgqIEZyb20gUkZDNzU0MMKnNi45LjE6XG4gICAgICogICBBZnRlciBzZW5kaW5nIGEgZmxvdy1jb250cm9sbGVkIGZyYW1lLCB0aGUgc2VuZGVyIHJlZHVjZXMgdGhlIHNwYWNlXG4gICAgICogICBhdmFpbGFibGUgaW4gYm90aCB3aW5kb3dzIGJ5IHRoZSBsZW5ndGggb2YgdGhlIHRyYW5zbWl0dGVkIGZyYW1lLiAqKVxuICAgIHJvb3QuZmxvdyA8LSBJbnQzMi5zdWIgcm9vdC5mbG93IHdyaXR0ZW4zMjtcbiAgICBzdHJlYW0uZmxvdyA8LSBJbnQzMi5zdWIgc3RyZWFtLmZsb3cgd3JpdHRlbjMyO1xuICAgIHdyaXR0ZW5cblxuICBsZXQgbWFya19mb3JfcmVtb3ZhbCAoQ29ubmVjdGlvbiByb290KSBpZCBjbG9zZWQgPVxuICAgIFN0cmVhbXNUYmwucmVwbGFjZSByb290Lm1hcmtlZF9mb3JfcmVtb3ZhbCBpZCBjbG9zZWRcblxuICBsZXQgaW1wbGljaXRseV9jbG9zZV9pZGxlX3N0cmVhbSBkZXNjcmlwdG9yIG1heF9zZWVuX2lkcyA9XG4gICAgbGV0IGltcGxpY2l0bHlfY2xvc2Vfc3RyZWFtIGRlc2NyaXB0b3IgPVxuICAgICAgaWYgU3RyZWFtZC5pc19pZGxlIGRlc2NyaXB0b3JcbiAgICAgIHRoZW5cbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc1LjEuMTpcbiAgICAgICAgICogICBUaGUgZmlyc3QgdXNlIG9mIGEgbmV3IHN0cmVhbSBpZGVudGlmaWVyIGltcGxpY2l0bHkgY2xvc2VzIGFsbFxuICAgICAgICAgKiAgIHN0cmVhbXMgaW4gdGhlIFwiaWRsZVwiIHN0YXRlIHRoYXQgbWlnaHQgaGF2ZSBiZWVuIGluaXRpYXRlZCBieVxuICAgICAgICAgKiAgIHRoYXQgcGVlciB3aXRoIGEgbG93ZXItdmFsdWVkIHN0cmVhbSBpZGVudGlmaWVyLiAqKVxuICAgICAgICBTdHJlYW1kLmZpbmlzaF9zdHJlYW0gZGVzY3JpcHRvciBGaW5pc2hlZFxuICAgIGluXG4gICAgbGV0IG1heF9jbGllbnRfc3RyZWFtX2lkLCBtYXhfcHVzaGVkX3N0cmVhbV9pZCA9IG1heF9zZWVuX2lkcyBpblxuICAgIGxldCBzdHJlYW1faWQgPSBTdHJlYW1kLmlkIGRlc2NyaXB0b3IgaW5cbiAgICBpZiBTdHJlYW1faWRlbnRpZmllci5pc19yZXF1ZXN0IHN0cmVhbV9pZFxuICAgIHRoZW4gKFxuICAgICAgaWYgc3RyZWFtX2lkIDwgbWF4X2NsaWVudF9zdHJlYW1faWRcbiAgICAgIHRoZW4gaW1wbGljaXRseV9jbG9zZV9zdHJlYW0gZGVzY3JpcHRvcilcbiAgICBlbHNlIGlmIHN0cmVhbV9pZCA8IG1heF9wdXNoZWRfc3RyZWFtX2lkXG4gICAgdGhlbiBpbXBsaWNpdGx5X2Nsb3NlX3N0cmVhbSBkZXNjcmlwdG9yXG5cbiAgKCogU2NoZWR1bGluZyBhbGdvcml0aG0gZnJvbSBodHRwczovL2dvby5nbC8zc1NIWEogKGJhc2VkIG9uIG5naHR0cDIpOlxuICAgKlxuICAgKiAxICBkZWYgc2NoZWR1bGUocCk6XG4gICAqIDIgICAgaWYgc3RyZWFtICNwIGhhcyBkYXRhIHRvIHNlbmQ6XG4gICAqIDMgICAgICBzZW5kIGRhdGEgZm9yICNwLCB1cGRhdGUgbnNlbnRbcF1cbiAgICogNCAgICAgIHJldHVyblxuICAgKiA1ICAgIGlmICNwJ3MgcXVldWUgaXMgZW1wdHk6XG4gICAqIDYgICAgICByZXR1cm5cbiAgICogNyAgICBwb3AgI2kgZnJvbSBxdWV1ZVxuICAgKiA4ICAgIHVwZGF0ZSB0X2xhc3RbcF0gPSB0W2ldXG4gICAqIDkgICAgc2NoZWR1bGUoaSlcbiAgICogMTAgICBpZiAjaSBvciBpdHMgZGVzY2VuZGFudCBpcyBcImFjdGl2ZVwiOlxuICAgKiAxMSAgICAgdXBkYXRlIHRbaV0gYW5kIHB1c2ggaXQgaW50byBxdWV1ZSBhZ2FpblxuICAgKiAxMlxuICAgKiAxMyBzY2hlZHVsZSgwKVxuICAgKilcbiAgbGV0IGZsdXNoIHQgbWF4X3NlZW5faWRzID1cbiAgICBsZXQgcmVjIHNjaGVkdWxlIDogdHlwZSBhLiBhIG5vZGUgLT4gaW50ICogYm9vbCA9IGZ1bmN0aW9uXG4gICAgICB8IENvbm5lY3Rpb24gXyBhcyBwX25vZGUgLT5cbiAgICAgICAgKCogVGhlIHJvb3QgY2FuIG5ldmVyIHNlbmQgZGF0YS4gKilcbiAgICAgICAgdHJhdmVyc2UgcF9ub2RlXG4gICAgICB8IFN0cmVhbSAoeyBkZXNjcmlwdG9yOyBfIH0gYXMgc3RyZWFtKSBhcyBwX25vZGUgLT5cbiAgICAgICAgbGV0IHdyaXR0ZW4gPVxuICAgICAgICAgIGlmIFN0cmVhbWQucmVxdWlyZXNfb3V0cHV0IGRlc2NyaXB0b3JcbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAoKiBJbiB0aGlzIGJyYW5jaCwgZmxvdy1jb250cm9sIGhhcyBubyBiZWFyaW5nIG9uIGFjdGl2aXR5LCBvdGhlcndpc2VcbiAgICAgICAgICAgICAqIGEgZmxvdy1jb250cm9sbGVkIHN0cmVhbSB3b3VsZCBiZSBjb25zaWRlcmVkIGluYWN0aXZlIChiZWNhdXNlIGl0XG4gICAgICAgICAgICAgKiBjYW4ndCBtYWtlIHByb2dyZXNzIGF0IHRoZSBtb21lbnQpIGFuZCByZW1vdmVkIGZyb20gdGhlIHByaW9yaXR5XG4gICAgICAgICAgICAgKiB0cmVlIGFsdG9nZXRoZXIuICopXG4gICAgICAgICAgICB3cml0ZSB0IHBfbm9kZVxuICAgICAgICAgIGVsc2UgMFxuICAgICAgICBpblxuICAgICAgICBpZiB3cml0dGVuID4gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgKCogV2UgY2hlY2sgZm9yIGFjdGl2aXR5IGFnYWluLCBiZWNhdXNlIHRoZSBzdHJlYW0gbWF5IGhhdmUgZ29uZVxuICAgICAgICAgICAqIGluYWN0aXZlIGFmdGVyIHRoZSBjYWxsIHRvIGB3cml0ZWAgYWJvdmUuICopXG4gICAgICAgICAgbGV0IHN1YnRyZWVfaXNfYWN0aXZlID1cbiAgICAgICAgICAgIFN0cmVhbWQucmVxdWlyZXNfb3V0cHV0IGRlc2NyaXB0b3JcbiAgICAgICAgICAgIHx8IG5vdCAoUHJpb3JpdHlRdWV1ZS5pc19lbXB0eSBzdHJlYW0uY2hpbGRyZW4pXG4gICAgICAgICAgaW5cbiAgICAgICAgICB3cml0dGVuLCBzdWJ0cmVlX2lzX2FjdGl2ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgKCogSWYgd2UgaGF2ZW4ndCB3cml0dGVuIGFueXRoaW5nLCBjaGVjayBpZiBhbnkgb2Ygb3VyIGNoaWxkcmVuXG4gICAgICAgICAgICAgaGF2ZS4gKilcbiAgICAgICAgICBsZXQgd3JpdHRlbiwgc3VidHJlZV9pc19hY3RpdmUnID0gdHJhdmVyc2UgcF9ub2RlIGluXG4gICAgICAgICAgbGV0IHN1YnRyZWVfaXNfYWN0aXZlID1cbiAgICAgICAgICAgIFN0cmVhbWQucmVxdWlyZXNfb3V0cHV0IGRlc2NyaXB0b3IgfHwgc3VidHJlZV9pc19hY3RpdmUnXG4gICAgICAgICAgaW5cbiAgICAgICAgICAobWF0Y2ggd3JpdHRlbiB3aXRoXG4gICAgICAgICAgfCAwIC0+IHdyaXR0ZW4sIHN1YnRyZWVfaXNfYWN0aXZlXG4gICAgICAgICAgfCB3cml0dGVuIC0+XG4gICAgICAgICAgICAoKiBJZiB0aGVyZSdzIHN0aWxsIG1vcmUgdG8gd3JpdGUsIHB1dCB0aGUgbm9kZSBiYWNrIGluIHRoZSB0cmVlLiAqKVxuICAgICAgICAgICAgaWYgc3VidHJlZV9pc19hY3RpdmUgdGhlbiB1cGRhdGVfdCBwX25vZGUgd3JpdHRlbjtcbiAgICAgICAgICAgIHdyaXR0ZW4sIHN1YnRyZWVfaXNfYWN0aXZlKVxuICAgIGFuZCB0cmF2ZXJzZSA6IHR5cGUgYS4gYSBub2RlIC0+IGludCAqIGJvb2wgPVxuICAgICBmdW4gcF9ub2RlIC0+XG4gICAgICBsZXQgcmVjIGxvb3AgcmVtYWluaW5nX2NoaWxkcmVuID1cbiAgICAgICAgbWF0Y2ggUHJpb3JpdHlRdWV1ZS5wb3AgcmVtYWluaW5nX2NoaWxkcmVuIHdpdGhcbiAgICAgICAgfCBTb21lICgoaWQsIChTdHJlYW0gaSBhcyBpX25vZGUpKSwgcmVtYWluaW5nX2NoaWxkcmVuJykgLT5cbiAgICAgICAgICB1cGRhdGVfdF9sYXN0IHBfbm9kZSBpLnQ7XG4gICAgICAgICAgbGV0IHdyaXR0ZW4sIHN1YnRyZWVfaXNfYWN0aXZlID0gc2NoZWR1bGUgaV9ub2RlIGluXG5cbiAgICAgICAgICBpZiBub3Qgc3VidHJlZV9pc19hY3RpdmVcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGltcGxpY2l0bHlfY2xvc2VfaWRsZV9zdHJlYW0gaS5kZXNjcmlwdG9yIG1heF9zZWVuX2lkcztcbiAgICAgICAgICAgICgqIFhYWChhbm1vbnRlaXJvKTogd2UgbWF5IG5vdCB3YW50IHRvIHJlbW92ZSBmcm9tIHRoZSB0cmVlIHJpZ2h0XG4gICAgICAgICAgICAgKiBhd2F5LiAqKVxuICAgICAgICAgICAgcmVtb3ZlX2NoaWxkIHBfbm9kZSBpZCk7XG5cbiAgICAgICAgICAobWF0Y2ggd3JpdHRlbiB3aXRoXG4gICAgICAgICAgfCAwIC0+XG4gICAgICAgICAgICAoKiBJZiB0aGlzIHN1YnRyZWUgZGlkbid0IHdyaXRlIGFueXRoaW5nLCBjaGVjayB0aGUgb3RoZXIgY2hpbGRyZW5cbiAgICAgICAgICAgICAgIGluIHRoZSBwcmlvcml0eSBxdWV1ZS4gKilcbiAgICAgICAgICAgIGxvb3AgcmVtYWluaW5nX2NoaWxkcmVuJ1xuICAgICAgICAgIHwgd3JpdHRlbiAtPlxuICAgICAgICAgICAgKCogSWYgdGhlcmUncyBzdGlsbCBtb3JlIHRvIHdyaXRlLCBwdXQgdGhlIG5vZGUgYmFjayBpbiB0aGUgdHJlZS4gKilcbiAgICAgICAgICAgIGlmIHN1YnRyZWVfaXNfYWN0aXZlIHRoZW4gdXBkYXRlX3QgaV9ub2RlIHdyaXR0ZW47XG4gICAgICAgICAgICB3cml0dGVuLCBzdWJ0cmVlX2lzX2FjdGl2ZSlcbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgKCogTm8gZGF0YSB3cml0dGVuLCBidXQgcXVldWUgd2FzIG5vdCBvcmlnaW5hbGx5IGVtcHR5LlxuICAgICAgICAgICAqIFRoZXJlZm9yZSwgd2UgY2FuJ3QgZGV0ZXJtaW5lIHRoZSBzdWJ0cmVlIGlzIGluYWN0aXZlLiAqKVxuICAgICAgICAgIDAsIHRydWVcbiAgICAgIGluXG4gICAgICBsZXQgY2hpbGRyZW4gPSBjaGlsZHJlbiBwX25vZGUgaW5cbiAgICAgIG1hdGNoIFByaW9yaXR5UXVldWUuaXNfZW1wdHkgY2hpbGRyZW4gd2l0aFxuICAgICAgfCB0cnVlIC0+XG4gICAgICAgICgqIFF1ZXVlIGlzIGVtcHR5LCBzZWUgbGluZSA2IGFib3ZlLiAqKVxuICAgICAgICAwLCBmYWxzZVxuICAgICAgfCBmYWxzZSAtPiBsb29wIGNoaWxkcmVuXG4gICAgaW5cblxuICAgIGxldCAoQ29ubmVjdGlvbiByb290KSA9IHQgaW5cbiAgICBpZ25vcmUgKHNjaGVkdWxlIHQpO1xuICAgIFN0cmVhbXNUYmwuaXRlclxuICAgICAgKGZ1biBpZCBjbG9zZWQgLT5cbiAgICAgICAgICgqIFdoZW4gYSBzdHJlYW0gY29tcGxldGVzLCBpLmUuIGRvZXNuJ3QgcmVxdWlyZSBtb3JlIG91dHB1dCBhbmRcbiAgICAgICAgICAqIGVudGVycyB0aGUgYENsb3NlZGAgc3RhdGUsIHdlIHNldCBhIFRUTCB2YWx1ZSB3aGljaCByZXByZXNlbnRzIHRoZVxuICAgICAgICAgICogbnVtYmVyIG9mIHdyaXRlciB5aWVsZHMgdGhhdCB0aGUgc3RyZWFtIGhhcyBiZWZvcmUgaXQgaXMgcmVtb3ZlZFxuICAgICAgICAgICogZnJvbSB0aGUgY29ubmVjdGlvbiBIYXNoIFRhYmxlLiBCeSBkb2luZyB0aGlzIHdlIGF2b2lkIGxvc2luZyBzb21lXG4gICAgICAgICAgKiBwb3RlbnRpYWxseSB1c2VmdWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIHRoZSBzdHJlYW0ncyBzdGF0ZSBhdCB0aGVcbiAgICAgICAgICAqIGNvc3Qgb2Yga2VlcGluZyBpdCBhcm91bmQgZm9yIGEgbGl0dGxlIHdoaWxlIGxvbmdlci4gKilcbiAgICAgICAgIGlmIGNsb3NlZC5TdHJlYW0udHRsID0gMFxuICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgIFN0cmVhbXNUYmwucmVtb3ZlIHJvb3QubWFya2VkX2Zvcl9yZW1vdmFsIGlkO1xuICAgICAgICAgICBTdHJlYW1zVGJsLnJlbW92ZSByb290LmFsbF9zdHJlYW1zIGlkKVxuICAgICAgICAgZWxzZSBjbG9zZWQudHRsIDwtIGNsb3NlZC50dGwgLSAxKVxuICAgICAgcm9vdC5tYXJrZWRfZm9yX3JlbW92YWxcblxuICAoKiBYWFgoYW5tb250ZWlybyk6IENvbnNpZGVyIHVzaW5nIGBvcHRpbnRgIGZvciB0aGlzP1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWlyYWdlL29wdGludFxuICAgKilcbiAgbGV0IGNoZWNrX2Zsb3cgZmxvdyBncm93dGggZmxvdycgPVxuICAgICgqIENoZWNrIGZvciBvdmVyZmxvdyBvbiAzMi1iaXQgc3lzdGVtcy4gKilcbiAgICBJbnQzMi5jb21wYXJlIGZsb3cnIGdyb3d0aCA+IDAgPSAoSW50MzIuY29tcGFyZSBmbG93IDBsID4gMClcbiAgICAmJiBJbnQzMi5jb21wYXJlIGZsb3cnIFNldHRpbmdzLldpbmRvd1NpemUubWF4X3dpbmRvd19zaXplIDw9IDBcblxuICBsZXQgYWRkX2Zsb3cgOiB0eXBlIGEuIGEgbm9kZSAtPiBpbnQzMiAtPiBib29sID1cbiAgIGZ1biB0IGdyb3d0aCAtPlxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgQ29ubmVjdGlvbiAoeyBmbG93OyBfIH0gYXMgcm9vdCkgLT5cbiAgICAgIGxldCBmbG93JyA9IEludDMyLmFkZCBmbG93IGdyb3d0aCBpblxuICAgICAgbGV0IHZhbGlkX2Zsb3cgPSBjaGVja19mbG93IGZsb3cgZ3Jvd3RoIGZsb3cnIGluXG4gICAgICBpZiB2YWxpZF9mbG93IHRoZW4gcm9vdC5mbG93IDwtIGZsb3cnO1xuICAgICAgdmFsaWRfZmxvd1xuICAgIHwgU3RyZWFtICh7IGZsb3c7IF8gfSBhcyBzdHJlYW0pIC0+XG4gICAgICBsZXQgZmxvdycgPSBJbnQzMi5hZGQgZmxvdyBncm93dGggaW5cbiAgICAgIGxldCB2YWxpZF9mbG93ID0gY2hlY2tfZmxvdyBmbG93IGdyb3d0aCBmbG93JyBpblxuICAgICAgaWYgdmFsaWRfZmxvdyB0aGVuIHN0cmVhbS5mbG93IDwtIGZsb3cnO1xuICAgICAgdmFsaWRfZmxvd1xuXG4gIGxldCBhZGRfaW5mbG93IDogdHlwZSBhLiBhIG5vZGUgLT4gaW50MzIgLT4gYm9vbCA9XG4gICBmdW4gdCBncm93dGggLT5cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IENvbm5lY3Rpb24gKHsgaW5mbG93OyBfIH0gYXMgcm9vdCkgLT5cbiAgICAgIGxldCBpbmZsb3cnID0gSW50MzIuYWRkIGluZmxvdyBncm93dGggaW5cbiAgICAgIGxldCB2YWxpZF9pbmZsb3cgPSBjaGVja19mbG93IGluZmxvdyBncm93dGggaW5mbG93JyBpblxuICAgICAgaWYgdmFsaWRfaW5mbG93IHRoZW4gcm9vdC5pbmZsb3cgPC0gaW5mbG93JztcbiAgICAgIHZhbGlkX2luZmxvd1xuICAgIHwgU3RyZWFtICh7IGluZmxvdzsgXyB9IGFzIHN0cmVhbSkgLT5cbiAgICAgIGxldCBpbmZsb3cnID0gSW50MzIuYWRkIGluZmxvdyBncm93dGggaW5cbiAgICAgIGxldCB2YWxpZF9pbmZsb3cgPSBjaGVja19mbG93IGluZmxvdyBncm93dGggaW5mbG93JyBpblxuICAgICAgaWYgdmFsaWRfaW5mbG93IHRoZW4gc3RyZWFtLmluZmxvdyA8LSBpbmZsb3cnO1xuICAgICAgdmFsaWRfaW5mbG93XG5cbiAgbGV0IGRlZHVjdF9pbmZsb3cgOiB0eXBlIGEuIGEgbm9kZSAtPiBpbnQzMiAtPiB1bml0ID1cbiAgIGZ1biB0IHNpemUgLT5cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IENvbm5lY3Rpb24gKHsgaW5mbG93OyBfIH0gYXMgcm9vdCkgLT5cbiAgICAgICgqIG5vIG5lZWQgdG8gY2hlY2ssIHdlIHZlcmlmeSB0aGF0IHRoZSBwZWVyIGlzIGFsbG93ZWQgdG8gc2VuZC4gKilcbiAgICAgIHJvb3QuaW5mbG93IDwtIEludDMyLnN1YiBpbmZsb3cgc2l6ZVxuICAgIHwgU3RyZWFtICh7IGluZmxvdzsgXyB9IGFzIHN0cmVhbSkgLT4gc3RyZWFtLmluZmxvdyA8LSBJbnQzMi5zdWIgaW5mbG93IHNpemVcblxuICBsZXQgcHBfaHVtIGZtdCB0ID1cbiAgICBsZXQgcmVjIHBwX2h1bV9pbm5lciBsZXZlbCBmbXQgdCA9XG4gICAgICBsZXQgcHBfYmluZGluZyBmbXQgKGlkLCBTdHJlYW0geyBjaGlsZHJlbjsgdDsgXyB9KSA9XG4gICAgICAgIEZvcm1hdC5mcHJpbnRmXG4gICAgICAgICAgZm10XG4gICAgICAgICAgXCJcXG4lcyVsZCwgJWQgLT4gWyVhXVwiXG4gICAgICAgICAgKFN0cmluZy5tYWtlIChsZXZlbCAqIDIpICcgJylcbiAgICAgICAgICBpZFxuICAgICAgICAgIHRcbiAgICAgICAgICAocHBfaHVtX2lubmVyIChsZXZlbCArIDEpKVxuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICBpblxuICAgICAgUHJpb3JpdHlRdWV1ZS5wcCBwcF9iaW5kaW5nIGZtdCB0XG4gICAgaW5cbiAgICBwcF9odW1faW5uZXIgMCBmbXQgdFxuXG4gIGxldCBwcF9odW0gZm10IChDb25uZWN0aW9uIHsgY2hpbGRyZW47IF8gfSkgPSBwcF9odW0gZm10IGNoaWxkcmVuXG5lbmRcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE5IEFudG9uaW8gTi4gTW9udGVpcm8uXG4gKlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogIGFyZSBtZXQ6XG4gKlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gKiAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gKiAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gKiAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gKiAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gKiAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICogIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICogIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG5tb2R1bGUgSHR0cGFmID0gRHJlYW1faHR0cGFmXy5IdHRwYWZcbm1vZHVsZSBIcGFjayA9IERyZWFtX2hwYWNrLkhwYWNrXG5cbm1vZHVsZSBBQiA9IEFuZ3N0cm9tLkJ1ZmZlcmVkXG5tb2R1bGUgUmVhZGVyID0gUGFyc2UuUmVhZGVyXG5tb2R1bGUgV3JpdGVyID0gU2VyaWFsaXplLldyaXRlclxuXG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyLk1ha2UgKHN0cnVjdFxuICAgIGluY2x1ZGUgU3RyZWFtXG5cbiAgICB0eXBlIHQgPSBSZXFkLnRcblxuICAgIGxldCBmbHVzaF93cml0ZV9ib2R5ID0gUmVxZC5mbHVzaF9yZXNwb25zZV9ib2R5XG4gICAgbGV0IHJlcXVpcmVzX291dHB1dCA9IFJlcWQucmVxdWlyZXNfb3V0cHV0XG4gIGVuZClcblxudHlwZSByZXF1ZXN0X2hhbmRsZXIgPSBSZXFkLnQgLT4gdW5pdFxuXG50eXBlIGVycm9yID1cbiAgWyBgQmFkX3JlcXVlc3RcbiAgfCBgSW50ZXJuYWxfc2VydmVyX2Vycm9yXG4gIHwgYEV4biBvZiBleG5cbiAgXVxuXG50eXBlIGVycm9yX2hhbmRsZXIgPVxuICA/cmVxdWVzdDpSZXF1ZXN0LnQgLT4gZXJyb3IgLT4gKEhlYWRlcnMudCAtPiBCb2R5LldyaXRlci50KSAtPiB1bml0XG5cbnR5cGUgdCA9XG4gIHsgbXV0YWJsZSBzZXR0aW5ncyA6IFNldHRpbmdzLnRcbiAgOyByZWFkZXIgOiBSZWFkZXIuZnJhbWVcbiAgOyB3cml0ZXIgOiBXcml0ZXIudFxuICA7IGNvbmZpZyA6IENvbmZpZy50XG4gIDsgcmVxdWVzdF9oYW5kbGVyIDogcmVxdWVzdF9oYW5kbGVyXG4gIDsgZXJyb3JfaGFuZGxlciA6IGVycm9yX2hhbmRsZXJcbiAgOyBzdHJlYW1zIDogU2NoZWR1bGVyLnRcbiAgICAgICAgKCogTnVtYmVyIG9mIGN1cnJlbnRseSBvcGVuIGNsaWVudCBzdHJlYW1zLiBVc2VkIGZvclxuICAgICAgICAgKiBNQVhfQ09OQ1VSUkVOVF9TVFJFQU1TIGJvb2trZWVwaW5nICopXG4gIDsgbXV0YWJsZSBjdXJyZW50X2NsaWVudF9zdHJlYW1zIDogaW50XG4gIDsgbXV0YWJsZSBtYXhfY2xpZW50X3N0cmVhbV9pZCA6IFN0cmVhbV9pZGVudGlmaWVyLnRcbiAgOyBtdXRhYmxlIG1heF9wdXNoZWRfc3RyZWFtX2lkIDogU3RyZWFtX2lkZW50aWZpZXIudFxuICA7IG11dGFibGUgcmVjZWl2aW5nX2hlYWRlcnNfZm9yX3N0cmVhbSA6IFN0cmVhbV9pZGVudGlmaWVyLnQgb3B0aW9uXG4gICAgICAgICgqIEtlZXAgdHJhY2sgb2YgbnVtYmVyIG9mIFNFVFRJTkdTIGZyYW1lcyB0aGF0IHdlIHNlbnQgYW5kIGZvciB3aGljaFxuICAgICAgICAgKiB3ZSBoYXZlbid0IGVjZWl2ZWQgYW4gYWNrbm93bGVkZ21lbnQgZnJvbSB0aGUgY2xpZW50LiAqKVxuICA7IG11dGFibGUgdW5hY2tlZF9zZXR0aW5ncyA6IGludFxuICA7IG11dGFibGUgZGlkX3NlbmRfZ29fYXdheSA6IGJvb2xcbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc0LjM6XG4gICAgICAgICAqICAgSGVhZGVyIGNvbXByZXNzaW9uIGlzIHN0YXRlZnVsLiBPbmUgY29tcHJlc3Npb24gY29udGV4dCBhbmQgb25lXG4gICAgICAgICAqICAgZGVjb21wcmVzc2lvbiBjb250ZXh0IGFyZSB1c2VkIGZvciB0aGUgZW50aXJlIGNvbm5lY3Rpb24uICopXG4gIDsgaHBhY2tfZW5jb2RlciA6IEhwYWNrLkVuY29kZXIudFxuICA7IGhwYWNrX2RlY29kZXIgOiBIcGFjay5EZWNvZGVyLnRcbiAgfVxuXG5sZXQgaXNfY2xvc2VkIHQgPSBSZWFkZXIuaXNfY2xvc2VkIHQucmVhZGVyICYmIFdyaXRlci5pc19jbG9zZWQgdC53cml0ZXJcbmxldCB3YWtldXBfd3JpdGVyIHQgPSBXcml0ZXIud2FrZXVwIHQud3JpdGVyXG5sZXQgc2h1dGRvd25fcmVhZGVyIHQgPSBSZWFkZXIuZm9yY2VfY2xvc2UgdC5yZWFkZXJcblxubGV0IHNodXRkb3duX3dyaXRlciB0ID1cbiAgV3JpdGVyLmNsb3NlIHQud3JpdGVyO1xuICB3YWtldXBfd3JpdGVyIHRcblxubGV0IHNodXRkb3duIHQgPVxuICBzaHV0ZG93bl9yZWFkZXIgdDtcbiAgc2h1dGRvd25fd3JpdGVyIHRcblxuKCogSGFuZGxpbmcgZnJhbWVzIGFnYWluc3QgY2xvc2VkIHN0cmVhbXMgaXMgaGFyZC4gU2VlOlxuICogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vcHJlc2VudGF0aW9uL2QvMWlHX1UyYktUYzlDbktyMGpQVHJOZm14eUx1ZnhfY0sybk5oOVZqcktINnNcbiAqKVxubGV0IHdhc19jbG9zZWRfb3JfaW1wbGljaXRseV9jbG9zZWQgdCBzdHJlYW1faWQgPVxuICBpZiBTdHJlYW1faWRlbnRpZmllci5pc19yZXF1ZXN0IHN0cmVhbV9pZFxuICB0aGVuIFN0cmVhbV9pZGVudGlmaWVyLihzdHJlYW1faWQgPD0gdC5tYXhfY2xpZW50X3N0cmVhbV9pZClcbiAgZWxzZSBTdHJlYW1faWRlbnRpZmllci4oc3RyZWFtX2lkIDw9IHQubWF4X3B1c2hlZF9zdHJlYW1faWQpXG5cbigqIFRPRE86IGN1cnJlbnRseSBjb25uZWN0aW9uLWxldmVsIGVycm9ycyBhcmUgbm90IHJlcG9ydGVkIHRvIHRoZSBlcnJvclxuICogaGFuZGxlciBiZWNhdXNlIGl0IGlzIGFzc3VtZWQgdGhhdCBhbiBlcnJvciBoYW5kbGVyIHdpbGwgcHJvZHVjZSBhIHJlc3BvbnNlLFxuICogYW5kIHNpbmNlIEhUVFAvMiBpcyBtdWx0aXBsZXhlZCwgdGhlcmUncyBubyBtYXRjaGluZyByZXNwb25zZSBmb3IgYVxuICogY29ubmVjdGlvbiBlcnJvci4gV2Ugc2hvdWxkIGRvIHNvbWV0aGluZyBhYm91dCBpdC4gKilcbmxldCByZXBvcnRfZXJyb3IgdCA9IGZ1bmN0aW9uXG4gIHwgRXJyb3IuQ29ubmVjdGlvbkVycm9yIChlcnJvciwgZGF0YSkgLT5cbiAgICBpZiBub3QgdC5kaWRfc2VuZF9nb19hd2F5XG4gICAgdGhlbiAoXG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuNC4xOlxuICAgICAgICogICBBbiBlbmRwb2ludCB0aGF0IGVuY291bnRlcnMgYSBjb25uZWN0aW9uIGVycm9yIFNIT1VMRCBmaXJzdCBzZW5kIGFcbiAgICAgICAqICAgR09BV0FZIGZyYW1lIChTZWN0aW9uIDYuOCkgd2l0aCB0aGUgc3RyZWFtIGlkZW50aWZpZXIgb2YgdGhlIGxhc3RcbiAgICAgICAqICAgc3RyZWFtIHRoYXQgaXQgc3VjY2Vzc2Z1bGx5IHJlY2VpdmVkIGZyb20gaXRzIHBlZXIuIFRoZSBHT0FXQVkgZnJhbWVcbiAgICAgICAqICAgaW5jbHVkZXMgYW4gZXJyb3IgY29kZSB0aGF0IGluZGljYXRlcyB3aHkgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICAgICAqICAgdGVybWluYXRpbmcuIEFmdGVyIHNlbmRpbmcgdGhlIEdPQVdBWSBmcmFtZSBmb3IgYW4gZXJyb3IgY29uZGl0aW9uLFxuICAgICAgICogICB0aGUgZW5kcG9pbnQgTVVTVCBjbG9zZSB0aGUgVENQIGNvbm5lY3Rpb24uICopXG4gICAgICBsZXQgZGVidWdfZGF0YSA9XG4gICAgICAgIGlmIFN0cmluZy5sZW5ndGggZGF0YSA9IDBcbiAgICAgICAgdGhlbiBCaWdzdHJpbmdhZi5lbXB0eVxuICAgICAgICBlbHNlIEJpZ3N0cmluZ2FmLm9mX3N0cmluZyB+b2ZmOjAgfmxlbjooU3RyaW5nLmxlbmd0aCBkYXRhKSBkYXRhXG4gICAgICBpblxuICAgICAgbGV0IGZyYW1lX2luZm8gPSBXcml0ZXIubWFrZV9mcmFtZV9pbmZvIFN0cmVhbV9pZGVudGlmaWVyLmNvbm5lY3Rpb24gaW5cbiAgICAgICgqIFRPRE86IE9ubHkgd3JpdGUgaWYgbm90IGFscmVhZHkgc2h1dGRvd24uICopXG4gICAgICBXcml0ZXIud3JpdGVfZ29fYXdheVxuICAgICAgICB0LndyaXRlclxuICAgICAgICBmcmFtZV9pbmZvXG4gICAgICAgIH5kZWJ1Z19kYXRhXG4gICAgICAgIH5sYXN0X3N0cmVhbV9pZDp0Lm1heF9jbGllbnRfc3RyZWFtX2lkXG4gICAgICAgIGVycm9yO1xuICAgICAgV3JpdGVyLmZsdXNoIHQud3JpdGVyIChmdW4gKCkgLT5cbiAgICAgICAgKCogWFhYOiBXZSBuZWVkIHRvIGFsbG93IGxvd2VyIG51bWJlcmVkIHN0cmVhbXMgdG8gY29tcGxldGUgYmVmb3JlXG4gICAgICAgICAqIHNodXR0aW5nIGRvd24uICopXG4gICAgICAgIHNodXRkb3duIHQpO1xuICAgICAgdC5kaWRfc2VuZF9nb19hd2F5IDwtIHRydWU7XG4gICAgICB3YWtldXBfd3JpdGVyIHQpXG4gIHwgU3RyZWFtRXJyb3IgKHN0cmVhbV9pZCwgZXJyb3IpIC0+XG4gICAgKG1hdGNoIFNjaGVkdWxlci5maW5kIHQuc3RyZWFtcyBzdHJlYW1faWQgd2l0aFxuICAgIHwgU29tZSByZXFkIC0+IFN0cmVhbS5yZXNldF9zdHJlYW0gcmVxZCBlcnJvclxuICAgIHwgTm9uZSAtPlxuICAgICAgaWYgbm90ICh3YXNfY2xvc2VkX29yX2ltcGxpY2l0bHlfY2xvc2VkIHQgc3RyZWFtX2lkKVxuICAgICAgdGhlblxuICAgICAgICAoKiBQb3NzaWJsZSBpZiB0aGUgc3RyZWFtIHdhcyBnb2luZyB0byBlbnRlciB0aGUgSWRsZSBzdGF0ZSAoZmlyc3QgdGltZVxuICAgICAgICAgKiB3ZSBzYXcgZS5nLiBhIFBSSU9SSVRZIGZyYW1lIGZvciBpdCkgYnV0IGhhZCBlLmcuIGFcbiAgICAgICAgICogRlJBTUVfU0laRV9FUlJPUi4gKilcbiAgICAgICAgbGV0IGZyYW1lX2luZm8gPSBXcml0ZXIubWFrZV9mcmFtZV9pbmZvIHN0cmVhbV9pZCBpblxuICAgICAgICBXcml0ZXIud3JpdGVfcnN0X3N0cmVhbSB0LndyaXRlciBmcmFtZV9pbmZvIGVycm9yKTtcbiAgICB3YWtldXBfd3JpdGVyIHRcblxubGV0IHJlcG9ydF9jb25uZWN0aW9uX2Vycm9yIHQgPyhyZWFzb24gPSBcIlwiKSBlcnJvciA9XG4gIHJlcG9ydF9lcnJvciB0IChDb25uZWN0aW9uRXJyb3IgKGVycm9yLCByZWFzb24pKVxuXG5sZXQgcmVwb3J0X3N0cmVhbV9lcnJvciB0IHN0cmVhbV9pZCBlcnJvciA9XG4gIHJlcG9ydF9lcnJvciB0IChTdHJlYW1FcnJvciAoc3RyZWFtX2lkLCBlcnJvcikpXG5cbmxldCBzZXRfZXJyb3JfYW5kX2hhbmRsZSA/cmVxdWVzdCB0IHN0cmVhbSBlcnJvciBlcnJvcl9jb2RlID1cbiAgYXNzZXJ0IChyZXF1ZXN0ID0gTm9uZSk7XG4gIFJlcWQucmVwb3J0X2Vycm9yIHN0cmVhbSBlcnJvciBlcnJvcl9jb2RlO1xuICB3YWtldXBfd3JpdGVyIHRcblxubGV0IHJlcG9ydF9leG4gdCBleG4gPVxuICBpZiBub3QgKGlzX2Nsb3NlZCB0KVxuICB0aGVuXG4gICAgbGV0IHJlYXNvbiA9IFByaW50ZXhjLnRvX3N0cmluZyBleG4gaW5cbiAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IH5yZWFzb24gRXJyb3JfY29kZS5JbnRlcm5hbEVycm9yXG5cbmxldCBvbl9jbG9zZV9zdHJlYW0gdCBpZCB+YWN0aXZlIGNsb3NlZCA9XG4gIGlmIGFjdGl2ZVxuICB0aGVuXG4gICAgKCogRnJvbSBSRkM3NTQwwqc1LjEuMjpcbiAgICAgKiAgIFN0cmVhbXMgdGhhdCBhcmUgaW4gdGhlIFwib3BlblwiIHN0YXRlIG9yIGluIGVpdGhlciBvZiB0aGUgXCJoYWxmLWNsb3NlZFwiXG4gICAgICogICBzdGF0ZXMgY291bnQgdG93YXJkIHRoZSBtYXhpbXVtIG51bWJlciBvZiBzdHJlYW1zIHRoYXQgYW4gZW5kcG9pbnQgaXNcbiAgICAgKiAgIHBlcm1pdHRlZCB0byBvcGVuLiAqKVxuICAgIHQuY3VycmVudF9jbGllbnRfc3RyZWFtcyA8LSB0LmN1cnJlbnRfY2xpZW50X3N0cmVhbXMgLSAxO1xuICBTY2hlZHVsZXIubWFya19mb3JfcmVtb3ZhbCB0LnN0cmVhbXMgaWQgY2xvc2VkXG5cbmxldCBzZW5kX3dpbmRvd191cGRhdGUgOlxuICAgIHR5cGUgYS4gdCAtPiBhIFNjaGVkdWxlci5Qcmlvcml0eVRyZWVOb2RlLm5vZGUgLT4gaW50MzIgLT4gdW5pdFxuICA9XG4gZnVuIHQgc3RyZWFtIG4gLT5cbiAgbGV0IHNlbmRfd2luZG93X3VwZGF0ZV9mcmFtZSBzdHJlYW1faWQgbiA9XG4gICAgbGV0IHZhbGlkX2luZmxvdyA9IFNjaGVkdWxlci5hZGRfaW5mbG93IHN0cmVhbSBuIGluXG4gICAgYXNzZXJ0IHZhbGlkX2luZmxvdztcbiAgICBsZXQgZnJhbWVfaW5mbyA9IFdyaXRlci5tYWtlX2ZyYW1lX2luZm8gc3RyZWFtX2lkIGluXG4gICAgV3JpdGVyLndyaXRlX3dpbmRvd191cGRhdGUgdC53cml0ZXIgZnJhbWVfaW5mbyBuXG4gIGluXG4gIGlmIEludDMyLmNvbXBhcmUgbiAwbCA+IDBcbiAgdGhlbiAoXG4gICAgbGV0IG1heF93aW5kb3dfc2l6ZSA9IFNldHRpbmdzLldpbmRvd1NpemUubWF4X3dpbmRvd19zaXplIGluXG4gICAgbGV0IHN0cmVhbV9pZCA9IFNjaGVkdWxlci5zdHJlYW1faWQgc3RyZWFtIGluXG4gICAgbGV0IHJlYyBsb29wIG4gPVxuICAgICAgaWYgbiA+IG1heF93aW5kb3dfc2l6ZVxuICAgICAgdGhlbiAoXG4gICAgICAgIHNlbmRfd2luZG93X3VwZGF0ZV9mcmFtZSBzdHJlYW1faWQgbWF4X3dpbmRvd19zaXplO1xuICAgICAgICBsb29wIChJbnQzMi5zdWIgbiBtYXhfd2luZG93X3NpemUpKVxuICAgICAgZWxzZSBzZW5kX3dpbmRvd191cGRhdGVfZnJhbWUgc3RyZWFtX2lkIG5cbiAgICBpblxuICAgIGxvb3AgbjtcbiAgICB3YWtldXBfd3JpdGVyIHQpXG5cbmxldCBjcmVhdGVfcHVzaF9zdHJlYW0gdCBwYXJlbnRfc3RyZWFtX2lkID1cbiAgbGV0IGNhbmRpZGF0ZV9wdXNoX3N0cmVhbV9pZCA9IEludDMyLmFkZCB0Lm1heF9wdXNoZWRfc3RyZWFtX2lkIDJsIGluXG4gIGlmIG5vdCB0LnNldHRpbmdzLmVuYWJsZV9wdXNoXG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNjpcbiAgICAgKiAgIFBVU0hfUFJPTUlTRSBNVVNUIE5PVCBiZSBzZW50IGlmIHRoZSBTRVRUSU5HU19FTkFCTEVfUFVTSCBzZXR0aW5nIG9mXG4gICAgICogICB0aGUgcGVlciBlbmRwb2ludCBpcyBzZXQgdG8gMC4gKilcbiAgICBFcnJvciBgUHVzaF9kaXNhYmxlZFxuICBlbHNlIGlmIFN0cmVhbV9pZGVudGlmaWVyLihjYW5kaWRhdGVfcHVzaF9zdHJlYW1faWQgPiBtYXhfc3RyZWFtX2lkKVxuICB0aGVuIChcbiAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgKiAgIFN0cmVhbSBpZGVudGlmaWVycyBjYW5ub3QgYmUgcmV1c2VkLiBMb25nLWxpdmVkIGNvbm5lY3Rpb25zIGNhbiByZXN1bHRcbiAgICAgKiAgIGluIGFuIGVuZHBvaW50IGV4aGF1c3RpbmcgdGhlIGF2YWlsYWJsZSByYW5nZSBvZiBzdHJlYW0gaWRlbnRpZmllcnMuXG4gICAgICogICBbLi4uXSBBIHNlcnZlciB0aGF0IGlzIHVuYWJsZSB0byBlc3RhYmxpc2ggYSBuZXcgc3RyZWFtIGlkZW50aWZpZXIgY2FuXG4gICAgICogICBzZW5kIGEgR09BV0FZIGZyYW1lIHNvIHRoYXQgdGhlIGNsaWVudCBpcyBmb3JjZWQgdG8gb3BlbiBhIG5ld1xuICAgICAqICAgY29ubmVjdGlvbiBmb3IgbmV3IHN0cmVhbXMuICopXG4gICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLk5vRXJyb3I7XG4gICAgRXJyb3IgYFN0cmVhbV9pZHNfZXhoYXVzdGVkKVxuICBlbHNlXG4gICAgbGV0IHB1c2hlZF9zdHJlYW1faWQgPSBjYW5kaWRhdGVfcHVzaF9zdHJlYW1faWQgaW5cbiAgICB0Lm1heF9wdXNoZWRfc3RyZWFtX2lkIDwtIHB1c2hlZF9zdHJlYW1faWQ7XG4gICAgbGV0IHJlcWQgPVxuICAgICAgU3RyZWFtLmNyZWF0ZVxuICAgICAgICBwdXNoZWRfc3RyZWFtX2lkXG4gICAgICAgIH5tYXhfZnJhbWVfc2l6ZTp0LnNldHRpbmdzLm1heF9mcmFtZV9zaXplXG4gICAgICAgIHQud3JpdGVyXG4gICAgICAgIHQuZXJyb3JfaGFuZGxlclxuICAgICAgICAob25fY2xvc2Vfc3RyZWFtIHQgcHVzaGVkX3N0cmVhbV9pZClcbiAgICBpblxuICAgICgqIEZyb20gUkZDNzU0MMKnNS4zLjU6XG4gICAgICogICBBbGwgc3RyZWFtcyBhcmUgaW5pdGlhbGx5IGFzc2lnbmVkIGEgbm9uLWV4Y2x1c2l2ZSBkZXBlbmRlbmN5IG9uXG4gICAgICogICBzdHJlYW0gMHgwLiBQdXNoZWQgc3RyZWFtcyAoU2VjdGlvbiA4LjIpIGluaXRpYWxseSBkZXBlbmQgb24gdGhlaXJcbiAgICAgKiAgIGFzc29jaWF0ZWQgc3RyZWFtLiBJbiBib3RoIGNhc2VzLCBzdHJlYW1zIGFyZSBhc3NpZ25lZCBhIGRlZmF1bHRcbiAgICAgKiAgIHdlaWdodCBvZiAxNi4gKilcbiAgICBsZXQgX3N0cmVhbSA6IFNjaGVkdWxlci5ub25yb290IFNjaGVkdWxlci5ub2RlID1cbiAgICAgIFNjaGVkdWxlci5hZGRcbiAgICAgICAgdC5zdHJlYW1zXG4gICAgICAgIH5wcmlvcml0eTpcbiAgICAgICAgICB7IFByaW9yaXR5LmRlZmF1bHRfcHJpb3JpdHkgd2l0aFxuICAgICAgICAgICAgc3RyZWFtX2RlcGVuZGVuY3kgPSBwYXJlbnRfc3RyZWFtX2lkXG4gICAgICAgICAgfVxuICAgICAgICB+aW5pdGlhbF9zZW5kX3dpbmRvd19zaXplOnQuc2V0dGluZ3MuaW5pdGlhbF93aW5kb3dfc2l6ZVxuICAgICAgICB+aW5pdGlhbF9yZWN2X3dpbmRvd19zaXplOnQuY29uZmlnLmluaXRpYWxfd2luZG93X3NpemVcbiAgICAgICAgcmVxZFxuICAgIGluXG4gICAgT2sgcmVxZFxuXG5sZXQgaGFuZGxlX2hlYWRlcnMgdCB+ZW5kX3N0cmVhbSBzdHJlYW0gYWN0aXZlX3N0cmVhbSBoZWFkZXJzID1cbiAgbGV0IChTY2hlZHVsZXIuU3RyZWFtIHsgZGVzY3JpcHRvciA9IHJlcWQ7IF8gfSkgPSBzdHJlYW0gaW5cbiAgKCogRnJvbSBSRkM3NTQwwqc1LjEuMjpcbiAgICogICBFbmRwb2ludHMgTVVTVCBOT1QgZXhjZWVkIHRoZSBsaW1pdCBzZXQgYnkgdGhlaXIgcGVlci4gQW4gZW5kcG9pbnQgdGhhdFxuICAgKiAgIHJlY2VpdmVzIGEgSEVBREVSUyBmcmFtZSB0aGF0IGNhdXNlcyBpdHMgYWR2ZXJ0aXNlZCBjb25jdXJyZW50IHN0cmVhbVxuICAgKiAgIGxpbWl0IHRvIGJlIGV4Y2VlZGVkIE1VU1QgdHJlYXQgdGhpcyBhcyBhIHN0cmVhbSBlcnJvciAoU2VjdGlvbiA1LjQuMilcbiAgICogICBvZiB0eXBlIFBST1RPQ09MX0VSUk9SIG9yIFJFRlVTRURfU1RSRUFNLiAqKVxuICBpZiBJbnQzMi4oXG4gICAgICAgY29tcGFyZVxuICAgICAgICAgKG9mX2ludCAodC5jdXJyZW50X2NsaWVudF9zdHJlYW1zICsgMSkpXG4gICAgICAgICB0LmNvbmZpZy5tYXhfY29uY3VycmVudF9zdHJlYW1zKVxuICAgICA+IDBcbiAgdGhlblxuICAgIGlmIHQudW5hY2tlZF9zZXR0aW5ncyA+IDBcbiAgICB0aGVuXG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzguMS40OlxuICAgICAgICogICBUaGUgUkVGVVNFRF9TVFJFQU0gZXJyb3IgY29kZSBjYW4gYmUgaW5jbHVkZWQgaW4gYSBSU1RfU1RSRUFNIGZyYW1lXG4gICAgICAgKiAgIHRvIGluZGljYXRlIHRoYXQgdGhlIHN0cmVhbSBpcyBiZWluZyBjbG9zZWQgcHJpb3IgdG8gYW55IHByb2Nlc3NpbmdcbiAgICAgICAqICAgaGF2aW5nIG9jY3VycmVkLiBBbnkgcmVxdWVzdCB0aGF0IHdhcyBzZW50IG9uIHRoZSByZXNldCBzdHJlYW0gY2FuXG4gICAgICAgKiAgIGJlIHNhZmVseSByZXRyaWVkLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IGlmIHRoZXJlIGFyZSBwZW5kaW5nIFNFVFRJTkdTIHRvIGFja25vd2xlZGdlLCBhc3N1bWUgdGhlcmUgd2FzIGFcbiAgICAgICAqIHJhY2UgY29uZGl0aW9uIGFuZCBsZXQgdGhlIGNsaWVudCByZXRyeS4gKilcbiAgICAgIHJlcG9ydF9zdHJlYW1fZXJyb3IgdCByZXFkLlN0cmVhbS5pZCBFcnJvcl9jb2RlLlJlZnVzZWRTdHJlYW1cbiAgICBlbHNlIHJlcG9ydF9zdHJlYW1fZXJyb3IgdCByZXFkLlN0cmVhbS5pZCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgZWxzZSAoXG4gICAgcmVxZC5zdGF0ZSA8LSBBY3RpdmUgKE9wZW4gRnVsbEhlYWRlcnMsIGFjdGl2ZV9zdHJlYW0pO1xuICAgICgqIEZyb20gUkZDNzU0MMKnNS4xLjI6XG4gICAgICogICBTdHJlYW1zIHRoYXQgYXJlIGluIHRoZSBcIm9wZW5cIiBzdGF0ZSBvciBpbiBlaXRoZXIgb2YgdGhlIFwiaGFsZi1jbG9zZWRcIlxuICAgICAqICAgc3RhdGVzIGNvdW50IHRvd2FyZCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3RyZWFtcyB0aGF0IGFuIGVuZHBvaW50IGlzXG4gICAgICogICBwZXJtaXR0ZWQgdG8gb3Blbi4gKilcbiAgICB0LmN1cnJlbnRfY2xpZW50X3N0cmVhbXMgPC0gdC5jdXJyZW50X2NsaWVudF9zdHJlYW1zICsgMTtcbiAgICBtYXRjaCBIZWFkZXJzLm1ldGhvZF9wYXRoX2FuZF9zY2hlbWVfb3JfbWFsZm9ybWVkIGhlYWRlcnMgd2l0aFxuICAgIHwgYE1hbGZvcm1lZCAtPlxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc4LjEuMi42OlxuICAgICAgICogICBGb3IgbWFsZm9ybWVkIHJlcXVlc3RzLCBhIHNlcnZlciBNQVkgc2VuZCBhbiBIVFRQIHJlc3BvbnNlIHByaW9yIHRvXG4gICAgICAgKiAgIGNsb3Npbmcgb3IgcmVzZXR0aW5nIHRoZSBzdHJlYW0uICopXG4gICAgICBzZXRfZXJyb3JfYW5kX2hhbmRsZSB0IHJlcWQgYEJhZF9yZXF1ZXN0IFByb3RvY29sRXJyb3JcbiAgICB8IGBWYWxpZCAobWV0aCwgcGF0aCwgc2NoZW1lKSAtPlxuICAgICAgKCogTm90ZTogd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgYGVuZF9zdHJlYW1gIGZsYWcgKyBhIG5vbi16ZXJvIGJvZHlcbiAgICAgICAqIGxlbmd0aCwgYXMgdGhlIHNwZWMgYWxsb3dzIGZvciBub24temVybyBjb250ZW50LWxlbmd0aCBoZWFkZXJzIGFuZCBub1xuICAgICAgICogREFUQSBmcmFtZXMuXG4gICAgICAgKlxuICAgICAgICogRnJvbSBSRkM3NTQwwqc4LjEuMi42OlxuICAgICAgICogICBBIHJlc3BvbnNlIHRoYXQgaXMgZGVmaW5lZCB0byBoYXZlIG5vIHBheWxvYWQsIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICogICBbUkZDNzIzMF0sIFNlY3Rpb24gMy4zLjIsIGNhbiBoYXZlIGEgbm9uLXplcm8gY29udGVudC1sZW5ndGggaGVhZGVyXG4gICAgICAgKiAgIGZpZWxkLCBldmVuIHRob3VnaCBubyBjb250ZW50IGlzIGluY2x1ZGVkIGluIERBVEEgZnJhbWVzLiAqKVxuICAgICAgKG1hdGNoIE1lc3NhZ2UuYm9keV9sZW5ndGggaGVhZGVycyB3aXRoXG4gICAgICB8IGBFcnJvciBlIC0+IHNldF9lcnJvcl9hbmRfaGFuZGxlIHQgcmVxZCBlIFByb3RvY29sRXJyb3JcbiAgICAgIHwgYEZpeGVkIF8gfCBgVW5rbm93biAtPlxuICAgICAgICBsZXQgcmVxdWVzdCA9XG4gICAgICAgICAgUmVxdWVzdC5jcmVhdGUgfnNjaGVtZSB+aGVhZGVycyAoSHR0cGFmLk1ldGhvZC5vZl9zdHJpbmcgbWV0aCkgcGF0aFxuICAgICAgICBpblxuICAgICAgICBsZXQgcmVxdWVzdF9ib2R5ID1cbiAgICAgICAgICBpZiBlbmRfc3RyZWFtXG4gICAgICAgICAgdGhlbiBCb2R5LlJlYWRlci5lbXB0eVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIEJvZHkuUmVhZGVyLmNyZWF0ZVxuICAgICAgICAgICAgICAoQmlnc3RyaW5nYWYuY3JlYXRlIHQuY29uZmlnLnJlcXVlc3RfYm9keV9idWZmZXJfc2l6ZSlcbiAgICAgICAgICAgICAgfmRvbmVfcmVhZGluZzooZnVuIGxlbiAtPlxuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBJbnQzMi5vZl9pbnQgbGVuIGluXG4gICAgICAgICAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjkuMTpcbiAgICAgICAgICAgICAgICAgKiAgIFRoZSByZWNlaXZlciBvZiBhIGZyYW1lIHNlbmRzIGEgV0lORE9XX1VQREFURSBmcmFtZSBhcyBpdFxuICAgICAgICAgICAgICAgICAqICAgY29uc3VtZXMgZGF0YSBhbmQgZnJlZXMgdXAgc3BhY2UgaW4gZmxvdy1jb250cm9sIHdpbmRvd3MuXG4gICAgICAgICAgICAgICAgICogICBTZXBhcmF0ZSBXSU5ET1dfVVBEQVRFIGZyYW1lcyBhcmUgc2VudCBmb3IgdGhlIHN0cmVhbS0gYW5kXG4gICAgICAgICAgICAgICAgICogICBjb25uZWN0aW9uLWxldmVsIGZsb3ctY29udHJvbCB3aW5kb3dzLiAqKVxuICAgICAgICAgICAgICAgIG1hdGNoIHJlcWQuc3RhdGUgd2l0aFxuICAgICAgICAgICAgICAgIHwgQWN0aXZlIF8gLT5cbiAgICAgICAgICAgICAgICAgIHNlbmRfd2luZG93X3VwZGF0ZSB0IHQuc3RyZWFtcyBsZW47XG4gICAgICAgICAgICAgICAgICBzZW5kX3dpbmRvd191cGRhdGUgdCBzdHJlYW0gbGVuXG4gICAgICAgICAgICAgICAgfCBJZGxlIHwgUmVzZXJ2ZWQgXyB8IENsb3NlZCBfIC0+ICgpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgcmVxdWVzdF9pbmZvID0gUmVxZC5jcmVhdGVfYWN0aXZlX3JlcXVlc3QgcmVxdWVzdCByZXF1ZXN0X2JvZHkgaW5cbiAgICAgICAgaWYgZW5kX3N0cmVhbVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgICAgICAgKiAgIFsuLi5dIGFuIGVuZHBvaW50IHJlY2VpdmluZyBhbiBFTkRfU1RSRUFNIGZsYWcgY2F1c2VzIHRoZSBzdHJlYW1cbiAgICAgICAgICAgKiAgIHN0YXRlIHRvIGJlY29tZSBcImhhbGYtY2xvc2VkIChyZW1vdGUpXCIuICopXG4gICAgICAgICAgcmVxZC5zdGF0ZSA8LSBBY3RpdmUgKEhhbGZDbG9zZWQgcmVxdWVzdF9pbmZvLCBhY3RpdmVfc3RyZWFtKTtcbiAgICAgICAgICAoKiBEZWxpdmVyIEVPRiB0byB0aGUgcmVxdWVzdCBib2R5LCBhcyB0aGUgaGFuZGxlciBtaWdodCBiZSB3YWl0aW5nXG4gICAgICAgICAgICogb24gaXQgdG8gcHJvZHVjZSBhIHJlc3BvbnNlLiAqKVxuICAgICAgICAgIEJvZHkuUmVhZGVyLmNsb3NlIHJlcXVlc3RfYm9keSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJlcWQuc3RhdGUgPC0gQWN0aXZlIChPcGVuIChBY3RpdmVNZXNzYWdlIHJlcXVlc3RfaW5mbyksIGFjdGl2ZV9zdHJlYW0pO1xuICAgICAgICB0LnJlcXVlc3RfaGFuZGxlciByZXFkO1xuICAgICAgICB3YWtldXBfd3JpdGVyIHQpKVxuXG5sZXQgaGFuZGxlX2hlYWRlcnNfYmxvY2tcbiAgICB0XG4gICAgPyhpc190cmFpbGVycyA9IGZhbHNlKVxuICAgIHN0cmVhbVxuICAgIGFjdGl2ZV9zdHJlYW1cbiAgICBwYXJ0aWFsX2hlYWRlcnNcbiAgICBmbGFnc1xuICAgIGhlYWRlcnNfYmxvY2tcbiAgPVxuICBsZXQgb3BlbiBBQiBpblxuICBsZXQgKFNjaGVkdWxlci5TdHJlYW0geyBkZXNjcmlwdG9yID0gcmVxZDsgXyB9KSA9IHN0cmVhbSBpblxuICBsZXQgZW5kX2hlYWRlcnMgPSBGbGFncy50ZXN0X2VuZF9oZWFkZXIgZmxhZ3MgaW5cbiAgKCogRnJvbSBSRkM3NTQwwqc2LjEwOlxuICAgKiAgIEFuIGVuZHBvaW50IHJlY2VpdmluZyBIRUFERVJTLCBQVVNIX1BST01JU0UsIG9yIENPTlRJTlVBVElPTlxuICAgKiAgIGZyYW1lcyBuZWVkcyB0byByZWFzc2VtYmxlIGhlYWRlciBibG9ja3MgYW5kIHBlcmZvcm0gZGVjb21wcmVzc2lvblxuICAgKiAgIGV2ZW4gaWYgdGhlIGZyYW1lcyBhcmUgdG8gYmUgZGlzY2FyZGVkICopXG4gIGxldCBwYXJzZV9zdGF0ZScgPVxuICAgIEFCLmZlZWQgcGFydGlhbF9oZWFkZXJzLlN0cmVhbS5wYXJzZV9zdGF0ZSAoYEJpZ3N0cmluZyBoZWFkZXJzX2Jsb2NrKVxuICBpblxuICBpZiBlbmRfaGVhZGVyc1xuICB0aGVuIChcbiAgICB0LnJlY2VpdmluZ19oZWFkZXJzX2Zvcl9zdHJlYW0gPC0gTm9uZTtcbiAgICBsZXQgcGFyc2Vfc3RhdGUnID0gQUIuZmVlZCBwYXJzZV9zdGF0ZScgYEVvZiBpblxuICAgIG1hdGNoIHBhcnNlX3N0YXRlJyB3aXRoXG4gICAgfCBEb25lIChfLCBPayBoZWFkZXJzKSAtPlxuICAgICAgaWYgbm90IGlzX3RyYWlsZXJzXG4gICAgICB0aGVuIChcbiAgICAgICAgKCogTm90ZTpcbiAgICAgICAgICogICB0aGUgaGlnaGVzdCBzdHJlYW0gaWRlbnRpZmllciB0aGF0IHRoZSBzZXJ2ZXIgaGFzIHNlZW4gaXMgc2V0IGhlcmVcbiAgICAgICAgICogICAoYXMgb3Bwb3NlZCB0byB3aGVuIHRoZSBzdHJlYW0gd2FzIGZpcnN0IG9wZW5lZCAtIHdoZW4gaGFuZGxpbmdcbiAgICAgICAgICogICB0aGUgZmlyc3QgSEVBREVSUyBmcmFtZSkgYmVjYXVzZSBpdCByZWZlcnMgdG8gdGhlIGhpZ2hlc3Qgc3RyZWFtXG4gICAgICAgICAqICAgaWRlbnRpZmllciB0aGF0IHRoZSBzZXJ2ZXIgd2lsbCBwcm9jZXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGcm9tIFJGQzc1NDDCpzYuODpcbiAgICAgICAgICogICBUaGUgbGFzdCBzdHJlYW0gaWRlbnRpZmllciBpbiB0aGUgR09BV0FZIGZyYW1lIGNvbnRhaW5zIHRoZVxuICAgICAgICAgKiAgIGhpZ2hlc3QtbnVtYmVyZWQgc3RyZWFtIGlkZW50aWZpZXIgZm9yIHdoaWNoIHRoZSBzZW5kZXIgb2YgdGhlXG4gICAgICAgICAqICAgR09BV0FZIGZyYW1lIG1pZ2h0IGhhdmUgdGFrZW4gc29tZSBhY3Rpb24gb24gb3IgbWlnaHQgeWV0IHRha2VcbiAgICAgICAgICogICBhY3Rpb24gb24uIEFsbCBzdHJlYW1zIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhlIGlkZW50aWZpZWQgc3RyZWFtXG4gICAgICAgICAqICAgbWlnaHQgaGF2ZSBiZWVuIHByb2Nlc3NlZCBpbiBzb21lIHdheS4gKilcbiAgICAgICAgdC5tYXhfY2xpZW50X3N0cmVhbV9pZCA8LSByZXFkLlN0cmVhbS5pZDtcbiAgICAgICAgKCogYGhhbmRsZV9oZWFkZXJzYCB3aWxsIHRha2UgY2FyZSBvZiB0cmFuc2l0aW9uaW5nIHRoZSBzdHJlYW0gc3RhdGUgKilcbiAgICAgICAgaGFuZGxlX2hlYWRlcnNcbiAgICAgICAgICB0XG4gICAgICAgICAgfmVuZF9zdHJlYW06cGFydGlhbF9oZWFkZXJzLmVuZF9zdHJlYW1cbiAgICAgICAgICBzdHJlYW1cbiAgICAgICAgICBhY3RpdmVfc3RyZWFtXG4gICAgICAgICAgaGVhZGVycylcbiAgICAgIGVsc2UgaWYgSGVhZGVycy50cmFpbGVyc192YWxpZCBoZWFkZXJzXG4gICAgICB0aGVuIChcbiAgICAgICAgUmVxZC5kZWxpdmVyX3RyYWlsZXJfaGVhZGVycyByZXFkIGhlYWRlcnM7XG4gICAgICAgIGxldCByZXF1ZXN0X2JvZHkgPSBSZXFkLnJlcXVlc3RfYm9keSByZXFkIGluXG4gICAgICAgIEJvZHkuUmVhZGVyLmNsb3NlIHJlcXVlc3RfYm9keSlcbiAgICAgIGVsc2VcbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc4LjEuMi4xOlxuICAgICAgICAgKiAgIFBzZXVkby1oZWFkZXIgZmllbGRzIE1VU1QgTk9UIGFwcGVhciBpbiB0cmFpbGVycy4gRW5kcG9pbnRzIE1VU1RcbiAgICAgICAgICogICB0cmVhdCBhIHJlcXVlc3Qgb3IgcmVzcG9uc2UgdGhhdCBjb250YWlucyB1bmRlZmluZWQgb3IgaW52YWxpZFxuICAgICAgICAgKiAgIHBzZXVkby1oZWFkZXIgZmllbGRzIGFzIG1hbGZvcm1lZCAoU2VjdGlvbiA4LjEuMi42KS4gKilcbiAgICAgICAgc2V0X2Vycm9yX2FuZF9oYW5kbGUgdCByZXFkIGBCYWRfcmVxdWVzdCBQcm90b2NvbEVycm9yXG4gICAgKCogRnJvbSBSRkM3NTQwwqc0LjM6XG4gICAgICogICBBIGRlY29kaW5nIGVycm9yIGluIGEgaGVhZGVyIGJsb2NrIE1VU1QgYmUgdHJlYXRlZCBhcyBhIGNvbm5lY3Rpb25cbiAgICAgKiAgIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlIENPTVBSRVNTSU9OX0VSUk9SLiAqKVxuICAgIHwgRG9uZSAoXywgRXJyb3IgXykgfCBQYXJ0aWFsIF8gLT5cbiAgICAgIHJlcG9ydF9jb25uZWN0aW9uX2Vycm9yIHQgRXJyb3JfY29kZS5Db21wcmVzc2lvbkVycm9yXG4gICAgfCBGYWlsIChfLCBfLCBtZXNzYWdlKSAtPlxuICAgICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCB+cmVhc29uOm1lc3NhZ2UgRXJyb3JfY29kZS5Db21wcmVzc2lvbkVycm9yKVxuICBlbHNlIHBhcnRpYWxfaGVhZGVycy5wYXJzZV9zdGF0ZSA8LSBwYXJzZV9zdGF0ZSdcblxubGV0IGhhbmRsZV90cmFpbGVyX2hlYWRlcnMgPSBoYW5kbGVfaGVhZGVyc19ibG9jayB+aXNfdHJhaWxlcnM6dHJ1ZVxuXG5sZXQgb3Blbl9zdHJlYW0gdCB+cHJpb3JpdHkgc3RyZWFtX2lkID1cbiAgaWYgbm90IFN0cmVhbV9pZGVudGlmaWVyLihzdHJlYW1faWQgPiB0Lm1heF9jbGllbnRfc3RyZWFtX2lkKVxuICB0aGVuIChcbiAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMS4xOlxuICAgICAqICAgWy4uLl0gVGhlIGlkZW50aWZpZXIgb2YgYSBuZXdseSBlc3RhYmxpc2hlZCBzdHJlYW0gTVVTVCBiZSBudW1lcmljYWxseVxuICAgICAqICAgZ3JlYXRlciB0aGFuIGFsbCBzdHJlYW1zIHRoYXQgdGhlIGluaXRpYXRpbmcgZW5kcG9pbnQgaGFzIG9wZW5lZCBvclxuICAgICAqICAgcmVzZXJ2ZWQuIFsuLi5dIEFuIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgYW4gdW5leHBlY3RlZCBzdHJlYW1cbiAgICAgKiAgIGlkZW50aWZpZXIgTVVTVCByZXNwb25kIHdpdGggYSBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZlxuICAgICAqICAgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvcjtcbiAgICBOb25lKVxuICBlbHNlXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2LjI6XG4gICAgICogICBUaGUgSEVBREVSUyBmcmFtZSAodHlwZT0weDEpIGlzIHVzZWQgdG8gb3BlbiBhIHN0cmVhbSAoU2VjdGlvbiA1LjEpLFxuICAgICAqICAgYW5kIGFkZGl0aW9uYWxseSBjYXJyaWVzIGEgaGVhZGVyIGJsb2NrIGZyYWdtZW50LiBIRUFERVJTIGZyYW1lcyBjYW5cbiAgICAgKiAgIGJlIHNlbnQgb24gYSBzdHJlYW0gaW4gdGhlIFwiaWRsZVwiLCBcInJlc2VydmVkIChsb2NhbClcIiwgXCJvcGVuXCIsIG9yXG4gICAgICogICBcImhhbGYtY2xvc2VkIChyZW1vdGUpXCIgc3RhdGUuICopXG4gICAgbWF0Y2ggU2NoZWR1bGVyLmdldF9ub2RlIHQuc3RyZWFtcyBzdHJlYW1faWQgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IHJlcWQgPVxuICAgICAgICBTdHJlYW0uY3JlYXRlXG4gICAgICAgICAgc3RyZWFtX2lkXG4gICAgICAgICAgfm1heF9mcmFtZV9zaXplOnQuc2V0dGluZ3MubWF4X2ZyYW1lX3NpemVcbiAgICAgICAgICB0LndyaXRlclxuICAgICAgICAgIHQuZXJyb3JfaGFuZGxlclxuICAgICAgICAgIChvbl9jbG9zZV9zdHJlYW0gdCBzdHJlYW1faWQpXG4gICAgICBpblxuICAgICAgbGV0IHN0cmVhbSA6IFNjaGVkdWxlci5ub25yb290IFNjaGVkdWxlci5ub2RlID1cbiAgICAgICAgU2NoZWR1bGVyLmFkZFxuICAgICAgICAgIHQuc3RyZWFtc1xuICAgICAgICAgIH5wcmlvcml0eVxuICAgICAgICAgIH5pbml0aWFsX3NlbmRfd2luZG93X3NpemU6dC5zZXR0aW5ncy5pbml0aWFsX3dpbmRvd19zaXplXG4gICAgICAgICAgfmluaXRpYWxfcmVjdl93aW5kb3dfc2l6ZTp0LmNvbmZpZy5pbml0aWFsX3dpbmRvd19zaXplXG4gICAgICAgICAgcmVxZFxuICAgICAgaW5cbiAgICAgIFNvbWUgc3RyZWFtXG4gICAgfCBTb21lIChTY2hlZHVsZXIuU3RyZWFtIG5vZGUgYXMgc3RyZWFtKSAtPlxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjkuMjpcbiAgICAgICAqICAgQm90aCBlbmRwb2ludHMgY2FuIGFkanVzdCB0aGUgaW5pdGlhbCB3aW5kb3cgc2l6ZSBmb3IgbmV3IHN0cmVhbXNcbiAgICAgICAqICAgYnkgaW5jbHVkaW5nIGEgdmFsdWUgZm9yIFNFVFRJTkdTX0lOSVRJQUxfV0lORE9XX1NJWkUgaW4gdGhlXG4gICAgICAgKiAgIFNFVFRJTkdTIGZyYW1lLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IHdlIGFscmVhZHkgaGF2ZSB0aGUgc3RyZWFtIGluIHRoZSBwcmlvcml0eSB0cmVlLCBhbmQgdGhlXG4gICAgICAgKiBkZWZhdWx0IGluaXRpYWwgd2luZG93IHNpemUgZm9yIG5ldyBzdHJlYW1zIGNvdWxkIGhhdmUgY2hhbmdlZFxuICAgICAgICogYmV0d2VlbiBhZGRpbmcgdGhlIChpZGxlKSBzdHJlYW0gYW5kIG9wZW5pbmcgaXQuXG4gICAgICAgKlxuICAgICAgICogTm90ZTogYGluZmxvd2AgZG9lc24ndCBjaGFuZ2UsIHRoYXQncyBzZXQgYnkgdXMgc3RhdGljYWxseSB2aWEgY29uZmlnLlxuICAgICAgICopXG4gICAgICBub2RlLmZsb3cgPC0gdC5zZXR0aW5ncy5pbml0aWFsX3dpbmRvd19zaXplO1xuICAgICAgU29tZSBzdHJlYW1cblxubGV0IHByb2Nlc3NfZmlyc3RfaGVhZGVyc19ibG9jayB0IGZyYW1lX2hlYWRlciBzdHJlYW0gaGVhZGVyc19ibG9jayA9XG4gIGxldCAoU2NoZWR1bGVyLlN0cmVhbSB7IGRlc2NyaXB0b3IgPSByZXFkOyBfIH0pID0gc3RyZWFtIGluXG4gIGxldCB7IEZyYW1lLnN0cmVhbV9pZDsgZmxhZ3M7IF8gfSA9IGZyYW1lX2hlYWRlciBpblxuICBsZXQgZW5kX2hlYWRlcnMgPSBGbGFncy50ZXN0X2VuZF9oZWFkZXIgZmxhZ3MgaW5cbiAgbGV0IGhlYWRlcnNfYmxvY2tfbGVuZ3RoID0gQmlnc3RyaW5nYWYubGVuZ3RoIGhlYWRlcnNfYmxvY2sgaW5cbiAgbGV0IGluaXRpYWxfYnVmZmVyX3NpemUgPVxuICAgIGlmIGVuZF9oZWFkZXJzXG4gICAgdGhlbiBoZWFkZXJzX2Jsb2NrX2xlbmd0aFxuICAgIGVsc2VcbiAgICAgICgqIENvbnNlcnZhdGl2ZSBlc3RpbWF0ZSB0aGF0IHRoZXJlJ3Mgb25seSBnb2luZyB0byBiZSBvbmUgQ09OVElOVUFUSU9OXG4gICAgICAgKiBmcmFtZS4gKilcbiAgICAgIDIgKiBoZWFkZXJzX2Jsb2NrX2xlbmd0aFxuICBpblxuICBsZXQgcGFydGlhbF9oZWFkZXJzID1cbiAgICB7IFN0cmVhbS5wYXJzZV9zdGF0ZSA9XG4gICAgICAgIEFCLnBhcnNlXG4gICAgICAgICAgfmluaXRpYWxfYnVmZmVyX3NpemVcbiAgICAgICAgICAoSHBhY2suRGVjb2Rlci5kZWNvZGVfaGVhZGVycyB0LmhwYWNrX2RlY29kZXIpXG4gICAgOyBlbmRfc3RyZWFtID0gRmxhZ3MudGVzdF9lbmRfc3RyZWFtIGZsYWdzXG4gICAgfVxuICBpblxuICBsZXQgYWN0aXZlX3N0cmVhbSA9XG4gICAgUmVxZC5jcmVhdGVfYWN0aXZlX3N0cmVhbVxuICAgICAgdC5ocGFja19lbmNvZGVyXG4gICAgICB0LmNvbmZpZy5yZXNwb25zZV9ib2R5X2J1ZmZlcl9zaXplXG4gICAgICAoY3JlYXRlX3B1c2hfc3RyZWFtIHQpXG4gIGluXG4gIHJlcWQuU3RyZWFtLnN0YXRlIDwtXG4gICAgQWN0aXZlIChPcGVuIChQYXJ0aWFsSGVhZGVycyBwYXJ0aWFsX2hlYWRlcnMpLCBhY3RpdmVfc3RyZWFtKTtcbiAgaWYgbm90IGVuZF9oZWFkZXJzIHRoZW4gdC5yZWNlaXZpbmdfaGVhZGVyc19mb3Jfc3RyZWFtIDwtIFNvbWUgc3RyZWFtX2lkO1xuICBoYW5kbGVfaGVhZGVyc19ibG9ja1xuICAgIHRcbiAgICBzdHJlYW1cbiAgICBhY3RpdmVfc3RyZWFtXG4gICAgcGFydGlhbF9oZWFkZXJzXG4gICAgZmxhZ3NcbiAgICBoZWFkZXJzX2Jsb2NrXG5cbmxldCBwcm9jZXNzX3RyYWlsZXJfaGVhZGVycyB0IHN0cmVhbSBhY3RpdmVfc3RyZWFtIGZyYW1lX2hlYWRlciBoZWFkZXJzX2Jsb2NrID1cbiAgbGV0IChTY2hlZHVsZXIuU3RyZWFtIHsgZGVzY3JpcHRvciA9IHJlcWQ7IF8gfSkgPSBzdHJlYW0gaW5cbiAgbGV0IHsgRnJhbWUuc3RyZWFtX2lkOyBmbGFnczsgXyB9ID0gZnJhbWVfaGVhZGVyIGluXG4gIGxldCBlbmRfc3RyZWFtID0gRmxhZ3MudGVzdF9lbmRfc3RyZWFtIGZsYWdzIGluXG4gIGlmIG5vdCBlbmRfc3RyZWFtXG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzguMTpcbiAgICAgKiAgIEEgSEVBREVSUyBmcmFtZSAoYW5kIGFzc29jaWF0ZWQgQ09OVElOVUFUSU9OIGZyYW1lcykgY2FuIG9ubHkgYXBwZWFyXG4gICAgICogICBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgc3RyZWFtLiBBbiBlbmRwb2ludCB0aGF0IHJlY2VpdmVzIGEgSEVBREVSU1xuICAgICAqICAgZnJhbWUgd2l0aG91dCB0aGUgRU5EX1NUUkVBTSBmbGFnIHNldCBhZnRlciByZWNlaXZpbmcgYSBmaW5hbFxuICAgICAqICAgKG5vbi1pbmZvcm1hdGlvbmFsKSBzdGF0dXMgY29kZSBNVVNUIHRyZWF0IHRoZSBjb3JyZXNwb25kaW5nIHJlcXVlc3RcbiAgICAgKiAgIG9yIHJlc3BvbnNlIGFzIG1hbGZvcm1lZCAoU2VjdGlvbiA4LjEuMi42KS4gKilcbiAgICBzZXRfZXJyb3JfYW5kX2hhbmRsZSB0IHJlcWQgYEJhZF9yZXF1ZXN0IFByb3RvY29sRXJyb3JcbiAgZWxzZVxuICAgIGxldCBwYXJ0aWFsX2hlYWRlcnMgPVxuICAgICAgeyBTdHJlYW0ucGFyc2Vfc3RhdGUgPVxuICAgICAgICAgIEFCLnBhcnNlIChIcGFjay5EZWNvZGVyLmRlY29kZV9oZWFkZXJzIHQuaHBhY2tfZGVjb2RlcilcbiAgICAgICAgICAoKiBvYnZpb3VzbHkgdHJ1ZSBhdCB0aGlzIHBvaW50LiAqKVxuICAgICAgOyBlbmRfc3RyZWFtXG4gICAgICB9XG4gICAgaW5cbiAgICBhY3RpdmVfc3RyZWFtLlJlcWQudHJhaWxlcnNfcGFyc2VyIDwtIFNvbWUgcGFydGlhbF9oZWFkZXJzO1xuICAgIGlmIG5vdCBGbGFncy4odGVzdF9lbmRfaGVhZGVyIGZsYWdzKVxuICAgIHRoZW4gdC5yZWNlaXZpbmdfaGVhZGVyc19mb3Jfc3RyZWFtIDwtIFNvbWUgc3RyZWFtX2lkO1xuICAgICgqIHRyYWlsZXIgaGVhZGVyczogUkZDNzIzMMKnNC40ICopXG4gICAgaGFuZGxlX3RyYWlsZXJfaGVhZGVyc1xuICAgICAgdFxuICAgICAgc3RyZWFtXG4gICAgICBhY3RpdmVfc3RyZWFtXG4gICAgICBwYXJ0aWFsX2hlYWRlcnNcbiAgICAgIGZsYWdzXG4gICAgICBoZWFkZXJzX2Jsb2NrXG5cbmxldCBwcm9jZXNzX2hlYWRlcnNfZnJhbWUgdCB7IEZyYW1lLmZyYW1lX2hlYWRlcjsgXyB9IH5wcmlvcml0eSBoZWFkZXJzX2Jsb2NrID1cbiAgbGV0IHsgRnJhbWUuc3RyZWFtX2lkOyBfIH0gPSBmcmFtZV9oZWFkZXIgaW5cbiAgbGV0IHsgUHJpb3JpdHkuc3RyZWFtX2RlcGVuZGVuY3k7IF8gfSA9IHByaW9yaXR5IGluXG4gIGlmIG5vdCBTdHJlYW1faWRlbnRpZmllci4oaXNfcmVxdWVzdCBzdHJlYW1faWQpXG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMS4xOlxuICAgICAqICAgU3RyZWFtcyBpbml0aWF0ZWQgYnkgYSBjbGllbnQgTVVTVCB1c2Ugb2RkLW51bWJlcmVkIHN0cmVhbVxuICAgICAqICAgaWRlbnRpZmllcnMuIFsuLi5dIEFuIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgYW4gdW5leHBlY3RlZFxuICAgICAqICAgc3RyZWFtIGlkZW50aWZpZXIgTVVTVCByZXNwb25kIHdpdGggYSBjb25uZWN0aW9uIGVycm9yXG4gICAgICogICAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuICBlbHNlIGlmIFN0cmVhbV9pZGVudGlmaWVyLihzdHJlYW1fZGVwZW5kZW5jeSA9PT0gc3RyZWFtX2lkKVxuICB0aGVuXG4gICAgKCogRnJvbSBSRkM3NTQwwqc1LjMuMTpcbiAgICAgKiAgIEEgc3RyZWFtIGNhbm5vdCBkZXBlbmQgb24gaXRzZWxmLiBBbiBlbmRwb2ludCBNVVNUIHRyZWF0IHRoaXMgYXMgYVxuICAgICAqICAgc3RyZWFtIGVycm9yIChTZWN0aW9uIDUuNC4yKSBvZiB0eXBlIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgIHJlcG9ydF9zdHJlYW1fZXJyb3IgdCBzdHJlYW1faWQgRXJyb3JfY29kZS5Qcm90b2NvbEVycm9yXG4gIGVsc2VcbiAgICBtYXRjaCBTY2hlZHVsZXIuZ2V0X25vZGUgdC5zdHJlYW1zIHN0cmVhbV9pZCB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAobWF0Y2ggb3Blbl9zdHJlYW0gdCB+cHJpb3JpdHkgc3RyZWFtX2lkIHdpdGhcbiAgICAgIHwgU29tZSByZXFkIC0+XG4gICAgICAgIHByb2Nlc3NfZmlyc3RfaGVhZGVyc19ibG9jayB0IGZyYW1lX2hlYWRlciByZXFkIGhlYWRlcnNfYmxvY2tcbiAgICAgIHwgTm9uZSAtPiAoKSlcbiAgICB8IFNvbWUgKFNjaGVkdWxlci5TdHJlYW0geyBkZXNjcmlwdG9yID0gcmVxZDsgXyB9IGFzIHN0cmVhbSkgLT5cbiAgICAgIChtYXRjaCByZXFkLnN0YXRlIHdpdGhcbiAgICAgIHwgSWRsZSAtPlxuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuMjpcbiAgICAgICAgICogICBIRUFERVJTIGZyYW1lcyBjYW4gYmUgc2VudCBvbiBhIHN0cmVhbSBpbiB0aGUgXCJpZGxlXCIsIFwicmVzZXJ2ZWRcbiAgICAgICAgICogICAobG9jYWwpXCIsIFwib3BlblwiLCBvciBcImhhbGYtY2xvc2VkIChyZW1vdGUpXCIgc3RhdGUuICopXG4gICAgICAgIChtYXRjaCBvcGVuX3N0cmVhbSB0IH5wcmlvcml0eSBzdHJlYW1faWQgd2l0aFxuICAgICAgICB8IFNvbWUgcmVxZCAtPlxuICAgICAgICAgIHByb2Nlc3NfZmlyc3RfaGVhZGVyc19ibG9jayB0IGZyYW1lX2hlYWRlciByZXFkIGhlYWRlcnNfYmxvY2tcbiAgICAgICAgfCBOb25lIC0+ICgpKVxuICAgICAgfCBBY3RpdmUgKE9wZW4gKFdhaXRpbmdGb3JQZWVyIHwgUGFydGlhbEhlYWRlcnMgXyksIF8pIC0+XG4gICAgICAgICgqIFRoaXMgY2FzZSBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHdlIGNoZWNrIHRoYXQgcGFydGlhbCBIRUFERVJTXG4gICAgICAgICAqIHN0YXRlcyBtdXN0IGJlIGZvbGxvd2VkIGJ5IENPTlRJTlVBVElPTiBmcmFtZXMgZWxzZXdoZXJlLiAqKVxuICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICAgICgqIGlmIHdlJ3JlIGdldHRpbmcgYSBIRUFERVJTIGZyYW1lIGF0IHRoaXMgcG9pbnQsIHRoZXkgbXVzdCBiZVxuICAgICAgICogdHJhaWxlcnMsIGFuZCB0aGUgRU5EX1NUUkVBTSBmbGFnIG5lZWRzIHRvIGJlIHNldC4gKilcbiAgICAgIHwgQWN0aXZlIChPcGVuIChGdWxsSGVhZGVycyB8IEFjdGl2ZU1lc3NhZ2UgXyksIGFjdGl2ZV9zdHJlYW0pIC0+XG4gICAgICAgIHByb2Nlc3NfdHJhaWxlcl9oZWFkZXJzXG4gICAgICAgICAgdFxuICAgICAgICAgIHN0cmVhbVxuICAgICAgICAgIGFjdGl2ZV9zdHJlYW1cbiAgICAgICAgICBmcmFtZV9oZWFkZXJcbiAgICAgICAgICBoZWFkZXJzX2Jsb2NrO1xuICAgICAgICBTdHJlYW0uZmluaXNoX3N0cmVhbSByZXFkIEZpbmlzaGVkXG4gICAgICB8IEFjdGl2ZSAoSGFsZkNsb3NlZCBfLCBfKVxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc1LjE6XG4gICAgICAgKiAgIGhhbGYtY2xvc2VkIChyZW1vdGUpOiBbLi4uXSBJZiBhbiBlbmRwb2ludCByZWNlaXZlcyBhZGRpdGlvbmFsXG4gICAgICAgKiAgIGZyYW1lcywgb3RoZXIgdGhhbiBXSU5ET1dfVVBEQVRFLCBQUklPUklUWSwgb3IgUlNUX1NUUkVBTSwgZm9yIGFcbiAgICAgICAqICAgc3RyZWFtIHRoYXQgaXMgaW4gdGhpcyBzdGF0ZSwgaXQgTVVTVCByZXNwb25kIHdpdGggYSBzdHJlYW1cbiAgICAgICAqICAgZXJyb3IgKFNlY3Rpb24gNS40LjIpIG9mIHR5cGUgU1RSRUFNX0NMT1NFRC4gKilcbiAgICAgIHwgQ2xvc2VkIHsgcmVhc29uID0gUmVzZXRCeVRoZW0gXzsgXyB9IC0+XG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4xOlxuICAgICAgICAgKiAgIGNsb3NlZDogWy4uLl0gQW4gZW5kcG9pbnQgdGhhdCByZWNlaXZlcyBhbnkgZnJhbWUgb3RoZXIgdGhhblxuICAgICAgICAgKiAgIFBSSU9SSVRZIGFmdGVyIHJlY2VpdmluZyBhIFJTVF9TVFJFQU0gTVVTVCB0cmVhdCB0aGF0IGFzIGFcbiAgICAgICAgICogICBzdHJlYW0gZXJyb3IgKFNlY3Rpb24gNS40LjIpIG9mIHR5cGUgU1RSRUFNX0NMT1NFRC4gKilcbiAgICAgICAgcmVwb3J0X3N0cmVhbV9lcnJvciB0IHN0cmVhbV9pZCBFcnJvcl9jb2RlLlN0cmVhbUNsb3NlZFxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc1LjE6XG4gICAgICAgKiAgIHJlc2VydmVkIChsb2NhbCk6IFsuLi5dIFJlY2VpdmluZyBhbnkgdHlwZSBvZiBmcmFtZSBvdGhlciB0aGFuXG4gICAgICAgKiAgIFJTVF9TVFJFQU0sIFBSSU9SSVRZLCBvciBXSU5ET1dfVVBEQVRFIG9uIGEgc3RyZWFtIGluIHRoaXMgc3RhdGVcbiAgICAgICAqICAgTVVTVCBiZSB0cmVhdGVkIGFzIGEgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZVxuICAgICAgICogICBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICAgIHwgUmVzZXJ2ZWQgXyB8IENsb3NlZCBfIC0+XG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4xOlxuICAgICAgICAgKiAgIFNpbWlsYXJseSwgYW4gZW5kcG9pbnQgdGhhdCByZWNlaXZlcyBhbnkgZnJhbWVzIGFmdGVyIHJlY2VpdmluZ1xuICAgICAgICAgKiAgIGEgZnJhbWUgd2l0aCB0aGUgRU5EX1NUUkVBTSBmbGFnIHNldCBNVVNUIHRyZWF0IHRoYXQgYXMgYVxuICAgICAgICAgKiAgIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgU1RSRUFNX0NMT1NFRCBbLi4uXS4gKilcbiAgICAgICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLlN0cmVhbUNsb3NlZClcblxubGV0IHByb2Nlc3NfZGF0YV9mcmFtZSB0IHsgRnJhbWUuZnJhbWVfaGVhZGVyOyBfIH0gYnN0ciA9XG4gIGxldCBvcGVuIFNjaGVkdWxlciBpblxuICBsZXQgeyBGcmFtZS5mbGFnczsgc3RyZWFtX2lkOyBwYXlsb2FkX2xlbmd0aDsgXyB9ID0gZnJhbWVfaGVhZGVyIGluXG4gIGlmIG5vdCAoU3RyZWFtX2lkZW50aWZpZXIuaXNfcmVxdWVzdCBzdHJlYW1faWQpXG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMS4xOlxuICAgICAqICAgU3RyZWFtcyBpbml0aWF0ZWQgYnkgYSBjbGllbnQgTVVTVCB1c2Ugb2RkLW51bWJlcmVkIHN0cmVhbVxuICAgICAqICAgaWRlbnRpZmllcnMuIFsuLi5dIEFuIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgYW4gdW5leHBlY3RlZCBzdHJlYW1cbiAgICAgKiAgIGlkZW50aWZpZXIgTVVTVCByZXNwb25kIHdpdGggYSBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZlxuICAgICAqICAgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuICBlbHNlXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2Ljk6XG4gICAgICogICBBIHJlY2VpdmVyIHRoYXQgcmVjZWl2ZXMgYSBmbG93LWNvbnRyb2xsZWQgZnJhbWUgTVVTVCBhbHdheXMgYWNjb3VudFxuICAgICAqICAgZm9yIGl0cyBjb250cmlidXRpb24gYWdhaW5zdCB0aGUgY29ubmVjdGlvbiBmbG93LWNvbnRyb2wgd2luZG93LFxuICAgICAqICAgdW5sZXNzIHRoZSByZWNlaXZlciB0cmVhdHMgdGhpcyBhcyBhIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpLlxuICAgICAqICAgVGhpcyBpcyBuZWNlc3NhcnkgZXZlbiBpZiB0aGUgZnJhbWUgaXMgaW4gZXJyb3IuICopXG4gICAgbGV0IHBheWxvYWRfbGVuMzIgPSBJbnQzMi5vZl9pbnQgcGF5bG9hZF9sZW5ndGggaW5cbiAgICBTY2hlZHVsZXIuZGVkdWN0X2luZmxvdyB0LnN0cmVhbXMgcGF5bG9hZF9sZW4zMjtcbiAgICBtYXRjaCBTY2hlZHVsZXIuZ2V0X25vZGUgdC5zdHJlYW1zIHN0cmVhbV9pZCB3aXRoXG4gICAgfCBTb21lIChTdHJlYW0geyBkZXNjcmlwdG9yOyBfIH0gYXMgc3RyZWFtKSAtPlxuICAgICAgKG1hdGNoIGRlc2NyaXB0b3Iuc3RhdGUgd2l0aFxuICAgICAgfCBBY3RpdmUgKE9wZW4gKEFjdGl2ZU1lc3NhZ2UgcmVxdWVzdF9pbmZvKSwgYWN0aXZlX3N0cmVhbSkgLT5cbiAgICAgICAgbGV0IHJlcXVlc3RfYm9keSA9IFJlcWQucmVxdWVzdF9ib2R5IGRlc2NyaXB0b3IgaW5cbiAgICAgICAgcmVxdWVzdF9pbmZvLnJlcXVlc3RfYm9keV9ieXRlcyA8LVxuICAgICAgICAgIEludDY0LihcbiAgICAgICAgICAgIGFkZFxuICAgICAgICAgICAgICByZXF1ZXN0X2luZm8ucmVxdWVzdF9ib2R5X2J5dGVzXG4gICAgICAgICAgICAgIChvZl9pbnQgKEJpZ3N0cmluZ2FmLmxlbmd0aCBic3RyKSkpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHJlcXVlc3RfaW5mby5yZXF1ZXN0IGluXG4gICAgICAgIGlmIG5vdCBTY2hlZHVsZXIuKGFsbG93ZWRfdG9fcmVjZWl2ZSB0LnN0cmVhbXMgc3RyZWFtIHBheWxvYWRfbGVuMzIpXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi45OlxuICAgICAgICAgICAqICBBIHJlY2VpdmVyIE1BWSByZXNwb25kIHdpdGggYSBzdHJlYW0gZXJyb3IgKFNlY3Rpb24gNS40LjIpIG9yXG4gICAgICAgICAgICogIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgRkxPV19DT05UUk9MX0VSUk9SIGlmIGl0XG4gICAgICAgICAgICogIGlzIHVuYWJsZSB0byBhY2NlcHQgYSBmcmFtZS4gKilcbiAgICAgICAgICBzZW5kX3dpbmRvd191cGRhdGUgdCB0LnN0cmVhbXMgcGF5bG9hZF9sZW4zMjtcbiAgICAgICAgICByZXBvcnRfc3RyZWFtX2Vycm9yIHQgc3RyZWFtX2lkIEVycm9yX2NvZGUuRmxvd0NvbnRyb2xFcnJvcilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgU2NoZWR1bGVyLmRlZHVjdF9pbmZsb3cgc3RyZWFtIHBheWxvYWRfbGVuMzI7XG4gICAgICAgICAgbWF0Y2ggTWVzc2FnZS5ib2R5X2xlbmd0aCByZXF1ZXN0LmhlYWRlcnMgd2l0aFxuICAgICAgICAgIHwgYEZpeGVkIGxlblxuICAgICAgICAgICgqIEdldHRpbmcgbW9yZSB0aGFuIHRoZSBjbGllbnQgZGVjbGFyZWQgKilcbiAgICAgICAgICAgIHdoZW4gSW50NjQuY29tcGFyZSByZXF1ZXN0X2luZm8ucmVxdWVzdF9ib2R5X2J5dGVzIGxlbiA+IDAgLT5cbiAgICAgICAgICAgICgqIEdpdmUgYmFjayBjb25uZWN0aW9uLWxldmVsIGZsb3ctY29udHJvbGxlZCBieXRlcyAod2UgdXNlIHBheWxvYWRcbiAgICAgICAgICAgICAqIGxlbmd0aCB0byBpbmNsdWRlIGFueSBwYWRkaW5nIGJ5dGVzIHRoYXQgdGhlIGZyYW1lIG1pZ2h0IGhhdmVcbiAgICAgICAgICAgICAqIGluY2x1ZGVkIC0gd2hpY2ggd2VyZSBpZ25vcmVkIGF0IHBhcnNlIHRpbWUpLiAqKVxuICAgICAgICAgICAgc2VuZF93aW5kb3dfdXBkYXRlIHQgdC5zdHJlYW1zIHBheWxvYWRfbGVuMzI7XG4gICAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzguMS4yLjY6XG4gICAgICAgICAgICAgKiAgIEEgcmVxdWVzdCBvciByZXNwb25zZSBpcyBhbHNvIG1hbGZvcm1lZCBpZiB0aGUgdmFsdWUgb2YgYVxuICAgICAgICAgICAgICogICBjb250ZW50LWxlbmd0aCBoZWFkZXIgZmllbGQgZG9lcyBub3QgZXF1YWwgdGhlIHN1bSBvZiB0aGVcbiAgICAgICAgICAgICAqICAgREFUQSBmcmFtZSBwYXlsb2FkIGxlbmd0aHMgdGhhdCBmb3JtIHRoZSBib2R5LiAqKVxuICAgICAgICAgICAgc2V0X2Vycm9yX2FuZF9oYW5kbGUgdCBkZXNjcmlwdG9yIGBCYWRfcmVxdWVzdCBQcm90b2NvbEVycm9yXG4gICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBsZXQgZW5kX3N0cmVhbSA9IEZsYWdzLnRlc3RfZW5kX3N0cmVhbSBmbGFncyBpblxuICAgICAgICAgICAgaWYgZW5kX3N0cmVhbVxuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICBpZiAoKiBGcm9tIFJGQzc1NDDCpzYuMTpcbiAgICAgICAgICAgICAgICAgICogICBXaGVuIHNldCwgYml0IDAgaW5kaWNhdGVzIHRoYXQgdGhpcyBmcmFtZSBpcyB0aGUgbGFzdCB0aGF0XG4gICAgICAgICAgICAgICAgICAqICAgdGhlIGVuZHBvaW50IHdpbGwgc2VuZCBmb3IgdGhlIGlkZW50aWZpZWQgc3RyZWFtLiBTZXR0aW5nXG4gICAgICAgICAgICAgICAgICAqICAgdGhpcyBmbGFnIGNhdXNlcyB0aGUgc3RyZWFtIHRvIGVudGVyIG9uZSBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICogICBcImhhbGYtY2xvc2VkXCIgc3RhdGVzIG9yIHRoZSBcImNsb3NlZFwiIHN0YXRlXG4gICAgICAgICAgICAgICAgICAqICAgKFNlY3Rpb24gNS4xKS4gKilcbiAgICAgICAgICAgICAgICAgUmVxZC5yZXF1aXJlc19vdXRwdXQgZGVzY3JpcHRvclxuICAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICAgKCogVGhlcmUncyBhIHBvdGVudGlhbCByYWNlIGNvbmRpdGlvbiBoZXJlIGlmIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICogaGFuZGxlciBjb21wbGV0ZXMgdGhlIHJlc3BvbnNlIHJpZ2h0IGFmdGVyLiAqKVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3Iuc3RhdGUgPC1cbiAgICAgICAgICAgICAgICAgIEFjdGl2ZSAoSGFsZkNsb3NlZCByZXF1ZXN0X2luZm8sIGFjdGl2ZV9zdHJlYW0pXG4gICAgICAgICAgICAgIGVsc2UgU3RyZWFtLmZpbmlzaF9zdHJlYW0gZGVzY3JpcHRvciBGaW5pc2hlZDtcbiAgICAgICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi45LjE6XG4gICAgICAgICAgICAgKiAgIFRoZSByZWNlaXZlciBvZiBhIGZyYW1lIHNlbmRzIGEgV0lORE9XX1VQREFURSBmcmFtZSBhcyBpdFxuICAgICAgICAgICAgICogICBjb25zdW1lcyBkYXRhIGFuZCBmcmVlcyB1cCBzcGFjZSBpbiBmbG93LWNvbnRyb2wgd2luZG93cy5cbiAgICAgICAgICAgICAqICAgU2VwYXJhdGUgV0lORE9XX1VQREFURSBmcmFtZXMgYXJlIHNlbnQgZm9yIHRoZSBzdHJlYW0tIGFuZFxuICAgICAgICAgICAgICogICBjb25uZWN0aW9uLWxldmVsIGZsb3ctY29udHJvbCB3aW5kb3dzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE5vdGU6IHdlIHNlbmQgdGhlc2UgV0lORE9XX1VQREFURSBmcmFtZXMgb25jZSB0aGUgYm9keSBieXRlc1xuICAgICAgICAgICAgICogaGF2ZSBiZWVuIHN1cmZhY2VkIHRvIHRoZSBhcHBsaWNhdGlvbi4gVGhpcyBpcyBkb25lIGluIHRoZVxuICAgICAgICAgICAgICogcmVjb3JkIGZpZWxkIGBkb25lX3JlYWRpbmdgIG9mIGBCb2R5LnRgLiAqKVxuICAgICAgICAgICAgbGV0IGZhcmFkYXkgPSBCb2R5LlJlYWRlci51bnNhZmVfZmFyYWRheSByZXF1ZXN0X2JvZHkgaW5cbiAgICAgICAgICAgIGlmIG5vdCAoRmFyYWRheS5pc19jbG9zZWQgZmFyYWRheSlcbiAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICBGYXJhZGF5LnNjaGVkdWxlX2JpZ3N0cmluZyBmYXJhZGF5IGJzdHI7XG4gICAgICAgICAgICAgIGlmIGVuZF9zdHJlYW0gdGhlbiBCb2R5LlJlYWRlci5jbG9zZSByZXF1ZXN0X2JvZHkpO1xuICAgICAgICAgICAgUmVxZC5mbHVzaF9yZXF1ZXN0X2JvZHkgZGVzY3JpcHRvcilcbiAgICAgIHwgSWRsZSAtPlxuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgICAgICogICBpZGxlOiBbLi4uXSBSZWNlaXZpbmcgYW55IGZyYW1lIG90aGVyIHRoYW4gSEVBREVSUyBvciBQUklPUklUWSBvblxuICAgICAgICAgKiAgIGEgc3RyZWFtIGluIHRoaXMgc3RhdGUgTVVTVCBiZSB0cmVhdGVkIGFzIGEgY29ubmVjdGlvbiBlcnJvclxuICAgICAgICAgKiAgIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuICAgICAgKCogVGhpcyBpcyB0ZWNobmljYWxseSBpbiB0aGUgaGFsZi1jbG9zZWQgKGxvY2FsKSBzdGF0ZSAqKVxuICAgICAgfCBDbG9zZWQgeyByZWFzb24gPSBSZXNldEJ5VXMgTm9FcnJvcjsgXyB9IC0+XG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi45OlxuICAgICAgICAgKiAgIEEgcmVjZWl2ZXIgdGhhdCByZWNlaXZlcyBhIGZsb3ctY29udHJvbGxlZCBmcmFtZSBNVVNUIGFsd2F5c1xuICAgICAgICAgKiAgIGFjY291bnQgZm9yIGl0cyBjb250cmlidXRpb24gYWdhaW5zdCB0aGUgY29ubmVjdGlvbiBmbG93LWNvbnRyb2xcbiAgICAgICAgICogICB3aW5kb3csIHVubGVzcyB0aGUgcmVjZWl2ZXIgdHJlYXRzIHRoaXMgYXMgYSBjb25uZWN0aW9uIGVycm9yXG4gICAgICAgICAqICAgKFNlY3Rpb24gNS40LjEpLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBmcmFtZSBpcyBpblxuICAgICAgICAgKiAgIGVycm9yLiAqKVxuICAgICAgICBzZW5kX3dpbmRvd191cGRhdGUgdCB0LnN0cmVhbXMgcGF5bG9hZF9sZW4zMlxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjQ6XG4gICAgICAgKiAgIFsuLi5dIGFmdGVyIHNlbmRpbmcgdGhlIFJTVF9TVFJFQU0sIHRoZSBzZW5kaW5nIGVuZHBvaW50IE1VU1QgYmVcbiAgICAgICAqICAgcHJlcGFyZWQgdG8gcmVjZWl2ZSBhbmQgcHJvY2VzcyBhZGRpdGlvbmFsIGZyYW1lcyBzZW50IG9uIHRoZVxuICAgICAgICogICBzdHJlYW0gdGhhdCBtaWdodCBoYXZlIGJlZW4gc2VudCBieSB0aGUgcGVlciBwcmlvciB0byB0aGUgYXJyaXZhbFxuICAgICAgICogICBvZiB0aGUgUlNUX1NUUkVBTS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlOiBhZnRlciBzb21lIHdyaXRlciB5aWVsZHMgLyB3YWtlIHVwcywgd2Ugd2lsbCBoYXZlIHN0b3BwZWRcbiAgICAgICAqIGtlZXBpbmcgc3RhdGUgaW5mb3JtYXRpb24gZm9yIHRoZSBzdHJlYW0uIFRoaXMgZnVuY3Rpb25zIGVmZmVjdGl2ZWx5XG4gICAgICAgKiBhcyBhIHdheSBvZiBvbmx5IGFjY2VwdGluZyBmcmFtZXMgYWZ0ZXIgYW4gUlNUX1NUUkVBTSBmcm9tIHVzIHVwIHRvXG4gICAgICAgKiBhIHRpbWUgbGltaXQuICopXG4gICAgICB8IF8gLT5cbiAgICAgICAgc2VuZF93aW5kb3dfdXBkYXRlIHQgdC5zdHJlYW1zIHBheWxvYWRfbGVuMzI7XG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi4xOlxuICAgICAgICAgKiAgIElmIGEgREFUQSBmcmFtZSBpcyByZWNlaXZlZCB3aG9zZSBzdHJlYW0gaXMgbm90IGluIFwib3BlblwiIG9yXG4gICAgICAgICAqICAgXCJoYWxmLWNsb3NlZCAobG9jYWwpXCIgc3RhdGUsIHRoZSByZWNpcGllbnQgTVVTVCByZXNwb25kIHdpdGggYVxuICAgICAgICAgKiAgIHN0cmVhbSBlcnJvciAoU2VjdGlvbiA1LjQuMikgb2YgdHlwZSBTVFJFQU1fQ0xPU0VELiAqKVxuICAgICAgICByZXBvcnRfc3RyZWFtX2Vycm9yIHQgc3RyZWFtX2lkIEVycm9yX2NvZGUuU3RyZWFtQ2xvc2VkKVxuICAgIHwgTm9uZSAtPlxuICAgICAgaWYgbm90ICh3YXNfY2xvc2VkX29yX2ltcGxpY2l0bHlfY2xvc2VkIHQgc3RyZWFtX2lkKVxuICAgICAgdGhlblxuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgICAgICogICBpZGxlOiBbLi4uXSBSZWNlaXZpbmcgYW55IGZyYW1lIG90aGVyIHRoYW4gSEVBREVSUyBvciBQUklPUklUWSBvblxuICAgICAgICAgKiAgIGEgc3RyZWFtIGluIHRoaXMgc3RhdGUgTVVTVCBiZSB0cmVhdGVkIGFzIGEgY29ubmVjdGlvbiBlcnJvclxuICAgICAgICAgKiAgIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuXG5sZXQgcHJvY2Vzc19wcmlvcml0eV9mcmFtZSB0IHsgRnJhbWUuZnJhbWVfaGVhZGVyOyBfIH0gcHJpb3JpdHkgPVxuICBsZXQgeyBGcmFtZS5zdHJlYW1faWQ7IF8gfSA9IGZyYW1lX2hlYWRlciBpblxuICBsZXQgeyBQcmlvcml0eS5zdHJlYW1fZGVwZW5kZW5jeTsgXyB9ID0gcHJpb3JpdHkgaW5cbiAgaWYgbm90IChTdHJlYW1faWRlbnRpZmllci5pc19yZXF1ZXN0IHN0cmVhbV9pZClcbiAgdGhlblxuICAgICgqIEZyb20gUkZDNzU0MMKnNS4xLjE6XG4gICAgICogICBTdHJlYW1zIGluaXRpYXRlZCBieSBhIGNsaWVudCBNVVNUIHVzZSBvZGQtbnVtYmVyZWQgc3RyZWFtXG4gICAgICogICBpZGVudGlmaWVycy4gWy4uLl0gQW4gZW5kcG9pbnQgdGhhdCByZWNlaXZlcyBhbiB1bmV4cGVjdGVkIHN0cmVhbVxuICAgICAqICAgaWRlbnRpZmllciBNVVNUIHJlc3BvbmQgd2l0aCBhIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mXG4gICAgICogICB0eXBlIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgIHJlcG9ydF9jb25uZWN0aW9uX2Vycm9yIHQgRXJyb3JfY29kZS5Qcm90b2NvbEVycm9yXG4gIGVsc2UgaWYgU3RyZWFtX2lkZW50aWZpZXIuKHN0cmVhbV9pZCA9PT0gc3RyZWFtX2RlcGVuZGVuY3kpXG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMy4xOlxuICAgICAqICAgQSBzdHJlYW0gY2Fubm90IGRlcGVuZCBvbiBpdHNlbGYuIEFuIGVuZHBvaW50IE1VU1QgdHJlYXQgdGhpcyBhcyBhXG4gICAgICogICBzdHJlYW0gZXJyb3IgKFNlY3Rpb24gNS40LjIpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgcmVwb3J0X3N0cmVhbV9lcnJvciB0IHN0cmVhbV9pZCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgZWxzZVxuICAgIG1hdGNoIFNjaGVkdWxlci5nZXRfbm9kZSB0LnN0cmVhbXMgc3RyZWFtX2lkIHdpdGhcbiAgICB8IFNvbWUgc3RyZWFtIC0+IFNjaGVkdWxlci5yZXByaW9yaXRpemVfc3RyZWFtIHQuc3RyZWFtcyB+cHJpb3JpdHkgc3RyZWFtXG4gICAgfCBOb25lIC0+XG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMS4xOlxuICAgICAgICogICBFbmRwb2ludHMgU0hPVUxEIHByb2Nlc3MgUFJJT1JJVFkgZnJhbWVzLCB0aG91Z2ggdGhleSBjYW4gYmUgaWdub3JlZFxuICAgICAgICogICBpZiB0aGUgc3RyZWFtIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSB0cmVlIChzZWUgU2VjdGlvblxuICAgICAgICogICA1LjMuNCkuXG4gICAgICAgKlxuICAgICAgICogTm90ZTpcbiAgICAgICAqICAgaWYgd2UncmUgcmVjZWl2aW5nIGEgUFJJT1JJVFkgZnJhbWUgZm9yIGEgc3RyZWFtIHRoYXQgd2UgYWxyZWFkeVxuICAgICAgICogICByZW1vdmVkIGZyb20gdGhlIHRyZWUgKGkuZS4gY2FuJ3QgYmUgZm91bmQgaW4gdGhlIGhhc2ggdGFibGUsIGFuZFxuICAgICAgICogICBmb3Igd2hpY2ggdGhlIHN0cmVhbSBJRCBpcyBzbWFsbGVyIHRoZW4gb3IgZXF1YWwgdG8gdGhlIG1heCBzdHJlYW1cbiAgICAgICAqICAgaWQgdGhhdCB0aGUgY2xpZW50IGhhcyBvcGVuZWQpLCBkb24ndCBib3RoZXIgcHJvY2Vzc2luZyBpdC4gKilcbiAgICAgIGlmIG5vdCAod2FzX2Nsb3NlZF9vcl9pbXBsaWNpdGx5X2Nsb3NlZCB0IHN0cmVhbV9pZClcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHJlcWQgPVxuICAgICAgICAgIFN0cmVhbS5jcmVhdGVcbiAgICAgICAgICAgIHN0cmVhbV9pZFxuICAgICAgICAgICAgfm1heF9mcmFtZV9zaXplOnQuc2V0dGluZ3MubWF4X2ZyYW1lX3NpemVcbiAgICAgICAgICAgIHQud3JpdGVyXG4gICAgICAgICAgICB0LmVycm9yX2hhbmRsZXJcbiAgICAgICAgICAgIChvbl9jbG9zZV9zdHJlYW0gdCBzdHJlYW1faWQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBfc3RyZWFtIDogU2NoZWR1bGVyLm5vbnJvb3QgU2NoZWR1bGVyLm5vZGUgPVxuICAgICAgICAgIFNjaGVkdWxlci5hZGRcbiAgICAgICAgICAgIHQuc3RyZWFtc1xuICAgICAgICAgICAgfnByaW9yaXR5XG4gICAgICAgICAgICB+aW5pdGlhbF9zZW5kX3dpbmRvd19zaXplOnQuc2V0dGluZ3MuaW5pdGlhbF93aW5kb3dfc2l6ZVxuICAgICAgICAgICAgfmluaXRpYWxfcmVjdl93aW5kb3dfc2l6ZTp0LmNvbmZpZy5pbml0aWFsX3dpbmRvd19zaXplXG4gICAgICAgICAgICByZXFkXG4gICAgICAgIGluXG4gICAgICAgICgpXG5cbmxldCBwcm9jZXNzX3JzdF9zdHJlYW1fZnJhbWUgdCB7IEZyYW1lLmZyYW1lX2hlYWRlcjsgXyB9IGVycm9yX2NvZGUgPVxuICBsZXQgeyBGcmFtZS5zdHJlYW1faWQ7IF8gfSA9IGZyYW1lX2hlYWRlciBpblxuICBpZiBub3QgKFN0cmVhbV9pZGVudGlmaWVyLmlzX3JlcXVlc3Qgc3RyZWFtX2lkKVxuICB0aGVuXG4gICAgKCogRnJvbSBSRkM3NTQwwqc1LjEuMTpcbiAgICAgKiAgIFN0cmVhbXMgaW5pdGlhdGVkIGJ5IGEgY2xpZW50IE1VU1QgdXNlIG9kZC1udW1iZXJlZCBzdHJlYW1cbiAgICAgKiAgIGlkZW50aWZpZXJzLiBbLi4uXSBBbiBlbmRwb2ludCB0aGF0IHJlY2VpdmVzIGFuIHVuZXhwZWN0ZWQgc3RyZWFtXG4gICAgICogICBpZGVudGlmaWVyIE1VU1QgcmVzcG9uZCB3aXRoIGEgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvbiA1LjQuMSkgb2ZcbiAgICAgKiAgIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgZWxzZVxuICAgIG1hdGNoIFNjaGVkdWxlci5maW5kIHQuc3RyZWFtcyBzdHJlYW1faWQgd2l0aFxuICAgIHwgU29tZSByZXFkIC0+XG4gICAgICAobWF0Y2ggcmVxZC5zdGF0ZSB3aXRoXG4gICAgICB8IElkbGUgLT5cbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjQ6XG4gICAgICAgICAqICAgUlNUX1NUUkVBTSBmcmFtZXMgTVVTVCBOT1QgYmUgc2VudCBmb3IgYSBzdHJlYW0gaW4gdGhlIFwiaWRsZVwiXG4gICAgICAgICAqICAgc3RhdGUuIElmIGEgUlNUX1NUUkVBTSBmcmFtZSBpZGVudGlmeWluZyBhbiBpZGxlIHN0cmVhbSBpc1xuICAgICAgICAgKiAgIHJlY2VpdmVkLCB0aGUgcmVjaXBpZW50IE1VU1QgdHJlYXQgdGhpcyBhcyBhIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgICAgICogICAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICAgICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgICAgIHwgXyAtPlxuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNDpcbiAgICAgICAgICogICBUaGUgUlNUX1NUUkVBTSBmcmFtZSBmdWxseSB0ZXJtaW5hdGVzIHRoZSByZWZlcmVuY2VkIHN0cmVhbSBhbmRcbiAgICAgICAgICogICBjYXVzZXMgaXQgdG8gZW50ZXIgdGhlIFwiY2xvc2VkXCIgc3RhdGUuIEFmdGVyIHJlY2VpdmluZyBhXG4gICAgICAgICAqICAgUlNUX1NUUkVBTSBvbiBhIHN0cmVhbSwgdGhlIHJlY2VpdmVyIE1VU1QgTk9UIHNlbmQgYWRkaXRpb25hbFxuICAgICAgICAgKiAgIGZyYW1lcyBmb3IgdGhhdCBzdHJlYW0sIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBQUklPUklUWS5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTpcbiAgICAgICAgICogICBUaGlzIG1hdGNoIGJyYW5jaCBhbHNvIGFjY2VwdHMgc3RyZWFtcyBpbiB0aGUgYENsb3NlZGAgc3RhdGUuIFdlXG4gICAgICAgICAqICAgZG8gdGhhdCB0byBjb21wbHkgd2l0aCB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgKlxuICAgICAgICAgKiBGcm9tIFJGQzc1NDDCpzYuNDpcbiAgICAgICAgICogICBbLi4uXSBhZnRlciBzZW5kaW5nIHRoZSBSU1RfU1RSRUFNLCB0aGUgc2VuZGluZyBlbmRwb2ludCBNVVNUIGJlXG4gICAgICAgICAqICAgcHJlcGFyZWQgdG8gcmVjZWl2ZSBhbmQgcHJvY2VzcyBhZGRpdGlvbmFsIGZyYW1lcyBzZW50IG9uIHRoZVxuICAgICAgICAgKiAgIHN0cmVhbSB0aGF0IG1pZ2h0IGhhdmUgYmVlbiBzZW50IGJ5IHRoZSBwZWVyIHByaW9yIHRvIHRoZSBhcnJpdmFsXG4gICAgICAgICAqICAgb2YgdGhlIFJTVF9TVFJFQU0uICopXG4gICAgICAgIFN0cmVhbS5maW5pc2hfc3RyZWFtIHJlcWQgKFJlc2V0QnlUaGVtIGVycm9yX2NvZGUpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgKCogV2UgbWlnaHQgaGF2ZSByZW1vdmVkIHRoZSBzdHJlYW0gZnJvbSB0aGUgaGFzaCB0YWJsZS4gSWYgaXRzIHN0cmVhbVxuICAgICAgICogaWQgaXMgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBtYXggY2xpZW50IHN0cmVhbSBpZCB3ZSd2ZSBzZWVuLFxuICAgICAgICogdGhlbiBpdCBtdXN0IGhhdmUgYmVlbiBjbG9zZWQuICopXG4gICAgICBpZiBub3QgKHdhc19jbG9zZWRfb3JfaW1wbGljaXRseV9jbG9zZWQgdCBzdHJlYW1faWQpXG4gICAgICB0aGVuXG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi40OlxuICAgICAgICAgKiAgIFJTVF9TVFJFQU0gZnJhbWVzIE1VU1QgTk9UIGJlIHNlbnQgZm9yIGEgc3RyZWFtIGluIHRoZSBcImlkbGVcIlxuICAgICAgICAgKiAgIHN0YXRlLiBJZiBhIFJTVF9TVFJFQU0gZnJhbWUgaWRlbnRpZnlpbmcgYW4gaWRsZSBzdHJlYW0gaXNcbiAgICAgICAgICogICByZWNlaXZlZCwgdGhlIHJlY2lwaWVudCBNVVNUIHRyZWF0IHRoaXMgYXMgYSBjb25uZWN0aW9uIGVycm9yXG4gICAgICAgICAqICAgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6XG4gICAgICAgICAqICAgSWYgd2UgZGlkbid0IGZpbmQgdGhlIHN0cmVhbSBpbiB0aGUgaGFzaCB0YWJsZSBpdCBtdXN0IGJlXG4gICAgICAgICAqICAgXCJpZGxlXCIuICopXG4gICAgICAgIHJlcG9ydF9jb25uZWN0aW9uX2Vycm9yIHQgRXJyb3JfY29kZS5Qcm90b2NvbEVycm9yXG5cbmxldCBhcHBseV9zZXR0aW5nc19saXN0IHQgc2V0dGluZ3MgPVxuICBsZXQgb3BlbiBTY2hlZHVsZXIgaW5cbiAgKCogRnJvbSBSRkM3NTQwwqc2LjU6XG4gICAqICAgRWFjaCBwYXJhbWV0ZXIgaW4gYSBTRVRUSU5HUyBmcmFtZSByZXBsYWNlcyBhbnkgZXhpc3RpbmcgdmFsdWUgZm9yXG4gICAqICAgdGhhdCBwYXJhbWV0ZXIuIFBhcmFtZXRlcnMgYXJlIHByb2Nlc3NlZCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleVxuICAgKiAgIGFwcGVhciwgYW5kIGEgcmVjZWl2ZXIgb2YgYSBTRVRUSU5HUyBmcmFtZSBkb2VzIG5vdCBuZWVkIHRvIG1haW50YWluXG4gICAqICAgYW55IHN0YXRlIG90aGVyIHRoYW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgaXRzIHBhcmFtZXRlcnMuICopXG4gIGxldCBuZXdfc2V0dGluZ3MgPVxuICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAoZnVuIChhY2MgOiBTZXR0aW5ncy50KSBpdGVtIC0+XG4gICAgICAgICBtYXRjaCBpdGVtIHdpdGhcbiAgICAgICAgIHwgU2V0dGluZ3MuSGVhZGVyVGFibGVTaXplIHggLT5cbiAgICAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjUuMjpcbiAgICAgICAgICAgICogICBBbGxvd3MgdGhlIHNlbmRlciB0byBpbmZvcm0gdGhlIHJlbW90ZSBlbmRwb2ludCBvZiB0aGUgbWF4aW11bVxuICAgICAgICAgICAgKiAgIHNpemUgb2YgdGhlIGhlYWRlciBjb21wcmVzc2lvbiB0YWJsZSB1c2VkIHRvIGRlY29kZSBoZWFkZXJcbiAgICAgICAgICAgICogICBibG9ja3MsIGluIG9jdGV0cy4gKilcbiAgICAgICAgICAgSHBhY2suRW5jb2Rlci5zZXRfY2FwYWNpdHkgdC5ocGFja19lbmNvZGVyIHg7XG4gICAgICAgICAgIHsgYWNjIHdpdGggaGVhZGVyX3RhYmxlX3NpemUgPSB4IH1cbiAgICAgICAgIHwgRW5hYmxlUHVzaCB4IC0+XG4gICAgICAgICAgICgqIFdlJ3ZlIGFscmVhZHkgdmVyaWZpZWQgdGhhdCB0aGlzIHNldHRpbmcgaXMgZWl0aGVyIDAgb3IgMSBpbiB0aGVcbiAgICAgICAgICAgICogY2FsbCB0byBgU2V0dGluZ3MuY2hlY2tfc2V0dGluZ3NfbGlzdGAgYWJvdmUuICopXG4gICAgICAgICAgIHsgYWNjIHdpdGggZW5hYmxlX3B1c2ggPSB4ID0gMSB9XG4gICAgICAgICB8IE1heENvbmN1cnJlbnRTdHJlYW1zIHggLT4geyBhY2Mgd2l0aCBtYXhfY29uY3VycmVudF9zdHJlYW1zID0geCB9XG4gICAgICAgICB8IEluaXRpYWxXaW5kb3dTaXplIG5ld192YWwgLT5cbiAgICAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjkuMjpcbiAgICAgICAgICAgICogICBbLi4uXSBhIFNFVFRJTkdTIGZyYW1lIGNhbiBhbHRlciB0aGUgaW5pdGlhbCBmbG93LWNvbnRyb2xcbiAgICAgICAgICAgICogICB3aW5kb3cgc2l6ZSBmb3Igc3RyZWFtcyB3aXRoIGFjdGl2ZSBmbG93LWNvbnRyb2wgd2luZG93cyAodGhhdFxuICAgICAgICAgICAgKiAgIGlzLCBzdHJlYW1zIGluIHRoZSBcIm9wZW5cIiBvciBcImhhbGYtY2xvc2VkIChyZW1vdGUpXCIgc3RhdGUpLlxuICAgICAgICAgICAgKiAgIFdoZW4gdGhlIHZhbHVlIG9mIFNFVFRJTkdTX0lOSVRJQUxfV0lORE9XX1NJWkUgY2hhbmdlcywgYVxuICAgICAgICAgICAgKiAgIHJlY2VpdmVyIE1VU1QgYWRqdXN0IHRoZSBzaXplIG9mIGFsbCBzdHJlYW0gZmxvdy1jb250cm9sXG4gICAgICAgICAgICAqICAgd2luZG93cyB0aGF0IGl0IG1haW50YWlucyBieSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXdcbiAgICAgICAgICAgICogICB2YWx1ZSBhbmQgdGhlIG9sZCB2YWx1ZS4gKilcbiAgICAgICAgICAgbGV0IG9sZF92YWwgPSBhY2MuaW5pdGlhbF93aW5kb3dfc2l6ZSBpblxuICAgICAgICAgICBsZXQgZ3Jvd3RoID0gSW50MzIuc3ViIG5ld192YWwgb2xkX3ZhbCBpblxuICAgICAgICAgICBsZXQgZXhjZXB0aW9uIExvY2FsIGluXG4gICAgICAgICAgIChtYXRjaFxuICAgICAgICAgICAgICBTY2hlZHVsZXIuaXRlclxuICAgICAgICAgICAgICAgIH5mOihmdW4gc3RyZWFtIC0+XG4gICAgICAgICAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuOS4yOlxuICAgICAgICAgICAgICAgICAgICogICBBbiBlbmRwb2ludCBNVVNUIHRyZWF0IGEgY2hhbmdlIHRvXG4gICAgICAgICAgICAgICAgICAgKiAgIFNFVFRJTkdTX0lOSVRJQUxfV0lORE9XX1NJWkUgdGhhdCBjYXVzZXMgYW55XG4gICAgICAgICAgICAgICAgICAgKiAgIGZsb3ctY29udHJvbCB3aW5kb3cgdG8gZXhjZWVkIHRoZSBtYXhpbXVtIHNpemUgYXMgYVxuICAgICAgICAgICAgICAgICAgICogICBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlXG4gICAgICAgICAgICAgICAgICAgKiAgIEZMT1dfQ09OVFJPTF9FUlJPUi4gKilcbiAgICAgICAgICAgICAgICAgIGlmIG5vdCAoU2NoZWR1bGVyLmFkZF9mbG93IHN0cmVhbSBncm93dGgpIHRoZW4gcmFpc2UgTG9jYWwpXG4gICAgICAgICAgICAgICAgdC5zdHJlYW1zXG4gICAgICAgICAgICB3aXRoXG4gICAgICAgICAgIHwgKCkgLT4gKClcbiAgICAgICAgICAgfCBleGNlcHRpb24gTG9jYWwgLT5cbiAgICAgICAgICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvclxuICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICAgfnJlYXNvbjpcbiAgICAgICAgICAgICAgICAgKEZvcm1hdC5zcHJpbnRmXG4gICAgICAgICAgICAgICAgICAgIFwiV2luZG93IHNpemUgZm9yIHN0cmVhbSB3b3VsZCBleGNlZWQgJWxkXCJcbiAgICAgICAgICAgICAgICAgICAgU2V0dGluZ3MuV2luZG93U2l6ZS5tYXhfd2luZG93X3NpemUpXG4gICAgICAgICAgICAgICBFcnJvcl9jb2RlLkZsb3dDb250cm9sRXJyb3IpO1xuICAgICAgICAgICB7IGFjYyB3aXRoIGluaXRpYWxfd2luZG93X3NpemUgPSBuZXdfdmFsIH1cbiAgICAgICAgIHwgTWF4RnJhbWVTaXplIHggLT5cbiAgICAgICAgICAgKCogWFhYOiBXZSdyZSBwcm9iYWJseSBub3QgYWJpZGluZyBlbnRpcmVseSBieSB0aGlzLiBJZiB3ZSBnZXQgYVxuICAgICAgICAgICAgKiBNQVhfRlJBTUVfU0laRSBzZXR0aW5nIHdlJ2QgbmVlZCB0byByZWFsbG9jYXRlIHRoZSByZWFkIGJ1ZmZlcj9cbiAgICAgICAgICAgICogVGhpcyB3aWxsIG5lZWQgc3VwcG9ydCBmcm9tIHRoZSBJL08gcnVudGltZXMuICopXG4gICAgICAgICAgIFNjaGVkdWxlci5pdGVyXG4gICAgICAgICAgICAgfmY6KGZ1biAoU3RyZWFtIHsgZGVzY3JpcHRvcjsgXyB9KSAtPlxuICAgICAgICAgICAgICAgaWYgUmVxZC5yZXF1aXJlc19vdXRwdXQgZGVzY3JpcHRvclxuICAgICAgICAgICAgICAgdGhlbiBkZXNjcmlwdG9yLm1heF9mcmFtZV9zaXplIDwtIHgpXG4gICAgICAgICAgICAgdC5zdHJlYW1zO1xuICAgICAgICAgICB7IGFjYyB3aXRoIG1heF9mcmFtZV9zaXplID0geCB9XG4gICAgICAgICB8IE1heEhlYWRlckxpc3RTaXplIHggLT4geyBhY2Mgd2l0aCBtYXhfaGVhZGVyX2xpc3Rfc2l6ZSA9IFNvbWUgeCB9KVxuICAgICAgdC5zZXR0aW5nc1xuICAgICAgc2V0dGluZ3NcbiAgaW5cbiAgdC5zZXR0aW5ncyA8LSBuZXdfc2V0dGluZ3NcblxubGV0IHdyaXRlX3NldHRpbmdzX2ZyYW1lIHQgfmFjayBzZXR0aW5ncyA9XG4gIGxldCBmbGFncyA9XG4gICAgaWYgYWNrIHRoZW4gRmxhZ3MuKHNldF9hY2sgZGVmYXVsdF9mbGFncykgZWxzZSBGbGFncy5kZWZhdWx0X2ZsYWdzXG4gIGluXG4gIGxldCBmcmFtZV9pbmZvID0gV3JpdGVyLm1ha2VfZnJhbWVfaW5mbyB+ZmxhZ3MgU3RyZWFtX2lkZW50aWZpZXIuY29ubmVjdGlvbiBpblxuICBXcml0ZXIud3JpdGVfc2V0dGluZ3MgdC53cml0ZXIgZnJhbWVfaW5mbyBzZXR0aW5ncztcbiAgaWYgbm90IGFja1xuICB0aGVuXG4gICAgKCogRG9uJ3QgZXhwZWN0ZWQgb3VyIGFja25vd2xlZGdlbWVudHMgdG8gYmUgYWNrbm93bGVkZ2VkLi4uICopXG4gICAgdC51bmFja2VkX3NldHRpbmdzIDwtIHQudW5hY2tlZF9zZXR0aW5ncyArIDFcblxubGV0IHByb2Nlc3Nfc2V0dGluZ3NfZnJhbWUgdCB7IEZyYW1lLmZyYW1lX2hlYWRlcjsgXyB9IHNldHRpbmdzID1cbiAgbGV0IHsgRnJhbWUuZmxhZ3M7IF8gfSA9IGZyYW1lX2hlYWRlciBpblxuICAoKiBXZSBhbHJlYWR5IGNoZWNrZWQgdGhhdCBhbiBhY2tlZCBTRVRUSU5HUyBpcyBlbXB0eS4gRG9uJ3QgbmVlZCB0byBkb1xuICAgKiBhbnl0aGluZyBlbHNlIGluIHRoYXQgY2FzZSAqKVxuICBpZiBGbGFncy4odGVzdF9hY2sgZmxhZ3MpXG4gIHRoZW4gKFxuICAgIHQudW5hY2tlZF9zZXR0aW5ncyA8LSB0LnVuYWNrZWRfc2V0dGluZ3MgLSAxO1xuICAgIGlmIHQudW5hY2tlZF9zZXR0aW5ncyA8IDBcbiAgICB0aGVuXG4gICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvclxuICAgICAgICB0XG4gICAgICAgIH5yZWFzb246XCJSZWNlaXZlZCB1bmV4cGVjdGVkIFNFVFRJTkdTIGZyYW1lIHdpdGggYWNrbm93bGVkZ2VtZW50XCJcbiAgICAgICAgRXJyb3JfY29kZS5Qcm90b2NvbEVycm9yKVxuICBlbHNlXG4gICAgbWF0Y2ggU2V0dGluZ3MuY2hlY2tfc2V0dGluZ3NfbGlzdCBzZXR0aW5ncyB3aXRoXG4gICAgfCBPayAoKSAtPlxuICAgICAgYXBwbHlfc2V0dGluZ3NfbGlzdCB0IHNldHRpbmdzO1xuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjUuMjpcbiAgICAgICAqICAgT25jZSBhbGwgdmFsdWVzIGhhdmUgYmVlbiBwcm9jZXNzZWQsIHRoZSByZWNpcGllbnQgTVVTVCBpbW1lZGlhdGVseVxuICAgICAgICogICBlbWl0IGEgU0VUVElOR1MgZnJhbWUgd2l0aCB0aGUgQUNLIGZsYWcgc2V0LlxuICAgICAgICpcbiAgICAgICAqIEZyb20gUkZDNzU0MMKnNi41OlxuICAgICAgICogICBBQ0sgKDB4MSk6IFsuLi5dIFdoZW4gdGhpcyBiaXQgaXMgc2V0LCB0aGUgcGF5bG9hZCBvZiB0aGUgU0VUVElOR1NcbiAgICAgICAqICAgZnJhbWUgTVVTVCBiZSBlbXB0eS4gKilcbiAgICAgIHdyaXRlX3NldHRpbmdzX2ZyYW1lIHQgfmFjazp0cnVlIFtdO1xuICAgICAgd2FrZXVwX3dyaXRlciB0XG4gICAgfCBFcnJvciBlcnJvciAtPiByZXBvcnRfZXJyb3IgdCBlcnJvclxuXG5sZXQgcHJvY2Vzc19waW5nX2ZyYW1lIHQgeyBGcmFtZS5mcmFtZV9oZWFkZXI7IF8gfSBwYXlsb2FkID1cbiAgbGV0IHsgRnJhbWUuZmxhZ3M7IF8gfSA9IGZyYW1lX2hlYWRlciBpblxuICAoKiBGcm9tIFJGQzc1NDDCpzYuNzpcbiAgICogICBBQ0sgKDB4MSk6IFdoZW4gc2V0LCBiaXQgMCBpbmRpY2F0ZXMgdGhhdCB0aGlzIFBJTkcgZnJhbWUgaXMgYSBQSU5HXG4gICAqICAgcmVzcG9uc2UuIFsuLi5dIEFuIGVuZHBvaW50IE1VU1QgTk9UIHJlc3BvbmQgdG8gUElORyBmcmFtZXMgY29udGFpbmluZ1xuICAgKiAgIHRoaXMgZmxhZy4gKilcbiAgaWYgbm90IChGbGFncy50ZXN0X2FjayBmbGFncylcbiAgdGhlbiAoXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2Ljc6XG4gICAgICogICBSZWNlaXZlcnMgb2YgYSBQSU5HIGZyYW1lIHRoYXQgZG9lcyBub3QgaW5jbHVkZSBhbiBBQ0sgZmxhZyBNVVNUIHNlbmRcbiAgICAgKiAgIGEgUElORyBmcmFtZSB3aXRoIHRoZSBBQ0sgZmxhZyBzZXQgaW4gcmVzcG9uc2UsIHdpdGggYW4gaWRlbnRpY2FsXG4gICAgICogICBwYXlsb2FkLiBQSU5HIHJlc3BvbnNlcyBTSE9VTEQgYmUgZ2l2ZW4gaGlnaGVyIHByaW9yaXR5IHRoYW4gYW55IG90aGVyXG4gICAgICogICBmcmFtZS4gKilcbiAgICBsZXQgZnJhbWVfaW5mbyA9XG4gICAgICBXcml0ZXIubWFrZV9mcmFtZV9pbmZvXG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNzpcbiAgICAgICAqICAgQUNLICgweDEpOiBXaGVuIHNldCwgYml0IDAgaW5kaWNhdGVzIHRoYXQgdGhpcyBQSU5HIGZyYW1lIGlzIGFcbiAgICAgICAqICAgUElORyByZXNwb25zZS4gQW4gZW5kcG9pbnQgTVVTVCBzZXQgdGhpcyBmbGFnIGluIFBJTkdcbiAgICAgICAqICAgcmVzcG9uc2VzLiAqKVxuICAgICAgICB+ZmxhZ3M6RmxhZ3MuKHNldF9hY2sgZGVmYXVsdF9mbGFncylcbiAgICAgICAgU3RyZWFtX2lkZW50aWZpZXIuY29ubmVjdGlvblxuICAgIGluXG4gICAgKCogRnJvbSBSRkM3NTQwwqc2Ljc6XG4gICAgICogICBSZWNlaXZlcnMgb2YgYSBQSU5HIGZyYW1lIHRoYXQgZG9lcyBub3QgaW5jbHVkZSBhbiBBQ0sgZmxhZyBNVVNUIHNlbmRcbiAgICAgKiAgIGEgUElORyBmcmFtZSB3aXRoIHRoZSBBQ0sgZmxhZyBzZXQgaW4gcmVzcG9uc2UsIHdpdGggYW4gaWRlbnRpY2FsXG4gICAgICogICBwYXlsb2FkLiAqKVxuICAgIFdyaXRlci53cml0ZV9waW5nIHQud3JpdGVyIGZyYW1lX2luZm8gcGF5bG9hZDtcbiAgICB3YWtldXBfd3JpdGVyIHQpXG5cbmxldCBwcm9jZXNzX2dvYXdheV9mcmFtZSB0IF9mcmFtZSB+bGFzdF9zdHJlYW1faWQ6XyB+ZGF0YSBlcnJvciA9XG4gIGxldCByZWFzb24gPVxuICAgIG1hdGNoIEJpZ3N0cmluZ2FmLmxlbmd0aCBkYXRhIHdpdGhcbiAgICB8IDAgLT4gTm9uZVxuICAgIHwgbGVuIC0+IFNvbWUgKEJpZ3N0cmluZ2FmLnN1YnN0cmluZyBkYXRhIH5vZmY6MCB+bGVuKVxuICBpblxuICAoKiBUT0RPKGFubW9udGVpcm8pOiBJIHRoaW5rIHdlIG5lZWQgdG8gYWxsb3cgbG93ZXIgbnVtYmVyZWQgc3RyZWFtcyB0b1xuICAgKiBjb21wbGV0ZS4gKilcbiAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCA/cmVhc29uIGVycm9yXG5cbmxldCBhZGRfd2luZG93X2luY3JlbWVudCA6XG4gICAgdHlwZSBhLiB0IC0+IGEgU2NoZWR1bGVyLlByaW9yaXR5VHJlZU5vZGUubm9kZSAtPiBpbnQzMiAtPiB1bml0XG4gID1cbiBmdW4gdCBzdHJlYW0gaW5jcmVtZW50IC0+XG4gIGxldCBvcGVuIFNjaGVkdWxlciBpblxuICBsZXQgZGlkX2FkZCA9IFNjaGVkdWxlci5hZGRfZmxvdyBzdHJlYW0gaW5jcmVtZW50IGluXG4gIGxldCBzdHJlYW1faWQgPSBTY2hlZHVsZXIuc3RyZWFtX2lkIHN0cmVhbSBpblxuICBsZXQgbmV3X2Zsb3cgPVxuICAgIG1hdGNoIHN0cmVhbSB3aXRoXG4gICAgfCBDb25uZWN0aW9uIHsgZmxvdzsgXyB9IC0+IGZsb3dcbiAgICB8IFN0cmVhbSB7IGZsb3c7IF8gfSAtPiBmbG93XG4gIGluXG4gIGlmIGRpZF9hZGRcbiAgdGhlbiAoXG4gICAgaWYgSW50MzIuY29tcGFyZSBuZXdfZmxvdyAwbCA+IDBcbiAgICB0aGVuXG4gICAgICAoKiBEb24ndCBib3RoZXIgd2FraW5nIHVwIHRoZSB3cml0ZXIgaWYgdGhlIG5ldyBmbG93IGRvZXNuJ3QgYWxsb3dcbiAgICAgICAqIHRoZSBzdHJlYW0gdG8gd3JpdGUuICopXG4gICAgICB3YWtldXBfd3JpdGVyIHQpXG4gIGVsc2UgaWYgU3RyZWFtX2lkZW50aWZpZXIuaXNfY29ubmVjdGlvbiBzdHJlYW1faWRcbiAgdGhlblxuICAgIHJlcG9ydF9jb25uZWN0aW9uX2Vycm9yXG4gICAgICB0XG4gICAgICB+cmVhc29uOlxuICAgICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgICAgXCJXaW5kb3cgc2l6ZSBmb3Igc3RyZWFtIHdvdWxkIGV4Y2VlZCAlbGRcIlxuICAgICAgICAgICBTZXR0aW5ncy5XaW5kb3dTaXplLm1heF93aW5kb3dfc2l6ZSlcbiAgICAgIEVycm9yX2NvZGUuRmxvd0NvbnRyb2xFcnJvclxuICBlbHNlIHJlcG9ydF9zdHJlYW1fZXJyb3IgdCBzdHJlYW1faWQgRXJyb3JfY29kZS5GbG93Q29udHJvbEVycm9yXG5cbmxldCBwcm9jZXNzX3dpbmRvd191cGRhdGVfZnJhbWUgdCB7IEZyYW1lLmZyYW1lX2hlYWRlcjsgXyB9IHdpbmRvd19pbmNyZW1lbnQgPVxuICBsZXQgb3BlbiBTY2hlZHVsZXIgaW5cbiAgbGV0IHsgRnJhbWUuc3RyZWFtX2lkOyBfIH0gPSBmcmFtZV9oZWFkZXIgaW5cbiAgKCogRnJvbSBSRkM3NTQwwqc2Ljk6XG4gICAqICAgVGhlIFdJTkRPV19VUERBVEUgZnJhbWUgY2FuIGJlIHNwZWNpZmljIHRvIGEgc3RyZWFtIG9yIHRvIHRoZSBlbnRpcmVcbiAgICogICBjb25uZWN0aW9uLiBJbiB0aGUgZm9ybWVyIGNhc2UsIHRoZSBmcmFtZSdzIHN0cmVhbSBpZGVudGlmaWVyIGluZGljYXRlc1xuICAgKiAgIHRoZSBhZmZlY3RlZCBzdHJlYW07IGluIHRoZSBsYXR0ZXIsIHRoZSB2YWx1ZSBcIjBcIiBpbmRpY2F0ZXMgdGhhdCB0aGVcbiAgICogICBlbnRpcmUgY29ubmVjdGlvbiBpcyB0aGUgc3ViamVjdCBvZiB0aGUgZnJhbWUuICopXG4gIGlmIFN0cmVhbV9pZGVudGlmaWVyLmlzX2Nvbm5lY3Rpb24gc3RyZWFtX2lkXG4gIHRoZW4gYWRkX3dpbmRvd19pbmNyZW1lbnQgdCB0LnN0cmVhbXMgd2luZG93X2luY3JlbWVudFxuICBlbHNlXG4gICAgbWF0Y2ggU2NoZWR1bGVyLmdldF9ub2RlIHQuc3RyZWFtcyBzdHJlYW1faWQgd2l0aFxuICAgIHwgU29tZSAoU3RyZWFtIHsgZGVzY3JpcHRvcjsgXyB9IGFzIHN0cmVhbV9ub2RlKSAtPlxuICAgICAgKG1hdGNoIGRlc2NyaXB0b3Iuc3RhdGUgd2l0aFxuICAgICAgfCBJZGxlIC0+XG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4xOlxuICAgICAgICAgKiAgIGlkbGU6IFsuLi5dIFJlY2VpdmluZyBhbnkgZnJhbWUgb3RoZXIgdGhhbiBIRUFERVJTIG9yIFBSSU9SSVRZIG9uXG4gICAgICAgICAqICAgYSBzdHJlYW0gaW4gdGhpcyBzdGF0ZSBNVVNUIGJlIHRyZWF0ZWQgYXMgYSBjb25uZWN0aW9uIGVycm9yXG4gICAgICAgICAqICAgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgICAgIHJlcG9ydF9jb25uZWN0aW9uX2Vycm9yIHQgRXJyb3JfY29kZS5Qcm90b2NvbEVycm9yXG4gICAgICB8IEFjdGl2ZSBfXG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgICAqICAgcmVzZXJ2ZWQgKGxvY2FsKTogWy4uLl0gQSBQUklPUklUWSBvciBXSU5ET1dfVVBEQVRFIGZyYW1lIE1BWSBiZVxuICAgICAgICogICByZWNlaXZlZCBpbiB0aGlzIHN0YXRlLiAqKVxuICAgICAgfCBSZXNlcnZlZCBfIC0+XG4gICAgICAgIGFkZF93aW5kb3dfaW5jcmVtZW50IHQgc3RyZWFtX25vZGUgd2luZG93X2luY3JlbWVudFxuICAgICAgfCBDbG9zZWQgXyAtPlxuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuOTpcbiAgICAgICAgICogICBbLi4uXSBhIHJlY2VpdmVyIGNvdWxkIHJlY2VpdmUgYSBXSU5ET1dfVVBEQVRFIGZyYW1lIG9uIGFcbiAgICAgICAgICogICBcImhhbGYtY2xvc2VkIChyZW1vdGUpXCIgb3IgXCJjbG9zZWRcIiBzdHJlYW0uIEEgcmVjZWl2ZXIgTVVTVCBOT1RcbiAgICAgICAgICogICB0cmVhdCB0aGlzIGFzIGFuIGVycm9yIChzZWUgU2VjdGlvbiA1LjEpLiAqKVxuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgICAgICogICBFbmRwb2ludHMgTVVTVCBpZ25vcmUgV0lORE9XX1VQREFURSBvciBSU1RfU1RSRUFNIGZyYW1lcyByZWNlaXZlZFxuICAgICAgICAgKiAgIGluIHRoaXMgc3RhdGUsIHRob3VnaCBlbmRwb2ludHMgTUFZIGNob29zZSB0byB0cmVhdCBmcmFtZXMgdGhhdFxuICAgICAgICAgKiAgIGFycml2ZSBhIHNpZ25pZmljYW50IHRpbWUgYWZ0ZXIgc2VuZGluZyBFTkRfU1RSRUFNIGFzIGEgY29ubmVjdGlvblxuICAgICAgICAgKiAgIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgICAgICAoKSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIGlmIG5vdCAod2FzX2Nsb3NlZF9vcl9pbXBsaWNpdGx5X2Nsb3NlZCB0IHN0cmVhbV9pZClcbiAgICAgIHRoZW5cbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc1LjE6XG4gICAgICAgICAqICAgaWRsZTogWy4uLl0gUmVjZWl2aW5nIGFueSBmcmFtZSBvdGhlciB0aGFuIEhFQURFUlMgb3IgUFJJT1JJVFkgb25cbiAgICAgICAgICogICBhIHN0cmVhbSBpbiB0aGlzIHN0YXRlIE1VU1QgYmUgdHJlYXRlZCBhcyBhIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgICAgICogICAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICAgICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcblxubGV0IHByb2Nlc3NfY29udGludWF0aW9uX2ZyYW1lIHQgeyBGcmFtZS5mcmFtZV9oZWFkZXI7IF8gfSBoZWFkZXJzX2Jsb2NrID1cbiAgbGV0IHsgRnJhbWUuc3RyZWFtX2lkOyBmbGFnczsgXyB9ID0gZnJhbWVfaGVhZGVyIGluXG4gIGlmIG5vdCAoU3RyZWFtX2lkZW50aWZpZXIuaXNfcmVxdWVzdCBzdHJlYW1faWQpXG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMS4xOlxuICAgICAqICAgU3RyZWFtcyBpbml0aWF0ZWQgYnkgYSBjbGllbnQgTVVTVCB1c2Ugb2RkLW51bWJlcmVkIHN0cmVhbVxuICAgICAqICAgaWRlbnRpZmllcnMuIFsuLi5dIEFuIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgYW4gdW5leHBlY3RlZCBzdHJlYW1cbiAgICAgKiAgIGlkZW50aWZpZXIgTVVTVCByZXNwb25kIHdpdGggYSBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZlxuICAgICAqICAgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuICBlbHNlXG4gICAgbWF0Y2ggU2NoZWR1bGVyLmdldF9ub2RlIHQuc3RyZWFtcyBzdHJlYW1faWQgd2l0aFxuICAgIHwgU29tZSAoU2NoZWR1bGVyLlN0cmVhbSB7IGRlc2NyaXB0b3I7IF8gfSBhcyBzdHJlYW0pIC0+XG4gICAgICAobWF0Y2ggZGVzY3JpcHRvci5zdGF0ZSB3aXRoXG4gICAgICB8IEFjdGl2ZSAoT3BlbiAoUGFydGlhbEhlYWRlcnMgcGFydGlhbF9oZWFkZXJzKSwgYWN0aXZlX3N0cmVhbSkgLT5cbiAgICAgICAgaGFuZGxlX2hlYWRlcnNfYmxvY2tcbiAgICAgICAgICB0XG4gICAgICAgICAgc3RyZWFtXG4gICAgICAgICAgYWN0aXZlX3N0cmVhbVxuICAgICAgICAgIHBhcnRpYWxfaGVhZGVyc1xuICAgICAgICAgIGZsYWdzXG4gICAgICAgICAgaGVhZGVyc19ibG9ja1xuICAgICAgfCBBY3RpdmVcbiAgICAgICAgICAoIE9wZW4gKEFjdGl2ZU1lc3NhZ2UgXylcbiAgICAgICAgICAsICh7IHRyYWlsZXJzX3BhcnNlciA9IFNvbWUgcGFydGlhbF9oZWFkZXJzOyBfIH0gYXMgYWN0aXZlX3N0cmVhbSkgKVxuICAgICAgICAtPlxuICAgICAgICBoYW5kbGVfdHJhaWxlcl9oZWFkZXJzXG4gICAgICAgICAgdFxuICAgICAgICAgIHN0cmVhbVxuICAgICAgICAgIGFjdGl2ZV9zdHJlYW1cbiAgICAgICAgICBwYXJ0aWFsX2hlYWRlcnNcbiAgICAgICAgICBmbGFnc1xuICAgICAgICAgIGhlYWRlcnNfYmxvY2tcbiAgICAgIHwgXyAtPlxuICAgICAgICAoKiBUT0RPOiBtYXliZSBuZWVkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgc3RyZWFtIGhhcyBiZWVuIGNsb3NlZFxuICAgICAgICAgKiBkdWUgdG8gYSBzdHJlYW0gZXJyb3IuICopXG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi4xMDpcbiAgICAgICAgICogICBBIFJTVF9TVFJFQU0gaXMgdGhlIGxhc3QgZnJhbWUgdGhhdCBhbiBlbmRwb2ludCBjYW4gc2VuZCBvbiBhXG4gICAgICAgICAqICAgc3RyZWFtLiBUaGUgcGVlciB0aGF0IHNlbmRzIHRoZSBSU1RfU1RSRUFNIGZyYW1lIE1VU1QgYmUgcHJlcGFyZWRcbiAgICAgICAgICogICB0byByZWNlaXZlIGFueSBmcmFtZXMgdGhhdCB3ZXJlIHNlbnQgb3IgZW5xdWV1ZWQgZm9yIHNlbmRpbmcgYnlcbiAgICAgICAgICogICB0aGUgcmVtb3RlIHBlZXIuIFRoZXNlIGZyYW1lcyBjYW4gYmUgaWdub3JlZCwgZXhjZXB0IHdoZXJlIHRoZXlcbiAgICAgICAgICogICBtb2RpZnkgY29ubmVjdGlvbiBzdGF0ZSAoc3VjaCBhcyB0aGUgc3RhdGUgbWFpbnRhaW5lZCBmb3IgaGVhZGVyXG4gICAgICAgICAqICAgY29tcHJlc3Npb24gKFNlY3Rpb24gNC4zKSBvciBmbG93IGNvbnRyb2wpLiAqKVxuICAgICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvcilcbiAgICB8IE5vbmUgLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnNi4xMDpcbiAgICAgICAqICAgQSBDT05USU5VQVRJT04gZnJhbWUgTVVTVCBiZSBwcmVjZWRlZCBieSBhIEhFQURFUlMsIFBVU0hfUFJPTUlTRSBvclxuICAgICAgICogICBDT05USU5VQVRJT04gZnJhbWUgd2l0aG91dCB0aGUgRU5EX0hFQURFUlMgZmxhZyBzZXQuIEEgcmVjaXBpZW50XG4gICAgICAgKiAgIHRoYXQgb2JzZXJ2ZXMgdmlvbGF0aW9uIG9mIHRoaXMgcnVsZSBNVVNUIHJlc3BvbmQgd2l0aCBhIGNvbm5lY3Rpb25cbiAgICAgICAqICAgZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuXG5sZXQgZGVmYXVsdF9lcnJvcl9oYW5kbGVyID9yZXF1ZXN0Ol8gZXJyb3IgaGFuZGxlID1cbiAgbGV0IG1lc3NhZ2UgPVxuICAgIG1hdGNoIGVycm9yIHdpdGhcbiAgICB8IGBFeG4gZXhuIC0+IFByaW50ZXhjLnRvX3N0cmluZyBleG5cbiAgICB8ICgjU3RhdHVzLmNsaWVudF9lcnJvciB8ICNTdGF0dXMuc2VydmVyX2Vycm9yKSBhcyBlcnJvciAtPlxuICAgICAgU3RhdHVzLnRvX3N0cmluZyBlcnJvclxuICBpblxuICBsZXQgYm9keSA9IGhhbmRsZSBIZWFkZXJzLmVtcHR5IGluXG4gIEJvZHkuV3JpdGVyLndyaXRlX3N0cmluZyBib2R5IG1lc3NhZ2U7XG4gIEJvZHkuV3JpdGVyLmNsb3NlIGJvZHlcblxubGV0IHdyaXRlX2Nvbm5lY3Rpb25fcHJlZmFjZSB0ID1cbiAgKCogQ2hlY2sgaWYgdGhlIHNldHRpbmdzIGZvciB0aGUgY29ubmVjdGlvbiBhcmUgZGlmZmVyZW50IHRoYW4gdGhlIGRlZmF1bHRcbiAgICogSFRUUC8yIHNldHRpbmdzLiBJbiB0aGUgZXZlbnQgdGhhdCB0aGV5IGFyZSwgd2UgbmVlZCB0byBzZW5kIGEgbm9uLWVtcHR5XG4gICAqIFNFVFRJTkdTIGZyYW1lIGFkdmVydGlzaW5nIG91ciBjb25maWd1cmF0aW9uLiAqKVxuICBsZXQgc2V0dGluZ3MgPSBTZXR0aW5ncy5zZXR0aW5nc19mb3JfdGhlX2Nvbm5lY3Rpb24gdC5zZXR0aW5ncyBpblxuICAoKiBYWFgoYW5tb250ZWlybyk6IHNhbWUgYXMgaW4gdGhlIGNsaWVudC4gUmV2ZXJ0XG4gICAqIFt0LnNldHRpbmdzLmluaXRpYWxfd2luZG93X3NpemVdIHRvIHRoZSBzcGVjLWRlZmF1bHQgdmFsdWUgdW50aWwgd2VcbiAgICogcmVjZWl2ZSBhIHNldHRpbmcgZm9yIGl0LiAqKVxuICB0LnNldHRpbmdzIDwtXG4gICAgeyB0LnNldHRpbmdzIHdpdGhcbiAgICAgIGluaXRpYWxfd2luZG93X3NpemUgPSBTZXR0aW5ncy5kZWZhdWx0LmluaXRpYWxfd2luZG93X3NpemVcbiAgICB9O1xuICAoKiBOb3cgc2VuZCB0aGUgY29ubmVjdGlvbiBwcmVmYWNlLCBpbmNsdWRpbmcgb3VyIHNldHRpbmdzIGZvciB0aGVcbiAgICogY29ubmVjdGlvbi5cbiAgICpcbiAgICogRnJvbSBSRkM3NTQwwqczLjU6XG4gICAqICAgVGhlIHNlcnZlciBjb25uZWN0aW9uIHByZWZhY2UgY29uc2lzdHMgb2YgYSBwb3RlbnRpYWxseSBlbXB0eVxuICAgKiAgIFNFVFRJTkdTIGZyYW1lIChTZWN0aW9uIDYuNSkgdGhhdCBNVVNUIGJlIHRoZSBmaXJzdCBmcmFtZSB0aGVcbiAgICogICBzZXJ2ZXIgc2VuZHMgaW4gdGhlIEhUVFAvMiBjb25uZWN0aW9uLiAqKVxuICB3cml0ZV9zZXR0aW5nc19mcmFtZSB+YWNrOmZhbHNlIHQgc2V0dGluZ3M7XG4gICgqIElmIGEgaGlnaGVyIHZhbHVlIGZvciBpbml0aWFsIHdpbmRvdyBzaXplIGlzIGNvbmZpZ3VyZWQsIGFkZCBtb3JlXG4gICAqIHRva2VucyB0byB0aGUgY29ubmVjdGlvbiAod2UgaGF2ZSBubyBzdHJlYW1zIGF0IHRoaXMgcG9pbnQpLiAqKVxuICBpZiB0LmNvbmZpZy5pbml0aWFsX3dpbmRvd19zaXplID4gU2V0dGluZ3MuZGVmYXVsdC5pbml0aWFsX3dpbmRvd19zaXplXG4gIHRoZW5cbiAgICBsZXQgZGlmZiA9XG4gICAgICBJbnQzMi5zdWJcbiAgICAgICAgdC5jb25maWcuaW5pdGlhbF93aW5kb3dfc2l6ZVxuICAgICAgICBTZXR0aW5ncy5kZWZhdWx0LmluaXRpYWxfd2luZG93X3NpemVcbiAgICBpblxuICAgIHNlbmRfd2luZG93X3VwZGF0ZSB0IHQuc3RyZWFtcyBkaWZmXG5cbmxldCBjcmVhdGVfZ2VuZXJpYyB+aDJjIH5jb25maWcgfmVycm9yX2hhbmRsZXIgcmVxdWVzdF9oYW5kbGVyID1cbiAgbGV0IHNldHRpbmdzID0gQ29uZmlnLnRvX3NldHRpbmdzIGNvbmZpZyBpblxuICBsZXQgd3JpdGVyID0gV3JpdGVyLmNyZWF0ZSBzZXR0aW5ncy5tYXhfZnJhbWVfc2l6ZSBpblxuICBsZXQgcmVjIGNvbm5lY3Rpb25fcHJlZmFjZV9oYW5kbGVyIHJlY3ZfZnJhbWUgc2V0dGluZ3NfbGlzdCA9XG4gICAgbGV0IHQgPSBMYXp5LmZvcmNlIHQgaW5cbiAgICAoKiBJZiB0aGlzIGNvbm5lY3Rpb24gaXMgYGgyY2AgKEhUVFAvMiBvdmVyIFRDUCksIHdlIGhhdmUgYWxyZWFkeSB3cml0dGVuXG4gICAgICogdGhlIHNlcnZlciBjb25uZWN0aW9uIHByZWZhY2UuIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgaWYgd2UncmVcbiAgICAgKiByZXNwb25kaW5nIHRvIGEgY2xpZW50LWluaXRpYXRlZCBjb25uZWN0aW9uLCBidXQgaW4gYGgyY2AgdGhlIHNlcnZlclxuICAgICAqIHdyaXRlcyB0aGUgcHJlZmFjZSBmaXJzdCAoaGFuZGxlZCBiZWxvdyBpbiBgY3JlYXRlX2gyY2ApICopXG4gICAgaWYgbm90IGgyYyB0aGVuIHdyaXRlX2Nvbm5lY3Rpb25fcHJlZmFjZSB0O1xuICAgICgqIE5vdyBwcm9jZXNzIHRoZSBjbGllbnQncyBTRVRUSU5HUyBmcmFtZS4gYHByb2Nlc3Nfc2V0dGluZ3NfZnJhbWVgIHdpbGxcbiAgICAgKiB0YWtlIGNhcmUgb2YgY2FsbGluZyBgd2FrZXVwX3dyaXRlcmAuICopXG4gICAgcHJvY2Vzc19zZXR0aW5nc19mcmFtZSB0IHJlY3ZfZnJhbWUgc2V0dGluZ3NfbGlzdFxuICBhbmQgZnJhbWVfaGFuZGxlciByID1cbiAgICBsZXQgdCA9IExhenkuZm9yY2UgdCBpblxuICAgIG1hdGNoIHIgd2l0aFxuICAgIHwgRXJyb3IgZSAtPiByZXBvcnRfZXJyb3IgdCBlXG4gICAgfCBPayAoeyBGcmFtZS5mcmFtZV9wYXlsb2FkOyBmcmFtZV9oZWFkZXIgfSBhcyBmcmFtZSkgLT5cbiAgICAgIChtYXRjaCB0LnJlY2VpdmluZ19oZWFkZXJzX2Zvcl9zdHJlYW0gd2l0aFxuICAgICAgfCBTb21lIHN0cmVhbV9pZFxuICAgICAgICB3aGVuIChub3QgU3RyZWFtX2lkZW50aWZpZXIuKHN0cmVhbV9pZCA9PT0gZnJhbWVfaGVhZGVyLnN0cmVhbV9pZCkpXG4gICAgICAgICAgICAgfHwgZnJhbWVfaGVhZGVyLmZyYW1lX3R5cGUgPD4gQ29udGludWF0aW9uIC0+XG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi4yOlxuICAgICAgICAgKiAgIEEgSEVBREVSUyBmcmFtZSB3aXRob3V0IHRoZSBFTkRfSEVBREVSUyBmbGFnIHNldCBNVVNUIGJlIGZvbGxvd2VkXG4gICAgICAgICAqICAgYnkgYSBDT05USU5VQVRJT04gZnJhbWUgZm9yIHRoZSBzYW1lIHN0cmVhbS4gQSByZWNlaXZlciBNVVNUIHRyZWF0XG4gICAgICAgICAqICAgdGhlIHJlY2VpcHQgb2YgYW55IG90aGVyIHR5cGUgb2YgZnJhbWUgb3IgYSBmcmFtZSBvbiBhIGRpZmZlcmVudFxuICAgICAgICAgKiAgIHN0cmVhbSBhcyBhIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGVcbiAgICAgICAgICogICBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICAgICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3JcbiAgICAgICAgICB0XG4gICAgICAgICAgfnJlYXNvbjpcbiAgICAgICAgICAgIFwiSEVBREVSUyBvciBQVVNIX1BST01JU0Ugd2l0aG91dCB0aGUgRU5EX0hFQURFUlMgZmxhZyBzZXQgbXVzdCBiZSBcXFxuICAgICAgICAgICAgIGZvbGxvd2VkIGJ5IGEgQ09OVElOVUFUSU9OIGZyYW1lIGZvciB0aGUgc2FtZSBzdHJlYW1cIlxuICAgICAgICAgIEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuICAgICAgfCBfIC0+XG4gICAgICAgIChtYXRjaCBmcmFtZV9wYXlsb2FkIHdpdGhcbiAgICAgICAgfCBIZWFkZXJzIChwcmlvcml0eSwgaGVhZGVyc19ibG9jaykgLT5cbiAgICAgICAgICBwcm9jZXNzX2hlYWRlcnNfZnJhbWUgdCBmcmFtZSB+cHJpb3JpdHkgaGVhZGVyc19ibG9ja1xuICAgICAgICB8IERhdGEgYnMgLT4gcHJvY2Vzc19kYXRhX2ZyYW1lIHQgZnJhbWUgYnNcbiAgICAgICAgfCBQcmlvcml0eSBwcmlvcml0eSAtPiBwcm9jZXNzX3ByaW9yaXR5X2ZyYW1lIHQgZnJhbWUgcHJpb3JpdHlcbiAgICAgICAgfCBSU1RTdHJlYW0gZXJyb3JfY29kZSAtPiBwcm9jZXNzX3JzdF9zdHJlYW1fZnJhbWUgdCBmcmFtZSBlcnJvcl9jb2RlXG4gICAgICAgIHwgU2V0dGluZ3Mgc2V0dGluZ3MgLT4gcHJvY2Vzc19zZXR0aW5nc19mcmFtZSB0IGZyYW1lIHNldHRpbmdzXG4gICAgICAgIHwgUHVzaFByb21pc2UgXyAtPlxuICAgICAgICAgICgqIEZyb20gUkZDNzU0MMKnOC4yOlxuICAgICAgICAgICAqICAgQSBjbGllbnQgY2Fubm90IHB1c2guIFRodXMsIHNlcnZlcnMgTVVTVCB0cmVhdCB0aGUgcmVjZWlwdCBvZiBhXG4gICAgICAgICAgICogICBQVVNIX1BST01JU0UgZnJhbWUgYXMgYSBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlXG4gICAgICAgICAgICogICBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICAgICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvclxuICAgICAgICAgICAgdFxuICAgICAgICAgICAgfnJlYXNvbjpcIkNsaWVudCBjYW5ub3QgcHVzaFwiXG4gICAgICAgICAgICBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgICAgICAgfCBQaW5nIGRhdGEgLT4gcHJvY2Vzc19waW5nX2ZyYW1lIHQgZnJhbWUgZGF0YVxuICAgICAgICB8IEdvQXdheSAobGFzdF9zdHJlYW1faWQsIGVycm9yLCBkYXRhKSAtPlxuICAgICAgICAgIHByb2Nlc3NfZ29hd2F5X2ZyYW1lIHQgZnJhbWUgfmxhc3Rfc3RyZWFtX2lkIH5kYXRhIGVycm9yXG4gICAgICAgIHwgV2luZG93VXBkYXRlIHdpbmRvd19zaXplIC0+XG4gICAgICAgICAgcHJvY2Vzc193aW5kb3dfdXBkYXRlX2ZyYW1lIHQgZnJhbWUgd2luZG93X3NpemVcbiAgICAgICAgfCBDb250aW51YXRpb24gaGVhZGVyc19ibG9jayAtPlxuICAgICAgICAgIHByb2Nlc3NfY29udGludWF0aW9uX2ZyYW1lIHQgZnJhbWUgaGVhZGVyc19ibG9ja1xuICAgICAgICB8IFVua25vd24gXyAtPlxuICAgICAgICAgICgqIFRPRE86IGluIHRoZSBmdXR1cmUgd2UgY2FuIGV4cG9zZSBhIGhvb2sgZm9yIGhhbmRsaW5nIHVua25vd25cbiAgICAgICAgICAgKiBmcmFtZXMsIGUuZy4gdGhlIEFMVFNWQyBmcmFtZSBkZWZpbmVkIGluIFJGQzc4MzjCpzRcbiAgICAgICAgICAgKiAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc4Mzgjc2VjdGlvbi00KSAqKVxuICAgICAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4xOlxuICAgICAgICAgICAqICAgRnJhbWVzIG9mIHVua25vd24gdHlwZXMgYXJlIGlnbm9yZWQuICopXG4gICAgICAgICAgKCkpKVxuICBhbmQgdCA9XG4gICAgbGF6eVxuICAgICAgeyBzZXR0aW5nc1xuICAgICAgOyByZWFkZXIgPVxuICAgICAgICAgIFJlYWRlci5zZXJ2ZXJfZnJhbWVzXG4gICAgICAgICAgICB+bWF4X2ZyYW1lX3NpemU6c2V0dGluZ3MubWF4X2ZyYW1lX3NpemVcbiAgICAgICAgICAgIGNvbm5lY3Rpb25fcHJlZmFjZV9oYW5kbGVyXG4gICAgICAgICAgICBmcmFtZV9oYW5kbGVyXG4gICAgICA7IHdyaXRlclxuICAgICAgOyBjb25maWdcbiAgICAgIDsgcmVxdWVzdF9oYW5kbGVyXG4gICAgICA7IGVycm9yX2hhbmRsZXJcbiAgICAgIDsgc3RyZWFtcyA9IFNjaGVkdWxlci5tYWtlX3Jvb3QgKClcbiAgICAgIDsgY3VycmVudF9jbGllbnRfc3RyZWFtcyA9IDBcbiAgICAgIDsgbWF4X2NsaWVudF9zdHJlYW1faWQgPSAwbFxuICAgICAgOyBtYXhfcHVzaGVkX3N0cmVhbV9pZCA9IDBsXG4gICAgICA7IHJlY2VpdmluZ19oZWFkZXJzX2Zvcl9zdHJlYW0gPSBOb25lXG4gICAgICA7IGRpZF9zZW5kX2dvX2F3YXkgPSBmYWxzZVxuICAgICAgOyB1bmFja2VkX3NldHRpbmdzID0gMFxuICAgICAgOyBocGFja19lbmNvZGVyID0gSHBhY2suRW5jb2Rlci4oY3JlYXRlIHNldHRpbmdzLmhlYWRlcl90YWJsZV9zaXplKVxuICAgICAgOyBocGFja19kZWNvZGVyID0gSHBhY2suRGVjb2Rlci4oY3JlYXRlIHNldHRpbmdzLmhlYWRlcl90YWJsZV9zaXplKVxuICAgICAgfVxuICBpblxuICBMYXp5LmZvcmNlIHRcblxubGV0IGNyZWF0ZVxuICAgID8oY29uZmlnID0gQ29uZmlnLmRlZmF1bHQpXG4gICAgPyhlcnJvcl9oYW5kbGVyID0gZGVmYXVsdF9lcnJvcl9oYW5kbGVyKVxuICAgIHJlcXVlc3RfaGFuZGxlclxuICA9XG4gICgqIGBoMmNgIGZhbHNlID0gZGlyZWN0ICopXG4gIGNyZWF0ZV9nZW5lcmljIH5oMmM6ZmFsc2UgfmNvbmZpZyB+ZXJyb3JfaGFuZGxlciByZXF1ZXN0X2hhbmRsZXJcblxubGV0IGhhbmRsZV9oMmNfcmVxdWVzdCB0IGhlYWRlcnMgcmVxdWVzdF9ib2R5X2lvdmVjcyA9XG4gICgqIEZyb20gUkZDNzU0MMKnMy4yOlxuICAgKiAgIFRoZSBIVFRQLzEuMSByZXF1ZXN0IHRoYXQgaXMgc2VudCBwcmlvciB0byB1cGdyYWRlIGlzIGFzc2lnbmVkIGEgc3RyZWFtXG4gICAqICAgaWRlbnRpZmllciBvZiAxIChzZWUgU2VjdGlvbiA1LjEuMSkgd2l0aCBkZWZhdWx0IHByaW9yaXR5IHZhbHVlc1xuICAgKiAgIChTZWN0aW9uIDUuMy41KS4gKilcbiAgbWF0Y2ggb3Blbl9zdHJlYW0gfnByaW9yaXR5OlByaW9yaXR5LmRlZmF1bHRfcHJpb3JpdHkgdCAxbCB3aXRoXG4gIHwgU29tZSAoU2NoZWR1bGVyLlN0cmVhbSB7IGRlc2NyaXB0b3IgPSByZXFkOyBfIH0gYXMgc3RyZWFtKSAtPlxuICAgIGxldCBhY3RpdmVfc3RyZWFtID1cbiAgICAgIFJlcWQuY3JlYXRlX2FjdGl2ZV9zdHJlYW1cbiAgICAgICAgdC5ocGFja19lbmNvZGVyXG4gICAgICAgIHQuY29uZmlnLnJlc3BvbnNlX2JvZHlfYnVmZmVyX3NpemVcbiAgICAgICAgKGNyZWF0ZV9wdXNoX3N0cmVhbSB0KVxuICAgIGluXG4gICAgdC5tYXhfY2xpZW50X3N0cmVhbV9pZCA8LSByZXFkLlN0cmVhbS5pZDtcbiAgICBsZXQgbGVuZ3RodiA9IEh0dHBhZi5JT1ZlYy5sZW5ndGh2IHJlcXVlc3RfYm9keV9pb3ZlY3MgaW5cbiAgICBsZXQgZW5kX3N0cmVhbSA9IGxlbmd0aHYgPSAwIGluXG4gICAgaGFuZGxlX2hlYWRlcnMgdCB+ZW5kX3N0cmVhbSBzdHJlYW0gYWN0aXZlX3N0cmVhbSBoZWFkZXJzO1xuICAgIGxldCByZXF1ZXN0ID0gUmVxZC5yZXF1ZXN0IHJlcWQgaW5cbiAgICBsZXQgcmVxdWVzdF9ib2R5ID0gUmVxZC5yZXF1ZXN0X2JvZHkgcmVxZCBpblxuICAgIGxldCByZXF1ZXN0X2luZm8gPSBSZXFkLmNyZWF0ZV9hY3RpdmVfcmVxdWVzdCByZXF1ZXN0IHJlcXVlc3RfYm9keSBpblxuICAgIHJlcXVlc3RfaW5mby5yZXF1ZXN0X2JvZHlfYnl0ZXMgPC1cbiAgICAgIEludDY0LihhZGQgcmVxdWVzdF9pbmZvLnJlcXVlc3RfYm9keV9ieXRlcyAob2ZfaW50IGxlbmd0aHYpKTtcbiAgICAoKiBGcm9tIFJGQzc1NDDCpzMuMjpcbiAgICAgKiAgIFN0cmVhbSAxIGlzIGltcGxpY2l0bHkgXCJoYWxmLWNsb3NlZFwiIGZyb20gdGhlIGNsaWVudCB0b3dhcmQgdGhlIHNlcnZlclxuICAgICAqICAgKHNlZSBTZWN0aW9uIDUuMSksIHNpbmNlIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlZCBhcyBhbiBIVFRQLzEuMVxuICAgICAqICAgcmVxdWVzdC4gQWZ0ZXIgY29tbWVuY2luZyB0aGUgSFRUUC8yIGNvbm5lY3Rpb24sIHN0cmVhbSAxIGlzIHVzZWQgZm9yXG4gICAgICogICB0aGUgcmVzcG9uc2UuICopXG4gICAgcmVxZC5zdGF0ZSA8LSBBY3RpdmUgKEhhbGZDbG9zZWQgcmVxdWVzdF9pbmZvLCBhY3RpdmVfc3RyZWFtKTtcbiAgICBpZiBub3QgZW5kX3N0cmVhbVxuICAgIHRoZW5cbiAgICAgIGxldCBmYXJhZGF5ID0gQm9keS5SZWFkZXIudW5zYWZlX2ZhcmFkYXkgcmVxdWVzdF9ib2R5IGluXG4gICAgICBpZiBub3QgKEZhcmFkYXkuaXNfY2xvc2VkIGZhcmFkYXkpXG4gICAgICB0aGVuIChcbiAgICAgICAgTGlzdC5pdGVyXG4gICAgICAgICAgKGZ1biB7IEh0dHBhZi5JT1ZlYy5idWZmZXI7IG9mZjsgbGVuIH0gLT5cbiAgICAgICAgICAgICBGYXJhZGF5LnNjaGVkdWxlX2JpZ3N0cmluZyBmYXJhZGF5IH5vZmYgfmxlbiBidWZmZXIpXG4gICAgICAgICAgcmVxdWVzdF9ib2R5X2lvdmVjcztcbiAgICAgICAgKCogQ2xvc2UgdGhlIHJlcXVlc3QgYm9keSwgd2UncmUgbm90IGV4cGVjdGluZyBtb3JlIGlucHV0LiAqKVxuICAgICAgICBCb2R5LlJlYWRlci5jbG9zZSByZXF1ZXN0X2JvZHkpXG4gIHwgTm9uZSAtPiAoKVxuXG4oKiBUaGlzIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGJlIGNhbGxlZCBpbnNpZGUgYW4gSFRUUC8xLjEgdXBncmFkZSBoYW5kbGVyLlxuICpcbiAqIEl0J3MgdXNlZnVsIHRvIGhhdmUgdGhlIHJlcXVlc3QgYm9keSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgYSBzaW5nbGUgcmVxdWVzdFxuICogaGFuZGxlciBtYXkgcHJvY2VzcyBib3RoIHVwZ3JhZGVkIChoMmMpIGFuZCBkaXJlY3QgY29ubmVjdGlvbnMuIEdpdmVuIHRoZVxuICogZm9sbG93aW5nLCBhcHBsaWNhdGlvbiBjb2RlIHRoYXQgY2FsbHMgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBidWZmZXIgdGhlXG4gKiBlbnRpcmUgcmVxdWVzdCBib2R5IGluIG1lbW9yeSBpZiBpdCB3YW50cywgc28gd2UgY2FuIGp1c3QgZ2V0IGFcbiAqIGBCaWdzdHJpbmdhZi50IElPVmVjLnQgbGlzdGBcbiAqXG4gKlxuICogRnJvbSBSRkM3NTQwwqczLjI6XG4gKiAgIFJlcXVlc3RzIHRoYXQgY29udGFpbiBhIHBheWxvYWQgYm9keSBNVVNUIGJlIHNlbnQgaW4gdGhlaXJcbiAqICAgZW50aXJldHkgYmVmb3JlIHRoZSBjbGllbnQgY2FuIHNlbmQgSFRUUC8yIGZyYW1lcy4gVGhpcyBtZWFuc1xuICogICB0aGF0IGEgbGFyZ2UgcmVxdWVzdCBjYW4gYmxvY2sgdGhlIHVzZSBvZiB0aGUgY29ubmVjdGlvbiB1bnRpbFxuICogICBpdCBpcyBjb21wbGV0ZWx5IHNlbnQuICopXG5sZXQgY3JlYXRlX2gyY1xuICAgID8oY29uZmlnID0gQ29uZmlnLmRlZmF1bHQpXG4gICAgPyhlcnJvcl9oYW5kbGVyID0gZGVmYXVsdF9lcnJvcl9oYW5kbGVyKVxuICAgIH5odHRwX3JlcXVlc3RcbiAgICA/KHJlcXVlc3RfYm9keSA9IFtdKVxuICAgIHJlcXVlc3RfaGFuZGxlclxuICA9XG4gIGxldCB7IEh0dHBhZi5SZXF1ZXN0LmhlYWRlcnM7IF8gfSA9IGh0dHBfcmVxdWVzdCBpblxuICAoKiBGcm9tIFJGQzc1NDDCpzMuMi4xOlxuICAgKiAgIEEgcmVxdWVzdCB0aGF0IHVwZ3JhZGVzIGZyb20gSFRUUC8xLjEgdG8gSFRUUC8yIE1VU1QgaW5jbHVkZSBleGFjdGx5IG9uZVxuICAgKiAgIEhUVFAyLVNldHRpbmdzIGhlYWRlciBmaWVsZC5cbiAgICpcbiAgICogICBbLi4uXSBBIHNlcnZlciBNVVNUIE5PVCB1cGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIEhUVFAvMiBpZiB0aGlzIGhlYWRlclxuICAgKiAgIGZpZWxkIGlzIG5vdCBwcmVzZW50IG9yIGlmIG1vcmUgdGhhbiBvbmUgaXMgcHJlc2VudC4gQSBzZXJ2ZXIgTVVTVCBOT1RcbiAgICogICBzZW5kIHRoaXMgaGVhZGVyIGZpZWxkLiAqKVxuICBtYXRjaFxuICAgIEh0dHBhZi5IZWFkZXJzLihcbiAgICAgIGdldF9tdWx0aSBoZWFkZXJzIFwiaHR0cDItc2V0dGluZ3NcIiwgZ2V0X211bHRpIGhlYWRlcnMgXCJjb25uZWN0aW9uXCIpXG4gIHdpdGhcbiAgfCBbIHNldHRpbmdzIF0sIFsgY29ubmVjdGlvbiBdIHdoZW4gSGVhZGVycy5pc192YWxpZF9oMmNfY29ubmVjdGlvbiBjb25uZWN0aW9uXG4gICAgLT5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzMuMi4xOlxuICAgICAqICAgVGhlIGNvbnRlbnQgb2YgdGhlIEhUVFAyLVNldHRpbmdzIGhlYWRlciBmaWVsZCBpcyB0aGUgcGF5bG9hZCBvZiBhXG4gICAgICogICBTRVRUSU5HUyBmcmFtZSAoU2VjdGlvbiA2LjUpLCBlbmNvZGVkIGFzIGEgYmFzZTY0dXJsIHN0cmluZyAodGhhdCBpcyxcbiAgICAgKiAgIHRoZSBVUkwtIGFuZCBmaWxlbmFtZS1zYWZlIEJhc2U2NCBlbmNvZGluZyBkZXNjcmliZWQgaW4gU2VjdGlvbiA1IG9mXG4gICAgICogICBbUkZDNDY0OF0sIHdpdGggYW55IHRyYWlsaW5nICc9JyBjaGFyYWN0ZXJzIG9taXR0ZWQpLlxuICAgICAqXG4gICAgICogICBbLi4uXSBBIHNlcnZlciBkZWNvZGVzIGFuZCBpbnRlcnByZXRzIHRoZXNlIHZhbHVlcyBhcyBpdCB3b3VsZCBhbnlcbiAgICAgKiAgIG90aGVyIFNFVFRJTkdTIGZyYW1lLiBFeHBsaWNpdCBhY2tub3dsZWRnZW1lbnQgb2YgdGhlc2Ugc2V0dGluZ3NcbiAgICAgKiAgIChTZWN0aW9uIDYuNS4zKSBpcyBub3QgbmVjZXNzYXJ5LCBzaW5jZSBhIDEwMSByZXNwb25zZSBzZXJ2ZXMgYXNcbiAgICAgKiAgIGltcGxpY2l0IGFja25vd2xlZGdlbWVudC4gKilcbiAgICAobWF0Y2ggSGVhZGVycy5vZl9odHRwMSBodHRwX3JlcXVlc3Qgd2l0aFxuICAgIHwgT2sgaDJfaGVhZGVycyAtPlxuICAgICAgKG1hdGNoIFNldHRpbmdzLm9mX2Jhc2U2NCBzZXR0aW5ncyB3aXRoXG4gICAgICB8IE9rIHVwZ3JhZGVfc2V0dGluZ3MgLT5cbiAgICAgICAgbGV0IHNldHRpbmdzX2xpc3QgPVxuICAgICAgICAgIFNldHRpbmdzLnNldHRpbmdzX2Zvcl90aGVfY29ubmVjdGlvbiB1cGdyYWRlX3NldHRpbmdzXG4gICAgICAgIGluXG4gICAgICAgIChtYXRjaCBTZXR0aW5ncy5jaGVja19zZXR0aW5nc19saXN0IHNldHRpbmdzX2xpc3Qgd2l0aFxuICAgICAgICB8IE9rICgpIC0+XG4gICAgICAgICAgbGV0IHQgPVxuICAgICAgICAgICAgY3JlYXRlX2dlbmVyaWMgfmgyYzp0cnVlIH5jb25maWcgfmVycm9yX2hhbmRsZXIgcmVxdWVzdF9oYW5kbGVyXG4gICAgICAgICAgaW5cbiAgICAgICAgICBhcHBseV9zZXR0aW5nc19saXN0IHQgc2V0dGluZ3NfbGlzdDtcbiAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzMuNTpcbiAgICAgICAgICAgKiAgIFRoZSBmaXJzdCBIVFRQLzIgZnJhbWUgc2VudCBieSB0aGUgc2VydmVyIE1VU1QgYmUgYSBzZXJ2ZXJcbiAgICAgICAgICAgKiAgIGNvbm5lY3Rpb24gcHJlZmFjZSAoU2VjdGlvbiAzLjUpIGNvbnNpc3Rpbmcgb2YgYSBTRVRUSU5HU1xuICAgICAgICAgICAqICAgZnJhbWUgKFNlY3Rpb24gNi41KS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgTm90ZTogYXMgb3Bwb3NlZCB0byBhIGNvbm5lY3Rpb24gc3RhcnRlZCBieSBhIGNsaWVudCwgaW4gaDJjXG4gICAgICAgICAgICogICB3ZSdyZSB1cGdyYWRpbmcgZnJvbSBIVFRQLzEuMSBzbyB0aGUgc2VydmVyIGlzIHJlcG9uc2libGUgZm9yXG4gICAgICAgICAgICogICB3cml0aW5nIHRoZSBIVFRQLzIgY29ubmVjdGlvbiBwcmVmYWNlIHRvIHRoZSB3aXJlIGZpcnN0LiBXZVxuICAgICAgICAgICAqICAgYWxzbyBjb25maWd1cmUgdGhlIGNvbm5lY3Rpb24gd2l0aCBgfmgyYzp0cnVlYCBhYm92ZSB0byBub3RcbiAgICAgICAgICAgKiAgIHNlbmQgaXQgYSBzZWNvbmQgdGltZS4gKilcbiAgICAgICAgICB3cml0ZV9jb25uZWN0aW9uX3ByZWZhY2UgdDtcbiAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzMuMjpcbiAgICAgICAgICAgKiAgIEEgc2VydmVyIHRoYXQgc3VwcG9ydHMgSFRUUC8yIGFjY2VwdHMgdGhlIHVwZ3JhZGUgd2l0aCBhIDEwMVxuICAgICAgICAgICAqICAgKFN3aXRjaGluZyBQcm90b2NvbHMpIHJlc3BvbnNlLiBBZnRlciB0aGUgZW1wdHkgbGluZSB0aGF0XG4gICAgICAgICAgICogICB0ZXJtaW5hdGVzIHRoZSAxMDEgcmVzcG9uc2UsIHRoZSBzZXJ2ZXIgY2FuIGJlZ2luIHNlbmRpbmdcbiAgICAgICAgICAgKiAgIEhUVFAvMiBmcmFtZXMuIFRoZXNlIGZyYW1lcyBNVVNUIGluY2x1ZGUgYSByZXNwb25zZSB0byB0aGVcbiAgICAgICAgICAgKiAgIHJlcXVlc3QgdGhhdCBpbml0aWF0ZWQgdGhlIHVwZ3JhZGUgKilcbiAgICAgICAgICBoYW5kbGVfaDJjX3JlcXVlc3QgdCBoMl9oZWFkZXJzIHJlcXVlc3RfYm9keTtcbiAgICAgICAgICBPayB0XG4gICAgICAgIHwgRXJyb3IgZXJyb3IgLT4gRXJyb3IgKEVycm9yLm1lc3NhZ2UgZXJyb3IpKVxuICAgICAgfCBFcnJvciBtc2cgLT4gRXJyb3IgbXNnKVxuICAgIHwgRXJyb3IgbXNnIC0+IEVycm9yIG1zZylcbiAgfCBfIC0+XG4gICAgRXJyb3JcbiAgICAgIFwiQSByZXF1ZXN0IHRoYXQgdXBncmFkZXMgZnJvbSBIVFRQLzEuMSB0byBIVFRQLzIgTVVTVCBpbmNsdWRlIGV4YWN0bHkgXFxcbiAgICAgICBvbmUgSFRUUDItU2V0dGluZ3MgaGVhZGVyIGZpZWxkIGFuZCBIVFRQMi1TZXR0aW5ncyBhcyBhIGNvbm5lY3Rpb24gXFxcbiAgICAgICBvcHRpb24gaW4gdGhlIENvbm5lY3Rpb24gaGVhZGVyIGZpZWxkLlwiXG5cbmxldCBuZXh0X3JlYWRfb3BlcmF0aW9uIHQgPVxuICBpZiBSZWFkZXIuaXNfY2xvc2VkIHQucmVhZGVyIHRoZW4gc2h1dGRvd25fcmVhZGVyIHQ7XG4gIG1hdGNoIFJlYWRlci5uZXh0IHQucmVhZGVyIHdpdGhcbiAgfCAoYFJlYWQgfCBgQ2xvc2UpIGFzIG9wZXJhdGlvbiAtPiBvcGVyYXRpb25cbiAgfCBgRXJyb3IgZSAtPlxuICAgIHJlcG9ydF9lcnJvciB0IGU7XG4gICAgKG1hdGNoIGUgd2l0aFxuICAgIHwgQ29ubmVjdGlvbkVycm9yIF8gLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnNS40LjE6XG4gICAgICAgKiAgIEEgY29ubmVjdGlvbiBlcnJvciBpcyBhbnkgZXJyb3IgdGhhdCBwcmV2ZW50cyBmdXJ0aGVyIHByb2Nlc3NpbmdcbiAgICAgICAqICAgb2YgdGhlIGZyYW1lIGxheWVyIG9yIGNvcnJ1cHRzIGFueSBjb25uZWN0aW9uIHN0YXRlLiAqKVxuICAgICAgYENsb3NlXG4gICAgfCBTdHJlYW1FcnJvciBfIC0+XG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuNC4yOlxuICAgICAgICogICBBIHN0cmVhbSBlcnJvciBpcyBhbiBlcnJvciByZWxhdGVkIHRvIGEgc3BlY2lmaWMgc3RyZWFtIHRoYXQgZG9lc1xuICAgICAgICogICBub3QgYWZmZWN0IHByb2Nlc3Npbmcgb2Ygb3RoZXIgc3RyZWFtcy4gKilcbiAgICAgIGBSZWFkKVxuXG5sZXQgcmVhZCB0IGJzIH5vZmYgfmxlbiA9IFJlYWRlci5yZWFkX3dpdGhfbW9yZSB0LnJlYWRlciBicyB+b2ZmIH5sZW4gSW5jb21wbGV0ZVxuXG5sZXQgcmVhZF9lb2YgdCBicyB+b2ZmIH5sZW4gPVxuICBSZWFkZXIucmVhZF93aXRoX21vcmUgdC5yZWFkZXIgYnMgfm9mZiB+bGVuIENvbXBsZXRlXG5cbigqIFhYWChhbm1vbnRlaXJvKTogdGhpcyBmdW5jdGlvbiBpcyBoZXJlIHRvIHBsZWFzZSB0aGUgR2x1dGVuIGBSVU5USU1FYFxuICogaW50ZXJmYWNlLlxuICpcbiAqIFdlIGRvbid0IGV4cGVjdCB0aGlzIGZ1bmN0aW9uIHRvIGV2ZXIgYmUgY2FsbGVkLiBIMiBuZXZlciBpc3N1ZXMgYFlpZWxkYFxuICogY29tbWFuZHMgYmVjYXVzZSB0aGUgY29ubmVjdGlvbiBpcyBtdWx0aXBsZXhlZCwgYW5kIGl0J3MgdGhlcmVmb3JlIGFsd2F5c1xuICogbG9va2luZyB0byByZWFkIGZyYW1lcyBmcm9tIHRoZSBwZWVyLiAqKVxubGV0IHlpZWxkX3JlYWRlciBfdCBrID0gayAoKVxuXG5sZXQgbmV4dF93cml0ZV9vcGVyYXRpb24gdCA9XG4gIFNjaGVkdWxlci5mbHVzaCB0LnN0cmVhbXMgKHQubWF4X2NsaWVudF9zdHJlYW1faWQsIHQubWF4X3B1c2hlZF9zdHJlYW1faWQpO1xuICBXcml0ZXIubmV4dCB0LndyaXRlclxuXG5sZXQgcmVwb3J0X3dyaXRlX3Jlc3VsdCB0IHJlc3VsdCA9IFdyaXRlci5yZXBvcnRfcmVzdWx0IHQud3JpdGVyIHJlc3VsdFxubGV0IHlpZWxkX3dyaXRlciB0IGsgPSBXcml0ZXIub25fd2FrZXVwX3dyaXRlciB0LndyaXRlciBrXG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIDIwMTkgQW50w7NuaW8gTnVubyBNb250ZWlyb1xuICpcbiAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzXG4gKiAgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqICBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiAgQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG4oKiBUT0RPKGFubW9udGVpcm8pOiB0aGluayBhYm91dCB3aGV0aGVyIHdlIHdhbm5hIGV4cG9zZSB0aGlzIG1vZHVsZS4gaXQgbWlnaHRcbiAqIGJlIGhlbHBmdWwgdG8gZXhwb3NlIGEgd2F5IHRvIHJlc2V0IHN0cmVhbXMsIGFuZCBJIHRoaW5rIHdlJ2QgbmVlZCBhXG4gKiByZWZlcmVuY2UgdG8gdGhlIFJlc3BkICopXG5cbm1vZHVsZSBXcml0ZXIgPSBTZXJpYWxpemUuV3JpdGVyXG5cbnR5cGUgZXJyb3IgPVxuICBbIGBNYWxmb3JtZWRfcmVzcG9uc2Ugb2Ygc3RyaW5nXG4gIHwgYEludmFsaWRfcmVzcG9uc2VfYm9keV9sZW5ndGggb2YgUmVzcG9uc2UudFxuICB8IGBQcm90b2NvbF9lcnJvciBvZiBFcnJvcl9jb2RlLnQgKiBzdHJpbmdcbiAgfCBgRXhuIG9mIGV4blxuICBdXG5cbnR5cGUgZXJyb3JfaGFuZGxlciA9IGVycm9yIC0+IHVuaXRcbnR5cGUgcmVzcG9uc2VfaGFuZGxlciA9IFJlc3BvbnNlLnQgLT4gQm9keS5SZWFkZXIudCAtPiB1bml0XG5cbnR5cGUgcmVzcG9uc2VfaW5mbyA9XG4gIHsgcmVzcG9uc2UgOiBSZXNwb25zZS50XG4gIDsgcmVzcG9uc2VfYm9keSA6IEJvZHkuUmVhZGVyLnRcbiAgOyBtdXRhYmxlIHJlc3BvbnNlX2JvZHlfYnl0ZXMgOiBpbnQ2NFxuICA7IG11dGFibGUgdHJhaWxlcnNfcGFyc2VyIDogU3RyZWFtLnBhcnRpYWxfaGVhZGVycyBvcHRpb25cbiAgfVxuXG50eXBlIHRyYWlsZXJzX2hhbmRsZXIgPSBIZWFkZXJzLnQgLT4gdW5pdFxuXG50eXBlIGFjdGl2ZV9yZXF1ZXN0ID1cbiAgeyByZXF1ZXN0IDogUmVxdWVzdC50XG4gIDsgcmVxdWVzdF9ib2R5IDogQm9keS5Xcml0ZXIudFxuICA7IHJlc3BvbnNlX2hhbmRsZXIgOiByZXNwb25zZV9oYW5kbGVyXG4gIDsgdHJhaWxlcnNfaGFuZGxlciA6IHRyYWlsZXJzX2hhbmRsZXJcbiAgfVxuXG50eXBlIGFjdGl2ZV9zdGF0ZSA9XG4gIChyZXNwb25zZV9pbmZvLCByZXNwb25zZV9pbmZvIFN0cmVhbS5yZW1vdGVfc3RhdGUpIFN0cmVhbS5hY3RpdmVfc3RhdGVcblxudHlwZSBzdGF0ZSA9XG4gICggYWN0aXZlX3N0YXRlXG4gICAgLCBhY3RpdmVfcmVxdWVzdFxuICAgICwgYWN0aXZlX3JlcXVlc3QgU3RyZWFtLnJlbW90ZV9zdGF0ZSApXG4gICAgU3RyZWFtLnN0YXRlXG5cbnR5cGUgdCA9IChzdGF0ZSwgZXJyb3IsIGVycm9yX2hhbmRsZXIpIFN0cmVhbS50XG5cbmxldCBjcmVhdGVfYWN0aXZlX3Jlc3BvbnNlIHJlc3BvbnNlIHJlc3BvbnNlX2JvZHkgPVxuICBTdHJlYW0uQWN0aXZlTWVzc2FnZVxuICAgIHsgcmVzcG9uc2VcbiAgICA7IHJlc3BvbnNlX2JvZHlcbiAgICA7IHJlc3BvbnNlX2JvZHlfYnl0ZXMgPSBJbnQ2NC56ZXJvXG4gICAgOyB0cmFpbGVyc19wYXJzZXIgPSBOb25lXG4gICAgfVxuXG5sZXQgcmVzcG9uc2VfYm9keV9leG4gKHQgOiB0KSA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IElkbGUgfCBSZXNlcnZlZCBfIC0+XG4gICAgZmFpbHdpdGggXCJoMi5SZXNwZC5yZXNwb25zZV9leG46IHJlc3BvbnNlIGhhcyBub3QgYXJyaXZlZFwiXG4gIHwgQWN0aXZlXG4gICAgICAoICggT3BlbiAoQWN0aXZlTWVzc2FnZSB7IHJlc3BvbnNlX2JvZHk7IF8gfSlcbiAgICAgICAgfCBIYWxmQ2xvc2VkIChBY3RpdmVNZXNzYWdlIHsgcmVzcG9uc2VfYm9keTsgXyB9KSApXG4gICAgICAsIF8gKSAtPlxuICAgIHJlc3BvbnNlX2JvZHlcbiAgfCBBY3RpdmUgKChPcGVuIF8gfCBIYWxmQ2xvc2VkIF8pLCBfKSAtPlxuICAgIGZhaWx3aXRoIFwiaDIuUmVzcGQucmVzcG9uc2VfZXhuOiByZXNwb25zZSBoYXMgbm90IGFycml2ZWRcIlxuICB8IENsb3NlZCBfIC0+IGZhaWx3aXRoIFwiaDIuUmVzcGQucmVzcG9uc2VfZXhuOiBzdHJlYW0gYWxyZWFkeSBjbG9zZWRcIlxuXG5sZXQgY2xvc2Vfc3RyZWFtICh0IDogdCkgPVxuICAoKiBUT0RPOiByZXNlcnZlZCAqKVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBBY3RpdmUgKEhhbGZDbG9zZWQgXywgXykgLT5cbiAgICAoKiBlYXN5IGNhc2UsIGp1c3QgdHJhbnNpdGlvbiB0byB0aGUgY2xvc2VkIHN0YXRlLiAqKVxuICAgIFN0cmVhbS5maW5pc2hfc3RyZWFtIHQgRmluaXNoZWRcbiAgfCBBY3RpdmUgKE9wZW4gXywgXykgLT5cbiAgICAoKiBTdGlsbCBub3QgZG9uZSBzZW5kaW5nLCByZXNldCBzdHJlYW0gd2l0aCBubyBlcnJvcj8gKilcbiAgICAoKiBUT0RPOiAqKVxuICAgICgpXG4gIHwgXyAtPiAoKVxuXG5sZXQgX3JlcG9ydF9lcnJvciAodCA6IHQpID9yZXNwb25zZV9ib2R5IChlcnJvciA6IGVycm9yKSBlcnJvcl9jb2RlID1cbiAgbWF0Y2ggdC5lcnJvcl9jb2RlIHdpdGhcbiAgfCBOb19lcnJvciAtPlxuICAgIChtYXRjaCByZXNwb25zZV9ib2R5IHdpdGhcbiAgICB8IFNvbWUgcmVzcG9uc2VfYm9keSAtPiBCb2R5LlJlYWRlci5jbG9zZSByZXNwb25zZV9ib2R5XG4gICAgfCBOb25lIC0+ICgpKTtcbiAgICB0LmVycm9yX2NvZGUgPC0gU3RyZWFtLmVycm9yX3RvX2NvZGUgZXJyb3IgZXJyb3JfY29kZTtcbiAgICB0LmVycm9yX2hhbmRsZXIgZXJyb3JcbiAgfCBFeG4gXyB8IE90aGVyIF8gLT5cbiAgICAoKiBBbHJlYWR5IGhhbmRsaW5nIGVycm9yLlxuICAgICAqIFRPRE8oYW5tb250ZWlybyk6IExvZyBhIG1lc3NhZ2Ugd2hlbiB3ZSBhZGQgTG9ncyBzdXBwb3J0ICopXG4gICAgKClcblxubGV0IHJlcG9ydF9lcnJvciAodCA6IHQpIGVycm9yIGVycm9yX2NvZGUgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBBY3RpdmVcbiAgICAgICggKCBPcGVuIChBY3RpdmVNZXNzYWdlIHsgcmVzcG9uc2VfYm9keTsgXyB9KVxuICAgICAgICB8IEhhbGZDbG9zZWQgKEFjdGl2ZU1lc3NhZ2UgeyByZXNwb25zZV9ib2R5OyBfIH0pIClcbiAgICAgICwgcyApIC0+XG4gICAgQm9keS5Xcml0ZXIuY2xvc2Ugcy5yZXF1ZXN0X2JvZHk7XG4gICAgX3JlcG9ydF9lcnJvciB0IH5yZXNwb25zZV9ib2R5IGVycm9yIGVycm9yX2NvZGU7XG4gICAgU3RyZWFtLnJlc2V0X3N0cmVhbSB0IGVycm9yX2NvZGVcbiAgfCBSZXNlcnZlZCAoQWN0aXZlTWVzc2FnZSBzKSB8IEFjdGl2ZSAoXywgcykgLT5cbiAgICBCb2R5LldyaXRlci5jbG9zZSBzLnJlcXVlc3RfYm9keTtcbiAgICBfcmVwb3J0X2Vycm9yIHQgZXJyb3IgZXJyb3JfY29kZTtcbiAgICBTdHJlYW0ucmVzZXRfc3RyZWFtIHQgZXJyb3JfY29kZVxuICB8IFJlc2VydmVkIF8gLT5cbiAgICAoKiBTdHJlYW1zIGluIHRoZSByZXNlcnZlZCBzdGF0ZSBkb24ndCB5ZXQgaGF2ZSBhIHN0cmVhbS1sZXZlbCBlcnJvclxuICAgICAqIGhhbmRsZXIgcmVnaXN0ZXJlZCB3aXRoIHRoZW0gKilcbiAgICAoKVxuICB8IElkbGUgfCBDbG9zZWQgXyAtPlxuICAgICgqIE5vdCBhbGxvd2VkIHRvIHNlbmQgUlNUX1NUUkVBTSBmcmFtZXMgaW4gdGhlc2Ugc3RhdGVzICopXG4gICAgaWdub3JlIChfcmVwb3J0X2Vycm9yIHQgZXJyb3IgZXJyb3JfY29kZSlcblxubGV0IHJlcXVpcmVzX291dHB1dCAodCA6IHQpID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgSWRsZSAtPiB0cnVlXG4gIHwgUmVzZXJ2ZWQgXyAtPiBmYWxzZVxuICB8IEFjdGl2ZSAoT3BlbiBfLCBfKSAtPiB0cnVlXG4gIHwgQWN0aXZlIChIYWxmQ2xvc2VkIF8sIF8pIC0+IGZhbHNlXG4gIHwgQ2xvc2VkIF8gLT4gZmFsc2VcblxubGV0IGZsdXNoX3JlcXVlc3RfYm9keSAodCA6IHQpIH5tYXhfYnl0ZXMgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBBY3RpdmUgKE9wZW4gYWN0aXZlX3N0YXRlLCAoeyByZXF1ZXN0X2JvZHk7IF8gfSBhcyBzKSkgLT5cbiAgICBpZiBCb2R5LldyaXRlci5oYXNfcGVuZGluZ19vdXRwdXQgcmVxdWVzdF9ib2R5ICYmIG1heF9ieXRlcyA+IDBcbiAgICB0aGVuXG4gICAgICBCb2R5LldyaXRlci50cmFuc2Zlcl90b193cml0ZXJcbiAgICAgICAgcmVxdWVzdF9ib2R5XG4gICAgICAgIHQud3JpdGVyXG4gICAgICAgIH5tYXhfZnJhbWVfc2l6ZTp0Lm1heF9mcmFtZV9zaXplXG4gICAgICAgIH5tYXhfYnl0ZXNcbiAgICAgICAgdC5pZFxuICAgIGVsc2UgaWYgQm9keS5Xcml0ZXIuaXNfY2xvc2VkIHJlcXVlc3RfYm9keVxuICAgIHRoZW4gKFxuICAgICAgKCogY2xvc2VkIGFuZCBubyBwZW5kaW5nIG91dHB1dCAqKVxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjkuMTpcbiAgICAgICAqICAgRnJhbWVzIHdpdGggemVybyBsZW5ndGggd2l0aCB0aGUgRU5EX1NUUkVBTSBmbGFnIHNldCAodGhhdCBpcywgYW5cbiAgICAgICAqICAgZW1wdHkgREFUQSBmcmFtZSkgTUFZIGJlIHNlbnQgaWYgdGhlcmUgaXMgbm8gYXZhaWxhYmxlIHNwYWNlIGluXG4gICAgICAgKiAgIGVpdGhlciBmbG93LWNvbnRyb2wgd2luZG93LiAqKVxuICAgICAgbGV0IGZyYW1lX2luZm8gPVxuICAgICAgICBXcml0ZXIubWFrZV9mcmFtZV9pbmZvXG4gICAgICAgICAgfm1heF9mcmFtZV9zaXplOnQubWF4X2ZyYW1lX3NpemVcbiAgICAgICAgICB+ZmxhZ3M6RmxhZ3MuKHNldF9lbmRfc3RyZWFtIGRlZmF1bHRfZmxhZ3MpXG4gICAgICAgICAgdC5pZFxuICAgICAgaW5cbiAgICAgIFdyaXRlci5zY2hlZHVsZV9kYXRhIHQud3JpdGVyIGZyYW1lX2luZm8gfmxlbjowIEJpZ3N0cmluZ2FmLmVtcHR5O1xuICAgICAgdC5zdGF0ZSA8LSBBY3RpdmUgKEhhbGZDbG9zZWQgYWN0aXZlX3N0YXRlLCBzKTtcbiAgICAgIDApXG4gICAgZWxzZSAoKiBub3QgY2xvc2VkIGFuZCBubyBwZW5kaW5nIG91dHB1dCAqKVxuICAgICAgMFxuICB8IF8gLT4gMFxuXG5sZXQgZGVsaXZlcl90cmFpbGVyX2hlYWRlcnMgKHQgOiB0KSBoZWFkZXJzID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgQWN0aXZlXG4gICAgICAoIChPcGVuIChBY3RpdmVNZXNzYWdlIF8pIHwgSGFsZkNsb3NlZCAoQWN0aXZlTWVzc2FnZSBfKSlcbiAgICAgICwgeyB0cmFpbGVyc19oYW5kbGVyOyBfIH0gKSAtPlxuICAgIHRyYWlsZXJzX2hhbmRsZXIgaGVhZGVyc1xuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBmbHVzaF9yZXNwb25zZV9ib2R5ICh0IDogdCkgPVxuICBtYXRjaCB0LnN0YXRlIHdpdGhcbiAgfCBBY3RpdmVcbiAgICAgICggKCBPcGVuIChBY3RpdmVNZXNzYWdlIHsgcmVzcG9uc2VfYm9keTsgXyB9KVxuICAgICAgICB8IEhhbGZDbG9zZWQgKEFjdGl2ZU1lc3NhZ2UgeyByZXNwb25zZV9ib2R5OyBfIH0pIClcbiAgICAgICwgXyApIC0+XG4gICAgaWYgQm9keS5SZWFkZXIuaGFzX3BlbmRpbmdfb3V0cHV0IHJlc3BvbnNlX2JvZHlcbiAgICB0aGVuIChcbiAgICAgIHRyeSBCb2R5LlJlYWRlci5leGVjdXRlX3JlYWQgcmVzcG9uc2VfYm9keSB3aXRoXG4gICAgICB8IGV4biAtPiByZXBvcnRfZXJyb3IgdCAoYEV4biBleG4pIEludGVybmFsRXJyb3IpXG4gIHwgXyAtPiAoKVxuIiwiKCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE3IEluaGFiaXRlZCBUeXBlIExMQy5cbiAqICBDb3B5cmlnaHQgKGMpIDIwMTkgQW50b25pbyBOLiBNb250ZWlyby5cbiAqXG4gKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiAgYXJlIG1ldDpcbiAqXG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAqICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAqICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09OVFJJQlVUT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NcbiAqICBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAqICBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbiAqICBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gKiAgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAqICBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTilcbiAqICBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXG4gKiAgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOXG4gKiAgQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbm1vZHVsZSBIdHRwYWYgPSBEcmVhbV9odHRwYWZfLkh0dHBhZlxubW9kdWxlIEhwYWNrID0gRHJlYW1faHBhY2suSHBhY2tcblxubW9kdWxlIEFCID0gQW5nc3Ryb20uQnVmZmVyZWRcbm1vZHVsZSBSZWFkZXIgPSBQYXJzZS5SZWFkZXJcbm1vZHVsZSBXcml0ZXIgPSBTZXJpYWxpemUuV3JpdGVyXG5tb2R1bGUgU3RyZWFtc1RibCA9IFNjaGVkdWxlci5TdHJlYW1zVGJsXG5cbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXIuTWFrZSAoc3RydWN0XG4gICAgaW5jbHVkZSBTdHJlYW1cblxuICAgIHR5cGUgdCA9IFJlc3BkLnRcblxuICAgIGxldCBmbHVzaF93cml0ZV9ib2R5ID0gUmVzcGQuZmx1c2hfcmVxdWVzdF9ib2R5XG4gICAgbGV0IHJlcXVpcmVzX291dHB1dCA9IFJlc3BkLnJlcXVpcmVzX291dHB1dFxuICBlbmQpXG5cbm1vZHVsZSBRdWV1ZSA9IHN0cnVjdFxuICBpbmNsdWRlIFF1ZXVlXG5cbiAgbGV0IHRha2Vfb3B0IHQgPSBtYXRjaCBpc19lbXB0eSB0IHdpdGggdHJ1ZSAtPiBOb25lIHwgZmFsc2UgLT4gU29tZSAodGFrZSB0KVxuZW5kXG5cbnR5cGUgZXJyb3IgPSBSZXNwZC5lcnJvclxudHlwZSB0cmFpbGVyc19oYW5kbGVyID0gSGVhZGVycy50IC0+IHVuaXRcbnR5cGUgcmVzcG9uc2VfaGFuZGxlciA9IFJlc3BvbnNlLnQgLT4gQm9keS5SZWFkZXIudCAtPiB1bml0XG50eXBlIGVycm9yX2hhbmRsZXIgPSBlcnJvciAtPiB1bml0XG5cbnR5cGUgdCA9XG4gIHsgbXV0YWJsZSBzZXR0aW5ncyA6IFNldHRpbmdzLnRcbiAgOyByZWFkZXIgOiBSZWFkZXIuZnJhbWVcbiAgOyB3cml0ZXIgOiBXcml0ZXIudFxuICA7IGNvbmZpZyA6IENvbmZpZy50XG4gIDsgc3RyZWFtcyA6IFNjaGVkdWxlci50XG4gIDsgbXV0YWJsZSBjdXJyZW50X3N0cmVhbV9pZCA6IFN0cmVhbV9pZGVudGlmaWVyLnRcbiAgOyBtdXRhYmxlIG1heF9wdXNoZWRfc3RyZWFtX2lkIDogU3RyZWFtX2lkZW50aWZpZXIudFxuICA7IG11dGFibGUgY3VycmVudF9zZXJ2ZXJfc3RyZWFtcyA6IGludFxuICA7IG11dGFibGUgcmVjZWl2aW5nX2hlYWRlcnNfZm9yX3N0cmVhbSA6IFN0cmVhbV9pZGVudGlmaWVyLnQgb3B0aW9uXG4gIDsgbXV0YWJsZSBkaWRfc2VuZF9nb19hd2F5IDogYm9vbFxuICA7IG11dGFibGUgdW5hY2tlZF9zZXR0aW5ncyA6IGludFxuICA7IHBlbmRpbmdfcGluZ3MgOiAoKHVuaXQsIFsgYEVPRiBdKSByZXN1bHQgLT4gdW5pdCkgUXVldWUudFxuICA7IGVycm9yX2hhbmRsZXIgOiBlcnJvciAtPiB1bml0XG4gIDsgcHVzaF9oYW5kbGVyIDogUmVxdWVzdC50IC0+IChyZXNwb25zZV9oYW5kbGVyLCB1bml0KSByZXN1bHRcbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc0LjM6XG4gICAgICAgICAqICAgSGVhZGVyIGNvbXByZXNzaW9uIGlzIHN0YXRlZnVsLiBPbmUgY29tcHJlc3Npb24gY29udGV4dCBhbmQgb25lXG4gICAgICAgICAqICAgZGVjb21wcmVzc2lvbiBjb250ZXh0IGFyZSB1c2VkIGZvciB0aGUgZW50aXJlIGNvbm5lY3Rpb24uICopXG4gIDsgaHBhY2tfZW5jb2RlciA6IEhwYWNrLkVuY29kZXIudFxuICA7IGhwYWNrX2RlY29kZXIgOiBIcGFjay5EZWNvZGVyLnRcbiAgfVxuXG5sZXQgZGVmYXVsdF9wdXNoX2hhbmRsZXIgPSBTeXMub3BhcXVlX2lkZW50aXR5IChmdW4gXyAtPiBPayAoZnVuIF8gXyAtPiAoKSkpXG5sZXQgaXNfY2xvc2VkIHQgPSBSZWFkZXIuaXNfY2xvc2VkIHQucmVhZGVyICYmIFdyaXRlci5pc19jbG9zZWQgdC53cml0ZXJcbmxldCBzaHV0ZG93bl9yZWFkZXIgdCA9IFJlYWRlci5mb3JjZV9jbG9zZSB0LnJlYWRlclxuXG5sZXQgZmx1c2hfcmVxdWVzdF9ib2R5IHQgPVxuICBTY2hlZHVsZXIuZmx1c2ggdC5zdHJlYW1zICh0LmN1cnJlbnRfc3RyZWFtX2lkLCB0Lm1heF9wdXNoZWRfc3RyZWFtX2lkKVxuXG5sZXQgc2h1dGRvd25fd3JpdGVyIHQgPVxuICBmbHVzaF9yZXF1ZXN0X2JvZHkgdDtcbiAgV3JpdGVyLmNsb3NlIHQud3JpdGVyO1xuICBXcml0ZXIud2FrZXVwIHQud3JpdGVyXG5cbigqIEhhbmRsaW5nIGZyYW1lcyBhZ2FpbnN0IGNsb3NlZCBzdHJlYW1zIGlzIGhhcmQuIFNlZTpcbiAqIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3ByZXNlbnRhdGlvbi9kLzFpR19VMmJLVGM5Q25LcjBqUFRyTmZteHlMdWZ4X2NLMm5OaDlWanJLSDZzXG4gKilcbmxldCB3YXNfY2xvc2VkX29yX2ltcGxpY2l0bHlfY2xvc2VkIHQgc3RyZWFtX2lkID1cbiAgaWYgU3RyZWFtX2lkZW50aWZpZXIuaXNfcmVxdWVzdCBzdHJlYW1faWRcbiAgdGhlbiBTdHJlYW1faWRlbnRpZmllci4oc3RyZWFtX2lkIDw9IHQuY3VycmVudF9zdHJlYW1faWQpXG4gIGVsc2UgU3RyZWFtX2lkZW50aWZpZXIuKHN0cmVhbV9pZCA8PSB0Lm1heF9wdXNoZWRfc3RyZWFtX2lkKVxuXG5sZXQgcmVwb3J0X2Vycm9yID1cbiAgbGV0IHNodXRkb3duX3J3IHQgPVxuICAgIHNodXRkb3duX3JlYWRlciB0O1xuICAgIHNodXRkb3duX3dyaXRlciB0XG4gIGluXG4gIGZ1biB0IGUgLT5cbiAgICBtYXRjaCBlIHdpdGhcbiAgICB8IEVycm9yLkNvbm5lY3Rpb25FcnJvciAoZXJyb3IsIGRhdGEpIC0+XG4gICAgICBpZiBub3QgdC5kaWRfc2VuZF9nb19hd2F5XG4gICAgICB0aGVuIChcbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc1LjQuMTpcbiAgICAgICAgICogICBBbiBlbmRwb2ludCB0aGF0IGVuY291bnRlcnMgYSBjb25uZWN0aW9uIGVycm9yIFNIT1VMRCBmaXJzdCBzZW5kIGFcbiAgICAgICAgICogICBHT0FXQVkgZnJhbWUgKFNlY3Rpb24gNi44KSB3aXRoIHRoZSBzdHJlYW0gaWRlbnRpZmllciBvZiB0aGUgbGFzdFxuICAgICAgICAgKiAgIHN0cmVhbSB0aGF0IGl0IHN1Y2Nlc3NmdWxseSByZWNlaXZlZCBmcm9tIGl0cyBwZWVyLiBUaGUgR09BV0FZIGZyYW1lXG4gICAgICAgICAqICAgaW5jbHVkZXMgYW4gZXJyb3IgY29kZSB0aGF0IGluZGljYXRlcyB3aHkgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICAgICAgICogICB0ZXJtaW5hdGluZy4gQWZ0ZXIgc2VuZGluZyB0aGUgR09BV0FZIGZyYW1lIGZvciBhbiBlcnJvciBjb25kaXRpb24sXG4gICAgICAgICAqICAgdGhlIGVuZHBvaW50IE1VU1QgY2xvc2UgdGhlIFRDUCBjb25uZWN0aW9uLiAqKVxuICAgICAgICBsZXQgZGVidWdfZGF0YSA9XG4gICAgICAgICAgaWYgU3RyaW5nLmxlbmd0aCBkYXRhID0gMFxuICAgICAgICAgIHRoZW4gQmlnc3RyaW5nYWYuZW1wdHlcbiAgICAgICAgICBlbHNlIEJpZ3N0cmluZ2FmLm9mX3N0cmluZyB+b2ZmOjAgfmxlbjooU3RyaW5nLmxlbmd0aCBkYXRhKSBkYXRhXG4gICAgICAgIGluXG4gICAgICAgIGxldCBmcmFtZV9pbmZvID0gV3JpdGVyLm1ha2VfZnJhbWVfaW5mbyBTdHJlYW1faWRlbnRpZmllci5jb25uZWN0aW9uIGluXG4gICAgICAgICgqIFRPRE86IE9ubHkgd3JpdGUgaWYgbm90IGFscmVhZHkgc2h1dGRvd24uICopXG4gICAgICAgIFdyaXRlci53cml0ZV9nb19hd2F5XG4gICAgICAgICAgdC53cml0ZXJcbiAgICAgICAgICBmcmFtZV9pbmZvXG4gICAgICAgICAgfmRlYnVnX2RhdGFcbiAgICAgICAgICB+bGFzdF9zdHJlYW1faWQ6XG4gICAgICAgICAgICAoaWYgU3RyZWFtX2lkZW50aWZpZXIuKHQuY3VycmVudF9zdHJlYW1faWQgPT09IC0xbClcbiAgICAgICAgICAgICB0aGVuIFN0cmVhbV9pZGVudGlmaWVyLmNvbm5lY3Rpb25cbiAgICAgICAgICAgICBlbHNlIHQuY3VycmVudF9zdHJlYW1faWQpXG4gICAgICAgICAgZXJyb3I7XG4gICAgICAgIHQuZGlkX3NlbmRfZ29fYXdheSA8LSB0cnVlO1xuICAgICAgICBpZiBlcnJvciA8PiBFcnJvcl9jb2RlLk5vRXJyb3JcbiAgICAgICAgdGhlbiB0LmVycm9yX2hhbmRsZXIgKGBQcm90b2NvbF9lcnJvciAoZXJyb3IsIGRhdGEpKTtcbiAgICAgICAgV3JpdGVyLmZsdXNoIHQud3JpdGVyIChmdW4gKCkgLT5cbiAgICAgICAgICAoKiBYWFg6IFdlIG5lZWQgdG8gYWxsb3cgbG93ZXIgbnVtYmVyZWQgc3RyZWFtcyB0byBjb21wbGV0ZSBiZWZvcmVcbiAgICAgICAgICAgKiBzaHV0dGluZyBkb3duLiAqKVxuICAgICAgICAgIHNodXRkb3duX3J3IHQpO1xuICAgICAgICBXcml0ZXIud2FrZXVwIHQud3JpdGVyKVxuICAgIHwgU3RyZWFtRXJyb3IgKHN0cmVhbV9pZCwgZXJyb3IpIC0+XG4gICAgICAobWF0Y2ggU2NoZWR1bGVyLmZpbmQgdC5zdHJlYW1zIHN0cmVhbV9pZCB3aXRoXG4gICAgICB8IFNvbWUgcmVzcGQgLT5cbiAgICAgICAgUmVzcGQucmVwb3J0X2Vycm9yIHJlc3BkIChgUHJvdG9jb2xfZXJyb3IgKGVycm9yLCBcIlwiKSkgZXJyb3JcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBpZiBub3QgKHdhc19jbG9zZWRfb3JfaW1wbGljaXRseV9jbG9zZWQgdCBzdHJlYW1faWQpXG4gICAgICAgIHRoZW5cbiAgICAgICAgICAoKiBQb3NzaWJsZSBpZiB0aGUgc3RyZWFtIHdhcyBnb2luZyB0byBlbnRlciB0aGUgSWRsZSBzdGF0ZSAoZmlyc3QgdGltZVxuICAgICAgICAgICAqIHdlIHNhdyBlLmcuIGEgUFJJT1JJVFkgZnJhbWUgZm9yIGl0KSBidXQgaGFkIGUuZy4gYVxuICAgICAgICAgICAqIEZSQU1FX1NJWkVfRVJST1IuICopXG4gICAgICAgICAgbGV0IGZyYW1lX2luZm8gPSBXcml0ZXIubWFrZV9mcmFtZV9pbmZvIHN0cmVhbV9pZCBpblxuICAgICAgICAgIFdyaXRlci53cml0ZV9yc3Rfc3RyZWFtIHQud3JpdGVyIGZyYW1lX2luZm8gZXJyb3IpO1xuICAgICAgV3JpdGVyLndha2V1cCB0LndyaXRlclxuXG5sZXQgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCA/KHJlYXNvbiA9IFwiXCIpIGVycm9yID1cbiAgcmVwb3J0X2Vycm9yIHQgKENvbm5lY3Rpb25FcnJvciAoZXJyb3IsIHJlYXNvbikpXG5cbmxldCByZXBvcnRfc3RyZWFtX2Vycm9yIHQgc3RyZWFtX2lkIGVycm9yID1cbiAgcmVwb3J0X2Vycm9yIHQgKFN0cmVhbUVycm9yIChzdHJlYW1faWQsIGVycm9yKSlcblxubGV0IHNodXRkb3duIHQgPVxuICAoKiBGcm9tIFJGQzc1NDDCpzYuODpcbiAgICogICBBIHNlcnZlciB0aGF0IGlzIGF0dGVtcHRpbmcgdG8gZ3JhY2VmdWxseSBzaHV0IGRvd24gYSBjb25uZWN0aW9uIFNIT1VMRFxuICAgKiAgIHNlbmQgYW4gaW5pdGlhbCBHT0FXQVkgZnJhbWUgd2l0aCB0aGUgbGFzdCBzdHJlYW0gaWRlbnRpZmllciBzZXQgdG9cbiAgICogICAyXjMxLTEgYW5kIGEgTk9fRVJST1IgY29kZS4gKilcbiAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLk5vRXJyb3JcblxubGV0IHNldF9lcnJvcl9hbmRfaGFuZGxlIHQgc3RyZWFtIGVycm9yIGVycm9yX2NvZGUgPVxuICBSZXNwZC5yZXBvcnRfZXJyb3Igc3RyZWFtIGVycm9yIGVycm9yX2NvZGU7XG4gIFdyaXRlci53YWtldXAgdC53cml0ZXJcblxubGV0IHJlcG9ydF9leG4gdCBleG4gPVxuICBpZiBub3QgKGlzX2Nsb3NlZCB0KVxuICB0aGVuXG4gICAgbGV0IHJlYXNvbiA9IFByaW50ZXhjLnRvX3N0cmluZyBleG4gaW5cbiAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IH5yZWFzb24gRXJyb3JfY29kZS5JbnRlcm5hbEVycm9yXG5cbmxldCBzZW5kX3dpbmRvd191cGRhdGUgOlxuICAgIHR5cGUgYS4gdCAtPiBhIFNjaGVkdWxlci5Qcmlvcml0eVRyZWVOb2RlLm5vZGUgLT4gaW50MzIgLT4gdW5pdFxuICA9XG4gZnVuIHQgc3RyZWFtIG4gLT5cbiAgbGV0IHNlbmRfd2luZG93X3VwZGF0ZV9mcmFtZSBzdHJlYW1faWQgbiA9XG4gICAgbGV0IHZhbGlkX2luZmxvdyA9IFNjaGVkdWxlci5hZGRfaW5mbG93IHN0cmVhbSBuIGluXG4gICAgYXNzZXJ0IHZhbGlkX2luZmxvdztcbiAgICBsZXQgZnJhbWVfaW5mbyA9IFdyaXRlci5tYWtlX2ZyYW1lX2luZm8gc3RyZWFtX2lkIGluXG4gICAgV3JpdGVyLndyaXRlX3dpbmRvd191cGRhdGUgdC53cml0ZXIgZnJhbWVfaW5mbyBuXG4gIGluXG4gIGlmIEludDMyLmNvbXBhcmUgbiAwbCA+IDBcbiAgdGhlbiAoXG4gICAgbGV0IG1heF93aW5kb3dfc2l6ZSA9IFNldHRpbmdzLldpbmRvd1NpemUubWF4X3dpbmRvd19zaXplIGluXG4gICAgbGV0IHN0cmVhbV9pZCA9IFNjaGVkdWxlci5zdHJlYW1faWQgc3RyZWFtIGluXG4gICAgbGV0IHJlYyBsb29wIG4gPVxuICAgICAgaWYgbiA+IG1heF93aW5kb3dfc2l6ZVxuICAgICAgdGhlbiAoXG4gICAgICAgIHNlbmRfd2luZG93X3VwZGF0ZV9mcmFtZSBzdHJlYW1faWQgbWF4X3dpbmRvd19zaXplO1xuICAgICAgICBsb29wIChJbnQzMi5zdWIgbiBtYXhfd2luZG93X3NpemUpKVxuICAgICAgZWxzZSBzZW5kX3dpbmRvd191cGRhdGVfZnJhbWUgc3RyZWFtX2lkIG5cbiAgICBpblxuICAgIGxvb3AgbjtcbiAgICBXcml0ZXIud2FrZXVwIHQud3JpdGVyKVxuXG5sZXQgaGFuZGxlX3B1c2hfcHJvbWlzZV9oZWFkZXJzIHQgcmVzcGQgaGVhZGVycyA9XG4gICgqIEZyb20gUkZDNzU0MMKnOC4yLjI6XG4gICAqICAgVGhlIGhlYWRlciBmaWVsZHMgaW4gUFVTSF9QUk9NSVNFIGFuZCBhbnkgc3Vic2VxdWVudCBDT05USU5VQVRJT04gZnJhbWVzXG4gICAqICAgTVVTVCBiZSBhIHZhbGlkIGFuZCBjb21wbGV0ZSBzZXQgb2YgcmVxdWVzdCBoZWFkZXIgZmllbGRzIChTZWN0aW9uXG4gICAqICAgOC4xLjIuMykuICopXG4gIG1hdGNoIEhlYWRlcnMubWV0aG9kX3BhdGhfYW5kX3NjaGVtZV9vcl9tYWxmb3JtZWQgaGVhZGVycyB3aXRoXG4gIHwgYE1hbGZvcm1lZCAtPlxuICAgICgqIEZyb20gUkZDNzU0MMKnOC4yLjI6XG4gICAgICogICBJZiBhIGNsaWVudCByZWNlaXZlcyBhIFBVU0hfUFJPTUlTRSB0aGF0IGRvZXMgbm90IGluY2x1ZGUgYSBjb21wbGV0ZVxuICAgICAqICAgYW5kIHZhbGlkIHNldCBvZiBoZWFkZXIgZmllbGRzIFsuLi5dIGl0IE1VU1QgcmVzcG9uZCB3aXRoIGEgc3RyZWFtXG4gICAgICogICBlcnJvciAoU2VjdGlvbiA1LjQuMikgb2YgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICByZXBvcnRfc3RyZWFtX2Vycm9yIHQgcmVzcGQuU3RyZWFtLmlkIEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuICB8IGBWYWxpZCAobWV0aCwgcGF0aCwgc2NoZW1lKSAtPlxuICAgIGxldCBtZXRoID0gSHR0cGFmLk1ldGhvZC5vZl9zdHJpbmcgbWV0aCBpblxuICAgIChtYXRjaFxuICAgICAgIG1ldGgsIEhlYWRlcnMuZ2V0X3BzZXVkbyBoZWFkZXJzIFwiYXV0aG9yaXR5XCIsIE1lc3NhZ2UuYm9keV9sZW5ndGggaGVhZGVyc1xuICAgICB3aXRoXG4gICAgfCAoI0h0dHBhZi5NZXRob2Quc3RhbmRhcmQgYXMgbWV0aCksIF8sIF9cbiAgICAgIHdoZW4gbm90IEh0dHBhZi5NZXRob2QuKGlzX2NhY2hlYWJsZSBtZXRoICYmIGlzX3NhZmUgbWV0aCkgLT5cbiAgICAgIHJlcG9ydF9zdHJlYW1fZXJyb3IgdCByZXNwZC5pZCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgICB8IF8sIF8sIGBGaXhlZCBsZW4gd2hlbiBub3QgKEludDY0LmVxdWFsIGxlbiAwTCkgLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnOC4yOlxuICAgICAgICogICBDbGllbnRzIHRoYXQgcmVjZWl2ZSBhIHByb21pc2VkIHJlcXVlc3QgdGhhdCBpcyBub3QgY2FjaGVhYmxlLFxuICAgICAgICogICB0aGF0IGlzIG5vdCBrbm93biB0byBiZSBzYWZlIG9yIHRoYXQgaW5kaWNhdGVzIHRoZSBwcmVzZW5jZSBvZiBhXG4gICAgICAgKiAgIHJlcXVlc3QgYm9keSBNVVNUIHJlc2V0IHRoZSBwcm9taXNlZCBzdHJlYW0gd2l0aCBhIHN0cmVhbSBlcnJvclxuICAgICAgICogICAoU2VjdGlvbiA1LjQuMikgb2YgdHlwZSBQUk9UT0NPTF9FUlJPUi5cbiAgICAgICAqXG4gICAgICAgKiBGcm9tIFJGQzcyMzHCpzQuMi4zIChDYWNoZWFibGUgTWV0aG9kcyk6XG4gICAgICAgKiAgIFsuLi5dIHRoaXMgc3BlY2lmaWNhdGlvbiBkZWZpbmVzIEdFVCwgSEVBRCwgYW5kIFBPU1QgYXMgY2FjaGVhYmxlXG4gICAgICAgKiAgIFsuLi5dLlxuICAgICAgICpcbiAgICAgICAqIEZyb20gUkZDNzIzMcKnNC4yLjEgKFNhZmUgTWV0aG9kcyk6XG4gICAgICAgKiAgIE9mIHRoZSByZXF1ZXN0IG1ldGhvZHMgZGVmaW5lZCBieSB0aGlzIHNwZWNpZmljYXRpb24sIHRoZSBHRVQsIEhFQUQsXG4gICAgICAgKiAgIE9QVElPTlMsIGFuZCBUUkFDRSBtZXRob2RzIGFyZSBkZWZpbmVkIHRvIGJlIHNhZmUuXG4gICAgICAgKlxuICAgICAgICogTm90ZTogdGhlIGludGVyc2VjdGlvbiBvZiBzYWZlIGFuZCBjYWNoZWFibGUgYXJlIHRoZSBHRVQgYW5kIEhFQURcbiAgICAgICAqIG1ldGhvZHMuICopXG4gICAgICByZXBvcnRfc3RyZWFtX2Vycm9yIHQgcmVzcGQuaWQgRXJyb3JfY29kZS5Qcm90b2NvbEVycm9yXG4gICAgKCogRnJvbSBSRkM3NTQwwqc4LjI6XG4gICAgICogICBUaGUgc2VydmVyIE1VU1QgaW5jbHVkZSBhIHZhbHVlIGluIHRoZSA6YXV0aG9yaXR5IHBzZXVkby1oZWFkZXIgZmllbGRcbiAgICAgKiAgIGZvciB3aGljaCB0aGUgc2VydmVyIGlzIGF1dGhvcml0YXRpdmUgKHNlZSBTZWN0aW9uIDEwLjEpLiBBIGNsaWVudFxuICAgICAqICAgTVVTVCB0cmVhdCBhIFBVU0hfUFJPTUlTRSBmb3Igd2hpY2ggdGhlIHNlcnZlciBpcyBub3QgYXV0aG9yaXRhdGl2ZSBhc1xuICAgICAqICAgYSBzdHJlYW0gZXJyb3IgKFNlY3Rpb24gNS40LjIpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgfCBfLCBOb25lLCBfIHwgXywgXywgYEVycm9yIF8gLT5cbiAgICAgIHJlcG9ydF9zdHJlYW1fZXJyb3IgdCByZXNwZC5pZCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgICB8IF8gLT5cbiAgICAgIGxldCByZXF1ZXN0ID0gUmVxdWVzdC5jcmVhdGUgfnNjaGVtZSB+aGVhZGVycyBtZXRoIHBhdGggaW5cbiAgICAgIChtYXRjaCB0LnB1c2hfaGFuZGxlciByZXF1ZXN0IHdpdGhcbiAgICAgIHwgT2sgcmVzcG9uc2VfaGFuZGxlciAtPlxuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzguMjpcbiAgICAgICAgICogICBQcm9taXNlZCByZXF1ZXN0cyBbLi4uXSBNVVNUIE5PVCBpbmNsdWRlIGEgcmVxdWVzdCBib2R5LiAqKVxuICAgICAgICBsZXQgcmVxdWVzdF9ib2R5ID0gQm9keS5Xcml0ZXIuY3JlYXRlX2VtcHR5IH53cml0ZXI6dC53cml0ZXIgaW5cbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc1LjE6XG4gICAgICAgICAqICAgcmVzZXJ2ZWQgKHJlbW90ZSk6IFsuLi5dIFJlY2VpdmluZyBhIEhFQURFUlMgZnJhbWUgY2F1c2VzIHRoZVxuICAgICAgICAgKiAgIHN0cmVhbSB0byB0cmFuc2l0aW9uIHRvIFwiaGFsZi1jbG9zZWQgKGxvY2FsKVwiLiAqKVxuICAgICAgICByZXNwZC5zdGF0ZSA8LVxuICAgICAgICAgIEFjdGl2ZVxuICAgICAgICAgICAgKCBIYWxmQ2xvc2VkIFN0cmVhbS5XYWl0aW5nRm9yUGVlclxuICAgICAgICAgICAgLCB7IFJlc3BkLnJlcXVlc3RcbiAgICAgICAgICAgICAgOyByZXF1ZXN0X2JvZHlcbiAgICAgICAgICAgICAgOyByZXNwb25zZV9oYW5kbGVyXG4gICAgICAgICAgICAgIDsgdHJhaWxlcnNfaGFuZGxlciA9IGlnbm9yZVxuICAgICAgICAgICAgICB9IClcbiAgICAgIHwgRXJyb3IgXyAtPlxuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNjpcbiAgICAgICAgICogICBSZWNpcGllbnRzIG9mIFBVU0hfUFJPTUlTRSBmcmFtZXMgY2FuIGNob29zZSB0byByZWplY3QgcHJvbWlzZWRcbiAgICAgICAgICogICBzdHJlYW1zIGJ5IHJldHVybmluZyBhIFJTVF9TVFJFQU0gcmVmZXJlbmNpbmcgdGhlIHByb21pc2VkIHN0cmVhbVxuICAgICAgICAgKiAgIGlkZW50aWZpZXIgYmFjayB0byB0aGUgc2VuZGVyIG9mIHRoZSBQVVNIX1BST01JU0UuICopXG4gICAgICAgIFN0cmVhbS5yZXNldF9zdHJlYW0gcmVzcGQgRXJyb3JfY29kZS5DYW5jZWwpKVxuXG5sZXQgaGFuZGxlX3Jlc3BvbnNlX2hlYWRlcnMgdCBzdHJlYW0gfmVuZF9zdHJlYW0gYWN0aXZlX3JlcXVlc3QgaGVhZGVycyA9XG4gIGxldCAoU2NoZWR1bGVyLlN0cmVhbSB7IGRlc2NyaXB0b3IgPSByZXNwZDsgXyB9KSA9IHN0cmVhbSBpblxuICAoKiBGcm9tIFJGQzc1NDDCpzguMS4yLjY6XG4gICAqICAgQ2xpZW50cyBNVVNUIE5PVCBhY2NlcHQgYSBtYWxmb3JtZWQgcmVzcG9uc2UuXG4gICAqXG4gICAqIE5vdGU6IGluIHRoZSBicmFuY2hlcyB3aGVyZSBhIG1hbGZvcm1lZCByZXNwb25zZSBpcyBkZXRlY3RlZCwgdGhlIHJlc3BvbnNlXG4gICAqIGhhbmRsZXIgaXMgbm90IGNhbGxlZC4gKilcbiAgbWF0Y2ggSGVhZGVycy5nZXRfbXVsdGlfcHNldWRvIGhlYWRlcnMgXCJzdGF0dXNcIiB3aXRoXG4gIHwgWyBzdGF0dXMgXSAtPlxuICAgIGxldCByZXNwb25zZSA9IFJlc3BvbnNlLmNyZWF0ZSB+aGVhZGVycyAoU3RhdHVzLm9mX3N0cmluZyBzdGF0dXMpIGluXG4gICAgKCogTm90ZTogd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgYGVuZF9zdHJlYW1gIGZsYWcgKyBhIG5vbi16ZXJvIGJvZHlcbiAgICAgKiBsZW5ndGgsIGFzIHRoZSBzcGVjIGFsbG93cyBmb3Igbm9uLXplcm8gY29udGVudC1sZW5ndGggaGVhZGVycyBhbmQgbm9cbiAgICAgKiBEQVRBIGZyYW1lcy5cbiAgICAgKlxuICAgICAqIEZyb20gUkZDNzU0MMKnOC4xLjIuNjpcbiAgICAgKiAgIEEgcmVzcG9uc2UgdGhhdCBpcyBkZWZpbmVkIHRvIGhhdmUgbm8gcGF5bG9hZCwgYXMgZGVzY3JpYmVkIGluXG4gICAgICogICBbUkZDNzIzMF0sIFNlY3Rpb24gMy4zLjIsIGNhbiBoYXZlIGEgbm9uLXplcm8gY29udGVudC1sZW5ndGggaGVhZGVyXG4gICAgICogICBmaWVsZCwgZXZlbiB0aG91Z2ggbm8gY29udGVudCBpcyBpbmNsdWRlZCBpbiBEQVRBIGZyYW1lcy4gKilcbiAgICAobWF0Y2ggTWVzc2FnZS5ib2R5X2xlbmd0aCBoZWFkZXJzIHdpdGhcbiAgICB8IGBFcnJvciBfIC0+XG4gICAgICBzZXRfZXJyb3JfYW5kX2hhbmRsZVxuICAgICAgICB0XG4gICAgICAgIHJlc3BkXG4gICAgICAgIChgSW52YWxpZF9yZXNwb25zZV9ib2R5X2xlbmd0aCByZXNwb25zZSlcbiAgICAgICAgUHJvdG9jb2xFcnJvclxuICAgIHwgYEZpeGVkIF8gfCBgVW5rbm93biAtPlxuICAgICAgbGV0IHJlc3BvbnNlX2JvZHkgPVxuICAgICAgICBpZiBlbmRfc3RyZWFtXG4gICAgICAgIHRoZW4gQm9keS5SZWFkZXIuZW1wdHlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIEJvZHkuUmVhZGVyLmNyZWF0ZVxuICAgICAgICAgICAgKEJpZ3N0cmluZ2FmLmNyZWF0ZSB0LmNvbmZpZy5yZXNwb25zZV9ib2R5X2J1ZmZlcl9zaXplKVxuICAgICAgICAgICAgfmRvbmVfcmVhZGluZzooZnVuIGxlbiAtPlxuICAgICAgICAgICAgICBsZXQgbGVuID0gSW50MzIub2ZfaW50IGxlbiBpblxuICAgICAgICAgICAgICBzZW5kX3dpbmRvd191cGRhdGUgdCB0LnN0cmVhbXMgbGVuO1xuICAgICAgICAgICAgICBzZW5kX3dpbmRvd191cGRhdGUgdCBzdHJlYW0gbGVuKVxuICAgICAgaW5cbiAgICAgIGxldCBuZXdfcmVzcG9uc2Vfc3RhdGUgPVxuICAgICAgICBSZXNwZC5jcmVhdGVfYWN0aXZlX3Jlc3BvbnNlIHJlc3BvbnNlIHJlc3BvbnNlX2JvZHlcbiAgICAgIGluXG4gICAgICByZXNwZC5zdGF0ZSA8LVxuICAgICAgICBBY3RpdmVcbiAgICAgICAgICAoIChpZiBTdHJlYW0uaXNfb3BlbiByZXNwZFxuICAgICAgICAgICAgIHRoZW4gT3BlbiBuZXdfcmVzcG9uc2Vfc3RhdGVcbiAgICAgICAgICAgICBlbHNlIEhhbGZDbG9zZWQgbmV3X3Jlc3BvbnNlX3N0YXRlKVxuICAgICAgICAgICwgYWN0aXZlX3JlcXVlc3QgKTtcbiAgICAgIGFjdGl2ZV9yZXF1ZXN0LnJlc3BvbnNlX2hhbmRsZXIgcmVzcG9uc2UgcmVzcG9uc2VfYm9keTtcbiAgICAgIGlmIGVuZF9zdHJlYW1cbiAgICAgIHRoZW4gKFxuICAgICAgICAoKiBEZWxpdmVyIEVPRiB0byB0aGUgcmVzcG9uc2UgYm9keSwgYXMgdGhlIGhhbmRsZXIgbWlnaHQgYmUgd2FpdGluZ1xuICAgICAgICAgKiBvbiBpdCB0byBhY3QuICopXG4gICAgICAgIEJvZHkuUmVhZGVyLmNsb3NlIHJlc3BvbnNlX2JvZHk7XG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4xOlxuICAgICAgICAgKiAgIFsuLi5dIGFuIGVuZHBvaW50IHJlY2VpdmluZyBhbiBFTkRfU1RSRUFNIGZsYWcgY2F1c2VzIHRoZSBzdHJlYW1cbiAgICAgICAgICogICBzdGF0ZSB0byBiZWNvbWUgXCJoYWxmLWNsb3NlZCAocmVtb3RlKVwiLiAqKVxuICAgICAgICBSZXNwZC5jbG9zZV9zdHJlYW0gcmVzcGQpKVxuICB8IF8gLT5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzguMS4yLjQ6XG4gICAgICogICBGb3IgSFRUUC8yIHJlc3BvbnNlcywgYSBzaW5nbGUgOnN0YXR1cyBwc2V1ZG8taGVhZGVyIGZpZWxkIGlzIGRlZmluZWRcbiAgICAgKiAgIHRoYXQgY2FycmllcyB0aGUgSFRUUCBzdGF0dXMgY29kZSBmaWVsZCAoc2VlIFtSRkM3MjMxXSwgU2VjdGlvbiA2KS5cbiAgICAgKiAgIFRoaXMgcHNldWRvLWhlYWRlciBmaWVsZCBNVVNUIGJlIGluY2x1ZGVkIGluIGFsbCByZXNwb25zZXM7IG90aGVyd2lzZSxcbiAgICAgKiAgIHRoZSByZXNwb25zZSBpcyBtYWxmb3JtZWQgKFNlY3Rpb24gOC4xLjIuNikuICopXG4gICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgXCJIVFRQLzIgcmVzcG9uc2VzIG11c3QgaW5jbHVkZSBhIHNpbmdsZSBgOnN0YXR1c2AgcHNldWRvLWhlYWRlclwiXG4gICAgaW5cbiAgICBzZXRfZXJyb3JfYW5kX2hhbmRsZSB0IHJlc3BkIChgTWFsZm9ybWVkX3Jlc3BvbnNlIG1lc3NhZ2UpIFByb3RvY29sRXJyb3JcblxubGV0IGhhbmRsZV9oZWFkZXJzIHQgfmVuZF9zdHJlYW0gc3RyZWFtIGhlYWRlcnMgPVxuICBsZXQgKFNjaGVkdWxlci5TdHJlYW0geyBkZXNjcmlwdG9yID0gcmVzcGQ7IF8gfSkgPSBzdHJlYW0gaW5cbiAgKCogRnJvbSBSRkM3NTQwwqc1LjEuMjpcbiAgICogICBFbmRwb2ludHMgTVVTVCBOT1QgZXhjZWVkIHRoZSBsaW1pdCBzZXQgYnkgdGhlaXIgcGVlci4gQW4gZW5kcG9pbnQgdGhhdFxuICAgKiAgIHJlY2VpdmVzIGEgSEVBREVSUyBmcmFtZSB0aGF0IGNhdXNlcyBpdHMgYWR2ZXJ0aXNlZCBjb25jdXJyZW50IHN0cmVhbVxuICAgKiAgIGxpbWl0IHRvIGJlIGV4Y2VlZGVkIE1VU1QgdHJlYXQgdGhpcyBhcyBhIHN0cmVhbSBlcnJvciAoU2VjdGlvbiA1LjQuMilcbiAgICogICBvZiB0eXBlIFBST1RPQ09MX0VSUk9SIG9yIFJFRlVTRURfU1RSRUFNLiAqKVxuICBpZiBJbnQzMi4oXG4gICAgICAgY29tcGFyZVxuICAgICAgICAgKG9mX2ludCAodC5jdXJyZW50X3NlcnZlcl9zdHJlYW1zICsgMSkpXG4gICAgICAgICB0LmNvbmZpZy5tYXhfY29uY3VycmVudF9zdHJlYW1zKVxuICAgICA+IDBcbiAgdGhlblxuICAgIGlmIHQudW5hY2tlZF9zZXR0aW5ncyA+IDBcbiAgICB0aGVuXG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzguMS40OlxuICAgICAgICogICBUaGUgUkVGVVNFRF9TVFJFQU0gZXJyb3IgY29kZSBjYW4gYmUgaW5jbHVkZWQgaW4gYSBSU1RfU1RSRUFNIGZyYW1lXG4gICAgICAgKiAgIHRvIGluZGljYXRlIHRoYXQgdGhlIHN0cmVhbSBpcyBiZWluZyBjbG9zZWQgcHJpb3IgdG8gYW55IHByb2Nlc3NpbmdcbiAgICAgICAqICAgaGF2aW5nIG9jY3VycmVkLiBBbnkgcmVxdWVzdCB0aGF0IHdhcyBzZW50IG9uIHRoZSByZXNldCBzdHJlYW0gY2FuXG4gICAgICAgKiAgIGJlIHNhZmVseSByZXRyaWVkLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IGlmIHRoZXJlIGFyZSBwZW5kaW5nIFNFVFRJTkdTIHRvIGFja25vd2xlZGdlLCBhc3N1bWUgdGhlcmUgd2FzIGFcbiAgICAgICAqIHJhY2UgY29uZGl0aW9uIGFuZCBsZXQgdGhlIGNsaWVudCByZXRyeS4gKilcbiAgICAgIHJlcG9ydF9zdHJlYW1fZXJyb3IgdCByZXNwZC5TdHJlYW0uaWQgRXJyb3JfY29kZS5SZWZ1c2VkU3RyZWFtXG4gICAgZWxzZSByZXBvcnRfc3RyZWFtX2Vycm9yIHQgcmVzcGQuU3RyZWFtLmlkIEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuICBlbHNlIChcbiAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMS4yOlxuICAgICAqICAgU3RyZWFtcyB0aGF0IGFyZSBpbiB0aGUgXCJvcGVuXCIgc3RhdGUgb3IgaW4gZWl0aGVyIG9mIHRoZSBcImhhbGYtY2xvc2VkXCJcbiAgICAgKiAgIHN0YXRlcyBjb3VudCB0b3dhcmQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0cmVhbXMgdGhhdCBhbiBlbmRwb2ludCBpc1xuICAgICAqICAgcGVybWl0dGVkIHRvIG9wZW4uICopXG4gICAgdC5jdXJyZW50X3NlcnZlcl9zdHJlYW1zIDwtIHQuY3VycmVudF9zZXJ2ZXJfc3RyZWFtcyArIDE7XG4gICAgbWF0Y2ggcmVzcGQuc3RhdGUgd2l0aFxuICAgIHwgUmVzZXJ2ZWQgXyAtPlxuICAgICAgcmVzcGQuc3RhdGUgPC0gUmVzZXJ2ZWQgU3RyZWFtLkZ1bGxIZWFkZXJzO1xuICAgICAgaGFuZGxlX3B1c2hfcHJvbWlzZV9oZWFkZXJzIHQgcmVzcGQgaGVhZGVyc1xuICAgIHwgQWN0aXZlIChhY3RpdmVfc3RhdGUsIGFjdGl2ZV9yZXF1ZXN0KSAtPlxuICAgICAgKG1hdGNoIGFjdGl2ZV9zdGF0ZSB3aXRoXG4gICAgICB8IE9wZW4gXyAtPiByZXNwZC5zdGF0ZSA8LSBBY3RpdmUgKE9wZW4gRnVsbEhlYWRlcnMsIGFjdGl2ZV9yZXF1ZXN0KVxuICAgICAgfCBIYWxmQ2xvc2VkIF8gLT5cbiAgICAgICAgcmVzcGQuc3RhdGUgPC0gQWN0aXZlIChIYWxmQ2xvc2VkIEZ1bGxIZWFkZXJzLCBhY3RpdmVfcmVxdWVzdCkpO1xuICAgICAgaGFuZGxlX3Jlc3BvbnNlX2hlYWRlcnMgdCBzdHJlYW0gfmVuZF9zdHJlYW0gYWN0aXZlX3JlcXVlc3QgaGVhZGVyc1xuICAgIHwgXyAtPlxuICAgICAgKCogVW5yZWFjaGFibGUuIFRoaXMgZnVuY3Rpb24gaXMgb25seSBpbnZva2VkIGlmIHRoZSBzdHJlYW0gaXMgYWN0aXZlLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlKVxuXG5sZXQgaGFuZGxlX2hlYWRlcnNfYmxvY2tcbiAgICB0XG4gICAgPyhpc190cmFpbGVycyA9IGZhbHNlKVxuICAgIHN0cmVhbVxuICAgIHBhcnRpYWxfaGVhZGVyc1xuICAgIGZsYWdzXG4gICAgaGVhZGVyc19ibG9ja1xuICA9XG4gIGxldCBvcGVuIEFCIGluXG4gIGxldCAoU2NoZWR1bGVyLlN0cmVhbSB7IGRlc2NyaXB0b3IgPSByZXNwZDsgXyB9KSA9IHN0cmVhbSBpblxuICBsZXQgZW5kX2hlYWRlcnMgPSBGbGFncy50ZXN0X2VuZF9oZWFkZXIgZmxhZ3MgaW5cbiAgKCogRnJvbSBSRkM3NTQwwqc2LjEwOlxuICAgKiAgIEFuIGVuZHBvaW50IHJlY2VpdmluZyBIRUFERVJTLCBQVVNIX1BST01JU0UsIG9yIENPTlRJTlVBVElPTlxuICAgKiAgIGZyYW1lcyBuZWVkcyB0byByZWFzc2VtYmxlIGhlYWRlciBibG9ja3MgYW5kIHBlcmZvcm0gZGVjb21wcmVzc2lvblxuICAgKiAgIGV2ZW4gaWYgdGhlIGZyYW1lcyBhcmUgdG8gYmUgZGlzY2FyZGVkICopXG4gIGxldCBwYXJzZV9zdGF0ZScgPVxuICAgIEFCLmZlZWQgcGFydGlhbF9oZWFkZXJzLlN0cmVhbS5wYXJzZV9zdGF0ZSAoYEJpZ3N0cmluZyBoZWFkZXJzX2Jsb2NrKVxuICBpblxuICBpZiBlbmRfaGVhZGVyc1xuICB0aGVuIChcbiAgICB0LnJlY2VpdmluZ19oZWFkZXJzX2Zvcl9zdHJlYW0gPC0gTm9uZTtcbiAgICBsZXQgcGFyc2Vfc3RhdGUnID0gQUIuZmVlZCBwYXJzZV9zdGF0ZScgYEVvZiBpblxuICAgIG1hdGNoIHBhcnNlX3N0YXRlJyB3aXRoXG4gICAgfCBEb25lIChfLCBPayBoZWFkZXJzKSAtPlxuICAgICAgaWYgbm90IGlzX3RyYWlsZXJzXG4gICAgICB0aGVuXG4gICAgICAgICgqIGBoYW5kbGVfaGVhZGVyc2Agd2lsbCB0YWtlIGNhcmUgb2YgdHJhbnNpdGlvbmluZyB0aGUgc3RyZWFtIHN0YXRlICopXG4gICAgICAgIGxldCBlbmRfc3RyZWFtID0gcGFydGlhbF9oZWFkZXJzLmVuZF9zdHJlYW0gaW5cbiAgICAgICAgaGFuZGxlX2hlYWRlcnMgdCB+ZW5kX3N0cmVhbSBzdHJlYW0gaGVhZGVyc1xuICAgICAgZWxzZSBpZiBIZWFkZXJzLnRyYWlsZXJzX3ZhbGlkIGhlYWRlcnNcbiAgICAgIHRoZW4gKFxuICAgICAgICBSZXNwZC5kZWxpdmVyX3RyYWlsZXJfaGVhZGVycyByZXNwZCBoZWFkZXJzO1xuICAgICAgICBsZXQgcmVzcG9uc2VfYm9keSA9IFJlc3BkLnJlc3BvbnNlX2JvZHlfZXhuIHJlc3BkIGluXG4gICAgICAgIEJvZHkuUmVhZGVyLmNsb3NlIHJlc3BvbnNlX2JvZHkpXG4gICAgICBlbHNlXG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnOC4xLjIuMTpcbiAgICAgICAgICogICBQc2V1ZG8taGVhZGVyIGZpZWxkcyBNVVNUIE5PVCBhcHBlYXIgaW4gdHJhaWxlcnMuIEVuZHBvaW50cyBNVVNUXG4gICAgICAgICAqICAgdHJlYXQgYSByZXF1ZXN0IG9yIHJlc3BvbnNlIHRoYXQgY29udGFpbnMgdW5kZWZpbmVkIG9yIGludmFsaWRcbiAgICAgICAgICogICBwc2V1ZG8taGVhZGVyIGZpZWxkcyBhcyBtYWxmb3JtZWQgKFNlY3Rpb24gOC4xLjIuNikuICopXG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJQc2V1ZG8taGVhZGVyIGZpZWxkcyBtdXN0IG5vdCBhcHBlYXIgaW4gdHJhaWxlcnNcIiBpblxuICAgICAgICBzZXRfZXJyb3JfYW5kX2hhbmRsZSB0IHJlc3BkIChgTWFsZm9ybWVkX3Jlc3BvbnNlIG1lc3NhZ2UpIFByb3RvY29sRXJyb3JcbiAgICAoKiBGcm9tIFJGQzc1NDDCpzQuMzpcbiAgICAgKiAgIEEgZGVjb2RpbmcgZXJyb3IgaW4gYSBoZWFkZXIgYmxvY2sgTVVTVCBiZSB0cmVhdGVkIGFzIGEgY29ubmVjdGlvblxuICAgICAqICAgZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgQ09NUFJFU1NJT05fRVJST1IuICopXG4gICAgfCBEb25lIChfLCBFcnJvciBfKSB8IFBhcnRpYWwgXyAtPlxuICAgICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLkNvbXByZXNzaW9uRXJyb3JcbiAgICB8IEZhaWwgKF8sIF8sIG1lc3NhZ2UpIC0+XG4gICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IH5yZWFzb246bWVzc2FnZSBFcnJvcl9jb2RlLkNvbXByZXNzaW9uRXJyb3IpXG4gIGVsc2UgcGFydGlhbF9oZWFkZXJzLnBhcnNlX3N0YXRlIDwtIHBhcnNlX3N0YXRlJ1xuXG5sZXQgaGFuZGxlX3RyYWlsZXJfaGVhZGVycyA9IGhhbmRsZV9oZWFkZXJzX2Jsb2NrIH5pc190cmFpbGVyczp0cnVlXG5cbmxldCBjcmVhdGVfcGFydGlhbF9oZWFkZXJzIHQgZmxhZ3MgaGVhZGVyc19ibG9jayA9XG4gIGxldCBlbmRfaGVhZGVycyA9IEZsYWdzLnRlc3RfZW5kX2hlYWRlciBmbGFncyBpblxuICBsZXQgaGVhZGVyc19ibG9ja19sZW5ndGggPSBCaWdzdHJpbmdhZi5sZW5ndGggaGVhZGVyc19ibG9jayBpblxuICBsZXQgaW5pdGlhbF9idWZmZXJfc2l6ZSA9XG4gICAgaWYgZW5kX2hlYWRlcnNcbiAgICB0aGVuIGhlYWRlcnNfYmxvY2tfbGVuZ3RoXG4gICAgZWxzZVxuICAgICAgKCogQ29uc2VydmF0aXZlIGVzdGltYXRlIHRoYXQgdGhlcmUncyBvbmx5IGdvaW5nIHRvIGJlIG9uZSBDT05USU5VQVRJT05cbiAgICAgICAqIGZyYW1lLiAqKVxuICAgICAgMiAqIGhlYWRlcnNfYmxvY2tfbGVuZ3RoXG4gIGluXG4gIHsgU3RyZWFtLnBhcnNlX3N0YXRlID1cbiAgICAgIEFCLnBhcnNlXG4gICAgICAgIH5pbml0aWFsX2J1ZmZlcl9zaXplXG4gICAgICAgIChIcGFjay5EZWNvZGVyLmRlY29kZV9oZWFkZXJzIHQuaHBhY2tfZGVjb2RlcilcbiAgOyBlbmRfc3RyZWFtID0gRmxhZ3MudGVzdF9lbmRfc3RyZWFtIGZsYWdzXG4gIH1cblxubGV0IGhhbmRsZV9maXJzdF9yZXNwb25zZV9ieXRlc1xuICAgIHRcbiAgICBzdHJlYW1cbiAgICBhY3RpdmVfcmVxdWVzdFxuICAgIGZyYW1lX2hlYWRlclxuICAgIGhlYWRlcnNfYmxvY2tcbiAgPVxuICBsZXQgKFNjaGVkdWxlci5TdHJlYW0geyBkZXNjcmlwdG9yOyBfIH0pID0gc3RyZWFtIGluXG4gIGxldCB7IEZyYW1lLmZsYWdzOyBzdHJlYW1faWQ7IF8gfSA9IGZyYW1lX2hlYWRlciBpblxuICBsZXQgcGFydGlhbF9oZWFkZXJzID0gY3JlYXRlX3BhcnRpYWxfaGVhZGVycyB0IGZsYWdzIGhlYWRlcnNfYmxvY2sgaW5cbiAgbGV0IHJlbW90ZV9zdGF0ZSA9IFN0cmVhbS5QYXJ0aWFsSGVhZGVycyBwYXJ0aWFsX2hlYWRlcnMgaW5cbiAgZGVzY3JpcHRvci5TdHJlYW0uc3RhdGUgPC1cbiAgICAoaWYgU3RyZWFtLmlzX29wZW4gZGVzY3JpcHRvclxuICAgICB0aGVuIEFjdGl2ZSAoT3BlbiByZW1vdGVfc3RhdGUsIGFjdGl2ZV9yZXF1ZXN0KVxuICAgICBlbHNlIEFjdGl2ZSAoSGFsZkNsb3NlZCByZW1vdGVfc3RhdGUsIGFjdGl2ZV9yZXF1ZXN0KSk7XG4gIGlmIG5vdCAoRmxhZ3MudGVzdF9lbmRfaGVhZGVyIGZsYWdzKVxuICB0aGVuIHQucmVjZWl2aW5nX2hlYWRlcnNfZm9yX3N0cmVhbSA8LSBTb21lIHN0cmVhbV9pZDtcbiAgaGFuZGxlX2hlYWRlcnNfYmxvY2sgdCBzdHJlYW0gcGFydGlhbF9oZWFkZXJzIGZsYWdzIGhlYWRlcnNfYmxvY2tcblxubGV0IHByb2Nlc3NfdHJhaWxlcl9oZWFkZXJzIHQgc3RyZWFtIGFjdGl2ZV9yZXNwb25zZSBmcmFtZV9oZWFkZXIgaGVhZGVyc19ibG9jayA9XG4gIGxldCAoU2NoZWR1bGVyLlN0cmVhbSB7IGRlc2NyaXB0b3IgPSByZXNwZDsgXyB9KSA9IHN0cmVhbSBpblxuICBsZXQgeyBGcmFtZS5zdHJlYW1faWQ7IGZsYWdzOyBfIH0gPSBmcmFtZV9oZWFkZXIgaW5cbiAgbGV0IGVuZF9zdHJlYW0gPSBGbGFncy50ZXN0X2VuZF9zdHJlYW0gZmxhZ3MgaW5cbiAgaWYgbm90IGVuZF9zdHJlYW1cbiAgdGhlblxuICAgICgqIEZyb20gUkZDNzU0MMKnOC4xOlxuICAgICAqICAgQSBIRUFERVJTIGZyYW1lIChhbmQgYXNzb2NpYXRlZCBDT05USU5VQVRJT04gZnJhbWVzKSBjYW4gb25seSBhcHBlYXJcbiAgICAgKiAgIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBzdHJlYW0uIEFuIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgYSBIRUFERVJTXG4gICAgICogICBmcmFtZSB3aXRob3V0IHRoZSBFTkRfU1RSRUFNIGZsYWcgc2V0IGFmdGVyIHJlY2VpdmluZyBhIGZpbmFsXG4gICAgICogICAobm9uLWluZm9ybWF0aW9uYWwpIHN0YXR1cyBjb2RlIE1VU1QgdHJlYXQgdGhlIGNvcnJlc3BvbmRpbmcgcmVxdWVzdFxuICAgICAqICAgb3IgcmVzcG9uc2UgYXMgbWFsZm9ybWVkIChTZWN0aW9uIDguMS4yLjYpLiAqKVxuICAgIGxldCBtZXNzYWdlID1cbiAgICAgIFwiSEVBREVSUyBmcmFtZXMgY29udGFpbmluZyB0cmFpbGVycyBtdXN0IHNldCB0aGUgRU5EX1NUUkVBTSBmbGFnXCJcbiAgICBpblxuICAgIHNldF9lcnJvcl9hbmRfaGFuZGxlIHQgcmVzcGQgKGBNYWxmb3JtZWRfcmVzcG9uc2UgbWVzc2FnZSkgUHJvdG9jb2xFcnJvclxuICBlbHNlXG4gICAgbGV0IHBhcnRpYWxfaGVhZGVycyA9XG4gICAgICB7IFN0cmVhbS5wYXJzZV9zdGF0ZSA9XG4gICAgICAgICAgQUIucGFyc2UgKEhwYWNrLkRlY29kZXIuZGVjb2RlX2hlYWRlcnMgdC5ocGFja19kZWNvZGVyKVxuICAgICAgICAgICgqIG9idmlvdXNseSB0cnVlIGF0IHRoaXMgcG9pbnQuICopXG4gICAgICA7IGVuZF9zdHJlYW1cbiAgICAgIH1cbiAgICBpblxuICAgIGFjdGl2ZV9yZXNwb25zZS5SZXNwZC50cmFpbGVyc19wYXJzZXIgPC0gU29tZSBwYXJ0aWFsX2hlYWRlcnM7XG4gICAgaWYgbm90IEZsYWdzLih0ZXN0X2VuZF9oZWFkZXIgZmxhZ3MpXG4gICAgdGhlbiB0LnJlY2VpdmluZ19oZWFkZXJzX2Zvcl9zdHJlYW0gPC0gU29tZSBzdHJlYW1faWQ7XG4gICAgKCogdHJhaWxlciBoZWFkZXJzOiBSRkM3MjMwwqc0LjQgKilcbiAgICBoYW5kbGVfdHJhaWxlcl9oZWFkZXJzIHQgc3RyZWFtIHBhcnRpYWxfaGVhZGVycyBmbGFncyBoZWFkZXJzX2Jsb2NrXG5cbmxldCBwcm9jZXNzX2hlYWRlcnNfZnJhbWUgdCB7IEZyYW1lLmZyYW1lX2hlYWRlcjsgXyB9IGhlYWRlcnNfYmxvY2sgPVxuICBsZXQgeyBGcmFtZS5zdHJlYW1faWQ7IF8gfSA9IGZyYW1lX2hlYWRlciBpblxuICBtYXRjaCBTY2hlZHVsZXIuZ2V0X25vZGUgdC5zdHJlYW1zIHN0cmVhbV9pZCB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICgqIElmIHdlJ3JlIHJlY2VpdmluZyBhIHJlc3BvbnNlIGZvciBhIHN0cmVhbSB0aGF0J3Mgbm8gbG9uZ2VyIGluIHRoZVxuICAgICAqIHByaW9yaXR5IHRyZWUsIGFzc3VtZSB0aGlzIGlzIGEgbmV0d29yayByYWNlIC0gd2UgY2FuY2VsZWQgYSByZXF1ZXN0XG4gICAgICogYnV0IGEgcmVzcG9ubnNlIHdhcyBhbHJlYWR5IGluIGZsaWdodC5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIGlmIHRoZSBzdHJlYW0gaWRlbnRpZmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGFyZ2VzdCBzdHJlYW1cbiAgICAgKiBpZGVudGlmaWVyIHdlIGhhdmUgcHJvZHVjZWQsIHRoZXkgc2hvdWxkIGtub3cgYmV0dGVyLiBJbiB0aGlzIGNhc2UsXG4gICAgICogc2VuZCBhbiBSU1RfU1RSRUFNLiAqKVxuICAgIGlmIFN0cmVhbV9pZGVudGlmaWVyLihcbiAgICAgICAgIHN0cmVhbV9pZCA+PSB0LmN1cnJlbnRfc3RyZWFtX2lkICYmIGlzX3JlcXVlc3Qgc3RyZWFtX2lkKVxuICAgIHRoZW4gcmVwb3J0X3N0cmVhbV9lcnJvciB0IHN0cmVhbV9pZCBFcnJvcl9jb2RlLlN0cmVhbUNsb3NlZFxuICB8IFNvbWUgKFNjaGVkdWxlci5TdHJlYW0geyBkZXNjcmlwdG9yOyBfIH0gYXMgc3RyZWFtKSAtPlxuICAgIChtYXRjaCBkZXNjcmlwdG9yLnN0YXRlIHdpdGhcbiAgICB8IElkbGUgLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnNi4yOlxuICAgICAgICogICBIRUFERVJTIGZyYW1lcyBjYW4gYmUgc2VudCBvbiBhIHN0cmVhbSBpbiB0aGUgXCJpZGxlXCIsIFwicmVzZXJ2ZWRcbiAgICAgICAqICAgKGxvY2FsKVwiLCBcIm9wZW5cIiwgb3IgXCJoYWxmLWNsb3NlZCAocmVtb3RlKVwiIHN0YXRlLiAqKVxuICAgICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgICB8IEFjdGl2ZSAoKE9wZW4gV2FpdGluZ0ZvclBlZXIgfCBIYWxmQ2xvc2VkIFdhaXRpbmdGb3JQZWVyKSwgYWN0aXZlX3JlcXVlc3QpXG4gICAgICAtPlxuICAgICAgaGFuZGxlX2ZpcnN0X3Jlc3BvbnNlX2J5dGVzXG4gICAgICAgIHRcbiAgICAgICAgc3RyZWFtXG4gICAgICAgIGFjdGl2ZV9yZXF1ZXN0XG4gICAgICAgIGZyYW1lX2hlYWRlclxuICAgICAgICBoZWFkZXJzX2Jsb2NrXG4gICAgfCBBY3RpdmVcbiAgICAgICAgKCAoIE9wZW4gKEZ1bGxIZWFkZXJzIHwgUGFydGlhbEhlYWRlcnMgXylcbiAgICAgICAgICB8IEhhbGZDbG9zZWQgKEZ1bGxIZWFkZXJzIHwgUGFydGlhbEhlYWRlcnMgXykgKVxuICAgICAgICAsIF8gKSAtPlxuICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgKCogaWYgd2UncmUgZ2V0dGluZyBhIEhFQURFUlMgZnJhbWUgYXQgdGhpcyBwb2ludCwgdGhleSBtdXN0IGJlXG4gICAgICogdHJhaWxlcnMsIGFuZCB0aGUgRU5EX1NUUkVBTSBmbGFnIG5lZWRzIHRvIGJlIHNldC4gKilcbiAgICB8IEFjdGl2ZVxuICAgICAgICAoICggT3BlbiAoQWN0aXZlTWVzc2FnZSBhY3RpdmVfcmVzcG9uc2UpXG4gICAgICAgICAgfCBIYWxmQ2xvc2VkIChBY3RpdmVNZXNzYWdlIGFjdGl2ZV9yZXNwb25zZSkgKVxuICAgICAgICAsIF8gKSAtPlxuICAgICAgcHJvY2Vzc190cmFpbGVyX2hlYWRlcnNcbiAgICAgICAgdFxuICAgICAgICBzdHJlYW1cbiAgICAgICAgYWN0aXZlX3Jlc3BvbnNlXG4gICAgICAgIGZyYW1lX2hlYWRlclxuICAgICAgICBoZWFkZXJzX2Jsb2NrO1xuICAgICAgU3RyZWFtLmZpbmlzaF9zdHJlYW0gZGVzY3JpcHRvciBGaW5pc2hlZFxuICAgIHwgQ2xvc2VkIHsgcmVhc29uID0gUmVzZXRCeVRoZW0gXzsgXyB9IC0+XG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgICAqICAgY2xvc2VkOiBbLi4uXSBBbiBlbmRwb2ludCB0aGF0IHJlY2VpdmVzIGFueSBmcmFtZSBvdGhlciB0aGFuXG4gICAgICAgKiAgIFBSSU9SSVRZIGFmdGVyIHJlY2VpdmluZyBhIFJTVF9TVFJFQU0gTVVTVCB0cmVhdCB0aGF0IGFzIGFcbiAgICAgICAqICAgc3RyZWFtIGVycm9yIChTZWN0aW9uIDUuNC4yKSBvZiB0eXBlIFNUUkVBTV9DTE9TRUQuICopXG4gICAgICByZXBvcnRfc3RyZWFtX2Vycm9yIHQgc3RyZWFtX2lkIEVycm9yX2NvZGUuU3RyZWFtQ2xvc2VkXG4gICAgKCogRnJvbSBSRkM3NTQwwqc1LjE6XG4gICAgICogICByZXNlcnZlZCAobG9jYWwpOiBbLi4uXSBSZWNlaXZpbmcgYW55IHR5cGUgb2YgZnJhbWUgb3RoZXIgdGhhblxuICAgICAqICAgUlNUX1NUUkVBTSwgUFJJT1JJVFksIG9yIFdJTkRPV19VUERBVEUgb24gYSBzdHJlYW0gaW4gdGhpcyBzdGF0ZVxuICAgICAqICAgTVVTVCBiZSB0cmVhdGVkIGFzIGEgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZVxuICAgICAqICAgUFJPVE9DT0xfRVJST1IuICopXG4gICAgfCBSZXNlcnZlZCBfIHwgQ2xvc2VkIF8gLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4xOlxuICAgICAgICogICBTaW1pbGFybHksIGFuIGVuZHBvaW50IHRoYXQgcmVjZWl2ZXMgYW55IGZyYW1lcyBhZnRlciByZWNlaXZpbmdcbiAgICAgICAqICAgYSBmcmFtZSB3aXRoIHRoZSBFTkRfU1RSRUFNIGZsYWcgc2V0IE1VU1QgdHJlYXQgdGhhdCBhcyBhXG4gICAgICAgKiAgIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgU1RSRUFNX0NMT1NFRCBbLi4uXS4gKilcbiAgICAgIHJlcG9ydF9jb25uZWN0aW9uX2Vycm9yIHQgRXJyb3JfY29kZS5TdHJlYW1DbG9zZWQpXG5cbmxldCBwcm9jZXNzX2RhdGFfZnJhbWUgdCB7IEZyYW1lLmZyYW1lX2hlYWRlcjsgXyB9IGJzdHIgPVxuICBsZXQgb3BlbiBTY2hlZHVsZXIgaW5cbiAgbGV0IHsgRnJhbWUuZmxhZ3M7IHN0cmVhbV9pZDsgcGF5bG9hZF9sZW5ndGg7IF8gfSA9IGZyYW1lX2hlYWRlciBpblxuICBsZXQgcGF5bG9hZF9sZW4zMiA9IEludDMyLm9mX2ludCBwYXlsb2FkX2xlbmd0aCBpblxuICBtYXRjaCBTY2hlZHVsZXIuZ2V0X25vZGUgdC5zdHJlYW1zIHN0cmVhbV9pZCB3aXRoXG4gIHwgU29tZSAoU3RyZWFtIHsgZGVzY3JpcHRvcjsgXyB9IGFzIHN0cmVhbSkgLT5cbiAgICAobWF0Y2ggZGVzY3JpcHRvci5zdGF0ZSB3aXRoXG4gICAgfCBBY3RpdmVcbiAgICAgICAgKCAoIE9wZW4gKEFjdGl2ZU1lc3NhZ2UgcmVzcG9uc2VfaW5mbylcbiAgICAgICAgICB8IEhhbGZDbG9zZWQgKEFjdGl2ZU1lc3NhZ2UgcmVzcG9uc2VfaW5mbykgKVxuICAgICAgICAsIF8gKSAtPlxuICAgICAgbGV0IHsgUmVzcGQucmVzcG9uc2U7IHJlc3BvbnNlX2JvZHk7IHJlc3BvbnNlX2JvZHlfYnl0ZXM7IF8gfSA9XG4gICAgICAgIHJlc3BvbnNlX2luZm9cbiAgICAgIGluXG4gICAgICByZXNwb25zZV9pbmZvLnJlc3BvbnNlX2JvZHlfYnl0ZXMgPC1cbiAgICAgICAgSW50NjQuKGFkZCByZXNwb25zZV9ib2R5X2J5dGVzIChvZl9pbnQgKEJpZ3N0cmluZ2FmLmxlbmd0aCBic3RyKSkpO1xuICAgICAgKCogRmlyc3QsIGNhbGN1bGF0ZSB3aGV0aGVyIHdlJ3JlIGFsbG93ZWQgdG8gcmVjZWl2ZSB0aGlzIGZyYW1lIGJhc2VkXG4gICAgICAgKiBvbiB0aGUgX2N1cnJlbnRfIGluZmxvdy4gKilcbiAgICAgIGxldCBhbGxvd2VkX3RvX3JlY2VpdmUgPVxuICAgICAgICBTY2hlZHVsZXIuKGFsbG93ZWRfdG9fcmVjZWl2ZSB0LnN0cmVhbXMgc3RyZWFtIHBheWxvYWRfbGVuMzIpXG4gICAgICBpblxuICAgICAgKCogVGhlbiwgZGVkdWN0IGluZmxvdyBmcm9tIHRoZSBjb25uZWN0aW9uIGZsb3ctY29udHJvbCB3aW5kb3csIGFzXG4gICAgICAgKiBtYW5kYXRlZCBieSB0aGUgcHJvdG9jb2wuXG4gICAgICAgKlxuICAgICAgICogRnJvbSBSRkM3NTQwwqc2Ljk6XG4gICAgICAgKiAgIEEgcmVjZWl2ZXIgdGhhdCByZWNlaXZlcyBhIGZsb3ctY29udHJvbGxlZCBmcmFtZSBNVVNUIGFsd2F5cyBhY2NvdW50XG4gICAgICAgKiAgIGZvciBpdHMgY29udHJpYnV0aW9uIGFnYWluc3QgdGhlIGNvbm5lY3Rpb24gZmxvdy1jb250cm9sIHdpbmRvdyxcbiAgICAgICAqICAgdW5sZXNzIHRoZSByZWNlaXZlciB0cmVhdHMgdGhpcyBhcyBhIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpLlxuICAgICAgICogICBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBmcmFtZSBpcyBpbiBlcnJvci4gKilcbiAgICAgIFNjaGVkdWxlci5kZWR1Y3RfaW5mbG93IHQuc3RyZWFtcyBwYXlsb2FkX2xlbjMyO1xuICAgICAgaWYgbm90IGFsbG93ZWRfdG9fcmVjZWl2ZVxuICAgICAgdGhlbiAoXG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi45OlxuICAgICAgICAgKiAgQSByZWNlaXZlciBNQVkgcmVzcG9uZCB3aXRoIGEgc3RyZWFtIGVycm9yIChTZWN0aW9uIDUuNC4yKSBvclxuICAgICAgICAgKiAgY29ubmVjdGlvbiBlcnJvciAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZSBGTE9XX0NPTlRST0xfRVJST1IgaWYgaXRcbiAgICAgICAgICogIGlzIHVuYWJsZSB0byBhY2NlcHQgYSBmcmFtZS4gKilcbiAgICAgICAgc2VuZF93aW5kb3dfdXBkYXRlIHQgdC5zdHJlYW1zIHBheWxvYWRfbGVuMzI7XG4gICAgICAgIHJlcG9ydF9zdHJlYW1fZXJyb3IgdCBzdHJlYW1faWQgRXJyb3JfY29kZS5GbG93Q29udHJvbEVycm9yKVxuICAgICAgZWxzZSAoXG4gICAgICAgIFNjaGVkdWxlci5kZWR1Y3RfaW5mbG93IHN0cmVhbSBwYXlsb2FkX2xlbjMyO1xuICAgICAgICBtYXRjaCBNZXNzYWdlLmJvZHlfbGVuZ3RoIHJlc3BvbnNlLmhlYWRlcnMgd2l0aFxuICAgICAgICB8IGBGaXhlZCBsZW5cbiAgICAgICAgKCogR2V0dGluZyBtb3JlIHRoYW4gdGhlIHNlcnZlciBkZWNsYXJlZCAqKVxuICAgICAgICAgIHdoZW4gSW50NjQuY29tcGFyZSByZXNwb25zZV9pbmZvLnJlc3BvbnNlX2JvZHlfYnl0ZXMgbGVuID4gMCAtPlxuICAgICAgICAgICgqIEdpdmUgYmFjayBjb25uZWN0aW9uLWxldmVsIGZsb3ctY29udHJvbGxlZCBieXRlcyAod2UgdXNlIHBheWxvYWRcbiAgICAgICAgICAgKiBsZW5ndGggdG8gaW5jbHVkZSBhbnkgcGFkZGluZyBieXRlcyB0aGF0IHRoZSBmcmFtZSBtaWdodCBoYXZlXG4gICAgICAgICAgICogaW5jbHVkZWQgLSB3aGljaCB3ZXJlIGlnbm9yZWQgYXQgcGFyc2UgdGltZSkuICopXG4gICAgICAgICAgc2VuZF93aW5kb3dfdXBkYXRlIHQgdC5zdHJlYW1zIHBheWxvYWRfbGVuMzI7XG4gICAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc4LjEuMi42OlxuICAgICAgICAgICAqICAgQSByZXF1ZXN0IG9yIHJlc3BvbnNlIGlzIGFsc28gbWFsZm9ybWVkIGlmIHRoZSB2YWx1ZSBvZiBhXG4gICAgICAgICAgICogICBjb250ZW50LWxlbmd0aCBoZWFkZXIgZmllbGQgZG9lcyBub3QgZXF1YWwgdGhlIHN1bSBvZiB0aGVcbiAgICAgICAgICAgKiAgIERBVEEgZnJhbWUgcGF5bG9hZCBsZW5ndGhzIHRoYXQgZm9ybSB0aGUgYm9keS4gKilcbiAgICAgICAgICBzZXRfZXJyb3JfYW5kX2hhbmRsZVxuICAgICAgICAgICAgdFxuICAgICAgICAgICAgZGVzY3JpcHRvclxuICAgICAgICAgICAgKGBJbnZhbGlkX3Jlc3BvbnNlX2JvZHlfbGVuZ3RoIHJlc3BvbnNlKVxuICAgICAgICAgICAgUHJvdG9jb2xFcnJvclxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBsZXQgZW5kX3N0cmVhbSA9IEZsYWdzLnRlc3RfZW5kX3N0cmVhbSBmbGFncyBpblxuICAgICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi45LjE6XG4gICAgICAgICAgICogICBUaGUgcmVjZWl2ZXIgb2YgYSBmcmFtZSBzZW5kcyBhIFdJTkRPV19VUERBVEUgZnJhbWUgYXMgaXRcbiAgICAgICAgICAgKiAgIGNvbnN1bWVzIGRhdGEgYW5kIGZyZWVzIHVwIHNwYWNlIGluIGZsb3ctY29udHJvbCB3aW5kb3dzLlxuICAgICAgICAgICAqICAgU2VwYXJhdGUgV0lORE9XX1VQREFURSBmcmFtZXMgYXJlIHNlbnQgZm9yIHRoZSBzdHJlYW0tIGFuZFxuICAgICAgICAgICAqICAgY29ubmVjdGlvbi1sZXZlbCBmbG93LWNvbnRyb2wgd2luZG93cy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIE5vdGU6IHdlIHNlbmQgdGhlc2UgV0lORE9XX1VQREFURSBmcmFtZXMgb25jZSB0aGUgYm9keSBieXRlc1xuICAgICAgICAgICAqIGhhdmUgYmVlbiBzdXJmYWNlZCB0byB0aGUgYXBwbGljYXRpb24uIFRoaXMgaXMgZG9uZSBpbiB0aGVcbiAgICAgICAgICAgKiByZWNvcmQgZmllbGQgYGRvbmVfcmVhZGluZ2Agb2YgYEJvZHkudGAuICopXG4gICAgICAgICAgbGV0IGZhcmFkYXkgPSBCb2R5LlJlYWRlci51bnNhZmVfZmFyYWRheSByZXNwb25zZV9ib2R5IGluXG4gICAgICAgICAgaWYgbm90IChGYXJhZGF5LmlzX2Nsb3NlZCBmYXJhZGF5KVxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgRmFyYWRheS5zY2hlZHVsZV9iaWdzdHJpbmcgZmFyYWRheSBic3RyO1xuICAgICAgICAgICAgaWYgZW5kX3N0cmVhbSB0aGVuIEJvZHkuUmVhZGVyLmNsb3NlIHJlc3BvbnNlX2JvZHkpO1xuICAgICAgICAgIFJlc3BkLmZsdXNoX3Jlc3BvbnNlX2JvZHkgZGVzY3JpcHRvcjtcbiAgICAgICAgICBpZiBlbmRfc3RyZWFtICYmIG5vdCAoUmVzcGQucmVxdWlyZXNfb3V0cHV0IGRlc2NyaXB0b3IpXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjE6XG4gICAgICAgICAgICAgKiAgIFdoZW4gc2V0LCBiaXQgMCBpbmRpY2F0ZXMgdGhhdCB0aGlzIGZyYW1lIGlzIHRoZSBsYXN0IHRoYXRcbiAgICAgICAgICAgICAqICAgdGhlIGVuZHBvaW50IHdpbGwgc2VuZCBmb3IgdGhlIGlkZW50aWZpZWQgc3RyZWFtLiBTZXR0aW5nXG4gICAgICAgICAgICAgKiAgIHRoaXMgZmxhZyBjYXVzZXMgdGhlIHN0cmVhbSB0byBlbnRlciBvbmUgb2YgdGhlXG4gICAgICAgICAgICAgKiAgIFwiaGFsZi1jbG9zZWRcIiBzdGF0ZXMgb3IgdGhlIFwiY2xvc2VkXCIgc3RhdGUgKFNlY3Rpb24gNS4xKS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUcmFuc2l0aW9uIHRvIHRoZSBcImNsb3NlZFwiIHN0YXRlIGlmIHRoaXMgaXMgdGhlIGxhc3QgREFUQSBmcmFtZVxuICAgICAgICAgICAgICogdGhhdCB0aGUgc2VydmVyIHdpbGwgc2VuZCBhbmQgd2UncmUgZG9uZSBzZW5kaW5nLiAqKVxuICAgICAgICAgICAgU3RyZWFtLmZpbmlzaF9zdHJlYW0gZGVzY3JpcHRvciBGaW5pc2hlZClcbiAgICB8IElkbGUgLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4xOlxuICAgICAgICogICBpZGxlOiBbLi4uXSBSZWNlaXZpbmcgYW55IGZyYW1lIG90aGVyIHRoYW4gSEVBREVSUyBvciBQUklPUklUWSBvblxuICAgICAgICogICBhIHN0cmVhbSBpbiB0aGlzIHN0YXRlIE1VU1QgYmUgdHJlYXRlZCBhcyBhIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgICAqICAgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuICAgICgqIFRoaXMgaXMgdGVjaG5pY2FsbHkgaW4gdGhlIGhhbGYtY2xvc2VkIChsb2NhbCkgc3RhdGUgKilcbiAgICB8IENsb3NlZCB7IHJlYXNvbiA9IFJlc2V0QnlVcyBOb0Vycm9yOyBfIH0gLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnNi45OlxuICAgICAgICogICBBIHJlY2VpdmVyIHRoYXQgcmVjZWl2ZXMgYSBmbG93LWNvbnRyb2xsZWQgZnJhbWUgTVVTVCBhbHdheXNcbiAgICAgICAqICAgYWNjb3VudCBmb3IgaXRzIGNvbnRyaWJ1dGlvbiBhZ2FpbnN0IHRoZSBjb25uZWN0aW9uIGZsb3ctY29udHJvbFxuICAgICAgICogICB3aW5kb3csIHVubGVzcyB0aGUgcmVjZWl2ZXIgdHJlYXRzIHRoaXMgYXMgYSBjb25uZWN0aW9uIGVycm9yXG4gICAgICAgKiAgIChTZWN0aW9uIDUuNC4xKS4gVGhpcyBpcyBuZWNlc3NhcnkgZXZlbiBpZiB0aGUgZnJhbWUgaXMgaW5cbiAgICAgICAqICAgZXJyb3IuICopXG4gICAgICBzZW5kX3dpbmRvd191cGRhdGUgdCB0LnN0cmVhbXMgcGF5bG9hZF9sZW4zMlxuICAgICgqIEZyb20gUkZDNzU0MMKnNi40OlxuICAgICAqICAgWy4uLl0gYWZ0ZXIgc2VuZGluZyB0aGUgUlNUX1NUUkVBTSwgdGhlIHNlbmRpbmcgZW5kcG9pbnQgTVVTVCBiZVxuICAgICAqICAgcHJlcGFyZWQgdG8gcmVjZWl2ZSBhbmQgcHJvY2VzcyBhZGRpdGlvbmFsIGZyYW1lcyBzZW50IG9uIHRoZVxuICAgICAqICAgc3RyZWFtIHRoYXQgbWlnaHQgaGF2ZSBiZWVuIHNlbnQgYnkgdGhlIHBlZXIgcHJpb3IgdG8gdGhlIGFycml2YWxcbiAgICAgKiAgIG9mIHRoZSBSU1RfU1RSRUFNLlxuICAgICAqXG4gICAgICogTm90ZTogYWZ0ZXIgc29tZSB3cml0ZXIgeWllbGRzIC8gd2FrZSB1cHMsIHdlIHdpbGwgaGF2ZSBzdG9wcGVkXG4gICAgICoga2VlcGluZyBzdGF0ZSBpbmZvcm1hdGlvbiBmb3IgdGhlIHN0cmVhbS4gVGhpcyBmdW5jdGlvbnMgZWZmZWN0aXZlbHlcbiAgICAgKiBhcyBhIHdheSBvZiBvbmx5IGFjY2VwdGluZyBmcmFtZXMgYWZ0ZXIgYW4gUlNUX1NUUkVBTSBmcm9tIHVzIHVwIHRvXG4gICAgICogYSB0aW1lIGxpbWl0LiAqKVxuICAgIHwgXyAtPlxuICAgICAgc2VuZF93aW5kb3dfdXBkYXRlIHQgdC5zdHJlYW1zIHBheWxvYWRfbGVuMzI7XG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuMTpcbiAgICAgICAqICAgSWYgYSBEQVRBIGZyYW1lIGlzIHJlY2VpdmVkIHdob3NlIHN0cmVhbSBpcyBub3QgaW4gXCJvcGVuXCIgb3JcbiAgICAgICAqICAgXCJoYWxmLWNsb3NlZCAobG9jYWwpXCIgc3RhdGUsIHRoZSByZWNpcGllbnQgTVVTVCByZXNwb25kIHdpdGggYVxuICAgICAgICogICBzdHJlYW0gZXJyb3IgKFNlY3Rpb24gNS40LjIpIG9mIHR5cGUgU1RSRUFNX0NMT1NFRC4gKilcbiAgICAgIHJlcG9ydF9zdHJlYW1fZXJyb3IgdCBzdHJlYW1faWQgRXJyb3JfY29kZS5TdHJlYW1DbG9zZWQpXG4gIHwgTm9uZSAtPlxuICAgIGlmIG5vdCAod2FzX2Nsb3NlZF9vcl9pbXBsaWNpdGx5X2Nsb3NlZCB0IHN0cmVhbV9pZClcbiAgICB0aGVuXG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgICAqICAgaWRsZTogWy4uLl0gUmVjZWl2aW5nIGFueSBmcmFtZSBvdGhlciB0aGFuIEhFQURFUlMgb3IgUFJJT1JJVFkgb25cbiAgICAgICAqICAgYSBzdHJlYW0gaW4gdGhpcyBzdGF0ZSBNVVNUIGJlIHRyZWF0ZWQgYXMgYSBjb25uZWN0aW9uIGVycm9yXG4gICAgICAgKiAgIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcblxubGV0IG9uX2Nsb3NlX3N0cmVhbSB0IGlkIH5hY3RpdmUgY2xvc2VkID1cbiAgaWYgYWN0aXZlXG4gIHRoZW5cbiAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMS4yOlxuICAgICAqICAgU3RyZWFtcyB0aGF0IGFyZSBpbiB0aGUgXCJvcGVuXCIgc3RhdGUgb3IgaW4gZWl0aGVyIG9mIHRoZSBcImhhbGYtY2xvc2VkXCJcbiAgICAgKiAgIHN0YXRlcyBjb3VudCB0b3dhcmQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0cmVhbXMgdGhhdCBhbiBlbmRwb2ludCBpc1xuICAgICAqICAgcGVybWl0dGVkIHRvIG9wZW4uICopXG4gICAgdC5jdXJyZW50X3NlcnZlcl9zdHJlYW1zIDwtIHQuY3VycmVudF9zZXJ2ZXJfc3RyZWFtcyAtIDE7XG4gIFNjaGVkdWxlci5tYXJrX2Zvcl9yZW1vdmFsIHQuc3RyZWFtcyBpZCBjbG9zZWRcblxubGV0IHByb2Nlc3NfcHJpb3JpdHlfZnJhbWUgdCB7IEZyYW1lLmZyYW1lX2hlYWRlcjsgXyB9IHByaW9yaXR5ID1cbiAgbGV0IHsgRnJhbWUuc3RyZWFtX2lkOyBfIH0gPSBmcmFtZV9oZWFkZXIgaW5cbiAgbGV0IHsgUHJpb3JpdHkuc3RyZWFtX2RlcGVuZGVuY3k7IF8gfSA9IHByaW9yaXR5IGluXG4gIGlmIFN0cmVhbV9pZGVudGlmaWVyLihzdHJlYW1faWQgPT09IHN0cmVhbV9kZXBlbmRlbmN5KVxuICB0aGVuXG4gICAgKCogRnJvbSBSRkM3NTQwwqc1LjMuMTpcbiAgICAgKiAgIEEgc3RyZWFtIGNhbm5vdCBkZXBlbmQgb24gaXRzZWxmLiBBbiBlbmRwb2ludCBNVVNUIHRyZWF0IHRoaXMgYXMgYVxuICAgICAqICAgc3RyZWFtIGVycm9yIChTZWN0aW9uIDUuNC4yKSBvZiB0eXBlIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgIHJlcG9ydF9zdHJlYW1fZXJyb3IgdCBzdHJlYW1faWQgRXJyb3JfY29kZS5Qcm90b2NvbEVycm9yXG4gIGVsc2VcbiAgICBtYXRjaCBTY2hlZHVsZXIuZ2V0X25vZGUgdC5zdHJlYW1zIHN0cmVhbV9pZCB3aXRoXG4gICAgfCBTb21lIHN0cmVhbSAtPiBTY2hlZHVsZXIucmVwcmlvcml0aXplX3N0cmVhbSB0LnN0cmVhbXMgfnByaW9yaXR5IHN0cmVhbVxuICAgIHwgTm9uZSAtPlxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc1LjM6XG4gICAgICAgKiAgIEEgY2xpZW50IGNhbiBhc3NpZ24gYSBwcmlvcml0eSBmb3IgYSBuZXcgc3RyZWFtIGJ5IGluY2x1ZGluZ1xuICAgICAgICogICBwcmlvcml0aXphdGlvbiBpbmZvcm1hdGlvbiBpbiB0aGUgSEVBREVSUyBmcmFtZSAoU2VjdGlvbiA2LjIpIHRoYXRcbiAgICAgICAqICAgb3BlbnMgdGhlIHN0cmVhbS4gQXQgYW55IG90aGVyIHRpbWUsIHRoZSBQUklPUklUWSBmcmFtZSAoU2VjdGlvblxuICAgICAgICogICA2LjMpIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgcHJpb3JpdHkgb2YgYSBzdHJlYW0uXG4gICAgICAgKlxuICAgICAgICogTm90ZTogVGhlIHNwZWMgbW9zdGx5IG9ubHkgbWVudGlvbnMgdGhhdCBjbGllbnRzIGFyZSB0aGUgZW5kcG9pbnRzXG4gICAgICAgKiAgICAgICB0aGF0IG1ha2UgdXNlIG9mIFBSSU9SSVRZIGZyYW1lcy4gQXMgc3VjaCwgd2UgZG9uJ3QgbWFrZSB0b29cbiAgICAgICAqICAgICAgIG11Y2ggb2YgYW4gZWZmb3J0IHRvIHByb2Nlc3MgUFJJT1JJVFkgZnJhbWVzIGNvbWluZyBmcm9tIGFcbiAgICAgICAqICAgICAgIHNlcnZlci4gSWYgd2Uga25vdyBhYm91dCBhIHN0cmVhbSwgd2UgcmVwcmlvcml0aXplIGl0IChtZWFuaW5nXG4gICAgICAgKiAgICAgICBwcmlvcml0aXphdGlvbiBpcyBhbiBpbnB1dCB0byB0aGUgcHJvY2VzcyBvZiBhbGxvY2F0aW5nXG4gICAgICAgKiAgICAgICByZXNvdXJjZXMgd2hlbiBmbHVzaGluZyByZXF1ZXN0IGJvZGllcykuIE90aGVyd2lzZSwgd2UgaWdub3JlXG4gICAgICAgKiAgICAgICBpdC4gV2UgZG9uJ3QsIGhvd2V2ZXIsIHJlcG9ydCBhbnkgZXJyb3JzIGlmIHRoZSBmcmFtZSBpc1xuICAgICAgICogICAgICAgd2VsbC1mb3JtZWQsIGFzIHNlY3Rpb24gNS4gY2xlYXJseSBtZW50aW9ucyB0aGF0IFBSSU9SSVRZIGZyYW1lc1xuICAgICAgICogICAgICAgbXVzdCBiZSBhY2NlcHRlZCBpbiBhbGwgc3RyZWFtIHN0YXRlcy5cbiAgICAgICAqXG4gICAgICAgKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgICAqICAgTm90ZSB0aGF0IFBSSU9SSVRZIGNhbiBiZSBzZW50IGFuZCByZWNlaXZlZCBpbiBhbnkgc3RyZWFtIHN0YXRlLiAqKVxuICAgICAgKClcblxubGV0IHByb2Nlc3NfcnN0X3N0cmVhbV9mcmFtZSB0IHsgRnJhbWUuZnJhbWVfaGVhZGVyOyBfIH0gZXJyb3JfY29kZSA9XG4gIGxldCB7IEZyYW1lLnN0cmVhbV9pZDsgXyB9ID0gZnJhbWVfaGVhZGVyIGluXG4gIG1hdGNoIFNjaGVkdWxlci5maW5kIHQuc3RyZWFtcyBzdHJlYW1faWQgd2l0aFxuICB8IFNvbWUgcmVzcGQgLT5cbiAgICAobWF0Y2ggcmVzcGQuc3RhdGUsIGVycm9yX2NvZGUgd2l0aFxuICAgIHwgSWRsZSwgXyAtPlxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjQ6XG4gICAgICAgKiAgIFJTVF9TVFJFQU0gZnJhbWVzIE1VU1QgTk9UIGJlIHNlbnQgZm9yIGEgc3RyZWFtIGluIHRoZSBcImlkbGVcIlxuICAgICAgICogICBzdGF0ZS4gSWYgYSBSU1RfU1RSRUFNIGZyYW1lIGlkZW50aWZ5aW5nIGFuIGlkbGUgc3RyZWFtIGlzXG4gICAgICAgKiAgIHJlY2VpdmVkLCB0aGUgcmVjaXBpZW50IE1VU1QgdHJlYXQgdGhpcyBhcyBhIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgICAqICAgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuICAgIHwgQWN0aXZlIF8sIEVycm9yX2NvZGUuTm9FcnJvciAtPlxuICAgICAgKCogSWYgd2UncmUgYWN0aXZlIChpLmUuIG5vdCBkb25lIHNlbmRpbmcgdGhlIHJlcXVlc3QgYm9keSksIGZpbmlzaCB0aGVcbiAgICAgICAqIHN0cmVhbSwgaW4gb3JkZXIgdG8gbWFyayBpdCBmb3IgY2xlYW51cC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlOiB3ZSBkb24ndCBjbG9zZSB0aGUgcmVxdWVzdCBib2R5IGhlcmUgYmVjYXVzZSB0aGUgY2xpZW50IG1heSBiZVxuICAgICAgICogaW4gdGhlIHByb2Nlc3Mgb2Ygd3JpdGluZyB0byBpdCwgYW5kIHdoaWxlIHdlJ3JlIG5vdCBnb2luZyB0byBzZW5kXG4gICAgICAgKiB0aG9zZSBieXRlcyB0byB0aGUgb3V0cHV0IGNoYW5uZWwsIHdlIGRvbid0IHdhbnQgdG8gZmFpbCB3aGVuIHdyaXRpbmdcbiAgICAgICAqIGVpdGhlci4gKilcbiAgICAgIFN0cmVhbS5maW5pc2hfc3RyZWFtIHJlc3BkIChSZXNldEJ5VGhlbSBlcnJvcl9jb2RlKVxuICAgIHwgQ2xvc2VkIF8sIF8gLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnOC4xOlxuICAgICAgICogICBBIHNlcnZlciBjYW4gc2VuZCBhIGNvbXBsZXRlIHJlc3BvbnNlIHByaW9yIHRvIHRoZSBjbGllbnQgc2VuZGluZyBhblxuICAgICAgICogICBlbnRpcmUgcmVxdWVzdCBpZiB0aGUgcmVzcG9uc2UgZG9lcyBub3QgZGVwZW5kIG9uIGFueSBwb3J0aW9uIG9mIHRoZVxuICAgICAgICogICByZXF1ZXN0IHRoYXQgaGFzIG5vdCBiZWVuIHNlbnQgYW5kIHJlY2VpdmVkLiBXaGVuIHRoaXMgaXMgdHJ1ZSwgYVxuICAgICAgICogICBzZXJ2ZXIgTUFZIHJlcXVlc3QgdGhhdCB0aGUgY2xpZW50IGFib3J0IHRyYW5zbWlzc2lvbiBvZiBhIHJlcXVlc3RcbiAgICAgICAqICAgd2l0aG91dCBlcnJvciBieSBzZW5kaW5nIGEgUlNUX1NUUkVBTSB3aXRoIGFuIGVycm9yIGNvZGUgb2YgTk9fRVJST1JcbiAgICAgICAqICAgYWZ0ZXIgc2VuZGluZyBhIGNvbXBsZXRlIHJlc3BvbnNlIChpLmUuLCBhIGZyYW1lIHdpdGggdGhlIEVORF9TVFJFQU1cbiAgICAgICAqICAgZmxhZykuXG4gICAgICAgKlxuICAgICAgICogSWYgd2UncmUgZG9uZSBzZW5kaW5nIHRoZSByZXF1ZXN0IHRoZXJlJ3Mgbm90aGluZyB0byBkbyBoZXJlLCBhbGxvd1xuICAgICAgICogdGhlIHN0cmVhbSB0byBmaW5pc2ggc3VjY2Vzc2Z1bGx5LlxuICAgICAgICpcbiAgICAgICAqIEZyb20gUkZDNzU0MMKnNS4xOlxuICAgICAgICogICBFbmRwb2ludHMgTVVTVCBpZ25vcmUgV0lORE9XX1VQREFURSBvciBSU1RfU1RSRUFNIGZyYW1lcyByZWNlaXZlZFxuICAgICAgICogICBpbiB0aGlzIHN0YXRlLCB0aG91Z2ggZW5kcG9pbnRzIE1BWSBjaG9vc2UgdG8gdHJlYXQgZnJhbWVzIHRoYXRcbiAgICAgICAqICAgYXJyaXZlIGEgc2lnbmlmaWNhbnQgdGltZSBhZnRlciBzZW5kaW5nIEVORF9TVFJFQU0gYXMgYSBjb25uZWN0aW9uXG4gICAgICAgKiAgIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlIFBST1RPQ09MX0VSUk9SLlxuICAgICAgICpcbiAgICAgICAqIFdlIGlnbm9yZSBmdXJ0aGVyIFJTVF9TVFJFQU0gZnJhbWVzLlxuICAgICAgICopXG4gICAgICAoKiBYWFgoYW5tb250ZWlybyk6IFdoZW4gd2UgYWRkIGxvZ2dpbmcgc3VwcG9ydCwgYWRkIHNvbWV0aGluZyBoZXJlLiAqKVxuICAgICAgKClcbiAgICB8IF8gLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnNi40OlxuICAgICAgICogICBUaGUgUlNUX1NUUkVBTSBmcmFtZSBmdWxseSB0ZXJtaW5hdGVzIHRoZSByZWZlcmVuY2VkIHN0cmVhbSBhbmRcbiAgICAgICAqICAgY2F1c2VzIGl0IHRvIGVudGVyIHRoZSBcImNsb3NlZFwiIHN0YXRlLiBBZnRlciByZWNlaXZpbmcgYVxuICAgICAgICogICBSU1RfU1RSRUFNIG9uIGEgc3RyZWFtLCB0aGUgcmVjZWl2ZXIgTVVTVCBOT1Qgc2VuZCBhZGRpdGlvbmFsXG4gICAgICAgKiAgIGZyYW1lcyBmb3IgdGhhdCBzdHJlYW0sIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBQUklPUklUWS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlOlxuICAgICAgICogICBUaGlzIG1hdGNoIGJyYW5jaCBhbHNvIGFjY2VwdHMgc3RyZWFtcyBpbiB0aGUgYENsb3NlZGAgc3RhdGUuIFdlXG4gICAgICAgKiAgIGRvIHRoYXQgdG8gY29tcGx5IHdpdGggdGhlIGZvbGxvd2luZzpcbiAgICAgICAqXG4gICAgICAgKiBGcm9tIFJGQzc1NDDCpzYuNDpcbiAgICAgICAqICAgWy4uLl0gYWZ0ZXIgc2VuZGluZyB0aGUgUlNUX1NUUkVBTSwgdGhlIHNlbmRpbmcgZW5kcG9pbnQgTVVTVCBiZVxuICAgICAgICogICBwcmVwYXJlZCB0byByZWNlaXZlIGFuZCBwcm9jZXNzIGFkZGl0aW9uYWwgZnJhbWVzIHNlbnQgb24gdGhlXG4gICAgICAgKiAgIHN0cmVhbSB0aGF0IG1pZ2h0IGhhdmUgYmVlbiBzZW50IGJ5IHRoZSBwZWVyIHByaW9yIHRvIHRoZSBhcnJpdmFsXG4gICAgICAgKiAgIG9mIHRoZSBSU1RfU1RSRUFNLiAqKVxuICAgICAgU3RyZWFtLmZpbmlzaF9zdHJlYW0gcmVzcGQgKFJlc2V0QnlUaGVtIGVycm9yX2NvZGUpO1xuICAgICAgKCogRnJvbSBSRkM3NTQwwqc1LjQuMjpcbiAgICAgICAqICAgVG8gYXZvaWQgbG9vcGluZywgYW4gZW5kcG9pbnQgTVVTVCBOT1Qgc2VuZCBhIFJTVF9TVFJFQU0gaW4gcmVzcG9uc2VcbiAgICAgICAqICAgdG8gYSBSU1RfU1RSRUFNIGZyYW1lLlxuICAgICAgICpcbiAgICAgICAqICAgTm90ZTogdGhlIHshUmVzcGQucmVwb3J0X2Vycm9yfSBmdW5jdGlvbiBkb2VzIG5vdCBzZW5kIGFuIFJTVF9TVFJFQU1cbiAgICAgICAqICAgZnJhbWUgZm9yIHN0cmVhbXMgaW4gdGhlIGNsb3NlZCBzdGF0ZS4gU28gd2UgY2xvc2UgdGhlIHN0cmVhbSBiZWZvcmVcbiAgICAgICAqICAgcmVwb3J0aW5nIHRoZSBlcnJvci4gKilcbiAgICAgIHNldF9lcnJvcl9hbmRfaGFuZGxlIHQgcmVzcGQgKGBQcm90b2NvbF9lcnJvciAoZXJyb3JfY29kZSwgXCJcIikpIGVycm9yX2NvZGUpXG4gIHwgTm9uZSAtPlxuICAgICgqIFdlIG1pZ2h0IGhhdmUgcmVtb3ZlZCB0aGUgc3RyZWFtIGZyb20gdGhlIGhhc2ggdGFibGUuIElmIGl0cyBzdHJlYW1cbiAgICAgKiBpZCBpcyBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG1heCBjbGllbnQgc3RyZWFtIGlkIHdlJ3ZlIGdlbmVyYXRlZCxcbiAgICAgKiB0aGVuIGl0IG11c3QgaGF2ZSBiZWVuIGNsb3NlZC4gKilcbiAgICBpZiBub3QgKHdhc19jbG9zZWRfb3JfaW1wbGljaXRseV9jbG9zZWQgdCBzdHJlYW1faWQpXG4gICAgdGhlblxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjQ6XG4gICAgICAgKiAgIFJTVF9TVFJFQU0gZnJhbWVzIE1VU1QgTk9UIGJlIHNlbnQgZm9yIGEgc3RyZWFtIGluIHRoZSBcImlkbGVcIlxuICAgICAgICogICBzdGF0ZS4gSWYgYSBSU1RfU1RSRUFNIGZyYW1lIGlkZW50aWZ5aW5nIGFuIGlkbGUgc3RyZWFtIGlzXG4gICAgICAgKiAgIHJlY2VpdmVkLCB0aGUgcmVjaXBpZW50IE1VU1QgdHJlYXQgdGhpcyBhcyBhIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgICAqICAgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuXG4gICAgICAgKlxuICAgICAgICogTm90ZTpcbiAgICAgICAqICAgSWYgd2UgZGlkbid0IGZpbmQgdGhlIHN0cmVhbSBpbiB0aGUgaGFzaCB0YWJsZSBpdCBtdXN0IGJlIFwiaWRsZVwiLiAqKVxuICAgICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcblxubGV0IHByb2Nlc3Nfc2V0dGluZ3NfZnJhbWUgdCB7IEZyYW1lLmZyYW1lX2hlYWRlcjsgXyB9IHNldHRpbmdzID1cbiAgbGV0IG9wZW4gU2NoZWR1bGVyIGluXG4gIGxldCB7IEZyYW1lLmZsYWdzOyBfIH0gPSBmcmFtZV9oZWFkZXIgaW5cbiAgKCogV2UgYWxyZWFkeSBjaGVja2VkIHRoYXQgYW4gYWNrZWQgU0VUVElOR1MgaXMgZW1wdHkuIERvbid0IG5lZWQgdG8gZG9cbiAgICogYW55dGhpbmcgZWxzZSBpbiB0aGF0IGNhc2UgKilcbiAgaWYgRmxhZ3MuKHRlc3RfYWNrIGZsYWdzKVxuICB0aGVuIChcbiAgICB0LnVuYWNrZWRfc2V0dGluZ3MgPC0gdC51bmFja2VkX3NldHRpbmdzIC0gMTtcbiAgICBpZiB0LnVuYWNrZWRfc2V0dGluZ3MgPCAwXG4gICAgdGhlblxuICAgICAgKCogVGhlIHNlcnZlciBpcyBBQ0tpbmcgYSBTRVRUSU5HUyBmcmFtZSB0aGF0IHdlIGRpZG4ndCBzZW5kICopXG4gICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvclxuICAgICAgICB0XG4gICAgICAgIH5yZWFzb246XCJSZWNlaXZlZCB1bmV4cGVjdGVkIFNFVFRJTkdTIGZyYW1lIHdpdGggYWNrbm93bGVkZ2VtZW50XCJcbiAgICAgICAgRXJyb3JfY29kZS5Qcm90b2NvbEVycm9yKVxuICBlbHNlXG4gICAgbWF0Y2ggU2V0dGluZ3MuY2hlY2tfc2V0dGluZ3NfbGlzdCB+aXNfY2xpZW50OnRydWUgc2V0dGluZ3Mgd2l0aFxuICAgIHwgT2sgKCkgLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnNi41OlxuICAgICAgICogICBFYWNoIHBhcmFtZXRlciBpbiBhIFNFVFRJTkdTIGZyYW1lIHJlcGxhY2VzIGFueSBleGlzdGluZyB2YWx1ZSBmb3JcbiAgICAgICAqICAgdGhhdCBwYXJhbWV0ZXIuIFBhcmFtZXRlcnMgYXJlIHByb2Nlc3NlZCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleVxuICAgICAgICogICBhcHBlYXIsIGFuZCBhIHJlY2VpdmVyIG9mIGEgU0VUVElOR1MgZnJhbWUgZG9lcyBub3QgbmVlZCB0byBtYWludGFpblxuICAgICAgICogICBhbnkgc3RhdGUgb3RoZXIgdGhhbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBpdHMgcGFyYW1ldGVycy4gKilcbiAgICAgIGxldCBuZXdfc2V0dGluZ3MgPVxuICAgICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgICAgIChmdW4gKGFjYyA6IFNldHRpbmdzLnQpIGl0ZW0gLT5cbiAgICAgICAgICAgICBtYXRjaCBpdGVtIHdpdGhcbiAgICAgICAgICAgICB8IFNldHRpbmdzLkhlYWRlclRhYmxlU2l6ZSB4IC0+XG4gICAgICAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNS4yOlxuICAgICAgICAgICAgICAgICogICBBbGxvd3MgdGhlIHNlbmRlciB0byBpbmZvcm0gdGhlIHJlbW90ZSBlbmRwb2ludCBvZiB0aGUgbWF4aW11bVxuICAgICAgICAgICAgICAgICogICBzaXplIG9mIHRoZSBoZWFkZXIgY29tcHJlc3Npb24gdGFibGUgdXNlZCB0byBkZWNvZGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgKiAgIGJsb2NrcywgaW4gb2N0ZXRzLiAqKVxuICAgICAgICAgICAgICAgSHBhY2suRW5jb2Rlci5zZXRfY2FwYWNpdHkgdC5ocGFja19lbmNvZGVyIHg7XG4gICAgICAgICAgICAgICB7IGFjYyB3aXRoIGhlYWRlcl90YWJsZV9zaXplID0geCB9XG4gICAgICAgICAgICAgfCBFbmFibGVQdXNoIHggLT5cbiAgICAgICAgICAgICAgICgqIFdlJ3ZlIGFscmVhZHkgdmVyaWZpZWQgdGhhdCB0aGlzIHNldHRpbmcgaXMgZWl0aGVyIDAgb3IgMSBpbiB0aGVcbiAgICAgICAgICAgICAgICAqIGNhbGwgdG8gYFNldHRpbmdzLmNoZWNrX3NldHRpbmdzX2xpc3RgIGFib3ZlLiAqKVxuICAgICAgICAgICAgICAgeyBhY2Mgd2l0aCBlbmFibGVfcHVzaCA9IHggPSAxIH1cbiAgICAgICAgICAgICB8IE1heENvbmN1cnJlbnRTdHJlYW1zIHggLT4geyBhY2Mgd2l0aCBtYXhfY29uY3VycmVudF9zdHJlYW1zID0geCB9XG4gICAgICAgICAgICAgfCBJbml0aWFsV2luZG93U2l6ZSBuZXdfdmFsIC0+XG4gICAgICAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuOS4yOlxuICAgICAgICAgICAgICAgICogICBJbiBhZGRpdGlvbiB0byBjaGFuZ2luZyB0aGUgZmxvdy1jb250cm9sIHdpbmRvdyBmb3Igc3RyZWFtc1xuICAgICAgICAgICAgICAgICogICB0aGF0IGFyZSBub3QgeWV0IGFjdGl2ZSwgIGEgU0VUVElOR1MgZnJhbWUgY2FuIGFsdGVyIHRoZVxuICAgICAgICAgICAgICAgICogICBpbml0aWFsIGZsb3ctY29udHJvbCB3aW5kb3cgc2l6ZSBmb3Igc3RyZWFtcyB3aXRoIGFjdGl2ZVxuICAgICAgICAgICAgICAgICogICBmbG93LWNvbnRyb2wgd2luZG93cyAodGhhdCBpcywgc3RyZWFtcyBpbiB0aGUgXCJvcGVuXCIgb3JcbiAgICAgICAgICAgICAgICAqICAgXCJoYWxmLWNsb3NlZCAocmVtb3RlKVwiIHN0YXRlKS4gV2hlbiB0aGUgdmFsdWUgb2ZcbiAgICAgICAgICAgICAgICAqICAgU0VUVElOR1NfSU5JVElBTF9XSU5ET1dfU0laRSBjaGFuZ2VzLCBhIHJlY2VpdmVyIE1VU1QgYWRqdXN0XG4gICAgICAgICAgICAgICAgKiAgIHRoZSBzaXplIG9mIGFsbCBzdHJlYW0gZmxvdy1jb250cm9sIHdpbmRvd3MgdGhhdCBpdFxuICAgICAgICAgICAgICAgICogICBtYWludGFpbnMgYnkgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IHZhbHVlIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAqICAgb2xkIHZhbHVlLlxuICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAqICAgWy4uLl0gQSBTRVRUSU5HUyBmcmFtZSBjYW5ub3QgYWx0ZXIgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAqICAgZmxvdy1jb250cm9sIHdpbmRvdy4gKilcbiAgICAgICAgICAgICAgIGxldCBvbGRfdmFsID0gdC5zZXR0aW5ncy5pbml0aWFsX3dpbmRvd19zaXplIGluXG4gICAgICAgICAgICAgICBsZXQgZ3Jvd3RoID0gSW50MzIuc3ViIG5ld192YWwgb2xkX3ZhbCBpblxuICAgICAgICAgICAgICAgbGV0IGV4Y2VwdGlvbiBMb2NhbCBpblxuICAgICAgICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgICAgICBTY2hlZHVsZXIuaXRlclxuICAgICAgICAgICAgICAgICAgICB+ZjooZnVuIHN0cmVhbSAtPlxuICAgICAgICAgICAgICAgICAgICAgICgqIEZyb20gUkZDNzU0MMKnNi45LjI6XG4gICAgICAgICAgICAgICAgICAgICAgICogICBBbiBlbmRwb2ludCBNVVNUIHRyZWF0IGEgY2hhbmdlIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICogICBTRVRUSU5HU19JTklUSUFMX1dJTkRPV19TSVpFIHRoYXQgY2F1c2VzIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAqICAgZmxvdy1jb250cm9sIHdpbmRvdyB0byBleGNlZWQgdGhlIG1heGltdW0gc2l6ZSBhcyBhXG4gICAgICAgICAgICAgICAgICAgICAgICogICBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICogICBGTE9XX0NPTlRST0xfRVJST1IuICopXG4gICAgICAgICAgICAgICAgICAgICAgaWYgbm90IChTY2hlZHVsZXIuYWRkX2Zsb3cgc3RyZWFtIGdyb3d0aCkgdGhlbiByYWlzZSBMb2NhbClcbiAgICAgICAgICAgICAgICAgICAgdC5zdHJlYW1zXG4gICAgICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgICAgfCAoKSAtPiAoKVxuICAgICAgICAgICAgICAgfCBleGNlcHRpb24gTG9jYWwgLT5cbiAgICAgICAgICAgICAgICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3JcbiAgICAgICAgICAgICAgICAgICB0XG4gICAgICAgICAgICAgICAgICAgfnJlYXNvbjpcbiAgICAgICAgICAgICAgICAgICAgIChGb3JtYXQuc3ByaW50ZlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJXaW5kb3cgc2l6ZSBmb3Igc3RyZWFtIHdvdWxkIGV4Y2VlZCAlbGRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgU2V0dGluZ3MuV2luZG93U2l6ZS5tYXhfd2luZG93X3NpemUpXG4gICAgICAgICAgICAgICAgICAgRXJyb3JfY29kZS5GbG93Q29udHJvbEVycm9yKTtcbiAgICAgICAgICAgICAgIHsgYWNjIHdpdGggaW5pdGlhbF93aW5kb3dfc2l6ZSA9IG5ld192YWwgfVxuICAgICAgICAgICAgIHwgTWF4RnJhbWVTaXplIHggLT5cbiAgICAgICAgICAgICAgIFNjaGVkdWxlci5pdGVyXG4gICAgICAgICAgICAgICAgIH5mOihmdW4gKFN0cmVhbSB7IGRlc2NyaXB0b3I7IF8gfSkgLT5cbiAgICAgICAgICAgICAgICAgICBpZiBSZXNwZC5yZXF1aXJlc19vdXRwdXQgZGVzY3JpcHRvclxuICAgICAgICAgICAgICAgICAgIHRoZW4gZGVzY3JpcHRvci5tYXhfZnJhbWVfc2l6ZSA8LSB4KVxuICAgICAgICAgICAgICAgICB0LnN0cmVhbXM7XG4gICAgICAgICAgICAgICB7IGFjYyB3aXRoIG1heF9mcmFtZV9zaXplID0geCB9XG4gICAgICAgICAgICAgfCBNYXhIZWFkZXJMaXN0U2l6ZSB4IC0+IHsgYWNjIHdpdGggbWF4X2hlYWRlcl9saXN0X3NpemUgPSBTb21lIHggfSlcbiAgICAgICAgICB0LnNldHRpbmdzXG4gICAgICAgICAgc2V0dGluZ3NcbiAgICAgIGluXG4gICAgICB0LnNldHRpbmdzIDwtIG5ld19zZXR0aW5ncztcbiAgICAgIGxldCBmcmFtZV9pbmZvID1cbiAgICAgICAgV3JpdGVyLm1ha2VfZnJhbWVfaW5mb1xuICAgICAgICAgIH5mbGFnczpGbGFncy4oc2V0X2FjayBkZWZhdWx0X2ZsYWdzKVxuICAgICAgICAgIFN0cmVhbV9pZGVudGlmaWVyLmNvbm5lY3Rpb25cbiAgICAgIGluXG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuNTpcbiAgICAgICAqICAgQUNLICgweDEpOiBbLi4uXSBXaGVuIHRoaXMgYml0IGlzIHNldCwgdGhlIHBheWxvYWQgb2YgdGhlIFNFVFRJTkdTXG4gICAgICAgKiAgIGZyYW1lIE1VU1QgYmUgZW1wdHkuICopXG4gICAgICBXcml0ZXIud3JpdGVfc2V0dGluZ3MgdC53cml0ZXIgZnJhbWVfaW5mbyBbXTtcbiAgICAgIHQudW5hY2tlZF9zZXR0aW5ncyA8LSB0LnVuYWNrZWRfc2V0dGluZ3MgKyAxO1xuICAgICAgV3JpdGVyLndha2V1cCB0LndyaXRlclxuICAgIHwgRXJyb3IgZXJyb3IgLT4gcmVwb3J0X2Vycm9yIHQgZXJyb3JcblxubGV0IHJlc2VydmVfc3RyZWFtIHQgeyBGcmFtZS5mcmFtZV9oZWFkZXI7IF8gfSBwcm9taXNlZF9zdHJlYW1faWQgaGVhZGVyc19ibG9jayA9XG4gIGxldCB7IEZyYW1lLmZsYWdzOyBzdHJlYW1faWQ7IF8gfSA9IGZyYW1lX2hlYWRlciBpblxuICAoKiBGcm9tIFJGQzc1NDDCpzYuNjpcbiAgICogICBUaGUgUFVTSF9QUk9NSVNFIGZyYW1lICh0eXBlPTB4NSkgaXMgdXNlZCB0byBub3RpZnkgdGhlIHBlZXIgZW5kcG9pbnQgaW5cbiAgICogICBhZHZhbmNlIG9mIHN0cmVhbXMgdGhlIHNlbmRlciBpbnRlbmRzIHRvIGluaXRpYXRlLiAqKVxuICBsZXQgcmVzcGQgPVxuICAgIFN0cmVhbS5jcmVhdGVcbiAgICAgIHByb21pc2VkX3N0cmVhbV9pZFxuICAgICAgfm1heF9mcmFtZV9zaXplOnQuc2V0dGluZ3MubWF4X2ZyYW1lX3NpemVcbiAgICAgIHQud3JpdGVyXG4gICAgICB0LmVycm9yX2hhbmRsZXJcbiAgICAgIChvbl9jbG9zZV9zdHJlYW0gdCBwcm9taXNlZF9zdHJlYW1faWQpXG4gIGluXG4gICgqIEZyb20gUkZDNzU0MMKnNS4zLjU6XG4gICAqICAgQWxsIHN0cmVhbXMgYXJlIGluaXRpYWxseSBhc3NpZ25lZCBhIG5vbi1leGNsdXNpdmUgZGVwZW5kZW5jeSBvbiBzdHJlYW1cbiAgICogICAweDAuIFB1c2hlZCBzdHJlYW1zIChTZWN0aW9uIDguMikgaW5pdGlhbGx5IGRlcGVuZCBvbiB0aGVpciBhc3NvY2lhdGVkXG4gICAqICAgc3RyZWFtLiBJbiBib3RoIGNhc2VzLCBzdHJlYW1zIGFyZSBhc3NpZ25lZCBhIGRlZmF1bHQgd2VpZ2h0IG9mIDE2LiAqKVxuICBsZXQgc3RyZWFtIDogU2NoZWR1bGVyLm5vbnJvb3QgU2NoZWR1bGVyLm5vZGUgPVxuICAgIFNjaGVkdWxlci5hZGRcbiAgICAgIHQuc3RyZWFtc1xuICAgICAgfnByaW9yaXR5OnsgUHJpb3JpdHkuZGVmYXVsdF9wcmlvcml0eSB3aXRoIHN0cmVhbV9kZXBlbmRlbmN5ID0gc3RyZWFtX2lkIH1cbiAgICAgIH5pbml0aWFsX3NlbmRfd2luZG93X3NpemU6dC5zZXR0aW5ncy5pbml0aWFsX3dpbmRvd19zaXplXG4gICAgICB+aW5pdGlhbF9yZWN2X3dpbmRvd19zaXplOnQuY29uZmlnLmluaXRpYWxfd2luZG93X3NpemVcbiAgICAgIHJlc3BkXG4gIGluXG4gIGxldCBwYXJ0aWFsX2hlYWRlcnMgPSBjcmVhdGVfcGFydGlhbF9oZWFkZXJzIHQgZmxhZ3MgaGVhZGVyc19ibG9jayBpblxuICByZXNwZC5zdGF0ZSA8LSBSZXNlcnZlZCAoUGFydGlhbEhlYWRlcnMgcGFydGlhbF9oZWFkZXJzKTtcbiAgaWYgbm90IChGbGFncy50ZXN0X2VuZF9oZWFkZXIgZmxhZ3MpXG4gIHRoZW4gdC5yZWNlaXZpbmdfaGVhZGVyc19mb3Jfc3RyZWFtIDwtIFNvbWUgcHJvbWlzZWRfc3RyZWFtX2lkO1xuICBoYW5kbGVfaGVhZGVyc19ibG9jayB0IHN0cmVhbSBwYXJ0aWFsX2hlYWRlcnMgZmxhZ3MgaGVhZGVyc19ibG9ja1xuXG5sZXQgcHJvY2Vzc19wdXNoX3Byb21pc2VfZnJhbWVcbiAgICB0XG4gICAgKHsgRnJhbWUuZnJhbWVfaGVhZGVyOyBfIH0gYXMgZnJhbWUpXG4gICAgcHJvbWlzZWRfc3RyZWFtX2lkXG4gICAgaGVhZGVyc19ibG9ja1xuICA9XG4gIGxldCB7IEZyYW1lLnN0cmVhbV9pZDsgXyB9ID0gZnJhbWVfaGVhZGVyIGluXG4gICgqIEF0IHRoaXMgcG9pbnQsIGBwcm9taXNlZF9zdHJlYW1faWRgIGhhcyBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGJ5IHRoZVxuICAgKiBwYXJzZXIgKilcbiAgaWYgbm90IHQuc2V0dGluZ3MuZW5hYmxlX3B1c2hcbiAgdGhlblxuICAgICgqIEZyb20gUkZDNzU0MMKnNi42OlxuICAgICAqICAgUFVTSF9QUk9NSVNFIE1VU1QgTk9UIGJlIHNlbnQgaWYgdGhlIFNFVFRJTkdTX0VOQUJMRV9QVVNIIHNldHRpbmcgb2ZcbiAgICAgKiAgIHRoZSBwZWVyIGVuZHBvaW50IGlzIHNldCB0byAwLiBBbiBlbmRwb2ludCB0aGF0IGhhcyBzZXQgdGhpcyBzZXR0aW5nXG4gICAgICogICBhbmQgaGFzIHJlY2VpdmVkIGFja25vd2xlZGdlbWVudCBNVVNUIHRyZWF0IHRoZSByZWNlaXB0IG9mIGFcbiAgICAgKiAgIFBVU0hfUFJPTUlTRSBmcmFtZSBhcyBhIGNvbm5lY3Rpb24gZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGVcbiAgICAgKiAgIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgIHJlcG9ydF9jb25uZWN0aW9uX2Vycm9yXG4gICAgICB0XG4gICAgICB+cmVhc29uOlwiUHVzaCBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb25uZWN0aW9uXCJcbiAgICAgIEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuICBlbHNlIGlmIG5vdCBTdHJlYW1faWRlbnRpZmllci4ocHJvbWlzZWRfc3RyZWFtX2lkID4gdC5tYXhfcHVzaGVkX3N0cmVhbV9pZClcbiAgdGhlblxuICAgICgqIEZyb20gUkZDNzU0MMKnNi42OlxuICAgICAqICAgQSByZWNlaXZlciBNVVNUIHRyZWF0IHRoZSByZWNlaXB0IG9mIGEgUFVTSF9QUk9NSVNFIHRoYXQgcHJvbWlzZXMgYW5cbiAgICAgKiAgIGlsbGVnYWwgc3RyZWFtIGlkZW50aWZpZXIgKFNlY3Rpb24gNS4xLjEpIGFzIGEgY29ubmVjdGlvbiBlcnJvclxuICAgICAqICAgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuIE5vdGUgdGhhdCBhbiBpbGxlZ2FsIHN0cmVhbVxuICAgICAqICAgaWRlbnRpZmllciBpcyBhbiBpZGVudGlmaWVyIGZvciBhIHN0cmVhbSB0aGF0IGlzIG5vdCBjdXJyZW50bHkgaW4gdGhlXG4gICAgICogICBcImlkbGVcIiBzdGF0ZS4gKilcbiAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvclxuICAgICAgdFxuICAgICAgfnJlYXNvbjpcIklsbGVnYWwgc3RyZWFtIGlkZW50aWZpZXIgcHJvbWlzZWQgYnkgUFVTSF9QUk9NSVNFXCJcbiAgICAgIEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuICBlbHNlXG4gICAgbGV0IHNlbmRfY29ubmVjdGlvbl9lcnJvciAoKSA9XG4gICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvclxuICAgICAgICB0XG4gICAgICAgIH5yZWFzb246XG4gICAgICAgICAgXCJSZWNlaXZlZCBQVVNIX1BST01JU0Ugb24gYSBzdHJlYW0gdGhhdCBpcyBuZWl0aGVyIG9wZW4gbm9yIFxcXG4gICAgICAgICAgIGhhbGYtY2xvc2VkIChsb2NhbClcIlxuICAgICAgICBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgICBpblxuICAgIHQubWF4X3B1c2hlZF9zdHJlYW1faWQgPC0gcHJvbWlzZWRfc3RyZWFtX2lkO1xuICAgIG1hdGNoIFNjaGVkdWxlci5maW5kIHQuc3RyZWFtcyBzdHJlYW1faWQgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjY6XG4gICAgICAgKiAgIEEgcmVjZWl2ZXIgTVVTVCB0cmVhdCB0aGUgcmVjZWlwdCBvZiBhIFBVU0hfUFJPTUlTRSBvbiBhIHN0cmVhbSB0aGF0XG4gICAgICAgKiAgIGlzIG5laXRoZXIgXCJvcGVuXCIgbm9yIFwiaGFsZi1jbG9zZWQgKGxvY2FsKVwiIGFzIGEgY29ubmVjdGlvbiBlcnJvclxuICAgICAgICogICAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICAgIHNlbmRfY29ubmVjdGlvbl9lcnJvciAoKVxuICAgIHwgU29tZSByZXNwZCAtPlxuICAgICAgKG1hdGNoIHJlc3BkLnN0YXRlIHdpdGhcbiAgICAgIHwgQWN0aXZlICgoT3BlbiBfIHwgSGFsZkNsb3NlZCBfKSwgXykgLT5cbiAgICAgICAgcmVzZXJ2ZV9zdHJlYW0gdCBmcmFtZSBwcm9taXNlZF9zdHJlYW1faWQgaGVhZGVyc19ibG9ja1xuICAgICAgfCBfIC0+IHNlbmRfY29ubmVjdGlvbl9lcnJvciAoKSlcblxubGV0IG9rID0gT2sgKClcblxubGV0IHByb2Nlc3NfcGluZ19mcmFtZSB0IHsgRnJhbWUuZnJhbWVfaGVhZGVyOyBfIH0gcGF5bG9hZCA9XG4gIGxldCB7IEZyYW1lLmZsYWdzOyBfIH0gPSBmcmFtZV9oZWFkZXIgaW5cbiAgKCogRnJvbSBSRkM3NTQwwqc2Ljc6XG4gICAqICAgQUNLICgweDEpOiBXaGVuIHNldCwgYml0IDAgaW5kaWNhdGVzIHRoYXQgdGhpcyBQSU5HIGZyYW1lIGlzIGEgUElOR1xuICAgKiAgIHJlc3BvbnNlLiBbLi4uXSBBbiBlbmRwb2ludCBNVVNUIE5PVCByZXNwb25kIHRvIFBJTkcgZnJhbWVzIGNvbnRhaW5pbmdcbiAgICogICB0aGlzIGZsYWcuICopXG4gIGlmIEZsYWdzLnRlc3RfYWNrIGZsYWdzXG4gIHRoZW5cbiAgICBtYXRjaCBRdWV1ZS50YWtlX29wdCB0LnBlbmRpbmdfcGluZ3Mgd2l0aFxuICAgIHwgU29tZSBjYWxsYmFjayAtPiBjYWxsYmFjayBva1xuICAgIHwgTm9uZSAtPlxuICAgICAgKCogc2VydmVyIGlzIEFDS2luZyBhIFBJTkcgdGhhdCB3ZSBkaWRuJ3Qgc2VuZD8gKilcbiAgICAgIHJlcG9ydF9jb25uZWN0aW9uX2Vycm9yXG4gICAgICAgIHRcbiAgICAgICAgfnJlYXNvbjpcIlVuZXhwZWN0ZWQgUElORyBhY2tub3dsZWRnZW1lbnRcIlxuICAgICAgICBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgZWxzZVxuICAgICgqIEZyb20gUkZDNzU0MMKnNi43OlxuICAgICAqICAgUmVjZWl2ZXJzIG9mIGEgUElORyBmcmFtZSB0aGF0IGRvZXMgbm90IGluY2x1ZGUgYW4gQUNLIGZsYWcgTVVTVCBzZW5kXG4gICAgICogICBhIFBJTkcgZnJhbWUgd2l0aCB0aGUgQUNLIGZsYWcgc2V0IGluIHJlc3BvbnNlLCB3aXRoIGFuIGlkZW50aWNhbFxuICAgICAqICAgcGF5bG9hZC4gUElORyByZXNwb25zZXMgU0hPVUxEIGJlIGdpdmVuIGhpZ2hlciBwcmlvcml0eSB0aGFuIGFueSBvdGhlclxuICAgICAqICAgZnJhbWUuICopXG4gICAgbGV0IGZyYW1lX2luZm8gPVxuICAgICAgV3JpdGVyLm1ha2VfZnJhbWVfaW5mb1xuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2Ljc6XG4gICAgICAgKiAgIEFDSyAoMHgxKTogV2hlbiBzZXQsIGJpdCAwIGluZGljYXRlcyB0aGF0IHRoaXMgUElORyBmcmFtZSBpcyBhXG4gICAgICAgKiAgIFBJTkcgcmVzcG9uc2UuIEFuIGVuZHBvaW50IE1VU1Qgc2V0IHRoaXMgZmxhZyBpbiBQSU5HXG4gICAgICAgKiAgIHJlc3BvbnNlcy4gKilcbiAgICAgICAgfmZsYWdzOkZsYWdzLihzZXRfYWNrIGRlZmF1bHRfZmxhZ3MpXG4gICAgICAgIFN0cmVhbV9pZGVudGlmaWVyLmNvbm5lY3Rpb25cbiAgICBpblxuICAgICgqIEZyb20gUkZDNzU0MMKnNi43OlxuICAgICAqICAgUmVjZWl2ZXJzIG9mIGEgUElORyBmcmFtZSB0aGF0IGRvZXMgbm90IGluY2x1ZGUgYW4gQUNLIGZsYWcgTVVTVCBzZW5kXG4gICAgICogICBhIFBJTkcgZnJhbWUgd2l0aCB0aGUgQUNLIGZsYWcgc2V0IGluIHJlc3BvbnNlLCB3aXRoIGFuIGlkZW50aWNhbFxuICAgICAqICAgcGF5bG9hZC4gKilcbiAgICBXcml0ZXIud3JpdGVfcGluZyB0LndyaXRlciBmcmFtZV9pbmZvIHBheWxvYWQ7XG4gICAgV3JpdGVyLndha2V1cCB0LndyaXRlclxuXG5sZXQgcHJvY2Vzc19nb2F3YXlfZnJhbWUgdCBfZnJhbWUgfmxhc3Rfc3RyZWFtX2lkOl8gfmRhdGEgZXJyb3IgPVxuICBsZXQgcmVhc29uID1cbiAgICBtYXRjaCBCaWdzdHJpbmdhZi5sZW5ndGggZGF0YSB3aXRoXG4gICAgfCAwIC0+IE5vbmVcbiAgICB8IGxlbiAtPiBTb21lIChCaWdzdHJpbmdhZi5zdWJzdHJpbmcgZGF0YSB+b2ZmOjAgfmxlbilcbiAgaW5cbiAgKCogVE9ETyhhbm1vbnRlaXJvKTogSSB0aGluayB3ZSBuZWVkIHRvIGFsbG93IGxvd2VyIG51bWJlcmVkIHN0cmVhbXMgdG9cbiAgICogY29tcGxldGUuICopXG4gIHJlcG9ydF9jb25uZWN0aW9uX2Vycm9yIHQgP3JlYXNvbiBlcnJvclxuXG5sZXQgYWRkX3dpbmRvd19pbmNyZW1lbnQgOlxuICAgIHR5cGUgYS4gdCAtPiBhIFNjaGVkdWxlci5Qcmlvcml0eVRyZWVOb2RlLm5vZGUgLT4gaW50MzIgLT4gdW5pdFxuICA9XG4gZnVuIHQgc3RyZWFtIGluY3JlbWVudCAtPlxuICBsZXQgb3BlbiBTY2hlZHVsZXIgaW5cbiAgbGV0IGRpZF9hZGQgPSBTY2hlZHVsZXIuYWRkX2Zsb3cgc3RyZWFtIGluY3JlbWVudCBpblxuICBsZXQgc3RyZWFtX2lkID0gU2NoZWR1bGVyLnN0cmVhbV9pZCBzdHJlYW0gaW5cbiAgbGV0IG5ld19mbG93ID1cbiAgICBtYXRjaCBzdHJlYW0gd2l0aFxuICAgIHwgQ29ubmVjdGlvbiB7IGZsb3c7IF8gfSAtPiBmbG93XG4gICAgfCBTdHJlYW0geyBmbG93OyBfIH0gLT4gZmxvd1xuICBpblxuICBpZiBkaWRfYWRkXG4gIHRoZW4gKFxuICAgIGlmIEludDMyLmNvbXBhcmUgbmV3X2Zsb3cgMGwgPiAwXG4gICAgdGhlblxuICAgICAgKCogRG9uJ3QgYm90aGVyIHdha2luZyB1cCB0aGUgd3JpdGVyIGlmIHRoZSBuZXcgZmxvdyBkb2Vzbid0IGFsbG93XG4gICAgICAgKiB0aGUgc3RyZWFtIHRvIHdyaXRlLiAqKVxuICAgICAgV3JpdGVyLndha2V1cCB0LndyaXRlcilcbiAgZWxzZSBpZiBTdHJlYW1faWRlbnRpZmllci5pc19jb25uZWN0aW9uIHN0cmVhbV9pZFxuICB0aGVuXG4gICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3JcbiAgICAgIHRcbiAgICAgIH5yZWFzb246XG4gICAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgICBcIldpbmRvdyBzaXplIGZvciBzdHJlYW0gd291bGQgZXhjZWVkICVsZFwiXG4gICAgICAgICAgIFNldHRpbmdzLldpbmRvd1NpemUubWF4X3dpbmRvd19zaXplKVxuICAgICAgRXJyb3JfY29kZS5GbG93Q29udHJvbEVycm9yXG4gIGVsc2UgcmVwb3J0X3N0cmVhbV9lcnJvciB0IHN0cmVhbV9pZCBFcnJvcl9jb2RlLkZsb3dDb250cm9sRXJyb3JcblxubGV0IHByb2Nlc3Nfd2luZG93X3VwZGF0ZV9mcmFtZSB0IHsgRnJhbWUuZnJhbWVfaGVhZGVyOyBfIH0gd2luZG93X2luY3JlbWVudCA9XG4gIGxldCBvcGVuIFNjaGVkdWxlciBpblxuICBsZXQgeyBGcmFtZS5zdHJlYW1faWQ7IF8gfSA9IGZyYW1lX2hlYWRlciBpblxuICAoKiBGcm9tIFJGQzc1NDDCpzYuOTpcbiAgICogICBUaGUgV0lORE9XX1VQREFURSBmcmFtZSBjYW4gYmUgc3BlY2lmaWMgdG8gYSBzdHJlYW0gb3IgdG8gdGhlIGVudGlyZVxuICAgKiAgIGNvbm5lY3Rpb24uIEluIHRoZSBmb3JtZXIgY2FzZSwgdGhlIGZyYW1lJ3Mgc3RyZWFtIGlkZW50aWZpZXIgaW5kaWNhdGVzXG4gICAqICAgdGhlIGFmZmVjdGVkIHN0cmVhbTsgaW4gdGhlIGxhdHRlciwgdGhlIHZhbHVlIFwiMFwiIGluZGljYXRlcyB0aGF0IHRoZVxuICAgKiAgIGVudGlyZSBjb25uZWN0aW9uIGlzIHRoZSBzdWJqZWN0IG9mIHRoZSBmcmFtZS4gKilcbiAgaWYgU3RyZWFtX2lkZW50aWZpZXIuaXNfY29ubmVjdGlvbiBzdHJlYW1faWRcbiAgdGhlbiBhZGRfd2luZG93X2luY3JlbWVudCB0IHQuc3RyZWFtcyB3aW5kb3dfaW5jcmVtZW50XG4gIGVsc2VcbiAgICBtYXRjaCBTY2hlZHVsZXIuZ2V0X25vZGUgdC5zdHJlYW1zIHN0cmVhbV9pZCB3aXRoXG4gICAgfCBTb21lIChTdHJlYW0geyBkZXNjcmlwdG9yOyBfIH0gYXMgc3RyZWFtX25vZGUpIC0+XG4gICAgICAobWF0Y2ggZGVzY3JpcHRvci5zdGF0ZSB3aXRoXG4gICAgICB8IElkbGUgLT5cbiAgICAgICAgKCogRnJvbSBSRkM3NTQwwqc1LjE6XG4gICAgICAgICAqICAgaWRsZTogWy4uLl0gUmVjZWl2aW5nIGFueSBmcmFtZSBvdGhlciB0aGFuIEhFQURFUlMgb3IgUFJJT1JJVFkgb25cbiAgICAgICAgICogICBhIHN0cmVhbSBpbiB0aGlzIHN0YXRlIE1VU1QgYmUgdHJlYXRlZCBhcyBhIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgICAgICogICAoU2VjdGlvbiA1LjQuMSkgb2YgdHlwZSBQUk9UT0NPTF9FUlJPUi4gKilcbiAgICAgICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgICAgIHwgQWN0aXZlIF9cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4xOlxuICAgICAgICogICByZXNlcnZlZCAobG9jYWwpOiBbLi4uXSBBIFBSSU9SSVRZIG9yIFdJTkRPV19VUERBVEUgZnJhbWUgTUFZIGJlXG4gICAgICAgKiAgIHJlY2VpdmVkIGluIHRoaXMgc3RhdGUuICopXG4gICAgICB8IFJlc2VydmVkIF8gLT5cbiAgICAgICAgYWRkX3dpbmRvd19pbmNyZW1lbnQgdCBzdHJlYW1fbm9kZSB3aW5kb3dfaW5jcmVtZW50XG4gICAgICB8IENsb3NlZCBfIC0+XG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4xOlxuICAgICAgICAgKiAgIEVuZHBvaW50cyBNVVNUIGlnbm9yZSBXSU5ET1dfVVBEQVRFIG9yIFJTVF9TVFJFQU0gZnJhbWVzIHJlY2VpdmVkXG4gICAgICAgICAqICAgaW4gdGhpcyBzdGF0ZSwgdGhvdWdoIGVuZHBvaW50cyBNQVkgY2hvb3NlIHRvIHRyZWF0IGZyYW1lcyB0aGF0XG4gICAgICAgICAqICAgYXJyaXZlIGEgc2lnbmlmaWNhbnQgdGltZSBhZnRlciBzZW5kaW5nIEVORF9TVFJFQU0gYXMgYSBjb25uZWN0aW9uXG4gICAgICAgICAqICAgZXJyb3IgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgICAgICgpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgaWYgbm90ICh3YXNfY2xvc2VkX29yX2ltcGxpY2l0bHlfY2xvc2VkIHQgc3RyZWFtX2lkKVxuICAgICAgdGhlblxuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgICAgICogICBpZGxlOiBbLi4uXSBSZWNlaXZpbmcgYW55IGZyYW1lIG90aGVyIHRoYW4gSEVBREVSUyBvciBQUklPUklUWSBvblxuICAgICAgICAgKiAgIGEgc3RyZWFtIGluIHRoaXMgc3RhdGUgTVVTVCBiZSB0cmVhdGVkIGFzIGEgY29ubmVjdGlvbiBlcnJvclxuICAgICAgICAgKiAgIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlIFBST1RPQ09MX0VSUk9SLiAqKVxuICAgICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvclxuXG5sZXQgcHJvY2Vzc19jb250aW51YXRpb25fZnJhbWUgdCB7IEZyYW1lLmZyYW1lX2hlYWRlcjsgXyB9IGhlYWRlcnNfYmxvY2sgPVxuICBsZXQgeyBGcmFtZS5zdHJlYW1faWQ7IGZsYWdzOyBfIH0gPSBmcmFtZV9oZWFkZXIgaW5cbiAgbWF0Y2ggU2NoZWR1bGVyLmdldF9ub2RlIHQuc3RyZWFtcyBzdHJlYW1faWQgd2l0aFxuICB8IFNvbWUgKFNjaGVkdWxlci5TdHJlYW0geyBkZXNjcmlwdG9yOyBfIH0gYXMgc3RyZWFtKSAtPlxuICAgIChtYXRjaCBkZXNjcmlwdG9yLnN0YXRlIHdpdGhcbiAgICB8IEFjdGl2ZVxuICAgICAgICAoICggT3BlbiAoUGFydGlhbEhlYWRlcnMgcGFydGlhbF9oZWFkZXJzKVxuICAgICAgICAgIHwgSGFsZkNsb3NlZCAoUGFydGlhbEhlYWRlcnMgcGFydGlhbF9oZWFkZXJzKSApXG4gICAgICAgICwgXyApIC0+XG4gICAgICBoYW5kbGVfaGVhZGVyc19ibG9jayB0IHN0cmVhbSBwYXJ0aWFsX2hlYWRlcnMgZmxhZ3MgaGVhZGVyc19ibG9ja1xuICAgIHwgQWN0aXZlXG4gICAgICAgICggKCBPcGVuIChBY3RpdmVNZXNzYWdlIHsgdHJhaWxlcnNfcGFyc2VyID0gU29tZSBwYXJ0aWFsX2hlYWRlcnM7IF8gfSlcbiAgICAgICAgICB8IEhhbGZDbG9zZWRcbiAgICAgICAgICAgICAgKEFjdGl2ZU1lc3NhZ2UgeyB0cmFpbGVyc19wYXJzZXIgPSBTb21lIHBhcnRpYWxfaGVhZGVyczsgXyB9KSApXG4gICAgICAgICwgXyApIC0+XG4gICAgICBoYW5kbGVfdHJhaWxlcl9oZWFkZXJzIHQgc3RyZWFtIHBhcnRpYWxfaGVhZGVycyBmbGFncyBoZWFkZXJzX2Jsb2NrXG4gICAgfCBfIC0+XG4gICAgICAoKiBUT0RPOiBtYXliZSBuZWVkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgc3RyZWFtIGhhcyBiZWVuIGNsb3NlZFxuICAgICAgICogZHVlIHRvIGEgc3RyZWFtIGVycm9yLiAqKVxuICAgICAgKCogRnJvbSBSRkM3NTQwwqc2LjEwOlxuICAgICAgICogICBBIFJTVF9TVFJFQU0gaXMgdGhlIGxhc3QgZnJhbWUgdGhhdCBhbiBlbmRwb2ludCBjYW4gc2VuZCBvbiBhXG4gICAgICAgKiAgIHN0cmVhbS4gVGhlIHBlZXIgdGhhdCBzZW5kcyB0aGUgUlNUX1NUUkVBTSBmcmFtZSBNVVNUIGJlIHByZXBhcmVkXG4gICAgICAgKiAgIHRvIHJlY2VpdmUgYW55IGZyYW1lcyB0aGF0IHdlcmUgc2VudCBvciBlbnF1ZXVlZCBmb3Igc2VuZGluZyBieVxuICAgICAgICogICB0aGUgcmVtb3RlIHBlZXIuIFRoZXNlIGZyYW1lcyBjYW4gYmUgaWdub3JlZCwgZXhjZXB0IHdoZXJlIHRoZXlcbiAgICAgICAqICAgbW9kaWZ5IGNvbm5lY3Rpb24gc3RhdGUgKHN1Y2ggYXMgdGhlIHN0YXRlIG1haW50YWluZWQgZm9yIGhlYWRlclxuICAgICAgICogICBjb21wcmVzc2lvbiAoU2VjdGlvbiA0LjMpIG9yIGZsb3cgY29udHJvbCkuICopXG4gICAgICByZXBvcnRfY29ubmVjdGlvbl9lcnJvciB0IEVycm9yX2NvZGUuUHJvdG9jb2xFcnJvcilcbiAgfCBOb25lIC0+XG4gICAgKCogRnJvbSBSRkM3NTQwwqc2LjEwOlxuICAgICAqICAgQSBDT05USU5VQVRJT04gZnJhbWUgTVVTVCBiZSBwcmVjZWRlZCBieSBhIEhFQURFUlMsIFBVU0hfUFJPTUlTRSBvclxuICAgICAqICAgQ09OVElOVUFUSU9OIGZyYW1lIHdpdGhvdXQgdGhlIEVORF9IRUFERVJTIGZsYWcgc2V0LiBBIHJlY2lwaWVudCB0aGF0XG4gICAgICogICBvYnNlcnZlcyB2aW9sYXRpb24gb2YgdGhpcyBydWxlIE1VU1QgcmVzcG9uZCB3aXRoIGEgY29ubmVjdGlvbiBlcnJvclxuICAgICAqICAgKFNlY3Rpb24gNS40LjEpIG9mIHR5cGUgUFJPVE9DT0xfRVJST1IuICopXG4gICAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcblxuKCogRnJvbSBSRkM3NTQwwqcxOlxuICogICBIVFRQLzIgWy4uLl0gYWxsb3dzIGludGVybGVhdmluZyBvZiByZXF1ZXN0IGFuZCByZXNwb25zZSBtZXNzYWdlcyBvbiB0aGVcbiAqICAgc2FtZSBjb25uZWN0aW9uIGFuZCB1c2VzIGFuIGVmZmljaWVudCBjb2RpbmcgZm9yIEhUVFAgaGVhZGVyIGZpZWxkcy4gKilcbmxldCBjcmVhdGUgPyhjb25maWcgPSBDb25maWcuZGVmYXVsdCkgP3B1c2hfaGFuZGxlciB+ZXJyb3JfaGFuZGxlciAoKSA9XG4gIGxldCBwdXNoX2hhbmRsZXIgPVxuICAgIG1hdGNoIHB1c2hfaGFuZGxlciB3aXRoXG4gICAgfCBTb21lIHB1c2hfaGFuZGxlciAtPiBwdXNoX2hhbmRsZXJcbiAgICB8IE5vbmUgLT4gZGVmYXVsdF9wdXNoX2hhbmRsZXJcbiAgaW5cbiAgbGV0IHNldHRpbmdzID1cbiAgICB7IChDb25maWcudG9fc2V0dGluZ3MgY29uZmlnKSB3aXRoXG4gICAgICAoKiBJZiB0aGUgY2FsbGVyIGlzIG5vdCBnb2luZyB0byBwcm9jZXNzIFBVU0hfUFJPTUlTRSBmcmFtZXMsIGp1c3RcbiAgICAgICAqIGRpc2FibGUgaXQuICopXG4gICAgICBlbmFibGVfcHVzaCA9XG4gICAgICAgIGNvbmZpZy5lbmFibGVfc2VydmVyX3B1c2ggJiYgcHVzaF9oYW5kbGVyICE9IGRlZmF1bHRfcHVzaF9oYW5kbGVyXG4gICAgfVxuICBpblxuICBsZXQgcmVjIGNvbm5lY3Rpb25fcHJlZmFjZV9oYW5kbGVyIHJlY3ZfZnJhbWUgc2V0dGluZ3NfbGlzdCA9XG4gICAgbGV0IHQgPSBMYXp5LmZvcmNlIHQgaW5cbiAgICAoKiBOb3cgcHJvY2VzcyB0aGUgY2xpZW50J3MgU0VUVElOR1MgZnJhbWUuIGBwcm9jZXNzX3NldHRpbmdzX2ZyYW1lYCB3aWxsXG4gICAgICogdGFrZSBjYXJlIG9mIGNhbGxpbmcgYHdha2V1cF93cml0ZXJgLiAqKVxuICAgIHByb2Nlc3Nfc2V0dGluZ3NfZnJhbWUgdCByZWN2X2ZyYW1lIHNldHRpbmdzX2xpc3RcbiAgYW5kIGZyYW1lX2hhbmRsZXIgciA9XG4gICAgbGV0IHQgPSBMYXp5LmZvcmNlIHQgaW5cbiAgICBtYXRjaCByIHdpdGhcbiAgICB8IEVycm9yIGUgLT4gcmVwb3J0X2Vycm9yIHQgZVxuICAgIHwgT2sgKHsgRnJhbWUuZnJhbWVfcGF5bG9hZDsgZnJhbWVfaGVhZGVyIH0gYXMgZnJhbWUpIC0+XG4gICAgICAobWF0Y2ggdC5yZWNlaXZpbmdfaGVhZGVyc19mb3Jfc3RyZWFtIHdpdGhcbiAgICAgIHwgU29tZSBzdHJlYW1faWRcbiAgICAgICAgd2hlbiAobm90IFN0cmVhbV9pZGVudGlmaWVyLihzdHJlYW1faWQgPT09IGZyYW1lX2hlYWRlci5zdHJlYW1faWQpKVxuICAgICAgICAgICAgIHx8IGZyYW1lX2hlYWRlci5mcmFtZV90eXBlIDw+IENvbnRpbnVhdGlvbiAtPlxuICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzYuMjpcbiAgICAgICAgICogICBBIEhFQURFUlMgZnJhbWUgd2l0aG91dCB0aGUgRU5EX0hFQURFUlMgZmxhZyBzZXQgTVVTVCBiZSBmb2xsb3dlZFxuICAgICAgICAgKiAgIGJ5IGEgQ09OVElOVUFUSU9OIGZyYW1lIGZvciB0aGUgc2FtZSBzdHJlYW0uIEEgcmVjZWl2ZXIgTVVTVCB0cmVhdFxuICAgICAgICAgKiAgIHRoZSByZWNlaXB0IG9mIGFueSBvdGhlciB0eXBlIG9mIGZyYW1lIG9yIGEgZnJhbWUgb24gYSBkaWZmZXJlbnRcbiAgICAgICAgICogICBzdHJlYW0gYXMgYSBjb25uZWN0aW9uIGVycm9yIChTZWN0aW9uIDUuNC4xKSBvZiB0eXBlXG4gICAgICAgICAqICAgUFJPVE9DT0xfRVJST1IuICopXG4gICAgICAgIHJlcG9ydF9jb25uZWN0aW9uX2Vycm9yXG4gICAgICAgICAgdFxuICAgICAgICAgIH5yZWFzb246XG4gICAgICAgICAgICBcIkhFQURFUlMgb3IgUFVTSF9QUk9NSVNFIHdpdGhvdXQgdGhlIEVORF9IRUFERVJTIGZsYWcgc2V0IG11c3QgYmUgXFxcbiAgICAgICAgICAgICBmb2xsb3dlZCBieSBhIENPTlRJTlVBVElPTiBmcmFtZSBmb3IgdGhlIHNhbWUgc3RyZWFtXCJcbiAgICAgICAgICBFcnJvcl9jb2RlLlByb3RvY29sRXJyb3JcbiAgICAgIHwgXyAtPlxuICAgICAgICAobWF0Y2ggZnJhbWVfcGF5bG9hZCB3aXRoXG4gICAgICAgIHwgSGVhZGVycyAoX3ByaW9yaXR5LCBoZWFkZXJzX2Jsb2NrKSAtPlxuICAgICAgICAgIHByb2Nlc3NfaGVhZGVyc19mcmFtZSB0IGZyYW1lIGhlYWRlcnNfYmxvY2tcbiAgICAgICAgfCBEYXRhIGJzIC0+IHByb2Nlc3NfZGF0YV9mcmFtZSB0IGZyYW1lIGJzXG4gICAgICAgIHwgUHJpb3JpdHkgcHJpb3JpdHkgLT4gcHJvY2Vzc19wcmlvcml0eV9mcmFtZSB0IGZyYW1lIHByaW9yaXR5XG4gICAgICAgIHwgUlNUU3RyZWFtIGVycm9yX2NvZGUgLT4gcHJvY2Vzc19yc3Rfc3RyZWFtX2ZyYW1lIHQgZnJhbWUgZXJyb3JfY29kZVxuICAgICAgICB8IFNldHRpbmdzIHNldHRpbmdzIC0+IHByb2Nlc3Nfc2V0dGluZ3NfZnJhbWUgdCBmcmFtZSBzZXR0aW5nc1xuICAgICAgICB8IFB1c2hQcm9taXNlIChwcm9taXNlZF9zdHJlYW1faWQsIGJzKSAtPlxuICAgICAgICAgIHByb2Nlc3NfcHVzaF9wcm9taXNlX2ZyYW1lIHQgZnJhbWUgcHJvbWlzZWRfc3RyZWFtX2lkIGJzXG4gICAgICAgIHwgUGluZyBkYXRhIC0+IHByb2Nlc3NfcGluZ19mcmFtZSB0IGZyYW1lIGRhdGFcbiAgICAgICAgfCBHb0F3YXkgKGxhc3Rfc3RyZWFtX2lkLCBlcnJvciwgZGF0YSkgLT5cbiAgICAgICAgICBwcm9jZXNzX2dvYXdheV9mcmFtZSB0IGZyYW1lIH5sYXN0X3N0cmVhbV9pZCB+ZGF0YSBlcnJvclxuICAgICAgICB8IFdpbmRvd1VwZGF0ZSB3aW5kb3dfc2l6ZSAtPlxuICAgICAgICAgIHByb2Nlc3Nfd2luZG93X3VwZGF0ZV9mcmFtZSB0IGZyYW1lIHdpbmRvd19zaXplXG4gICAgICAgIHwgQ29udGludWF0aW9uIGhlYWRlcnNfYmxvY2sgLT5cbiAgICAgICAgICBwcm9jZXNzX2NvbnRpbnVhdGlvbl9mcmFtZSB0IGZyYW1lIGhlYWRlcnNfYmxvY2tcbiAgICAgICAgfCBVbmtub3duIF8gLT5cbiAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuMTpcbiAgICAgICAgICAgKiAgIEZyYW1lcyBvZiB1bmtub3duIHR5cGVzIGFyZSBpZ25vcmVkLiAqKVxuICAgICAgICAgICgpKSlcbiAgYW5kIHQgPVxuICAgIGxhenlcbiAgICAgIHsgc2V0dGluZ3NcbiAgICAgIDsgY29uZmlnXG4gICAgICAgICgqIEZyb20gUkZDNzU0MMKnNS4xLjE6XG4gICAgICAgICAqICAgU3RyZWFtcyBpbml0aWF0ZWQgYnkgYSBjbGllbnQgTVVTVCB1c2Ugb2RkLW51bWJlcmVkIHN0cmVhbVxuICAgICAgICAgKiAgIGlkZW50aWZpZXJzICopXG4gICAgICA7IGN1cnJlbnRfc3RyZWFtX2lkID0gLTFsXG4gICAgICA7IG1heF9wdXNoZWRfc3RyZWFtX2lkID0gMGxcbiAgICAgIDsgY3VycmVudF9zZXJ2ZXJfc3RyZWFtcyA9IDBcbiAgICAgIDsgcmVjZWl2aW5nX2hlYWRlcnNfZm9yX3N0cmVhbSA9IE5vbmVcbiAgICAgIDsgZGlkX3NlbmRfZ29fYXdheSA9IGZhbHNlXG4gICAgICA7IHVuYWNrZWRfc2V0dGluZ3MgPSAwXG4gICAgICA7IHBlbmRpbmdfcGluZ3MgPSBRdWV1ZS5jcmVhdGUgKClcbiAgICAgIDsgZXJyb3JfaGFuZGxlclxuICAgICAgOyBwdXNoX2hhbmRsZXJcbiAgICAgIDsgcmVhZGVyID1cbiAgICAgICAgICBSZWFkZXIuY2xpZW50X2ZyYW1lc1xuICAgICAgICAgICAgfm1heF9mcmFtZV9zaXplOnNldHRpbmdzLm1heF9mcmFtZV9zaXplXG4gICAgICAgICAgICBjb25uZWN0aW9uX3ByZWZhY2VfaGFuZGxlclxuICAgICAgICAgICAgZnJhbWVfaGFuZGxlclxuICAgICAgOyB3cml0ZXIgPSBXcml0ZXIuY3JlYXRlIHNldHRpbmdzLm1heF9mcmFtZV9zaXplXG4gICAgICA7IHN0cmVhbXMgPVxuICAgICAgICAgIFNjaGVkdWxlci5tYWtlX3Jvb3QgKClcbiAgICAgICAgICAoKiBGcm9tIFJGQzc1NDDCpzQuMzpcbiAgICAgICAgICAgKiAgIEhlYWRlciBjb21wcmVzc2lvbiBpcyBzdGF0ZWZ1bC4gT25lIGNvbXByZXNzaW9uIGNvbnRleHQgYW5kIG9uZVxuICAgICAgICAgICAqICAgZGVjb21wcmVzc2lvbiBjb250ZXh0IGFyZSB1c2VkIGZvciB0aGUgZW50aXJlIGNvbm5lY3Rpb24uICopXG4gICAgICA7IGhwYWNrX2VuY29kZXIgPSBIcGFjay5FbmNvZGVyLihjcmVhdGUgc2V0dGluZ3MuaGVhZGVyX3RhYmxlX3NpemUpXG4gICAgICA7IGhwYWNrX2RlY29kZXIgPSBIcGFjay5EZWNvZGVyLihjcmVhdGUgc2V0dGluZ3MuaGVhZGVyX3RhYmxlX3NpemUpXG4gICAgICB9XG4gIGluXG4gIGxldCB0ID0gTGF6eS5mb3JjZSB0IGluXG4gICgqIENoZWNrIGlmIHRoZSBzZXR0aW5ncyBmb3IgdGhlIGNvbm5lY3Rpb24gYXJlIGRpZmZlcmVudCB0aGFuIHRoZSBkZWZhdWx0XG4gICAqIEhUVFAvMiBzZXR0aW5ncy4gSW4gdGhlIGV2ZW50IHRoYXQgdGhleSBhcmUsIHdlIG5lZWQgdG8gc2VuZCBhIG5vbi1lbXB0eVxuICAgKiBTRVRUSU5HUyBmcmFtZSBhZHZlcnRpc2luZyBvdXIgY29uZmlndXJhdGlvbi4gKilcbiAgbGV0IHNldHRpbmdzID0gU2V0dGluZ3Muc2V0dGluZ3NfZm9yX3RoZV9jb25uZWN0aW9uIHQuc2V0dGluZ3MgaW5cbiAgKCogRnJvbSBSRkM3NTQwwqc2LjkuMjpcbiAgICogICBXaGVuIGFuIEhUVFAvMiBjb25uZWN0aW9uIGlzIGZpcnN0IGVzdGFibGlzaGVkLCBuZXcgc3RyZWFtcyBhcmUgY3JlYXRlZFxuICAgKiAgIHdpdGggYW4gaW5pdGlhbCBmbG93LWNvbnRyb2wgd2luZG93IHNpemUgb2YgNjUsNTM1IG9jdGV0cy4gVGhlXG4gICAqICAgY29ubmVjdGlvbiBmbG93LWNvbnRyb2wgd2luZG93IGlzIGFsc28gNjUsNTM1IG9jdGV0cy5cbiAgICpcbiAgICogWFhYKGFubW9udGVpcm8pOiB0aGUgc3RhcnRpbmcgc2V0dGluZyBmb3IgdGhlIGluaXRpYWwgd2luZG93IHNpemUgZm9yXG4gICAqIF9zZW5kaW5nXyBpcyB0aGUgZGVmYXVsdCBvZiA2NTUzNSBvY3RldHMuIFdlJ3JlIGVmZmVjdGl2ZWx5IG92ZXJ3cml0aW5nIGl0XG4gICAqIGhlcmUgdG8gZW5mb3JjZSB0aGlzIGRlZmF1bHQgYWZ0ZXIgYWJ1c2luZyB0aGUgc2V0dGluZ3MgaW1wbGVtZW50YXRpb24gdG9cbiAgICogc2VuZCBvdXIgKHJlY2VpdmluZykgaW4tZmxvdyBzZXR0aW5nIHRvIHRoZSBwZWVyLiBUaHJvdWdob3V0IG90aGVyIHBhcnRzXG4gICAqIG9mIHRoZSBjb2RlIHdlIChzaG91bGQpIHJlZmVyIHRvIGl0IHRocm91Z2hcbiAgICogW3QuY29uZmlnLmluaXRpYWxfd2luZG93X3NpemVdLiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBjbGVhbmVkIHVwIGluIHRoZVxuICAgKiBmdXR1cmUuICopXG4gIHQuc2V0dGluZ3MgPC1cbiAgICB7IHQuc2V0dGluZ3Mgd2l0aFxuICAgICAgaW5pdGlhbF93aW5kb3dfc2l6ZSA9IFNldHRpbmdzLmRlZmF1bHQuaW5pdGlhbF93aW5kb3dfc2l6ZVxuICAgIH07XG4gICgqIFNlbmQgdGhlIGNsaWVudCBjb25uZWN0aW9uIHByZWZhY2UgKilcbiAgV3JpdGVyLndyaXRlX2Nvbm5lY3Rpb25fcHJlZmFjZSB0LndyaXRlciBzZXR0aW5ncztcbiAgKCogSWYgYSBoaWdoZXIgdmFsdWUgZm9yIGluaXRpYWwgd2luZG93IHNpemUgaXMgY29uZmlndXJlZCwgYWRkIG1vcmUgdG9rZW5zXG4gICAqIHRvIHRoZSBjb25uZWN0aW9uICh3ZSBoYXZlIG5vIHN0cmVhbXMgYXQgdGhpcyBwb2ludCkgLS0gdGhlIHBlZXIgaXNcbiAgICogYWxsb3dlZCB0byBzZW5kIG1vcmUgdGhhbiB0aGUgZGVmYXVsdHMuXG4gICAqXG4gICAqIEZyb20gUkZDNzU0MMKnNi45LjI6XG4gICAqICAgVGhlIGNvbm5lY3Rpb24gZmxvdy1jb250cm9sIHdpbmRvdyBjYW4gb25seSBiZSBjaGFuZ2VkIHVzaW5nXG4gICAqICAgV0lORE9XX1VQREFURSBmcmFtZXMuICopXG4gIChpZiB0LmNvbmZpZy5pbml0aWFsX3dpbmRvd19zaXplID4gU2V0dGluZ3MuZGVmYXVsdC5pbml0aWFsX3dpbmRvd19zaXplXG4gICB0aGVuXG4gICAgIGxldCBkaWZmID1cbiAgICAgICBJbnQzMi5zdWJcbiAgICAgICAgIHQuY29uZmlnLmluaXRpYWxfd2luZG93X3NpemVcbiAgICAgICAgIFNldHRpbmdzLmRlZmF1bHQuaW5pdGlhbF93aW5kb3dfc2l6ZVxuICAgICBpblxuICAgICBzZW5kX3dpbmRvd191cGRhdGUgdCB0LnN0cmVhbXMgZGlmZik7XG4gIHRcblxubGV0IGNyZWF0ZV9hbmRfYWRkX3N0cmVhbSB0IH5lcnJvcl9oYW5kbGVyID1cbiAgbGV0IG1heF9mcmFtZV9zaXplID0gdC5zZXR0aW5ncy5tYXhfZnJhbWVfc2l6ZSBpblxuICB0LmN1cnJlbnRfc3RyZWFtX2lkIDwtIEludDMyLmFkZCB0LmN1cnJlbnRfc3RyZWFtX2lkIDJsO1xuICBsZXQgc3RyZWFtX2lkID0gdC5jdXJyZW50X3N0cmVhbV9pZCBpblxuICBsZXQgcmVzcGQgPVxuICAgIFN0cmVhbS5jcmVhdGVcbiAgICAgIHN0cmVhbV9pZFxuICAgICAgfm1heF9mcmFtZV9zaXplXG4gICAgICB0LndyaXRlclxuICAgICAgZXJyb3JfaGFuZGxlclxuICAgICAgKG9uX2Nsb3NlX3N0cmVhbSB0IHN0cmVhbV9pZClcbiAgaW5cbiAgKCogVE9ETzogY3VzdG9tIHByaW9yaXR5ICopXG4gIGxldCBfc3RyZWFtIDogU2NoZWR1bGVyLm5vbnJvb3QgU2NoZWR1bGVyLm5vZGUgPVxuICAgIFNjaGVkdWxlci5hZGRcbiAgICAgIHQuc3RyZWFtc1xuICAgICAgfnByaW9yaXR5OlByaW9yaXR5LmRlZmF1bHRfcHJpb3JpdHlcbiAgICAgIH5pbml0aWFsX3NlbmRfd2luZG93X3NpemU6dC5zZXR0aW5ncy5pbml0aWFsX3dpbmRvd19zaXplXG4gICAgICB+aW5pdGlhbF9yZWN2X3dpbmRvd19zaXplOnQuY29uZmlnLmluaXRpYWxfd2luZG93X3NpemVcbiAgICAgIHJlc3BkXG4gIGluXG4gIHJlc3BkXG5cbigqIE1lYW50IHRvIGJlIGNhbGxlZCBhZnRlciByZWNlaXZpbmcgYW4gSFRUUC8xLjEgYDEwMSBTd2l0Y2hpbmdfcHJvdG9jb2xzYFxuICogcmVzcG9uc2UgdXBncmFkaW5nIHRvIEhUVFAvMi4gKilcbmxldCBjcmVhdGVfaDJjXG4gICAgP2NvbmZpZ1xuICAgID9wdXNoX2hhbmRsZXJcbiAgICB+aHR0cF9yZXF1ZXN0XG4gICAgfmVycm9yX2hhbmRsZXJcbiAgICAocmVzcG9uc2VfaGFuZGxlciwgcmVzcG9uc2VfZXJyb3JfaGFuZGxlcilcbiAgPVxuICBsZXQgeyBIdHRwYWYuUmVxdWVzdC50YXJnZXQ7IG1ldGg7IF8gfSA9IGh0dHBfcmVxdWVzdCBpblxuICBtYXRjaCBIZWFkZXJzLm9mX2h0dHAxIGh0dHBfcmVxdWVzdCB3aXRoXG4gIHwgT2sgaGVhZGVycyAtPlxuICAgICgqIEZyb20gUkZDNzU0MMKnMy4yOlxuICAgICAqICAgVXBvbiByZWNlaXZpbmcgdGhlIDEwMSByZXNwb25zZSwgdGhlIGNsaWVudCBNVVNUIHNlbmQgYSBjb25uZWN0aW9uXG4gICAgICogICBwcmVmYWNlIChTZWN0aW9uIDMuNSksIHdoaWNoIGluY2x1ZGVzIGEgU0VUVElOR1MgZnJhbWUuICopXG4gICAgbGV0IHQgPSBjcmVhdGUgP2NvbmZpZyA/cHVzaF9oYW5kbGVyIH5lcnJvcl9oYW5kbGVyICgpIGluXG4gICAgbGV0IHJlc3BkID0gY3JlYXRlX2FuZF9hZGRfc3RyZWFtIHQgfmVycm9yX2hhbmRsZXI6cmVzcG9uc2VfZXJyb3JfaGFuZGxlciBpblxuICAgIGFzc2VydCAoU3RyZWFtX2lkZW50aWZpZXIuKHQuY3VycmVudF9zdHJlYW1faWQgPT09IDFsKSk7XG4gICAgYXNzZXJ0IChTdHJlYW1faWRlbnRpZmllci4ocmVzcGQuaWQgPT09IDFsKSk7XG4gICAgbGV0IHJlcXVlc3QgPSBSZXF1ZXN0LmNyZWF0ZSB+aGVhZGVycyB+c2NoZW1lOlwiaHR0cFwiIG1ldGggdGFyZ2V0IGluXG4gICAgKCogRnJvbSBSRkM3NTQwwqczLjI6XG4gICAgICogICBUaGUgSFRUUC8xLjEgcmVxdWVzdCB0aGF0IGlzIHNlbnQgcHJpb3IgdG8gdXBncmFkZSBpcyBhc3NpZ25lZCBhXG4gICAgICogICBzdHJlYW0gaWRlbnRpZmllciBvZiAxIChzZWUgU2VjdGlvbiA1LjEuMSkgd2l0aCBkZWZhdWx0IHByaW9yaXR5XG4gICAgICogICB2YWx1ZXMgKFNlY3Rpb24gNS4zLjUpLiBTdHJlYW0gMSBpcyBpbXBsaWNpdGx5IFwiaGFsZi1jbG9zZWRcIiBmcm9tIHRoZVxuICAgICAqICAgY2xpZW50IHRvd2FyZCB0aGUgc2VydmVyIChzZWUgU2VjdGlvbiA1LjEpLCBzaW5jZSB0aGUgcmVxdWVzdCBpc1xuICAgICAqICAgY29tcGxldGVkIGFzIGFuIEhUVFAvMS4xIHJlcXVlc3QuICopXG4gICAgcmVzcGQuc3RhdGUgPC1cbiAgICAgIEFjdGl2ZVxuICAgICAgICAoIEhhbGZDbG9zZWQgV2FpdGluZ0ZvclBlZXJcbiAgICAgICAgLCB7IHJlcXVlc3RcbiAgICAgICAgICAgICgqIFRoZSByZXF1ZXN0IGJvZHkgaXMgbm8gbW9yZSB0aGFuIGEgcGxhY2Vob2xkZXIuIFRoZSBIVFRQLzEuMVxuICAgICAgICAgICAgICogY29ubmVjdGlvbiB0aGF0IHdlJ3JlIHVwZ3JhZGluZyBmcm9tIGFscmVhZHkgc2VudCBpdCB0byB0aGVcbiAgICAgICAgICAgICAqIHNlcnZlci4gQXBwbGljYXRpb24gY29kZSBrbm93cyB3aGF0IGl0IGlzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEZyb20gUkZDNzU0MMKnMy4yOlxuICAgICAgICAgICAgICogICBSZXF1ZXN0cyB0aGF0IGNvbnRhaW4gYSBwYXlsb2FkIGJvZHkgTVVTVCBiZSBzZW50IGluIHRoZWlyXG4gICAgICAgICAgICAgKiAgIGVudGlyZXR5IGJlZm9yZSB0aGUgY2xpZW50IGNhbiBzZW5kIEhUVFAvMiBmcmFtZXMuIFRoaXMgbWVhbnNcbiAgICAgICAgICAgICAqICAgdGhhdCBhIGxhcmdlIHJlcXVlc3QgY2FuIGJsb2NrIHRoZSB1c2Ugb2YgdGhlIGNvbm5lY3Rpb24gdW50aWxcbiAgICAgICAgICAgICAqICAgaXQgaXMgY29tcGxldGVseSBzZW50LiAqKVxuICAgICAgICAgIDsgcmVxdWVzdF9ib2R5ID0gQm9keS5Xcml0ZXIuY3JlYXRlX2VtcHR5IH53cml0ZXI6dC53cml0ZXJcbiAgICAgICAgICA7IHJlc3BvbnNlX2hhbmRsZXJcbiAgICAgICAgICA7IHRyYWlsZXJzX2hhbmRsZXIgPSBpZ25vcmVcbiAgICAgICAgICB9ICk7XG4gICAgV3JpdGVyLndha2V1cCB0LndyaXRlcjtcbiAgICBPayB0XG4gIHwgRXJyb3IgbXNnIC0+IEVycm9yIG1zZ1xuXG5sZXQgcmVxdWVzdFxuICAgIHRcbiAgICA/KGZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHkgPSBmYWxzZSlcbiAgICA/KHRyYWlsZXJzX2hhbmRsZXIgPSBpZ25vcmUpXG4gICAgcmVxdWVzdFxuICAgIH5lcnJvcl9oYW5kbGVyXG4gICAgfnJlc3BvbnNlX2hhbmRsZXJcbiAgPVxuICBsZXQgbWF4X2ZyYW1lX3NpemUgPSB0LnNldHRpbmdzLm1heF9mcmFtZV9zaXplIGluXG4gIGxldCByZXNwZCA9IGNyZWF0ZV9hbmRfYWRkX3N0cmVhbSB0IH5lcnJvcl9oYW5kbGVyIGluXG4gIGxldCByZXF1ZXN0X2JvZHkgPVxuICAgIEJvZHkuV3JpdGVyLmNyZWF0ZSAoQmlnc3RyaW5nYWYuY3JlYXRlIG1heF9mcmFtZV9zaXplKSB+d3JpdGVyOnQud3JpdGVyXG4gIGluXG4gIGxldCBmcmFtZV9pbmZvID1cbiAgICBXcml0ZXIubWFrZV9mcmFtZV9pbmZvXG4gICAgICB+bWF4X2ZyYW1lX3NpemU6dC5zZXR0aW5ncy5tYXhfZnJhbWVfc2l6ZVxuICAgICAgfmZsYWdzOkZsYWdzLmRlZmF1bHRfZmxhZ3NcbiAgICAgIHJlc3BkLmlkXG4gIGluXG4gIFdyaXRlci53cml0ZV9yZXF1ZXN0X2hlYWRlcnNcbiAgICB0LndyaXRlclxuICAgIHQuaHBhY2tfZW5jb2RlclxuICAgIH5wcmlvcml0eTpcbiAgICAgICgqIFRPRE86IGFsbG93IHNldHRpbmcgdGhlIHByaW9yaXR5IG9mIHRoZSByZXF1ZXN0LiAqKVxuICAgICAgUHJpb3JpdHkuZGVmYXVsdF9wcmlvcml0eVxuICAgIGZyYW1lX2luZm9cbiAgICByZXF1ZXN0O1xuICByZXNwZC5zdGF0ZSA8LVxuICAgIEFjdGl2ZVxuICAgICAgKCBPcGVuIFdhaXRpbmdGb3JQZWVyXG4gICAgICAsIHsgcmVxdWVzdDsgcmVxdWVzdF9ib2R5OyByZXNwb25zZV9oYW5kbGVyOyB0cmFpbGVyc19oYW5kbGVyIH0gKTtcbiAgaWYgbm90IGZsdXNoX2hlYWRlcnNfaW1tZWRpYXRlbHkgdGhlbiBXcml0ZXIueWllbGQgdC53cml0ZXI7XG4gIFdyaXRlci53YWtldXAgdC53cml0ZXI7XG4gICgqIENsb3NpbmcgdGhlIHJlcXVlc3QgYm9keSBwdXRzIHRoZSBzdHJlYW0gaW4gdGhlIGhhbGYtY2xvc2VkIChsb2NhbCkgc3RhdGUuXG4gICAqIFRoaXMgaXMgaGFuZGxlZCBieSB7IVJlc3BkLmZsdXNoX3JlcXVlc3RfYm9keX0sIHdoaWNoIHRyYW5zaXRpb25zIHRoZVxuICAgKiBzdGF0ZSBvbmNlIGl0IHZlcmlmaWVzIHRoYXQgdGhlcmUncyBubyBtb3JlIGRhdGEgdG8gc2VuZCBmb3IgdGhlXG4gICAqIHN0cmVhbS4gKilcbiAgcmVxdWVzdF9ib2R5XG5cbigqIFhYWDogd2Ugc3RvcmUgUElORyBjYWxsYmFja3MgaW4gRklGTyBvcmRlci4gV291bGQgaXQgZXZlciBiZSB0aGUgY2FzZSB0aGF0XG4gKiB0aGUgcmVjZWlwdCBvZiBhIFBJTkcgZnJhbWUgYWNrbm93bGVkZ2VzIGEgbGF0ZXIgY2FsbGJhY2s/IElmIHNvLCB3ZSdkIG5lZWRcbiAqIHRvIGRpc2FsbG93IHNlbmRpbmcgY3VzdG9tIFBJTkcgcGF5bG9hZHMgYW5kIGdlbmVyYXRlIGEgcmFuZG9tIHBheWxvYWQgdGhhdFxuICogd2Ugc3RvcmUgaW4gYSBIYXNodGJsLiAqKVxubGV0IHBpbmcgdCA/cGF5bG9hZCA/KG9mZiA9IDApIGNhbGxiYWNrID1cbiAgbGV0IHBheWxvYWQgPVxuICAgIG1hdGNoIHBheWxvYWQgd2l0aFxuICAgIHwgTm9uZSAtPiBTZXJpYWxpemUuZGVmYXVsdF9waW5nX3BheWxvYWRcbiAgICB8IFNvbWUgcGF5bG9hZCAtPlxuICAgICAgaWYgQmlnc3RyaW5nYWYubGVuZ3RoIHBheWxvYWQgLSBvZmYgPCA4XG4gICAgICB0aGVuIGZhaWx3aXRoIFwiUElORyBwYXlsb2FkIG11c3QgaGF2ZSBhdCBsZWFzdCA4IG9jdGV0cyBpbiBsZW5ndGhcIjtcbiAgICAgIHBheWxvYWRcbiAgaW5cbiAgKCogRnJvbSBSRkM3NTQwwqc2Ljc6XG4gICAqICAgQUNLICgweDEpOiBXaGVuIHNldCwgYml0IDAgaW5kaWNhdGVzIHRoYXQgdGhpcyBQSU5HIGZyYW1lIGlzIGEgUElOR1xuICAgKiAgIHJlc3BvbnNlLlxuICAgKlxuICAgKiAgIE5vdGU6IHRoaXMgaXMgbm90IGEgUElORyByZXNwb25zZSwgcXVpdGUgdGhlIG9wcG9zaXRlLCBzbyB3ZSBkb24ndCBzZXRcbiAgICogICB0aGUgQUNLIGZsYWcuICopXG4gIGxldCBmcmFtZV9pbmZvID0gV3JpdGVyLm1ha2VfZnJhbWVfaW5mbyBTdHJlYW1faWRlbnRpZmllci5jb25uZWN0aW9uIGluXG4gIFF1ZXVlLmFkZCBjYWxsYmFjayB0LnBlbmRpbmdfcGluZ3M7XG4gIFdyaXRlci53cml0ZV9waW5nIHQud3JpdGVyIGZyYW1lX2luZm8gfm9mZiBwYXlsb2FkO1xuICBXcml0ZXIud2FrZXVwIHQud3JpdGVyXG5cbmxldCBuZXh0X3JlYWRfb3BlcmF0aW9uIHQgPVxuICBpZiBSZWFkZXIuaXNfY2xvc2VkIHQucmVhZGVyIHRoZW4gc2h1dGRvd25fcmVhZGVyIHQ7XG4gIG1hdGNoIFJlYWRlci5uZXh0IHQucmVhZGVyIHdpdGhcbiAgfCAoYFJlYWQgfCBgQ2xvc2UpIGFzIG9wZXJhdGlvbiAtPiBvcGVyYXRpb25cbiAgfCBgRXJyb3IgZSAtPlxuICAgIHJlcG9ydF9lcnJvciB0IGU7XG4gICAgKG1hdGNoIGUgd2l0aFxuICAgIHwgQ29ubmVjdGlvbkVycm9yIF8gLT5cbiAgICAgICgqIEZyb20gUkZDNzU0MMKnNS40LjE6XG4gICAgICAgKiAgIEEgY29ubmVjdGlvbiBlcnJvciBpcyBhbnkgZXJyb3IgdGhhdCBwcmV2ZW50cyBmdXJ0aGVyIHByb2Nlc3NpbmdcbiAgICAgICAqICAgb2YgdGhlIGZyYW1lIGxheWVyIG9yIGNvcnJ1cHRzIGFueSBjb25uZWN0aW9uIHN0YXRlLiAqKVxuICAgICAgYENsb3NlXG4gICAgfCBTdHJlYW1FcnJvciBfIC0+XG4gICAgICAoKiBGcm9tIFJGQzc1NDDCpzUuNC4yOlxuICAgICAgICogICBBIHN0cmVhbSBlcnJvciBpcyBhbiBlcnJvciByZWxhdGVkIHRvIGEgc3BlY2lmaWMgc3RyZWFtIHRoYXQgZG9lc1xuICAgICAgICogICBub3QgYWZmZWN0IHByb2Nlc3Npbmcgb2Ygb3RoZXIgc3RyZWFtcy4gKilcbiAgICAgIGBSZWFkKVxuXG5sZXQgcmVhZCB0IGJzIH5vZmYgfmxlbiA9IFJlYWRlci5yZWFkX3dpdGhfbW9yZSB0LnJlYWRlciBicyB+b2ZmIH5sZW4gSW5jb21wbGV0ZVxuXG5sZXQgdW5leHBlY3RlZF9lb2YgdCA9XG4gIFNjaGVkdWxlci5pdGVyXG4gICAgfmY6KGZ1biAoU3RyZWFtIHsgZGVzY3JpcHRvcjsgXyB9KSAtPlxuICAgICAgbWF0Y2ggZGVzY3JpcHRvci5zdGF0ZSB3aXRoXG4gICAgICB8IElkbGUgfCBSZXNlcnZlZCBfIHwgQ2xvc2VkIF8gLT4gKClcbiAgICAgIHwgQWN0aXZlIF8gLT5cbiAgICAgICAgUmVzcGQucmVwb3J0X2Vycm9yXG4gICAgICAgICAgZGVzY3JpcHRvclxuICAgICAgICAgIChgTWFsZm9ybWVkX3Jlc3BvbnNlIFwidW5leHBlY3RlZCBlb2ZcIilcbiAgICAgICAgICBQcm90b2NvbEVycm9yKVxuICAgIHQuc3RyZWFtcztcbiAgUXVldWUuaXRlciAoZnVuIGYgLT4gZiAoRXJyb3IgYEVPRikpIHQucGVuZGluZ19waW5ncztcbiAgcmVwb3J0X2Nvbm5lY3Rpb25fZXJyb3IgdCB+cmVhc29uOlwidW5leHBlY3RlZCBlb2ZcIiBQcm90b2NvbEVycm9yXG5cbmxldCByZWFkX2VvZiB0IGJzIH5vZmYgfmxlbiA9XG4gIGxldCBieXRlc19yZWFkID0gUmVhZGVyLnJlYWRfd2l0aF9tb3JlIHQucmVhZGVyIGJzIH5vZmYgfmxlbiBDb21wbGV0ZSBpblxuICB1bmV4cGVjdGVkX2VvZiB0O1xuICBieXRlc19yZWFkXG5cbigqIFhYWChhbm1vbnRlaXJvKTogdGhpcyBmdW5jdGlvbiBpcyBoZXJlIHRvIHBsZWFzZSB0aGUgR2x1dGVuIGBSVU5USU1FYFxuICogaW50ZXJmYWNlLlxuICpcbiAqIFdlIGRvbid0IGV4cGVjdCB0aGlzIGZ1bmN0aW9uIHRvIGV2ZXIgYmUgY2FsbGVkLiBIMiBuZXZlciBpc3N1ZXMgYFlpZWxkYFxuICogY29tbWFuZHMgYmVjYXVzZSB0aGUgY29ubmVjdGlvbiBpcyBtdWx0aXBsZXhlZCwgYW5kIGl0J3MgdGhlcmVmb3JlIGFsd2F5c1xuICogbG9va2luZyB0byByZWFkIGZyYW1lcyBmcm9tIHRoZSBwZWVyLiAqKVxubGV0IHlpZWxkX3JlYWRlciBfdCBrID0gayAoKVxuXG5sZXQgbmV4dF93cml0ZV9vcGVyYXRpb24gdCA9XG4gIGZsdXNoX3JlcXVlc3RfYm9keSB0O1xuICBXcml0ZXIubmV4dCB0LndyaXRlclxuXG5sZXQgeWllbGRfd3JpdGVyIHQgayA9IFdyaXRlci5vbl93YWtldXBfd3JpdGVyIHQud3JpdGVyIGtcbmxldCByZXBvcnRfd3JpdGVfcmVzdWx0IHQgcmVzdWx0ID0gV3JpdGVyLnJlcG9ydF9yZXN1bHQgdC53cml0ZXIgcmVzdWx0XG4iXX0=
