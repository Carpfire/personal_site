// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Bigstring_unix
//# unitInfo: Requires: Core, Core__Bigstring, Core__Or_error, Core_unix, Core_unix__File_descr, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdlib, Stdlib__Bigarray, Stdlib__Callback
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_min_len = ": min_len (",
    cst_Bigstring_unix$0 = "Bigstring_unix",
    cst_bigstring_unix$0 = "bigstring_unix",
    cst_bigstring_unix_src_bigstri = "bigstring_unix/src/bigstring_unix.ml",
    cst_pread = "pread",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    loc$5 = "recvmmsg_assume_fd_is_nonblocking",
    loc$4 = "output",
    loc$3 = "pwrite",
    loc$2 = "input",
    loc$1 = cst_pread,
    loc$0 = cst_pread,
    loc = "read",
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Core_unix = global_data.Core_unix,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Bigstring = global_data.Core__Bigstring,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib = global_data.Stdlib,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Core_unix_File_descr = global_data.Core_unix__File_descr,
    Core_Or_error = global_data.Core__Or_error;
   caml_call1(Ppx_module_timer_runtime[4], cst_Bigstring_unix$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_bigstring_unix$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_bigstring_unix_src_bigstri);
   caml_call2
    (Ppx_inline_test_lib[6], cst_bigstring_unix$0, "bigstring_unix.ml");
   var
    quickcheck_generator = Core_Bigstring[1],
    quickcheck_observer = Core_Bigstring[2],
    quickcheck_shrinker = Core_Bigstring[3],
    compare = Core_Bigstring[4],
    t_of_sexp = Core_Bigstring[5],
    sexp_of_t = Core_Bigstring[6],
    compare_t_frozen = Core_Bigstring[7],
    hash_fold_t_frozen = Core_Bigstring[8],
    hash_t_frozen = Core_Bigstring[9],
    sexp_of_t_frozen = Core_Bigstring[10],
    t_frozen_of_sexp = Core_Bigstring[11],
    equal = Core_Bigstring[12],
    init = Core_Bigstring[13],
    of_string = Core_Bigstring[14],
    of_bytes = Core_Bigstring[15],
    to_string = Core_Bigstring[16],
    to_bytes = Core_Bigstring[17],
    concat = Core_Bigstring[18],
    check_args = Core_Bigstring[19],
    get_opt_len = Core_Bigstring[20],
    length = Core_Bigstring[21],
    blit = Core_Bigstring[22],
    blito = Core_Bigstring[23],
    unsafe_blit = Core_Bigstring[24],
    sub = Core_Bigstring[25],
    subo = Core_Bigstring[26],
    copy = Core_Bigstring[27],
    memset = Core_Bigstring[32],
    unsafe_memset = Core_Bigstring[33],
    memcmp = Core_Bigstring[34],
    memcmp_bytes = Core_Bigstring[35],
    memcmp_string = Core_Bigstring[36],
    find = Core_Bigstring[37],
    memmem = Core_Bigstring[38],
    get_int8 = Core_Bigstring[39],
    set_int8_exn = Core_Bigstring[40],
    get_uint8 = Core_Bigstring[41],
    set_uint8_exn = Core_Bigstring[42],
    unsafe_get_int8 = Core_Bigstring[43],
    unsafe_set_int8 = Core_Bigstring[44],
    unsafe_get_uint8 = Core_Bigstring[45],
    unsafe_set_uint8 = Core_Bigstring[46],
    get_int16_le = Core_Bigstring[47],
    get_int16_be = Core_Bigstring[48],
    set_int16_le_exn = Core_Bigstring[49],
    set_int16_be_exn = Core_Bigstring[50],
    unsafe_get_int16_le = Core_Bigstring[51],
    unsafe_get_int16_be = Core_Bigstring[52],
    unsafe_set_int16_le = Core_Bigstring[53],
    unsafe_set_int16_be = Core_Bigstring[54],
    get_uint16_le = Core_Bigstring[55],
    get_uint16_be = Core_Bigstring[56],
    set_uint16_le_exn = Core_Bigstring[57],
    set_uint16_be_exn = Core_Bigstring[58],
    unsafe_get_uint16_le = Core_Bigstring[59],
    unsafe_get_uint16_be = Core_Bigstring[60],
    unsafe_set_uint16_le = Core_Bigstring[61],
    unsafe_set_uint16_be = Core_Bigstring[62],
    get_int32_le = Core_Bigstring[63],
    get_int32_be = Core_Bigstring[64],
    set_int32_le_exn = Core_Bigstring[65],
    set_int32_be_exn = Core_Bigstring[66],
    unsafe_get_int32_le = Core_Bigstring[67],
    unsafe_get_int32_be = Core_Bigstring[68],
    unsafe_set_int32_le = Core_Bigstring[69],
    unsafe_set_int32_be = Core_Bigstring[70],
    get_uint32_le = Core_Bigstring[71],
    get_uint32_be = Core_Bigstring[72],
    set_uint32_le_exn = Core_Bigstring[73],
    set_uint32_be_exn = Core_Bigstring[74],
    unsafe_get_uint32_le = Core_Bigstring[75],
    unsafe_get_uint32_be = Core_Bigstring[76],
    unsafe_set_uint32_le = Core_Bigstring[77],
    unsafe_set_uint32_be = Core_Bigstring[78],
    get_int64_le_exn = Core_Bigstring[79],
    get_int64_be_exn = Core_Bigstring[80],
    get_int64_le_trunc = Core_Bigstring[81],
    get_int64_be_trunc = Core_Bigstring[82],
    set_int64_le = Core_Bigstring[83],
    set_int64_be = Core_Bigstring[84],
    unsafe_get_int64_le_exn = Core_Bigstring[85],
    unsafe_get_int64_be_exn = Core_Bigstring[86],
    unsafe_get_int64_le_trunc = Core_Bigstring[87],
    unsafe_get_int64_be_trunc = Core_Bigstring[88],
    unsafe_set_int64_le = Core_Bigstring[89],
    unsafe_set_int64_be = Core_Bigstring[90],
    get_uint64_be_exn = Core_Bigstring[91],
    get_uint64_le_exn = Core_Bigstring[92],
    set_uint64_le_exn = Core_Bigstring[93],
    set_uint64_be_exn = Core_Bigstring[94],
    unsafe_get_uint64_be_exn = Core_Bigstring[95],
    unsafe_get_uint64_le_exn = Core_Bigstring[96],
    unsafe_set_uint64_le = Core_Bigstring[97],
    unsafe_set_uint64_be = Core_Bigstring[98],
    get_int32_t_le = Core_Bigstring[99],
    get_int32_t_be = Core_Bigstring[100],
    set_int32_t_le = Core_Bigstring[101],
    set_int32_t_be = Core_Bigstring[102],
    unsafe_get_int32_t_le = Core_Bigstring[103],
    unsafe_get_int32_t_be = Core_Bigstring[104],
    unsafe_set_int32_t_le = Core_Bigstring[105],
    unsafe_set_int32_t_be = Core_Bigstring[106],
    get_int64_t_le = Core_Bigstring[107],
    get_int64_t_be = Core_Bigstring[108],
    set_int64_t_le = Core_Bigstring[109],
    set_int64_t_be = Core_Bigstring[110],
    unsafe_get_int64_t_le = Core_Bigstring[111],
    unsafe_get_int64_t_be = Core_Bigstring[112],
    unsafe_set_int64_t_le = Core_Bigstring[113],
    unsafe_set_int64_t_be = Core_Bigstring[114],
    get_string = Core_Bigstring[115],
    unsafe_get_string = Core_Bigstring[116],
    create = Core_Bigstring[121],
    sub_shared = Core_Bigstring[122],
    write_bin_prot = Core_Bigstring[123],
    write_bin_prot_known_size = Core_Bigstring[124],
    read_bin_prot = Core_Bigstring[125],
    read_bin_prot_verbose_errors = Core_Bigstring[126],
    get_tail_padded_fixed_string = Core_Bigstring[127],
    get_tail_padded_fixed_string_l = Core_Bigstring[128],
    set_tail_padded_fixed_string = Core_Bigstring[129],
    get_head_padded_fixed_string = Core_Bigstring[130],
    get_head_padded_fixed_string_l = Core_Bigstring[131],
    set_head_padded_fixed_string = Core_Bigstring[132],
    IOError = [248, "Bigstring_unix.IOError", runtime.caml_fresh_oo_id(0)],
    cst_sendmsg_nonblocking_no_sig = "sendmsg_nonblocking_no_sigpipe",
    cst_count_n_srcs = ": count > n_srcs",
    cst_count_n_lens = ": count > n_lens",
    cst_really_output = "really_output",
    cst_writev_nonblocking = "writev_nonblocking",
    cst_writev = "writev",
    cst_count_0 = ": count < 0",
    cst_count_n_iovecs = ": count > n_iovecs",
    cst_write_assume_fd_is_nonbloc = "write_assume_fd_is_nonblocking",
    cst_write = "write",
    cst_sendto_nonblocking_no_sigp = "sendto_nonblocking_no_sigpipe",
    cst_send_nonblocking_no_sigpip = "send_nonblocking_no_sigpipe",
    cst_really_send_no_sigpipe = "really_send_no_sigpipe",
    cst_really_write = "really_write",
    cst_really_input = "really_input",
    cst_read_assume_fd_is_nonblock = "read_assume_fd_is_nonblocking",
    cst_recvfrom_assume_fd_is_nonb = "recvfrom_assume_fd_is_nonblocking",
    cst_recv_peek_assume_fd_is_non = "recv_peek_assume_fd_is_nonblocking",
    cst_really_recv = "really_recv",
    _d_ =
      [0,
       [2,
        0,
        [11,
         cst_min_len,
         [4, 0, 0, 0, [11, ") > len (", [4, 0, 0, 0, [12, 41, 0]]]]]],
       "%s: min_len (%d) > len (%d)"],
    _e_ =
      [0,
       [2, 0, [11, cst_min_len, [4, 0, 0, 0, [11, ") < 0", 0]]]],
       "%s: min_len (%d) < 0"],
    _b_ = [0, "bigstring_unix/src/bigstring_unix.ml.IOError"],
    _c_ = [0, "_none_", 0, -1],
    cst_Bigstring_End_of_file = "Bigstring.End_of_file",
    cst_Bigstring_IOError = "Bigstring.IOError",
    _m_ = [0, cst_bigstring_unix_src_bigstri, 391, 4],
    cst_Bigstring_recvmmsg_assume_ =
      "Bigstring.recvmmsg_assume_fd_is_nonblocking",
    cst_bigstring_unix = cst_bigstring_unix$0,
    cst_Bigstring_unix = cst_Bigstring_unix$0;
   function _a_(param){
    if(param[1] !== IOError)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var
     arg1_002 = param[3],
     arg0_001 = param[2],
     res0_003 = caml_call1(Core[389], arg0_001),
     res1_004 = caml_call1(Core[625], arg1_002);
    return [1, [0, _b_, [0, res0_003, [0, res1_004, 0]]]];
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, IOError, _a_);
   caml_call2(Stdlib_Callback[2], cst_Bigstring_End_of_file, Stdlib[12]);
   caml_call2
    (Stdlib_Callback[2], cst_Bigstring_IOError, [0, IOError, 0, Core[7]]);
   runtime.bigstring_init_stub(0);
   function check_min_len(loc, len, param){
    if(! param) return 0;
    var min_len = param[1];
    if(caml_call2(Core[91], min_len, len)){
     var msg = caml_call4(Core[265], _d_, loc, min_len, len);
     caml_call1(Core[5], msg);
    }
    if(caml_call2(Core[92], min_len, 0)){
     var msg$0 = caml_call3(Core[265], _e_, loc, min_len);
     caml_call1(Core[5], msg$0);
    }
    return min_len;
   }
   function read(min_len, fd, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, loc, pos, len$0, bstr);
    var min_len$0 = check_min_len(loc, len$0, min_len);
    return runtime.bigstring_read_stub(min_len$0, fd, pos, len$0, bstr);
   }
   function pread(min_len, fd, offset, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, loc$0, pos, len$0, bstr);
    var min_len$0 = check_min_len(loc$0, len$0, min_len);
    return runtime.bigstring_pread_bytecode
            (min_len$0, fd, offset, pos, len$0, bstr);
   }
   function pread_assume_fd_is_nonblocking(fd, offset, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, loc$1, pos, len$0, bstr);
    return runtime.bigstring_pread_assume_fd_is_nonblocking_stub
            (fd, offset, pos, len$0, bstr);
   }
   function really_read(fd, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    read([0, len$0], fd, [0, pos], [0, len$0], bstr);
    return 0;
   }
   function really_pread(fd, offset, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    pread([0, len$0], fd, offset, [0, pos], [0, len$0], bstr);
    return 0;
   }
   function really_recv(sock, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, cst_really_recv, pos, len$0, bstr);
    return runtime.bigstring_really_recv_stub(sock, pos, len$0, bstr);
   }
   function recv_peek_assume_fd_is_nonbloc(sock, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    caml_call4(check_args, cst_recv_peek_assume_fd_is_non, pos, len, bstr);
    return runtime.bigstring_recv_peek_assume_fd_is_nonblocking_stub
            (sock, pos, len, bstr);
   }
   function recvfrom_assume_fd_is_nonblock(sock, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, cst_recvfrom_assume_fd_is_nonb, pos, len$0, bstr);
    return runtime.bigstring_recvfrom_assume_fd_is_nonblocking_stub
            (sock, pos, len$0, bstr);
   }
   function read_assume_fd_is_nonblocking(fd, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, cst_read_assume_fd_is_nonblock, pos, len$0, bstr);
    return runtime.bigstring_read_assume_fd_is_nonblocking_stub
            (fd, pos, len$0, bstr);
   }
   function input(min_len, ic, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, loc$2, pos, len$0, bstr);
    var min_len$0 = check_min_len(loc$2, len$0, min_len);
    return runtime.bigstring_input_stub(min_len$0, ic, pos, len$0, bstr);
   }
   function really_input(ic, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, cst_really_input, pos, len$0, bstr);
    runtime.bigstring_input_stub(len$0, ic, pos, len$0, bstr);
    return 0;
   }
   function really_write(fd, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, cst_really_write, pos, len$0, bstr);
    return runtime.bigstring_really_write_stub(fd, pos, len$0, bstr);
   }
   function pwrite_assume_fd_is_nonblockin(fd, offset, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, loc$3, pos, len$0, bstr);
    return runtime.bigstring_pwrite_assume_fd_is_nonblocking_stub
            (fd, offset, pos, len$0, bstr);
   }
   function _f_(fd, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, cst_really_send_no_sigpipe, pos, len$0, bstr);
    return runtime.bigstring_really_send_no_sigpipe_stub(fd, pos, len$0, bstr);
   }
   function _g_(fd, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, cst_send_nonblocking_no_sigpip, pos, len$0, bstr);
    return runtime.bigstring_send_nonblocking_no_sigpipe_stub
            (fd, pos, len$0, bstr);
   }
   var
    really_send_no_sigpipe = [0, _f_],
    send_nonblocking_no_sigpipe = [0, _g_],
    sendto_nonblocking_no_sigpipe =
      [0,
       function(fd, opt, len, bstr, sockaddr){
        if(opt) var sth = opt[1], pos = sth; else var pos = 0;
        var len$0 = caml_call3(get_opt_len, bstr, pos, len);
        caml_call4
         (check_args, cst_sendto_nonblocking_no_sigp, pos, len$0, bstr);
        return runtime.bigstring_sendto_nonblocking_no_sigpipe_stub
                (fd, pos, len$0, bstr, sockaddr);
       }],
    unsafe_really_send_no_sigpipe =
      [0,
       function(_F_, _E_, _D_, _C_){
        return runtime.bigstring_really_send_no_sigpipe_stub
                (_F_, _E_, _D_, _C_);
       }],
    unsafe_send_nonblocking_no_sig =
      [0,
       function(_B_, _A_, _z_, _y_){
        return runtime.bigstring_send_nonblocking_no_sigpipe_stub
                (_B_, _A_, _z_, _y_);
       }];
   function write(fd, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, cst_write, pos, len$0, bstr);
    return runtime.bigstring_write_stub(fd, pos, len$0, bstr);
   }
   function write_assume_fd_is_nonblocking(fd, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, cst_write_assume_fd_is_nonbloc, pos, len$0, bstr);
    return runtime.bigstring_write_assume_fd_is_nonblocking_stub
            (fd, pos, len$0, bstr);
   }
   function get_iovec_count(loc, iovecs, param){
    if(! param) return iovecs.length - 1;
    var count = param[1];
    if(caml_call2(Core[92], count, 0)){
     var _w_ = caml_call2(Core[18], loc, cst_count_0);
     caml_call1(Core[5], _w_);
    }
    var n_iovecs = iovecs.length - 1;
    if(caml_call2(Core[91], count, n_iovecs)){
     var _x_ = caml_call2(Core[18], loc, cst_count_n_iovecs);
     caml_call1(Core[5], _x_);
    }
    return count;
   }
   function writev(fd, count, iovecs){
    var count$0 = get_iovec_count(cst_writev, iovecs, count);
    return runtime.bigstring_writev_stub(fd, iovecs, count$0);
   }
   function writev_assume_fd_is_nonblockin(fd, count, iovecs){
    var count$0 = get_iovec_count(cst_writev_nonblocking, iovecs, count);
    return runtime.bigstring_writev_assume_fd_is_nonblocking_stub
            (fd, iovecs, count$0);
   }
   function output(min_len, oc, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, loc$4, pos, len$0, bstr);
    var min_len$0 = check_min_len(loc$4, len$0, min_len);
    return runtime.bigstring_output_stub(min_len$0, oc, pos, len$0, bstr);
   }
   function really_output(oc, opt, len, bstr){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var len$0 = caml_call3(get_opt_len, bstr, pos, len);
    caml_call4(check_args, cst_really_output, pos, len$0, bstr);
    runtime.bigstring_output_stub(len$0, oc, pos, len$0, bstr);
    return 0;
   }
   function recvmmsg_assume_fd_is_nonblock(fd, count, srcs, iovecs, lens){
    var count$0 = get_iovec_count(loc$5, iovecs, count);
    if(srcs){
     var a = srcs[1];
     if(caml_call2(Core[91], count$0, a.length - 1)){
      var _u_ = caml_call2(Core[18], loc$5, cst_count_n_srcs);
      caml_call1(Core[5], _u_);
     }
    }
    if(caml_call2(Core[91], count$0, lens.length - 1)){
     var _v_ = caml_call2(Core[18], loc$5, cst_count_n_lens);
     caml_call1(Core[5], _v_);
    }
    return runtime.bigstring_recvmmsg_assume_fd_is_nonblocking_stub
            (fd, iovecs, count$0, srcs, lens);
   }
   var
    unsafe_recvmmsg_assume_fd_is_n =
      [0,
       function(_t_, _s_, _r_, _q_, _p_){
        return runtime.bigstring_recvmmsg_assume_fd_is_nonblocking_stub
                (_t_, _s_, _r_, _q_, _p_);
       }],
    ok = [0, recvmmsg_assume_fd_is_nonblock];
   try{
    var
     _l_ =
       recvmmsg_assume_fd_is_nonblock
        (caml_call1(Core_unix_File_descr[13], -1), 0, 0, [0], [0]);
    if(! caml_call2(Core[90], _l_, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    var recvmmsg_assume_fd_is_nonblock$0 = ok;
   }
   catch(_o_){
    var _h_ = caml_wrap_exception(_o_);
    a:
    {
     if(_h_[1] === Core_unix[4]){
      var _i_ = _h_[2];
      if(typeof _i_ === "number" && 25 === _i_){
       var
        _j_ = caml_call1(Core_Or_error[52], cst_Bigstring_recvmmsg_assume_);
       break a;
      }
     }
     var _j_ = ok;
    }
    var recvmmsg_assume_fd_is_nonblock$0 = _j_;
   }
   function _k_(fd, iovecs, count){
    var
     res =
       runtime.bigstring_sendmsg_nonblocking_no_sigpipe_stub
        (fd, iovecs, count);
    return caml_call2(Core[90], res, -1) ? 0 : [0, res];
   }
   var
    sendmsg_nonblocking_no_sigpipe =
      [0,
       function(fd, count, iovecs){
        var
         count$0 =
           get_iovec_count(cst_sendmsg_nonblocking_no_sig, iovecs, count);
        return _k_(fd, iovecs, count$0);
       }],
    unsafe_sendmsg_nonblocking_no_ = [0, _k_];
   function map_file(shared, fd, size){
    var
     _n_ =
       caml_call6
        (Core_unix[84],
         fd,
         0,
         Stdlib_Bigarray[13],
         Stdlib_Bigarray[15],
         shared,
         [0, size]);
    return caml_call1(Stdlib_Bigarray[23], _n_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_bigstring_unix);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Bigstring_unix);
   var
    Bigstring_unix =
      [0,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       compare,
       t_of_sexp,
       sexp_of_t,
       compare_t_frozen,
       hash_fold_t_frozen,
       hash_t_frozen,
       sexp_of_t_frozen,
       t_frozen_of_sexp,
       equal,
       init,
       of_string,
       of_bytes,
       to_string,
       to_bytes,
       concat,
       check_args,
       get_opt_len,
       length,
       blit,
       blito,
       unsafe_blit,
       sub,
       subo,
       copy,
       memset,
       unsafe_memset,
       memcmp,
       memcmp_bytes,
       memcmp_string,
       find,
       memmem,
       get_int8,
       set_int8_exn,
       get_uint8,
       set_uint8_exn,
       unsafe_get_int8,
       unsafe_set_int8,
       unsafe_get_uint8,
       unsafe_set_uint8,
       get_int16_le,
       get_int16_be,
       set_int16_le_exn,
       set_int16_be_exn,
       unsafe_get_int16_le,
       unsafe_get_int16_be,
       unsafe_set_int16_le,
       unsafe_set_int16_be,
       get_uint16_le,
       get_uint16_be,
       set_uint16_le_exn,
       set_uint16_be_exn,
       unsafe_get_uint16_le,
       unsafe_get_uint16_be,
       unsafe_set_uint16_le,
       unsafe_set_uint16_be,
       get_int32_le,
       get_int32_be,
       set_int32_le_exn,
       set_int32_be_exn,
       unsafe_get_int32_le,
       unsafe_get_int32_be,
       unsafe_set_int32_le,
       unsafe_set_int32_be,
       get_uint32_le,
       get_uint32_be,
       set_uint32_le_exn,
       set_uint32_be_exn,
       unsafe_get_uint32_le,
       unsafe_get_uint32_be,
       unsafe_set_uint32_le,
       unsafe_set_uint32_be,
       get_int64_le_exn,
       get_int64_be_exn,
       get_int64_le_trunc,
       get_int64_be_trunc,
       set_int64_le,
       set_int64_be,
       unsafe_get_int64_le_exn,
       unsafe_get_int64_be_exn,
       unsafe_get_int64_le_trunc,
       unsafe_get_int64_be_trunc,
       unsafe_set_int64_le,
       unsafe_set_int64_be,
       get_uint64_be_exn,
       get_uint64_le_exn,
       set_uint64_le_exn,
       set_uint64_be_exn,
       unsafe_get_uint64_be_exn,
       unsafe_get_uint64_le_exn,
       unsafe_set_uint64_le,
       unsafe_set_uint64_be,
       get_int32_t_le,
       get_int32_t_be,
       set_int32_t_le,
       set_int32_t_be,
       unsafe_get_int32_t_le,
       unsafe_get_int32_t_be,
       unsafe_set_int32_t_le,
       unsafe_set_int32_t_be,
       get_int64_t_le,
       get_int64_t_be,
       set_int64_t_le,
       set_int64_t_be,
       unsafe_get_int64_t_le,
       unsafe_get_int64_t_be,
       unsafe_set_int64_t_le,
       unsafe_set_int64_t_be,
       get_string,
       unsafe_get_string,
       create,
       sub_shared,
       write_bin_prot,
       write_bin_prot_known_size,
       read_bin_prot,
       read_bin_prot_verbose_errors,
       get_tail_padded_fixed_string,
       get_tail_padded_fixed_string_l,
       set_tail_padded_fixed_string,
       get_head_padded_fixed_string,
       get_head_padded_fixed_string_l,
       set_head_padded_fixed_string,
       IOError,
       read,
       really_read,
       really_recv,
       recv_peek_assume_fd_is_nonbloc,
       recvfrom_assume_fd_is_nonblock,
       read_assume_fd_is_nonblocking,
       pread,
       really_pread,
       pread_assume_fd_is_nonblocking,
       input,
       really_input,
       really_write,
       really_send_no_sigpipe,
       send_nonblocking_no_sigpipe,
       sendto_nonblocking_no_sigpipe,
       write,
       pwrite_assume_fd_is_nonblockin,
       write_assume_fd_is_nonblocking,
       writev,
       writev_assume_fd_is_nonblockin,
       recvmmsg_assume_fd_is_nonblock$0,
       unsafe_recvmmsg_assume_fd_is_n,
       sendmsg_nonblocking_no_sigpipe,
       output,
       really_output,
       unsafe_really_send_no_sigpipe,
       unsafe_send_nonblocking_no_sig,
       unsafe_sendmsg_nonblocking_no_,
       map_file];
   runtime.caml_register_global(56, Bigstring_unix, cst_Bigstring_unix$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiaWdzdHJpbmdfdW5peC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsibG9jJDUiLCJsb2MkNCIsImxvYyQzIiwibG9jJDIiLCJsb2MkMSIsImxvYyQwIiwibG9jIiwiY2hlY2tfbWluX2xlbiIsImxlbiIsIm1pbl9sZW4iLCJtc2ciLCJtc2ckMCIsInJlYWQiLCJmZCIsIm9wdCIsImJzdHIiLCJzdGgiLCJwb3MiLCJsZW4kMCIsIm1pbl9sZW4kMCIsInByZWFkIiwib2Zmc2V0IiwicHJlYWRfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nIiwicmVhbGx5X3JlYWQiLCJyZWFsbHlfcHJlYWQiLCJyZWFsbHlfcmVjdiIsInNvY2siLCJyZWN2X3BlZWtfYXNzdW1lX2ZkX2lzX25vbmJsb2MiLCJyZWN2ZnJvbV9hc3N1bWVfZmRfaXNfbm9uYmxvY2siLCJyZWFkX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyIsImlucHV0IiwiaWMiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfd3JpdGUiLCJwd3JpdGVfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW4iLCJyZWFsbHlfc2VuZF9ub19zaWdwaXBlIiwic2VuZF9ub25ibG9ja2luZ19ub19zaWdwaXBlIiwic2VuZHRvX25vbmJsb2NraW5nX25vX3NpZ3BpcGUiLCJzb2NrYWRkciIsInVuc2FmZV9yZWFsbHlfc2VuZF9ub19zaWdwaXBlIiwidW5zYWZlX3NlbmRfbm9uYmxvY2tpbmdfbm9fc2lnIiwid3JpdGUiLCJ3cml0ZV9hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmciLCJnZXRfaW92ZWNfY291bnQiLCJpb3ZlY3MiLCJjb3VudCIsIm5faW92ZWNzIiwid3JpdGV2IiwiY291bnQkMCIsIndyaXRldl9hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbiIsIm91dHB1dCIsIm9jIiwicmVhbGx5X291dHB1dCIsInJlY3ZtbXNnX2Fzc3VtZV9mZF9pc19ub25ibG9jayIsInNyY3MiLCJsZW5zIiwiYSIsInVuc2FmZV9yZWN2bW1zZ19hc3N1bWVfZmRfaXNfbiIsIm9rIiwicmVjdm1tc2dfYXNzdW1lX2ZkX2lzX25vbmJsb2NrJDAiLCJyZXMiLCJzZW5kbXNnX25vbmJsb2NraW5nX25vX3NpZ3BpcGUiLCJ1bnNhZmVfc2VuZG1zZ19ub25ibG9ja2luZ19ub18iLCJtYXBfZmlsZSIsInNoYXJlZCIsInNpemUiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9jb3JlX3VuaXgvYmlnc3RyaW5nX3VuaXgvYmlnc3RyaW5nX3VuaXgubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUFrWE1BO0lBeEJBQztJQWxKQUM7SUF2Q0FDO0lBakZBQztJQWpCQUM7SUFsQkFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FyQ047Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJOzs7Ozs7Ozs7O0dBS0U7R0FDQTs7R0FDQTtZQUdFQyxjQUFlRCxLQUFLRTtJLFlBQ1o7UUFDSEM7SUFDRixHQUFBLHFCQURFQSxTQUZlRDtLQUtSLElBQU5FLE1BQU0sMkJBTEdKLEtBRVZHLFNBRmVEO0tBTWxCLG9CQURJRTs7SUFFSCxHQUFBLHFCQUxFRDtLQU9PLElBQU5FLFFBQU0sMkJBVEdMLEtBRVZHO0tBUUgsb0JBRElFOztJQUVOLE9BVEtGOztZQXVCTEcsS0FBTUgsU0FBUUksSUFBS0MsS0FBVU4sS0FBSU87SUFDbkMsR0FEcUJELFNBQU1FLE1BQU5GLFFBQUFHLE1BQU1ELGNBQU5DO0lBQ1gsSUFBTkMsUUFBTSx3QkFEeUJILE1BQWRFLEtBQVVUO0lBRy9CLHVCQURJRixLQUZp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TUFBQTtRQVRBTSxtQ0FPRUQ7Ozs7Ozs7Ozs7Y0FPRjs7OztlQVBFQTs7UUFQRkM7O2dCQTRDc0M5QyxJQUFHK0IsUUFBT0M7SUFDeEM7S0FBTmU7T0FBTTtTQUQ4Qi9DLElBQUcrQixRQUFPQztJQUUvQyxPQUFBLHFCQURDZSxtQkFBQUE7R0FDK0I7R0FRQTtJQUFqQ0M7O2dCQUwrQmhELElBQUlnQyxPQUFNRDtRQUMvQjtTQUFSSTtXQTFIRkwsZ0RBeUh5Q0MsUUFBTkM7UUFFckMsV0FGaUNoQyxJQUFVK0IsUUFDdkNJO09BQ2lEO0lBSW5EYztZQWdCQUMsU0FBVUMsUUFBT25ELElBQUdvRDtJQUNNOztPQUFBOztTQURUcEQ7Ozs7U0FBUG1EO2FBQVVDO0lBQ00sT0FBQTtHQUE0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTFadEZyRDtPQTBDQVc7T0EwQkFFO09BTUFFO09BYUFDO09BY0FDO09BbkZBVDtPQTZCQUk7T0FaQUY7T0FpRkFRO09BUUFFO09BZ0JBQztPQTBFQUU7T0FDQUM7T0FDQUM7T0F1QkFJO09BcEZBUDtPQWtHQVE7T0FzQkFLO09BWUFFO09BbURBVTtPQUZBRjtPQXdEQUk7T0EzRkFYO09BUUFFO09BNUZBYjtPQUNBQztPQStLQXNCO09BZ0JBQzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJbJSVpbXBvcnQgXCJjb25maWcuaFwiXVxuXG5vcGVuISBDb3JlXG5tb2R1bGUgVW5peCA9IENvcmVfdW5peFxubW9kdWxlIFN5c2NhbGxfcmVzdWx0ID0gVW5peC5TeXNjYWxsX3Jlc3VsdFxub3BlbiBCaWdhcnJheVxuaW5jbHVkZSBDb3JlLkJpZ3N0cmluZ1xuXG5leGNlcHRpb24gSU9FcnJvciBvZiBpbnQgKiBleG4gW0BAZGVyaXZpbmcgc2V4cF1cblxuZXh0ZXJuYWwgaW5pdF9zdHViIDogdW5pdCAtPiB1bml0ID0gXCJiaWdzdHJpbmdfaW5pdF9zdHViXCJcblxubGV0ICgpID1cbiAgQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwiQmlnc3RyaW5nLkVuZF9vZl9maWxlXCIgRW5kX29mX2ZpbGU7XG4gIENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcIkJpZ3N0cmluZy5JT0Vycm9yXCIgKElPRXJyb3IgKDAsIEV4aXQpKTtcbiAgaW5pdF9zdHViICgpXG47O1xuXG5sZXQgY2hlY2tfbWluX2xlbiB+bG9jIH5sZW4gPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gMFxuICB8IFNvbWUgbWluX2xlbiAtPlxuICAgIGlmIG1pbl9sZW4gPiBsZW5cbiAgICB0aGVuIChcbiAgICAgIGxldCBtc2cgPSBzcHJpbnRmIFwiJXM6IG1pbl9sZW4gKCVkKSA+IGxlbiAoJWQpXCIgbG9jIG1pbl9sZW4gbGVuIGluXG4gICAgICBpbnZhbGlkX2FyZyBtc2cpO1xuICAgIGlmIG1pbl9sZW4gPCAwXG4gICAgdGhlbiAoXG4gICAgICBsZXQgbXNnID0gc3ByaW50ZiBcIiVzOiBtaW5fbGVuICglZCkgPCAwXCIgbG9jIG1pbl9sZW4gaW5cbiAgICAgIGludmFsaWRfYXJnIG1zZyk7XG4gICAgbWluX2xlblxuOztcblxuKCogSW5wdXQgZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIHVuc2FmZV9yZWFkXG4gIDogIG1pbl9sZW46aW50XG4gIC0+IFVuaXguRmlsZV9kZXNjci50XG4gIC0+IHBvczppbnRcbiAgLT4gbGVuOmludFxuICAtPiB0XG4gIC0+IGludFxuICA9IFwiYmlnc3RyaW5nX3JlYWRfc3R1YlwiXG5cbmxldCByZWFkID9taW5fbGVuIGZkID8ocG9zID0gMCkgP2xlbiBic3RyID1cbiAgbGV0IGxlbiA9IGdldF9vcHRfbGVuIGJzdHIgfnBvcyBsZW4gaW5cbiAgbGV0IGxvYyA9IFwicmVhZFwiIGluXG4gIGNoZWNrX2FyZ3MgfmxvYyB+cG9zIH5sZW4gYnN0cjtcbiAgbGV0IG1pbl9sZW4gPSBjaGVja19taW5fbGVuIH5sb2MgfmxlbiBtaW5fbGVuIGluXG4gIHVuc2FmZV9yZWFkIH5taW5fbGVuIGZkIH5wb3MgfmxlbiBic3RyXG47O1xuXG5leHRlcm5hbCB1bnNhZmVfcHJlYWRcbiAgOiAgbWluX2xlbjppbnRcbiAgLT4gVW5peC5GaWxlX2Rlc2NyLnRcbiAgLT4gb2Zmc2V0OmludFxuICAtPiBwb3M6aW50XG4gIC0+IGxlbjppbnRcbiAgLT4gdFxuICAtPiBpbnRcbiAgPSBcImJpZ3N0cmluZ19wcmVhZF9ieXRlY29kZVwiIFwiYmlnc3RyaW5nX3ByZWFkX3N0dWJcIlxuXG5sZXQgcHJlYWQgP21pbl9sZW4gZmQgfm9mZnNldCA/KHBvcyA9IDApID9sZW4gYnN0ciA9XG4gIGxldCBsZW4gPSBnZXRfb3B0X2xlbiBic3RyIH5wb3MgbGVuIGluXG4gIGxldCBsb2MgPSBcInByZWFkXCIgaW5cbiAgY2hlY2tfYXJncyB+bG9jIH5wb3MgfmxlbiBic3RyO1xuICBsZXQgbWluX2xlbiA9IGNoZWNrX21pbl9sZW4gfmxvYyB+bGVuIG1pbl9sZW4gaW5cbiAgdW5zYWZlX3ByZWFkIH5taW5fbGVuIGZkIH5vZmZzZXQgfnBvcyB+bGVuIGJzdHJcbjs7XG5cbmV4dGVybmFsIHVuc2FmZV9wcmVhZF9hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmdfc3R1YlxuICA6ICBVbml4LkZpbGVfZGVzY3IudFxuICAtPiBvZmZzZXQ6aW50XG4gIC0+IHBvczppbnRcbiAgLT4gbGVuOmludFxuICAtPiB0XG4gIC0+IGludFxuICA9IFwiYmlnc3RyaW5nX3ByZWFkX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZ19zdHViXCJcblxubGV0IHByZWFkX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyBmZCB+b2Zmc2V0ID8ocG9zID0gMCkgP2xlbiBic3RyID1cbiAgbGV0IGxlbiA9IGdldF9vcHRfbGVuIGJzdHIgfnBvcyBsZW4gaW5cbiAgbGV0IGxvYyA9IFwicHJlYWRcIiBpblxuICBjaGVja19hcmdzIH5sb2MgfnBvcyB+bGVuIGJzdHI7XG4gIHVuc2FmZV9wcmVhZF9hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmdfc3R1YiBmZCB+b2Zmc2V0IH5wb3MgfmxlbiBic3RyXG47O1xuXG5sZXQgcmVhbGx5X3JlYWQgZmQgPyhwb3MgPSAwKSA/bGVuIGJzdHIgPVxuICBsZXQgbGVuID0gZ2V0X29wdF9sZW4gYnN0ciB+cG9zIGxlbiBpblxuICBpZ25vcmUgKHJlYWQgfm1pbl9sZW46bGVuIGZkIH5wb3MgfmxlbiBic3RyIDogaW50KVxuOztcblxubGV0IHJlYWxseV9wcmVhZCBmZCB+b2Zmc2V0ID8ocG9zID0gMCkgP2xlbiBic3RyID1cbiAgbGV0IGxlbiA9IGdldF9vcHRfbGVuIGJzdHIgfnBvcyBsZW4gaW5cbiAgaWdub3JlIChwcmVhZCB+bWluX2xlbjpsZW4gZmQgfm9mZnNldCB+cG9zIH5sZW4gYnN0ciA6IGludClcbjs7XG5cbmV4dGVybmFsIHVuc2FmZV9yZWFsbHlfcmVjdlxuICA6ICBVbml4LkZpbGVfZGVzY3IudFxuICAtPiBwb3M6aW50XG4gIC0+IGxlbjppbnRcbiAgLT4gdFxuICAtPiB1bml0XG4gID0gXCJiaWdzdHJpbmdfcmVhbGx5X3JlY3Zfc3R1YlwiXG5cbmV4dGVybmFsIHVuc2FmZV9yZWN2X3BlZWtfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXG4gIDogIFVuaXguRmlsZV9kZXNjci50XG4gIC0+IHBvczppbnRcbiAgLT4gbGVuOmludFxuICAtPiB0XG4gIC0+IGludFxuICA9IFwiYmlnc3RyaW5nX3JlY3ZfcGVla19hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmdfc3R1YlwiXG5cbmxldCByZWFsbHlfcmVjdiBzb2NrID8ocG9zID0gMCkgP2xlbiBic3RyID1cbiAgbGV0IGxlbiA9IGdldF9vcHRfbGVuIGJzdHIgfnBvcyBsZW4gaW5cbiAgY2hlY2tfYXJncyB+bG9jOlwicmVhbGx5X3JlY3ZcIiB+cG9zIH5sZW4gYnN0cjtcbiAgdW5zYWZlX3JlYWxseV9yZWN2IHNvY2sgfnBvcyB+bGVuIGJzdHJcbjs7XG5cbmxldCByZWN2X3BlZWtfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nIHNvY2sgPyhwb3MgPSAwKSB+bGVuIGJzdHIgPVxuICBjaGVja19hcmdzIH5sb2M6XCJyZWN2X3BlZWtfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXCIgfnBvcyB+bGVuIGJzdHI7XG4gIHVuc2FmZV9yZWN2X3BlZWtfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nIHNvY2sgfnBvcyB+bGVuIGJzdHJcbjs7XG5cbmV4dGVybmFsIHVuc2FmZV9yZWN2ZnJvbV9hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmdcbiAgOiAgVW5peC5GaWxlX2Rlc2NyLnRcbiAgLT4gcG9zOmludFxuICAtPiBsZW46aW50XG4gIC0+IHRcbiAgLT4gaW50ICogVW5peC5zb2NrYWRkclxuICA9IFwiYmlnc3RyaW5nX3JlY3Zmcm9tX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZ19zdHViXCJcblxubGV0IHJlY3Zmcm9tX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyBzb2NrID8ocG9zID0gMCkgP2xlbiBic3RyID1cbiAgbGV0IGxlbiA9IGdldF9vcHRfbGVuIGJzdHIgfnBvcyBsZW4gaW5cbiAgY2hlY2tfYXJncyB+bG9jOlwicmVjdmZyb21fYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXCIgfnBvcyB+bGVuIGJzdHI7XG4gIHVuc2FmZV9yZWN2ZnJvbV9hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmcgc29jayB+cG9zIH5sZW4gYnN0clxuOztcblxuZXh0ZXJuYWwgdW5zYWZlX3JlYWRfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXG4gIDogIFVuaXguRmlsZV9kZXNjci50XG4gIC0+IHBvczppbnRcbiAgLT4gbGVuOmludFxuICAtPiB0XG4gIC0+IFN5c2NhbGxfcmVzdWx0LkludC50XG4gID0gXCJiaWdzdHJpbmdfcmVhZF9hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmdfc3R1YlwiXG5cbmxldCByZWFkX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyBmZCA/KHBvcyA9IDApID9sZW4gYnN0ciA9XG4gIGxldCBsZW4gPSBnZXRfb3B0X2xlbiBic3RyIH5wb3MgbGVuIGluXG4gIGNoZWNrX2FyZ3MgfmxvYzpcInJlYWRfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXCIgfnBvcyB+bGVuIGJzdHI7XG4gIHVuc2FmZV9yZWFkX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyBmZCB+cG9zIH5sZW4gYnN0clxuOztcblxuZXh0ZXJuYWwgdW5zYWZlX2lucHV0XG4gIDogIG1pbl9sZW46aW50XG4gIC0+IEluX2NoYW5uZWwudFxuICAtPiBwb3M6aW50XG4gIC0+IGxlbjppbnRcbiAgLT4gdFxuICAtPiBpbnRcbiAgPSBcImJpZ3N0cmluZ19pbnB1dF9zdHViXCJcblxubGV0IGlucHV0ID9taW5fbGVuIGljID8ocG9zID0gMCkgP2xlbiBic3RyID1cbiAgbGV0IGxlbiA9IGdldF9vcHRfbGVuIGJzdHIgfnBvcyBsZW4gaW5cbiAgbGV0IGxvYyA9IFwiaW5wdXRcIiBpblxuICBjaGVja19hcmdzIH5sb2MgfnBvcyB+bGVuIGJzdHI7XG4gIGxldCBtaW5fbGVuID0gY2hlY2tfbWluX2xlbiB+bG9jIH5sZW4gbWluX2xlbiBpblxuICB1bnNhZmVfaW5wdXQgfm1pbl9sZW4gaWMgfnBvcyB+bGVuIGJzdHJcbjs7XG5cbmxldCByZWFsbHlfaW5wdXQgaWMgPyhwb3MgPSAwKSA/bGVuIGJzdHIgPVxuICBsZXQgbGVuID0gZ2V0X29wdF9sZW4gYnN0ciB+cG9zIGxlbiBpblxuICBjaGVja19hcmdzIH5sb2M6XCJyZWFsbHlfaW5wdXRcIiB+cG9zIH5sZW4gYnN0cjtcbiAgaWdub3JlICh1bnNhZmVfaW5wdXQgfm1pbl9sZW46bGVuIGljIH5wb3MgfmxlbiBic3RyIDogaW50KVxuOztcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCB1bnNhZmVfcmVhbGx5X3dyaXRlXG4gIDogIFVuaXguRmlsZV9kZXNjci50XG4gIC0+IHBvczppbnRcbiAgLT4gbGVuOmludFxuICAtPiB0XG4gIC0+IHVuaXRcbiAgPSBcImJpZ3N0cmluZ19yZWFsbHlfd3JpdGVfc3R1YlwiXG5cbmxldCByZWFsbHlfd3JpdGUgZmQgPyhwb3MgPSAwKSA/bGVuIGJzdHIgPVxuICBsZXQgbGVuID0gZ2V0X29wdF9sZW4gYnN0ciB+cG9zIGxlbiBpblxuICBjaGVja19hcmdzIH5sb2M6XCJyZWFsbHlfd3JpdGVcIiB+cG9zIH5sZW4gYnN0cjtcbiAgdW5zYWZlX3JlYWxseV93cml0ZSBmZCB+cG9zIH5sZW4gYnN0clxuOztcblxuZXh0ZXJuYWwgdW5zYWZlX3B3cml0ZV9hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmdcbiAgOiAgVW5peC5GaWxlX2Rlc2NyLnRcbiAgLT4gb2Zmc2V0OmludFxuICAtPiBwb3M6aW50XG4gIC0+IGxlbjppbnRcbiAgLT4gdFxuICAtPiBpbnRcbiAgPSBcImJpZ3N0cmluZ19wd3JpdGVfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nX3N0dWJcIlxuXG5sZXQgcHdyaXRlX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyBmZCB+b2Zmc2V0ID8ocG9zID0gMCkgP2xlbiBic3RyID1cbiAgbGV0IGxlbiA9IGdldF9vcHRfbGVuIGJzdHIgfnBvcyBsZW4gaW5cbiAgbGV0IGxvYyA9IFwicHdyaXRlXCIgaW5cbiAgY2hlY2tfYXJncyB+bG9jIH5wb3MgfmxlbiBic3RyO1xuICB1bnNhZmVfcHdyaXRlX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyBmZCB+b2Zmc2V0IH5wb3MgfmxlbiBic3RyXG47O1xuXG5bJSVpZmRlZiBKU0NfTVNHX05PU0lHTkFMXVxuWyUlZGVmaW5lIEpTQ19OT1NJR1BJUEVdXG5bJSVlbmRpZl1cblslJWlmZGVmIEpTQ19TT19OT1NJR1BJUEVdXG5bJSVkZWZpbmUgSlNDX05PU0lHUElQRV1cblslJWVuZGlmXVxuWyUlaWZkZWYgSlNDX05PU0lHUElQRV1cblxuZXh0ZXJuYWwgdW5zYWZlX3JlYWxseV9zZW5kX25vX3NpZ3BpcGVcbiAgOiAgVW5peC5GaWxlX2Rlc2NyLnRcbiAgLT4gcG9zOmludFxuICAtPiBsZW46aW50XG4gIC0+IHRcbiAgLT4gdW5pdFxuICA9IFwiYmlnc3RyaW5nX3JlYWxseV9zZW5kX25vX3NpZ3BpcGVfc3R1YlwiXG5cbmxldCByZWFsbHlfc2VuZF9ub19zaWdwaXBlIGZkID8ocG9zID0gMCkgP2xlbiBic3RyID1cbiAgbGV0IGxlbiA9IGdldF9vcHRfbGVuIGJzdHIgfnBvcyBsZW4gaW5cbiAgY2hlY2tfYXJncyB+bG9jOlwicmVhbGx5X3NlbmRfbm9fc2lncGlwZVwiIH5wb3MgfmxlbiBic3RyO1xuICB1bnNhZmVfcmVhbGx5X3NlbmRfbm9fc2lncGlwZSBmZCB+cG9zIH5sZW4gYnN0clxuOztcblxuZXh0ZXJuYWwgdW5zYWZlX3NlbmRfbm9uYmxvY2tpbmdfbm9fc2lncGlwZVxuICA6ICBVbml4LkZpbGVfZGVzY3IudFxuICAtPiBwb3M6aW50XG4gIC0+IGxlbjppbnRcbiAgLT4gdFxuICAtPiBTeXNjYWxsX3Jlc3VsdC5JbnQudFxuICA9IFwiYmlnc3RyaW5nX3NlbmRfbm9uYmxvY2tpbmdfbm9fc2lncGlwZV9zdHViXCJcbiAgW0BAbm9hbGxvY11cblxubGV0IHNlbmRfbm9uYmxvY2tpbmdfbm9fc2lncGlwZSBmZCA/KHBvcyA9IDApID9sZW4gYnN0ciA9XG4gIGxldCBsZW4gPSBnZXRfb3B0X2xlbiBic3RyIH5wb3MgbGVuIGluXG4gIGNoZWNrX2FyZ3MgfmxvYzpcInNlbmRfbm9uYmxvY2tpbmdfbm9fc2lncGlwZVwiIH5wb3MgfmxlbiBic3RyO1xuICB1bnNhZmVfc2VuZF9ub25ibG9ja2luZ19ub19zaWdwaXBlIGZkIH5wb3MgfmxlbiBic3RyXG47O1xuXG5leHRlcm5hbCB1bnNhZmVfc2VuZHRvX25vbmJsb2NraW5nX25vX3NpZ3BpcGVcbiAgOiAgVW5peC5GaWxlX2Rlc2NyLnRcbiAgLT4gcG9zOmludFxuICAtPiBsZW46aW50XG4gIC0+IHRcbiAgLT4gVW5peC5zb2NrYWRkclxuICAtPiBTeXNjYWxsX3Jlc3VsdC5JbnQudFxuICA9IFwiYmlnc3RyaW5nX3NlbmR0b19ub25ibG9ja2luZ19ub19zaWdwaXBlX3N0dWJcIlxuXG5sZXQgc2VuZHRvX25vbmJsb2NraW5nX25vX3NpZ3BpcGUgZmQgPyhwb3MgPSAwKSA/bGVuIGJzdHIgc29ja2FkZHIgPVxuICBsZXQgbGVuID0gZ2V0X29wdF9sZW4gYnN0ciB+cG9zIGxlbiBpblxuICBjaGVja19hcmdzIH5sb2M6XCJzZW5kdG9fbm9uYmxvY2tpbmdfbm9fc2lncGlwZVwiIH5wb3MgfmxlbiBic3RyO1xuICB1bnNhZmVfc2VuZHRvX25vbmJsb2NraW5nX25vX3NpZ3BpcGUgZmQgfnBvcyB+bGVuIGJzdHIgc29ja2FkZHJcbjs7XG5cbmxldCByZWFsbHlfc2VuZF9ub19zaWdwaXBlID0gT2sgcmVhbGx5X3NlbmRfbm9fc2lncGlwZVxubGV0IHNlbmRfbm9uYmxvY2tpbmdfbm9fc2lncGlwZSA9IE9rIHNlbmRfbm9uYmxvY2tpbmdfbm9fc2lncGlwZVxubGV0IHNlbmR0b19ub25ibG9ja2luZ19ub19zaWdwaXBlID0gT2sgc2VuZHRvX25vbmJsb2NraW5nX25vX3NpZ3BpcGVcbmxldCB1bnNhZmVfcmVhbGx5X3NlbmRfbm9fc2lncGlwZSA9IE9rIHVuc2FmZV9yZWFsbHlfc2VuZF9ub19zaWdwaXBlXG5sZXQgdW5zYWZlX3NlbmRfbm9uYmxvY2tpbmdfbm9fc2lncGlwZSA9IE9rIHVuc2FmZV9zZW5kX25vbmJsb2NraW5nX25vX3NpZ3BpcGVcblxuWyUlZWxzZV1cblxubGV0IHUgPSBPcl9lcnJvci51bmltcGxlbWVudGVkXG5sZXQgcmVhbGx5X3NlbmRfbm9fc2lncGlwZSA9IHUgXCJCaWdzdHJpbmcucmVhbGx5X3NlbmRfbm9fc2lncGlwZVwiXG5sZXQgc2VuZF9ub25ibG9ja2luZ19ub19zaWdwaXBlID0gdSBcIkJpZ3N0cmluZy5zZW5kX25vbmJsb2NraW5nX25vX3NpZ3BpcGVcIlxubGV0IHNlbmR0b19ub25ibG9ja2luZ19ub19zaWdwaXBlID0gdSBcIkJpZ3N0cmluZy5zZW5kdG9fbm9uYmxvY2tpbmdfbm9fc2lncGlwZVwiXG5sZXQgdW5zYWZlX3JlYWxseV9zZW5kX25vX3NpZ3BpcGUgPSB1IFwiQmlnc3RyaW5nLnVuc2FmZV9yZWFsbHlfc2VuZF9ub19zaWdwaXBlXCJcbmxldCB1bnNhZmVfc2VuZF9ub25ibG9ja2luZ19ub19zaWdwaXBlID0gdSBcIkJpZ3N0cmluZy51bnNhZmVfc2VuZF9ub25ibG9ja2luZ19ub19zaWdwaXBlXCJcblxuWyUlZW5kaWZdXG5cbmV4dGVybmFsIHVuc2FmZV93cml0ZVxuICA6ICBVbml4LkZpbGVfZGVzY3IudFxuICAtPiBwb3M6aW50XG4gIC0+IGxlbjppbnRcbiAgLT4gdFxuICAtPiBpbnRcbiAgPSBcImJpZ3N0cmluZ193cml0ZV9zdHViXCJcblxubGV0IHdyaXRlIGZkID8ocG9zID0gMCkgP2xlbiBic3RyID1cbiAgbGV0IGxlbiA9IGdldF9vcHRfbGVuIGJzdHIgfnBvcyBsZW4gaW5cbiAgY2hlY2tfYXJncyB+bG9jOlwid3JpdGVcIiB+cG9zIH5sZW4gYnN0cjtcbiAgdW5zYWZlX3dyaXRlIGZkIH5wb3MgfmxlbiBic3RyXG47O1xuXG5leHRlcm5hbCB1bnNhZmVfd3JpdGVfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXG4gIDogIFVuaXguRmlsZV9kZXNjci50XG4gIC0+IHBvczppbnRcbiAgLT4gbGVuOmludFxuICAtPiB0XG4gIC0+IGludFxuICA9IFwiYmlnc3RyaW5nX3dyaXRlX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZ19zdHViXCJcblxubGV0IHdyaXRlX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyBmZCA/KHBvcyA9IDApID9sZW4gYnN0ciA9XG4gIGxldCBsZW4gPSBnZXRfb3B0X2xlbiBic3RyIH5wb3MgbGVuIGluXG4gIGNoZWNrX2FyZ3MgfmxvYzpcIndyaXRlX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZ1wiIH5wb3MgfmxlbiBic3RyO1xuICB1bnNhZmVfd3JpdGVfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nIGZkIH5wb3MgfmxlbiBic3RyXG47O1xuXG5leHRlcm5hbCB1bnNhZmVfd3JpdGV2XG4gIDogIFVuaXguRmlsZV9kZXNjci50XG4gIC0+IHQgVW5peC5JT1ZlYy50IGFycmF5XG4gIC0+IGludFxuICAtPiBpbnRcbiAgPSBcImJpZ3N0cmluZ193cml0ZXZfc3R1YlwiXG5cbmxldCBnZXRfaW92ZWNfY291bnQgbG9jIGlvdmVjcyA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBBcnJheS5sZW5ndGggaW92ZWNzXG4gIHwgU29tZSBjb3VudCAtPlxuICAgIGlmIGNvdW50IDwgMCB0aGVuIGludmFsaWRfYXJnIChsb2MgXiBcIjogY291bnQgPCAwXCIpO1xuICAgIGxldCBuX2lvdmVjcyA9IEFycmF5Lmxlbmd0aCBpb3ZlY3MgaW5cbiAgICBpZiBjb3VudCA+IG5faW92ZWNzIHRoZW4gaW52YWxpZF9hcmcgKGxvYyBeIFwiOiBjb3VudCA+IG5faW92ZWNzXCIpO1xuICAgIGNvdW50XG47O1xuXG5sZXQgd3JpdGV2IGZkID9jb3VudCBpb3ZlY3MgPVxuICBsZXQgY291bnQgPSBnZXRfaW92ZWNfY291bnQgXCJ3cml0ZXZcIiBpb3ZlY3MgY291bnQgaW5cbiAgdW5zYWZlX3dyaXRldiBmZCBpb3ZlY3MgY291bnRcbjs7XG5cbmV4dGVybmFsIHVuc2FmZV93cml0ZXZfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXG4gIDogIFVuaXguRmlsZV9kZXNjci50XG4gIC0+IHQgVW5peC5JT1ZlYy50IGFycmF5XG4gIC0+IGludFxuICAtPiBpbnRcbiAgPSBcImJpZ3N0cmluZ193cml0ZXZfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nX3N0dWJcIlxuXG5sZXQgd3JpdGV2X2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyBmZCA/Y291bnQgaW92ZWNzID1cbiAgbGV0IGNvdW50ID0gZ2V0X2lvdmVjX2NvdW50IFwid3JpdGV2X25vbmJsb2NraW5nXCIgaW92ZWNzIGNvdW50IGluXG4gIHVuc2FmZV93cml0ZXZfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nIGZkIGlvdmVjcyBjb3VudFxuOztcblxuZXh0ZXJuYWwgdW5zYWZlX291dHB1dFxuICA6ICBtaW5fbGVuOmludFxuICAtPiBPdXRfY2hhbm5lbC50XG4gIC0+IHBvczppbnRcbiAgLT4gbGVuOmludFxuICAtPiB0XG4gIC0+IGludFxuICA9IFwiYmlnc3RyaW5nX291dHB1dF9zdHViXCJcblxubGV0IG91dHB1dCA/bWluX2xlbiBvYyA/KHBvcyA9IDApID9sZW4gYnN0ciA9XG4gIGxldCBsZW4gPSBnZXRfb3B0X2xlbiBic3RyIH5wb3MgbGVuIGluXG4gIGxldCBsb2MgPSBcIm91dHB1dFwiIGluXG4gIGNoZWNrX2FyZ3MgfmxvYyB+cG9zIH5sZW4gYnN0cjtcbiAgbGV0IG1pbl9sZW4gPSBjaGVja19taW5fbGVuIH5sb2MgfmxlbiBtaW5fbGVuIGluXG4gIHVuc2FmZV9vdXRwdXQgb2Mgfm1pbl9sZW4gfnBvcyB+bGVuIGJzdHJcbjs7XG5cbmxldCByZWFsbHlfb3V0cHV0IG9jID8ocG9zID0gMCkgP2xlbiBic3RyID1cbiAgbGV0IGxlbiA9IGdldF9vcHRfbGVuIGJzdHIgfnBvcyBsZW4gaW5cbiAgY2hlY2tfYXJncyB+bG9jOlwicmVhbGx5X291dHB1dFwiIH5wb3MgfmxlbiBic3RyO1xuICBpZ25vcmUgKHVuc2FmZV9vdXRwdXQgb2Mgfm1pbl9sZW46bGVuIH5wb3MgfmxlbiBic3RyIDogaW50KVxuOztcblxuWyUlaWZkZWYgSlNDX1JFQ1ZNTVNHXVxuXG5leHRlcm5hbCB1bnNhZmVfcmVjdm1tc2dfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXG4gIDogIFVuaXguRmlsZV9kZXNjci50XG4gIC0+IHQgVW5peC5JT1ZlYy50IGFycmF5XG4gIC0+IGludFxuICAtPiBVbml4LnNvY2thZGRyIGFycmF5IG9wdGlvblxuICAtPiBpbnQgYXJyYXlcbiAgLT4gaW50XG4gID0gXCJiaWdzdHJpbmdfcmVjdm1tc2dfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nX3N0dWJcIlxuXG5sZXQgcmVjdm1tc2dfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nIGZkID9jb3VudCA/c3JjcyBpb3ZlY3MgfmxlbnMgPVxuICBsZXQgbG9jID0gXCJyZWN2bW1zZ19hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmdcIiBpblxuICBsZXQgY291bnQgPSBnZXRfaW92ZWNfY291bnQgbG9jIGlvdmVjcyBjb3VudCBpblxuICAobWF0Y2ggc3JjcyB3aXRoXG4gICB8IE5vbmUgLT4gKClcbiAgIHwgU29tZSBhIC0+IGlmIGNvdW50ID4gQXJyYXkubGVuZ3RoIGEgdGhlbiBpbnZhbGlkX2FyZyAobG9jIF4gXCI6IGNvdW50ID4gbl9zcmNzXCIpKTtcbiAgaWYgY291bnQgPiBBcnJheS5sZW5ndGggbGVucyB0aGVuIGludmFsaWRfYXJnIChsb2MgXiBcIjogY291bnQgPiBuX2xlbnNcIik7XG4gIHVuc2FmZV9yZWN2bW1zZ19hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmcgZmQgaW92ZWNzIGNvdW50IHNyY3MgbGVuc1xuOztcblxubGV0IHVuc2FmZV9yZWN2bW1zZ19hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmcgPSBPayB1bnNhZmVfcmVjdm1tc2dfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXG5cbmxldCByZWN2bW1zZ19hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmcgPVxuICAoKiBBdCBKYW5lIFN0cmVldCwgd2UgbGluayB3aXRoIFstLXdyYXAgcmVjdm1tc2ddIHNvIHRoYXQgd2UgY2FuIHVzZSBvdXIgb3duIHdyYXBwZXJcbiAgICAgYXJvdW5kIFtyZWN2bW1zZ10uICBUaGlzIGFsbG93cyB1cyB0byBjb21waWxlIGFuIGV4ZWN1dGFibGUgb24gYSBtYWNoaW5lIHRoYXQgaGFzXG4gICAgIHJlY3ZtbXNnIChlLmcuLCBDZW50T1MgNikgYnV0IHRoZW4gcnVuIHRoZSBleGVjdXRhYmxlIG9uIGEgbWFjaGluZSB0aGF0IGRvZXMgbm90XG4gICAgIChlLmcuLCBDZW50T1MgNSksIGJ1dCB0aGF0IGhhcyBvdXIgd3JhcHBlciBsaWJyYXJ5LiAgV2Ugc2V0IHVwIG91ciB3cmFwcGVyIHNvIHRoYXRcbiAgICAgd2hlbiBydW5uaW5nIG9uIGEgbWFjaGluZSB0aGF0IGRvZXNuJ3QgaGF2ZSBpdCwgW3JlY3ZtbXNnXSBhbHdheXMgcmV0dXJucyAtMSBhbmQgc2V0c1xuICAgICBlcnJubyB0byBFTk9TWVMuICopXG4gIGxldCBvayA9IE9rIHJlY3ZtbXNnX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyBpblxuICB0cnlcbiAgICBhc3NlcnQgKFxuICAgICAgcmVjdm1tc2dfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nIChVbml4LkZpbGVfZGVzY3Iub2ZfaW50ICgtMSkpIFt8fF0gfmxlbnM6W3x8XSA9IDApO1xuICAgIG9rICgqIG1heWJlIGl0IHdpbGwgaWdub3JlIHRoZSBib2d1cyBzb2NrZmQgKilcbiAgd2l0aFxuICB8IFVuaXguVW5peF9lcnJvciAoRU5PU1lTLCBfLCBfKSAtPlxuICAgIE9yX2Vycm9yLnVuaW1wbGVtZW50ZWQgXCJCaWdzdHJpbmcucmVjdm1tc2dfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nXCJcbiAgfCBfIC0+IG9rXG47O1xuXG5bJSVlbHNlXVxuKCogTkRFRiBSRUNWTU1TRyAqKVxuXG5sZXQgdW5zYWZlX3JlY3ZtbXNnX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZyA9XG4gIE9yX2Vycm9yLnVuaW1wbGVtZW50ZWQgXCJCaWdzdHJpbmcudW5zYWZlX3JlY3ZtbXNnX2Fzc3VtZV9mZF9pc19ub25ibG9ja2luZ1wiXG47O1xuXG5sZXQgcmVjdm1tc2dfYXNzdW1lX2ZkX2lzX25vbmJsb2NraW5nID1cbiAgT3JfZXJyb3IudW5pbXBsZW1lbnRlZCBcIkJpZ3N0cmluZy5yZWN2bW1zZ19hc3N1bWVfZmRfaXNfbm9uYmxvY2tpbmdcIlxuOztcblxuWyUlZW5kaWZdXG4oKiBSRUNWTU1TRyAqKVxuXG4oKiBNZW1vcnkgbWFwcGluZyAqKVxuXG5bJSVpZmRlZiBKU0NfTVNHX05PU0lHTkFMXVxuKCogSW5wdXQgYW5kIG91dHB1dCwgbGludXggb25seSAqKVxuXG5leHRlcm5hbCB1bnNhZmVfc2VuZG1zZ19ub25ibG9ja2luZ19ub19zaWdwaXBlXG4gIDogIFVuaXguRmlsZV9kZXNjci50XG4gIC0+IHQgVW5peC5JT1ZlYy50IGFycmF5XG4gIC0+IGludFxuICAtPiBpbnRcbiAgPSBcImJpZ3N0cmluZ19zZW5kbXNnX25vbmJsb2NraW5nX25vX3NpZ3BpcGVfc3R1YlwiXG5cbmxldCB1bnNhZmVfc2VuZG1zZ19ub25ibG9ja2luZ19ub19zaWdwaXBlIGZkIGlvdmVjcyBjb3VudCA9XG4gIGxldCByZXMgPSB1bnNhZmVfc2VuZG1zZ19ub25ibG9ja2luZ19ub19zaWdwaXBlIGZkIGlvdmVjcyBjb3VudCBpblxuICBpZiByZXMgPSAtMSB0aGVuIE5vbmUgZWxzZSBTb21lIHJlc1xuOztcblxubGV0IHNlbmRtc2dfbm9uYmxvY2tpbmdfbm9fc2lncGlwZSBmZCA/Y291bnQgaW92ZWNzID1cbiAgbGV0IGNvdW50ID0gZ2V0X2lvdmVjX2NvdW50IFwic2VuZG1zZ19ub25ibG9ja2luZ19ub19zaWdwaXBlXCIgaW92ZWNzIGNvdW50IGluXG4gIHVuc2FmZV9zZW5kbXNnX25vbmJsb2NraW5nX25vX3NpZ3BpcGUgZmQgaW92ZWNzIGNvdW50XG47O1xuXG5sZXQgc2VuZG1zZ19ub25ibG9ja2luZ19ub19zaWdwaXBlID0gT2sgc2VuZG1zZ19ub25ibG9ja2luZ19ub19zaWdwaXBlXG5sZXQgdW5zYWZlX3NlbmRtc2dfbm9uYmxvY2tpbmdfbm9fc2lncGlwZSA9IE9rIHVuc2FmZV9zZW5kbXNnX25vbmJsb2NraW5nX25vX3NpZ3BpcGVcblxuWyUlZWxzZV1cblxubGV0IHNlbmRtc2dfbm9uYmxvY2tpbmdfbm9fc2lncGlwZSA9XG4gIE9yX2Vycm9yLnVuaW1wbGVtZW50ZWQgXCJCaWdzdHJpbmcuc2VuZG1zZ19ub25ibG9ja2luZ19ub19zaWdwaXBlXCJcbjs7XG5cbmxldCB1bnNhZmVfc2VuZG1zZ19ub25ibG9ja2luZ19ub19zaWdwaXBlID1cbiAgT3JfZXJyb3IudW5pbXBsZW1lbnRlZCBcIkJpZ3N0cmluZy51bnNhZmVfc2VuZG1zZ19ub25ibG9ja2luZ19ub19zaWdwaXBlXCJcbjs7XG5cblslJWVuZGlmXVxuXG4oKiBNZW1vcnkgbWFwcGluZyAqKVxuXG5sZXQgbWFwX2ZpbGUgfnNoYXJlZCBmZCBzaXplID1cbiAgQmlnYXJyYXkuYXJyYXkxX29mX2dlbmFycmF5IChVbml4Lm1hcF9maWxlIGZkIEJpZ2FycmF5LmNoYXIgY19sYXlvdXQgfnNoYXJlZCBbfCBzaXplIHxdKVxuOztcbiJdfQ==
