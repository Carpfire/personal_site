// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Protocol_version_header__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Protocol_version_header = [0],
    Protocol_version_header$0 = [0, Protocol_version_header];
   runtime.caml_register_global
    (0, Protocol_version_header$0, "Protocol_version_header__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__Known_protocol
//# unitInfo: Requires: Bin_prot__Common, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Write, Bin_shape, Core, Core__Char, Core__Int, Core__List, Core__String, Inline_test_config, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Krb = "Krb",
    cst_Krb_test_mode = "Krb_test_mode",
    cst_Protocol_version_header_Kn$0 =
      "Protocol_version_header__Known_protocol",
    cst_Rpc = "Rpc",
    cst_krb = "krb",
    cst_krb_test_mode = "krb_test_mode",
    cst_protocol_version_header$0 = "protocol_version_header",
    cst_rpc = "rpc",
    cst_src_known_protocol_ml$0 = "src/known_protocol.ml",
    cst_t$1 = "t",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "src/known_protocol.ml.t",
    retired_krb_word = "KRB",
    Core_List = global_data.Core__List,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Core_Char = global_data.Core__Char,
    Core_String = global_data.Core__String;
   global_data.Bin_prot__Read;
   global_data.Bin_prot__Common;
   global_data.Bin_prot__Write;
   var
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Bin_shape = global_data.Bin_shape,
    Core_Int = global_data.Core__Int,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Kn$0);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_known_protocol_ml$0);
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_protocol_version_header$0,
     "known_protocol.ml");
   var
    compare = runtime.caml_int_compare,
    _o_ = [0, cst_src_known_protocol_ml$0, 29, 2],
    _n_ = [0, cst_src_known_protocol_ml$0, 30, 2],
    _m_ = [0, cst_src_known_protocol_ml$0, 31, 2],
    _l_ = [0, cst_src_known_protocol_ml$0, 32, 2],
    cst_KRB2 = "KRB2",
    cst_KBT = "KBT",
    cst_RPC = "RPC",
    _a_ = [0, cst_Krb],
    _b_ = [0, cst_Krb_test_mode],
    _c_ = [0, cst_Rpc],
    _d_ =
      [0,
       [0, cst_Krb, 0],
       [0, [0, cst_Krb_test_mode, 0], [0, [0, cst_Rpc, 0], 0]]],
    cst_t = cst_t$1,
    cst_src_known_protocol_ml_3_0 = "src/known_protocol.ml:3:0",
    cst_t$0 = cst_t$1,
    cst_src_known_protocol_ml = cst_src_known_protocol_ml$0,
    cst_magic_numbers = "magic numbers",
    cst_protocol_version_header = cst_protocol_version_header$0,
    cst_Protocol_version_header_Kn = cst_Protocol_version_header_Kn$0;
   function t_of_sexp(sexp_006){
    a:
    {
     if(0 === sexp_006[0]){
      var _w_ = sexp_006[1];
      b:
      if(caml_string_notequal(_w_, cst_Krb)){
       c:
       if(caml_string_notequal(_w_, cst_Krb_test_mode)){
        if(caml_string_notequal(_w_, cst_Rpc)){
         if(! caml_string_notequal(_w_, cst_krb)) break b;
         if(! caml_string_notequal(_w_, cst_krb_test_mode)) break c;
         if(caml_string_notequal(_w_, cst_rpc)) break a;
        }
        return 2;
       }
       return 1;
      }
      return 0;
     }
     var _x_ = sexp_006[1];
     if(! _x_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_005, sexp_006);
     var _y_ = _x_[1];
     if(0 !== _y_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_005, sexp_006);
     var _z_ = _y_[1];
     b:
     if(caml_string_notequal(_z_, cst_Krb)){
      c:
      if(caml_string_notequal(_z_, cst_Krb_test_mode)){
       if(caml_string_notequal(_z_, cst_Rpc)){
        if(! caml_string_notequal(_z_, cst_krb)) break b;
        if(! caml_string_notequal(_z_, cst_krb_test_mode)) break c;
        if(caml_string_notequal(_z_, cst_rpc)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var
    _e_ = caml_call1(Bin_prot_Shape[5], _d_),
    _f_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), 0, _e_], 0],
    _g_ = caml_call1(Bin_shape[4][1], cst_src_known_protocol_ml_3_0),
    group = caml_call2(Bin_prot_Shape[2], _g_, _f_),
    _h_ = caml_call1(Bin_shape[2][1], cst_t$0);
   caml_call1(caml_call2(Bin_prot_Shape[10], group, _h_), 0);
   function magic_word(param){
    switch(param){
      case 0:
       return cst_KRB2;
      case 1:
       return cst_KBT;
      default: return cst_RPC;
    }
   }
   function gen_magic_number(word){
    function _u_(acc, c){
     return (acc * 256 | 0) + caml_call1(Core_Char[11], c) | 0;
    }
    var _v_ = caml_call1(Core_String[70], word);
    return caml_call3(Core_List[20], _v_, 0, _u_);
   }
   function magic_number(t){return gen_magic_number(magic_word(t));}
   function _i_(p){return [0, magic_number(p), p];}
   var
    _j_ = caml_call2(Core_List[51], all, _i_),
    by_magic_number = caml_call1(Core_Int[98][15], _j_);
   function _k_(param){
    var _q_ = gen_magic_number(retired_krb_word);
    if(! caml_call2(Core[90], _q_, 4346443))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
    var _r_ = magic_number(0);
    if(! caml_call2(Core[90], _r_, 843207243))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    var _s_ = magic_number(1);
    if(! caml_call2(Core[90], _s_, 5521995))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    var _t_ = magic_number(2);
    if(caml_call2(Core[90], _t_, 4411474)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
   }
   caml_call8
    (Ppx_inline_test_lib[9],
     Inline_test_config,
     cst_magic_numbers,
     0,
     cst_src_known_protocol_ml,
     28,
     0,
     223,
     _k_);
   var
    all_magic_numbers_including_re =
      [246,
       function(param){
        var
         _p_ =
           [0, retired_krb_word, caml_call2(Core_List[51], all, magic_word)];
        return caml_call2(Core_List[51], _p_, gen_magic_number);
       }],
    For_test = [0, all_magic_numbers_including_re];
   caml_call1(Ppx_inline_test_lib[7], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Kn);
   var
    Protocol_version_header_Known_ =
      [0,
       compare,
       all,
       t_of_sexp,
       sexp_of_t,
       magic_number,
       by_magic_number,
       For_test];
   runtime.caml_register_global
    (57, Protocol_version_header_Known_, cst_Protocol_version_header_Kn$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__List_with_max_len_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header_Li =
      "Protocol_version_header__List_with_max_len_intf",
    cst_protocol_version_header = "protocol_version_header";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Li);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][1], "src/list_with_max_len_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_protocol_version_header,
     "list_with_max_len_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Li);
   var Protocol_version_header_List_w = [0];
   runtime.caml_register_global
    (11, Protocol_version_header_List_w, cst_Protocol_version_header_Li);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__List_with_max_len
//# unitInfo: Requires: Base__Exn, Bin_prot__Read, Bin_prot__Shape, Bin_shape, Core, Core__Info, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Protocol_version_header__List_with_max_len_intf, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header_Li =
      "Protocol_version_header__List_with_max_len",
    cst_a$1 = "a",
    cst_protocol_version_header = "protocol_version_header",
    cst_t$1 = "t",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_List = global_data.Core__List,
    Core = global_data.Core,
    Core_Info = global_data.Core__Info,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Base_Exn = global_data.Base__Exn,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Li);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][1], "src/list_with_max_len.ml");
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_protocol_version_header,
     "list_with_max_len.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Li);
   var
    _a_ = [0, "max_len"],
    _b_ = [0, "len"],
    _c_ = [0, "context"],
    cst_List_is_too_large = "List is too large",
    cst_t$0 = cst_t$1,
    cst_a = cst_a$1,
    cst_src_list_with_max_len_ml_7 = "src/list_with_max_len.ml:7:14",
    cst_a$0 = cst_a$1,
    cst_t = cst_t$1,
    cst_src_list_with_max_len_ml_7$0 = "src/list_with_max_len.ml:7:2",
    Protocol_version_header_List_w =
      [0,
       function(Config){
        var
         max_len = Config[1],
         context = Config[2],
         _d_ = caml_call1(Bin_shape[3][1], cst_a),
         _e_ = caml_call1(Bin_shape[4][1], cst_src_list_with_max_len_ml_7),
         _f_ = caml_call2(Bin_prot_Shape[11], _e_, _d_),
         _g_ = caml_call1(Core[456], _f_),
         _h_ = [0, caml_call1(Bin_shape[3][1], cst_a$0), 0],
         _i_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), _h_, _g_], 0],
         _j_ = caml_call1(Bin_shape[4][1], cst_src_list_with_max_len_ml_7$0),
         group = caml_call2(Bin_prot_Shape[2], _j_, _i_);
        function bin_shape_t(a){
         var _A_ = caml_call1(Bin_shape[2][1], cst_t$0);
         return caml_call1
                 (caml_call2(Bin_prot_Shape[10], group, _A_), [0, a, 0]);
        }
        function bin_size_t(size_of_a, v){
         return caml_call2(Core[457], size_of_a, v);
        }
        function bin_write_t(write_a, buf, pos, v){
         return caml_call4(Core[459], write_a, buf, pos, v);
        }
        function bin_writer_t(bin_writer_a){
         function _w_(v){
          var _x_ = bin_writer_a[2];
          return function(_y_, _z_){return bin_write_t(_x_, v, _y_, _z_);};
         }
         return [0, function(v){return bin_size_t(bin_writer_a[1], v);}, _w_];
        }
        var bin_read_t = Core_List[158];
        function bin_read_t$0(bin_read_el, buf, pos_ref){
         try{
          var
           _v_ =
             caml_call4(Bin_prot_Read[40], max_len, bin_read_el, buf, pos_ref);
          return _v_;
         }
         catch(exn$0){
          var
           exn = caml_wrap_exception(exn$0),
           _u_ = caml_call1(Core_Info[12], context);
          return caml_call2(Base_Exn[8], exn, _u_);
         }
        }
        function bin_reader_t(bin_reader_a){
         var
          _q_ = caml_call1(bin_read_t, bin_reader_a[1]),
          _r_ = bin_reader_a[1];
         return [0,
                 function(_s_, _t_){return bin_read_t$0(_r_, _s_, _t_);},
                 _q_];
        }
        function bin_t(bin_a){
         var _o_ = bin_reader_t(bin_a[3]), _p_ = bin_writer_t(bin_a[2]);
         return [0, bin_shape_t(bin_a[1]), _p_, _o_];
        }
        function of_list_exn(l){
         var len = caml_call1(Core_List[45], l);
         if(caml_call2(Core[91], len, max_len)){
          var
           _k_ = [0, [1, [0, _a_, [0, caml_call1(Core[389], max_len), 0]]], 0],
           _l_ = [0, [1, [0, _b_, [0, caml_call1(Core[389], len), 0]]], _k_],
           _m_ =
             [0,
              [1, [0, _c_, [0, caml_call1(Core_Info[9], context), 0]]],
              _l_],
           _n_ =
             [1,
              [0,
               caml_call1(Sexplib0_Sexp_conv[7], cst_List_is_too_large),
               _m_]];
          caml_call1(Core[261], _n_);
         }
         return l;
        }
        var sexp_of_t = Core_List[6];
        function t_of_sexp(t_of_a, sexp){
         var t = caml_call2(Core_List[5], t_of_a, sexp);
         return of_list_exn(t);
        }
        return [0,
                bin_shape_t,
                bin_size_t,
                bin_write_t,
                bin_read_t$0,
                bin_read_t,
                bin_writer_t,
                bin_reader_t,
                bin_t,
                t_of_sexp,
                sexp_of_t,
                of_list_exn,
                max_len];
       }];
   runtime.caml_register_global
    (29, Protocol_version_header_List_w, cst_Protocol_version_header_Li);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header
//# unitInfo: Requires: Base__Or_error, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Type_class, Bin_shape, Core, Core__Fn, Core__Info, Core__Int, Core__List, Core__Map, Core__Or_error, Core__Set, Inline_test_config, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Protocol_version_header__Known_protocol, Protocol_version_header__List_with_max_len, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header$1 = "Protocol_version_header",
    cst_Protocol_version_header_ne$3 =
      "[Protocol_version_header.negotiate]: conflicting magic protocol numbers",
    cst_additional_magic_numbers = "additional_magic_numbers",
    cst_max_supported_version = "max_supported_version",
    cst_peer_protocol = "peer_protocol",
    cst_protocol_version_header$0 = "protocol_version_header",
    cst_src_protocol_version_heade$2 = "src/protocol_version_header.ml",
    cst_t$3 = "t",
    cst_us_protocol = "us_protocol",
    cst_us_versions = "us_versions",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Int = global_data.Core__Int,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Protocol_version_header_Known_ =
      global_data.Protocol_version_header__Known_protocol,
    Core_Map = global_data.Core__Map,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Core_List = global_data.Core__List,
    Bin_prot_Type_class = global_data.Bin_prot__Type_class,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Or_error = global_data.Core__Or_error,
    Core_Set = global_data.Core__Set,
    Base_Or_error = global_data.Base__Or_error,
    Core_Fn = global_data.Core__Fn,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Info = global_data.Core__Info,
    Protocol_version_header_List_w =
      global_data.Protocol_version_header__List_with_max_len,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header$1);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_protocol_version_heade$2);
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_protocol_version_header$0,
     "protocol_version_header.ml");
   var
    _D_ = [0, cst_src_protocol_version_heade$2, 202, 2],
    _C_ = [0, cst_src_protocol_version_heade$2, 203, 2],
    _B_ = [0, cst_src_protocol_version_heade$2, 204, 2],
    _u_ = [0, cst_us_versions],
    cst_No_magic_numbers_seen = "No magic numbers seen",
    _r_ = [0, "Unknown"],
    _s_ = [0, cst_peer_protocol],
    _t_ = [0, cst_us_protocol],
    cst_Protocol_version_header_ne$2 = cst_Protocol_version_header_ne$3,
    _m_ = [0, "protocol"],
    _n_ = [0, "peer_versions"],
    _o_ = [0, cst_us_versions],
    cst_Protocol_version_header_ne$0 =
      "[Protocol_version_header.negotiate]: no shared version numbers",
    _p_ = [0, cst_peer_protocol],
    _q_ = [0, cst_us_protocol],
    cst_Protocol_version_header_ne$1 = cst_Protocol_version_header_ne$3,
    _k_ = [0, "versions"],
    _l_ = [0, "protocols"],
    cst_Protocol_version_header_ne =
      "[Protocol_version_header.negotiate]: multiple magic numbers seen.",
    _i_ = [0, "known_protocol_magic_numbers"],
    _j_ = [0, cst_additional_magic_numbers],
    cst_additional_magic_numbers_s$0 =
      "[additional_magic_numbers] shouldn't be overlapping with potential [protocol_magic_number]s",
    _g_ = [0, cst_additional_magic_numbers],
    _h_ = [0, cst_max_supported_version],
    cst_additional_magic_numbers_s =
      "[additional_magic_numbers] shouldn't be within [max_supported_version] range",
    _e_ = [0, "supported_versions"],
    _f_ = [0, cst_max_supported_version],
    cst_Unable_to_advertise_versio =
      "Unable to advertise versions larger than max supported version",
    cst_Protocol_version_header = cst_Protocol_version_header$1,
    cst_t = cst_t$3,
    cst_src_protocol_version_heade = "src/protocol_version_header.ml:14:2",
    cst_t$0 = cst_t$3,
    cst_t$1 = cst_t$3,
    cst_src_protocol_version_heade$0 = "src/protocol_version_header.ml:135:2",
    cst_t$2 = cst_t$3,
    cst_src_protocol_version_heade$1 = cst_src_protocol_version_heade$2,
    cst_bin_sizes_are_not_changed_ = "bin sizes are not changed by accident",
    cst_protocol_version_header = cst_protocol_version_header$0,
    cst_Protocol_version_header$0 = cst_Protocol_version_header$1,
    max_supported_version = 1000000;
   function outside_max_supported_version_(num){
    return caml_call2(Core[91], num, max_supported_version);
   }
   var
    context = caml_call1(Core_Info[14], cst_Protocol_version_header),
    Bounded_list_in_case_someone_s =
      caml_call1(Protocol_version_header_List_w[1], [0, 100, context]),
    _a_ = caml_call1(Bounded_list_in_case_someone_s[1], Core[372]),
    _b_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), 0, _a_], 0],
    _c_ = caml_call1(Bin_shape[4][1], cst_src_protocol_version_heade),
    group = caml_call2(Bin_prot_Shape[2], _c_, _b_),
    _d_ = caml_call1(Bin_shape[2][1], cst_t$0),
    bin_shape_t = caml_call1(caml_call2(Bin_prot_Shape[10], group, _d_), 0);
   function bin_size_t(v){
    return caml_call2(Bounded_list_in_case_someone_s[2], Core[373], v);
   }
   function bin_write_t(buf, pos, v){
    return caml_call4
            (Bounded_list_in_case_someone_s[3], Core[375], buf, pos, v);
   }
   var bin_writer_t = [0, bin_size_t, bin_write_t];
   function bin_read_t(buf, pos_ref, vint){
    return caml_call3
            (caml_call1(Bounded_list_in_case_someone_s[5], Core[378]),
             buf,
             pos_ref,
             vint);
   }
   function bin_read_t$0(buf, pos_ref){
    return caml_call2
            (caml_call1(Bounded_list_in_case_someone_s[4], Core[378]),
             buf,
             pos_ref);
   }
   var
    bin_reader_t = [0, bin_read_t$0, bin_read_t],
    bin_t = [0, bin_shape_t, bin_writer_t, bin_reader_t];
   function t_of_sexp(x_002){
    return caml_call2(Bounded_list_in_case_someone_s[9], Core[390], x_002);
   }
   function sexp_of_t(x_003){
    return caml_call2(Bounded_list_in_case_someone_s[10], Core[389], x_003);
   }
   var
    known_protocol_magic_numbers =
      [246,
       function(_at_){
        return caml_call1(Core_Map[120], Protocol_version_header_Known_[6]);
       }];
   function create_exn(opt, protocol, supported_versions, param){
    if(opt)
     var sth = opt[1], additional_magic_numbers = sth;
    else
     var additional_magic_numbers = 0;
    var
     protocol_magic_number =
       caml_call1(Protocol_version_header_Known_[5], protocol);
    if
     (caml_call2
       (Core_List[23], supported_versions, outside_max_supported_version_)){
     var
      _af_ =
        [0,
         [1,
          [0,
           _e_,
           [0, caml_call2(Core[472], Core[389], supported_versions), 0]]],
         0],
      _ag_ =
        [0,
         [1, [0, _f_, [0, caml_call1(Core[389], max_supported_version), 0]]],
         _af_],
      _ah_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Unable_to_advertise_versio),
          _ag_]];
     caml_call1(Core[261], _ah_);
    }
    var _ai_ = caml_call1(Core_Fn[2], outside_max_supported_version_);
    if(caml_call2(Core_List[23], additional_magic_numbers, _ai_)){
     var
      _aj_ =
        [0,
         [1,
          [0,
           _g_,
           [0, caml_call2(Core[472], Core[389], additional_magic_numbers), 0]]],
         0],
      _ak_ =
        [0,
         [1, [0, _h_, [0, caml_call1(Core[389], max_supported_version), 0]]],
         _aj_],
      _al_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_additional_magic_numbers_s),
          _ak_]];
     caml_call1(Core[261], _al_);
    }
    var
     _am_ = caml_call1(Core[248], known_protocol_magic_numbers),
     _an_ = caml_call1(Core_Set[11], _am_);
    if(caml_call2(Core_List[23], additional_magic_numbers, _an_)){
     var
      _ao_ = caml_call1(Core[248], known_protocol_magic_numbers),
      _ap_ = [0, [1, [0, _i_, [0, caml_call1(Core_Int[99][28], _ao_), 0]]], 0],
      _aq_ =
        [0,
         [1,
          [0,
           _j_,
           [0, caml_call2(Core[472], Core[389], additional_magic_numbers), 0]]],
         _ap_],
      _ar_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_additional_magic_numbers_s$0),
          _aq_]];
     caml_call1(Core[261], _ar_);
    }
    var
     _as_ =
       [0,
        protocol_magic_number,
        caml_call2(Core[156], additional_magic_numbers, supported_versions)];
    return caml_call1(Bounded_list_in_case_someone_s[11], _as_);
   }
   function raw_version_list(t){return t;}
   function get_protocol(t){
    function _ab_(v){
     var
      match = caml_call2(Core_Map[44], Protocol_version_header_Known_[6], v);
     if(! match)
      return outside_max_supported_version_(v)
              ? [0, 4202758, v]
              : [0, 4152137, v];
     var p = match[1];
     return [0, 3506791, p];
    }
    var
     match = caml_call2(Core_List[76], t, _ab_),
     versions = match[2],
     protocols = match[1];
    if(! protocols) return [0, [0, 0, caml_call1(Core_Int[99][8], versions)]];
    if(protocols[2]){
     var
      _ac_ =
        [0,
         [1, [0, _k_, [0, caml_call2(Core[472], Core[389], versions), 0]]],
         0],
      _ad_ =
        [0,
         [1,
          [0,
           _l_,
           [0,
            caml_call2
             (Core[472], Protocol_version_header_Known_[4], protocols),
            0]]],
         _ac_],
      _ae_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne),
          _ad_]];
     return caml_call1(Core_Or_error[45], _ae_);
    }
    var p = protocols[1];
    return [0, [0, [0, p], caml_call1(Core_Int[99][8], versions)]];
   }
   function negotiate(allow_legacy_peer, us, peer){
    function _I_(param){
     var us_versions = param[2], us_protocol = param[1];
     function _K_(param){
      var peer_versions = param[2], peer_protocol = param[1];
      function _M_(us_protocol){
       function _Q_(peer_protocol){
        var
         _U_ =
           0
            ===
             caml_call2
              (Protocol_version_header_Known_[1], us_protocol, peer_protocol)
            ? 1
            : 0;
        if(! _U_){
         var
          ___ =
            [0,
             [1,
              [0,
               _p_,
               [0,
                caml_call1(Protocol_version_header_Known_[4], peer_protocol),
                0]]],
             0],
          _$_ =
            [0,
             [1,
              [0,
               _q_,
               [0,
                caml_call1(Protocol_version_header_Known_[4], us_protocol),
                0]]],
             ___],
          _aa_ =
            [1,
             [0,
              caml_call1
               (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$1),
              _$_]];
         return caml_call1(Core_Or_error[45], _aa_);
        }
        var
         _V_ = caml_call2(Core_Set[16], us_versions, peer_versions),
         match = caml_call1(Core_Set[60], _V_);
        if(match){var version = match[1]; return [0, version];}
        var
         _W_ =
           [0,
            [1,
             [0,
              _m_,
              [0,
               caml_call1(Protocol_version_header_Known_[4], us_protocol),
               0]]],
            0],
         _X_ =
           [0,
            [1, [0, _n_, [0, caml_call1(Core_Int[99][28], peer_versions), 0]]],
            _W_],
         _Y_ =
           [0,
            [1, [0, _o_, [0, caml_call1(Core_Int[99][28], us_versions), 0]]],
            _X_],
         _Z_ =
           [1,
            [0,
             caml_call1
              (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$0),
             _Y_]];
        return caml_call1(Core_Or_error[45], _Z_);
       }
       if(peer_protocol)
        var x = peer_protocol[1], _R_ = caml_call1(Base_Or_error[28][1], x);
       else if(allow_legacy_peer)
        var _R_ = caml_call1(Base_Or_error[28][1], us_protocol);
       else
        var
         _S_ =
           [0,
            [1,
             [0,
              _t_,
              [0,
               caml_call1(Protocol_version_header_Known_[4], us_protocol),
               0]]],
            [0, [1, [0, _s_, [0, _r_, 0]]], 0]],
         _T_ =
           [1,
            [0,
             caml_call1
              (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$2),
             _S_]],
         _R_ = caml_call1(Core_Or_error[45], _T_);
       return caml_call2(Base_Or_error[28][4][2], _R_, _Q_);
      }
      if(us_protocol)
       var x = us_protocol[1], _N_ = caml_call1(Base_Or_error[28][1], x);
      else
       var
        _O_ =
          [0,
           [1, [0, _u_, [0, caml_call1(Core_Int[99][28], us_versions), 0]]],
           0],
        _P_ =
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7], cst_No_magic_numbers_seen),
            _O_]],
        _N_ = caml_call1(Core[245], _P_);
      return caml_call2(Base_Or_error[28][4][2], _N_, _M_);
     }
     var _L_ = get_protocol(peer);
     return caml_call2(Base_Or_error[28][4][2], _L_, _K_);
    }
    var _J_ = get_protocol(us);
    return caml_call2(Base_Or_error[28][4][2], _J_, _I_);
   }
   function matches_magic_prefix(t, protocol){
    var
     magic_number = caml_call1(Protocol_version_header_Known_[5], protocol);
    return caml_call3(Core_List[17], t, magic_number, Core_Int[87]);
   }
   function contains_magic_prefix(protocol){
    var _F_ = bin_t[3];
    function _G_(_H_){return matches_magic_prefix(_H_, protocol);}
    return caml_call2(Bin_prot_Type_class[151], _G_, _F_);
   }
   function f(t){
    function _E_(protocol){return matches_magic_prefix(t, protocol);}
    return caml_call2(Core_List[27], Protocol_version_header_Known_[2], _E_);
   }
   var
    any_magic_prefix = caml_call2(Bin_prot_Type_class[151], f, bin_t[3]),
    _v_ = Core[372],
    _w_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$1), 0, _v_], 0],
    _x_ = caml_call1(Bin_shape[4][1], cst_src_protocol_version_heade$0),
    group$0 = caml_call2(Bin_prot_Shape[2], _x_, _w_),
    _y_ = caml_call1(Bin_shape[2][1], cst_t$2);
   caml_call1(caml_call2(Bin_prot_Shape[10], group$0, _y_), 0);
   var
    bin_size_t$0 = Core[373],
    any_magic_prefix_from_six_byte =
      caml_call1(bin_size_t$0, Bounded_list_in_case_someone_s[12]) + 5 | 0,
    magic_number_bin_size = 5;
   function bin_read_t$1(buf, pos_ref){
    caml_call2(Bin_prot_Read[7], buf, pos_ref);
    return caml_call2(Bin_prot_Read[6], buf, pos_ref);
   }
   var bin_reader_t$0 = [0, bin_read_t$1, Core_Int[124]];
   function _z_(magic_number){
    return caml_call1
            (caml_call1(Core_Map[44], Protocol_version_header_Known_[6]),
             magic_number);
   }
   var
    any_magic_prefix_from_six_byte$0 =
      caml_call2(Bin_prot_Type_class[151], _z_, bin_reader_t$0),
    Pair = [0],
    none = caml_call1(Bounded_list_in_case_someone_s[11], 0);
   function is_none(t){return t ? 0 : 1;}
   var Expert = [0, raw_version_list, none, is_none];
   function _A_(param){
    var
     bounded_list_bin_size =
       caml_call1(Core_Int[121], Bounded_list_in_case_someone_s[12]);
    if(! caml_call2(Core[90], bounded_list_bin_size, 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
    if(! caml_call2(Core[90], 6, 5 + bounded_list_bin_size | 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
    if
     (caml_call2
       (Core[90],
        any_magic_prefix_from_six_byte,
        5 + bounded_list_bin_size | 0))
     return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
   }
   caml_call8
    (Ppx_inline_test_lib[9],
     Inline_test_config,
     cst_bin_sizes_are_not_changed_,
     0,
     cst_src_protocol_version_heade$1,
     194,
     0,
     707,
     _A_);
   caml_call1(Ppx_inline_test_lib[7], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header$0);
   var
    Protocol_version_header =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t$0,
       bin_read_t,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       t_of_sexp,
       sexp_of_t,
       create_exn,
       negotiate,
       contains_magic_prefix,
       any_magic_prefix,
       any_magic_prefix_from_six_byte$0,
       any_magic_prefix_from_six_byte,
       Pair,
       Expert,
       [0,
        Protocol_version_header_List_w[1],
        magic_number_bin_size,
        max_supported_version]];
   runtime.caml_register_global
    (66, Protocol_version_header, cst_Protocol_version_header$1);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcm90b2NvbF92ZXJzaW9uX2hlYWRlci5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiYWxsIiwiZXJyb3Jfc291cmNlXzAwNSIsInJldGlyZWRfa3JiX3dvcmQiLCJjb21wYXJlIiwidF9vZl9zZXhwIiwic2V4cF8wMDYiLCJzZXhwX29mX3QiLCJncm91cCIsIm1hZ2ljX3dvcmQiLCJnZW5fbWFnaWNfbnVtYmVyIiwid29yZCIsImFjYyIsImMiLCJtYWdpY19udW1iZXIiLCJ0IiwicCIsImJ5X21hZ2ljX251bWJlciIsImFsbF9tYWdpY19udW1iZXJzX2luY2x1ZGluZ19yZSIsImJpbl9zaGFwZV90IiwiYSIsImJpbl9zaXplX3QiLCJzaXplX29mX2EiLCJ2IiwiYmluX3dyaXRlX3QiLCJ3cml0ZV9hIiwiYnVmIiwicG9zIiwiYmluX3dyaXRlcl90IiwiYmluX3dyaXRlcl9hIiwiYmluX3JlYWRfdCIsImJpbl9yZWFkX3QkMCIsImJpbl9yZWFkX2VsIiwicG9zX3JlZiIsImV4biQwIiwiZXhuIiwiYmluX3JlYWRlcl90IiwiYmluX3JlYWRlcl9hIiwiYmluX3QiLCJiaW5fYSIsIm9mX2xpc3RfZXhuIiwibCIsImxlbiIsInRfb2ZfYSIsInNleHAiLCJtYXhfc3VwcG9ydGVkX3ZlcnNpb24iLCJvdXRzaWRlX21heF9zdXBwb3J0ZWRfdmVyc2lvbl8iLCJudW0iLCJjb250ZXh0IiwidmludCIsInhfMDAyIiwieF8wMDMiLCJrbm93bl9wcm90b2NvbF9tYWdpY19udW1iZXJzIiwiY3JlYXRlX2V4biIsIm9wdCIsInByb3RvY29sIiwic3VwcG9ydGVkX3ZlcnNpb25zIiwic3RoIiwiYWRkaXRpb25hbF9tYWdpY19udW1iZXJzIiwicHJvdG9jb2xfbWFnaWNfbnVtYmVyIiwicmF3X3ZlcnNpb25fbGlzdCIsImdldF9wcm90b2NvbCIsInZlcnNpb25zIiwicHJvdG9jb2xzIiwibmVnb3RpYXRlIiwiYWxsb3dfbGVnYWN5X3BlZXIiLCJ1cyIsInBlZXIiLCJ1c192ZXJzaW9ucyIsInVzX3Byb3RvY29sIiwicGVlcl92ZXJzaW9ucyIsInBlZXJfcHJvdG9jb2wiLCJ2ZXJzaW9uIiwieCIsIm1hdGNoZXNfbWFnaWNfcHJlZml4IiwiY29udGFpbnNfbWFnaWNfcHJlZml4IiwiZiIsImFueV9tYWdpY19wcmVmaXgiLCJncm91cCQwIiwiYmluX3NpemVfdCQwIiwiYW55X21hZ2ljX3ByZWZpeF9mcm9tX3NpeF9ieXRlIiwibWFnaWNfbnVtYmVyX2Jpbl9zaXplIiwiYmluX3JlYWRfdCQxIiwiYmluX3JlYWRlcl90JDAiLCJhbnlfbWFnaWNfcHJlZml4X2Zyb21fc2l4X2J5dGUkMCIsIm5vbmUiLCJpc19ub25lIiwiYm91bmRlZF9saXN0X2Jpbl9zaXplIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIvcHJvdG9jb2xfdmVyc2lvbl9oZWFkZXJfXy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3Byb3RvY29sX3ZlcnNpb25faGVhZGVyL2tub3duX3Byb3RvY29sLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIvbGlzdF93aXRoX21heF9sZW4ubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9wcm90b2NvbF92ZXJzaW9uX2hlYWRlci9wcm90b2NvbF92ZXJzaW9uX2hlYWRlci5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztHQVdtQzs7SUFBQTs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQ1RuQ0E7SUFBQUM7SUFzQklDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdEJKO0lBQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBQUEsU0FB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O0tBQWZ6QyxlQUFlLDhDQURheUM7SUFFaEMsT0FBQSwwQkFGd0J4QyxHQUNwQkQ7R0FDdUQ7WUFHekQ2RCxzQkFBdUJwQjtJQUN6QixVQTVHQWpCO3NCLE9Bc0dFb0MsMEJBS3VCbkI7SUFDTSxPQUFBO0dBQTZDO1lBSXhFcUIsRUFBRTdEO2lCQUNpQ3dDLFVBQVksT0FYakRtQixxQkFVSTNELEdBQ2lDd0MsVUFBNEM7SUFBakQsT0FBQTtHQUFrRDtHQUVwRjtJQUpFc0IsbUJBSUYscUNBSElELEdBaEhKdEM7O0lBeUhBLGNBQUs7SUFBTCxNQUFBO0lBQUF3QyxVQUFBO0lBQUEsTUFBQTtHQUFBLFdBQUEsK0JBQUFBO0dBWUU7SUFaRkM7SUFnQ0VDO01BcEJBLFdBWkZEO0lBSEVFO1lBbUJFQyxhQUFXeEQsS0FBS087SUFDcUIsNkJBRDFCUCxLQUFLTztJQUVsQixPQUFBLDZCQUZhUCxLQUFLTztHQUVxQjtHQUl2QyxJQURFa0QscUJBTEFEO2dCQVlHcEU7SUFBZ0IsT0FBQTthQUFBO2FBQWhCQTtHQUFzRTtHQUQ3RTtJQURFc0U7TUFDRiwwQ0FOSUQ7SUFhUTtJQVNSRSxPQUFPO1lBRVBDLFFBQVN2RSxHQUNYLE9BRFdBLFVBR007R0FQTCxpQkE5SFo2QyxrQkFnSUV5QixNQUVBQzs7SUFvQkY7S0FERUM7T0FDRjtJQUVLLEtBQUEscUJBSEhBO0tBR0osTUFBQTtJQUNPLEtBQUEsNEJBSkhBO0tBSUosTUFBQTtJQUNPO01BQUE7O1FBckNMUDtZQWdDRU87O0lBS0osTUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTlMQWxFO09BQUFHO09BQUFPO09BQUFEO09BQUtYO09BQUxTO09BQUFRO09BQUFFO09BQUFqQztPQUFBRTtPQU1FOEM7T0FvREFXO09BaURBVztPQUlBRTtPQW9DQU87T0FNQUo7Ozs7O1FBbkNBQztRQWhJQXBDOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBQcm90b2NvbF92ZXJzaW9uX2hlYWRlci5Lbm93bl9wcm90b2NvbCAqKVxubW9kdWxlIEtub3duX3Byb3RvY29sID0gUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXJfX0tub3duX3Byb3RvY29sXG5cbigqKiBAY2Fub25pY2FsIFByb3RvY29sX3ZlcnNpb25faGVhZGVyLkxpc3Rfd2l0aF9tYXhfbGVuICopXG5tb2R1bGUgTGlzdF93aXRoX21heF9sZW4gPSBQcm90b2NvbF92ZXJzaW9uX2hlYWRlcl9fTGlzdF93aXRoX21heF9sZW5cblxuKCoqIEBjYW5vbmljYWwgUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIuTGlzdF93aXRoX21heF9sZW5faW50ZiAqKVxubW9kdWxlIExpc3Rfd2l0aF9tYXhfbGVuX2ludGYgPSBQcm90b2NvbF92ZXJzaW9uX2hlYWRlcl9fTGlzdF93aXRoX21heF9sZW5faW50ZlxuXG5tb2R1bGUgUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXJfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwib3BlbiEgQ29yZVxuXG50eXBlIHQgPVxuICB8IEtyYlxuICB8IEtyYl90ZXN0X21vZGVcbiAgfCBScGNcbltAQGRlcml2aW5nIGNvbXBhcmUsIGVudW1lcmF0ZSwgc2V4cCwgYmluX2lvXVxuXG5sZXQgbWFnaWNfd29yZCA9IGZ1bmN0aW9uXG4gIHwgS3JiIC0+IFwiS1JCMlwiXG4gIHwgS3JiX3Rlc3RfbW9kZSAtPiBcIktCVFwiXG4gIHwgUnBjIC0+IFwiUlBDXCJcbjs7XG5cbmxldCBnZW5fbWFnaWNfbnVtYmVyIHdvcmQgPVxuICBTdHJpbmcudG9fbGlzdF9yZXYgd29yZFxuICB8PiBMaXN0LmZvbGQgfmluaXQ6MCB+ZjooZnVuIGFjYyBjIC0+IChhY2MgKiAyNTYpICsgQ2hhci50b19pbnQgYylcbjs7XG5cbmxldCBtYWdpY19udW1iZXIgdCA9IGdlbl9tYWdpY19udW1iZXIgKG1hZ2ljX3dvcmQgdClcbmxldCBieV9tYWdpY19udW1iZXIgPSBJbnQuTWFwLm9mX2FsaXN0X2V4biAoTGlzdC5tYXAgYWxsIH5mOihmdW4gcCAtPiBtYWdpY19udW1iZXIgcCwgcCkpXG5cbigqIFdlIG9uY2UgbWludGVkIGEgbmV3IG1hZ2ljIG51bWJlciBmb3IgS3JiIGluIG9yZGVyIHRvIGNoYW5nZSB0aGUgcHJvdG9jb2xcbiAgIG5lZ290aWF0aW9uLiAgTGV0J3MgYmUgY2FyZWZ1bCB0aGF0IHdlIGRvbid0IHJldXNlIHRoZSBvbGQgbWFnaWMgbnVtYmVyICopXG5sZXQgcmV0aXJlZF9rcmJfd29yZCA9IFwiS1JCXCJcblxuKCogRW5zdXJlIHRlc3RzIGJyZWFrIGlmIHRoZSBtYWdpYyBudW1iZXJzIGFyZSBjaGFuZ2VkICopXG5sZXQldGVzdF91bml0IFwibWFnaWMgbnVtYmVyc1wiID1cbiAgYXNzZXJ0IChnZW5fbWFnaWNfbnVtYmVyIHJldGlyZWRfa3JiX3dvcmQgPSA0XzM0Nl80NDMpO1xuICBhc3NlcnQgKG1hZ2ljX251bWJlciBLcmIgPSA4NDNfMjA3XzI0Myk7XG4gIGFzc2VydCAobWFnaWNfbnVtYmVyIEtyYl90ZXN0X21vZGUgPSA1XzUyMV85OTUpO1xuICBhc3NlcnQgKG1hZ2ljX251bWJlciBScGMgPSA0XzQxMV80NzQpXG47O1xuXG5tb2R1bGUgRm9yX3Rlc3QgPSBzdHJ1Y3RcbiAgbGV0IGFsbF9tYWdpY19udW1iZXJzX2luY2x1ZGluZ19yZXRpcmVkID1cbiAgICBsYXp5IChyZXRpcmVkX2tyYl93b3JkIDo6IExpc3QubWFwIGFsbCB+ZjptYWdpY193b3JkIHw+IExpc3QubWFwIH5mOmdlbl9tYWdpY19udW1iZXIpXG4gIDs7XG5lbmRcbiIsIm9wZW4hIENvcmVcbmluY2x1ZGUgTGlzdF93aXRoX21heF9sZW5faW50ZlxuXG5tb2R1bGUgTWFrZSAoQ29uZmlnIDogQ29uZmlnKSA9IHN0cnVjdFxuICBpbmNsdWRlIENvbmZpZ1xuXG4gIHR5cGUgJ2EgdCA9ICdhIGxpc3QgW0BAZGVyaXZpbmcgYmluX3NoYXBlLCBiaW5fd3JpdGVdXG5cbiAgbGV0IF9fYmluX3JlYWRfdF9fID0gTGlzdC5fX2Jpbl9yZWFkX3RfX1xuXG4gIGxldCBiaW5fcmVhZF90IGJpbl9yZWFkX2VsIGJ1ZiB+cG9zX3JlZiA9XG4gICAgdHJ5IEJpbl9wcm90LlJlYWQuYmluX3JlYWRfbGlzdF93aXRoX21heF9sZW4gfm1heF9sZW4gYmluX3JlYWRfZWwgYnVmIH5wb3NfcmVmIHdpdGhcbiAgICB8IGV4biAtPiBFeG4ucmVyYWlzZSBleG4gKEluZm8udG9fc3RyaW5nX2h1bSBjb250ZXh0KVxuICA7O1xuXG4gIGxldCBiaW5fcmVhZGVyX3QgKGJpbl9yZWFkZXJfYSA6ICdhIEJpbl9wcm90LlR5cGVfY2xhc3MucmVhZGVyKSA9XG4gICAgeyBCaW5fcHJvdC5UeXBlX2NsYXNzLnJlYWQgPSBiaW5fcmVhZF90IGJpbl9yZWFkZXJfYS5yZWFkXG4gICAgOyB2dGFnX3JlYWQgPSBfX2Jpbl9yZWFkX3RfXyBiaW5fcmVhZGVyX2EucmVhZFxuICAgIH1cbiAgOztcblxuICBsZXQgYmluX3QgKGJpbl9hIDogJ2EgQmluX3Byb3QuVHlwZV9jbGFzcy50KSA9XG4gICAgeyBCaW5fcHJvdC5UeXBlX2NsYXNzLnNoYXBlID0gYmluX3NoYXBlX3QgYmluX2Euc2hhcGVcbiAgICA7IHdyaXRlciA9IGJpbl93cml0ZXJfdCBiaW5fYS53cml0ZXJcbiAgICA7IHJlYWRlciA9IGJpbl9yZWFkZXJfdCBiaW5fYS5yZWFkZXJcbiAgICB9XG4gIDs7XG5cbiAgbGV0IG9mX2xpc3RfZXhuIGwgPVxuICAgIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCBsIGluXG4gICAgaWYgbGVuID4gbWF4X2xlblxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiTGlzdCBpcyB0b28gbGFyZ2VcIiAoY29udGV4dCA6IEluZm8udCkgKGxlbiA6IGludCkgKG1heF9sZW4gOiBpbnQpXTtcbiAgICBsXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA9IExpc3Quc2V4cF9vZl90XG5cbiAgbGV0IHRfb2Zfc2V4cCB0X29mX2Egc2V4cCA9XG4gICAgbGV0IHQgPSBMaXN0LnRfb2Zfc2V4cCB0X29mX2Egc2V4cCBpblxuICAgIG9mX2xpc3RfZXhuIHRcbiAgOztcbmVuZFxuIiwib3BlbiEgQ29yZVxubW9kdWxlIEtub3duX3Byb3RvY29sID0gS25vd25fcHJvdG9jb2xcblxubGV0IG1heF9zdXBwb3J0ZWRfdmVyc2lvbiA9IDFfMDAwXzAwMFxubGV0IG91dHNpZGVfbWF4X3N1cHBvcnRlZF92ZXJzaW9uX3JhbmdlIG51bSA9IG51bSA+IG1heF9zdXBwb3J0ZWRfdmVyc2lvblxuXG5tb2R1bGUgQm91bmRlZF9saXN0X2luX2Nhc2Vfc29tZW9uZV9zZW5kc19nYXJiYWdlX29uX3RoZV93aXJlID1cbkxpc3Rfd2l0aF9tYXhfbGVuLk1ha2UgKHN0cnVjdFxuICBsZXQgbWF4X2xlbiA9IDEwMFxuICBsZXQgY29udGV4dCA9IEluZm8ub2Zfc3RyaW5nIFwiUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXJcIlxuZW5kKVxuXG5pbmNsdWRlIHN0cnVjdFxuICB0eXBlIHQgPSBpbnQgQm91bmRlZF9saXN0X2luX2Nhc2Vfc29tZW9uZV9zZW5kc19nYXJiYWdlX29uX3RoZV93aXJlLnRcbiAgW0BAZGVyaXZpbmcgYmluX2lvLCBzZXhwXVxuZW5kXG5cbmxldCBrbm93bl9wcm90b2NvbF9tYWdpY19udW1iZXJzID0gbGF6eSAoTWFwLmtleV9zZXQgS25vd25fcHJvdG9jb2wuYnlfbWFnaWNfbnVtYmVyKVxuXG5sZXQgY3JlYXRlX2V4biA/KGFkZGl0aW9uYWxfbWFnaWNfbnVtYmVycyA9IFtdKSB+cHJvdG9jb2wgfnN1cHBvcnRlZF92ZXJzaW9ucyAoKSA9XG4gIGxldCBwcm90b2NvbF9tYWdpY19udW1iZXIgPSBLbm93bl9wcm90b2NvbC5tYWdpY19udW1iZXIgcHJvdG9jb2wgaW5cbiAgaWYgTGlzdC5leGlzdHMgc3VwcG9ydGVkX3ZlcnNpb25zIH5mOm91dHNpZGVfbWF4X3N1cHBvcnRlZF92ZXJzaW9uX3JhbmdlXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJVbmFibGUgdG8gYWR2ZXJ0aXNlIHZlcnNpb25zIGxhcmdlciB0aGFuIG1heCBzdXBwb3J0ZWQgdmVyc2lvblwiXG4gICAgICAgICAgKG1heF9zdXBwb3J0ZWRfdmVyc2lvbiA6IGludClcbiAgICAgICAgICAoc3VwcG9ydGVkX3ZlcnNpb25zIDogaW50IGxpc3QpXTtcbiAgaWYgTGlzdC5leGlzdHMgYWRkaXRpb25hbF9tYWdpY19udW1iZXJzIH5mOihGbi5ub24gb3V0c2lkZV9tYXhfc3VwcG9ydGVkX3ZlcnNpb25fcmFuZ2UpXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJbYWRkaXRpb25hbF9tYWdpY19udW1iZXJzXSBzaG91bGRuJ3QgYmUgd2l0aGluIFttYXhfc3VwcG9ydGVkX3ZlcnNpb25dIHJhbmdlXCJcbiAgICAgICAgICAobWF4X3N1cHBvcnRlZF92ZXJzaW9uIDogaW50KVxuICAgICAgICAgIChhZGRpdGlvbmFsX21hZ2ljX251bWJlcnMgOiBpbnQgbGlzdCldO1xuICBpZiBMaXN0LmV4aXN0c1xuICAgICAgIGFkZGl0aW9uYWxfbWFnaWNfbnVtYmVyc1xuICAgICAgIH5mOihTZXQubWVtIChmb3JjZSBrbm93bl9wcm90b2NvbF9tYWdpY19udW1iZXJzKSlcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlthZGRpdGlvbmFsX21hZ2ljX251bWJlcnNdIHNob3VsZG4ndCBiZSBvdmVybGFwcGluZyB3aXRoIHBvdGVudGlhbCBcXFxuICAgICAgICAgW3Byb3RvY29sX21hZ2ljX251bWJlcl1zXCJcbiAgICAgICAgICAoYWRkaXRpb25hbF9tYWdpY19udW1iZXJzIDogaW50IGxpc3QpXG4gICAgICAgICAgfmtub3duX3Byb3RvY29sX21hZ2ljX251bWJlcnM6KGZvcmNlIGtub3duX3Byb3RvY29sX21hZ2ljX251bWJlcnMgOiBJbnQuU2V0LnQpXTtcbiAgcHJvdG9jb2xfbWFnaWNfbnVtYmVyIDo6IChhZGRpdGlvbmFsX21hZ2ljX251bWJlcnMgQCBzdXBwb3J0ZWRfdmVyc2lvbnMpXG4gIHw+IEJvdW5kZWRfbGlzdF9pbl9jYXNlX3NvbWVvbmVfc2VuZHNfZ2FyYmFnZV9vbl90aGVfd2lyZS5vZl9saXN0X2V4blxuOztcblxubGV0IHJhd192ZXJzaW9uX2xpc3QgKHQgOiB0KSA9ICh0IDo+IGludCBsaXN0KVxuXG5sZXQgZ2V0X3Byb3RvY29sICh0IDogdCkgPVxuICBsZXQgcHJvdG9jb2xzLCB2ZXJzaW9ucywgX2FkZGl0aW9uYWxfbWFnaWNfbnVtYmVycyA9XG4gICAgTGlzdC5wYXJ0aXRpb24zX21hcFxuICAgICAgKHQgOj4gaW50IGxpc3QpXG4gICAgICB+ZjooZnVuIHYgLT5cbiAgICAgICAgbWF0Y2ggTWFwLmZpbmQgS25vd25fcHJvdG9jb2wuYnlfbWFnaWNfbnVtYmVyIHYgd2l0aFxuICAgICAgICB8IFNvbWUgcCAtPiBgRnN0IHBcbiAgICAgICAgfCBOb25lIC0+IGlmIG91dHNpZGVfbWF4X3N1cHBvcnRlZF92ZXJzaW9uX3JhbmdlIHYgdGhlbiBgVHJkIHYgZWxzZSBgU25kIHYpXG4gIGluXG4gIG1hdGNoIHByb3RvY29scyB3aXRoXG4gIHwgW10gLT4gT2sgKE5vbmUsIEludC5TZXQub2ZfbGlzdCB2ZXJzaW9ucylcbiAgfCBbIHAgXSAtPiBPayAoU29tZSBwLCBJbnQuU2V0Lm9mX2xpc3QgdmVyc2lvbnMpXG4gIHwgXyAtPlxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIltQcm90b2NvbF92ZXJzaW9uX2hlYWRlci5uZWdvdGlhdGVdOiBtdWx0aXBsZSBtYWdpYyBudW1iZXJzIHNlZW4uXCJcbiAgICAgICAgICAocHJvdG9jb2xzIDogS25vd25fcHJvdG9jb2wudCBsaXN0KVxuICAgICAgICAgICh2ZXJzaW9ucyA6IGludCBsaXN0KV1cbjs7XG5cbmxldCBuZWdvdGlhdGUgfmFsbG93X2xlZ2FjeV9wZWVyIH4odXMgOiB0KSB+KHBlZXIgOiB0KSA9XG4gIGxldCBvcGVuIE9yX2Vycm9yLkxldF9zeW50YXggaW5cbiAgbGV0JWJpbmQgdXNfcHJvdG9jb2wsIHVzX3ZlcnNpb25zID0gZ2V0X3Byb3RvY29sIHVzIGluXG4gIGxldCViaW5kIHBlZXJfcHJvdG9jb2wsIHBlZXJfdmVyc2lvbnMgPSBnZXRfcHJvdG9jb2wgcGVlciBpblxuICBsZXQlYmluZCB1c19wcm90b2NvbCA9XG4gICAgbWF0Y2ggdXNfcHJvdG9jb2wgd2l0aFxuICAgIHwgU29tZSB4IC0+IHJldHVybiB4XG4gICAgfCBOb25lIC0+IGVycm9yX3MgWyVtZXNzYWdlIFwiTm8gbWFnaWMgbnVtYmVycyBzZWVuXCIgKHVzX3ZlcnNpb25zIDogSW50LlNldC50KV1cbiAgaW5cbiAgbGV0JWJpbmQgcGVlcl9wcm90b2NvbCA9XG4gICAgbWF0Y2ggcGVlcl9wcm90b2NvbCB3aXRoXG4gICAgfCBTb21lIHggLT4gcmV0dXJuIHhcbiAgICB8IE5vbmUgLT5cbiAgICAgICgqIHdlIGFzc3VtZSBwZWVyIGlzIHNwZWFraW5nIG91ciBwcm90b2NvbCBpZiBbYWxsb3dfbGVnYWN5X3BlZXJdICopXG4gICAgICBpZiBhbGxvd19sZWdhY3lfcGVlclxuICAgICAgdGhlbiByZXR1cm4gdXNfcHJvdG9jb2xcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcGVlcl9wcm90b2NvbCA9IGBVbmtub3duIGluXG4gICAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFwiW1Byb3RvY29sX3ZlcnNpb25faGVhZGVyLm5lZ290aWF0ZV06IGNvbmZsaWN0aW5nIG1hZ2ljIHByb3RvY29sIG51bWJlcnNcIlxuICAgICAgICAgICAgICAodXNfcHJvdG9jb2wgOiBLbm93bl9wcm90b2NvbC50KVxuICAgICAgICAgICAgICAocGVlcl9wcm90b2NvbCA6IFsgYFVua25vd24gXSldKVxuICBpblxuICBpZiBub3QgKFslY29tcGFyZS5lcXVhbDogS25vd25fcHJvdG9jb2wudF0gdXNfcHJvdG9jb2wgcGVlcl9wcm90b2NvbClcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIltQcm90b2NvbF92ZXJzaW9uX2hlYWRlci5uZWdvdGlhdGVdOiBjb25mbGljdGluZyBtYWdpYyBwcm90b2NvbCBudW1iZXJzXCJcbiAgICAgICAgICAodXNfcHJvdG9jb2wgOiBLbm93bl9wcm90b2NvbC50KVxuICAgICAgICAgIChwZWVyX3Byb3RvY29sIDogS25vd25fcHJvdG9jb2wudCldXG4gIGVsc2UgKFxuICAgIGxldCBwcm90b2NvbCA9IHVzX3Byb3RvY29sIGluXG4gICAgbWF0Y2ggU2V0Lm1heF9lbHQgKFNldC5pbnRlciB1c192ZXJzaW9ucyBwZWVyX3ZlcnNpb25zKSB3aXRoXG4gICAgfCBTb21lIHZlcnNpb24gLT4gT2sgdmVyc2lvblxuICAgIHwgTm9uZSAtPlxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIltQcm90b2NvbF92ZXJzaW9uX2hlYWRlci5uZWdvdGlhdGVdOiBubyBzaGFyZWQgdmVyc2lvbiBudW1iZXJzXCJcbiAgICAgICAgICAgICh1c192ZXJzaW9ucyA6IEludC5TZXQudClcbiAgICAgICAgICAgIChwZWVyX3ZlcnNpb25zIDogSW50LlNldC50KVxuICAgICAgICAgICAgKHByb3RvY29sIDogS25vd25fcHJvdG9jb2wudCldKVxuOztcblxubGV0IG1hdGNoZXNfbWFnaWNfcHJlZml4ICh0IDogdCkgfnByb3RvY29sID1cbiAgbGV0IG1hZ2ljX251bWJlciA9IEtub3duX3Byb3RvY29sLm1hZ2ljX251bWJlciBwcm90b2NvbCBpblxuICBMaXN0Lm1lbSB+ZXF1YWw6SW50LmVxdWFsIChyYXdfdmVyc2lvbl9saXN0IHQpIG1hZ2ljX251bWJlclxuOztcblxubGV0IGNvbnRhaW5zX21hZ2ljX3ByZWZpeCB+cHJvdG9jb2wgPVxuICBCaW5fcHJvdC5UeXBlX2NsYXNzLmNudl9yZWFkZXIgKG1hdGNoZXNfbWFnaWNfcHJlZml4IH5wcm90b2NvbCkgYmluX3QucmVhZGVyXG47O1xuXG5sZXQgYW55X21hZ2ljX3ByZWZpeCA9XG4gIGxldCBmIHQgPVxuICAgIExpc3QuZmluZCBLbm93bl9wcm90b2NvbC5hbGwgfmY6KGZ1biBwcm90b2NvbCAtPiBtYXRjaGVzX21hZ2ljX3ByZWZpeCB+cHJvdG9jb2wgdClcbiAgaW5cbiAgQmluX3Byb3QuVHlwZV9jbGFzcy5jbnZfcmVhZGVyIGYgYmluX3QucmVhZGVyXG47O1xuXG5sZXQgbWFnaWNfbnVtYmVyX2Jpbl9zaXplID0gNVxuXG5tb2R1bGUgTWFnaWNfcHJlZml4X2Jpbl9yZXByID0gc3RydWN0XG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZyBiaW5fc2hhcGUsIGJpbl93cml0ZV1cblxuICAoKiBUaGUgYmluIHByb3QgcmVwcmVzZW50YXRpb24gb2YgYSBwcm90b2NvbCB2ZXJzaW9uIGhlYWRlciBpcyB0aGUgc3RhbmRhcmRcbiAgICAgcmVwcmVzZW50YXRpb24gZm9yIGFuIGludCBsaXN0OlxuXG4gICAgIHwgbmF0MCBpbmRpY2F0aW5nIHNpemUgfCBlbGVtZW50IDAgfCBlbGVtZW50IDEgfCAuLi5cblxuICAgICBbY3JlYXRlX2V4bl0gd2lsbCBhbHdheXMgcHV0IHRoZSBrbm93biBwcm90b2NvbCBtYWdpYyBudW1iZXIgYXMgXCJlbGVtZW50IDBcIi5cblxuICAgICBUaGUgYmluIHNpemUgb2YgXCJuYXQwIGluZGljYXRpbmcgc2l6ZVwiIGFuZCBcImVsZW1lbnQgMFwiIGlzIGZpeGVkICh0aGVyZSBhcmUgZXhwZWN0XG4gICAgIHRlc3RzIHRvIG1ha2Ugc3VyZSB3ZSBuZXZlciBjaGFuZ2UgdGhlbSkuICopXG4gIGxldCBiaW5fc2l6ZSA9XG4gICAgYmluX3NpemVfdCBCb3VuZGVkX2xpc3RfaW5fY2FzZV9zb21lb25lX3NlbmRzX2dhcmJhZ2Vfb25fdGhlX3dpcmUubWF4X2xlblxuICAgICsgbWFnaWNfbnVtYmVyX2Jpbl9zaXplXG4gIDs7XG5cbiAgbGV0IGJpbl9yZWFkX3QgYnVmIH5wb3NfcmVmID1cbiAgICBsZXQgKF9saXN0X2xlbmd0aCA6IEJpbl9wcm90Lk5hdDAudCkgPSBCaW5fcHJvdC5SZWFkLmJpbl9yZWFkX25hdDAgYnVmIH5wb3NfcmVmIGluXG4gICAgQmluX3Byb3QuUmVhZC5iaW5fcmVhZF9pbnQgYnVmIH5wb3NfcmVmXG4gIDs7XG5cbiAgbGV0IGJpbl9yZWFkZXJfdCA9XG4gICAgeyBCaW5fcHJvdC5UeXBlX2NsYXNzLnJlYWQgPSBiaW5fcmVhZF90OyB2dGFnX3JlYWQgPSBJbnQuX19iaW5fcmVhZF90X18gfVxuICA7O1xuZW5kXG5cbmxldCBhbnlfbWFnaWNfcHJlZml4X2Zyb21fc2l4X2J5dGVzID1cbiAgQmluX3Byb3QuVHlwZV9jbGFzcy5jbnZfcmVhZGVyXG4gICAgKGZ1biBtYWdpY19udW1iZXIgLT4gKE1hcC5maW5kIEtub3duX3Byb3RvY29sLmJ5X21hZ2ljX251bWJlcikgbWFnaWNfbnVtYmVyKVxuICAgIE1hZ2ljX3ByZWZpeF9iaW5fcmVwci5iaW5fcmVhZGVyX3Rcbjs7XG5cbmxldCBhbnlfbWFnaWNfcHJlZml4X2Zyb21fc2l4X2J5dGVzX2Jpbl9zaXplID0gTWFnaWNfcHJlZml4X2Jpbl9yZXByLmJpbl9zaXplXG5cbm1vZHVsZSBQYWlyID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPVxuICAgIHsgdXMgOiB0XG4gICAgOyBwZWVyIDogdFxuICAgIH1cbmVuZFxuXG5tb2R1bGUgRXhwZXJ0ID0gc3RydWN0XG4gIGxldCByYXdfdmVyc2lvbl9saXN0ID0gcmF3X3ZlcnNpb25fbGlzdFxuICBsZXQgbm9uZSA9IEJvdW5kZWRfbGlzdF9pbl9jYXNlX3NvbWVvbmVfc2VuZHNfZ2FyYmFnZV9vbl90aGVfd2lyZS5vZl9saXN0X2V4biBbXVxuXG4gIGxldCBpc19ub25lICh0IDogdCkgPVxuICAgIG1hdGNoICh0IDo+IGludCBsaXN0KSB3aXRoXG4gICAgfCBbXSAtPiB0cnVlXG4gICAgfCBfIDo6IF8gLT4gZmFsc2VcbiAgOztcbmVuZFxuXG5tb2R1bGUgRm9yX3Rlc3QgPSBzdHJ1Y3RcbiAgbW9kdWxlIE1ha2VfbGlzdF93aXRoX21heF9sZW4gPSBMaXN0X3dpdGhfbWF4X2xlbi5NYWtlXG5cbiAgbGV0IG1hZ2ljX251bWJlcl9iaW5fc2l6ZSA9IG1hZ2ljX251bWJlcl9iaW5fc2l6ZVxuICBsZXQgbWF4X3N1cHBvcnRlZF92ZXJzaW9uID0gbWF4X3N1cHBvcnRlZF92ZXJzaW9uXG5lbmRcblxubGV0JXRlc3RfdW5pdCBcImJpbiBzaXplcyBhcmUgbm90IGNoYW5nZWQgYnkgYWNjaWRlbnRcIiA9XG4gICgqIEVuc3VyZSB0aGUgYmluX3NpemUgb2YgQm91bmRlZF9saXN0X2luX2Nhc2Vfc29tZW9uZV9zZW5kc19nYXJiYWdlX29uX3RoZV93aXJlLm1heF9sZW5cbiAgICAgaXMgYWx3YXlzIDEuIFRoaXMgbWVhbnMgdGhhdCByZWdhcmRsZXNzIG9mIGhvdyBsb25nIHRoZSBsaXN0IG9mIHZlcnNpb25zIGluIHRoZVxuICAgICBwcm90b2NvbCBoZWFkZXIgaXMsIHRoZSByZXByZXNlbnRhdGlvbiB3aWxsIGJlIHRoZSBzYW1lIG51bWJlciBvZiBieXRlcy4gVGhlXG4gICAgIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludCBqdW1wcyB0byAzIGJ5dGVzIGF0IHRoZSB2YWx1ZSAxMjguICopXG4gIGxldCBib3VuZGVkX2xpc3RfYmluX3NpemUgPVxuICAgIEludC5iaW5fc2l6ZV90IEJvdW5kZWRfbGlzdF9pbl9jYXNlX3NvbWVvbmVfc2VuZHNfZ2FyYmFnZV9vbl90aGVfd2lyZS5tYXhfbGVuXG4gIGluXG4gIGFzc2VydCAoYm91bmRlZF9saXN0X2Jpbl9zaXplID0gMSk7XG4gIGFzc2VydCAoNiA9IG1hZ2ljX251bWJlcl9iaW5fc2l6ZSArIGJvdW5kZWRfbGlzdF9iaW5fc2l6ZSk7XG4gIGFzc2VydCAoXG4gICAgYW55X21hZ2ljX3ByZWZpeF9mcm9tX3NpeF9ieXRlc19iaW5fc2l6ZVxuICAgID0gbWFnaWNfbnVtYmVyX2Jpbl9zaXplICsgYm91bmRlZF9saXN0X2Jpbl9zaXplKVxuOztcbiJdfQ==
