// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Re__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Re = [0];
   runtime.caml_register_global(0, Re, "Re__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Bit_vector
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Char = global_data.Stdlib__Char,
    cst_Bit_vector_get = "Bit_vector.get",
    cst_Bit_vector_set = "Bit_vector.set";
   function length(t){return t[1];}
   function set(v, n, b){
    var _f_ = n < 0 ? 1 : 0, _g_ = _f_ || (v[1] <= n ? 1 : 0);
    if(_g_) caml_call1(Stdlib[1], cst_Bit_vector_set);
    var
     i = n >>> 3 | 0,
     c = caml_bytes_unsafe_get(v[2], i),
     mask = 1 << (n & 7),
     x = b ? c | mask : c & caml_call1(Stdlib[21], mask),
     s = v[2];
    runtime.caml_bytes_unsafe_set(s, i, caml_call1(Stdlib_Char[1], x));
    return 0;
   }
   function get(v, n){
    var _d_ = n < 0 ? 1 : 0, _e_ = _d_ || (v[1] <= n ? 1 : 0);
    if(_e_) caml_call1(Stdlib[1], cst_Bit_vector_get);
    var i = n >>> 3 | 0;
    return 0 < (caml_bytes_unsafe_get(v[2], i) & 1 << (n & 7)) ? 1 : 0;
   }
   function reset_zero(t){
    var _b_ = runtime.caml_ml_bytes_length(t[2]) - 1 | 0, _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      runtime.caml_bytes_set(t[2], i, 0);
      var _c_ = i + 1 | 0;
      if(_b_ === i) break;
      var i = _c_;
     }
    }
    return 0;
   }
   function create_zero(len){
    var
     r = len & 7,
     q = len >>> 3 | 0,
     len$0 = 0 === r ? q : q + 1 | 0,
     bits = caml_call2(Stdlib_Bytes[1], len$0, 0);
    return [0, len, bits];
   }
   var Re_Bit_vector = [0, length, set, create_zero, get, reset_zero];
   runtime.caml_register_global(5, Re_Bit_vector, "Re__Bit_vector");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Category
//# unitInfo: Requires: Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format;
   function equal(x, y){return x === y ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function to_int(x){return x;}
   var pp = Stdlib_Format[19];
   function intersect(x, y){return 0 !== (x & y) ? 1 : 0;}
   function symbol(x, y){return x | y;}
   var
    dummy = -1,
    inexistant = 1,
    letter = 2,
    not_letter = 4,
    newline = 8,
    lastnewline = 16,
    search_boundary = 32;
   function from_char(param){
    a:
    {
     if(170 <= param)
      if(187 <= param){
       var _a_ = param - 192 | 0;
       if(54 < _a_ >>> 0){if(56 <= _a_) break a;} else if(23 !== _a_) break a;
      }
      else{
       var _b_ = param - 171 | 0;
       if(14 < _b_ >>> 0 || 10 === _b_) break a;
      }
     else if(65 <= param){
      var _c_ = param - 91 | 0;
      if(5 < _c_ >>> 0){if(32 > _c_) break a;} else if(4 === _c_) break a;
     }
     else
      if(48 <= param){
       if(58 > param) break a;
      }
      else if(10 === param) return 12;
     return not_letter;
    }
    return letter;
   }
   var
    Re_Category =
      [0,
       symbol,
       from_char,
       dummy,
       inexistant,
       letter,
       not_letter,
       newline,
       lastnewline,
       search_boundary,
       to_int,
       equal,
       compare,
       intersect,
       pp];
   runtime.caml_register_global(1, Re_Category, "Re__Category");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Fmt
//# unitInfo: Requires: Stdlib__Buffer, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_3 = "<3>", cst = "@ ";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Format = global_data.Stdlib__Format,
    pp_print_string = Stdlib_Format[13],
    pp_print_int = Stdlib_Format[19],
    pp_print_space = Stdlib_Format[27],
    pp_print_list = Stdlib_Format[130],
    fprintf = Stdlib_Format[137],
    _d_ = [0, [12, 59, [17, [0, cst, 1, 0], 0]], ";@ "],
    _e_ =
      [0,
       [18,
        [1, [0, [11, cst_3, 0], cst_3]],
        [12,
         91,
         [17,
          [0, cst, 1, 0],
          [15, [17, [0, cst, 1, 0], [12, 93, [17, 0, 0]]]]]]],
       "@[<3>[@ %a@ ]@]"],
    _c_ = [0, [12, 34, [2, 0, [12, 34, 0]]], '"%s"'],
    _b_ = [0, [17, [0, cst, 1, 0], [4, 0, 0, 0, 0]], "@ %d"],
    _a_ =
      [0,
       [18,
        [1, [0, [11, cst_3, 0], cst_3]],
        [12, 40, [2, 0, [17, [0, cst, 1, 0], [15, [12, 41, [17, 0, 0]]]]]]],
       "@[<3>(%s@ %a)@]"];
   function sexp(fmt, s, pp, x){
    return caml_call5(fprintf, fmt, _a_, s, pp, x);
   }
   function pair(pp1, pp2, fmt, param){
    var v2 = param[2], v1 = param[1];
    caml_call2(pp1, fmt, v1);
    caml_call2(pp_print_space, fmt, 0);
    return caml_call2(pp2, fmt, v2);
   }
   function triple(pp1, pp2, pp3, fmt, param){
    var v3 = param[3], v2 = param[2], v1 = param[1];
    caml_call2(pp1, fmt, v1);
    caml_call2(pp_print_space, fmt, 0);
    caml_call2(pp2, fmt, v2);
    caml_call2(pp_print_space, fmt, 0);
    return caml_call2(pp3, fmt, v3);
   }
   function optint(fmt, param){
    if(! param) return 0;
    var i = param[1];
    return caml_call3(fprintf, fmt, _b_, i);
   }
   function pp_elem(fmt, s){
    return caml_call3(Stdlib_Format[137], fmt, _c_, s);
   }
   function pp_str_list(fmt){
    var
     _f_ =
       caml_call2
        (pp_print_list,
         [0, function(fmt, param){return caml_call2(fprintf, fmt, _d_);}],
         pp_elem);
    return caml_call3(Stdlib_Format[137], fmt, _e_, _f_);
   }
   function to_to_string(pp, x){
    var
     b = caml_call1(Stdlib_Buffer[1], 16),
     fmt = caml_call1(Stdlib_Format[114], b);
    caml_call2(pp, fmt, x);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   var
    Re_Fmt =
      [0,
       pp_str_list,
       sexp,
       pp_print_string,
       optint,
       pp_print_int,
       pair,
       triple,
       pp_print_list,
       to_to_string];
   runtime.caml_register_global(7, Re_Fmt, "Re__Fmt");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Import
//# unitInfo: Requires: Stdlib__Int
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Int = global_data.Stdlib__Int,
    equal = runtime.caml_equal,
    Poly = [0, equal],
    symbol = Stdlib_Int[8],
    Re_Import = [0, Poly, symbol];
   runtime.caml_register_global(1, Re_Import, "Re__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Cset
//# unitInfo: Requires: Re__Fmt, Stdlib, Stdlib__Char, Stdlib__Format, Stdlib__Int, Stdlib__ListLabels, Stdlib__Map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_compare = runtime.caml_compare,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cany = [0, [0, 0, 255], 0],
    cst = "\t ",
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Char = global_data.Stdlib__Char,
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_Map = global_data.Stdlib__Map,
    _d_ = [0, "lib/cset.ml", 163, 9],
    cst_Re_cset_pick = "Re_cset.pick",
    _b_ = [0, [4, 0, 0, 0, 0], "%d"],
    _c_ = [0, [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]], "%d-%d"],
    _i_ = [0, 170, [0, 181, [0, 186, [0, 223, [0, 255, 0]]]]];
   function to_int(x){return x;}
   function of_int(x){return x;}
   function to_char(t){return caml_call1(Stdlib_Char[1], t);}
   function of_char(c){return c;}
   function _a_(param, _P_){
    var
     y = _P_[2],
     x = _P_[1],
     y$0 = param[2],
     x$0 = param[1],
     _Q_ = caml_call2(Stdlib_Int[8], x$0, x);
    return _Q_ ? caml_call2(Stdlib_Int[8], y$0, y) : _Q_;
   }
   var equal = caml_call1(Stdlib_ListLabels[16], _a_);
   function union(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return l$2;
     if(! l$2) return l$1;
     var
      r = l$1[2],
      _O_ = l$1[1],
      c2 = _O_[2],
      c1 = _O_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if((c2$0 + 1 | 0) < c1) return [0, [0, c1$0, c2$0], union(r$0, l$1)];
     if((c2 + 1 | 0) < c1$0) return [0, [0, c1, c2], union(l$2, r)];
     if(c2$0 < c2)
      var
       l$3 = [0, [0, caml_call2(Stdlib[16], c1$0, c1), c2], r],
       l$2 = r$0,
       l$1 = l$3;
     else
      var
       l$4 = [0, [0, caml_call2(Stdlib[16], c1$0, c1), c2$0], r$0],
       l$2 = l$4,
       l$1 = r;
    }
   }
   function inter(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return 0;
     if(! l$2) return 0;
     var
      r = l$1[2],
      _L_ = l$1[1],
      c2 = _L_[2],
      c1 = _L_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if(caml_lessthan(c2$0, c1))
      var l$2 = r$0;
     else{
      if(! caml_lessthan(c2, c1$0)){
       if(caml_lessthan(c2$0, c2)){
        var _M_ = inter(r$0, l$1);
        return [0, [0, caml_call2(Stdlib[17], c1$0, c1), c2$0], _M_];
       }
       var _N_ = inter(l$2, r);
       return [0, [0, caml_call2(Stdlib[17], c1$0, c1), c2], _N_];
      }
      var l$1 = r;
     }
    }
   }
   function diff(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return l$2;
     if(! l$2) return 0;
     var
      r = l$1[2],
      _K_ = l$1[1],
      c2 = _K_[2],
      c1 = _K_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if(c2$0 < c1) return [0, [0, c1$0, c2$0], diff(r$0, l$1)];
     if(c2 < c1$0)
      var l$1 = r;
     else{
      var r$1 = c2 < c2$0 ? [0, [0, c2 + 1 | 0, c2$0], r$0] : r$0;
      if(c1$0 < c1) return [0, [0, c1$0, c1 - 1 | 0], diff(r$1, r)];
      var l$2 = r$1, l$1 = r;
     }
    }
   }
   function single(c){return [0, [0, c, c], 0];}
   function add(c, l){return union(single(c), l);}
   function seq(c$0, c){
    return runtime.caml_lessequal(c$0, c)
            ? [0, [0, c$0, c], 0]
            : [0, [0, c, c$0], 0];
   }
   function offset(o, l){
    if(! l) return 0;
    var r = l[2], match = l[1], c2 = match[2], c1 = match[1];
    return [0, [0, c1 + o | 0, c2 + o | 0], offset(o, r)];
   }
   var
    union_all = caml_call2(Stdlib_ListLabels[26], union, 0),
    intersect_all = caml_call2(Stdlib_ListLabels[26], inter, cany),
    empty = 0;
   function mem(c, s){
    var s$0 = s;
    for(;;){
     if(! s$0) return 0;
     var rem = s$0[2], match = s$0[1], c2 = match[2], c1 = match[1];
     if(c <= c2) return c1 <= c ? 1 : 0;
     var s$0 = rem;
    }
   }
   function hash_rec(param){
    if(! param) return 0;
    var r = param[2], match = param[1], j = match[2], i = match[1];
    return (i + (13 * j | 0) | 0) + (257 * hash_rec(r) | 0) | 0;
   }
   function hash(l){return hash_rec(l) & 1073741823;}
   function print_one(ch, param){
    var c2 = param[2], c1 = param[1];
    return caml_call2(Stdlib_Int[8], c1, c2)
            ? caml_call3(Stdlib_Format[137], ch, _b_, c1)
            : caml_call4(Stdlib_Format[137], ch, _c_, c1, c2);
   }
   var pp = caml_call2(Re_Fmt[8], 0, print_one);
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var xs = t$0[2], match = t$0[1], y = match[2], x = match[1];
     caml_call2(f, x, y);
     var t$0 = xs;
    }
   }
   function one_char(param){
    if(param && ! param[2]){
     var match = param[1], j = match[2], i = match[1];
     if(caml_call2(Stdlib_Int[8], i, j)) return [0, i];
    }
    return 0;
   }
   function compare(param, _J_){
    var
     v = _J_[2],
     j = _J_[1],
     u = param[2],
     i = param[1],
     c = caml_compare(i, j);
    return 0 === c ? caml_compare(u, v) : c;
   }
   var CSetMap = caml_call1(Stdlib_Map[1], [0, compare]);
   function fold_right(t, init, f){
    return caml_call3(Stdlib_ListLabels[27], f, t, init);
   }
   function csingle(c){return single(c);}
   function is_empty(param){return param ? 0 : 1;}
   function prepend(s, x, l){
    var s$0 = s;
    for(;;){
     if(! s$0) return l;
     if(! l) return 0;
     var _E_ = l[1], _F_ = _E_[1];
     if(_F_ && ! _F_[2]){
      var
       x$0 = _E_[2],
       _G_ = _F_[1],
       d = _G_[2],
       d$0 = _G_[1],
       r = s$0[2],
       match = s$0[1],
       c = match[2],
       c$0 = match[1];
      if(c < d$0){var s$0 = r; continue;}
      var r$0 = l[2];
      if(c$0 > d$0)
       return d < c$0
               ? [0, [0, [0, [0, d$0, d], 0], x$0], prepend(s$0, x, r$0)]
               : [0,
                 [0, [0, [0, d$0, c$0 - 1 | 0], 0], x$0],
                 prepend(s$0, x, [0, [0, [0, [0, c$0, d], 0], x$0], r$0])];
      if(c < d){
       var _H_ = prepend(r, x, [0, [0, [0, [0, c + 1 | 0, d], 0], x$0], r$0]);
       return [0,
               [0, [0, [0, d$0, c], 0], caml_call2(Stdlib[37], x, x$0)],
               _H_];
      }
      var _I_ = prepend(s$0, x, r$0);
      return [0,
              [0, [0, [0, d$0, d], 0], caml_call2(Stdlib[37], x, x$0)],
              _I_];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
   }
   function pick(param){
    if(! param) return caml_call1(Stdlib[1], cst_Re_cset_pick);
    var x = param[1][1];
    return x;
   }
   function cseq(c$0, c){return seq(c$0, c);}
   var
    _e_ = [0, cseq(216, 222), 0],
    _f_ = [0, cseq(192, 214), _e_],
    upper = caml_call1(union_all, [0, cseq(65, 90), _f_]),
    clower = offset(32, upper),
    cdigit = cseq(48, 57),
    ascii = cseq(0, 127);
   function cadd(c, s){return add(c, s);}
   var
    space = add(32, cseq(9, 13)),
    _g_ = [0, cseq(65, 70), 0],
    xdigit = caml_call1(union_all, [0, cdigit, [0, cseq(97, 102), _g_]]),
    _h_ = union(clower, upper),
    calpha = caml_call3(Stdlib_ListLabels[27], cadd, _i_, _h_),
    calnum = union(calpha, cdigit);
   function case_insens(s){
    var _D_ = [0, offset(-32, inter(s, clower)), 0];
    return caml_call1
            (union_all, [0, s, [0, offset(32, inter(s, upper)), _D_]]);
   }
   var
    cword = cadd(95, calnum),
    notnl = diff(cany, csingle(10)),
    nl = csingle(10);
   function set(str){
    var
     s = [0, empty],
     _A_ = runtime.caml_ml_string_length(str) - 1 | 0,
     _z_ = 0;
    if(_A_ >= 0){
     var i = _z_;
     for(;;){
      var _B_ = s[1];
      s[1] = union(csingle(runtime.caml_string_get(str, i)), _B_);
      var _C_ = i + 1 | 0;
      if(_A_ === i) break;
      var i = _C_;
     }
    }
    return s[1];
   }
   var
    blank = set(cst),
    _j_ = [0, cseq(248, 255), 0],
    _k_ = [0, cseq(223, 246), _j_],
    _l_ = [0, csingle(181), _k_],
    lower = caml_call1(union_all, [0, cseq(97, 122), _l_]),
    _m_ = [0, csingle(186), 0],
    alpha =
      caml_call1(union_all, [0, lower, [0, upper, [0, csingle(170), _m_]]]),
    alnum = caml_call1(union_all, [0, alpha, [0, cdigit, 0]]),
    wordc = caml_call1(union_all, [0, alnum, [0, csingle(95), 0]]),
    _n_ = [0, cseq(127, 159), 0],
    cntrl = caml_call1(union_all, [0, cseq(0, 31), _n_]),
    _o_ = [0, cseq(160, 255), 0],
    graph = caml_call1(union_all, [0, cseq(33, 126), _o_]),
    _p_ = [0, cseq(160, 255), 0],
    print = caml_call1(union_all, [0, cseq(32, 126), _p_]),
    _q_ = [0, csingle(247), 0],
    _r_ = [0, csingle(215), _q_],
    _s_ = [0, cseq(187, 191), _r_],
    _t_ = [0, cseq(182, 185), _s_],
    _u_ = [0, cseq(171, 180), _t_],
    _v_ = [0, cseq(160, 169), _u_],
    _w_ = [0, cseq(123, 126), _v_],
    _x_ = [0, cseq(91, 96), _w_],
    _y_ = [0, cseq(58, 64), _x_],
    punct = caml_call1(union_all, [0, cseq(33, 47), _y_]),
    Re_Cset =
      [0,
       to_int,
       of_int,
       to_char,
       of_char,
       equal,
       iter,
       union,
       union_all,
       intersect_all,
       inter,
       diff,
       offset,
       empty,
       single,
       seq,
       add,
       mem,
       case_insens,
       cdigit,
       calpha,
       cword,
       notnl,
       ascii,
       nl,
       cseq,
       set,
       blank,
       space,
       xdigit,
       lower,
       upper,
       alpha,
       alnum,
       wordc,
       cntrl,
       graph,
       print,
       punct,
       hash,
       pp,
       one_char,
       fold_right,
       hash_rec,
       CSetMap,
       cany,
       csingle,
       is_empty,
       prepend,
       pick];
   runtime.caml_register_global(15, Re_Cset, "Re__Cset");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Mark_infos
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List;
   function make(marks){
    var _f_ = -1;
    function _g_(ma, param){
     var i = param[1];
     return caml_call2(Stdlib[17], ma, i);
    }
    var
     len = 1 + caml_call3(Stdlib_List[26], _g_, _f_, marks) | 0,
     t = runtime.caml_make_vect(len, -1);
    function _h_(param){
     var v = param[2], i = param[1];
     caml_check_bound(t, i)[1 + i] = v;
     return 0;
    }
    caml_call2(Stdlib_List[18], _h_, marks);
    return t;
   }
   function test(t, i){
    if(t.length - 1 <= (2 * i | 0)) return 0;
    var _e_ = 2 * i | 0;
    return -1 !== caml_check_bound(t, _e_)[1 + _e_] ? 1 : 0;
   }
   function offset(t, i){
    var start_i = 2 * i | 0, stop_i = start_i + 1 | 0;
    if(t.length - 1 <= stop_i) return 0;
    var start = caml_check_bound(t, start_i)[1 + start_i];
    if(-1 === start) return 0;
    var stop = caml_check_bound(t, stop_i)[1 + stop_i];
    return [0, [0, start, stop]];
   }
   function iteri(t, f){
    var _b_ = ((t.length - 1) / 2 | 0) - 1 | 0, _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      var idx = 2 * i | 0, start = caml_check_bound(t, idx)[1 + idx];
      if(-1 !== start){
       var _c_ = idx + 1 | 0, stop = caml_check_bound(t, _c_)[1 + _c_];
       caml_call3(f, i, start, stop);
      }
      var _d_ = i + 1 | 0;
      if(_b_ === i) break;
      var i = _d_;
     }
    }
    return 0;
   }
   var Re_Mark_infos = [0, make, offset, test, iteri];
   runtime.caml_register_global(2, Re_Mark_infos, "Re__Mark_infos");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Pmark
//# unitInfo: Requires: Stdlib__Format, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Set = global_data.Stdlib__Set;
   function equal(x, y){return x === y ? 1 : 0;}
   var compare = runtime.caml_int_compare, r = [0, 0];
   function gen(param){r[1]++; return r[1];}
   var
    pp = Stdlib_Format[19],
    Set = caml_call1(Stdlib_Set[1], [0, compare]),
    Re_Pmark = [0, equal, compare, gen, pp, Set];
   runtime.caml_register_global(2, Re_Pmark, "Re__Pmark");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Automata
//# unitInfo: Requires: Re__Bit_vector, Re__Category, Re__Cset, Re__Fmt, Re__Import, Re__Mark_infos, Re__Pmark, Stdlib__Format, Stdlib__Hashtbl, Stdlib__Int, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_compare = runtime.caml_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    eps_expr = [0, 0, 0],
    Re_Fmt = global_data.Re__Fmt,
    Re_Cset = global_data.Re__Cset,
    Re_Category = global_data.Re__Category,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Re_Bit_vector = global_data.Re__Bit_vector,
    Re_Import = global_data.Re__Import,
    Re_Mark_infos = global_data.Re__Mark_infos,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Format = global_data.Stdlib__Format,
    Re_Pmark = global_data.Re__Pmark,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Int = global_data.Stdlib__Int,
    cst_eps = "eps",
    cst_cst = "cst",
    cst_alt = "alt",
    cst_seq = "seq",
    cst_rep = "rep",
    cst_mark = "mark",
    cst_erase = "erase",
    cst_before = "before",
    cst_after = "after",
    cst_pmark = "pmark",
    _c_ = [0, "lib/automata.ml", 317, 14],
    _a_ = [1, 0],
    cst_Non_greedy = "Non_greedy",
    cst_Greedy = "Greedy",
    cst_first = "first",
    cst_short = "short",
    cst_long = "long";
   function create(param){return [0, 0];}
   var equal = Re_Import[1][1];
   function pp(ch, k){
    var
     _aI_ =
       -730718166 === k ? cst_long : 332064784 <= k ? cst_first : cst_short;
    return caml_call2(Stdlib_Format[13], ch, _aI_);
   }
   function pp$0(fmt, param){
    return 620821490 <= param
            ? caml_call2(Stdlib_Format[13], fmt, cst_Non_greedy)
            : caml_call2(Stdlib_Format[13], fmt, cst_Greedy);
   }
   var Rep_kind = [0, pp$0], start = 0;
   function prev(x){return x - 1 | 0;}
   function next(x){return x + 1 | 0;}
   function next2(x){return x + 2 | 0;}
   function group_count(x){return x / 2 | 0;}
   var Mark = [0, start, prev, next, next2, group_count];
   function hash_combine(h, accu){return (accu * 65599 | 0) + h | 0;}
   function equal$0(param, t){
    var pmarks = param[2], marks = param[1], _aD_ = t[1];
    function _aE_(param, _aG_){
     var
      y = _aG_[2],
      x = _aG_[1],
      y$0 = param[2],
      x$0 = param[1],
      _aH_ = caml_call2(Stdlib_Int[8], x$0, x);
     return _aH_ ? caml_call2(Stdlib_Int[8], y$0, y) : _aH_;
    }
    var _aF_ = caml_call3(Stdlib_ListLabels[16], _aE_, marks, _aD_);
    return _aF_ ? caml_call2(Re_Pmark[5][32], pmarks, t[2]) : _aF_;
   }
   var empty = [0, 0, Re_Pmark[5][1]];
   function merge_marks_offset(old, param){
    if(! param) return old;
    var
     rem = param[2],
     match = param[1],
     v = match[2],
     i = match[1],
     nw = merge_marks_offset(caml_call2(Stdlib_ListLabels[56], i, old), rem);
    return caml_call2(Re_Import[2], v, -2) ? nw : [0, [0, i, v], nw];
   }
   function merge(old, nw){
    var _aC_ = caml_call2(Re_Pmark[5][5], old[2], nw[2]);
    return [0, merge_marks_offset(old[1], nw[1]), _aC_];
   }
   function hash(m, accu$1){
    var
     accu$2 = hash_combine(caml_call1(Stdlib_Hashtbl[28], m[2]), accu$1),
     l$0 = m[1],
     l = l$0,
     accu = accu$2;
    for(;;){
     if(! l) return accu;
     var
      r = l[2],
      match = l[1],
      i = match[2],
      a = match[1],
      accu$0 = hash_combine(a, hash_combine(i, accu)),
      l = r,
      accu = accu$0;
    }
   }
   function marks_set_idx(idx, marks){
    if(marks){
     var _aB_ = marks[1];
     if(-1 === _aB_[2]){
      var rem = marks[2], a = _aB_[1];
      return [0, [0, a, idx], marks_set_idx(idx, rem)];
     }
    }
    return marks;
   }
   function marks_set_idx$0(marks, idx){
    var _aA_ = marks[2];
    return [0, marks_set_idx(idx, marks[1]), _aA_];
   }
   function filter(t, b, e){
    var _av_ = t[2], _aw_ = t[1];
    function _ax_(param){
     var i = param[1], _ay_ = i < b ? 1 : 0, _az_ = _ay_ || (e < i ? 1 : 0);
     return _az_;
    }
    return [0, caml_call2(Stdlib_ListLabels[44], _ax_, _aw_), _av_];
   }
   function set_mark(t, i){
    var _au_ = t[2];
    return [0,
            [0, [0, i, -1], caml_call2(Stdlib_ListLabels[56], i, t[1])],
            _au_];
   }
   function pp$1(ch, e){
    var match = e[2];
    if(typeof match === "number") return caml_call2(Re_Fmt[3], ch, cst_eps);
    switch(match[0]){
      case 0:
       var l = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_cst, Re_Cset[40], l);
      case 1:
       var l$0 = match[1], _aq_ = caml_call2(Re_Fmt[8], 0, pp$1);
       return caml_call4(Re_Fmt[2], ch, cst_alt, _aq_, l$0);
      case 2:
       var
        e$0 = match[3],
        e$1 = match[2],
        k = match[1],
        _ar_ = caml_call3(Re_Fmt[7], pp, pp$1, pp$1);
       return caml_call4(Re_Fmt[2], ch, cst_seq, _ar_, [0, k, e$1, e$0]);
      case 3:
       var
        e$2 = match[3],
        k$0 = match[2],
        _as_ = caml_call2(Re_Fmt[6], pp, pp$1);
       return caml_call4(Re_Fmt[2], ch, cst_rep, _as_, [0, k$0, e$2]);
      case 4:
       var i = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_mark, Re_Fmt[5], i);
      case 5:
       var
        e$3 = match[2],
        b = match[1],
        _at_ = caml_call2(Re_Fmt[6], Re_Fmt[5], Re_Fmt[5]);
       return caml_call4(Re_Fmt[2], ch, cst_erase, _at_, [0, b, e$3]);
      case 6:
       var c = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_before, Re_Category[14], c);
      case 7:
       var c$0 = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_after, Re_Category[14], c$0);
      default:
       var i$0 = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_pmark, Re_Fmt[5], i$0);
    }
   }
   function mk_expr(ids, def){ids[1]++; return [0, ids[1], def];}
   function empty$0(ids){return mk_expr(ids, _a_);}
   function cst(ids, s){
    return caml_call1(Re_Cset[47], s) ? empty$0(ids) : mk_expr(ids, [0, s]);
   }
   function alt(ids, l){
    if(! l) return empty$0(ids);
    if(l[2]) return mk_expr(ids, [1, l]);
    var c = l[1];
    return c;
   }
   function seq(ids, kind, x, y){
    var _ao_ = x[2], _ap_ = y[2];
    if(typeof _ao_ !== "number" && 1 === _ao_[0] && ! _ao_[1]) return x;
    if(typeof _ap_ !== "number" && 1 === _ap_[0] && ! _ap_[1]) return y;
    if(typeof _ao_ === "number") return y;
    if(typeof _ap_ === "number" && caml_call2(equal, kind, 332064784))
     return x;
    return mk_expr(ids, [2, kind, x, y]);
   }
   function is_eps(expr){return typeof expr[2] === "number" ? 1 : 0;}
   function eps(ids){return mk_expr(ids, 0);}
   function rep(ids, kind, sem, x){return mk_expr(ids, [3, kind, sem, x]);}
   function mark(ids, m){return mk_expr(ids, [4, m]);}
   function pmark(ids, i){return mk_expr(ids, [8, i]);}
   function erase(ids, m$0, m){return mk_expr(ids, [5, m$0, m]);}
   function before(ids, c){return mk_expr(ids, [6, c]);}
   function after(ids, c){return mk_expr(ids, [7, c]);}
   function rename(ids, x){
    var match = x[2];
    if(typeof match !== "number")
     switch(match[0]){
       case 1:
        var l = match[1], _al_ = function(_an_){return rename(ids, _an_);};
        return mk_expr(ids, [1, caml_call2(Stdlib_ListLabels[20], _al_, l)]);
       case 2:
        var z = match[3], y = match[2], k = match[1], _am_ = rename(ids, z);
        return mk_expr(ids, [2, k, rename(ids, y), _am_]);
       case 3:
        var y$0 = match[3], k$0 = match[2], g = match[1];
        return mk_expr(ids, [3, g, k$0, rename(ids, y$0)]);
     }
    return mk_expr(ids, x[2]);
   }
   function is_tmatch(param){return 2 === param[0] ? 1 : 0;}
   function equal$1(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      var _ad_ = l1$0[1];
      switch(_ad_[0]){
        case 0:
         if(l2$0){
          var match = l2$0[1], r1 = l1$0[2], e1 = _ad_[2], l1$1 = _ad_[1];
          if(0 === match[0]){
           var
            r2 = l2$0[2],
            e2 = match[2],
            l2$1 = match[1],
            _ae_ = caml_call2(Re_Import[2], e1[1], e2[1]);
           if(_ae_){
            var _af_ = equal$1(l1$1, l2$1);
            if(_af_){var l1$0 = r1, l2$0 = r2; continue;}
            var _ag_ = _af_;
           }
           else
            var _ag_ = _ae_;
           return _ag_;
          }
         }
         break;
        case 1:
         if(l2$0){
          var
           match$0 = l2$0[1],
           r1$0 = l1$0[2],
           e1$0 = _ad_[2],
           marks1 = _ad_[1];
          if(1 === match$0[0]){
           var
            r2$0 = l2$0[2],
            e2$0 = match$0[2],
            marks2 = match$0[1],
            _ah_ = caml_call2(Re_Import[2], e1$0[1], e2$0[1]);
           if(_ah_){
            var _ai_ = equal$0(marks1, marks2);
            if(_ai_){var l1$0 = r1$0, l2$0 = r2$0; continue;}
            var _aj_ = _ai_;
           }
           else
            var _aj_ = _ah_;
           return _aj_;
          }
         }
         break;
        default:
         if(l2$0){
          var match$1 = l2$0[1], r1$1 = l1$0[2], marks1$0 = _ad_[1];
          if(2 === match$1[0]){
           var
            r2$1 = l2$0[2],
            marks2$0 = match$1[1],
            _ak_ = equal$0(marks1$0, marks2$0);
           if(! _ak_) return _ak_;
           var l1$0 = r1$1, l2$0 = r2$1;
           continue;
          }
         }
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function hash$0(l, accu){
    var l$0 = l, accu$0 = accu;
    for(;;){
     if(! l$0) return accu$0;
     var match = l$0[1];
     switch(match[0]){
       case 0:
        var
         r = l$0[2],
         e = match[2],
         l$1 = match[1],
         _ab_ = hash$0(l$1, accu$0),
         accu$1 = hash_combine(388635598, hash_combine(e[1], _ab_)),
         l$0 = r,
         accu$0 = accu$1;
        break;
       case 1:
        var
         r$0 = l$0[2],
         e$0 = match[2],
         marks = match[1],
         _ac_ = hash(marks, accu$0),
         accu$2 = hash_combine(726404471, hash_combine(e$0[1], _ac_)),
         l$0 = r$0,
         accu$0 = accu$2;
        break;
       default:
        var
         r$1 = l$0[2],
         marks$0 = match[1],
         accu$3 = hash_combine(471882453, hash(marks$0, accu$0)),
         l$0 = r$1,
         accu$0 = accu$3;
     }
    }
   }
   function tseq(kind, x, y, rem){
    if(! x) return rem;
    var _aa_ = x[1];
    if(1 === _aa_[0] && typeof _aa_[2][2] === "number" && ! x[2]){var marks = _aa_[1]; return [0, [1, marks, y], rem];}
    return [0, [0, x, y, kind], rem];
   }
   function first_match(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var match = param$0[1];
     if(2 === match[0]){var marks = match[1]; return [0, marks];}
     var r = param$0[2], param$0 = r;
    }
   }
   function _b_(param){return 2 === param[0] ? 0 : 1;}
   var remove_matches = caml_call1(Stdlib_ListLabels[44], _b_);
   function split_at_match(l$1){
    var l = 0, param = l$1;
    for(;;){
     if(! param)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var x = param[1];
     if(2 === x[0]){
      var r$0 = param[2], _$_ = caml_call1(remove_matches, r$0);
      return [0, caml_call1(Stdlib_ListLabels[10], l), _$_];
     }
     var r = param[2], l$0 = [0, x, l], l = l$0, param = r;
    }
   }
   var exists_tmatch = caml_call1(Stdlib_ListLabels[34], is_tmatch);
   function set_idx(idx, param){
    if(! param) return 0;
    var match = param[1];
    switch(match[0]){
      case 0:
       var
        r = param[2],
        kind = match[3],
        x = match[2],
        l = match[1],
        _Y_ = set_idx(idx, r);
       return [0, [0, set_idx(idx, l), x, kind], _Y_];
      case 1:
       var
        r$0 = param[2],
        x$0 = match[2],
        marks = match[1],
        _Z_ = set_idx(idx, r$0);
       return [0, [1, marks_set_idx$0(marks, idx), x$0], _Z_];
      default:
       var r$1 = param[2], marks$0 = match[1], ___ = set_idx(idx, r$1);
       return [0, [2, marks_set_idx$0(marks$0, idx)], ___];
    }
   }
   function idx(t){return t[1];}
   var dummy = [0, -1, Re_Category[3], 0, 0, -1];
   function mk(idx, cat, desc){
    return [0,
            idx,
            cat,
            desc,
            0,
            hash$0
             (desc,
              hash_combine
               (idx, hash_combine(caml_call1(Re_Category[10], cat), 0)))
            & 1073741823];
   }
   function create$0(cat, e){return mk(0, cat, [0, [1, empty, e], 0]);}
   function equal$2(x, y){
    var _U_ = caml_call2(Re_Import[2], x[5], y[5]);
    if(_U_){
     var _V_ = caml_call2(Re_Import[2], x[1], y[1]);
     if(_V_){
      var _W_ = caml_call2(Re_Category[11], x[2], y[2]);
      if(_W_) return equal$1(x[3], y[3]);
      var _X_ = _W_;
     }
     else
      var _X_ = _V_;
    }
    else
     var _X_ = _U_;
    return _X_;
   }
   function status(s){
    var match = s[4];
    if(match){var st = match[1]; return st;}
    var _S_ = s[3];
    if(_S_){
     var match$0 = _S_[1];
     if(2 === match$0[0])
      var
       m = match$0[1],
       _T_ = m[2],
       st$0 = [0, caml_call1(Re_Mark_infos[1], m[1]), _T_];
     else
      var st$0 = 1;
    }
    else
     var st$0 = 0;
    s[4] = [0, st$0];
    return st$0;
   }
   function hash$1(t){return t[5];}
   var Table = caml_call1(Stdlib_Hashtbl[26], [0, equal$2, hash$1]);
   function create$1(param){return [0, caml_call1(Re_Bit_vector[3], 1)];}
   function index_count(w){return caml_call1(Re_Bit_vector[1], w[1]);}
   function mark_used_indices(tbl){
    function _O_(param){
     if(0 === param[0]){
      var l = param[1];
      return caml_call1(mark_used_indices(tbl), l);
     }
     var marks = param[1], _P_ = marks[1];
     function _Q_(param){
      var i = param[2], _R_ = 0 <= i ? 1 : 0;
      return _R_ ? caml_call3(Re_Bit_vector[2], tbl, i, 1) : _R_;
     }
     return caml_call2(Stdlib_ListLabels[18], _Q_, _P_);
    }
    return caml_call1(Stdlib_ListLabels[18], _O_);
   }
   function free_index(tbl_ref, l){
    var tbl = tbl_ref[1];
    caml_call1(Re_Bit_vector[5], tbl);
    caml_call1(mark_used_indices(tbl), l);
    var len = caml_call1(Re_Bit_vector[1], tbl), idx = 0;
    for(;;){
     if
      (!
       caml_call2(Re_Import[2], idx, len)
       && caml_call2(Re_Bit_vector[4], tbl, idx)){
      var idx$0 = idx + 1 | 0, idx = idx$0;
      continue;
     }
     if(caml_call2(Re_Import[2], idx, len))
      tbl_ref[1] = caml_call1(Re_Bit_vector[3], 2 * len | 0);
     return idx;
    }
   }
   function remove_duplicates(prev, l, y){
    var l$0 = l;
    for(;;){
     if(! l$0) return [0, 0, prev];
     var x = l$0[1];
     switch(x[0]){
       case 0:
        var
         r = l$0[2],
         kind = x[3],
         x$0 = x[2],
         l$1 = x[1],
         match = remove_duplicates(prev, l$1, x$0),
         prev$0 = match[2],
         l$2 = match[1],
         match$0 = remove_duplicates(prev$0, r, y),
         prev$1 = match$0[2],
         r$0 = match$0[1];
        return [0, tseq(kind, l$2, x$0, r$0), prev$1];
       case 1:
        if(typeof x[2][2] === "number"){
         var r$1 = l$0[2];
         if(! caml_call2(Stdlib_ListLabels[38], y[1], prev)){
          var
           match$1 = remove_duplicates([0, y[1], prev], r$1, y),
           prev$2 = match$1[2],
           r$2 = match$1[1];
          return [0, [0, x, r$2], prev$2];
         }
         var l$0 = r$1;
        }
        else{
         var r$3 = l$0[2], x$1 = x[2];
         if(! caml_call2(Stdlib_ListLabels[38], x$1[1], prev)){
          var
           match$2 = remove_duplicates([0, x$1[1], prev], r$3, y),
           prev$3 = match$2[2],
           r$4 = match$2[1];
          return [0, [0, x, r$4], prev$3];
         }
         var l$0 = r$3;
        }
        break;
       default: return [0, [0, x, 0], prev];
     }
    }
   }
   function delta_1$0(counter, ctx, x, rem){
    var marks$0 = ctx[4], c = ctx[1], match = x[2];
    if(typeof match === "number") return [0, [2, marks$0], rem];
    switch(match[0]){
      case 0:
       var s = match[1];
       return caml_call2(Re_Cset[17], c, s)
               ? [0, [1, marks$0, eps_expr], rem]
               : rem;
      case 1:
       var l = match[1];
       if(counter >= 50)
        return caml_trampoline_return(delta_alt$0, [0, ctx, l, rem]);
       var counter$0 = counter + 1 | 0;
       return delta_alt$0(counter$0, ctx, l, rem);
      case 2:
       var
        z = match[3],
        y = match[2],
        kind = match[1],
        y$0 = delta_1(ctx, y, 0);
       if(counter >= 50)
        return caml_trampoline_return
                (delta_seq$0, [0, ctx, kind, y$0, z, rem]);
       var counter$1 = counter + 1 | 0;
       return delta_seq$0(counter$1, ctx, kind, y$0, z, rem);
      case 3:
       var
        y$1 = match[3],
        kind$0 = match[2],
        rep_kind = match[1],
        y$2 = delta_1(ctx, y$1, 0),
        match$0 = first_match(y$2);
       if(match$0)
        var
         marks$1 = match$0[1],
         marks$2 = marks$1,
         y$3 = caml_call1(remove_matches, y$2);
       else
        var marks$2 = marks$0, y$3 = y$2;
       return 620821490 <= rep_kind
               ? [0, [2, marks$0], tseq(kind$0, y$3, x, rem)]
               : tseq(kind$0, y$3, x, [0, [2, marks$2], rem]);
      case 4:
       var i = match[1], marks$3 = set_mark(marks$0, i);
       return [0, [2, marks$3], rem];
      case 5:
       var e = match[2], b = match[1];
       return [0, [2, filter(marks$0, b, e)], rem];
      case 6:
       var cat = match[1];
       return caml_call2(Re_Category[13], ctx[3], cat)
               ? [0, [2, marks$0], rem]
               : rem;
      case 7:
       var cat$0 = match[1];
       return caml_call2(Re_Category[13], ctx[2], cat$0)
               ? [0, [2, marks$0], rem]
               : rem;
      default:
       var
        i$0 = match[1],
        _N_ = caml_call2(Re_Pmark[5][2], i$0, marks$0[2]),
        marks = [0, marks$0[1], _N_];
       return [0, [2, marks], rem];
    }
   }
   function delta_alt$0(counter, ctx, l, rem){
    if(! l) return rem;
    var r = l[2], y = l[1], _M_ = delta_alt(ctx, r, rem);
    if(counter >= 50)
     return caml_trampoline_return(delta_1$0, [0, ctx, y, _M_]);
    var counter$0 = counter + 1 | 0;
    return delta_1$0(counter$0, ctx, y, _M_);
   }
   function delta_seq$0(counter, ctx, kind, y, z, rem){
    var match = first_match(y);
    if(! match) return tseq(kind, y, z, rem);
    var marks = match[1], ctx$0 = [0, ctx[1], ctx[2], ctx[3], marks];
    if(-730718166 === kind){
     var _K_ = delta_1(ctx$0, z, rem);
     return tseq(kind, caml_call1(remove_matches, y), z, _K_);
    }
    if(332064784 <= kind){
     var match$0 = split_at_match(y), y$0 = match$0[2], y$1 = match$0[1];
     return tseq(kind, y$1, z, delta_1(ctx$0, z, tseq(kind, y$0, z, rem)));
    }
    var _L_ = tseq(kind, caml_call1(remove_matches, y), z, rem);
    if(counter >= 50)
     return caml_trampoline_return(delta_1$0, [0, ctx$0, z, _L_]);
    var counter$0 = counter + 1 | 0;
    return delta_1$0(counter$0, ctx$0, z, _L_);
   }
   function delta_1(ctx, x, rem){
    return caml_trampoline(delta_1$0(0, ctx, x, rem));
   }
   function delta_alt(ctx, l, rem){
    return caml_trampoline(delta_alt$0(0, ctx, l, rem));
   }
   function delta_seq(ctx, kind, y, z, rem){
    return caml_trampoline(delta_seq$0(0, ctx, kind, y, z, rem));
   }
   function delta_4(ctx, l, rem){
    if(! l) return rem;
    var r = l[2], y$1 = l[1], rem$0 = delta_4(ctx, r, rem);
    switch(y$1[0]){
      case 0:
       var kind = y$1[3], z = y$1[2], y = y$1[1], y$0 = delta_4(ctx, y, 0);
       return delta_seq(ctx, kind, y$0, z, rem$0);
      case 1:
       var e = y$1[2], marks = y$1[1];
       return delta_1([0, ctx[1], ctx[2], ctx[3], marks], e, rem$0);
      default: return [0, y$1, rem$0];
    }
   }
   function delta(tbl_ref, next_cat, char$0, st){
    var
     prev_cat = st[2],
     ctx = [0, char$0, prev_cat, next_cat, empty],
     expr = remove_duplicates(0, delta_4(ctx, st[3], 0), eps_expr)[1],
     idx = free_index(tbl_ref, expr),
     expr$0 = set_idx(idx, expr);
    return mk(idx, next_cat, expr$0);
   }
   function red_tr(l){
    var l$0 = l;
    for(;;){
     if(l$0){
      var match = l$0[2];
      if(match){
       var
        rem = match[2],
        tr2 = match[1],
        st2 = tr2[2],
        s2 = tr2[1],
        tr1 = l$0[1],
        st1 = tr1[2],
        s1 = tr1[1];
       if(! equal$2(st1, st2)) return [0, tr1, red_tr([0, tr2, rem])];
       var
        l$1 = [0, [0, caml_call2(Re_Cset[7], s1, s2), st1], rem],
        l$0 = l$1;
       continue;
      }
     }
     return l$0;
    }
   }
   function prepend_deriv(init){
    function _H_(param, l){
     var x = param[2], s = param[1];
     return caml_call3(Re_Cset[48], s, x, l);
    }
    var _I_ = caml_call1(Stdlib_ListLabels[27], _H_);
    return function(_J_){return caml_call2(_I_, _J_, init);};
   }
   function restrict(s, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      rem = param$0[2],
      match = param$0[1],
      x = match[2],
      s$0 = match[1],
      s$1 = caml_call2(Re_Cset[10], s, s$0);
     if(! caml_call1(Re_Cset[47], s$1))
      return [0, [0, s$1, x], restrict(s, rem)];
     var param$0 = rem;
    }
   }
   function prepend_marks_expr_lst(m, l){
    function _G_(param){
     switch(param[0]){
       case 0:
        var s = param[3], e = param[2], l = param[1];
        return [0, prepend_marks_expr_lst(m, l), e, s];
       case 1:
        var e$0 = param[2], m$0 = param[1]; return [1, merge(m, m$0), e$0];
       default: var m$1 = param[1]; return [2, merge(m, m$1)];
     }
    }
    return caml_call2(Stdlib_ListLabels[20], _G_, l);
   }
   function deriv_1$0(counter, all_chars, categories, marks, cat, x, rem$2){
    var match = x[2];
    if(typeof match === "number")
     return caml_call3(Re_Cset[48], all_chars, [0, [2, marks], 0], rem$2);
    switch(match[0]){
      case 0:
       var s = match[1];
       return caml_call3(Re_Cset[48], s, [0, [1, marks, eps_expr], 0], rem$2);
      case 1:
       var l = match[1];
       if(counter >= 50)
        return caml_trampoline_return
                (deriv_2$0, [0, all_chars, categories, marks, cat, l, rem$2]);
       var counter$0 = counter + 1 | 0;
       return deriv_2$0
               (counter$0, all_chars, categories, marks, cat, l, rem$2);
      case 2:
       var
        z = match[3],
        y = match[2],
        kind = match[1],
        y$0 =
          deriv_1
           (all_chars, categories, marks, cat, y, [0, [0, all_chars, 0], 0]);
       return deriv_seq(all_chars, categories, cat, kind, y$0, z, rem$2);
      case 3:
       var
        y$1 = match[3],
        kind$0 = match[2],
        rep_kind = match[1],
        y$2 =
          deriv_1
           (all_chars, categories, marks, cat, y$1, [0, [0, all_chars, 0], 0]),
        _B_ =
          function(param, rem){
           var z = param[2], s = param[1], match = first_match(z);
           if(match)
            var
             marks$0 = match[1],
             marks$1 = marks$0,
             z$0 = caml_call1(remove_matches, z);
           else
            var marks$1 = marks, z$0 = z;
           var
            _F_ =
              620821490 <= rep_kind
               ? [0, [2, marks], tseq(kind$0, z$0, x, 0)]
               : tseq(kind$0, z$0, x, [0, [2, marks$1], 0]);
           return caml_call3(Re_Cset[48], s, _F_, rem);
          };
       return caml_call3(Stdlib_ListLabels[27], _B_, y$2, rem$2);
      case 4:
       var i = match[1], _C_ = [0, [2, set_mark(marks, i)], 0];
       return caml_call3(Re_Cset[48], all_chars, _C_, rem$2);
      case 5:
       var
        e$1 = match[2],
        b = match[1],
        _A_ = marks[2],
        rem$1 = filter(marks, b, e$1)[1],
        e = e$1,
        rem = rem$1,
        _D_ = 0;
       for(;;){
        if(e < b)
         return caml_call3
                 (Re_Cset[48], all_chars, [0, [2, [0, rem, _A_]], _D_], rem$2);
        var
         rem$0 = [0, [0, e, -2], rem],
         e$0 = e - 1 | 0,
         e = e$0,
         rem = rem$0;
       }
       break;
      case 6:
       var
        cat$0 = match[1],
        _E_ = caml_call2(Stdlib_ListLabels[51], cat$0, categories);
       return caml_call3(Re_Cset[48], _E_, [0, [2, marks], 0], rem$2);
      case 7:
       var cat$1 = match[1];
       return caml_call2(Re_Category[13], cat, cat$1)
               ? caml_call3(Re_Cset[48], all_chars, [0, [2, marks], 0], rem$2)
               : rem$2;
      default:
       return caml_call3(Re_Cset[48], all_chars, [0, [2, marks], 0], rem$2);
    }
   }
   function deriv_2$0(counter, all_chars, categories, marks, cat, l, rem){
    if(! l) return rem;
    var
     r = l[2],
     y = l[1],
     _z_ = deriv_2(all_chars, categories, marks, cat, r, rem);
    if(counter >= 50)
     return caml_trampoline_return
             (deriv_1$0, [0, all_chars, categories, marks, cat, y, _z_]);
    var counter$0 = counter + 1 | 0;
    return deriv_1$0(counter$0, all_chars, categories, marks, cat, y, _z_);
   }
   function deriv_1(all_chars, categories, marks, cat, x, rem){
    return caml_trampoline
            (deriv_1$0(0, all_chars, categories, marks, cat, x, rem));
   }
   function deriv_2(all_chars, categories, marks, cat, l, rem){
    return caml_trampoline
            (deriv_2$0(0, all_chars, categories, marks, cat, l, rem));
   }
   function deriv_seq(all_chars, categories, cat, kind, y, z, rem){
    function _l_(param){
     var xl = param[2];
     return caml_call1(exists_tmatch, xl);
    }
    if(caml_call2(Stdlib_ListLabels[34], _l_, y)){
     var
      z$0 =
        deriv_1
         (all_chars, categories, empty, cat, z, [0, [0, all_chars, 0], 0]),
      _m_ =
        function(param, rem){
         var y = param[2], s = param[1], match = first_match(y);
         if(! match){
          var _y_ = tseq(kind, y, z, 0);
          return caml_call3(Re_Cset[48], s, _y_, rem);
         }
         var marks = match[1];
         function _p_(param){
          var x = param[2], s = param[1];
          return [0, s, prepend_marks_expr_lst(marks, x)];
         }
         var
          z$1 =
            restrict
             (s, caml_call1(caml_call1(Stdlib_ListLabels[20], _p_), z$0));
         if(-730718166 === kind){
          var
           _q_ = prepend_deriv(z$1)(rem),
           _r_ = tseq(kind, caml_call1(remove_matches, y), z, 0);
          return caml_call3(Re_Cset[48], s, _r_, _q_);
         }
         if(332064784 <= kind){
          var
           match$0 = split_at_match(y),
           y$0 = match$0[2],
           y$1 = match$0[1],
           _s_ = tseq(kind, y$0, z, 0),
           _t_ = caml_call3(Re_Cset[48], s, _s_, rem),
           _u_ = prepend_deriv(z$1)(_t_),
           _v_ = tseq(kind, y$1, z, 0);
          return caml_call3(Re_Cset[48], s, _v_, _u_);
         }
         var
          _w_ = tseq(kind, caml_call1(remove_matches, y), z, 0),
          _x_ = caml_call3(Re_Cset[48], s, _w_, rem);
         return prepend_deriv(z$1)(_x_);
        };
     return caml_call3(Stdlib_ListLabels[27], _m_, y, rem);
    }
    function _n_(param, rem){
     var xl = param[2], s = param[1], _o_ = tseq(kind, xl, z, 0);
     return caml_call3(Re_Cset[48], s, _o_, rem);
    }
    return caml_call3(Stdlib_ListLabels[27], _n_, y, rem);
   }
   function deriv_4(all_chars, categories, cat, l, rem){
    if(! l) return rem;
    var
     r = l[2],
     y$1 = l[1],
     rem$0 = deriv_4(all_chars, categories, cat, r, rem);
    switch(y$1[0]){
      case 0:
       var
        kind = y$1[3],
        z = y$1[2],
        y = y$1[1],
        y$0 =
          deriv_4(all_chars, categories, cat, y, [0, [0, all_chars, 0], 0]);
       return deriv_seq(all_chars, categories, cat, kind, y$0, z, rem$0);
      case 1:
       var e = y$1[2], marks = y$1[1];
       return deriv_1(all_chars, categories, marks, cat, e, rem$0);
      default: return caml_call3(Re_Cset[48], all_chars, [0, y$1, 0], rem$0);
    }
   }
   function deriv(tbl_ref, all_chars, categories, st){
    var
     der =
       deriv_4(all_chars, categories, st[2], st[3], [0, [0, all_chars, 0], 0]),
     _g_ = 0;
    function _h_(param, rem){
     var
      expr = param[2],
      s = param[1],
      expr$0 = remove_duplicates(0, expr, eps_expr)[1],
      idx = free_index(tbl_ref, expr$0),
      expr$1 = set_idx(idx, expr$0);
     function _k_(param, rem){
      var
       s$0 = param[2],
       cat = param[1],
       s$1 = caml_call2(Re_Cset[10], s, s$0);
      return caml_call1(Re_Cset[47], s$1)
              ? rem
              : [0, [0, s$1, mk(idx, cat, expr$1)], rem];
     }
     return caml_call3(Stdlib_ListLabels[27], _k_, categories, rem);
    }
    var l = caml_call3(Stdlib_ListLabels[27], _h_, der, _g_);
    function _d_(param, _j_){
     var
      st2 = _j_[2],
      st1 = param[2],
      c = runtime.caml_int_compare(st1[5], st2[5]);
     if(0 !== c) return c;
     var c$0 = caml_call2(Re_Category[12], st1[2], st2[2]);
     return 0 === c$0 ? caml_compare(st1[3], st2[3]) : c$0;
    }
    var _e_ = red_tr(caml_call2(Stdlib_ListLabels[59], _d_, l));
    function _f_(param, _i_){
     var s2 = _i_[1], s1 = param[1];
     return caml_compare(s1, s2);
    }
    return caml_call2(Stdlib_ListLabels[59], _f_, _e_);
   }
   var
    Re_Automata =
      [0,
       Mark,
       [0, pp],
       Rep_kind,
       is_eps,
       pp$1,
       [0, create],
       cst,
       empty$0,
       alt,
       seq,
       eps,
       rep,
       mark,
       pmark,
       erase,
       before,
       after,
       rename,
       [0, dummy, create$0, idx, status, Table],
       [0, create$1, index_count],
       delta,
       deriv];
   runtime.caml_register_global(40, Re_Automata, "Re__Automata");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Color_map
//# unitInfo: Requires: Re__Cset, Stdlib__Bytes, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Cset = global_data.Re__Cset,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function repr(t, color){
    return caml_string_get(t, caml_call1(Re_Cset[1], color));
   }
   var length = runtime.caml_ml_string_length, Repr = [0, repr, length];
   function get_char(t, c){
    return caml_string_get(t, caml_call1(Re_Cset[1], c));
   }
   function get(t, c){
    var _g_ = caml_string_get(t, c);
    return caml_call1(Re_Cset[2], _g_);
   }
   function translate_colors(cm, cset){
    function _e_(param, l){
     var
      j = param[2],
      i = param[1],
      start = get_char(cm, i),
      stop = get_char(cm, j),
      _f_ = caml_call2(Re_Cset[25], start, stop);
     return caml_call2(Re_Cset[7], _f_, l);
    }
    return caml_call3(Re_Cset[42], cset, Re_Cset[13], _e_);
   }
   var Table = [0, get_char, get, translate_colors];
   function make(param){return caml_call2(Stdlib_Bytes[1], 257, 0);}
   function flatten(cm){
    var
     c = caml_create_bytes(256),
     color_repr = caml_create_bytes(256),
     v = [0, 0];
    caml_bytes_set(c, 0, 0);
    caml_bytes_set(color_repr, 0, 0);
    var i = 1;
    for(;;){
     if(0 !== runtime.caml_bytes_get(cm, i)) v[1]++;
     caml_bytes_set(c, i, caml_call1(Stdlib_Char[1], v[1]));
     var _c_ = caml_call1(Stdlib_Char[1], i);
     caml_bytes_set(color_repr, v[1], _c_);
     var _d_ = i + 1 | 0;
     if(255 === i){
      var _b_ = caml_call3(Stdlib_Bytes[8], color_repr, 0, v[1] + 1 | 0);
      return [0, caml_call1(Stdlib_Bytes[44], c), _b_];
     }
     var i = _d_;
    }
   }
   function split(t, set){
    function _a_(i, j){
     caml_bytes_set(t, caml_call1(Re_Cset[1], i), 1);
     return caml_bytes_set(t, caml_call1(Re_Cset[1], j) + 1 | 0, 1);
    }
    return caml_call2(Re_Cset[6], set, _a_);
   }
   var Re_Color_map = [0, Repr, Table, make, flatten, split];
   runtime.caml_register_global(3, Re_Color_map, "Re__Color_map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Ast
//# unitInfo: Requires: Re__Automata, Re__Color_map, Re__Cset, Re__Fmt, Re__Import, Re__Pmark, Stdlib, Stdlib__Buffer, Stdlib__Format, Stdlib__Int, Stdlib__ListLabels, Stdlib__Option, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Re_repn$1 = "Re.repn",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    s = "Sequence",
    cst = cst$1,
    cst$0 = cst$1,
    empty_alternative = [0, 0],
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_Format = global_data.Stdlib__Format,
    Re_Pmark = global_data.Re__Pmark,
    Re_Automata = global_data.Re__Automata,
    Re_Cset = global_data.Re__Cset,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Option = global_data.Stdlib__Option,
    Re_Import = global_data.Re__Import,
    Stdlib = global_data.Stdlib,
    Re_Color_map = global_data.Re__Color_map,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    _a_ = [0, [15, [17, [0, "@ ", 1, 0], [4, 0, 0, 0, [15, 0]]]], "%a@ %d%a"],
    cst_Beg_of_line = "Beg_of_line",
    cst_End_of_line = "End_of_line",
    cst_Beg_of_word = "Beg_of_word",
    cst_End_of_word = "End_of_word",
    cst_Not_bound = "Not_bound",
    cst_Beg_of_str = "Beg_of_str",
    cst_End_of_str = "End_of_str",
    cst_Last_end_of_line = "Last_end_of_line",
    cst_Start = "Start",
    cst_Stop = "Stop",
    cst_Repeat = "Repeat",
    cst_Named_group = "Named_group",
    cst_Group = "Group",
    cst_No_group = "No_group",
    cst_Nest = "Nest",
    cst_Pmark = "Pmark",
    cst_Sem = "Sem",
    cst_Sem_greedy = "Sem_greedy",
    cst_Set = "Set",
    cst_Intersection = "Intersection",
    cst_Complement = "Complement",
    cst_Difference = "Difference",
    _i_ = [0, "lib/ast.ml", 298, 32],
    cst_Re_diff = "Re.diff",
    cst_Re_compl = "Re.compl",
    cst_Re_inter = "Re.inter",
    _b_ = [0, 1],
    cst_Re_repn = cst_Re_repn$1,
    cst_Re_repn$0 = cst_Re_repn$1,
    cst_Alternative = "Alternative",
    cst_No_case = "No_case",
    cst_Case = "Case";
   function pp_ast(f, fmt, ast){
    function var$0(s, re){return caml_call4(Re_Fmt[2], fmt, s, f, re);}
    switch(ast[0]){
      case 0:
       var alt = ast[1], _ap_ = caml_call2(Re_Fmt[8], 0, f);
       return caml_call4(Re_Fmt[2], fmt, cst_Alternative, _ap_, alt);
      case 1:
       var c = ast[1]; return var$0(cst_No_case, c);
      default: var c$0 = ast[1]; return var$0(cst_Case, c$0);
    }
   }
   function pp_gen(pp_cset, fmt, t){
    function pp(_an_, _ao_){return pp_gen(pp_cset, _an_, _ao_);}
    function var$0(s, re){return caml_call4(Re_Fmt[2], fmt, s, pp, re);}
    if(typeof t === "number")
     switch(t){
       case 0:
        return caml_call2(Re_Fmt[3], fmt, cst_Beg_of_line);
       case 1:
        return caml_call2(Re_Fmt[3], fmt, cst_End_of_line);
       case 2:
        return caml_call2(Re_Fmt[3], fmt, cst_Beg_of_word);
       case 3:
        return caml_call2(Re_Fmt[3], fmt, cst_End_of_word);
       case 4:
        return caml_call2(Re_Fmt[3], fmt, cst_Not_bound);
       case 5:
        return caml_call2(Re_Fmt[3], fmt, cst_Beg_of_str);
       case 6:
        return caml_call2(Re_Fmt[3], fmt, cst_End_of_str);
       case 7:
        return caml_call2(Re_Fmt[3], fmt, cst_Last_end_of_line);
       case 8:
        return caml_call2(Re_Fmt[3], fmt, cst_Start);
       default: return caml_call2(Re_Fmt[3], fmt, cst_Stop);
     }
    switch(t[0]){
      case 0:
       var cset = t[1]; return caml_call2(pp_cset, fmt, cset);
      case 1:
       var a = t[1]; return pp_ast(pp, fmt, a);
      case 2:
       var rel = t[1], _ai_ = caml_call2(Re_Fmt[8], 0, pp);
       return caml_call4(Re_Fmt[2], fmt, s, _ai_, rel);
      case 3:
       var
        stop = t[3],
        start = t[2],
        re = t[1],
        pp$0 =
          function(fmt, param){
           return caml_call7
                   (Stdlib_Format[137],
                    fmt,
                    _a_,
                    pp,
                    re,
                    start,
                    Re_Fmt[4],
                    stop);
          };
       return caml_call4(Re_Fmt[2], fmt, cst_Repeat, pp$0, 0);
      case 4:
       var match = t[1];
       if(match){
        var
         c = t[2],
         n = match[1],
         _aj_ = caml_call2(Re_Fmt[6], Re_Fmt[3], pp);
        return caml_call4(Re_Fmt[2], fmt, cst_Named_group, _aj_, [0, n, c]);
       }
       var c$0 = t[2];
       return var$0(cst_Group, c$0);
      case 5:
       var c$1 = t[1]; return var$0(cst_No_group, c$1);
      case 6:
       var c$2 = t[1]; return var$0(cst_Nest, c$2);
      case 7:
       var r = t[2], m = t[1], _ak_ = caml_call2(Re_Fmt[6], Re_Pmark[4], pp);
       return caml_call4(Re_Fmt[2], fmt, cst_Pmark, _ak_, [0, m, r]);
      case 8:
       var
        a$0 = t[2],
        sem = t[1],
        _al_ = caml_call2(Re_Fmt[6], Re_Automata[2][1], pp);
       return caml_call4(Re_Fmt[2], fmt, cst_Sem, _al_, [0, sem, a$0]);
      default:
       var
        re$0 = t[2],
        k = t[1],
        _am_ = caml_call2(Re_Fmt[6], Re_Automata[3][1], pp);
       return caml_call4(Re_Fmt[2], fmt, cst_Sem_greedy, _am_, [0, k, re$0]);
    }
   }
   function pp_cset(fmt, cset){
    function seq(s, rel){
     var _ah_ = caml_call2(Re_Fmt[8], 0, pp_cset);
     return caml_call4(Re_Fmt[2], fmt, s, _ah_, rel);
    }
    switch(cset[0]){
      case 0:
       var s = cset[1];
       return caml_call4(Re_Fmt[2], fmt, cst_Set, Re_Cset[40], s);
      case 1:
       var c = cset[1]; return seq(cst_Intersection, c);
      case 2:
       var c$0 = cset[1]; return seq(cst_Complement, c$0);
      case 3:
       var
        b = cset[2],
        a = cset[1],
        _ag_ = caml_call2(Re_Fmt[6], pp_cset, pp_cset);
       return caml_call4(Re_Fmt[2], fmt, cst_Difference, _ag_, [0, a, b]);
      default: var s$0 = cset[1]; return pp_ast(pp_cset, fmt, s$0);
    }
   }
   function equal(cset, x1, x2){
    var x1$0 = x1, x2$0 = x2;
    for(;;){
     a:
     {
      if(typeof x1$0 === "number"){
       switch(x1$0){
         case 0:
          if(typeof x2$0 !== "number" || x2$0) break a; break;
         case 1:
          if(typeof x2$0 !== "number" || 1 !== x2$0) break a; break;
         case 2:
          if(typeof x2$0 !== "number" || 2 !== x2$0) break a; break;
         case 3:
          if(typeof x2$0 !== "number" || 3 !== x2$0) break a; break;
         case 4:
          if(typeof x2$0 !== "number" || 4 !== x2$0) break a; break;
         case 5:
          if(typeof x2$0 !== "number" || 5 !== x2$0) break a; break;
         case 6:
          if(typeof x2$0 !== "number" || 6 !== x2$0) break a; break;
         case 7:
          if(typeof x2$0 !== "number" || 7 !== x2$0) break a; break;
         case 8:
          if(typeof x2$0 !== "number" || 8 !== x2$0) break a; break;
         default: if(typeof x2$0 !== "number" || 9 > x2$0) break a;
       }
       return 1;
      }
      switch(x1$0[0]){
        case 0:
         if(typeof x2$0 !== "number" && 0 === x2$0[0]){
          var s2 = x2$0[1], s1 = x1$0[1];
          return caml_call2(cset, s1, s2);
         }
         break;
        case 1:
         if(typeof x2$0 !== "number" && 1 === x2$0[0]){
          var
           y = x2$0[1],
           x = x1$0[1],
           eq = function(_ae_, _af_){return equal(cset, _ae_, _af_);},
           b = y[1],
           a = x[1];
          return caml_call3(Stdlib_ListLabels[16], eq, a, b);
         }
         break;
        case 2:
         if(typeof x2$0 !== "number" && 2 === x2$0[0]){
          var
           l2 = x2$0[1],
           l1 = x1$0[1],
           _X_ = function(_ac_, _ad_){return equal(cset, _ac_, _ad_);};
          return caml_call3(Stdlib_ListLabels[16], _X_, l1, l2);
         }
         break;
        case 3:
         if(typeof x2$0 !== "number" && 3 === x2$0[0]){
          var
           j2 = x2$0[3],
           i2 = x2$0[2],
           x2$1 = x2$0[1],
           j1 = x1$0[3],
           i1 = x1$0[2],
           x1$1 = x1$0[1],
           _Y_ = caml_call2(Stdlib_Int[8], i1, i2);
          if(_Y_){
           var _Z_ = caml_call3(Stdlib_Option[12], Stdlib_Int[8], j1, j2);
           if(_Z_){var x1$0 = x1$1, x2$0 = x2$1; continue;}
           var ___ = _Z_;
          }
          else
           var ___ = _Y_;
          return ___;
         }
         break;
        case 4:
         if(typeof x2$0 !== "number" && 4 === x2$0[0]) return 0; break;
        case 6:
         if(typeof x2$0 !== "number" && 6 === x2$0[0]){
          var x2$2 = x2$0[1], x1$2 = x1$0[1], x1$0 = x1$2, x2$0 = x2$2;
          continue;
         }
         break;
        case 7:
         if(typeof x2$0 !== "number" && 7 === x2$0[0]){
          var
           r2 = x2$0[2],
           m2 = x2$0[1],
           r1 = x1$0[2],
           m1 = x1$0[1],
           _$_ = caml_call2(Re_Pmark[1], m1, m2);
          if(! _$_) return _$_;
          var x1$0 = r1, x2$0 = r2;
          continue;
         }
         break;
        case 8:
         if(typeof x2$0 !== "number" && 8 === x2$0[0]){
          var
           x2$3 = x2$0[2],
           sem = x2$0[1],
           x1$3 = x1$0[2],
           sem$0 = x1$0[1],
           _aa_ = caml_call2(Re_Import[1][1], sem$0, sem);
          if(! _aa_) return _aa_;
          var x1$0 = x1$3, x2$0 = x2$3;
          continue;
         }
         break;
        case 9:
         if(typeof x2$0 !== "number" && 9 === x2$0[0]){
          var
           x2$4 = x2$0[2],
           rep = x2$0[1],
           x1$4 = x1$0[2],
           rep$0 = x1$0[1],
           _ab_ = caml_call2(Re_Import[1][1], rep$0, rep);
          if(! _ab_) return _ab_;
          var x1$0 = x1$4, x2$0 = x2$4;
          continue;
         }
         break;
      }
     }
     return 0;
    }
   }
   function pp(_V_, _W_){return pp_gen(pp_cset, _V_, _W_);}
   function cset(cset){return [0, [0, cset]];}
   function handle_case_cset(ign_case, param){
    var ign_case$0 = ign_case, param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var s = param$0[1];
        return ign_case$0 ? caml_call1(Re_Cset[18], s) : s;
       case 1:
        var
         l = param$0[1],
         _I_ = function(_U_){return handle_case_cset(ign_case$0, _U_);},
         _J_ = caml_call2(Stdlib_ListLabels[20], _I_, l);
        return caml_call1(Re_Cset[9], _J_);
       case 2:
        var
         l$0 = param$0[1],
         _K_ = function(_T_){return handle_case_cset(ign_case$0, _T_);},
         _L_ = caml_call2(Stdlib_ListLabels[20], _K_, l$0),
         _M_ = caml_call1(Re_Cset[8], _L_);
        return caml_call1(caml_call1(Re_Cset[11], Re_Cset[45]), _M_);
       case 3:
        var
         r = param$0[2],
         r$0 = param$0[1],
         _N_ = handle_case_cset(ign_case$0, r),
         _O_ = caml_call2(Re_Cset[11], Re_Cset[45], _N_),
         _P_ = handle_case_cset(ign_case$0, r$0);
        return caml_call2(Re_Cset[10], _P_, _O_);
       default:
        var match = param$0[1];
        switch(match[0]){
          case 0:
           var
            l$1 = match[1],
            _Q_ = function(_S_){return handle_case_cset(ign_case$0, _S_);},
            _R_ = caml_call2(Stdlib_ListLabels[20], _Q_, l$1);
           return caml_call1(Re_Cset[8], _R_);
          case 1:
           var a = match[1], ign_case$0 = 1, param$0 = a; break;
          default: var a$0 = match[1], ign_case$0 = 0, param$0 = a$0;
        }
     }
   }
   function handle_case(ign_case, r){
    var ign_case$0 = ign_case, r$0 = r;
    for(;;){
     if(typeof r$0 === "number") return r$0;
     switch(r$0[0]){
       case 0:
        var s = r$0[1]; return [0, handle_case_cset(ign_case$0, s)];
       case 1:
        var match = r$0[1];
        switch(match[0]){
          case 0:
           var
            l = match[1],
            _E_ = function(_H_){return handle_case(ign_case$0, _H_);},
            l$0 = caml_call2(Stdlib_ListLabels[20], _E_, l);
           return [1, [0, l$0]];
          case 1:
           var r$1 = match[1], ign_case$0 = 1, r$0 = r$1; break;
          default: var r$2 = match[1], ign_case$0 = 0, r$0 = r$2;
        }
        break;
       case 2:
        var
         l$1 = r$0[1],
         _F_ = function(_G_){return handle_case(ign_case$0, _G_);};
        return [2, caml_call2(Stdlib_ListLabels[20], _F_, l$1)];
       case 3:
        var j = r$0[3], i = r$0[2], r$3 = r$0[1];
        return [3, handle_case(ign_case$0, r$3), i, j];
       case 4:
        var r$4 = r$0[2], n = r$0[1];
        return [4, n, handle_case(ign_case$0, r$4)];
       case 5:
        var r$5 = r$0[1]; return [5, handle_case(ign_case$0, r$5)];
       case 6:
        var r$6 = r$0[1]; return [6, handle_case(ign_case$0, r$6)];
       case 7:
        var r$7 = r$0[2], i$0 = r$0[1];
        return [7, i$0, handle_case(ign_case$0, r$7)];
       case 8:
        var r$8 = r$0[2], k = r$0[1];
        return [8, k, handle_case(ign_case$0, r$8)];
       default:
        var r$9 = r$0[2], k$0 = r$0[1];
        return [9, k$0, handle_case(ign_case$0, r$9)];
     }
    }
   }
   function seq(l){if(l && ! l[2]){var r = l[1]; return r;} return [2, l];}
   function str(s){
    var l = [0, 0], _A_ = caml_ml_string_length(s) - 1 | 0;
    if(_A_ >= 0){
     var i = _A_;
     for(;;){
      var _B_ = l[1], _C_ = runtime.caml_string_get(s, i);
      l[1] = [0, [0, [0, caml_call1(Re_Cset[46], _C_)]], _B_];
      var _D_ = i - 1 | 0;
      if(0 === i) break;
      var i = _D_;
     }
    }
    return seq(l[1]);
   }
   function as_set_elems(elems){
    try{
     var
      _y_ =
        function(param){
         if(typeof param !== "number" && 0 === param[0]){var e = param[1]; return e;}
         throw Stdlib[3];
        },
      e = caml_call2(Stdlib_ListLabels[20], _y_, elems);
    }
    catch(_z_){
     var _x_ = caml_wrap_exception(_z_);
     if(_x_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_x_, 0);
    }
    return [0, e];
   }
   var empty = [1, empty_alternative];
   function alt(elems){
    if(! elems) return empty;
    if(! elems[2]){var x = elems[1]; return x;}
    var match = as_set_elems(elems);
    if(! match) return [1, [0, elems]];
    var elems$0 = match[1];
    return [0, [4, [0, elems$0]]];
   }
   var epsilon = seq(0);
   function repn(r, i, j){
    if(i < 0) caml_call1(Stdlib[1], cst_Re_repn);
    if(j){
     var j$0 = j[1];
     if(j$0 < i) return caml_call1(Stdlib[1], cst_Re_repn$0);
     if(0 === j$0){
      if(0 === i) return epsilon;
     }
     else if(1 === j$0 && 1 === i) return r;
    }
    return [3, r, i, j];
   }
   function rep(r){return repn(r, 0, 0);}
   function rep1(r){return repn(r, 1, 0);}
   function opt(r){return repn(r, 0, _b_);}
   var bol = 0, eol = 1, bow = 2, eow = 3;
   function word(r){return seq([0, bow, [0, r, [0, eow, 0]]]);}
   var not_boundary = 4, bos = 5, eos = 6;
   function whole_string(r){return seq([0, bos, [0, r, [0, eos, 0]]]);}
   var leol = 7, start = 8, stop = 9;
   function make_set(f, t){
    if(typeof t !== "number" && 0 === t[0]){
     var x = t[1];
     return [0, [4, caml_call1(f[1], x)]];
    }
    return [1, caml_call1(f[1], t)];
   }
   function preserve_set(f, t){
    if(typeof t !== "number" && 0 === t[0]) return t;
    return caml_call1(f, t);
   }
   function _c_(t){return [8, -730718166, t];}
   function longest(_w_){return preserve_set(_c_, _w_);}
   function _d_(t){return [8, -1034406550, t];}
   function shortest(_v_){return preserve_set(_d_, _v_);}
   function _e_(t){return [8, 332064784, t];}
   function first(_u_){return preserve_set(_e_, _u_);}
   function _f_(t){return [9, -904640576, t];}
   function greedy(_t_){return preserve_set(_f_, _t_);}
   function _g_(t){return [9, 620821490, t];}
   function non_greedy(_s_){return preserve_set(_g_, _s_);}
   function group(name, r){return [4, name, r];}
   function _h_(t){return [5, t];}
   function no_group(_r_){return preserve_set(_h_, _r_);}
   function nest(r){return [6, r];}
   function set(str){return cset(caml_call1(Re_Cset[26], str));}
   function mark(r){
    var i = caml_call1(Re_Pmark[3], 0);
    return [0, i, [7, i, r]];
   }
   function as_set_or_error(name, elems){
    var match = as_set_elems(elems);
    if(! match) return caml_call1(Stdlib[1], name);
    var s = match[1];
    return s;
   }
   function inter(elems){
    return [0, [1, as_set_or_error(cst_Re_inter, elems)]];
   }
   function compl(elems){
    return [0, [2, as_set_or_error(cst_Re_compl, elems)]];
   }
   function diff(r$0, r){
    if
     (typeof r$0 !== "number"
      && 0 === r$0[0] && typeof r !== "number" && 0 === r[0]){
     var r$1 = r[1], r$2 = r$0[1];
     return [0, [3, r$2, r$1]];
    }
    return caml_call1(Stdlib[1], cst_Re_diff);
   }
   var f = [0, function(r){return [2, r];}];
   function case$0(t){return make_set(f, t);}
   var f$0 = [0, function(r){return [1, r];}];
   function no_case(t){return make_set(f$0, t);}
   function witness(t){
    function witness(t){
     var t$0 = t;
     for(;;){
      if(typeof t$0 === "number") return cst;
      switch(t$0[0]){
        case 0:
         var
          c = t$0[1],
          _m_ = caml_call1(Re_Cset[49], c),
          _n_ = caml_call1(Re_Cset[3], _m_);
         return caml_call2(Stdlib_String[1], 1, _n_);
        case 1:
         var match = t$0[1][1];
         if(! match)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
         var x = match[1], t$0 = x;
         continue;
        case 2:
         var
          xs = t$0[1],
          _o_ = caml_call2(Stdlib_ListLabels[20], witness, xs);
         return caml_call2(Stdlib_String[7], cst$0, _o_);
        case 3:
         var
          from = t$0[2],
          r = t$0[1],
          w = witness(r),
          b =
            caml_call1
             (Stdlib_Buffer[1],
              runtime.caml_mul(caml_ml_string_length(w), from)),
          _p_ = 1;
         if(from >= 1){
          var i = _p_;
          for(;;){
           caml_call2(Stdlib_Buffer[16], b, w);
           var _q_ = i + 1 | 0;
           if(from === i) break;
           var i = _q_;
          }
         }
         return caml_call1(Stdlib_Buffer[2], b);
        case 5:
         var r$1 = t$0[1], t$0 = r$1; continue;
        case 6:
         var r$0 = t$0[1]; break;
        default: var r$0 = t$0[2];
      }
      var t$0 = r$0;
     }
    }
    return witness(handle_case(0, t));
   }
   function merge_sequences(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var x = param$0[1];
     if(typeof x !== "number")
      switch(x[0]){
        case 1:
         var match = x[1];
         if(0 === match[0]){
          var
           r$0 = param$0[2],
           l = match[1],
           param$0 = caml_call2(Stdlib[37], l, r$0);
          continue;
         }
         break;
        case 2:
         var match$0 = x[1];
         if(match$0){
          var
           r$1 = param$0[2],
           y = match$0[2],
           x$0 = match$0[1],
           r$2 = merge_sequences(r$1);
          a:
          if(r$2){
           var _k_ = r$2[1];
           if(typeof _k_ !== "number" && 2 === _k_[0]){
            var match$1 = _k_[1];
            if(! match$1) break a;
            var r$3 = r$2[2], y$0 = match$1[2], x$1 = match$1[1];
            if(! equal(Re_Cset[5], x$0, x$1)) break a;
            var _l_ = [0, seq(y$0), 0];
            return [0, [2, [0, x$0, [0, [1, [0, [0, seq(y), _l_]]], 0]]], r$3];
           }
          }
          return [0, [2, [0, x$0, y]], r$2];
         }
         break;
      }
     var r = param$0[2];
     return [0, x, merge_sequences(r)];
    }
   }
   function colorize(color_map, regexp){
    var lnl = [0, 0];
    function colorize(regexp){
     var regexp$0 = regexp;
     for(;;){
      if(typeof regexp$0 === "number")
       switch(regexp$0){
         case 7:
          lnl[1] = 1; return 0;
         case 0:
         case 1:
          return caml_call2(Re_Color_map[5], color_map, Re_Cset[24]);
         case 2:
         case 3:
         case 4:
          return caml_call2(Re_Color_map[5], color_map, Re_Cset[21]);
         default: return 0;
       }
      switch(regexp$0[0]){
        case 0:
         var s = regexp$0[1];
         return caml_call2(Re_Color_map[5], color_map, s);
        case 1:
         var l = regexp$0[1][1];
         return caml_call2(Stdlib_ListLabels[18], colorize, l);
        case 2:
         var l$0 = regexp$0[1];
         return caml_call2(Stdlib_ListLabels[18], colorize, l$0);
        case 3:
         var regexp$1 = regexp$0[1], regexp$0 = regexp$1; continue;
        case 4:
        case 7:
         var regexp$2 = regexp$0[2]; break;
        case 5:
        case 6:
         var regexp$2 = regexp$0[1]; break;
        default: var regexp$3 = regexp$0[2], regexp$0 = regexp$3; continue;
      }
      var regexp$0 = regexp$2;
     }
    }
    colorize(regexp);
    return lnl[1];
   }
   function anchored(param){
    var param$0 = param;
    for(;;){
     a:
     {
      if(typeof param$0 !== "number"){
       switch(param$0[0]){
         case 1:
          var a = param$0[1];
          if(0 === a[0]){
           var als = a[1];
           return caml_call2(Stdlib_ListLabels[33], anchored, als);
          }
          var r = a[1], param$0 = r;
          continue;
         case 2:
          var l = param$0[1];
          return caml_call2(Stdlib_ListLabels[34], anchored, l);
         case 3:
          var i = param$0[2], r$0 = param$0[1], _j_ = 0 < i ? 1 : 0;
          if(! _j_) return _j_;
          var param$0 = r$0;
          continue;
         case 0:
          break a;
         case 5:
         case 6:
          var r$1 = param$0[1]; break;
         default: var r$1 = param$0[2];
       }
       var param$0 = r$1;
       continue;
      }
      switch(param$0){case 5:case 8: return 1;
      }
     }
     return 0;
    }
   }
   function t_of_cset(x){return [0, x];}
   var
    Re_Ast =
      [0,
       pp,
       merge_sequences,
       handle_case,
       anchored,
       colorize,
       [0,
        empty,
        epsilon,
        str,
        no_case,
        case$0,
        diff,
        compl,
        repn,
        inter,
        set,
        mark,
        nest,
        no_group,
        whole_string,
        leol,
        longest,
        greedy,
        non_greedy,
        stop,
        not_boundary,
        group,
        word,
        first,
        bos,
        bow,
        eow,
        eos,
        bol,
        start,
        eol,
        opt,
        rep,
        rep1,
        alt,
        shortest,
        seq,
        pp,
        witness],
       cset,
       t_of_cset];
   runtime.caml_register_global(51, Re_Ast, "Re__Ast");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__View
//# unitInfo: Requires: Re__Ast, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Ast = global_data.Re__Ast,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels;
   function view_ast(f, t){
    switch(t[0]){
      case 0:
       var a = t[1]; return [2, caml_call2(Stdlib_ListLabels[20], f, a)];
      case 1:
       var a$0 = t[1]; return [10, caml_call1(f, a$0)];
      default: var a$1 = t[1]; return [9, caml_call1(f, a$1)];
    }
   }
   function view(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return 0;
       case 1:
        return 1;
       case 2:
        return 2;
       case 3:
        return 3;
       case 4:
        return 4;
       case 5:
        return 5;
       case 6:
        return 6;
       case 7:
        return 7;
       case 8:
        return 8;
       default: return 9;
     }
    switch(param[0]){
      case 0:
       var cset = param[1];
       switch(cset[0]){
         case 0:
          var set = cset[1]; return [0, set];
         case 1:
          var sets = cset[1];
          return [11, caml_call2(Stdlib_ListLabels[20], Re_Ast[8], sets)];
         case 2:
          var sets$0 = cset[1];
          return [12, caml_call2(Stdlib_ListLabels[20], Re_Ast[8], sets$0)];
         case 3:
          var y = cset[2], x = cset[1], _a_ = caml_call1(Re_Ast[8], y);
          return [13, caml_call1(Re_Ast[8], x), _a_];
         default: var ast = cset[1]; return view_ast(Re_Ast[8], ast);
       }
      case 1:
       var s = param[1]; return view_ast(function(x){return x;}, s);
      case 2:
       var s$0 = param[1]; return [1, s$0];
      case 3:
       var y$0 = param[3], x$0 = param[2], t = param[1];
       return [3, t, x$0, y$0];
      case 4:
       var t$0 = param[2], name = param[1]; return [6, name, t$0];
      case 5:
       var a = param[1]; return [7, a];
      case 6:
       var t$1 = param[1]; return [8, t$1];
      case 7:
       var t$2 = param[2], pmark = param[1]; return [14, pmark, t$2];
      case 8:
       var a$0 = param[2], sem = param[1]; return [4, sem, a$0];
      default: var a$1 = param[2], sem$0 = param[1]; return [5, sem$0, a$1];
    }
   }
   var Re_View = [0, view];
   runtime.caml_register_global(2, Re_View, "Re__View");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Group
//# unitInfo: Requires: Re__Fmt, Re__Mark_infos, Stdlib, Stdlib__Array, Stdlib__Format, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    dummy_offset = [0, -1, -1],
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Array = global_data.Stdlib__Array,
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_String = global_data.Stdlib__String,
    Re_Mark_infos = global_data.Re__Mark_infos,
    Stdlib = global_data.Stdlib,
    _a_ =
      [0,
       [18,
        [1, [0, 0, cst]],
        [12,
         40,
         [2,
          0,
          [11,
           " (",
           [4, 0, 0, 0, [12, 32, [4, 0, 0, 0, [11, "))", [17, 0, 0]]]]]]]]],
       "@[(%s (%d %d))@]"],
    cst_Group = "Group";
   function offset(t, i){
    var match = caml_call2(Re_Mark_infos[2], t[2], i);
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var
     match$0 = match[1],
     stop = match$0[2],
     start = match$0[1],
     _i_ = caml_check_bound(t[4], stop)[1 + stop];
    return [0, caml_check_bound(t[4], start)[1 + start], _i_];
   }
   function get(t, i){
    var match = offset(t, i), p2 = match[2], p1 = match[1];
    return caml_call3(Stdlib_String[16], t[1], p1, p2 - p1 | 0);
   }
   function start(subs, i){return offset(subs, i)[1];}
   function stop(subs, i){return offset(subs, i)[2];}
   function test(t, i){return caml_call2(Re_Mark_infos[3], t[2], i);}
   function get_opt(t, i){return test(t, i) ? [0, get(t, i)] : 0;}
   function all_offset(t){
    var res = caml_make_vect(t[5], dummy_offset);
    function _h_(i, start, stop){
     var
      p1 = caml_check_bound(t[4], start)[1 + start],
      p2 = caml_check_bound(t[4], stop)[1 + stop];
     caml_check_bound(res, i)[1 + i] = [0, p1, p2];
     return 0;
    }
    caml_call2(Re_Mark_infos[4], t[2], _h_);
    return res;
   }
   function all(t){
    var res = caml_make_vect(t[5], cst);
    function _f_(i, start, stop){
     var
      p1 = caml_check_bound(t[4], start)[1 + start],
      p2 = caml_check_bound(t[4], stop)[1 + stop],
      _g_ = caml_call3(Stdlib_String[16], t[1], p1, p2 - p1 | 0);
     caml_check_bound(res, i)[1 + i] = _g_;
     return 0;
    }
    caml_call2(Re_Mark_infos[4], t[2], _f_);
    return res;
   }
   function pp(fmt, t){
    var offsets = all_offset(t), strs = all(t);
    function _b_(i){
     var _e_ = caml_check_bound(offsets, i)[1 + i];
     return [0, caml_check_bound(strs, i)[1 + i], _e_];
    }
    var
     _c_ = caml_call2(Stdlib_Array[1], strs.length - 1, _b_),
     matches = caml_call1(Stdlib_Array[9], _c_);
    function pp_match(fmt, param){
     var match = param[2], stop = match[2], start = match[1], str = param[1];
     return caml_call5(Stdlib_Format[137], fmt, _a_, str, start, stop);
    }
    var _d_ = caml_call2(Re_Fmt[8], 0, pp_match);
    return caml_call4(Re_Fmt[2], fmt, cst_Group, _d_, matches);
   }
   function nb_groups(t){return t[5];}
   var
    Re_Group =
      [0,
       get,
       get_opt,
       offset,
       start,
       stop,
       all,
       all_offset,
       test,
       nb_groups,
       pp];
   runtime.caml_register_global(10, Re_Group, "Re__Group");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Compile
//# unitInfo: Requires: Re__Ast, Re__Automata, Re__Category, Re__Color_map, Re__Cset, Re__Import, Stdlib, Stdlib__Array, Stdlib__Char, Stdlib__Int, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Int = global_data.Stdlib__Int,
    Re_Import = global_data.Re__Import,
    Re_Cset = global_data.Re__Cset,
    Re_Color_map = global_data.Re__Color_map,
    Stdlib_Char = global_data.Stdlib__Char,
    Re_Automata = global_data.Re__Automata,
    Re_Category = global_data.Re__Category,
    Re_Ast = global_data.Re__Ast,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    _a_ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   function iter(n, f, v){
    var n$0 = n, v$0 = v;
    for(;;){
     if(caml_call2(Stdlib_Int[8], n$0, 0)) return v$0;
     var v$1 = caml_call1(f, v$0), n$1 = n$0 - 1 | 0, n$0 = n$1, v$0 = v$1;
    }
   }
   var unknown = -2, break$0 = -3;
   function follow_transition(param, color){
    return param[1 + (1 + caml_call1(Re_Cset[1], color) | 0)];
   }
   function set_transition(param, color, st){
    var _ax_ = 1 + caml_call1(Re_Cset[1], color) | 0;
    caml_check_bound(param, _ax_)[1 + _ax_] = st;
    return;
   }
   var unknown_state = [0, [0, unknown, 0, 0, Re_Automata[19][1]]];
   function pp_re(ch, re){return caml_call2(Re_Automata[5], ch, re[1]);}
   function group_count(re){return re[10];}
   function group_names(re){return re[9];}
   function category(re, color){
    var _ar_ = caml_call1(Re_Cset[1], color);
    if(caml_call2(Re_Import[2], _ar_, -1)) return Re_Category[4];
    var _as_ = re[6], _at_ = caml_call1(Re_Cset[1], color);
    if(caml_call2(Re_Import[2], _at_, _as_)){
     var
      _au_ = Re_Category[6],
      _av_ = caml_call2(Re_Category[1], Re_Category[8], Re_Category[7]);
     return caml_call2(Re_Category[1], _av_, _au_);
    }
    var _aw_ = caml_call2(Re_Color_map[1][1], re[4], color);
    return caml_call1(Re_Category[2], _aw_);
   }
   function find_state(re, desc){
    try{
     var _ap_ = caml_call2(Re_Automata[19][5][7], re[8], desc);
     return _ap_;
    }
    catch(_aq_){
     var _ao_ = caml_wrap_exception(_aq_);
     if(_ao_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ao_, 0);
     var ncol$0 = re[5], match = caml_call1(Re_Automata[19][4], desc);
     a:
     {
      if(typeof match === "number" && match){var break_state = 0; break a;}
      var break_state = 1;
     }
     var
      real_idx = caml_call1(Re_Automata[19][3], desc),
      _an_ = 0,
      break$1 = break_state ? break$0 : real_idx,
      state = [0, break$1, real_idx, _an_, desc],
      ncol = break_state ? 0 : ncol$0,
      st = caml_make_vect(ncol + 1 | 0, unknown_state);
     caml_check_bound(st, 0)[1] = state;
     caml_call3(Re_Automata[19][5][5], re[8], desc, st);
     return st;
    }
   }
   function delta(info, cat, color, st){
    var
     desc = caml_call4(Re_Automata[21], info[1][7], cat, color, st[4]),
     len = info[2].length - 1,
     _ak_ = caml_call1(Re_Automata[19][3], desc),
     _al_ = caml_call2(Re_Import[2], _ak_, len),
     _am_ = _al_ ? 0 < len ? 1 : 0 : _al_;
    if(_am_){
     var pos = info[2];
     info[2] = caml_make_vect(2 * len | 0, 0);
     caml_call5(Stdlib_Array[8], pos, 0, info[2], 0, len);
    }
    return desc;
   }
   function validate(info, s, pos, st){
    var
     _aj_ = caml_string_get(s, pos),
     color = caml_call2(Re_Color_map[2][2], info[1][3], _aj_),
     cat = category(info[1], color),
     desc = delta(info, cat, color, st[1]),
     st$0 = find_state(info[1], desc);
    return set_transition(st, color, st$0);
   }
   function next(colors, st, s, pos){
    return follow_transition
            (st,
             caml_call2
              (Re_Color_map[2][2],
               colors,
               runtime.caml_string_unsafe_get(s, pos)));
   }
   function get_color(re, s, pos){
    if(0 > pos) return caml_call1(Re_Cset[2], -1);
    var slen = caml_ml_string_length(s);
    if(slen <= pos) return caml_call1(Re_Cset[2], -1);
    if(caml_call2(Re_Import[2], pos, slen - 1 | 0) && -1 !== re[6]){
     var _ai_ = caml_string_get(s, pos);
     if(caml_call2(Stdlib_Char[6], _ai_, 10))
      return caml_call1(Re_Cset[2], re[6]);
    }
    var _ah_ = caml_string_get(s, pos);
    return caml_call2(Re_Color_map[2][2], re[3], _ah_);
   }
   function scan_str(info$0, s, initial_state, groups){
    var pos$3 = info$0[3], last = info$0[4];
    if
     (caml_call2(Re_Import[2], last, caml_ml_string_length(s))
      && -1 !== info$0[1][6] && pos$3 < last){
     var _ag_ = caml_string_get(s, last - 1 | 0);
     if(caml_call2(Stdlib_Char[6], _ag_, 10)){
      var
       info$1 = [0, info$0[1], info$0[2], info$0[3], last - 1 | 0],
       st$3 = scan_str(info$1, s, initial_state, groups);
      if(caml_call2(Re_Import[2], st$3[1][1], break$0)) return st$3;
      var pos$4 = last - 1 | 0;
      for(;;){
       var
        st$1 = follow_transition(st$3, caml_call1(Re_Cset[2], info$1[1][6])),
        info = st$1[1];
       if(0 <= info[1]){
        if(groups){
         var _ae_ = info[1];
         caml_check_bound(info$1[2], _ae_)[1 + _ae_] = pos$4;
        }
        return st$1;
       }
       if(caml_call2(Re_Import[2], info[1], break$0)){
        if(groups){
         var _af_ = info[2];
         caml_check_bound(info$1[2], _af_)[1 + _af_] = pos$4;
        }
        return st$1;
       }
       var
        color = caml_call1(Re_Cset[2], info$1[1][6]),
        cat = category(info$1[1], color),
        real_c = caml_call2(Re_Color_map[2][2], info$1[1][3], 10),
        desc = delta(info$1, cat, real_c, st$3[1]),
        st$2 = find_state(info$1[1], desc);
       set_transition(st$3, color, st$2);
      }
     }
    }
    if(groups){
     var
      positions$1 = info$0[2],
      colors = info$0[1][3],
      positions = positions$1,
      pos = pos$3,
      st0 = initial_state,
      st = initial_state;
     for(;;){
      if(pos >= last) return st;
      var
       st0$0 = next(colors, st, s, pos),
       state_info = st0$0[1],
       idx = state_info[1];
      if(0 <= idx){
       positions[1 + idx] = pos;
       var pos$0 = pos + 1 | 0, pos = pos$0, st0 = st0$0, st = st0$0;
      }
      else{
       if(caml_call2(Re_Import[2], idx, break$0)){
        positions[1 + state_info[2]] = pos;
        return st0$0;
       }
       validate(info$0, s, pos, st0);
       var positions$0 = info$0[2], positions = positions$0, st = st0;
      }
     }
    }
    else{
     var
      colors$0 = info$0[1][3],
      pos$1 = pos$3,
      st0$1 = initial_state,
      st$0 = initial_state;
     for(;;){
      if(pos$1 >= last) return st$0;
      var
       st0$2 = next(colors$0, st$0, s, pos$1),
       state_info$0 = st0$2[1],
       idx$0 = state_info$0[1];
      if(0 <= idx$0)
       var pos$2 = pos$1 + 1 | 0, pos$1 = pos$2, st0$1 = st0$2, st$0 = st0$2;
      else{
       if(caml_call2(Re_Import[2], idx$0, break$0)) return st0$2;
       validate(info$0, s, pos$1, st0$1);
       var st$0 = st0$1;
      }
     }
    }
   }
   function final_boundary_check(last, slen, re, s, info, st$0, groups){
    var
     _ac_ =
       caml_call2(Re_Import[2], last, slen)
        ? Re_Category[4]
        : category(re, get_color(re, s, last)),
     final_cat = caml_call2(Re_Category[1], Re_Category[9], _ac_),
     st$1 = st$0[1];
    try{
     var
      _ab_ = caml_call2(Stdlib_ListLabels[51], final_cat, st$1[3]),
      match = _ab_;
    }
    catch(_ad_){
     var _$_ = caml_wrap_exception(_ad_);
     if(_$_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_$_, 0);
     var
      st = delta(info, final_cat, caml_call1(Re_Cset[2], -1), st$1),
      _aa_ = caml_call1(Re_Automata[19][4], st),
      res = [0, caml_call1(Re_Automata[19][3], st), _aa_];
     st$1[3] = [0, [0, final_cat, res], st$1[3]];
     var match = res;
    }
    var res$0 = match[2], idx = match[1];
    a:
    if(groups && typeof res$0 !== "number"){
     caml_check_bound(info[2], idx)[1 + idx] = last;
     break a;
    }
    return res$0;
   }
   function match_str(groups, partial, re, s, pos, len){
    var
     slen = caml_ml_string_length(s),
     last = caml_call2(Re_Import[2], len, -1) ? slen : pos + len | 0;
    if(groups)
     var
      n = caml_call1(Re_Automata[20][2], re[7]) + 1 | 0,
      _V_ = 10 < n ? caml_make_vect(n, 0) : _a_.slice(),
      _W_ = _V_;
    else
     var _W_ = [0];
    var
     info = [0, re, _W_, pos, last],
     _X_ =
       caml_call2(Re_Import[2], pos, 0)
        ? Re_Category[4]
        : category(re, get_color(re, s, pos - 1 | 0)),
     initial_cat = caml_call2(Re_Category[1], Re_Category[9], _X_);
    try{
     var
      _U_ = caml_call2(Stdlib_ListLabels[51], initial_cat, re[2]),
      initial_state = _U_;
    }
    catch(___){
     var _T_ = caml_wrap_exception(___);
     if(_T_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_T_, 0);
     var
      st = find_state(re, caml_call2(Re_Automata[19][2], initial_cat, re[1]));
     re[2] = [0, [0, initial_cat, st], re[2]];
     var initial_state = st;
    }
    var st$0 = scan_str(info, s, initial_state, groups), state_info = st$0[1];
    a:
    {
     b:
     if(! caml_call2(Re_Import[2], state_info[1], break$0)){
      if(partial && ! groups) break b;
      if(partial && groups){
       var status = caml_call1(Re_Automata[19][4], state_info[4]);
       c:
       {
        if(typeof status === "number" && status){
         var
          status$0 =
            final_boundary_check(last, slen, re, s, info, st$0, groups),
          _Y_ = typeof status$0 === "number" ? 1 : status$0,
          _Z_ = _Y_;
         break c;
        }
        var _Z_ = status;
       }
       var match = _Z_;
       break a;
      }
      var match = final_boundary_check(last, slen, re, s, info, st$0, groups);
      break a;
     }
     var match = caml_call1(Re_Automata[19][4], state_info[4]);
    }
    if(typeof match !== "number"){
     var pmarks = match[2], marks = match[1];
     return [0, [0, s, marks, pmarks, info[2], re[10]]];
    }
    if(! match) return 0;
    var no_match_starts_before = groups ? caml_check_bound(info[2], 0)[1] : 0;
    return [1, no_match_starts_before];
   }
   function enforce_kind(ids, kind$0, kind, cr){
    if(typeof kind$0 === "number" && 332064784 === kind$0){
     if(typeof kind === "number" && 332064784 === kind) return cr;
     var _S_ = caml_call1(Re_Automata[11], ids);
     return caml_call4(Re_Automata[10], ids, kind, cr, _S_);
    }
    return cr;
   }
   function translate(ctx, ast){
    var ctx$0 = ctx, ast$0 = ast;
    for(;;){
     var
      colors = ctx$0[8],
      cache = ctx$0[7],
      names = ctx$0[6],
      pos = ctx$0[5],
      greedy = ctx$0[4],
      ign_group = ctx$0[3],
      kind = ctx$0[2],
      ids = ctx$0[1];
     if(typeof ast$0 === "number")
      switch(ast$0){
        case 0:
         var _l_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[7]);
         return [0, caml_call2(Re_Automata[17], ids, _l_), kind];
        case 1:
         var _m_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[7]);
         return [0, caml_call2(Re_Automata[16], ids, _m_), kind];
        case 2:
         var
          _n_ = caml_call2(Re_Automata[16], ids, Re_Category[5]),
          _o_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _p_ = caml_call2(Re_Automata[17], ids, _o_);
         return [0,
                 caml_call4(Re_Automata[10], ids, 332064784, _p_, _n_),
                 kind];
        case 3:
         var
          _q_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _r_ = caml_call2(Re_Automata[16], ids, _q_),
          _s_ = caml_call2(Re_Automata[17], ids, Re_Category[5]);
         return [0,
                 caml_call4(Re_Automata[10], ids, 332064784, _s_, _r_),
                 kind];
        case 4:
         var
          cat = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _t_ = caml_call2(Re_Automata[16], ids, cat),
          _u_ = caml_call2(Re_Automata[17], ids, cat),
          _v_ = [0, caml_call4(Re_Automata[10], ids, 332064784, _u_, _t_), 0],
          _w_ = caml_call2(Re_Automata[16], ids, Re_Category[5]),
          _x_ = caml_call2(Re_Automata[17], ids, Re_Category[5]),
          _y_ =
            [0, caml_call4(Re_Automata[10], ids, 332064784, _x_, _w_), _v_];
         return [0, caml_call2(Re_Automata[9], ids, _y_), kind];
        case 5:
         return [0, caml_call2(Re_Automata[17], ids, Re_Category[4]), kind];
        case 6:
         return [0, caml_call2(Re_Automata[16], ids, Re_Category[4]), kind];
        case 7:
         var _z_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[8]);
         return [0, caml_call2(Re_Automata[16], ids, _z_), kind];
        case 8:
         return [0, caml_call2(Re_Automata[17], ids, Re_Category[9]), kind];
        default:
         return [0, caml_call2(Re_Automata[16], ids, Re_Category[9]), kind];
      }
     switch(ast$0[0]){
       case 0:
        var s = ast$0[1], match = caml_call1(Re_Cset[41], s);
        if(match)
         var
          i = match[1],
          _i_ = caml_call2(Re_Color_map[2][1], colors, i),
          _A_ = caml_call1(Re_Cset[46], _i_);
        else{
         var v = [0, caml_call1(Re_Cset[43], s), s];
         try{var _k_ = caml_call2(Re_Cset[44][17], v, cache[1]), _A_ = _k_;}
         catch(_R_){
          var _j_ = caml_wrap_exception(_R_);
          if(_j_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_j_, 0);
          var l = caml_call2(Re_Color_map[2][3], colors, s);
          cache[1] = caml_call3(Re_Cset[44][2], v, l, cache[1]);
          var _A_ = l;
         }
        }
        return [0, caml_call2(Re_Automata[7], ids, _A_), kind];
       case 1:
        var l$0 = ast$0[1][1], merged_sequences = caml_call1(Re_Ast[2], l$0);
        if(merged_sequences && ! merged_sequences[2]){
         var
          r = merged_sequences[1],
          match$0 = translate(ctx$0, r),
          kind$0 = match$0[2],
          cr = match$0[1];
         return [0, enforce_kind(ids, kind, kind$0, cr), kind];
        }
        var
         _B_ =
           function(r){
            var match = translate(ctx$0, r), kind$0 = match[2], cr = match[1];
            return enforce_kind(ids, kind, kind$0, cr);
           },
         _C_ = caml_call2(Stdlib_ListLabels[20], _B_, merged_sequences);
        return [0, caml_call2(Re_Automata[9], ids, _C_), kind];
       case 2:
        var l$1 = ast$0[1]; return [0, trans_seq(ctx$0, l$1), kind];
       case 3:
        var
         j = ast$0[3],
         i$0 = ast$0[2],
         r$0 = ast$0[1],
         match$1 = translate(ctx$0, r$0),
         kind$1 = match$1[2],
         cr$0 = match$1[1];
        if(j)
         var
          j$0 = j[1],
          f =
            620821490 <= greedy
             ? function
              (rem){
               var
                _L_ = caml_call2(Re_Automata[18], ids, cr$0),
                _M_ =
                  [0, caml_call4(Re_Automata[10], ids, kind$1, _L_, rem), 0],
                _N_ = [0, caml_call1(Re_Automata[11], ids), _M_];
               return caml_call2(Re_Automata[9], ids, _N_);
              }
             : function
              (rem){
               var
                _O_ = [0, caml_call1(Re_Automata[11], ids), 0],
                _P_ = caml_call2(Re_Automata[18], ids, cr$0),
                _Q_ =
                  [0, caml_call4(Re_Automata[10], ids, kind$1, _P_, rem), _O_];
               return caml_call2(Re_Automata[9], ids, _Q_);
              },
          rem = iter(j$0 - i$0 | 0, f, caml_call1(Re_Automata[11], ids));
        else
         var rem = caml_call4(Re_Automata[12], ids, greedy, kind$1, cr$0);
        return [0,
                iter
                 (i$0,
                  function(rem){
                   var _K_ = caml_call2(Re_Automata[18], ids, cr$0);
                   return caml_call4(Re_Automata[10], ids, kind$1, _K_, rem);
                  },
                  rem),
                kind];
       case 4:
        var ast$1 = ast$0[2], n = ast$0[1];
        if(! ign_group){
         var p = pos[1];
         if(n){
          var name = n[1], _D_ = names[1];
          names[1] = [0, [0, name, caml_call1(Re_Automata[1][5], p)], _D_];
         }
         pos[1] = caml_call1(Re_Automata[1][4], pos[1]);
         var
          match$2 = translate(ctx$0, ast$1),
          kind$2 = match$2[2],
          cr$1 = match$2[1],
          _E_ = caml_call1(Re_Automata[1][3], p),
          _F_ = caml_call2(Re_Automata[13], ids, _E_),
          _G_ = caml_call4(Re_Automata[10], ids, 332064784, cr$1, _F_),
          _H_ = caml_call2(Re_Automata[13], ids, p);
         return [0,
                 caml_call4(Re_Automata[10], ids, 332064784, _H_, _G_),
                 kind$2];
        }
        var ast$0 = ast$1;
        break;
       case 5:
        var
         ast$2 = ast$0[1],
         ctx$1 =
           [0,
            ctx$0[1],
            ctx$0[2],
            1,
            ctx$0[4],
            ctx$0[5],
            ctx$0[6],
            ctx$0[7],
            ctx$0[8]],
         ctx$0 = ctx$1,
         ast$0 = ast$2;
        break;
       case 6:
        var
         r$1 = ast$0[1],
         b = pos[1],
         match$3 = translate(ctx$0, r$1),
         kind$3 = match$3[2],
         cr$2 = match$3[1],
         e = caml_call1(Re_Automata[1][2], pos[1]);
        if(e < b) return [0, cr$2, kind$3];
        var _I_ = caml_call3(Re_Automata[15], ids, b, e);
        return [0,
                caml_call4(Re_Automata[10], ids, 332064784, _I_, cr$2),
                kind$3];
       case 7:
        var
         r$2 = ast$0[2],
         i$1 = ast$0[1],
         match$4 = translate(ctx$0, r$2),
         kind$4 = match$4[2],
         cr$3 = match$4[1],
         _J_ = caml_call2(Re_Automata[14], ids, i$1);
        return [0,
                caml_call4(Re_Automata[10], ids, 332064784, _J_, cr$3),
                kind$4];
       case 8:
        var
         r$3 = ast$0[2],
         kind$5 = ast$0[1],
         match$5 =
           translate
            ([0,
              ctx$0[1],
              kind$5,
              ctx$0[3],
              ctx$0[4],
              ctx$0[5],
              ctx$0[6],
              ctx$0[7],
              ctx$0[8]],
             r$3),
         kind$6 = match$5[2],
         cr$4 = match$5[1];
        return [0, enforce_kind(ids, kind$5, kind$6, cr$4), kind$5];
       default:
        var
         ast$3 = ast$0[2],
         greedy$0 = ast$0[1],
         ctx$2 =
           [0,
            ctx$0[1],
            ctx$0[2],
            ctx$0[3],
            greedy$0,
            ctx$0[5],
            ctx$0[6],
            ctx$0[7],
            ctx$0[8]],
         ctx$0 = ctx$2,
         ast$0 = ast$3;
     }
    }
   }
   function trans_seq(ctx, param){
    var kind = ctx[2], ids = ctx[1];
    if(! param) return caml_call1(Re_Automata[11], ids);
    var r = param[1];
    if(param[2]){
     var
      rem = param[2],
      match = translate(ctx, r),
      kind$0 = match[2],
      cr = match[1],
      cr$0 = trans_seq(ctx, rem);
     return caml_call1(Re_Automata[4], cr$0)
             ? cr
             : caml_call1
                (Re_Automata[4], cr)
               ? cr$0
               : caml_call4(Re_Automata[10], ids, kind$0, cr, cr$0);
    }
    var match$0 = translate(ctx, r), kind$1 = match$0[2], cr$1 = match$0[1];
    return enforce_kind(ids, kind, kind$1, cr$1);
   }
   function compile(r$0){
    if(caml_call1(Re_Ast[4], r$0))
     var regexp$0 = caml_call2(Re_Ast[6][21], 0, r$0);
    else
     var
      _e_ = [0, caml_call2(Re_Ast[6][21], 0, r$0), 0],
      _f_ = caml_call1(Re_Ast[7], Re_Cset[45]),
      _g_ = caml_call1(Re_Ast[6][32], _f_),
      _h_ = [0, caml_call1(Re_Ast[6][35], _g_), _e_],
      regexp$0 = caml_call1(Re_Ast[6][36], _h_);
    var
     regexp = caml_call2(Re_Ast[3], 0, regexp$0),
     color_map = caml_call1(Re_Color_map[3], 0),
     need_lnl = caml_call2(Re_Ast[5], color_map, regexp),
     match = caml_call1(Re_Color_map[4], color_map),
     color_repr = match[2],
     colors = match[1],
     ncolor = caml_call1(Re_Color_map[1][2], color_repr),
     lnl = need_lnl ? ncolor : -1,
     ncolor$0 = need_lnl ? ncolor + 1 | 0 : ncolor,
     _c_ = [0, Re_Cset[44][1]],
     _d_ = [0, Re_Automata[1][1]],
     ctx =
       [0,
        caml_call1(Re_Automata[6][1], 0),
        332064784,
        0,
        -904640576,
        _d_,
        [0, 0],
        _c_,
        colors],
     match$0 = translate(ctx, regexp),
     kind = match$0[2],
     r = match$0[1],
     initial = enforce_kind(ctx[1], 332064784, kind, r),
     group_count = caml_call1(Re_Automata[1][5], ctx[5][1]),
     group_names = caml_call1(Stdlib_ListLabels[10], ctx[6][1]),
     _b_ = caml_call1(Re_Automata[19][5][1], 97);
    return [0,
            initial,
            0,
            colors,
            color_repr,
            ncolor$0,
            lnl,
            caml_call1(Re_Automata[20][1], 0),
            _b_,
            group_names,
            group_count];
   }
   var
    Re_Compile =
      [0, match_str, compile, group_count, group_names, pp_re, pp_re];
   runtime.caml_register_global(12, Re_Compile, "Re__Compile");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Search
//# unitInfo: Requires: Re__Compile, Re__Group, Stdlib, Stdlib__Seq, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Re_all$1 = "Re.all",
    cst_Re_split$1 = "Re.split",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Assert_failure = global_data.Assert_failure,
    Re_Compile = global_data.Re__Compile,
    Stdlib_String = global_data.Stdlib__String,
    Re_Group = global_data.Re__Group,
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    _a_ = [0, "lib/search.ml", 55, 6],
    cst_Re_split = cst_Re_split$1,
    cst_Re_split$0 = cst_Re_split$1,
    cst_Re_all = cst_Re_all$1,
    cst_Re_all$0 = cst_Re_all$1;
   function all(opt, len, re, s){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_all);
    if(len){
     var
      l = len[1],
      _s_ = l < 0 ? 1 : 0,
      _t_ = _s_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_t_) caml_call1(Stdlib[1], cst_Re_all$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    function aux(pos, on_match, param){
     var pos$0 = pos, on_match$0 = on_match;
     for(;;){
      if(limit < pos$0) return 0;
      var
       match =
         caml_call6(Re_Compile[1], 1, 0, re, s, pos$0, limit - pos$0 | 0);
      if(typeof match !== "number" && 0 === match[0]){
       var
        substr = match[1],
        match$0 = caml_call2(Re_Group[3], substr, 0),
        p2 = match$0[2],
        p1 = match$0[1];
       if(on_match$0 && p1 === pos$0 && p1 === p2){
        var pos$1 = pos$0 + 1 | 0, pos$0 = pos$1, on_match$0 = 0;
        continue;
       }
       var pos$2 = p1 === p2 ? p2 + 1 | 0 : p2, _w_ = p1 !== p2 ? 1 : 0;
       return [0, substr, function(_x_){return aux(pos$2, _w_, _x_);}];
      }
      return 0;
     }
    }
    var _u_ = 0;
    return function(_v_){return aux(pos, _u_, _v_);};
   }
   function matches(pos, len, re, s){
    var _q_ = all(pos, len, re, s);
    function _r_(sub){return caml_call2(Re_Group[1], sub, 0);}
    return caml_call1(caml_call1(Stdlib_Seq[29], _r_), _q_);
   }
   function split_full(opt, len, re, s){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_split);
    if(len){
     var
      l = len[1],
      _h_ = l < 0 ? 1 : 0,
      _i_ = _h_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_i_) caml_call1(Stdlib[1], cst_Re_split$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    function aux(state, i, pos$0, param){
     var old_i = i, pos$1 = pos$0;
     for(;;){
      if(typeof state !== "number"){
       var x = state[2], _l_ = 814535476;
       return [0, x, function(_p_){return aux(_l_, old_i, pos$1, _p_);}];
      }
      if(limit < pos$1){
       if(old_i === limit) return 0;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      }
      var
       match =
         caml_call6(Re_Compile[1], 1, 0, re, s, pos$1, limit - pos$1 | 0);
      if(typeof match === "number"){
       if(old_i >= limit) return 0;
       var text = caml_call3(Stdlib_String[16], s, old_i, limit - old_i | 0);
       return [0,
               [0, 936573133, text],
               function(_o_){return aux(state, limit, pos$1, _o_);}];
      }
      if(0 !== match[0]) return 0;
      var
       substr = match[1],
       match$0 = caml_call2(Re_Group[3], substr, 0),
       p2 = match$0[2],
       p1 = match$0[1],
       pos$2 = p1 === p2 ? p2 + 1 | 0 : p2;
      if(old_i === p1 && p1 === p2 && pos < p1){var old_i = p2, pos$1 = pos$2; continue;
      }
      if(pos >= p1)
       return [0,
               [0, -363573681, substr],
               function(_n_){return aux(state, p2, pos$2, _n_);}];
      var
       text$0 = caml_call3(Stdlib_String[16], s, old_i, p1 - old_i | 0),
       state$0 = [0, 73271853, [0, -363573681, substr]];
      return [0,
              [0, 936573133, text$0],
              function(_m_){return aux(state$0, p2, pos$2, _m_);}];
     }
    }
    var _j_ = 814535476;
    return function(_k_){return aux(_j_, pos, pos, _k_);};
   }
   function split(pos, len, re, s){
    var seq = split_full(pos, len, re, s);
    function filter(seq, param){
     var seq$0 = seq;
     for(;;){
      var match = caml_call1(seq$0, 0);
      if(! match) return 0;
      var match$0 = match[1];
      if(936573133 <= match$0[1]){
       var tl = match[2], s = match$0[2];
       return [0, s, function(_g_){return filter(tl, _g_);}];
      }
      var seq$1 = match[2], seq$0 = seq$1;
     }
    }
    return function(_f_){return filter(seq, _f_);};
   }
   function split_delim(pos, len, re, s){
    var seq = split_full(pos, len, re, s);
    function filter(delim, seq, param){
     var delim$0 = delim, seq$0 = seq;
     for(;;){
      var match = caml_call1(seq$0, 0);
      if(! match) return delim$0 ? [0, cst$0, function(param){return 0;}] : 0;
      var match$0 = match[1];
      if(936573133 <= match$0[1]){
       var tl = match[2], s = match$0[2], _d_ = 0;
       return [0, s, function(_e_){return filter(_d_, tl, _e_);}];
      }
      var seq$1 = match[2];
      if(delim$0)
       return [0, cst, function(param){return filter(1, seq$1, 0);}];
      var delim$0 = 1, seq$0 = seq$1;
     }
    }
    var _b_ = 1;
    return function(_c_){return filter(_b_, seq, _c_);};
   }
   var Re_Search = [0, all, matches, split_full, split, split_delim];
   runtime.caml_register_global(13, Re_Search, "Re__Search");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Core
//# unitInfo: Requires: Re__Ast, Re__Compile, Re__Cset, Re__Group, Re__Pmark, Re__Search, Stdlib, Stdlib__ListLabels, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Search = global_data.Re__Search,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Re_Pmark = global_data.Re__Pmark,
    Stdlib = global_data.Stdlib,
    Re_Compile = global_data.Re__Compile,
    Re_Cset = global_data.Re__Cset,
    Re_Ast = global_data.Re__Ast,
    Re_Group = global_data.Re__Group,
    cset = Re_Ast[7];
   function char$0(c){return caml_call1(cset, caml_call1(Re_Cset[46], c));}
   function rg(c$0, c){
    return caml_call1(cset, caml_call2(Re_Cset[25], c$0, c));
   }
   var
    any = caml_call1(cset, Re_Cset[45]),
    notnl = caml_call1(cset, Re_Cset[22]),
    lower = caml_call1(cset, Re_Cset[30]),
    upper = caml_call1(cset, Re_Cset[31]),
    alpha = caml_call1(cset, Re_Cset[32]),
    digit = caml_call1(cset, Re_Cset[19]),
    alnum = caml_call1(cset, Re_Cset[33]),
    wordc = caml_call1(cset, Re_Cset[34]),
    ascii = caml_call1(cset, Re_Cset[23]),
    blank = caml_call1(cset, Re_Cset[27]),
    cntrl = caml_call1(cset, Re_Cset[35]),
    graph = caml_call1(cset, Re_Cset[36]),
    print = caml_call1(cset, Re_Cset[37]),
    punct = caml_call1(cset, Re_Cset[38]),
    space = caml_call1(cset, Re_Cset[28]),
    xdigit = caml_call1(cset, Re_Cset[29]),
    include = Re_Ast[6],
    empty = include[1],
    epsilon = include[2],
    str = include[3],
    no_case = include[4],
    case$0 = include[5],
    diff = include[6],
    compl = include[7],
    repn = include[8],
    inter = include[9],
    set = include[10],
    mark = include[11],
    nest = include[12],
    no_group = include[13],
    whole_string = include[14],
    leol = include[15],
    longest = include[16],
    greedy = include[17],
    non_greedy = include[18],
    stop = include[19],
    not_boundary = include[20],
    group = include[21],
    word = include[22],
    first = include[23],
    bos = include[24],
    bow = include[25],
    eow = include[26],
    eos = include[27],
    bol = include[28],
    start = include[29],
    eol = include[30],
    opt = include[31],
    rep = include[32],
    rep1 = include[33],
    alt = include[34],
    shortest = include[35],
    seq = include[36],
    pp = include[37],
    witness = include[38];
   function exec_internal(opt, _d_, partial, groups, re, s){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(_d_) var sth$0 = _d_[1], len = sth$0; else var len = -1;
    return caml_call6(Re_Compile[1], groups, partial, re, s, pos, len);
   }
   function exec(pos, len, re, s){
    var match = exec_internal(pos, len, 0, 1, re, s);
    if(typeof match !== "number" && 0 === match[0]){var substr = match[1]; return substr;}
    throw caml_maybe_attach_backtrace(Stdlib[8], 1);
   }
   function exec_opt(pos, len, re, s){
    var match = exec_internal(pos, len, 0, 1, re, s);
    if(typeof match !== "number" && 0 === match[0]){var substr = match[1]; return [0, substr];}
    return 0;
   }
   function execp(pos, len, re, s){
    var match = exec_internal(pos, len, 0, 0, re, s);
    if(typeof match !== "number" && 0 === match[0]) return 1;
    return 0;
   }
   function exec_partial(pos, len, re, s){
    var match = exec_internal(pos, len, 1, 0, re, s);
    return typeof match === "number"
            ? -1062743954
            : 0 === match[0] ? 782112175 : 939392865;
   }
   function exec_partial_detailed(pos, len, re, s){
    var match = exec_internal(pos, len, 1, 1, re, s);
    if(typeof match === "number") return -1062743954;
    if(0 === match[0]){var group = match[1]; return [0, 782112175, group];}
    var no_match_starts_before = match[1];
    return [0, 939392865, no_match_starts_before];
   }
   function marked(g, p){return caml_call2(Re_Pmark[5][31], p, g[3]);}
   function mark_set(g){return g[3];}
   var equal = Re_Pmark[1], compare = Re_Pmark[2];
   function gen_of_seq(s){
    var r = [0, s];
    return function(param){
     var match = caml_call1(r[1], 0);
     if(! match) return 0;
     var tl = match[2], x = match[1];
     r[1] = tl;
     return [0, x];};
   }
   function split_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[4], pos, len, re, s));
   }
   function split_full_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[3], pos, len, re, s));
   }
   function all_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[1], pos, len, re, s));
   }
   function matches_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[2], pos, len, re, s));
   }
   var
    split_full_seq = Re_Search[3],
    split_seq = Re_Search[4],
    matches_seq = Re_Search[2],
    all_seq = Re_Search[1],
    get = Re_Group[1],
    get_ofs = Re_Group[3],
    get_all = Re_Group[6],
    get_all_ofs = Re_Group[7],
    test = Re_Group[8];
   function list_of_seq(s){
    var _a_ = 0;
    function _b_(l, x){return [0, x, l];}
    var _c_ = caml_call3(Stdlib_Seq[5], _b_, _a_, s);
    return caml_call1(Stdlib_ListLabels[10], _c_);
   }
   function all(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[1], pos, len, re, s));
   }
   function matches(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[2], pos, len, re, s));
   }
   function split_full(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[3], pos, len, re, s));
   }
   function split(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[4], pos, len, re, s));
   }
   function split_delim(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[5], pos, len, re, s));
   }
   var
    compile = Re_Compile[2],
    pp_re = Re_Compile[6],
    print_re = Re_Compile[5],
    group_names = Re_Compile[4],
    group_count = Re_Compile[3],
    Re_Core =
      [0,
       Re_Group,
       compile,
       group_count,
       group_names,
       exec,
       exec_opt,
       execp,
       exec_partial,
       exec_partial_detailed,
       [0, marked, Re_Pmark[5], mark_set, equal, compare],
       all,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split,
       split_delim,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       [0,
        Re_Search[1],
        Re_Search[2],
        Re_Search[4],
        Re_Search[5],
        Re_Search[3]],
       str,
       char$0,
       alt,
       seq,
       empty,
       epsilon,
       rep,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start,
       stop,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark,
       set,
       rg,
       inter,
       diff,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp,
       pp_re,
       print_re,
       witness,
       get,
       get_ofs,
       get_all,
       get_all_ofs,
       test,
       marked,
       mark_set];
   runtime.caml_register_global(9, Re_Core, "Re__Core");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Parse_buffer
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Parse_error =
      [248, "Re__Parse_buffer.Parse_error", runtime.caml_fresh_oo_id(0)];
   function create(str){return [0, str, 0];}
   function unget(t){t[2] = t[2] - 1 | 0; return 0;}
   function junk(t){t[2] = t[2] + 1 | 0; return 0;}
   function eos(t){return t[2] === caml_ml_string_length(t[1]) ? 1 : 0;}
   function test(t, c){
    var
     _l_ = 1 - eos(t),
     _m_ = _l_ ? caml_string_get(t[1], t[2]) === c ? 1 : 0 : _l_;
    return _m_;
   }
   function test2(t, c$0, c){
    var _i_ = (t[2] + 1 | 0) < caml_ml_string_length(t[1]) ? 1 : 0;
    if(_i_)
     var
      _j_ = caml_string_get(t[1], t[2]) === c$0 ? 1 : 0,
      _k_ = _j_ ? caml_string_get(t[1], t[2] + 1 | 0) === c ? 1 : 0 : _j_;
    else
     var _k_ = _i_;
    return _k_;
   }
   function accept(t, c){
    var r = test(t, c);
    if(r) t[2] = t[2] + 1 | 0;
    return r;
   }
   function accept2(t, c$0, c){
    var r = test2(t, c$0, c);
    if(r) t[2] = t[2] + 2 | 0;
    return r;
   }
   function get(t){
    var r = caml_string_get(t[1], t[2]);
    t[2] = t[2] + 1 | 0;
    return r;
   }
   function accept_s(t, s){
    var len = caml_ml_string_length(s);
    try{
     var _c_ = len - 1 | 0, _b_ = 0;
     if(_c_ >= 0){
      var j = _b_;
      for(;;){
       try{
        var _e_ = caml_string_get(t[1], t[2] + j | 0);
        if(caml_string_get(s, j) !== _e_) throw Stdlib[3];
       }
       catch(_h_){throw Stdlib[3];}
       var _f_ = j + 1 | 0;
       if(_c_ === j) break;
       var j = _f_;
      }
     }
     t[2] = t[2] + len | 0;
     var _d_ = 1;
     return _d_;
    }
    catch(_g_){
     var _a_ = caml_wrap_exception(_g_);
     if(_a_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   function integer(t){
    if(eos(t)) return 0;
    var d$0 = get(t);
    if(9 < d$0 - 48 >>> 0){unget(t); return 0;}
    var i$1 = d$0 - 48 | 0, i = i$1;
    for(;;){
     if(eos(t)) return [0, i];
     var d = get(t);
     if(9 < d - 48 >>> 0){unget(t); return [0, i];}
     var i$0 = (10 * i | 0) + (d - 48 | 0) | 0;
     if(i$0 < i) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var i = i$0;
    }
   }
   var
    Re_Parse_buffer =
      [0,
       Parse_error,
       create,
       junk,
       unget,
       eos,
       test,
       test2,
       get,
       accept,
       accept2,
       accept_s,
       integer];
   runtime.caml_register_global(2, Re_Parse_buffer, "Re__Parse_buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Emacs
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Parse_error = [248, "Re__Emacs.Parse_error", caml_fresh_oo_id(0)],
    Not_supported = [248, "Re__Emacs.Not_supported", caml_fresh_oo_id(0)];
   function re(opt, s){
    if(opt) var sth = opt[1], case$0 = sth; else var case$0 = 1;
    var
     buf = caml_call1(Re_Parse_buffer[2], s),
     accept = caml_call1(Re_Parse_buffer[9], buf),
     accept2 = caml_call1(Re_Parse_buffer[10], buf);
    function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
    var test2 = caml_call1(Re_Parse_buffer[7], buf);
    function get(param){return caml_call1(Re_Parse_buffer[8], buf);}
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! caml_call2(accept2, 92, 124)) return left$0;
      var
       _h_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[27], _h_),
       left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if
       (!
        eos(0)
        && ! caml_call2(test2, 92, 124) && ! caml_call2(test2, 92, 41)){
       a:
       if(caml_call1(accept, 46))
        var r = Re_Core[62];
       else if(caml_call1(accept, 94))
        var r = Re_Core[35];
       else if(caml_call1(accept, 36))
        var r = Re_Core[36];
       else if(caml_call1(accept, 91))
        if(caml_call1(accept, 94))
         var _d_ = bracket(0), r = caml_call1(Re_Core[60], _d_);
        else
         var _e_ = bracket(0), r = caml_call1(Re_Core[27], _e_);
       else{
        if(! caml_call1(accept, 92)){
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c$0 = get(0);
         b:
         {
          if(44 <= c$0){if(63 === c$0) break b;} else if(42 <= c$0) break b;
          var r = caml_call1(Re_Core[26], c$0);
          break a;
         }
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
        if(caml_call1(accept, 40)){
         var r$0 = regexp(0);
         if(1 - caml_call2(accept2, 92, 41))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         var r = caml_call2(Re_Core[52], 0, r$0);
        }
        else if(caml_call1(accept, 96))
         var r = Re_Core[39];
        else if(caml_call1(accept, 39))
         var r = Re_Core[40];
        else if(caml_call1(accept, 61))
         var r = Re_Core[42];
        else if(caml_call1(accept, 98))
         var
          r = caml_call1(Re_Core[27], [0, Re_Core[37], [0, Re_Core[38], 0]]);
        else if(caml_call1(accept, 66))
         var r = Re_Core[45];
        else if(caml_call1(accept, 60))
         var r = Re_Core[37];
        else if(caml_call1(accept, 62))
         var r = Re_Core[38];
        else if(caml_call1(accept, 119))
         var
          _f_ = [0, caml_call1(Re_Core[26], 95), 0],
          r = caml_call1(Re_Core[27], [0, Re_Core[63], _f_]);
        else if(caml_call1(accept, 87))
         var
          _g_ = [0, caml_call1(Re_Core[26], 95), 0],
          r = caml_call1(Re_Core[60], [0, Re_Core[63], _g_]);
        else{
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c = get(0);
         b:
         {
          if(63 <= c){
           if(91 <= c){if(95 > c) break b;} else if(64 > c) break b;
          }
          else
           if(48 <= c){
            if(58 > c) throw caml_maybe_attach_backtrace(Not_supported, 1);
           }
           else if(36 <= c)
            switch(c - 36 | 0){case 0:case 6:case 7:case 10: break b;}
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var r = caml_call1(Re_Core[26], c);
        }
       }
       var
        _c_ =
          caml_call1(accept, 42)
           ? caml_call1(Re_Core[31], r)
           : caml_call1
              (accept, 43)
             ? caml_call1(Re_Core[32], r)
             : caml_call1(accept, 63) ? caml_call1(Re_Core[34], r) : r,
        left$0 = [0, _c_, left],
        left = left$0;
       continue;
      }
      var _b_ = caml_call1(Stdlib_List[10], left);
      return caml_call1(Re_Core[28], _b_);
     }
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && caml_call1(accept, 93)) return s$0;
      var c = char$0(0);
      if(caml_call1(accept, 45)){
       if(caml_call1(accept, 93)){
        var _a_ = [0, caml_call1(Re_Core[26], 45), s$0];
        return [0, caml_call1(Re_Core[26], c), _a_];
       }
       var
        c$0 = char$0(0),
        s$1 = [0, caml_call2(Re_Core[57], c, c$0), s$0],
        s$0 = s$1;
      }
      else
       var s$2 = [0, caml_call1(Re_Core[26], c), s$0], s$0 = s$2;
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     return get(0);
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    return case$0 ? res : caml_call1(Re_Core[78], res);
   }
   var compile = Re_Core[2];
   function compile_pat(opt, s){
    if(opt) var sth = opt[1], case$0 = sth; else var case$0 = 1;
    return caml_call1(compile, re([0, case$0], s));
   }
   var Re_Emacs = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(5, Re_Emacs, "Re__Emacs");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Str
//# unitInfo: Requires: CamlinternalLazy, Re__Core, Re__Emacs, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Re_Core = global_data.Re__Core,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Re_Emacs = global_data.Re__Emacs,
    cst_Str_replace_illegal_backsl = "Str.replace: illegal backslash sequence",
    cst_Str_group_end = "Str.group_end",
    cst_Str_group_beginning = "Str.group_beginning";
   function compile_regexp(s, c){
    var
     re = caml_call2(Re_Emacs[3], [0, 1 - c], s),
     _ah_ = [246, function(_aj_){return caml_call1(Re_Core[2], re);}];
    return [0,
            re,
            [246,
             function(param){
              var
               _ai_ = caml_call1(Re_Core[28], [0, Re_Core[42], [0, re, 0]]);
              return caml_call1(Re_Core[2], _ai_);
             }],
            _ah_];
   }
   var state = [0, 0];
   function string_match(re, s, p){
    try{
     var _ac_ = re[2], _ad_ = caml_obj_tag(_ac_);
     a:
     if(250 === _ad_)
      var _ae_ = _ac_[1];
     else{
      if(246 !== _ad_ && 244 !== _ad_){var _ae_ = _ac_; break a;}
      var _ae_ = caml_call1(CamlinternalLazy[2], _ac_);
     }
     state[1] = [0, caml_call4(Re_Core[5], [0, p], 0, _ae_, s)];
     var _af_ = 1;
     return _af_;
    }
    catch(_ag_){
     var _ab_ = caml_wrap_exception(_ag_);
     if(_ab_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ab_, 0);
     state[1] = 0;
     return 0;
    }
   }
   function string_partial_match(re, s, p){
    var ___ = re[2], _$_ = caml_obj_tag(___);
    a:
    if(250 === _$_)
     var _aa_ = ___[1];
    else{
     if(246 !== _$_ && 244 !== _$_){var _aa_ = ___; break a;}
     var _aa_ = caml_call1(CamlinternalLazy[2], ___);
    }
    var match = caml_call4(Re_Core[8], [0, p], 0, _aa_, s);
    return 782112175 === match
            ? string_match(re, s, p)
            : 939392865 <= match ? 1 : 0;
   }
   function search_forward(re, s, p){
    try{
     var _V_ = re[3], _W_ = caml_obj_tag(_V_);
     a:
     if(250 === _W_)
      var _X_ = _V_[1];
     else{
      if(246 !== _W_ && 244 !== _W_){var _X_ = _V_; break a;}
      var _X_ = caml_call1(CamlinternalLazy[2], _V_);
     }
     var res = caml_call4(Re_Core[5], [0, p], 0, _X_, s);
     state[1] = [0, res];
     var _Y_ = caml_call2(Re_Core[1][3], res, 0)[1];
     return _Y_;
    }
    catch(_Z_){
     var _U_ = caml_wrap_exception(_Z_);
     if(_U_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_U_, 0);
     state[1] = 0;
     throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    }
   }
   function search_backward(re, s, p){
    var p$0 = p;
    for(;;)
     try{
      var _Q_ = re[2], _R_ = caml_obj_tag(_Q_);
      a:
      if(250 === _R_)
       var _S_ = _Q_[1];
      else{
       if(246 !== _R_ && 244 !== _R_){var _S_ = _Q_; break a;}
       var _S_ = caml_call1(CamlinternalLazy[2], _Q_);
      }
      var res = caml_call4(Re_Core[5], [0, p$0], 0, _S_, s);
      state[1] = [0, res];
      return p$0;
     }
     catch(_T_){
      var _P_ = caml_wrap_exception(_T_);
      if(_P_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_P_, 0);
      state[1] = 0;
      if(0 === p$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var p$1 = p$0 - 1 | 0, p$0 = p$1;
     }
   }
   function valid_group(n){
    var _M_ = 0 <= n ? 1 : 0;
    if(_M_){
     var _N_ = n < 10 ? 1 : 0;
     if(_N_){
      var match = state[1];
      if(match){
       var m = match[1];
       return n < caml_call1(Re_Core[1][9], m) ? 1 : 0;
      }
      var _O_ = 0;
     }
     else
      var _O_ = _N_;
    }
    else
     var _O_ = _M_;
    return _O_;
   }
   function offset_group(i){
    var match = state[1];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var m = match[1];
    return caml_call2(Re_Core[1][3], m, i);
   }
   function replacement_text(repl, orig){
    var len = caml_ml_string_length(repl), p = 0, q = 0;
    for(;;){
     if(p >= len) break;
     if(92 === caml_string_get(repl, p)){
      var p$0 = p + 1 | 0;
      if(p$0 === len) caml_call1(Stdlib[2], cst_Str_replace_illegal_backsl);
      var c = caml_string_get(repl, p$0);
      a:
      {
       if(58 <= c){
        if(92 === c){var q$0 = q + 1 | 0; break a;}
       }
       else if(48 <= c){
        var i = c - 48 | 0;
        try{
         var
          match = offset_group(i),
          e = match[2],
          b = match[1],
          _H_ = e - b | 0,
          _I_ = _H_;
        }
        catch(_L_){
         var _G_ = caml_wrap_exception(_L_);
         if(_G_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_G_, 0);
         var _I_ = 0;
        }
        var q$0 = q + _I_ | 0;
        break a;
       }
       var q$0 = q + 2 | 0;
      }
      var p$1 = p$0 + 1 | 0, p = p$1, q = q$0;
     }
     else
      var q$1 = q + 1 | 0, p$2 = p + 1 | 0, p = p$2, q = q$1;
    }
    var
     res = runtime.caml_create_bytes(q),
     len$0 = caml_ml_string_length(repl),
     p$3 = 0,
     q$2 = 0;
    for(;;){
     if(p$3 >= len$0) return caml_call1(Stdlib_Bytes[44], res);
     var c$0 = caml_string_get(repl, p$3);
     if(92 === c$0){
      var c$1 = caml_string_get(repl, p$3 + 1 | 0);
      if(58 <= c$1){
       if(92 === c$1){
        caml_bytes_set(res, q$2, 92);
        var q$3 = q$2 + 1 | 0, p$4 = p$3 + 2 | 0, p$3 = p$4, q$2 = q$3;
        continue;
       }
      }
      else if(48 <= c$1){
       try{
        var
         match$0 = offset_group(c$1 - 48 | 0),
         e$0 = match$0[2],
         b$0 = match$0[1],
         d$0 = e$0 - b$0 | 0;
        if(0 < d$0) caml_call5(Stdlib_String[6], orig, b$0, res, q$2, d$0);
        var d = d$0;
       }
       catch(_K_){
        var _J_ = caml_wrap_exception(_K_);
        if(_J_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_J_, 0);
        var d = 0;
       }
       var q$5 = q$2 + d | 0, p$6 = p$3 + 2 | 0, p$3 = p$6, q$2 = q$5;
       continue;
      }
      caml_bytes_set(res, q$2, 92);
      caml_bytes_set(res, q$2 + 1 | 0, c$1);
      var q$4 = q$2 + 2 | 0, p$5 = p$3 + 2 | 0, p$3 = p$5, q$2 = q$4;
     }
     else{
      caml_bytes_set(res, q$2, c$0);
      var q$6 = q$2 + 1 | 0, p$7 = p$3 + 1 | 0, p$3 = p$7, q$2 = q$6;
     }
    }
   }
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_call1(Stdlib_Buffer[1], 2 * len | 0),
     _C_ = len - 1 | 0,
     _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var c = caml_string_get(s, i), _D_ = c - 63 | 0;
      a:
      {
       b:
       {
        if(31 < _D_ >>> 0){
         var _E_ = _D_ + 27 | 0;
         if(10 < _E_ >>> 0) break b;
         switch(_E_){case 0:case 6:case 7:case 10: break;default: break b;
         }
        }
        else if(26 >= _D_ - 1 >>> 0) break b;
        caml_call2(Stdlib_Buffer[12], buf, 92);
        caml_call2(Stdlib_Buffer[12], buf, c);
        break a;
       }
       caml_call2(Stdlib_Buffer[12], buf, c);
      }
      var _F_ = i + 1 | 0;
      if(_C_ === i) break;
      var i = _F_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function string_before(s, n){
    return caml_call3(Stdlib_String[16], s, 0, n);
   }
   function string_after(s, n){
    return caml_call3
            (Stdlib_String[16], s, n, caml_ml_string_length(s) - n | 0);
   }
   function first_chars(s, n){return caml_call3(Stdlib_String[16], s, 0, n);}
   function last_chars(s, n){
    return caml_call3
            (Stdlib_String[16], s, caml_ml_string_length(s) - n | 0, n);
   }
   function regexp(e){return compile_regexp(e, 0);}
   function regexp_case_fold(e){return compile_regexp(e, 1);}
   function regexp_string(s){return compile_regexp(quote(s), 0);}
   function regexp_string_case_fold(s){return compile_regexp(quote(s), 1);}
   function group_beginning(n){
    if(1 - valid_group(n)) caml_call1(Stdlib[1], cst_Str_group_beginning);
    var pos = offset_group(n)[1];
    if(-1 === pos) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    return pos;
   }
   function group_end(n){
    if(1 - valid_group(n)) caml_call1(Stdlib[1], cst_Str_group_end);
    var pos = offset_group(n)[2];
    if(-1 === pos) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    return pos;
   }
   function matched_group(n, txt){
    var match = offset_group(n), e = match[2], b = match[1];
    return caml_call3(Stdlib_String[16], txt, b, e - b | 0);
   }
   function replace_matched(repl, matched){
    return replacement_text(repl, matched);
   }
   function match_beginning(param){return group_beginning(0);}
   function match_end(param){return group_end(0);}
   function matched_string(txt){return matched_group(0, txt);}
   function substitute_first(expr, repl_fun, text){
    try{
     var
      pos = search_forward(expr, text, 0),
      _w_ = [0, string_after(text, match_end(0)), 0],
      _x_ = [0, caml_call1(repl_fun, text), _w_],
      _y_ = [0, string_before(text, pos), _x_],
      _z_ = caml_call2(Stdlib_String[7], cst, _y_);
     return _z_;
    }
    catch(_A_){
     var _v_ = caml_wrap_exception(_A_);
     if(_v_ === Stdlib[8]) return text;
     throw caml_maybe_attach_backtrace(_v_, 0);
    }
   }
   function global_substitute(expr, repl_fun, text){
    var accu = 0, start = 0, last_was_empty = 0;
    for(;;){
     var startpos = last_was_empty ? start + 1 | 0 : start;
     a:
     {
      if(caml_ml_string_length(text) >= startpos){
       try{var pos = search_forward(expr, text, startpos);}
       catch(_u_){
        var _r_ = caml_wrap_exception(_u_);
        if(_r_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_r_, 0);
        var _s_ = [0, string_after(text, start), accu];
        break a;
       }
       var
        end_pos = match_end(0),
        repl_text = caml_call1(repl_fun, text),
        last_was_empty$0 = end_pos === pos ? 1 : 0,
        accu$0 =
          [0,
           repl_text,
           [0,
            caml_call3(Stdlib_String[16], text, start, pos - start | 0),
            accu]],
        accu = accu$0,
        start = end_pos,
        last_was_empty = last_was_empty$0;
       continue;
      }
      var _s_ = [0, string_after(text, start), accu];
     }
     var _t_ = caml_call1(Stdlib_List[10], _s_);
     return caml_call2(Stdlib_String[7], cst$0, _t_);
    }
   }
   function global_replace(expr, repl, text){
    return global_substitute
            (expr, function(_q_){return replacement_text(repl, _q_);}, text);
   }
   function replace_first(expr, repl, text){
    return substitute_first
            (expr, function(_p_){return replacement_text(repl, _p_);}, text);
   }
   function search_forward_progress(re, s, p){
    var pos = search_forward(re, s, p);
    if(p < match_end(0)) return pos;
    if(p < caml_ml_string_length(s)) return search_forward(re, s, p + 1 | 0);
    throw caml_maybe_attach_backtrace(Stdlib[8], 1);
   }
   function bounded_split(expr, text, num){
    var start = string_match(expr, text, 0) ? match_end(0) : 0;
    function split(accu, start, n){
     if(caml_ml_string_length(text) <= start) return accu;
     if(1 === n) return [0, string_after(text, start), accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       _m_ = match_end(0),
       _n_ =
         split
          ([0,
            caml_call3(Stdlib_String[16], text, start, pos - start | 0),
            accu],
           _m_,
           n - 1 | 0);
      return _n_;
     }
     catch(_o_){
      var _l_ = caml_wrap_exception(_o_);
      if(_l_ === Stdlib[8]) return [0, string_after(text, start), accu];
      throw caml_maybe_attach_backtrace(_l_, 0);
     }
    }
    var _k_ = split(0, start, num);
    return caml_call1(Stdlib_List[10], _k_);
   }
   function split(expr, text){return bounded_split(expr, text, 0);}
   function bounded_split_delim(expr, text, num){
    function split(accu, start, n){
     if(caml_ml_string_length(text) < start) return accu;
     if(1 === n) return [0, string_after(text, start), accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       _h_ = match_end(0),
       _i_ =
         split
          ([0,
            caml_call3(Stdlib_String[16], text, start, pos - start | 0),
            accu],
           _h_,
           n - 1 | 0);
      return _i_;
     }
     catch(_j_){
      var _g_ = caml_wrap_exception(_j_);
      if(_g_ === Stdlib[8]) return [0, string_after(text, start), accu];
      throw caml_maybe_attach_backtrace(_g_, 0);
     }
    }
    if(runtime.caml_string_equal(text, cst$1)) return 0;
    var _f_ = split(0, 0, num);
    return caml_call1(Stdlib_List[10], _f_);
   }
   function split_delim(expr, text){
    return bounded_split_delim(expr, text, 0);
   }
   function bounded_full_split(expr, text, num){
    function split(accu, start, n){
     if(caml_ml_string_length(text) <= start) return accu;
     if(1 === n) return [0, [0, string_after(text, start)], accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       s = matched_string(text);
      if(start < pos)
       var
        _c_ = match_end(0),
        _d_ =
          split
           ([0,
             [1, s],
             [0,
              [0, caml_call3(Stdlib_String[16], text, start, pos - start | 0)],
              accu]],
            _c_,
            n - 1 | 0);
      else
       var _d_ = split([0, [1, s], accu], match_end(0), n - 1 | 0);
      return _d_;
     }
     catch(_e_){
      var _b_ = caml_wrap_exception(_e_);
      if(_b_ === Stdlib[8]) return [0, [0, string_after(text, start)], accu];
      throw caml_maybe_attach_backtrace(_b_, 0);
     }
    }
    var _a_ = split(0, 0, num);
    return caml_call1(Stdlib_List[10], _a_);
   }
   function full_split(expr, text){return bounded_full_split(expr, text, 0);}
   var
    Re_Str =
      [0,
       regexp,
       regexp_case_fold,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_backward,
       string_partial_match,
       matched_string,
       match_beginning,
       match_end,
       matched_group,
       group_beginning,
       group_end,
       global_replace,
       replace_first,
       global_substitute,
       substitute_first,
       replace_matched,
       split,
       bounded_split,
       split_delim,
       bounded_split_delim,
       full_split,
       bounded_full_split,
       string_before,
       string_after,
       first_chars,
       last_chars];
   runtime.caml_register_global(14, Re_Str, "Re__Str");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Replace
//# unitInfo: Requires: Re__Compile, Re__Group, Stdlib, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Re_replace$1 = "Re.replace",
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Compile = global_data.Re__Compile,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Re_Group = global_data.Re__Group,
    Stdlib = global_data.Stdlib,
    cst_Re_replace = cst_Re_replace$1,
    cst_Re_replace$0 = cst_Re_replace$1;
   function replace(opt, len, _a_, re, f, s){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(_a_) var sth$0 = _a_[1], all = sth$0; else var all = 1;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_replace);
    if(len){
     var
      l = len[1],
      _b_ = l < 0 ? 1 : 0,
      _c_ = _b_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_c_) caml_call1(Stdlib[1], cst_Re_replace$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    var
     buf = caml_call1(Stdlib_Buffer[1], caml_ml_string_length(s)),
     pos$0 = pos,
     on_match = 0;
    for(;;){
     if(pos$0 <= limit){
      var
       match =
         caml_call6(Re_Compile[1], 1, 0, re, s, pos$0, limit - pos$0 | 0);
      if(typeof match === "number")
       caml_call4(Stdlib_Buffer[18], buf, s, pos$0, limit - pos$0 | 0);
      else if(0 === match[0]){
       var
        substr = match[1],
        match$0 = caml_call2(Re_Group[3], substr, 0),
        p2 = match$0[2],
        p1 = match$0[1];
       if(pos$0 === p1 && p1 === p2 && on_match){
        if(p2 < limit){
         var _d_ = caml_string_get(s, p2);
         caml_call2(Stdlib_Buffer[12], buf, _d_);
        }
        var pos$1 = p2 + 1 | 0, pos$0 = pos$1, on_match = 0;
        continue;
       }
       caml_call4(Stdlib_Buffer[18], buf, s, pos$0, p1 - pos$0 | 0);
       var replacing = caml_call1(f, substr);
       caml_call2(Stdlib_Buffer[16], buf, replacing);
       if(all){
        var on_match$0 = p1 !== p2 ? 1 : 0;
        if(p1 === p2){
         if(p2 < limit){
          var _e_ = caml_string_get(s, p2);
          caml_call2(Stdlib_Buffer[12], buf, _e_);
         }
         var pos$2 = p2 + 1 | 0;
        }
        else
         var pos$2 = p2;
        var pos$0 = pos$2, on_match = on_match$0;
        continue;
       }
       caml_call4(Stdlib_Buffer[18], buf, s, p2, limit - p2 | 0);
      }
     }
     return caml_call1(Stdlib_Buffer[2], buf);
    }
   }
   function replace_string(pos, len, all, re, by, s){
    return replace(pos, len, all, re, function(param){return by;}, s);
   }
   var Re_Replace = [0, replace, replace_string];
   runtime.caml_register_global(6, Re_Replace, "Re__Replace");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Glob
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Stdlib, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    beg = [0, cst$0, 0],
    cst = "/**",
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Parse_error = [248, "Re__Glob.Parse_error", runtime.caml_fresh_oo_id(0)],
    _h_ = [0, 1],
    _g_ = [0, 1],
    _e_ = [0, 47, [0, 92, 0]],
    _f_ = [0, 47, 0],
    _c_ = [0, cst$0, 0],
    _d_ = [0, cst$0, 0],
    _b_ = [0, 47],
    _a_ = [0, 45];
   function mul(l$0, l){
    function _ae_(s){
     function _ag_(s$0){return caml_call2(Stdlib[28], s, s$0);}
     return caml_call2(Stdlib_List[20], _ag_, l);
    }
    var _af_ = caml_call2(Stdlib_List[20], _ae_, l$0);
    return caml_call1(Stdlib_List[15], _af_);
   }
   function explicit_period(t){
    var _aa_ = t[7];
    if(_aa_){
     var _ab_ = t[3];
     if(_ab_)
      var _ac_ = _ab_;
     else
      var _ad_ = t[4], _ac_ = _ad_ ? t[5] : _ad_;
    }
    else
     var _ac_ = _aa_;
    return _ac_;
   }
   function slashes(t){return t[6] ? _e_ : _f_;}
   function append(opt, t, piece){
    if(opt)
     var sth = opt[1], am_at_start_of_component = sth;
    else
     var am_at_start_of_component = 0;
    return [0,
            [0, piece, t[1]],
            t[2],
            0,
            am_at_start_of_component,
            t[5],
            t[6],
            t[7]];
   }
   function next(t){
    var match = t[2];
    if(! match) return 0;
    var remaining = match[2], piece = match[1];
    return [0, [0, piece, [0, t[1], remaining, t[3], t[4], t[5], t[6], t[7]]]];
   }
   function one(explicit_slash, slashes, explicit_period){
    var
     _X_ = 0,
     _Y_ = explicit_period ? [0, caml_call1(Re_Core[26], 46), 0] : 0,
     _Z_ = [0, _Y_, _X_],
     ___ =
       explicit_slash ? caml_call2(Stdlib_List[20], Re_Core[26], slashes) : 0,
     _$_ = caml_call1(Stdlib_List[14], [0, ___, _Z_]);
    return caml_call1(Re_Core[60], _$_);
   }
   function enclosed(enclosed){
    if(0 === enclosed[0]){
     var c = enclosed[1];
     return caml_call1(Re_Core[26], c);
    }
    var high = enclosed[2], low = enclosed[1];
    return caml_call2(Re_Core[57], low, high);
   }
   function enclosed_set(explicit_slash, slashes, explicit_period, kind, set){
    var
     set$0 = caml_call2(Stdlib_List[20], enclosed, set),
     enclosure =
       596216810 <= kind
        ? caml_call1(Re_Core[27], set$0)
        : caml_call1(Re_Core[60], set$0),
     _W_ =
       [0, enclosure, [0, one(explicit_slash, slashes, explicit_period), 0]];
    return caml_call1(Re_Core[58], _W_);
   }
   function exactly(state, c){
    var
     slashes$0 = slashes(state),
     am_at_start_of_component = caml_call2(Stdlib_List[37], c, slashes$0),
     chars = am_at_start_of_component ? slashes$0 : [0, c, 0],
     _V_ = caml_call2(Stdlib_List[20], Re_Core[26], chars);
    return append
            ([0, am_at_start_of_component],
             state,
             caml_call1(Re_Core[27], _V_));
   }
   function many_many(state){
    var
     _J_ = state[7],
     explicit_period$0 = _J_ ? state[5] : _J_,
     first_explicit_period = explicit_period(state),
     slashes$0 = slashes(state);
    function match_component(explicit_period){
     var
      _S_ = one(1, slashes$0, 0),
      _T_ = [0, caml_call1(Re_Core[31], _S_), 0],
      _U_ = [0, one(1, slashes$0, explicit_period), _T_];
     return caml_call1(Re_Core[28], _U_);
    }
    var
     _K_ = match_component(explicit_period$0),
     _L_ = [0, caml_call1(Re_Core[34], _K_), 0],
     _M_ = caml_call2(Stdlib_List[20], Re_Core[26], slashes$0),
     _N_ = [0, caml_call1(Re_Core[27], _M_), _L_],
     _O_ = caml_call1(Re_Core[28], _N_),
     _P_ = [0, caml_call1(Re_Core[31], _O_), 0],
     _Q_ = match_component(first_explicit_period),
     _R_ = [0, caml_call1(Re_Core[34], _Q_), _P_];
    return append(0, state, caml_call1(Re_Core[28], _R_));
   }
   function glob(opt, _o_, _n_, _m_, _l_, _k_, str){
    if(opt) var sth = opt[1], anchored = sth; else var anchored = 0;
    if(_o_) var sth$0 = _o_[1], pathname = sth$0; else var pathname = 1;
    if(_n_)
     var sth$1 = _n_[1], match_backslashes = sth$1;
    else
     var match_backslashes = 0;
    if(_m_) var sth$2 = _m_[1], period = sth$2; else var period = 1;
    if(_l_)
     var sth$3 = _l_[1], expand_braces = sth$3;
    else
     var expand_braces = 0;
    if(_k_)
     var sth$4 = _k_[1], double_asterisk = sth$4;
    else
     var double_asterisk = 1;
    function to_re(s){
     var buf = caml_call1(Re_Parse_buffer[2], s);
     function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
     function read(c){return caml_call2(Re_Parse_buffer[9], buf, c);}
     function char$0(param){
      read(92);
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      return caml_call1(Re_Parse_buffer[8], buf);
     }
     function enclosed(param){
      var s = 0;
      for(;;){
       if(0 !== s && read(93)) return s;
       var c = char$0(0);
       if(read(45)){
        if(read(93)) return [0, [0, c], [0, _a_, s]];
        var c$0 = char$0(0), s$0 = [0, [1, c, c$0], s], s = s$0;
       }
       else
        var s$1 = [0, [0, c], s], s = s$1;
      }
     }
     var pieces = 0;
     for(;;){
      if(eos(0)) break;
      a:
      {
       if(double_asterisk && caml_call2(Re_Parse_buffer[11], buf, cst)){
        var _s_ = eos(0) ? [0, _b_, pieces] : pieces, pieces$0 = [0, 2, _s_];
        break a;
       }
       if(read(42)){
        b:
        {if(double_asterisk && read(42)){var _t_ = 2; break b;} var _t_ = 1;}
        var pieces$0 = [0, _t_, pieces];
       }
       else if(read(63))
        var pieces$0 = [0, 0, pieces];
       else if(read(91)){
        if(! read(94) && ! read(33)){
         var pieces$0 = [0, [1, enclosed(0)], pieces];
         break a;
        }
        var pieces$0 = [0, [2, enclosed(0)], pieces];
       }
       else
        var pieces$0 = [0, [0, char$0(0)], pieces];
      }
      var pieces = pieces$0;
     }
     var
      remaining = caml_call1(Stdlib_List[10], pieces),
      state = [0, 0, remaining, 1, 1, pathname, match_backslashes, period],
      state$8 = state;
     for(;;){
      var match$1 = next(state$8);
      if(! match$1){
       var
        _u_ = caml_call1(Stdlib_List[10], state$8[1]),
        re = caml_call1(Re_Core[28], _u_);
       return anchored ? caml_call1(Re_Core[46], re) : re;
      }
      var
       match$2 = match$1[1],
       state$9 = match$2[2],
       piece = match$2[1],
       explicit_slash$0 = state$9[5],
       explicit_period$1 = explicit_period(state$9),
       slashes$1 = slashes(state$9);
      if(typeof piece === "number")
       switch(piece){
         case 0:
          var
           state$10 =
             append
              (0,
               state$9,
               one(explicit_slash$0, slashes$1, explicit_period$1));
          break;
         case 1:
          var
           explicit_slash = state$9[5],
           explicit_period$0 = explicit_period(state$9),
           slashes$0 = slashes(state$9);
          if(explicit_period$0)
           if(explicit_slash){
            var
             _v_ = one(1, slashes$0, 0),
             _w_ = [0, caml_call1(Re_Core[31], _v_), 0],
             _x_ = [0, one(1, slashes$0, 1), _w_],
             not_empty = caml_call1(Re_Core[28], _x_),
             maybe_empty = caml_call1(Re_Core[34], not_empty),
             enclosed_set$1 =
               function(slashes, not_empty){
                function enclosed_set$0(state, kind, set){
                 var
                  _G_ =
                    [0,
                     not_empty,
                     [0, enclosed_set(1, slashes, 0, kind, set), 0]],
                  _H_ = [0, caml_call1(Re_Core[28], _G_), 0],
                  _I_ = [0, enclosed_set(1, slashes, 1, kind, set), _H_];
                 return append(0, state, caml_call1(Re_Core[27], _I_));
                }
                return enclosed_set$0;
               },
             enclosed_set$0 = enclosed_set$1(slashes$0, not_empty);
            a:
            {
             b:
             {
              c:
              {
               d:
               {
                var state$0 = state$9;
                for(;;){
                 var match = next(state$0);
                 if(! match) break;
                 var _y_ = match[1], match$0 = _y_[1];
                 if(typeof match$0 !== "number") break d;
                 switch(match$0){
                   case 0:
                    break b;
                   case 1:
                    var state$2 = _y_[2], state$0 = state$2; break;
                   default: break c;
                 }
                }
                var _z_ = append(0, state$0, maybe_empty);
                break a;
               }
               switch(match$0[0]){
                 case 0:
                  var
                   state$4 = _y_[2],
                   c = match$0[1],
                   not_empty$0 = 46 === c ? not_empty : maybe_empty,
                   state$5 = append(0, state$4, not_empty$0),
                   _z_ = exactly(state$5, c);
                  break a;
                 case 1:
                  var
                   state$6 = _y_[2],
                   enclosed$0 = match$0[1],
                   _z_ = enclosed_set$0(state$6, 596216810, enclosed$0);
                  break a;
                 default:
                  var
                   state$7 = _y_[2],
                   enclosed$1 = match$0[1],
                   _z_ = enclosed_set$0(state$7, -188280562, enclosed$1);
                  break a;
               }
              }
              var state$3 = _y_[2], _z_ = many_many(state$3);
              break a;
             }
             var state$1 = _y_[2], _z_ = append(0, state$1, not_empty);
            }
            var _F_ = _z_;
           }
           else
            var
             _A_ = one(0, slashes$0, 0),
             _B_ = [0, caml_call1(Re_Core[31], _A_), 0],
             _C_ = [0, one(0, slashes$0, explicit_period$0), _B_],
             _D_ = caml_call1(Re_Core[28], _C_),
             _F_ = append(0, state$9, caml_call1(Re_Core[34], _D_));
          else
           var
            _E_ = one(explicit_slash, slashes$0, explicit_period$0),
            _F_ = append(0, state$9, caml_call1(Re_Core[31], _E_));
          var state$10 = _F_;
          break;
         default: var state$10 = many_many(state$9);
       }
      else
       switch(piece[0]){
         case 0:
          var c$0 = piece[1], state$10 = exactly(state$9, c$0); break;
         case 1:
          var
           enclosed$2 = piece[1],
           state$10 =
             append
              (0,
               state$9,
               enclosed_set
                (explicit_slash$0,
                 slashes$1,
                 explicit_period$1,
                 596216810,
                 enclosed$2));
          break;
         default:
          var
           enclosed$3 = piece[1],
           state$10 =
             append
              (0,
               state$9,
               enclosed_set
                (explicit_slash$0,
                 slashes$1,
                 explicit_period$1,
                 -188280562,
                 enclosed$3));
       }
      var state$8 = state$10;
     }
    }
    if(! expand_braces) return to_re(str);
    var l = runtime.caml_ml_string_length(str);
    function expl(inner, s, i, acc, beg$0){
     var s$0 = s, i$0 = i, acc$0 = acc, beg$1 = beg$0;
     for(;;){
      if(l <= i$0){
       if(inner) throw caml_maybe_attach_backtrace(Parse_error, 1);
       return [0,
               mul
                (beg$1,
                 [0,
                  caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0),
                  0]),
               i$0];
      }
      var match = runtime.caml_string_get(str, i$0);
      if(44 === match){
       if(inner){
        var
         _q_ =
           mul
            (beg$1,
             [0, caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0), 0]),
         acc$1 = caml_call2(Stdlib[37], _q_, acc$0),
         i$1 = i$0 + 1 | 0,
         s$1 = i$0 + 1 | 0,
         s$0 = s$1,
         i$0 = i$1,
         acc$0 = acc$1,
         beg$1 = beg;
        continue;
       }
      }
      else
       if(123 <= match){
        if(126 > match)
         switch(match - 123 | 0){
           case 0:
            var
             match$0 = expl(1, i$0 + 1 | 0, i$0 + 1 | 0, 0, _c_),
             i$3 = match$0[2],
             t = match$0[1],
             beg$2 =
               mul
                (beg$1,
                 mul
                  ([0,
                    caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0),
                    0],
                   t)),
             s$0 = i$3,
             i$0 = i$3,
             beg$1 = beg$2;
            continue;
           case 1: break;
           default:
            if(inner){
             var
              _r_ =
                mul
                 (beg$1,
                  [0,
                   caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0),
                   0]);
             return [0, caml_call2(Stdlib[37], _r_, acc$0), i$0 + 1 | 0];
            }
         }
       }
       else if(92 === match){var i$4 = i$0 + 2 | 0, i$0 = i$4; continue;}
      var i$2 = i$0 + 1 | 0, i$0 = i$2;
     }
    }
    var
     _i_ = expl(0, 0, 0, 0, _d_)[1],
     _j_ = caml_call1(Stdlib_List[10], _i_),
     _p_ = caml_call2(Stdlib_List[20], to_re, _j_);
    return caml_call1(Re_Core[27], _p_);
   }
   function glob$0(anchored, period, s){
    return glob(anchored, 0, 0, [0, period], 0, 0, s);
   }
   function globx(anchored, s){return glob(anchored, 0, 0, 0, _g_, 0, s);}
   function globx$0(anchored, period, s){
    return glob(anchored, 0, 0, [0, period], _h_, 0, s);
   }
   var Re_Glob = [0, Parse_error, glob, glob$0, globx, globx$0];
   runtime.caml_register_global(16, Re_Glob, "Re__Glob");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Posix_class
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_alnum = "alnum",
    cst_alpha = "alpha",
    cst_ascii = "ascii",
    cst_blank = "blank",
    cst_cntrl = "cntrl",
    cst_digit = "digit",
    cst_graph = "graph",
    cst_lower = "lower",
    cst_print = "print",
    cst_punct = "punct",
    cst_space = "space",
    cst_upper = "upper",
    cst_word = "word",
    cst_xdigit = "xdigit",
    caml_list_of_js_array = runtime.caml_list_of_js_array,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ":]",
    names =
      caml_list_of_js_array
       ([cst_alpha,
         cst_alnum,
         cst_ascii,
         cst_blank,
         cst_cntrl,
         cst_digit,
         cst_lower,
         cst_print,
         cst_space,
         cst_upper,
         cst_word,
         cst_punct,
         cst_graph,
         cst_xdigit]),
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Re_Core = global_data.Re__Core,
    cst_Invalid_pcre_class = "Invalid pcre class: ";
   function of_name(class$0){
    var switch$0 = runtime.caml_string_compare(class$0, cst_lower);
    if(0 <= switch$0){
     if(0 >= switch$0) return Re_Core[71];
     if(! caml_string_notequal(class$0, cst_print)) return Re_Core[72];
     if(! caml_string_notequal(class$0, cst_punct)) return Re_Core[73];
     if(! caml_string_notequal(class$0, cst_space)) return Re_Core[74];
     if(! caml_string_notequal(class$0, cst_upper)) return Re_Core[75];
     if(! caml_string_notequal(class$0, cst_word)) return Re_Core[64];
     if(! caml_string_notequal(class$0, cst_xdigit)) return Re_Core[76];
    }
    else{
     if(! caml_string_notequal(class$0, cst_alnum)) return Re_Core[63];
     if(! caml_string_notequal(class$0, cst_alpha)) return Re_Core[65];
     if(! caml_string_notequal(class$0, cst_ascii)) return Re_Core[66];
     if(! caml_string_notequal(class$0, cst_blank)) return Re_Core[67];
     if(! caml_string_notequal(class$0, cst_cntrl)) return Re_Core[68];
     if(! caml_string_notequal(class$0, cst_digit)) return Re_Core[69];
     if(! caml_string_notequal(class$0, cst_graph)) return Re_Core[70];
    }
    var _d_ = caml_call2(Stdlib[28], cst_Invalid_pcre_class, class$0);
    return caml_call1(Stdlib[1], _d_);
   }
   function parse(buf){
    var
     accept = caml_call1(Re_Parse_buffer[9], buf),
     accept_s = caml_call1(Re_Parse_buffer[11], buf);
    if(! caml_call1(accept, 58)) return 0;
    var compl = caml_call1(accept, 94);
    try{var cls = caml_call2(Stdlib_List[39], accept_s, names);}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_ === Stdlib[8])
      throw caml_maybe_attach_backtrace(Re_Parse_buffer[1], 1);
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
    if(1 - caml_call1(accept_s, cst))
     throw caml_maybe_attach_backtrace(Re_Parse_buffer[1], 1);
    var
     posix_class = of_name(cls),
     _b_ = compl ? caml_call1(Re_Core[60], [0, posix_class, 0]) : posix_class;
    return [0, _b_];
   }
   var Re_Posix_class = [0, names, of_name, parse];
   runtime.caml_register_global(21, Re_Posix_class, "Re__Posix_class");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Perl
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Re__Posix_class, Stdlib, Stdlib__Buffer, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    Re_Core = global_data.Re__Core,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Re_Posix_class = global_data.Re__Posix_class,
    Parse_error = Re_Parse_buffer[1],
    Not_supported =
      [248, "Re__Perl.Not_supported", runtime.caml_fresh_oo_id(0)],
    _a_ = [0, 748194550, 8],
    _b_ = [0, 748194550, 10],
    _c_ = [0, 748194550, 13],
    _d_ = [0, 748194550, 9];
   function re(opt, s){
    if(opt) var sth = opt[1], opts = sth; else var opts = 0;
    var
     ungreedy = caml_call2(Stdlib_List[38], -243745063, opts),
     dotall = caml_call2(Stdlib_List[38], -424303016, opts),
     dollar_endonly = caml_call2(Stdlib_List[38], -712595228, opts),
     multiline = caml_call2(Stdlib_List[38], 1071952589, opts),
     buf = caml_call1(Re_Parse_buffer[2], s),
     accept = caml_call1(Re_Parse_buffer[9], buf);
    function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
    function test(c){return caml_call2(Re_Parse_buffer[6], buf, c);}
    function get(param){return caml_call1(Re_Parse_buffer[8], buf);}
    function greedy_mod(r){
     var gr = caml_call1(accept, 63), gr$0 = ungreedy ? 1 - gr : gr;
     return gr$0 ? caml_call1(Re_Core[51], r) : caml_call1(Re_Core[50], r);
    }
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! caml_call1(accept, 124)) return left$0;
      var
       _r_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[27], _r_),
       left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if(! eos(0) && ! test(124) && ! test(41)){
       var r = atom(0);
       if(caml_call1(accept, 42))
        var _q_ = greedy_mod(caml_call1(Re_Core[31], r));
       else if(caml_call1(accept, 43))
        var _q_ = greedy_mod(caml_call1(Re_Core[32], r));
       else if(caml_call1(accept, 63))
        var _q_ = greedy_mod(caml_call1(Re_Core[34], r));
       else if(caml_call1(accept, 123)){
        var match = caml_call1(Re_Parse_buffer[12], buf);
        if(match){
         var
          i = match[1],
          j =
            caml_call1(accept, 44)
             ? caml_call1(Re_Parse_buffer[12], buf)
             : [0, i];
         if(1 - caml_call1(accept, 125))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         if(j){
          var j$0 = j[1];
          if(j$0 < i) throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var _q_ = greedy_mod(caml_call3(Re_Core[33], r, i, j));
        }
        else{caml_call1(Re_Parse_buffer[4], buf); var _q_ = r;}
       }
       else
        var _q_ = r;
       var left$0 = [0, _q_, left], left = left$0;
       continue;
      }
      var _p_ = caml_call1(Stdlib_List[10], left);
      return caml_call1(Re_Core[28], _p_);
     }
    }
    function atom(param){
     if(caml_call1(accept, 46)) return dotall ? Re_Core[61] : Re_Core[62];
     if(! caml_call1(accept, 40)){
      if(caml_call1(accept, 94)) return multiline ? Re_Core[35] : Re_Core[39];
      if(caml_call1(accept, 36))
       return multiline
               ? Re_Core[36]
               : dollar_endonly ? Re_Core[41] : Re_Core[40];
      if(caml_call1(accept, 91)){
       if(caml_call1(accept, 94)){
        var _i_ = bracket(0);
        return caml_call1(Re_Core[60], _i_);
       }
       var _j_ = bracket(0);
       return caml_call1(Re_Core[27], _j_);
      }
      if(caml_call1(accept, 92)){
       if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
       var c = get(0), switcher = c - 48 | 0;
       if(74 >= switcher >>> 0)
        switch(switcher){
          case 17:
           return Re_Core[39];
          case 18:
           return Re_Core[45];
          case 20:
           return caml_call1(Re_Core[60], [0, Re_Core[69], 0]);
          case 23:
           return Re_Core[42];
          case 35:
           return caml_call1(Re_Core[60], [0, Re_Core[74], 0]);
          case 39:
           var _k_ = [0, caml_call1(Re_Core[26], 95), 0];
           return caml_call1(Re_Core[60], [0, Re_Core[63], _k_]);
          case 42:
           return Re_Core[41];
          case 50:
           return caml_call1
                   (Re_Core[27], [0, Re_Core[37], [0, Re_Core[38], 0]]);
          case 52:
           return Re_Core[69];
          case 53:
           return caml_call1(Re_Core[26], 27);
          case 54:
           return caml_call1(Re_Core[26], 12);
          case 62:
           return caml_call1(Re_Core[26], 10);
          case 66:
           return caml_call1(Re_Core[26], 13);
          case 67:
           return Re_Core[74];
          case 68:
           return caml_call1(Re_Core[26], 9);
          case 71:
           var _l_ = [0, caml_call1(Re_Core[26], 95), 0];
           return caml_call1(Re_Core[27], [0, Re_Core[63], _l_]);
          case 72:
           var
            c1 = hexdigit(0),
            c2 = hexdigit(0),
            code = (c1 * 16 | 0) + c2 | 0,
            _m_ = caml_call1(Stdlib[29], code);
           return caml_call1(Re_Core[26], _m_);
          case 74:
           return Re_Core[40];
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
           throw caml_maybe_attach_backtrace(Not_supported, 1);
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 48: break;
          default: throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
       return caml_call1(Re_Core[26], c);
      }
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$0 = get(0);
      a:
      {
       if(64 <= c$0){
        if(92 === c$0 || 123 === c$0) break a;
       }
       else
        if(44 <= c$0){if(63 <= c$0) break a;} else if(42 <= c$0) break a;
       return caml_call1(Re_Core[26], c$0);
      }
      throw caml_maybe_attach_backtrace(Parse_error, 1);
     }
     if(! caml_call1(accept, 63)){
      var r$1 = regexp(0);
      if(1 - caml_call1(accept, 41))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      return caml_call2(Re_Core[52], 0, r$1);
     }
     if(caml_call1(accept, 58)){
      var r = regexp(0);
      if(1 - caml_call1(accept, 41))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      return r;
     }
     if(! caml_call1(accept, 35)){
      if(! caml_call1(accept, 60))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$1 = get(0), _n_ = c$1 - 91 | 0;
      a:
      {
       if(5 < _n_ >>> 0){
        if(57 < _n_ + 26 >>> 0) break a;
       }
       else if(4 !== _n_) break a;
       var b = caml_call1(Stdlib_Buffer[1], 32);
       caml_call2(Stdlib_Buffer[12], b, c$1);
       for(;;){
        if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
        var c$2 = get(0);
        b:
        {
         if(65 <= c$2){
          var _o_ = c$2 - 91 | 0;
          if(5 < _o_ >>> 0){
           if(32 <= _o_) break b;
          }
          else if(4 !== _o_) break b;
         }
         else{
          if(58 <= c$2){
           if(62 !== c$2) break b;
           var name = caml_call1(Stdlib_Buffer[2], b), r$0 = regexp(0);
           if(1 - caml_call1(accept, 41))
            throw caml_maybe_attach_backtrace(Parse_error, 1);
           return caml_call2(Re_Core[52], [0, name], r$0);
          }
          if(48 > c$2) break b;
         }
         caml_call2(Stdlib_Buffer[12], b, c$2);
         continue;
        }
        throw caml_maybe_attach_backtrace(Parse_error, 1);
       }
      }
      throw caml_maybe_attach_backtrace(Parse_error, 1);
     }
     for(;;){
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      if(caml_call1(accept, 41)) return Re_Core[30];
      caml_call1(Re_Parse_buffer[3], buf);
     }
    }
    function hexdigit(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var d = get(0);
     if(65 <= d){
      if(97 <= d){
       if(103 > d) return (d - 97 | 0) + 10 | 0;
      }
      else if(71 > d) return (d - 65 | 0) + 10 | 0;
     }
     else if(9 >= d - 48 >>> 0) return d - 48 | 0;
     throw caml_maybe_attach_backtrace(Parse_error, 1);
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && caml_call1(accept, 93)) return s$0;
      var match = char$0(0);
      if(748194550 <= match[1]){
       var c = match[2];
       if(caml_call1(accept, 45)){
        if(caml_call1(accept, 93)){
         var _g_ = [0, caml_call1(Re_Core[26], 45), s$0];
         return [0, caml_call1(Re_Core[26], c), _g_];
        }
        var match$0 = char$0(0);
        if(748194550 <= match$0[1])
         var
          c$0 = match$0[2],
          s$1 = [0, caml_call2(Re_Core[57], c, c$0), s$0];
        else
         var
          st = match$0[2],
          _h_ = [0, caml_call1(Re_Core[26], 45), [0, st, s$0]],
          s$1 = [0, caml_call1(Re_Core[26], c), _h_];
        var s$0 = s$1;
       }
       else
        var s$2 = [0, caml_call1(Re_Core[26], c), s$0], s$0 = s$2;
      }
      else
       var st$0 = match[2], s$3 = [0, st$0, s$0], s$0 = s$3;
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c = get(0);
     if(91 === c){
      if(caml_call1(accept, 61))
       throw caml_maybe_attach_backtrace(Not_supported, 1);
      var match = caml_call1(Re_Posix_class[3], buf);
      if(match){var set = match[1]; return [0, 4150146, set];}
      if(! caml_call1(accept, 46)) return [0, 748194550, c];
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$0 = get(0);
      if(1 - caml_call1(accept, 46))
       throw caml_maybe_attach_backtrace(Not_supported, 1);
      if(1 - caml_call1(accept, 93))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      return [0, 748194550, c$0];
     }
     if(92 !== c) return [0, 748194550, c];
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c$1 = get(0);
     if(58 <= c$1){
      if(123 > c$1)
       switch(c$1 - 58 | 0){
         case 10:
          return [0, 4150146, caml_call1(Re_Core[60], [0, Re_Core[69], 0])];
         case 25:
          return [0, 4150146, caml_call1(Re_Core[60], [0, Re_Core[74], 0])];
         case 29:
          var _e_ = [0, caml_call1(Re_Core[26], 95), 0];
          return [0, 4150146, caml_call1(Re_Core[60], [0, Re_Core[63], _e_])];
         case 40:
          return _a_;
         case 42:
          return [0, 4150146, Re_Core[69]];
         case 52:
          return _b_;
         case 56:
          return _c_;
         case 57:
          return [0, 4150146, Re_Core[74]];
         case 58:
          return _d_;
         case 61:
          var _f_ = [0, caml_call1(Re_Core[26], 95), 0];
          return [0, 4150146, caml_call1(Re_Core[27], [0, Re_Core[63], _f_])];
         case 0:
         case 1:
         case 2:
         case 3:
         case 4:
         case 5:
         case 6:
         case 33:
         case 34:
         case 35:
         case 36:
         case 37:
         case 38: break;
         default: throw caml_maybe_attach_backtrace(Parse_error, 1);
       }
     }
     else if(48 <= c$1) throw caml_maybe_attach_backtrace(Not_supported, 1);
     return [0, 748194550, c$1];
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    var
     r =
       caml_call2(Stdlib_List[38], 616470068, opts)
        ? caml_call1(Re_Core[28], [0, Re_Core[42], [0, res, 0]])
        : res,
     r$0 =
       caml_call2(Stdlib_List[38], 604571177, opts)
        ? caml_call1(Re_Core[78], r)
        : r;
    return r$0;
   }
   var compile = Re_Core[2];
   function compile_pat(opt, s){
    if(opt) var sth = opt[1], opts = sth; else var opts = 0;
    return caml_call1(compile, re([0, opts], s));
   }
   var Re_Perl = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(11, Re_Perl, "Re__Perl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Pcre
//# unitInfo: Requires: Re__Core, Re__Perl, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Re_Perl = global_data.Re__Perl,
    Parse_error = Re_Perl[1],
    Not_supported = Re_Perl[2],
    _a_ = [0, -1, -1];
   function re(opt, pat){
    if(opt) var sth = opt[1], flags = sth; else var flags = 0;
    function _x_(param){
     return 601676297 <= param
             ? 613575188 <= param ? 616470068 : 604571177
             : 426394317 <= param ? 1071952589 : -424303016;
    }
    var opts = caml_call2(Stdlib_List[20], _x_, flags);
    return caml_call2(Re_Perl[3], [0, opts], pat);
   }
   function regexp(flags, pat){
    var _w_ = re(flags, pat);
    return caml_call1(Re_Core[2], _w_);
   }
   function extract(rex, s){
    var _v_ = caml_call4(Re_Core[5], 0, 0, rex, s);
    return caml_call1(Re_Core[1][6], _v_);
   }
   function exec(rex, pos, s){return caml_call4(Re_Core[5], pos, 0, rex, s);}
   function get_substring(s, i){return caml_call2(Re_Core[1][1], s, i);}
   function names(rex){
    var _r_ = caml_call1(Re_Core[4], rex);
    function _s_(_u_){return _u_[1];}
    var _t_ = caml_call1(caml_call1(Stdlib_List[20], _s_), _r_);
    return caml_call1(Stdlib_Array[10], _t_);
   }
   function get_named_substring(rex, name, s){
    var param = caml_call1(Re_Core[4], rex);
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var match = param[1], rem = param[2], i = match[2], n = match[1];
     if(runtime.caml_string_equal(n, name))
      try{var _p_ = get_substring(s, i); return _p_;}
      catch(_q_){
       var _o_ = caml_wrap_exception(_q_);
       if(_o_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_o_, 0);
       var param = rem;
      }
     else
      var rem$0 = param[2], param = rem$0;
    }
   }
   function get_substring_ofs(s, i){return caml_call2(Re_Core[1][3], s, i);}
   function pmatch(rex, s){return caml_call4(Re_Core[7], 0, 0, rex, s);}
   function substitute(rex, subst, str){
    var b = caml_call1(Stdlib_Buffer[1], 1024), pos = 0, on_match = 0;
    for(;;){
     a:
     if(caml_call4(Re_Core[7], [0, pos], 0, rex, str)){
      var
       ss = caml_call4(Re_Core[5], [0, pos], 0, rex, str),
       match = caml_call2(Re_Core[1][3], ss, 0),
       fin = match[2],
       start = match[1];
      if(on_match && start === pos && start === fin){
       if(pos >= caml_ml_string_length(str)) break a;
       var _l_ = caml_string_get(str, pos);
       caml_call2(Stdlib_Buffer[12], b, _l_);
       var pos$0 = pos + 1 | 0, pos = pos$0, on_match = 0;
       continue;
      }
      var pat = caml_call2(Re_Core[1][1], ss, 0);
      caml_call4(Stdlib_Buffer[18], b, str, pos, start - pos | 0);
      var _m_ = caml_call1(subst, pat);
      caml_call2(Stdlib_Buffer[16], b, _m_);
      if(start !== fin){var pos = fin, on_match = 1; continue;}
      if(fin < caml_ml_string_length(str)){
       var _n_ = caml_string_get(str, fin);
       caml_call2(Stdlib_Buffer[12], b, _n_);
       var pos$1 = fin + 1 | 0, pos = pos$1, on_match = 0;
       continue;
      }
     }
     else
      caml_call4
       (Stdlib_Buffer[18], b, str, pos, caml_ml_string_length(str) - pos | 0);
     return caml_call1(Stdlib_Buffer[2], b);
    }
   }
   function split(rex, str){
    function finish(str, last, accu){
     var
      accu$0 =
        [0,
         caml_call3
          (Stdlib_String[16],
           str,
           last,
           caml_ml_string_length(str) - last | 0),
         accu];
     return caml_call1(Stdlib_List[10], accu$0);
    }
    var accu = 0, last = 0, pos = 0, on_match = 0;
    for(;;){
     if(! caml_call4(Re_Core[7], [0, pos], 0, rex, str))
      return finish(str, last, accu);
     var
      ss = caml_call4(Re_Core[5], [0, pos], 0, rex, str),
      match = caml_call2(Re_Core[1][3], ss, 0),
      last$0 = match[2],
      start = match[1];
     if(on_match && start === pos && start === last$0){
      if(pos === caml_ml_string_length(str)) return finish(str, last, accu);
      var pos$0 = pos + 1 | 0, pos = pos$0, on_match = 0;
      continue;
     }
     var
      accu$0 =
        [0, caml_call3(Stdlib_String[16], str, last, start - last | 0), accu];
     if(start === last$0){
      if(last$0 === caml_ml_string_length(str))
       return finish(str, last$0, accu$0);
      var
       pos$1 = last$0 + 1 | 0,
       accu = accu$0,
       last = last$0,
       pos = pos$1,
       on_match = 0;
     }
     else
      var accu = accu$0, last = last$0, pos = last$0, on_match = 1;
    }
   }
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_create_bytes(len << 1),
     pos = [0, 0],
     _i_ = len - 1 | 0,
     _h_ = 0;
    if(_i_ >= 0){
     var i = _h_;
     for(;;){
      var c = runtime.caml_string_unsafe_get(s, i);
      a:
      {
       b:
       {
        if(91 <= c){
         var _j_ = c - 93 | 0;
         if(29 < _j_ >>> 0){
          if(32 <= _j_) break b;
         }
         else if(1 !== _j_) break b;
        }
        else
         if(47 <= c){
          if(63 !== c) break b;
         }
         else{
          if(36 > c) break b;
          switch(c - 36 | 0){case 1:case 2:case 3:case 8:case 9: break b;
          }
         }
        caml_bytes_unsafe_set(buf, pos[1], 92);
        pos[1]++;
        caml_bytes_unsafe_set(buf, pos[1], c);
        pos[1]++;
        break a;
       }
       caml_bytes_unsafe_set(buf, pos[1], c);
       pos[1]++;
      }
      var _k_ = i + 1 | 0;
      if(_i_ === i) break;
      var i = _k_;
     }
    }
    var len$0 = pos[1], r = caml_create_bytes(len$0);
    runtime.caml_blit_bytes(buf, 0, r, 0, len$0);
    return caml_call1(Stdlib_Bytes[44], r);
   }
   function full_split(opt, rex, s){
    if(opt) var sth = opt[1], max = sth; else var max = 0;
    if(0 === caml_ml_string_length(s)) return 0;
    if(1 === max) return [0, [0, s], 0];
    var results = caml_call4(Re_Core[21], 0, 0, rex, s);
    function _b_(param){
     if(936573133 <= param[1]){var s = param[2]; return [0, [0, s], 0];}
     var
      d = param[2],
      matches = caml_call1(Re_Core[1][7], d),
      delim = caml_call2(Re_Core[1][1], d, 0),
      l = [0, 0],
      _d_ = matches.length - 1 - 1 | 0,
      _c_ = 1;
     if(_d_ >= 1){
      var i = _c_;
      for(;;){
       var
        _e_ = l[1],
        _f_ =
          runtime.caml_equal(runtime.caml_check_bound(matches, i)[1 + i], _a_)
           ? 0
           : [2, i, caml_call2(Re_Core[1][1], d, i)];
       l[1] = [0, _f_, _e_];
       var _g_ = i + 1 | 0;
       if(_d_ === i) break;
       var i = _g_;
      }
     }
     return [0, [1, delim], caml_call1(Stdlib_List[10], l[1])];
    }
    var matches = caml_call2(Stdlib_List[20], _b_, results);
    return caml_call1(Stdlib_List[14], matches);
   }
   var
    Re_Pcre =
      [0,
       Parse_error,
       Not_supported,
       re,
       regexp,
       extract,
       exec,
       get_substring,
       names,
       get_named_substring,
       get_substring_ofs,
       pmatch,
       substitute,
       full_split,
       split,
       quote];
   runtime.caml_register_global(9, Re_Pcre, "Re__Pcre");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Posix
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Re__Posix_class, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Re_Posix_class = global_data.Re__Posix_class,
    Parse_error = Re_Parse_buffer[1],
    Not_supported =
      [248, "Re__Posix.Not_supported", runtime.caml_fresh_oo_id(0)];
   function re(opt, s){
    if(opt) var sth = opt[1], opts = sth; else var opts = 0;
    var
     newline = caml_call2(Stdlib_List[38], -638074828, opts),
     buf = caml_call1(Re_Parse_buffer[2], s),
     accept = caml_call1(Re_Parse_buffer[9], buf);
    function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
    function test(c){return caml_call2(Re_Parse_buffer[6], buf, c);}
    function get(param){return caml_call1(Re_Parse_buffer[8], buf);}
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! caml_call1(accept, 124)) return left$0;
      var
       _n_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[27], _n_),
       left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if(! eos(0) && ! test(124) && ! test(41)){
       a:
       if(caml_call1(accept, 46))
        var r = newline ? Re_Core[62] : Re_Core[61];
       else if(caml_call1(accept, 40)){
        var r$0 = regexp(0);
        if(1 - caml_call1(accept, 41))
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        var r = caml_call2(Re_Core[52], 0, r$0);
       }
       else if(caml_call1(accept, 94))
        var r = newline ? Re_Core[35] : Re_Core[39];
       else if(caml_call1(accept, 36))
        var r = newline ? Re_Core[36] : Re_Core[40];
       else{
        if(! caml_call1(accept, 91)){
         if(! caml_call1(accept, 92)){
          if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
          var c$0 = get(0);
          b:
          {
           if(64 <= c$0){
            if(92 === c$0 || 123 === c$0) break b;
           }
           else
            if(44 <= c$0){if(63 <= c$0) break b;} else if(42 <= c$0) break b;
           var r = caml_call1(Re_Core[26], c$0);
           break a;
          }
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c = get(0);
         b:
         {
          if(91 <= c){
           var _m_ = c - 93 | 0;
           if(29 < _m_ >>> 0){
            if(32 <= _m_) break b;
           }
           else if(1 !== _m_) break b;
          }
          else
           if(47 <= c){
            if(63 !== c) break b;
           }
           else{
            if(36 > c) break b;
            switch(c - 36 | 0){case 1:case 2:case 3:case 8:case 9: break b;
            }
           }
          var r = caml_call1(Re_Core[26], c);
          break a;
         }
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
        if(caml_call1(accept, 94))
         var
          _i_ = caml_call1(Re_Core[26], 10),
          _j_ = bracket(0),
          _k_ = caml_call1(Re_Core[60], _j_),
          r = caml_call2(Re_Core[59], _k_, _i_);
        else
         var _l_ = bracket(0), r = caml_call1(Re_Core[27], _l_);
       }
       if(caml_call1(accept, 42))
        var
         _f_ = caml_call1(Re_Core[54], r),
         _e_ = caml_call1(Re_Core[31], _f_);
       else if(caml_call1(accept, 43))
        var
         _g_ = caml_call1(Re_Core[54], r),
         _e_ = caml_call1(Re_Core[32], _g_);
       else if(caml_call1(accept, 63))
        var _e_ = caml_call1(Re_Core[34], r);
       else if(caml_call1(accept, 123)){
        var match = caml_call1(Re_Parse_buffer[12], buf);
        if(match){
         var
          i = match[1],
          j =
            caml_call1(accept, 44)
             ? caml_call1(Re_Parse_buffer[12], buf)
             : [0, i];
         if(1 - caml_call1(accept, 125))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         if(j){
          var j$0 = j[1];
          if(j$0 < i) throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var
          _h_ = caml_call1(Re_Core[54], r),
          _e_ = caml_call3(Re_Core[33], _h_, i, j);
        }
        else{caml_call1(Re_Parse_buffer[4], buf); var _e_ = r;}
       }
       else
        var _e_ = r;
       var left$0 = [0, _e_, left], left = left$0;
       continue;
      }
      var _d_ = caml_call1(Stdlib_List[10], left);
      return caml_call1(Re_Core[28], _d_);
     }
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && caml_call1(accept, 93)) return s$0;
      var match = char$0(0);
      if(748194550 <= match[1]){
       var c = match[2];
       if(caml_call1(accept, 45)){
        if(caml_call1(accept, 93)){
         var _b_ = [0, caml_call1(Re_Core[26], 45), s$0];
         return [0, caml_call1(Re_Core[26], c), _b_];
        }
        var match$0 = char$0(0);
        if(748194550 <= match$0[1])
         var
          c$0 = match$0[2],
          s$1 = [0, caml_call2(Re_Core[57], c, c$0), s$0];
        else
         var
          st = match$0[2],
          _c_ = [0, caml_call1(Re_Core[26], 45), [0, st, s$0]],
          s$1 = [0, caml_call1(Re_Core[26], c), _c_];
        var s$0 = s$1;
       }
       else
        var s$2 = [0, caml_call1(Re_Core[26], c), s$0], s$0 = s$2;
      }
      else
       var st$0 = match[2], s$3 = [0, st$0, s$0], s$0 = s$3;
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c = get(0);
     if(91 !== c) return [0, 748194550, c];
     var match = caml_call1(Re_Posix_class[3], buf);
     if(match){var set = match[1]; return [0, 4150146, set];}
     if(! caml_call1(accept, 46)) return [0, 748194550, c];
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c$0 = get(0);
     if(1 - caml_call1(accept, 46))
      throw caml_maybe_attach_backtrace(Not_supported, 1);
     if(1 - caml_call1(accept, 93))
      throw caml_maybe_attach_backtrace(Parse_error, 1);
     return [0, 748194550, c$0];
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    var
     r =
       caml_call2(Stdlib_List[38], 886285209, opts)
        ? caml_call1(Re_Core[78], res)
        : res,
     r$0 =
       caml_call2(Stdlib_List[38], 853495711, opts)
        ? caml_call1(Re_Core[53], r)
        : r;
    return r$0;
   }
   function compile(re){
    var _a_ = caml_call1(Re_Core[47], re);
    return caml_call1(Re_Core[2], _a_);
   }
   function compile_pat(opt, s){
    if(opt) var sth = opt[1], opts = sth; else var opts = 0;
    return compile(re([0, opts], s));
   }
   var Re_Posix = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(5, Re_Posix, "Re__Posix");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re
//# unitInfo: Requires: Re__Core, Re__Replace
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Re_Replace = global_data.Re__Replace,
    Group = Re_Core[1],
    compile = Re_Core[2],
    group_count = Re_Core[3],
    group_names = Re_Core[4],
    exec = Re_Core[5],
    exec_opt = Re_Core[6],
    execp = Re_Core[7],
    exec_partial = Re_Core[8],
    exec_partial_detailed = Re_Core[9],
    Mark = Re_Core[10],
    all = Re_Core[11],
    all_gen = Re_Core[12],
    all_seq = Re_Core[13],
    matches = Re_Core[14],
    matches_gen = Re_Core[15],
    matches_seq = Re_Core[16],
    split = Re_Core[17],
    split_delim = Re_Core[18],
    split_gen = Re_Core[19],
    split_seq = Re_Core[20],
    split_full = Re_Core[21],
    split_full_gen = Re_Core[22],
    split_full_seq = Re_Core[23],
    Seq = Re_Core[24],
    str = Re_Core[25],
    char$0 = Re_Core[26],
    alt = Re_Core[27],
    seq = Re_Core[28],
    empty = Re_Core[29],
    epsilon = Re_Core[30],
    rep = Re_Core[31],
    rep1 = Re_Core[32],
    repn = Re_Core[33],
    opt = Re_Core[34],
    bol = Re_Core[35],
    eol = Re_Core[36],
    bow = Re_Core[37],
    eow = Re_Core[38],
    bos = Re_Core[39],
    eos = Re_Core[40],
    leol = Re_Core[41],
    start = Re_Core[42],
    stop = Re_Core[43],
    word = Re_Core[44],
    not_boundary = Re_Core[45],
    whole_string = Re_Core[46],
    longest = Re_Core[47],
    shortest = Re_Core[48],
    first = Re_Core[49],
    greedy = Re_Core[50],
    non_greedy = Re_Core[51],
    group = Re_Core[52],
    no_group = Re_Core[53],
    nest = Re_Core[54],
    mark = Re_Core[55],
    set = Re_Core[56],
    rg = Re_Core[57],
    inter = Re_Core[58],
    diff = Re_Core[59],
    compl = Re_Core[60],
    any = Re_Core[61],
    notnl = Re_Core[62],
    alnum = Re_Core[63],
    wordc = Re_Core[64],
    alpha = Re_Core[65],
    ascii = Re_Core[66],
    blank = Re_Core[67],
    cntrl = Re_Core[68],
    digit = Re_Core[69],
    graph = Re_Core[70],
    lower = Re_Core[71],
    print = Re_Core[72],
    punct = Re_Core[73],
    space = Re_Core[74],
    upper = Re_Core[75],
    xdigit = Re_Core[76],
    case$0 = Re_Core[77],
    no_case = Re_Core[78],
    pp = Re_Core[79],
    pp_re = Re_Core[80],
    print_re = Re_Core[81],
    witness = Re_Core[82],
    get = Re_Core[83],
    get_ofs = Re_Core[84],
    get_all = Re_Core[85],
    get_all_ofs = Re_Core[86],
    test = Re_Core[87],
    marked = Re_Core[88],
    mark_set = Re_Core[89],
    replace = Re_Replace[1],
    replace_string = Re_Replace[2],
    Re =
      [0,
       Group,
       compile,
       group_count,
       group_names,
       exec,
       exec_opt,
       execp,
       exec_partial,
       exec_partial_detailed,
       Mark,
       all,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split,
       split_delim,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       Seq,
       str,
       char$0,
       alt,
       seq,
       empty,
       epsilon,
       rep,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start,
       stop,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark,
       set,
       rg,
       inter,
       diff,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp,
       pp_re,
       print_re,
       witness,
       get,
       get_ofs,
       get_all,
       get_all_ofs,
       test,
       marked,
       mark_set,
       replace,
       replace_string];
   runtime.caml_register_global(2, Re, "Re");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJyZS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsibGVuZ3RoIiwidCIsInNldCIsInYiLCJuIiwiYiIsImkiLCJjIiwibWFzayIsIngiLCJzIiwiZ2V0IiwicmVzZXRfemVybyIsImNyZWF0ZV96ZXJvIiwibGVuIiwiciIsInEiLCJsZW4kMCIsImJpdHMiLCJlcXVhbCIsInkiLCJjb21wYXJlIiwidG9faW50IiwicHAiLCJpbnRlcnNlY3QiLCJzeW1ib2wiLCJkdW1teSIsImluZXhpc3RhbnQiLCJsZXR0ZXIiLCJub3RfbGV0dGVyIiwibmV3bGluZSIsImxhc3RuZXdsaW5lIiwic2VhcmNoX2JvdW5kYXJ5IiwiZnJvbV9jaGFyIiwic2V4cCIsImZtdCIsInBhaXIiLCJwcDEiLCJwcDIiLCJ2MiIsInYxIiwidHJpcGxlIiwicHAzIiwidjMiLCJvcHRpbnQiLCJwcF9lbGVtIiwicHBfc3RyX2xpc3QiLCJ0b190b19zdHJpbmciLCJjYW55Iiwib2ZfaW50IiwidG9fY2hhciIsIm9mX2NoYXIiLCJ5JDAiLCJ4JDAiLCJ1bmlvbiIsImwkMCIsImwiLCJsJDIiLCJsJDEiLCJjMiIsImMxIiwiciQwIiwiYzIkMCIsImMxJDAiLCJsJDMiLCJsJDQiLCJpbnRlciIsImRpZmYiLCJyJDEiLCJzaW5nbGUiLCJhZGQiLCJzZXEiLCJjJDAiLCJvZmZzZXQiLCJvIiwidW5pb25fYWxsIiwiaW50ZXJzZWN0X2FsbCIsImVtcHR5IiwibWVtIiwicyQwIiwicmVtIiwiaGFzaF9yZWMiLCJqIiwiaGFzaCIsInByaW50X29uZSIsImNoIiwiaXRlciIsImYiLCJ0JDAiLCJ4cyIsIm9uZV9jaGFyIiwidSIsImZvbGRfcmlnaHQiLCJpbml0IiwiY3NpbmdsZSIsImlzX2VtcHR5IiwicHJlcGVuZCIsImQiLCJkJDAiLCJwaWNrIiwiY3NlcSIsInVwcGVyIiwiY2xvd2VyIiwiY2RpZ2l0IiwiYXNjaWkiLCJjYWRkIiwic3BhY2UiLCJ4ZGlnaXQiLCJjYWxwaGEiLCJjYWxudW0iLCJjYXNlX2luc2VucyIsImN3b3JkIiwibm90bmwiLCJubCIsInN0ciIsImJsYW5rIiwibG93ZXIiLCJhbHBoYSIsImFsbnVtIiwid29yZGMiLCJjbnRybCIsImdyYXBoIiwicHJpbnQiLCJwdW5jdCIsIm1ha2UiLCJtYXJrcyIsIm1hIiwidGVzdCIsInN0YXJ0X2kiLCJzdG9wX2kiLCJzdGFydCIsInN0b3AiLCJpdGVyaSIsImlkeCIsImdlbiIsImVwc19leHByIiwiY3JlYXRlIiwiayIsInBwJDAiLCJwcmV2IiwibmV4dCIsIm5leHQyIiwiZ3JvdXBfY291bnQiLCJoYXNoX2NvbWJpbmUiLCJoIiwiYWNjdSIsImVxdWFsJDAiLCJwbWFya3MiLCJtZXJnZV9tYXJrc19vZmZzZXQiLCJvbGQiLCJudyIsIm1lcmdlIiwibSIsImFjY3UkMSIsImFjY3UkMiIsImEiLCJhY2N1JDAiLCJtYXJrc19zZXRfaWR4IiwibWFya3Nfc2V0X2lkeCQwIiwiZmlsdGVyIiwiZSIsInNldF9tYXJrIiwicHAkMSIsImUkMCIsImUkMSIsImUkMiIsImskMCIsImUkMyIsImkkMCIsIm1rX2V4cHIiLCJpZHMiLCJkZWYiLCJlbXB0eSQwIiwiY3N0IiwiYWx0Iiwia2luZCIsImlzX2VwcyIsImV4cHIiLCJlcHMiLCJyZXAiLCJzZW0iLCJtYXJrIiwicG1hcmsiLCJlcmFzZSIsIm0kMCIsImJlZm9yZSIsImFmdGVyIiwicmVuYW1lIiwieiIsImciLCJpc190bWF0Y2giLCJlcXVhbCQxIiwibDEiLCJsMiIsImwxJDAiLCJsMiQwIiwicjEiLCJlMSIsImwxJDEiLCJyMiIsImUyIiwibDIkMSIsInIxJDAiLCJlMSQwIiwibWFya3MxIiwicjIkMCIsImUyJDAiLCJtYXJrczIiLCJyMSQxIiwibWFya3MxJDAiLCJyMiQxIiwibWFya3MyJDAiLCJoYXNoJDAiLCJtYXJrcyQwIiwiYWNjdSQzIiwidHNlcSIsImZpcnN0X21hdGNoIiwicmVtb3ZlX21hdGNoZXMiLCJzcGxpdF9hdF9tYXRjaCIsImV4aXN0c190bWF0Y2giLCJzZXRfaWR4IiwibWsiLCJjYXQiLCJkZXNjIiwiY3JlYXRlJDAiLCJlcXVhbCQyIiwic3RhdHVzIiwic3QiLCJzdCQwIiwiaGFzaCQxIiwiY3JlYXRlJDEiLCJpbmRleF9jb3VudCIsInciLCJtYXJrX3VzZWRfaW5kaWNlcyIsInRibCIsImZyZWVfaW5kZXgiLCJ0YmxfcmVmIiwiaWR4JDAiLCJyZW1vdmVfZHVwbGljYXRlcyIsInByZXYkMCIsInByZXYkMSIsInByZXYkMiIsInIkMiIsInIkMyIsIngkMSIsInByZXYkMyIsInIkNCIsImRlbHRhXzEkMCIsImN0eCIsImRlbHRhX2FsdCQwIiwiZGVsdGFfMSIsImRlbHRhX3NlcSQwIiwieSQxIiwia2luZCQwIiwicmVwX2tpbmQiLCJ5JDIiLCJtYXJrcyQxIiwibWFya3MkMiIsInkkMyIsIm1hcmtzJDMiLCJjYXQkMCIsImRlbHRhX2FsdCIsImN0eCQwIiwiZGVsdGFfc2VxIiwiZGVsdGFfNCIsInJlbSQwIiwiZGVsdGEiLCJuZXh0X2NhdCIsImNoYXIkMCIsInByZXZfY2F0IiwiZXhwciQwIiwicmVkX3RyIiwidHIyIiwic3QyIiwiczIiLCJ0cjEiLCJzdDEiLCJzMSIsInByZXBlbmRfZGVyaXYiLCJyZXN0cmljdCIsInMkMSIsInByZXBlbmRfbWFya3NfZXhwcl9sc3QiLCJtJDEiLCJkZXJpdl8xJDAiLCJhbGxfY2hhcnMiLCJjYXRlZ29yaWVzIiwicmVtJDIiLCJkZXJpdl8yJDAiLCJkZXJpdl8xIiwiZGVyaXZfc2VxIiwieiQwIiwicmVtJDEiLCJjYXQkMSIsImRlcml2XzIiLCJ4bCIsInokMSIsImRlcml2XzQiLCJkZXJpdiIsImRlciIsImV4cHIkMSIsInJlcHIiLCJjb2xvciIsImdldF9jaGFyIiwidHJhbnNsYXRlX2NvbG9ycyIsImNtIiwiY3NldCIsImZsYXR0ZW4iLCJjb2xvcl9yZXByIiwic3BsaXQiLCJlbXB0eV9hbHRlcm5hdGl2ZSIsInBwX2FzdCIsImFzdCIsInZhciQwIiwicmUiLCJwcF9nZW4iLCJwcF9jc2V0IiwicmVsIiwiYyQxIiwiYyQyIiwiYSQwIiwicmUkMCIsIngxIiwieDIiLCJ4MSQwIiwieDIkMCIsImVxIiwiajIiLCJpMiIsIngyJDEiLCJqMSIsImkxIiwieDEkMSIsIngyJDIiLCJ4MSQyIiwibTIiLCJtMSIsIngyJDMiLCJ4MSQzIiwic2VtJDAiLCJ4MiQ0IiwieDEkNCIsInJlcCQwIiwiaGFuZGxlX2Nhc2VfY3NldCIsImlnbl9jYXNlJDAiLCJoYW5kbGVfY2FzZSIsInIkNSIsInIkNiIsInIkNyIsInIkOCIsInIkOSIsImFzX3NldF9lbGVtcyIsImVsZW1zIiwiZWxlbXMkMCIsImVwc2lsb24iLCJyZXBuIiwiaiQwIiwicmVwMSIsIm9wdCIsImJvbCIsImVvbCIsImJvdyIsImVvdyIsIndvcmQiLCJub3RfYm91bmRhcnkiLCJib3MiLCJlb3MiLCJ3aG9sZV9zdHJpbmciLCJsZW9sIiwibWFrZV9zZXQiLCJwcmVzZXJ2ZV9zZXQiLCJsb25nZXN0Iiwic2hvcnRlc3QiLCJmaXJzdCIsImdyZWVkeSIsIm5vbl9ncmVlZHkiLCJncm91cCIsIm5hbWUiLCJub19ncm91cCIsIm5lc3QiLCJhc19zZXRfb3JfZXJyb3IiLCJjb21wbCIsImNhc2UkMCIsImYkMCIsIm5vX2Nhc2UiLCJ3aXRuZXNzIiwiZnJvbSIsIm1lcmdlX3NlcXVlbmNlcyIsImNvbG9yaXplIiwiY29sb3JfbWFwIiwicmVnZXhwIiwibG5sIiwicmVnZXhwJDAiLCJyZWdleHAkMSIsInJlZ2V4cCQyIiwicmVnZXhwJDMiLCJhbmNob3JlZCIsImFscyIsInRfb2ZfY3NldCIsInZpZXdfYXN0IiwiYSQxIiwidmlldyIsInNldHMiLCJzZXRzJDAiLCJ0JDEiLCJ0JDIiLCJkdW1teV9vZmZzZXQiLCJwMiIsInAxIiwic3VicyIsImdldF9vcHQiLCJhbGxfb2Zmc2V0IiwicmVzIiwiYWxsIiwib2Zmc2V0cyIsInN0cnMiLCJtYXRjaGVzIiwicHBfbWF0Y2giLCJuYl9ncm91cHMiLCJuJDAiLCJ2JDAiLCJ2JDEiLCJuJDEiLCJ1bmtub3duIiwiYnJlYWskMCIsImZvbGxvd190cmFuc2l0aW9uIiwicGFyYW0iLCJzZXRfdHJhbnNpdGlvbiIsInVua25vd25fc3RhdGUiLCJwcF9yZSIsImdyb3VwX25hbWVzIiwiY2F0ZWdvcnkiLCJmaW5kX3N0YXRlIiwibmNvbCQwIiwiYnJlYWtfc3RhdGUiLCJyZWFsX2lkeCIsImJyZWFrJDEiLCJzdGF0ZSIsIm5jb2wiLCJpbmZvIiwicG9zIiwidmFsaWRhdGUiLCJjb2xvcnMiLCJnZXRfY29sb3IiLCJzbGVuIiwic2Nhbl9zdHIiLCJpbmZvJDAiLCJpbml0aWFsX3N0YXRlIiwiZ3JvdXBzIiwicG9zJDMiLCJsYXN0IiwiaW5mbyQxIiwic3QkMyIsInBvcyQ0Iiwic3QkMSIsInJlYWxfYyIsInN0JDIiLCJwb3NpdGlvbnMkMSIsInBvc2l0aW9ucyIsInN0MCIsInN0MCQwIiwic3RhdGVfaW5mbyIsInBvcyQwIiwicG9zaXRpb25zJDAiLCJjb2xvcnMkMCIsInBvcyQxIiwic3QwJDEiLCJzdDAkMiIsInN0YXRlX2luZm8kMCIsInBvcyQyIiwiZmluYWxfYm91bmRhcnlfY2hlY2siLCJmaW5hbF9jYXQiLCJyZXMkMCIsIm1hdGNoX3N0ciIsInBhcnRpYWwiLCJpbml0aWFsX2NhdCIsInN0YXR1cyQwIiwibm9fbWF0Y2hfc3RhcnRzX2JlZm9yZSIsImVuZm9yY2Vfa2luZCIsImNyIiwidHJhbnNsYXRlIiwiYXN0JDAiLCJjYWNoZSIsIm5hbWVzIiwiaWduX2dyb3VwIiwibWVyZ2VkX3NlcXVlbmNlcyIsInRyYW5zX3NlcSIsImtpbmQkMSIsImNyJDAiLCJhc3QkMSIsInAiLCJraW5kJDIiLCJjciQxIiwiYXN0JDIiLCJjdHgkMSIsImtpbmQkMyIsImNyJDIiLCJpJDEiLCJraW5kJDQiLCJjciQzIiwia2luZCQ1Iiwia2luZCQ2IiwiY3IkNCIsImFzdCQzIiwiZ3JlZWR5JDAiLCJjdHgkMiIsImNvbXBpbGUiLCJuZWVkX2xubCIsIm5jb2xvciIsIm5jb2xvciQwIiwiaW5pdGlhbCIsInN0aCIsImxpbWl0IiwiYXV4Iiwib25fbWF0Y2giLCJvbl9tYXRjaCQwIiwic3Vic3RyIiwic3ViIiwic3BsaXRfZnVsbCIsIm9sZF9pIiwidGV4dCIsInRleHQkMCIsInN0YXRlJDAiLCJzZXEkMCIsInRsIiwic2VxJDEiLCJzcGxpdF9kZWxpbSIsImRlbGltIiwiZGVsaW0kMCIsInJnIiwiYW55IiwiZGlnaXQiLCJleGVjX2ludGVybmFsIiwic3RoJDAiLCJleGVjIiwiZXhlY19vcHQiLCJleGVjcCIsImV4ZWNfcGFydGlhbCIsImV4ZWNfcGFydGlhbF9kZXRhaWxlZCIsIm1hcmtlZCIsIm1hcmtfc2V0IiwiZ2VuX29mX3NlcSIsInNwbGl0X2dlbiIsInNwbGl0X2Z1bGxfZ2VuIiwiYWxsX2dlbiIsIm1hdGNoZXNfZ2VuIiwic3BsaXRfZnVsbF9zZXEiLCJzcGxpdF9zZXEiLCJtYXRjaGVzX3NlcSIsImFsbF9zZXEiLCJnZXRfb2ZzIiwiZ2V0X2FsbCIsImdldF9hbGxfb2ZzIiwibGlzdF9vZl9zZXEiLCJwcmludF9yZSIsInVuZ2V0IiwianVuayIsInRlc3QyIiwiYWNjZXB0IiwiYWNjZXB0MiIsImFjY2VwdF9zIiwiaW50ZWdlciIsImJ1ZiIsImxlZnQiLCJicmFuY2giLCJsZWZ0JDAiLCJsZWZ0JDEiLCJicmFja2V0IiwicyQyIiwiY29tcGlsZV9wYXQiLCJjb21waWxlX3JlZ2V4cCIsInN0cmluZ19tYXRjaCIsInN0cmluZ19wYXJ0aWFsX21hdGNoIiwic2VhcmNoX2ZvcndhcmQiLCJzZWFyY2hfYmFja3dhcmQiLCJwJDAiLCJwJDEiLCJ2YWxpZF9ncm91cCIsIm9mZnNldF9ncm91cCIsInJlcGxhY2VtZW50X3RleHQiLCJyZXBsIiwib3JpZyIsInEkMCIsInEkMSIsInAkMiIsInAkMyIsInEkMiIsInEkMyIsInAkNCIsImIkMCIsInEkNSIsInAkNiIsInEkNCIsInAkNSIsInEkNiIsInAkNyIsInF1b3RlIiwic3RyaW5nX2JlZm9yZSIsInN0cmluZ19hZnRlciIsImZpcnN0X2NoYXJzIiwibGFzdF9jaGFycyIsInJlZ2V4cF9jYXNlX2ZvbGQiLCJyZWdleHBfc3RyaW5nIiwicmVnZXhwX3N0cmluZ19jYXNlX2ZvbGQiLCJncm91cF9iZWdpbm5pbmciLCJncm91cF9lbmQiLCJtYXRjaGVkX2dyb3VwIiwidHh0IiwicmVwbGFjZV9tYXRjaGVkIiwibWF0Y2hlZCIsIm1hdGNoX2JlZ2lubmluZyIsIm1hdGNoX2VuZCIsIm1hdGNoZWRfc3RyaW5nIiwic3Vic3RpdHV0ZV9maXJzdCIsInJlcGxfZnVuIiwiZ2xvYmFsX3N1YnN0aXR1dGUiLCJsYXN0X3dhc19lbXB0eSIsInN0YXJ0cG9zIiwiZW5kX3BvcyIsInJlcGxfdGV4dCIsImxhc3Rfd2FzX2VtcHR5JDAiLCJnbG9iYWxfcmVwbGFjZSIsInJlcGxhY2VfZmlyc3QiLCJzZWFyY2hfZm9yd2FyZF9wcm9ncmVzcyIsImJvdW5kZWRfc3BsaXQiLCJudW0iLCJib3VuZGVkX3NwbGl0X2RlbGltIiwiYm91bmRlZF9mdWxsX3NwbGl0IiwiZnVsbF9zcGxpdCIsInJlcGxhY2UiLCJyZXBsYWNpbmciLCJyZXBsYWNlX3N0cmluZyIsImJ5IiwiYmVnIiwibXVsIiwiZXhwbGljaXRfcGVyaW9kIiwic2xhc2hlcyIsImFwcGVuZCIsInBpZWNlIiwiYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50IiwicmVtYWluaW5nIiwib25lIiwiZXhwbGljaXRfc2xhc2giLCJlbmNsb3NlZCIsImhpZ2giLCJsb3ciLCJlbmNsb3NlZF9zZXQiLCJzZXQkMCIsImVuY2xvc3VyZSIsImV4YWN0bHkiLCJzbGFzaGVzJDAiLCJjaGFycyIsIm1hbnlfbWFueSIsImV4cGxpY2l0X3BlcmlvZCQwIiwiZmlyc3RfZXhwbGljaXRfcGVyaW9kIiwibWF0Y2hfY29tcG9uZW50IiwiZ2xvYiIsInBhdGhuYW1lIiwic3RoJDEiLCJtYXRjaF9iYWNrc2xhc2hlcyIsInN0aCQyIiwicGVyaW9kIiwic3RoJDMiLCJleHBhbmRfYnJhY2VzIiwic3RoJDQiLCJkb3VibGVfYXN0ZXJpc2siLCJ0b19yZSIsInJlYWQiLCJwaWVjZXMiLCJwaWVjZXMkMCIsInN0YXRlJDgiLCJzdGF0ZSQ5IiwiZXhwbGljaXRfc2xhc2gkMCIsImV4cGxpY2l0X3BlcmlvZCQxIiwic2xhc2hlcyQxIiwic3RhdGUkMTAiLCJub3RfZW1wdHkiLCJtYXliZV9lbXB0eSIsImVuY2xvc2VkX3NldCQxIiwiZW5jbG9zZWRfc2V0JDAiLCJzdGF0ZSQyIiwic3RhdGUkNCIsIm5vdF9lbXB0eSQwIiwic3RhdGUkNSIsInN0YXRlJDYiLCJlbmNsb3NlZCQwIiwic3RhdGUkNyIsImVuY2xvc2VkJDEiLCJzdGF0ZSQzIiwic3RhdGUkMSIsImVuY2xvc2VkJDIiLCJlbmNsb3NlZCQzIiwiZXhwbCIsImlubmVyIiwiYWNjIiwiYmVnJDAiLCJhY2MkMCIsImJlZyQxIiwiYWNjJDEiLCJpJDMiLCJiZWckMiIsImkkNCIsImkkMiIsImdsb2IkMCIsImdsb2J4IiwiZ2xvYngkMCIsIm9mX25hbWUiLCJjbGFzcyQwIiwicGFyc2UiLCJjbHMiLCJwb3NpeF9jbGFzcyIsIm9wdHMiLCJ1bmdyZWVkeSIsImRvdGFsbCIsImRvbGxhcl9lbmRvbmx5IiwibXVsdGlsaW5lIiwiZ3JlZWR5X21vZCIsImdyIiwiZ3IkMCIsImF0b20iLCJoZXhkaWdpdCIsImNvZGUiLCJzJDMiLCJwYXQiLCJmbGFncyIsImV4dHJhY3QiLCJyZXgiLCJnZXRfc3Vic3RyaW5nIiwiZ2V0X25hbWVkX3N1YnN0cmluZyIsImdldF9zdWJzdHJpbmdfb2ZzIiwicG1hdGNoIiwic3Vic3RpdHV0ZSIsInN1YnN0Iiwic3MiLCJmaW4iLCJmaW5pc2giLCJsYXN0JDAiLCJtYXgiLCJyZXN1bHRzIl0sInNvdXJjZXMiOlsiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcmUvYml0X3ZlY3Rvci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3JlL2NhdGVnb3J5Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcmUvZm10Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcmUvaW1wb3J0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcmUvY3NldC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3JlL21hcmtfaW5mb3MubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9yZS9wbWFyay5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3JlL2F1dG9tYXRhLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcmUvY29sb3JfbWFwLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcmUvYXN0Lm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcmUvdmlldy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3JlL2dyb3VwLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcmUvY29tcGlsZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3JlL3NlYXJjaC5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3JlL2NvcmUubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9yZS9wYXJzZV9idWZmZXIubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9yZS9lbWFjcy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3JlL3N0ci5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3JlL3JlcGxhY2UubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9yZS9nbG9iLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcmUvcG9zaXhfY2xhc3MubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9yZS9wZXJsLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvcmUvcGNyZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3JlL3Bvc2l4Lm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7OztZQU9JQSxPQUFPQyxHQUFJLE9BQUpBLEtBQVM7WUFTaEJDLElBQUlDLEdBQUVDLEdBQUVDO0lBQ1YsVUFEUUQsNkJBQUZELFFBQUVDO1lBQ29CO0lBTnBCO0tBTEtFLElBVUxGO0tBTEpHLElBQUksc0JBS0ZKLE1BVk9HO0tBTVRFLGFBSUlKO0tBVk9LLElBVUxKLElBTE5FLElBQ0FDLE9BREFELElBRWdELHVCQURoREM7S0FOT0UsSUFVTFA7a0NBVktPLEdBQUVKLEdBQTJCLDJCQUF6Qkc7O0dBWUM7WUFRZEUsSUFBSVIsR0FBRUM7SUFDUixVQURRQSw2QkFBRkQsUUFBRUM7WUFDb0I7UUFMeEJFLElBSUlGO2dCQUhSLHNCQUdNRCxNQUpGRyxXQUlJRjtHQUVNO1lBR1pRLFdBQVdYO0lBQ2IsdUNBRGFBLGVBQ2I7O1NBQUFLOztNQUNFLHVCQUZXTCxNQUNiSztNQUNFLFVBREZBO2lCQUFBQTtVQUFBQTs7OztHQUVJO1lBR0ZPLFlBQVlDO0lBQ2Q7S0FDTUMsSUFGUUQ7S0FHUkUsSUFIUUY7S0FJUkcsY0FGQUYsSUFDQUMsSUFBQUE7S0FGRkUsT0FJRiw0QkFESUQ7SUFH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RytCLHdCQURsQ3ZyQjtVQUFBQTtJQUVKLE9BREk4QztHQUNIO1lBR0M0YixRQUFRaE07SUFBZ0IsVUFBQSx3QkFBaEJBO0lBQWdCLE9BQUE7R0FBZTtZQUN2QytQLFlBQWNuTixLQUFXM1Y7SUFBSSxHQUFmMlYsU0FBT3lKLE1BQVB6SixRQUFBaVcsT0FBT3hNLGNBQVB3TTtJQUF1QixPQURyQzdNLFFBUEFoTSxPQVFjNlksT0FBVzVyQjtHQUF3QjtrREFSakQrUyxJQU9BZ00sU0FDQStEOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsidHlwZSB0ID1cbiAgeyBsZW4gOiBpbnRcbiAgOyBiaXRzIDogQnl0ZXMudFxuICB9XG5cbmxldCBieXRlIHMgaSA9IENoYXIuY29kZSAoQnl0ZXMudW5zYWZlX2dldCBzIGkpXG5sZXQgc2V0X2J5dGUgcyBpIHggPSBCeXRlcy51bnNhZmVfc2V0IHMgaSAoQ2hhci5jaHIgeClcbmxldCBsZW5ndGggdCA9IHQubGVuXG5cbmxldCB1bnNhZmVfc2V0IHYgbiBiID1cbiAgbGV0IGkgPSBuIGxzciAzIGluXG4gIGxldCBjID0gYnl0ZSB2LmJpdHMgaSBpblxuICBsZXQgbWFzayA9IDEgbHNsIChuIGxhbmQgNykgaW5cbiAgc2V0X2J5dGUgdi5iaXRzIGkgKGlmIGIgdGhlbiBjIGxvciBtYXNrIGVsc2UgYyBsYW5kIGxub3QgbWFzaylcbjs7XG5cbmxldCBzZXQgdiBuIGIgPVxuICBpZiBuIDwgMCB8fCBuID49IHYubGVuIHRoZW4gaW52YWxpZF9hcmcgXCJCaXRfdmVjdG9yLnNldFwiO1xuICB1bnNhZmVfc2V0IHYgbiBiXG47O1xuXG5sZXQgdW5zYWZlX2dldCB2IG4gPVxuICBsZXQgaSA9IG4gbHNyIDMgaW5cbiAgYnl0ZSB2LmJpdHMgaSBsYW5kICgxIGxzbCAobiBsYW5kIDcpKSA+IDBcbjs7XG5cbmxldCBnZXQgdiBuID1cbiAgaWYgbiA8IDAgfHwgbiA+PSB2LmxlbiB0aGVuIGludmFsaWRfYXJnIFwiQml0X3ZlY3Rvci5nZXRcIjtcbiAgdW5zYWZlX2dldCB2IG5cbjs7XG5cbmxldCByZXNldF96ZXJvIHQgPVxuICBmb3IgaSA9IDAgdG8gQnl0ZXMubGVuZ3RoIHQuYml0cyAtIDEgZG9cbiAgICBCeXRlcy5zZXQgdC5iaXRzIGkgJ1xcMDAwJ1xuICBkb25lXG47O1xuXG5sZXQgY3JlYXRlX3plcm8gbGVuID1cbiAgbGV0IGJpdHMgPVxuICAgIGxldCByID0gbGVuIGxhbmQgNyBpblxuICAgIGxldCBxID0gbGVuIGxzciAzIGluXG4gICAgbGV0IGxlbiA9IGlmIHIgPSAwIHRoZW4gcSBlbHNlIHEgKyAxIGluXG4gICAgQnl0ZXMubWFrZSBsZW4gJ1xcMDAwJ1xuICBpblxuICB7IGxlbjsgYml0cyB9XG47O1xuIiwidHlwZSB0ID0gaW50XG5cbmxldCBlcXVhbCAoeCA6IGludCkgKHkgOiBpbnQpID0geCA9IHlcbmxldCBjb21wYXJlICh4IDogaW50KSAoeSA6IGludCkgPSBjb21wYXJlIHggeVxubGV0IHRvX2ludCB4ID0geFxubGV0IHBwID0gRm9ybWF0LnBwX3ByaW50X2ludFxubGV0IGludGVyc2VjdCB4IHkgPSB4IGxhbmQgeSA8PiAwXG5sZXQgKCArKyApIHggeSA9IHggbG9yIHlcbmxldCBkdW1teSA9IC0xXG5sZXQgaW5leGlzdGFudCA9IDFcbmxldCBsZXR0ZXIgPSAyXG5sZXQgbm90X2xldHRlciA9IDRcbmxldCBuZXdsaW5lID0gOFxubGV0IGxhc3RuZXdsaW5lID0gMTZcbmxldCBzZWFyY2hfYm91bmRhcnkgPSAzMlxuXG5sZXQgZnJvbV9jaGFyID0gZnVuY3Rpb25cbiAgKCogU2hvdWxkIG1hdGNoIFtjd29yZF0gZGVmaW5pdGlvbiAqKVxuICB8ICdhJyAuLiAneidcbiAgfCAnQScgLi4gJ1onXG4gIHwgJzAnIC4uICc5J1xuICB8ICdfJyB8ICdcXDE3MCcgfCAnXFwxODEnIHwgJ1xcMTg2J1xuICB8ICdcXDE5MicgLi4gJ1xcMjE0J1xuICB8ICdcXDIxNicgLi4gJ1xcMjQ2J1xuICB8ICdcXDI0OCcgLi4gJ1xcMjU1JyAtPiBsZXR0ZXJcbiAgfCAnXFxuJyAtPiBub3RfbGV0dGVyICsrIG5ld2xpbmVcbiAgfCBfIC0+IG5vdF9sZXR0ZXJcbjs7XG4iLCIoKiogVmVyeSBzbWFsbCB0b29saW5nIGZvciBmb3JtYXQgcHJpbnRlcnMuICopXG5cbmluY2x1ZGUgRm9ybWF0XG5cbnR5cGUgJ2EgdCA9IEZvcm1hdC5mb3JtYXR0ZXIgLT4gJ2EgLT4gdW5pdFxuXG5sZXQgbGlzdCA9IHBwX3ByaW50X2xpc3RcbmxldCBzdHIgPSBwcF9wcmludF9zdHJpbmdcbmxldCBzZXhwIGZtdCBzIHBwIHggPSBmcHJpbnRmIGZtdCBcIkBbPDM+KCVzQCAlYSlAXVwiIHMgcHAgeFxuXG5sZXQgcGFpciBwcDEgcHAyIGZtdCAodjEsIHYyKSA9XG4gIHBwMSBmbXQgdjE7XG4gIHBwX3ByaW50X3NwYWNlIGZtdCAoKTtcbiAgcHAyIGZtdCB2MlxuOztcblxubGV0IHRyaXBsZSBwcDEgcHAyIHBwMyBmbXQgKHYxLCB2MiwgdjMpID1cbiAgcHAxIGZtdCB2MTtcbiAgcHBfcHJpbnRfc3BhY2UgZm10ICgpO1xuICBwcDIgZm10IHYyO1xuICBwcF9wcmludF9zcGFjZSBmbXQgKCk7XG4gIHBwMyBmbXQgdjNcbjs7XG5cbmxldCBpbnQgPSBwcF9wcmludF9pbnRcblxubGV0IG9wdGludCBmbXQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGkgLT4gZnByaW50ZiBmbXQgXCJAICVkXCIgaVxuOztcblxubGV0IHF1b3RlIGZtdCBzID0gRm9ybWF0LmZwcmludGYgZm10IFwiXFxcIiVzXFxcIlwiIHNcblxubGV0IHBwX29saXN0IHBwX2VsZW0gZm10ID1cbiAgRm9ybWF0LmZwcmludGZcbiAgICBmbXRcbiAgICBcIkBbPDM+W0AgJWFAIF1AXVwiXG4gICAgKHBwX3ByaW50X2xpc3QgfnBwX3NlcDooZnVuIGZtdCAoKSAtPiBmcHJpbnRmIGZtdCBcIjtAIFwiKSBwcF9lbGVtKVxuOztcblxubGV0IHBwX3N0cl9saXN0ID0gcHBfb2xpc3QgcXVvdGVcblxubGV0IHRvX3RvX3N0cmluZyBwcCB4ID1cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDE2IGluXG4gIGxldCBmbXQgPSBGb3JtYXQuZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIHBwIGZtdCB4O1xuICBCdWZmZXIuY29udGVudHMgYlxuOztcbiIsIm1vZHVsZSBMaXN0ID0gU3RkbGliLkxpc3RMYWJlbHNcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgbGV0IGVxdWFsID0gKCA9IClcbmVuZFxuXG5sZXQgKCA9ICkgPSBJbnQuZXF1YWxcbiIsIm1vZHVsZSBMaXN0ID0gc3RydWN0IGVuZFxub3BlbiBJbXBvcnRcblxuKCpcbiAgIFJFIC0gQSByZWd1bGFyIGV4cHJlc3Npb24gbGlicmFyeVxuXG4gICBDb3B5cmlnaHQgKEMpIDIwMDEgSmVyb21lIFZvdWlsbG9uXG4gICBlbWFpbDogSmVyb21lLlZvdWlsbG9uQHBwcy5qdXNzaWV1LmZyXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGhcbiAgIGxpbmtpbmcgZXhjZXB0aW9uOyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdFxuICAgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuICAgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICAgRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQVxuKilcblxudHlwZSBjID0gaW50XG5cbmxldCB0b19pbnQgeCA9IHhcbmxldCBvZl9pbnQgeCA9IHhcbmxldCB0b19jaGFyIHQgPSBDaGFyLmNociB0XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcblxudHlwZSB0ID0gKGMgKiBjKSBsaXN0XG5cbmxldCBlcXVhbCA9IExpc3QuZXF1YWwgfmVxOihmdW4gKHgsIHkpICh4JywgeScpIC0+IEludC5lcXVhbCB4IHgnICYmIEludC5lcXVhbCB5IHknKVxuXG5sZXQgcmVjIHVuaW9uIGwgbCcgPVxuICBtYXRjaCBsLCBsJyB3aXRoXG4gIHwgXywgW10gLT4gbFxuICB8IFtdLCBfIC0+IGwnXG4gIHwgKGMxLCBjMikgOjogciwgKGMxJywgYzInKSA6OiByJyAtPlxuICAgIGlmIGMyICsgMSA8IGMxJ1xuICAgIHRoZW4gKGMxLCBjMikgOjogdW5pb24gciBsJ1xuICAgIGVsc2UgaWYgYzInICsgMSA8IGMxXG4gICAgdGhlbiAoYzEnLCBjMicpIDo6IHVuaW9uIGwgcidcbiAgICBlbHNlIGlmIGMyIDwgYzInXG4gICAgdGhlbiB1bmlvbiByICgobWluIGMxIGMxJywgYzInKSA6OiByJylcbiAgICBlbHNlIHVuaW9uICgobWluIGMxIGMxJywgYzIpIDo6IHIpIHInXG47O1xuXG5sZXQgcmVjIGludGVyIGwgbCcgPVxuICBtYXRjaCBsLCBsJyB3aXRoXG4gIHwgXywgW10gLT4gW11cbiAgfCBbXSwgXyAtPiBbXVxuICB8IChjMSwgYzIpIDo6IHIsIChjMScsIGMyJykgOjogcicgLT5cbiAgICBpZiBjMiA8IGMxJ1xuICAgIHRoZW4gaW50ZXIgciBsJ1xuICAgIGVsc2UgaWYgYzInIDwgYzFcbiAgICB0aGVuIGludGVyIGwgcidcbiAgICBlbHNlIGlmIGMyIDwgYzInXG4gICAgdGhlbiAobWF4IGMxIGMxJywgYzIpIDo6IGludGVyIHIgbCdcbiAgICBlbHNlIChtYXggYzEgYzEnLCBjMicpIDo6IGludGVyIGwgcidcbjs7XG5cbmxldCByZWMgZGlmZiBsIGwnID1cbiAgbWF0Y2ggbCwgbCcgd2l0aFxuICB8IF8sIFtdIC0+IGxcbiAgfCBbXSwgXyAtPiBbXVxuICB8IChjMSwgYzIpIDo6IHIsIChjMScsIGMyJykgOjogcicgLT5cbiAgICBpZiBjMiA8IGMxJ1xuICAgIHRoZW4gKGMxLCBjMikgOjogZGlmZiByIGwnXG4gICAgZWxzZSBpZiBjMicgPCBjMVxuICAgIHRoZW4gZGlmZiBsIHInXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcicnID0gaWYgYzInIDwgYzIgdGhlbiAoYzInICsgMSwgYzIpIDo6IHIgZWxzZSByIGluXG4gICAgICBpZiBjMSA8IGMxJyB0aGVuIChjMSwgYzEnIC0gMSkgOjogZGlmZiByJycgcicgZWxzZSBkaWZmIHInJyByJylcbjs7XG5cbmxldCBzaW5nbGUgYyA9IFsgYywgYyBdXG5sZXQgYWRkIGMgbCA9IHVuaW9uIChzaW5nbGUgYykgbFxubGV0IHNlcSBjIGMnID0gaWYgYyA8PSBjJyB0aGVuIFsgYywgYycgXSBlbHNlIFsgYycsIGMgXVxuXG5sZXQgcmVjIG9mZnNldCBvIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IChjMSwgYzIpIDo6IHIgLT4gKGMxICsgbywgYzIgKyBvKSA6OiBvZmZzZXQgbyByXG47O1xuXG5sZXQgZW1wdHkgPSBbXVxubGV0IGNhbnkgPSBbIDAsIDI1NSBdXG5sZXQgdW5pb25fYWxsIDogdCBsaXN0IC0+IHQgPSBMaXN0LmZvbGRfbGVmdCB+aW5pdDplbXB0eSB+Zjp1bmlvblxubGV0IGludGVyc2VjdF9hbGwgOiB0IGxpc3QgLT4gdCA9IExpc3QuZm9sZF9sZWZ0IH5pbml0OmNhbnkgfmY6aW50ZXJcblxubGV0IHJlYyBtZW0gKGMgOiBpbnQpIHMgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBbXSAtPiBmYWxzZVxuICB8IChjMSwgYzIpIDo6IHJlbSAtPiBpZiBjIDw9IGMyIHRoZW4gYyA+PSBjMSBlbHNlIG1lbSBjIHJlbVxuOztcblxuKCoqKiopXG5cbnR5cGUgaGFzaCA9IGludFxuXG5sZXQgcmVjIGhhc2hfcmVjID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAwXG4gIHwgKGksIGopIDo6IHIgLT4gaSArICgxMyAqIGopICsgKDI1NyAqIGhhc2hfcmVjIHIpXG47O1xuXG5sZXQgaGFzaCBsID0gaGFzaF9yZWMgbCBsYW5kIDB4M0ZGRkZGRkZcblxuKCoqKiopXG5cbmxldCBwcmludF9vbmUgY2ggKGMxLCBjMikgPVxuICBpZiBJbnQuZXF1YWwgYzEgYzIgdGhlbiBGb3JtYXQuZnByaW50ZiBjaCBcIiVkXCIgYzEgZWxzZSBGb3JtYXQuZnByaW50ZiBjaCBcIiVkLSVkXCIgYzEgYzJcbjs7XG5cbmxldCBwcCA9IEZtdC5saXN0IHByaW50X29uZVxuXG5sZXQgcmVjIGl0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+ICgpXG4gIHwgKHgsIHkpIDo6IHhzIC0+XG4gICAgZiB4IHk7XG4gICAgaXRlciB4cyB+ZlxuOztcblxubGV0IG9uZV9jaGFyID0gZnVuY3Rpb25cbiAgfCBbIChpLCBqKSBdIHdoZW4gSW50LmVxdWFsIGkgaiAtPiBTb21lIGlcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbm1vZHVsZSBDU2V0TWFwID0gTWFwLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgdCA9IGludCAqIChpbnQgKiBpbnQpIGxpc3RcblxuICAgIGxldCBjb21wYXJlIChpLCB1KSAoaiwgdikgPVxuICAgICAgbGV0IGMgPSBjb21wYXJlIGkgaiBpblxuICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlIGNvbXBhcmUgdSB2XG4gICAgOztcbiAgZW5kKVxuXG5sZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gTGlzdC5mb2xkX3JpZ2h0IH5mIHQgfmluaXRcbmxldCBjc2luZ2xlIGMgPSBzaW5nbGUgKENoYXIuY29kZSBjKVxuXG5sZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICB8IFtdIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgcmVjIHByZXBlbmQgcyB4IGwgPVxuICBtYXRjaCBzLCBsIHdpdGhcbiAgfCBbXSwgXyAtPiBsXG4gIHwgX3IsIFtdIC0+IFtdXG4gIHwgKF9jLCBjJykgOjogciwgKFsgKGQsIF9kJykgXSwgX3gnKSA6OiBfcicgd2hlbiBjJyA8IGQgLT4gcHJlcGVuZCByIHggbFxuICB8IChjLCBjJykgOjogciwgKFsgKGQsIGQnKSBdLCB4JykgOjogcicgLT5cbiAgICBpZiBjIDw9IGRcbiAgICB0aGVuXG4gICAgICBpZiBjJyA8IGQnXG4gICAgICB0aGVuIChbIGQsIGMnIF0sIHggQCB4JykgOjogcHJlcGVuZCByIHggKChbIGMnICsgMSwgZCcgXSwgeCcpIDo6IHInKVxuICAgICAgZWxzZSAoWyBkLCBkJyBdLCB4IEAgeCcpIDo6IHByZXBlbmQgcyB4IHInXG4gICAgZWxzZSBpZiBjID4gZCdcbiAgICB0aGVuIChbIGQsIGQnIF0sIHgnKSA6OiBwcmVwZW5kIHMgeCByJ1xuICAgIGVsc2UgKFsgZCwgYyAtIDEgXSwgeCcpIDo6IHByZXBlbmQgcyB4ICgoWyBjLCBkJyBdLCB4JykgOjogcicpXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2Vcbjs7XG5cbmxldCBwaWNrID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBpbnZhbGlkX2FyZyBcIlJlX2NzZXQucGlja1wiXG4gIHwgKHgsIF8pIDo6IF8gLT4geFxuOztcblxubGV0IGNzZXEgYyBjJyA9IHNlcSAob2ZfY2hhciBjKSAob2ZfY2hhciBjJylcbmxldCByZyA9IGNzZXFcbmxldCBjaGFyID0gY3NpbmdsZVxubGV0IHVwcGVyID0gdW5pb25fYWxsIFsgY3NlcSAnQScgJ1onOyBjc2VxICdcXDE5MicgJ1xcMjE0JzsgY3NlcSAnXFwyMTYnICdcXDIyMicgXVxubGV0IGNsb3dlciA9IG9mZnNldCAzMiB1cHBlclxubGV0IGNkaWdpdCA9IGNzZXEgJzAnICc5J1xubGV0IGFzY2lpID0gY3NlcSAnXFwwMDAnICdcXDEyNydcbmxldCBjYWRkIGMgcyA9IGFkZCAob2ZfY2hhciBjKSBzXG5sZXQgc3BhY2UgPSBhZGQgKG9mX2NoYXIgJyAnKSAoY3NlcSAnXFwwMDknICdcXDAxMycpXG5sZXQgeGRpZ2l0ID0gdW5pb25fYWxsIFsgY2RpZ2l0OyBjc2VxICdhJyAnZic7IGNzZXEgJ0EnICdGJyBdXG5cbmxldCBjYWxwaGEgPVxuICBMaXN0LmZvbGRfcmlnaHRcbiAgICB+ZjpjYWRkXG4gICAgWyAnXFwxNzAnOyAnXFwxODEnOyAnXFwxODYnOyAnXFwyMjMnOyAnXFwyNTUnIF1cbiAgICB+aW5pdDoodW5pb24gY2xvd2VyIHVwcGVyKVxuOztcblxubGV0IGNhbG51bSA9IHVuaW9uIGNhbHBoYSBjZGlnaXRcblxubGV0IGNhc2VfaW5zZW5zIHMgPVxuICB1bmlvbl9hbGwgWyBzOyBvZmZzZXQgMzIgKGludGVyIHMgdXBwZXIpOyBvZmZzZXQgKC0zMikgKGludGVyIHMgY2xvd2VyKSBdXG47O1xuXG5sZXQgY3dvcmQgPSBjYWRkICdfJyBjYWxudW1cbmxldCBub3RubCA9IGRpZmYgY2FueSAoY3NpbmdsZSAnXFxuJylcbmxldCBubCA9IGNzaW5nbGUgJ1xcbidcblxubGV0IHNldCBzdHIgPVxuICBsZXQgcyA9IHJlZiBlbXB0eSBpblxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdHIgLSAxIGRvXG4gICAgcyA6PSB1bmlvbiAoY3NpbmdsZSBzdHIuW2ldKSAhc1xuICBkb25lO1xuICAhc1xuOztcblxubGV0IGJsYW5rID0gc2V0IFwiXFx0IFwiXG5cbigqIENSIHJncmluYmVyZzogdGhpcyBbbG93ZXJdIGRvZXNuJ3QgbWF0Y2ggW2Nsb3dlcl0gKilcbmxldCBsb3dlciA9IHVuaW9uX2FsbCBbIHJnICdhJyAneic7IGNoYXIgJ1xcMTgxJzsgcmcgJ1xcMjIzJyAnXFwyNDYnOyByZyAnXFwyNDgnICdcXDI1NScgXVxubGV0IGFscGhhID0gdW5pb25fYWxsIFsgbG93ZXI7IHVwcGVyOyBjaGFyICdcXDE3MCc7IGNoYXIgJ1xcMTg2JyBdXG5sZXQgYWxudW0gPSB1bmlvbl9hbGwgWyBhbHBoYTsgY2RpZ2l0IF1cbmxldCB3b3JkYyA9IHVuaW9uX2FsbCBbIGFsbnVtOyBjaGFyICdfJyBdXG5sZXQgY250cmwgPSB1bmlvbl9hbGwgWyByZyAnXFwwMDAnICdcXDAzMSc7IHJnICdcXDEyNycgJ1xcMTU5JyBdXG5sZXQgZ3JhcGggPSB1bmlvbl9hbGwgWyByZyAnXFwwMzMnICdcXDEyNic7IHJnICdcXDE2MCcgJ1xcMjU1JyBdXG5sZXQgcHJpbnQgPSB1bmlvbl9hbGwgWyByZyAnXFwwMzInICdcXDEyNic7IHJnICdcXDE2MCcgJ1xcMjU1JyBdXG5cbmxldCBwdW5jdCA9XG4gIHVuaW9uX2FsbFxuICAgIFsgcmcgJ1xcMDMzJyAnXFwwNDcnXG4gICAgOyByZyAnXFwwNTgnICdcXDA2NCdcbiAgICA7IHJnICdcXDA5MScgJ1xcMDk2J1xuICAgIDsgcmcgJ1xcMTIzJyAnXFwxMjYnXG4gICAgOyByZyAnXFwxNjAnICdcXDE2OSdcbiAgICA7IHJnICdcXDE3MScgJ1xcMTgwJ1xuICAgIDsgcmcgJ1xcMTgyJyAnXFwxODUnXG4gICAgOyByZyAnXFwxODcnICdcXDE5MSdcbiAgICA7IGNoYXIgJ1xcMjE1J1xuICAgIDsgY2hhciAnXFwyNDcnXG4gICAgXVxuOztcbiIsInR5cGUgdCA9IGludCBhcnJheVxuXG5sZXQgbWFrZSBtYXJrcyA9XG4gIGxldCBsZW4gPSAxICsgTGlzdC5mb2xkX2xlZnQgKGZ1biBtYSAoaSwgXykgLT4gbWF4IG1hIGkpICgtMSkgbWFya3MgaW5cbiAgbGV0IHQgPSBBcnJheS5tYWtlIGxlbiAoLTEpIGluXG4gIExpc3QuaXRlciAoZnVuIChpLCB2KSAtPiB0LihpKSA8LSB2KSBtYXJrcztcbiAgdFxuOztcblxubGV0IHRlc3QgdCBpID0gaWYgMiAqIGkgPj0gQXJyYXkubGVuZ3RoIHQgdGhlbiBmYWxzZSBlbHNlIHQuKDIgKiBpKSA8PiAtMVxuXG5sZXQgb2Zmc2V0IHQgaSA9XG4gIGxldCBzdGFydF9pID0gMiAqIGkgaW5cbiAgbGV0IHN0b3BfaSA9IHN0YXJ0X2kgKyAxIGluXG4gIGlmIHN0b3BfaSA+PSBBcnJheS5sZW5ndGggdFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHN0YXJ0ID0gdC4oc3RhcnRfaSkgaW5cbiAgICBpZiBzdGFydCA9IC0xXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSAoXG4gICAgICBsZXQgc3RvcCA9IHQuKHN0b3BfaSkgaW5cbiAgICAgIFNvbWUgKHN0YXJ0LCBzdG9wKSkpXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGZvciBpID0gMCB0byAoQXJyYXkubGVuZ3RoIHQgLyAyKSAtIDEgZG9cbiAgICBsZXQgaWR4ID0gMiAqIGkgaW5cbiAgICBsZXQgc3RhcnQgPSB0LihpZHgpIGluXG4gICAgaWYgc3RhcnQgPD4gLTFcbiAgICB0aGVuIChcbiAgICAgIGxldCBzdG9wID0gdC4oaWR4ICsgMSkgaW5cbiAgICAgIGYgaSBzdGFydCBzdG9wKVxuICBkb25lXG47O1xuIiwibW9kdWxlIFBtYXJrID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCBlcXVhbCAoeCA6IGludCkgKHkgOiBpbnQpID0geCA9IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBpbnQpICh5IDogaW50KSA9IGNvbXBhcmUgeCB5XG4gIGxldCByID0gcmVmIDBcblxuICBsZXQgZ2VuICgpID1cbiAgICBpbmNyIHI7XG4gICAgIXJcbiAgOztcblxuICBsZXQgcHAgPSBGb3JtYXQucHBfcHJpbnRfaW50XG5lbmRcblxuaW5jbHVkZSBQbWFya1xubW9kdWxlIFNldCA9IFNldC5NYWtlIChQbWFyaylcbiIsIm9wZW4gSW1wb3J0XG5cbigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbm1vZHVsZSBJZHMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50IHJlZlxuXG4gIGxldCBjcmVhdGUgKCkgPSByZWYgMFxuXG4gIGxldCBuZXh0IHQgPVxuICAgIGluY3IgdDtcbiAgICAhdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBTZW0gPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBMb25nZXN0XG4gICAgfCBgU2hvcnRlc3RcbiAgICB8IGBGaXJzdFxuICAgIF1cblxuICBsZXQgZXF1YWwgPSBQb2x5LmVxdWFsXG5cbiAgbGV0IHBwIGNoIGsgPVxuICAgIEZvcm1hdC5wcF9wcmludF9zdHJpbmdcbiAgICAgIGNoXG4gICAgICAobWF0Y2ggayB3aXRoXG4gICAgICAgfCBgU2hvcnRlc3QgLT4gXCJzaG9ydFwiXG4gICAgICAgfCBgTG9uZ2VzdCAtPiBcImxvbmdcIlxuICAgICAgIHwgYEZpcnN0IC0+IFwiZmlyc3RcIilcbiAgOztcbmVuZFxuXG5tb2R1bGUgUmVwX2tpbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBHcmVlZHlcbiAgICB8IGBOb25fZ3JlZWR5XG4gICAgXVxuXG4gIGxldCBwcCBmbXQgPSBmdW5jdGlvblxuICAgIHwgYEdyZWVkeSAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCBcIkdyZWVkeVwiXG4gICAgfCBgTm9uX2dyZWVkeSAtPiBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZtdCBcIk5vbl9ncmVlZHlcIlxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYXJrID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCBzdGFydCA9IDBcbiAgbGV0IHByZXYgeCA9IHByZWQgeFxuICBsZXQgbmV4dCB4ID0gc3VjYyB4XG4gIGxldCBuZXh0MiB4ID0geCArIDJcbiAgbGV0IGdyb3VwX2NvdW50IHggPSB4IC8gMlxuZW5kXG5cbnR5cGUgaWR4ID0gaW50XG5cbnR5cGUgZXhwciA9XG4gIHsgaWQgOiBpbnRcbiAgOyBkZWYgOiBkZWZcbiAgfVxuXG5hbmQgZGVmID1cbiAgfCBDc3Qgb2YgQ3NldC50XG4gIHwgQWx0IG9mIGV4cHIgbGlzdFxuICB8IFNlcSBvZiBTZW0udCAqIGV4cHIgKiBleHByXG4gIHwgRXBzXG4gIHwgUmVwIG9mIFJlcF9raW5kLnQgKiBTZW0udCAqIGV4cHJcbiAgfCBNYXJrIG9mIGludFxuICB8IEVyYXNlIG9mIGludCAqIGludFxuICB8IEJlZm9yZSBvZiBDYXRlZ29yeS50XG4gIHwgQWZ0ZXIgb2YgQ2F0ZWdvcnkudFxuICB8IFBtYXJrIG9mIFBtYXJrLnRcblxubGV0IGhhc2hfY29tYmluZSBoIGFjY3UgPSAoYWNjdSAqIDY1NTk5KSArIGhcblxubW9kdWxlIE1hcmtzID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBtYXJrcyA6IChpbnQgKiBpbnQpIGxpc3RcbiAgICA7IHBtYXJrcyA6IFBtYXJrLlNldC50XG4gICAgfVxuXG4gIGxldCBlcXVhbCB7IG1hcmtzOyBwbWFya3MgfSB0ID1cbiAgICBMaXN0LmVxdWFsIH5lcTooZnVuICh4LCB5KSAoeCcsIHknKSAtPiBJbnQuZXF1YWwgeCB4JyAmJiBJbnQuZXF1YWwgeSB5JykgbWFya3MgdC5tYXJrc1xuICAgICYmIFBtYXJrLlNldC5lcXVhbCBwbWFya3MgdC5wbWFya3NcbiAgOztcblxuICBsZXQgZW1wdHkgPSB7IG1hcmtzID0gW107IHBtYXJrcyA9IFBtYXJrLlNldC5lbXB0eSB9XG5cbiAgbGV0IG1lcmdlID1cbiAgICBsZXQgcmVjIG1lcmdlX21hcmtzX29mZnNldCBvbGQgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBvbGRcbiAgICAgIHwgKGksIHYpIDo6IHJlbSAtPlxuICAgICAgICBsZXQgbncnID0gbWVyZ2VfbWFya3Nfb2Zmc2V0IChMaXN0LnJlbW92ZV9hc3NxIGkgb2xkKSByZW0gaW5cbiAgICAgICAgaWYgdiA9IC0yIHRoZW4gbncnIGVsc2UgKGksIHYpIDo6IG53J1xuICAgIGluXG4gICAgZnVuIG9sZCBudyAtPlxuICAgICAgeyBtYXJrcyA9IG1lcmdlX21hcmtzX29mZnNldCBvbGQubWFya3MgbncubWFya3NcbiAgICAgIDsgcG1hcmtzID0gUG1hcmsuU2V0LnVuaW9uIG9sZC5wbWFya3MgbncucG1hcmtzXG4gICAgICB9XG4gIDs7XG5cbiAgbGV0IHJlYyBoYXNoX21hcmtzX29mZnNldCBsIGFjY3UgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgKGEsIGkpIDo6IHIgLT4gaGFzaF9tYXJrc19vZmZzZXQgciAoaGFzaF9jb21iaW5lIGEgKGhhc2hfY29tYmluZSBpIGFjY3UpKVxuICA7O1xuXG4gIGxldCBoYXNoIG0gYWNjdSA9IGhhc2hfbWFya3Nfb2Zmc2V0IG0ubWFya3MgKGhhc2hfY29tYmluZSAoSGFzaHRibC5oYXNoIG0ucG1hcmtzKSBhY2N1KVxuXG4gIGxldCBtYXJrc19zZXRfaWR4ID1cbiAgICBsZXQgcmVjIG1hcmtzX3NldF9pZHggaWR4ID0gZnVuY3Rpb25cbiAgICAgIHwgKGEsIC0xKSA6OiByZW0gLT4gKGEsIGlkeCkgOjogbWFya3Nfc2V0X2lkeCBpZHggcmVtXG4gICAgICB8IG1hcmtzIC0+IG1hcmtzXG4gICAgaW5cbiAgICBmdW4gbWFya3MgaWR4IC0+IHsgbWFya3Mgd2l0aCBtYXJrcyA9IG1hcmtzX3NldF9pZHggaWR4IG1hcmtzLm1hcmtzIH1cbiAgOztcblxuICBsZXQgcmVjIHJlbW92ZV9tYXJrcyBiIGUgcmVtID1cbiAgICBpZiBiID4gZSB0aGVuIHJlbSBlbHNlIHJlbW92ZV9tYXJrcyBiIChlIC0gMSkgKChlLCAtMikgOjogcmVtKVxuICA7O1xuXG4gIGxldCBmaWx0ZXIgdCBiIGUgPVxuICAgIHsgdCB3aXRoIG1hcmtzID0gTGlzdC5maWx0ZXIgfmY6KGZ1biAoaSwgXykgLT4gaSA8IGIgfHwgaSA+IGUpIHQubWFya3MgfVxuICA7O1xuXG4gIGxldCBlcmFzZSB0IGIgZSA9IHsgdCB3aXRoIG1hcmtzID0gcmVtb3ZlX21hcmtzIGIgZSAoZmlsdGVyIHQgYiBlKS5tYXJrcyB9XG4gIGxldCBzZXRfbWFyayB0IGkgPSB7IHQgd2l0aCBtYXJrcyA9IChpLCAtMSkgOjogTGlzdC5yZW1vdmVfYXNzcSBpIHQubWFya3MgfVxuICBsZXQgc2V0X3BtYXJrIHQgaSA9IHsgdCB3aXRoIHBtYXJrcyA9IFBtYXJrLlNldC5hZGQgaSB0LnBtYXJrcyB9XG5cbiAgbGV0IHBwX21hcmtzIGNoIHQgPVxuICAgIG1hdGNoIHQubWFya3Mgd2l0aFxuICAgIHwgW10gLT4gKClcbiAgICB8IChhLCBpKSA6OiByIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBjaCBcIiVkLSVkXCIgYSBpO1xuICAgICAgTGlzdC5pdGVyIH5mOihmdW4gKGEsIGkpIC0+IEZvcm1hdC5mcHJpbnRmIGNoIFwiICVkLSVkXCIgYSBpKSByXG4gIDs7XG5lbmRcblxuKCoqKiopXG5cbmxldCByZWMgcHAgY2ggZSA9XG4gIGxldCBvcGVuIEZtdCBpblxuICBtYXRjaCBlLmRlZiB3aXRoXG4gIHwgQ3N0IGwgLT4gc2V4cCBjaCBcImNzdFwiIENzZXQucHAgbFxuICB8IEFsdCBsIC0+IHNleHAgY2ggXCJhbHRcIiAobGlzdCBwcCkgbFxuICB8IFNlcSAoaywgZSwgZScpIC0+IHNleHAgY2ggXCJzZXFcIiAodHJpcGxlIFNlbS5wcCBwcCBwcCkgKGssIGUsIGUnKVxuICB8IEVwcyAtPiBzdHIgY2ggXCJlcHNcIlxuICB8IFJlcCAoX3JrLCBrLCBlKSAtPiBzZXhwIGNoIFwicmVwXCIgKHBhaXIgU2VtLnBwIHBwKSAoaywgZSlcbiAgfCBNYXJrIGkgLT4gc2V4cCBjaCBcIm1hcmtcIiBpbnQgaVxuICB8IFBtYXJrIGkgLT4gc2V4cCBjaCBcInBtYXJrXCIgaW50IChpIDo+IGludClcbiAgfCBFcmFzZSAoYiwgZSkgLT4gc2V4cCBjaCBcImVyYXNlXCIgKHBhaXIgaW50IGludCkgKGIsIGUpXG4gIHwgQmVmb3JlIGMgLT4gc2V4cCBjaCBcImJlZm9yZVwiIENhdGVnb3J5LnBwIGNcbiAgfCBBZnRlciBjIC0+IHNleHAgY2ggXCJhZnRlclwiIENhdGVnb3J5LnBwIGNcbjs7XG5cbigqKioqKVxubGV0IGVwc19leHByID0geyBpZCA9IDA7IGRlZiA9IEVwcyB9XG5sZXQgbWtfZXhwciBpZHMgZGVmID0geyBpZCA9IElkcy5uZXh0IGlkczsgZGVmIH1cbmxldCBlbXB0eSBpZHMgPSBta19leHByIGlkcyAoQWx0IFtdKVxubGV0IGNzdCBpZHMgcyA9IGlmIENzZXQuaXNfZW1wdHkgcyB0aGVuIGVtcHR5IGlkcyBlbHNlIG1rX2V4cHIgaWRzIChDc3QgcylcblxubGV0IGFsdCBpZHMgPSBmdW5jdGlvblxuICB8IFtdIC0+IGVtcHR5IGlkc1xuICB8IFsgYyBdIC0+IGNcbiAgfCBsIC0+IG1rX2V4cHIgaWRzIChBbHQgbClcbjs7XG5cbmxldCBzZXEgaWRzIChraW5kIDogU2VtLnQpIHggeSA9XG4gIG1hdGNoIHguZGVmLCB5LmRlZiB3aXRoXG4gIHwgQWx0IFtdLCBfIC0+IHhcbiAgfCBfLCBBbHQgW10gLT4geVxuICB8IEVwcywgXyAtPiB5XG4gIHwgXywgRXBzIHdoZW4gU2VtLmVxdWFsIGtpbmQgYEZpcnN0IC0+IHhcbiAgfCBfIC0+IG1rX2V4cHIgaWRzIChTZXEgKGtpbmQsIHgsIHkpKVxuOztcblxubGV0IGlzX2VwcyBleHByID1cbiAgbWF0Y2ggZXhwci5kZWYgd2l0aFxuICB8IEVwcyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGVwcyBpZHMgPSBta19leHByIGlkcyBFcHNcbmxldCByZXAgaWRzIGtpbmQgc2VtIHggPSBta19leHByIGlkcyAoUmVwIChraW5kLCBzZW0sIHgpKVxubGV0IG1hcmsgaWRzIG0gPSBta19leHByIGlkcyAoTWFyayBtKVxubGV0IHBtYXJrIGlkcyBpID0gbWtfZXhwciBpZHMgKFBtYXJrIGkpXG5sZXQgZXJhc2UgaWRzIG0gbScgPSBta19leHByIGlkcyAoRXJhc2UgKG0sIG0nKSlcbmxldCBiZWZvcmUgaWRzIGMgPSBta19leHByIGlkcyAoQmVmb3JlIGMpXG5sZXQgYWZ0ZXIgaWRzIGMgPSBta19leHByIGlkcyAoQWZ0ZXIgYylcblxuKCoqKiopXG5cbmxldCByZWMgcmVuYW1lIGlkcyB4ID1cbiAgbWF0Y2ggeC5kZWYgd2l0aFxuICB8IENzdCBfIHwgRXBzIHwgTWFyayBfIHwgUG1hcmsgXyB8IEVyYXNlIF8gfCBCZWZvcmUgXyB8IEFmdGVyIF8gLT4gbWtfZXhwciBpZHMgeC5kZWZcbiAgfCBBbHQgbCAtPiBta19leHByIGlkcyAoQWx0IChMaXN0Lm1hcCB+ZjoocmVuYW1lIGlkcykgbCkpXG4gIHwgU2VxIChrLCB5LCB6KSAtPiBta19leHByIGlkcyAoU2VxIChrLCByZW5hbWUgaWRzIHksIHJlbmFtZSBpZHMgeikpXG4gIHwgUmVwIChnLCBrLCB5KSAtPiBta19leHByIGlkcyAoUmVwIChnLCBrLCByZW5hbWUgaWRzIHkpKVxuOztcblxuKCoqKiopXG5cbnR5cGUgaGFzaCA9IGludFxuXG50eXBlIHN0YXR1cyA9XG4gIHwgRmFpbGVkXG4gIHwgTWF0Y2ggb2YgTWFya19pbmZvcy50ICogUG1hcmsuU2V0LnRcbiAgfCBSdW5uaW5nXG5cbm1vZHVsZSBFID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBUU2VxIG9mIHQgbGlzdCAqIGV4cHIgKiBTZW0udFxuICAgIHwgVEV4cCBvZiBNYXJrcy50ICogZXhwclxuICAgIHwgVE1hdGNoIG9mIE1hcmtzLnRcblxuICBsZXQgaXNfdG1hdGNoID0gZnVuY3Rpb25cbiAgICB8IFRNYXRjaCBfIC0+IHRydWVcbiAgICB8IFRTZXEgXyB8IFRFeHAgXyAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCByZWMgZXF1YWwgbDEgbDIgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgW10gLT4gdHJ1ZVxuICAgIHwgVFNlcSAobDEnLCBlMSwgXykgOjogcjEsIFRTZXEgKGwyJywgZTIsIF8pIDo6IHIyIC0+XG4gICAgICBlMS5pZCA9IGUyLmlkICYmIGVxdWFsIGwxJyBsMicgJiYgZXF1YWwgcjEgcjJcbiAgICB8IFRFeHAgKG1hcmtzMSwgZTEpIDo6IHIxLCBURXhwIChtYXJrczIsIGUyKSA6OiByMiAtPlxuICAgICAgZTEuaWQgPSBlMi5pZCAmJiBNYXJrcy5lcXVhbCBtYXJrczEgbWFya3MyICYmIGVxdWFsIHIxIHIyXG4gICAgfCBUTWF0Y2ggbWFya3MxIDo6IHIxLCBUTWF0Y2ggbWFya3MyIDo6IHIyIC0+IE1hcmtzLmVxdWFsIG1hcmtzMSBtYXJrczIgJiYgZXF1YWwgcjEgcjJcbiAgICB8IF8gLT4gZmFsc2VcbiAgOztcblxuICBsZXQgcmVjIGhhc2ggbCBhY2N1ID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IFRTZXEgKGwnLCBlLCBfKSA6OiByIC0+XG4gICAgICBoYXNoIHIgKGhhc2hfY29tYmluZSAweDE3MmExYmNlIChoYXNoX2NvbWJpbmUgZS5pZCAoaGFzaCBsJyBhY2N1KSkpXG4gICAgfCBURXhwIChtYXJrcywgZSkgOjogciAtPlxuICAgICAgaGFzaCByIChoYXNoX2NvbWJpbmUgMHgyYjRjMGQ3NyAoaGFzaF9jb21iaW5lIGUuaWQgKE1hcmtzLmhhc2ggbWFya3MgYWNjdSkpKVxuICAgIHwgVE1hdGNoIG1hcmtzIDo6IHIgLT4gaGFzaCByIChoYXNoX2NvbWJpbmUgMHgxYzIwNWFkNSAoTWFya3MuaGFzaCBtYXJrcyBhY2N1KSlcbiAgOztcblxuICBsZXQgdGV4cCBtYXJrcyB4ID0gVEV4cCAobWFya3MsIHgpXG5cbiAgbGV0IHRzZXEga2luZCB4IHkgcmVtID1cbiAgICBtYXRjaCB4IHdpdGhcbiAgICB8IFtdIC0+IHJlbVxuICAgIHwgWyBURXhwIChtYXJrcywgeyBkZWYgPSBFcHM7IF8gfSkgXSAtPiBURXhwIChtYXJrcywgeSkgOjogcmVtXG4gICAgfCBfIC0+IFRTZXEgKHgsIHksIGtpbmQpIDo6IHJlbVxuICA7O1xuXG4gIGxldCByZWMgcHJpbnRfc3RhdGVfcmVjIGNoIGUgeSA9XG4gICAgbWF0Y2ggZSB3aXRoXG4gICAgfCBUTWF0Y2ggbWFya3MgLT4gRm9ybWF0LmZwcmludGYgY2ggXCJAWzwyPihNYXRjaEAgJWEpQF1cIiBNYXJrcy5wcF9tYXJrcyBtYXJrc1xuICAgIHwgVFNlcSAobCcsIHgsIF9raW5kKSAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgY2ggXCJAWzwyPihTZXFAIFwiO1xuICAgICAgcHJpbnRfc3RhdGVfbHN0IGNoIGwnIHg7XG4gICAgICBGb3JtYXQuZnByaW50ZiBjaCBcIkAgJWEpQF1cIiBwcCB4XG4gICAgfCBURXhwIChtYXJrcywgeyBkZWYgPSBFcHM7IF8gfSkgLT5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiQFs8Mj4oRXhwQCAlZEAgKCVhKUAgKGVwcykpQF1cIiB5LmlkIE1hcmtzLnBwX21hcmtzIG1hcmtzXG4gICAgfCBURXhwIChtYXJrcywgeCkgLT5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiQFs8Mj4oRXhwQCAlZEAgKCVhKUAgJWEpQF1cIiB4LmlkIE1hcmtzLnBwX21hcmtzIG1hcmtzIHBwIHhcblxuICBhbmQgcHJpbnRfc3RhdGVfbHN0IGNoIGwgeSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBGb3JtYXQuZnByaW50ZiBjaCBcIigpXCJcbiAgICB8IGUgOjogcmVtIC0+XG4gICAgICBwcmludF9zdGF0ZV9yZWMgY2ggZSB5O1xuICAgICAgTGlzdC5pdGVyIHJlbSB+ZjooZnVuIGUgLT5cbiAgICAgICAgRm9ybWF0LmZwcmludGYgY2ggXCJAIHwgXCI7XG4gICAgICAgIHByaW50X3N0YXRlX3JlYyBjaCBlIHkpXG4gIDs7XG5cbiAgbGV0IF9wcCBjaCB0ID0gcHJpbnRfc3RhdGVfbHN0IGNoIFsgdCBdIHsgaWQgPSAwOyBkZWYgPSBFcHMgfVxuZW5kXG5cbm1vZHVsZSBEZXNjID0gc3RydWN0XG4gIHR5cGUgdCA9IEUudCBsaXN0XG5cbiAgb3BlbiBFXG5cbiAgbGV0IHJlYyBmaXJzdF9tYXRjaCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBUTWF0Y2ggbWFya3MgOjogXyAtPiBTb21lIG1hcmtzXG4gICAgfCBfIDo6IHIgLT4gZmlyc3RfbWF0Y2ggclxuICA7O1xuXG4gIGxldCByZW1vdmVfbWF0Y2hlcyA9XG4gICAgTGlzdC5maWx0ZXIgfmY6KGZ1bmN0aW9uXG4gICAgICB8IFRNYXRjaCBfIC0+IGZhbHNlXG4gICAgICB8IF8gLT4gdHJ1ZSlcbiAgOztcblxuICBsZXQgc3BsaXRfYXRfbWF0Y2ggPVxuICAgIGxldCByZWMgc3BsaXRfYXRfbWF0Y2hfcmVjIGwgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgVE1hdGNoIF8gOjogciAtPiBMaXN0LnJldiBsLCByZW1vdmVfbWF0Y2hlcyByXG4gICAgICB8IHggOjogciAtPiBzcGxpdF9hdF9tYXRjaF9yZWMgKHggOjogbCkgclxuICAgIGluXG4gICAgZnVuIGwgLT4gc3BsaXRfYXRfbWF0Y2hfcmVjIFtdIGxcbiAgOztcblxuICBsZXQgZXhpc3RzX3RtYXRjaCA9IExpc3QuZXhpc3RzIH5mOmlzX3RtYXRjaFxuXG4gIGxldCByZWMgc2V0X2lkeCBpZHggPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IFRNYXRjaCBtYXJrcyA6OiByIC0+IFRNYXRjaCAoTWFya3MubWFya3Nfc2V0X2lkeCBtYXJrcyBpZHgpIDo6IHNldF9pZHggaWR4IHJcbiAgICB8IFRTZXEgKGwsIHgsIGtpbmQpIDo6IHIgLT4gVFNlcSAoc2V0X2lkeCBpZHggbCwgeCwga2luZCkgOjogc2V0X2lkeCBpZHggclxuICAgIHwgVEV4cCAobWFya3MsIHgpIDo6IHIgLT4gVEV4cCAoTWFya3MubWFya3Nfc2V0X2lkeCBtYXJrcyBpZHgsIHgpIDo6IHNldF9pZHggaWR4IHJcbiAgOztcbmVuZFxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGlkeCA6IGlkeFxuICAgIDsgY2F0ZWdvcnkgOiBDYXRlZ29yeS50XG4gICAgOyBkZXNjIDogRGVzYy50XG4gICAgOyBtdXRhYmxlIHN0YXR1cyA6IHN0YXR1cyBvcHRpb25cbiAgICA7IGhhc2ggOiBoYXNoXG4gICAgfVxuXG4gIGxldFtAaW5saW5lXSBpZHggdCA9IHQuaWR4XG4gIGxldCBkdW1teSA9IHsgaWR4ID0gLTE7IGNhdGVnb3J5ID0gQ2F0ZWdvcnkuZHVtbXk7IGRlc2MgPSBbXTsgc3RhdHVzID0gTm9uZTsgaGFzaCA9IC0xIH1cblxuICBsZXQgaGFzaCBpZHggY2F0IGRlc2MgPVxuICAgIEUuaGFzaCBkZXNjIChoYXNoX2NvbWJpbmUgaWR4IChoYXNoX2NvbWJpbmUgKENhdGVnb3J5LnRvX2ludCBjYXQpIDApKSBsYW5kIDB4M0ZGRkZGRkZcbiAgOztcblxuICBsZXQgbWsgaWR4IGNhdCBkZXNjID1cbiAgICB7IGlkeDsgY2F0ZWdvcnkgPSBjYXQ7IGRlc2M7IHN0YXR1cyA9IE5vbmU7IGhhc2ggPSBoYXNoIGlkeCBjYXQgZGVzYyB9XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSBjYXQgZSA9IG1rIDAgY2F0IFsgRS5URXhwIChNYXJrcy5lbXB0eSwgZSkgXVxuXG4gIGxldCBlcXVhbCB4IHkgPVxuICAgICh4Lmhhc2ggOiBpbnQpID0geS5oYXNoXG4gICAgJiYgKHguaWR4IDogaW50KSA9IHkuaWR4XG4gICAgJiYgQ2F0ZWdvcnkuZXF1YWwgeC5jYXRlZ29yeSB5LmNhdGVnb3J5XG4gICAgJiYgRS5lcXVhbCB4LmRlc2MgeS5kZXNjXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgeCB5ID1cbiAgICBsZXQgYyA9IGNvbXBhcmUgKHguaGFzaCA6IGludCkgeS5oYXNoIGluXG4gICAgaWYgYyA8PiAwXG4gICAgdGhlbiBjXG4gICAgZWxzZSAoXG4gICAgICBsZXQgYyA9IENhdGVnb3J5LmNvbXBhcmUgeC5jYXRlZ29yeSB5LmNhdGVnb3J5IGluXG4gICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2UgY29tcGFyZSB4LmRlc2MgeS5kZXNjKVxuICA7O1xuXG4gIGxldCBzdGF0dXMgcyA9XG4gICAgbWF0Y2ggcy5zdGF0dXMgd2l0aFxuICAgIHwgU29tZSBzdCAtPiBzdFxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IHN0ID1cbiAgICAgICAgbWF0Y2ggcy5kZXNjIHdpdGhcbiAgICAgICAgfCBbXSAtPiBGYWlsZWRcbiAgICAgICAgfCBFLlRNYXRjaCBtIDo6IF8gLT4gTWF0Y2ggKE1hcmtfaW5mb3MubWFrZSBtLm1hcmtzLCBtLnBtYXJrcylcbiAgICAgICAgfCBfIC0+IFJ1bm5pbmdcbiAgICAgIGluXG4gICAgICBzLnN0YXR1cyA8LSBTb21lIHN0O1xuICAgICAgc3RcbiAgOztcblxuICBtb2R1bGUgVGFibGUgPSBIYXNodGJsLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgbGV0IGVxdWFsID0gZXF1YWxcbiAgICAgIGxldCBoYXNoIHQgPSB0Lmhhc2hcbiAgICBlbmQpXG5lbmRcblxuKCoqKiogRmluZCBhIGZyZWUgaW5kZXggKioqKilcblxubW9kdWxlIFdvcmtpbmdfYXJlYSA9IHN0cnVjdFxuICB0eXBlIHQgPSBCaXRfdmVjdG9yLnQgcmVmXG5cbiAgbGV0IGNyZWF0ZSAoKSA9IHJlZiAoQml0X3ZlY3Rvci5jcmVhdGVfemVybyAxKVxuICBsZXQgaW5kZXhfY291bnQgdyA9IEJpdF92ZWN0b3IubGVuZ3RoICF3XG5cbiAgbGV0IHJlYyBtYXJrX3VzZWRfaW5kaWNlcyB0YmwgPVxuICAgIExpc3QuaXRlciB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRS5UU2VxIChsLCBfLCBfKSAtPiBtYXJrX3VzZWRfaW5kaWNlcyB0YmwgbFxuICAgICAgfCBFLlRFeHAgKG1hcmtzLCBfKSB8IEUuVE1hdGNoIG1hcmtzIC0+XG4gICAgICAgIExpc3QuaXRlciBtYXJrcy5tYXJrcyB+ZjooZnVuIChfLCBpKSAtPiBpZiBpID49IDAgdGhlbiBCaXRfdmVjdG9yLnNldCB0YmwgaSB0cnVlKSlcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfZnJlZSB0YmwgaWR4IGxlbiA9XG4gICAgaWYgaWR4ID0gbGVuIHx8IG5vdCAoQml0X3ZlY3Rvci5nZXQgdGJsIGlkeCkgdGhlbiBpZHggZWxzZSBmaW5kX2ZyZWUgdGJsIChpZHggKyAxKSBsZW5cbiAgOztcblxuICBsZXQgZnJlZV9pbmRleCB0YmxfcmVmIGwgPVxuICAgIGxldCB0YmwgPSAhdGJsX3JlZiBpblxuICAgIEJpdF92ZWN0b3IucmVzZXRfemVybyB0Ymw7XG4gICAgbWFya191c2VkX2luZGljZXMgdGJsIGw7XG4gICAgbGV0IGxlbiA9IEJpdF92ZWN0b3IubGVuZ3RoIHRibCBpblxuICAgIGxldCBpZHggPSBmaW5kX2ZyZWUgdGJsIDAgbGVuIGluXG4gICAgaWYgaWR4ID0gbGVuIHRoZW4gdGJsX3JlZiA6PSBCaXRfdmVjdG9yLmNyZWF0ZV96ZXJvICgyICogbGVuKTtcbiAgICBpZHhcbiAgOztcbmVuZFxuXG4oKioqKiBDb21wdXRhdGlvbiBvZiB0aGUgbmV4dCBzdGF0ZSAqKioqKVxuXG5sZXQgcmVjIHJlbW92ZV9kdXBsaWNhdGVzIHByZXYgbCB5ID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW10sIHByZXZcbiAgfCAoRS5UTWF0Y2ggXyBhcyB4KSA6OiBfIC0+XG4gICAgKCogVHJ1bmNhdGUgYWZ0ZXIgZmlyc3QgbWF0Y2ggKilcbiAgICBbIHggXSwgcHJldlxuICB8IEUuVFNlcSAobCwgeCwga2luZCkgOjogciAtPlxuICAgIGxldCBsLCBwcmV2ID0gcmVtb3ZlX2R1cGxpY2F0ZXMgcHJldiBsIHggaW5cbiAgICBsZXQgciwgcHJldiA9IHJlbW92ZV9kdXBsaWNhdGVzIHByZXYgciB5IGluXG4gICAgRS50c2VxIGtpbmQgbCB4IHIsIHByZXZcbiAgfCAoRS5URXhwIChfbWFya3MsIHsgZGVmID0gRXBzOyBfIH0pIGFzIGUpIDo6IHIgLT5cbiAgICBpZiBMaXN0Lm1lbXEgeS5pZCB+c2V0OnByZXZcbiAgICB0aGVuIHJlbW92ZV9kdXBsaWNhdGVzIHByZXYgciB5XG4gICAgZWxzZSAoXG4gICAgICBsZXQgciwgcHJldiA9IHJlbW92ZV9kdXBsaWNhdGVzICh5LmlkIDo6IHByZXYpIHIgeSBpblxuICAgICAgZSA6OiByLCBwcmV2KVxuICB8IChFLlRFeHAgKF9tYXJrcywgeCkgYXMgZSkgOjogciAtPlxuICAgIGlmIExpc3QubWVtcSB4LmlkIH5zZXQ6cHJldlxuICAgIHRoZW4gcmVtb3ZlX2R1cGxpY2F0ZXMgcHJldiByIHlcbiAgICBlbHNlIChcbiAgICAgIGxldCByLCBwcmV2ID0gcmVtb3ZlX2R1cGxpY2F0ZXMgKHguaWQgOjogcHJldikgciB5IGluXG4gICAgICBlIDo6IHIsIHByZXYpXG47O1xuXG50eXBlIGN0eCA9XG4gIHsgYyA6IENzZXQuY1xuICA7IHByZXZfY2F0IDogQ2F0ZWdvcnkudFxuICA7IG5leHRfY2F0IDogQ2F0ZWdvcnkudFxuICA7IG1hcmtzIDogTWFya3MudFxuICB9XG5cbmxldCByZWMgZGVsdGFfMSAoeyBjOyBtYXJrczsgXyB9IGFzIGN0eCkgeCByZW0gPVxuICAoKkZvcm1hdC5lcHJpbnRmIFwiJWRALlwiIHguaWQ7KilcbiAgbWF0Y2ggeC5kZWYgd2l0aFxuICB8IENzdCBzIC0+IGlmIENzZXQubWVtIGMgcyB0aGVuIEUudGV4cCBtYXJrcyBlcHNfZXhwciA6OiByZW0gZWxzZSByZW1cbiAgfCBBbHQgbCAtPiBkZWx0YV9hbHQgY3R4IGwgcmVtXG4gIHwgU2VxIChraW5kLCB5LCB6KSAtPlxuICAgIGxldCB5ID0gZGVsdGFfMSBjdHggeSBbXSBpblxuICAgIGRlbHRhX3NlcSBjdHgga2luZCB5IHogcmVtXG4gIHwgUmVwIChyZXBfa2luZCwga2luZCwgeSkgLT5cbiAgICBsZXQgeSwgbWFya3MnID1cbiAgICAgIGxldCB5ID0gZGVsdGFfMSBjdHggeSBbXSBpblxuICAgICAgbWF0Y2ggRGVzYy5maXJzdF9tYXRjaCB5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiB5LCBtYXJrc1xuICAgICAgfCBTb21lIG1hcmtzIC0+IERlc2MucmVtb3ZlX21hdGNoZXMgeSwgbWFya3NcbiAgICBpblxuICAgIChtYXRjaCByZXBfa2luZCB3aXRoXG4gICAgIHwgYEdyZWVkeSAtPiBFLnRzZXEga2luZCB5IHggKEUuVE1hdGNoIG1hcmtzJyA6OiByZW0pXG4gICAgIHwgYE5vbl9ncmVlZHkgLT4gRS5UTWF0Y2ggbWFya3MgOjogRS50c2VxIGtpbmQgeSB4IHJlbSlcbiAgfCBFcHMgLT4gRS5UTWF0Y2ggbWFya3MgOjogcmVtXG4gIHwgTWFyayBpIC0+XG4gICAgbGV0IG1hcmtzID0gTWFya3Muc2V0X21hcmsgbWFya3MgaSBpblxuICAgIEUuVE1hdGNoIG1hcmtzIDo6IHJlbVxuICB8IFBtYXJrIGkgLT5cbiAgICBsZXQgbWFya3MgPSBNYXJrcy5zZXRfcG1hcmsgbWFya3MgaSBpblxuICAgIEUuVE1hdGNoIG1hcmtzIDo6IHJlbVxuICB8IEVyYXNlIChiLCBlKSAtPiBFLlRNYXRjaCAoTWFya3MuZmlsdGVyIG1hcmtzIGIgZSkgOjogcmVtXG4gIHwgQmVmb3JlIGNhdCAtPlxuICAgIGlmIENhdGVnb3J5LmludGVyc2VjdCBjdHgubmV4dF9jYXQgY2F0IHRoZW4gRS5UTWF0Y2ggbWFya3MgOjogcmVtIGVsc2UgcmVtXG4gIHwgQWZ0ZXIgY2F0IC0+XG4gICAgaWYgQ2F0ZWdvcnkuaW50ZXJzZWN0IGN0eC5wcmV2X2NhdCBjYXQgdGhlbiBFLlRNYXRjaCBtYXJrcyA6OiByZW0gZWxzZSByZW1cblxuYW5kIGRlbHRhX2FsdCBjdHggbCByZW0gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiByZW1cbiAgfCB5IDo6IHIgLT4gZGVsdGFfMSBjdHggeSAoZGVsdGFfYWx0IGN0eCByIHJlbSlcblxuYW5kIGRlbHRhX3NlcSBjdHggKGtpbmQgOiBTZW0udCkgeSB6IHJlbSA9XG4gIG1hdGNoIERlc2MuZmlyc3RfbWF0Y2ggeSB3aXRoXG4gIHwgTm9uZSAtPiBFLnRzZXEga2luZCB5IHogcmVtXG4gIHwgU29tZSBtYXJrcyAtPlxuICAgIGxldCBjdHggPSB7IGN0eCB3aXRoIG1hcmtzIH0gaW5cbiAgICAobWF0Y2gga2luZCB3aXRoXG4gICAgIHwgYExvbmdlc3QgLT4gRS50c2VxIGtpbmQgKERlc2MucmVtb3ZlX21hdGNoZXMgeSkgeiAoZGVsdGFfMSBjdHggeiByZW0pXG4gICAgIHwgYFNob3J0ZXN0IC0+IGRlbHRhXzEgY3R4IHogKEUudHNlcSBraW5kIChEZXNjLnJlbW92ZV9tYXRjaGVzIHkpIHogcmVtKVxuICAgICB8IGBGaXJzdCAtPlxuICAgICAgIGxldCB5LCB5JyA9IERlc2Muc3BsaXRfYXRfbWF0Y2ggeSBpblxuICAgICAgIEUudHNlcSBraW5kIHkgeiAoZGVsdGFfMSBjdHggeiAoRS50c2VxIGtpbmQgeScgeiByZW0pKSlcbjs7XG5cbmxldCByZWMgZGVsdGFfMyBjdHggeCByZW0gPVxuICBtYXRjaCB4IHdpdGhcbiAgfCBFLlRTZXEgKHksIHosIGtpbmQpIC0+XG4gICAgbGV0IHkgPSBkZWx0YV80IGN0eCB5IFtdIGluXG4gICAgZGVsdGFfc2VxIGN0eCBraW5kIHkgeiByZW1cbiAgfCBFLlRFeHAgKG1hcmtzLCBlKSAtPiBkZWx0YV8xIHsgY3R4IHdpdGggbWFya3MgfSBlIHJlbVxuICB8IEUuVE1hdGNoIF8gLT4geCA6OiByZW1cblxuYW5kIGRlbHRhXzQgY3R4IGwgcmVtID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmVtXG4gIHwgeSA6OiByIC0+IGRlbHRhXzMgY3R4IHkgKGRlbHRhXzQgY3R4IHIgcmVtKVxuOztcblxubGV0IGRlbHRhIHRibF9yZWYgbmV4dF9jYXQgY2hhciAoc3QgOiBTdGF0ZS50KSA9XG4gIGxldCBleHByLCBfID1cbiAgICBsZXQgcHJldl9jYXQgPSBzdC5jYXRlZ29yeSBpblxuICAgIGxldCBjdHggPSB7IGMgPSBjaGFyOyBuZXh0X2NhdDsgcHJldl9jYXQ7IG1hcmtzID0gTWFya3MuZW1wdHkgfSBpblxuICAgIHJlbW92ZV9kdXBsaWNhdGVzIFtdIChkZWx0YV80IGN0eCBzdC5kZXNjIFtdKSBlcHNfZXhwclxuICBpblxuICBsZXQgaWR4ID0gV29ya2luZ19hcmVhLmZyZWVfaW5kZXggdGJsX3JlZiBleHByIGluXG4gIGxldCBleHByID0gRGVzYy5zZXRfaWR4IGlkeCBleHByIGluXG4gIFN0YXRlLm1rIGlkeCBuZXh0X2NhdCBleHByXG47O1xuXG4oKioqKilcblxubGV0IHJlYyByZWRfdHIgPSBmdW5jdGlvblxuICB8IChbXSB8IFsgXyBdKSBhcyBsIC0+IGxcbiAgfCAoKHMxLCBzdDEpIGFzIHRyMSkgOjogKChzMiwgc3QyKSBhcyB0cjIpIDo6IHJlbSAtPlxuICAgIGlmIFN0YXRlLmVxdWFsIHN0MSBzdDJcbiAgICB0aGVuIHJlZF90ciAoKENzZXQudW5pb24gczEgczIsIHN0MSkgOjogcmVtKVxuICAgIGVsc2UgdHIxIDo6IHJlZF90ciAodHIyIDo6IHJlbSlcbjs7XG5cbmxldCBzaW1wbF90ciBsID1cbiAgTGlzdC5zb3J0XG4gICAgfmNtcDooZnVuIChzMSwgXykgKHMyLCBfKSAtPiBjb21wYXJlIHMxIHMyKVxuICAgIChyZWRfdHIgKExpc3Quc29ydCB+Y21wOihmdW4gKF8sIHN0MSkgKF8sIHN0MikgLT4gU3RhdGUuY29tcGFyZSBzdDEgc3QyKSBsKSlcbjs7XG5cbigqKioqKVxuXG5sZXQgcHJlcGVuZF9kZXJpdiBpbml0ID0gTGlzdC5mb2xkX3JpZ2h0IH5pbml0IH5mOihmdW4gKHMsIHgpIGwgLT4gQ3NldC5wcmVwZW5kIHMgeCBsKVxuXG5sZXQgcmVjIHJlc3RyaWN0IHMgPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKHMnLCB4KSA6OiByZW0gLT5cbiAgICBsZXQgcycgPSBDc2V0LmludGVyIHMgcycgaW5cbiAgICBpZiBDc2V0LmlzX2VtcHR5IHMnIHRoZW4gcmVzdHJpY3QgcyByZW0gZWxzZSAocycsIHgpIDo6IHJlc3RyaWN0IHMgcmVtXG47O1xuXG5sZXQgcHJlcGVuZF9tYXJrcyA9XG4gIGxldCByZWMgcHJlcGVuZF9tYXJrc19leHByIG0gPSBmdW5jdGlvblxuICAgIHwgRS5UU2VxIChsLCBlLCBzKSAtPiBFLlRTZXEgKHByZXBlbmRfbWFya3NfZXhwcl9sc3QgbSBsLCBlLCBzKVxuICAgIHwgRS5URXhwIChtJywgZSkgLT4gRS5URXhwIChNYXJrcy5tZXJnZSBtIG0nLCBlKVxuICAgIHwgRS5UTWF0Y2ggbScgLT4gRS5UTWF0Y2ggKE1hcmtzLm1lcmdlIG0gbScpXG4gIGFuZCBwcmVwZW5kX21hcmtzX2V4cHJfbHN0IG0gbCA9IExpc3QubWFwIH5mOihwcmVwZW5kX21hcmtzX2V4cHIgbSkgbCBpblxuICBmdW4gbSAtPiBMaXN0Lm1hcCB+ZjooZnVuIChzLCB4KSAtPiBzLCBwcmVwZW5kX21hcmtzX2V4cHJfbHN0IG0geClcbjs7XG5cbmxldCByZWMgZGVyaXZfMSBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgeCByZW0gPVxuICBtYXRjaCB4LmRlZiB3aXRoXG4gIHwgQ3N0IHMgLT4gQ3NldC5wcmVwZW5kIHMgWyBFLnRleHAgbWFya3MgZXBzX2V4cHIgXSByZW1cbiAgfCBBbHQgbCAtPiBkZXJpdl8yIGFsbF9jaGFycyBjYXRlZ29yaWVzIG1hcmtzIGNhdCBsIHJlbVxuICB8IFNlcSAoa2luZCwgeSwgeikgLT5cbiAgICBsZXQgeSA9IGRlcml2XzEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgbWFya3MgY2F0IHkgWyBhbGxfY2hhcnMsIFtdIF0gaW5cbiAgICBkZXJpdl9zZXEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IGtpbmQgeSB6IHJlbVxuICB8IFJlcCAocmVwX2tpbmQsIGtpbmQsIHkpIC0+XG4gICAgbGV0IHkgPSBkZXJpdl8xIGFsbF9jaGFycyBjYXRlZ29yaWVzIG1hcmtzIGNhdCB5IFsgYWxsX2NoYXJzLCBbXSBdIGluXG4gICAgTGlzdC5mb2xkX3JpZ2h0IH5pbml0OnJlbSB5IH5mOihmdW4gKHMsIHopIHJlbSAtPlxuICAgICAgbGV0IHonLCBtYXJrcycgPVxuICAgICAgICBtYXRjaCBEZXNjLmZpcnN0X21hdGNoIHogd2l0aFxuICAgICAgICB8IE5vbmUgLT4geiwgbWFya3NcbiAgICAgICAgfCBTb21lIG1hcmtzJyAtPiBEZXNjLnJlbW92ZV9tYXRjaGVzIHosIG1hcmtzJ1xuICAgICAgaW5cbiAgICAgIENzZXQucHJlcGVuZFxuICAgICAgICBzXG4gICAgICAgIChtYXRjaCByZXBfa2luZCB3aXRoXG4gICAgICAgICB8IGBHcmVlZHkgLT4gRS50c2VxIGtpbmQgeicgeCBbIEUuVE1hdGNoIG1hcmtzJyBdXG4gICAgICAgICB8IGBOb25fZ3JlZWR5IC0+IEUuVE1hdGNoIG1hcmtzIDo6IEUudHNlcSBraW5kIHonIHggW10pXG4gICAgICAgIHJlbSlcbiAgfCBFcHMgLT4gQ3NldC5wcmVwZW5kIGFsbF9jaGFycyBbIEUuVE1hdGNoIG1hcmtzIF0gcmVtXG4gIHwgTWFyayBpIC0+IENzZXQucHJlcGVuZCBhbGxfY2hhcnMgWyBFLlRNYXRjaCAoTWFya3Muc2V0X21hcmsgbWFya3MgaSkgXSByZW1cbiAgfCBQbWFyayBfIC0+IENzZXQucHJlcGVuZCBhbGxfY2hhcnMgWyBFLlRNYXRjaCBtYXJrcyBdIHJlbVxuICB8IEVyYXNlIChiLCBlKSAtPiBDc2V0LnByZXBlbmQgYWxsX2NoYXJzIFsgRS5UTWF0Y2ggKE1hcmtzLmVyYXNlIG1hcmtzIGIgZSkgXSByZW1cbiAgfCBCZWZvcmUgY2F0IC0+IENzZXQucHJlcGVuZCAoTGlzdC5hc3NxIGNhdCBjYXRlZ29yaWVzKSBbIEUuVE1hdGNoIG1hcmtzIF0gcmVtXG4gIHwgQWZ0ZXIgY2F0JyAtPlxuICAgIGlmIENhdGVnb3J5LmludGVyc2VjdCBjYXQgY2F0J1xuICAgIHRoZW4gQ3NldC5wcmVwZW5kIGFsbF9jaGFycyBbIEUuVE1hdGNoIG1hcmtzIF0gcmVtXG4gICAgZWxzZSByZW1cblxuYW5kIGRlcml2XzIgYWxsX2NoYXJzIGNhdGVnb3JpZXMgbWFya3MgY2F0IGwgcmVtID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmVtXG4gIHwgeSA6OiByIC0+XG4gICAgZGVyaXZfMVxuICAgICAgYWxsX2NoYXJzXG4gICAgICBjYXRlZ29yaWVzXG4gICAgICBtYXJrc1xuICAgICAgY2F0XG4gICAgICB5XG4gICAgICAoZGVyaXZfMiBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgciByZW0pXG5cbmFuZCBkZXJpdl9zZXEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IGtpbmQgeSB6IHJlbSA9XG4gIGlmIExpc3QuZXhpc3RzIHkgfmY6KGZ1biAoX3MsIHhsKSAtPiBEZXNjLmV4aXN0c190bWF0Y2ggeGwpXG4gIHRoZW4gKFxuICAgIGxldCB6JyA9IGRlcml2XzEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgTWFya3MuZW1wdHkgY2F0IHogWyBhbGxfY2hhcnMsIFtdIF0gaW5cbiAgICBMaXN0LmZvbGRfcmlnaHQgfmluaXQ6cmVtIHkgfmY6KGZ1biAocywgeSkgcmVtIC0+XG4gICAgICBtYXRjaCBEZXNjLmZpcnN0X21hdGNoIHkgd2l0aFxuICAgICAgfCBOb25lIC0+IENzZXQucHJlcGVuZCBzIChFLnRzZXEga2luZCB5IHogW10pIHJlbVxuICAgICAgfCBTb21lIG1hcmtzIC0+XG4gICAgICAgIGxldCB6JycgPSBwcmVwZW5kX21hcmtzIG1hcmtzIHonIHw+IHJlc3RyaWN0IHMgaW5cbiAgICAgICAgKG1hdGNoIGtpbmQgd2l0aFxuICAgICAgICAgfCBgTG9uZ2VzdCAtPlxuICAgICAgICAgICBDc2V0LnByZXBlbmRcbiAgICAgICAgICAgICBzXG4gICAgICAgICAgICAgKEUudHNlcSBraW5kIChEZXNjLnJlbW92ZV9tYXRjaGVzIHkpIHogW10pXG4gICAgICAgICAgICAgKHByZXBlbmRfZGVyaXYgeicnIHJlbSlcbiAgICAgICAgIHwgYFNob3J0ZXN0IC0+XG4gICAgICAgICAgIHByZXBlbmRfZGVyaXZcbiAgICAgICAgICAgICB6JydcbiAgICAgICAgICAgICAoQ3NldC5wcmVwZW5kIHMgKEUudHNlcSBraW5kIChEZXNjLnJlbW92ZV9tYXRjaGVzIHkpIHogW10pIHJlbSlcbiAgICAgICAgIHwgYEZpcnN0IC0+XG4gICAgICAgICAgIGxldCB5JywgeScnID0gRGVzYy5zcGxpdF9hdF9tYXRjaCB5IGluXG4gICAgICAgICAgIENzZXQucHJlcGVuZFxuICAgICAgICAgICAgIHNcbiAgICAgICAgICAgICAoRS50c2VxIGtpbmQgeScgeiBbXSlcbiAgICAgICAgICAgICAocHJlcGVuZF9kZXJpdiB6JycgKENzZXQucHJlcGVuZCBzIChFLnRzZXEga2luZCB5JycgeiBbXSkgcmVtKSkpKSlcbiAgZWxzZVxuICAgIExpc3QuZm9sZF9yaWdodCB5IH5pbml0OnJlbSB+ZjooZnVuIChzLCB4bCkgcmVtIC0+XG4gICAgICBDc2V0LnByZXBlbmQgcyAoRS50c2VxIGtpbmQgeGwgeiBbXSkgcmVtKVxuOztcblxubGV0IHJlYyBkZXJpdl8zIGFsbF9jaGFycyBjYXRlZ29yaWVzIGNhdCB4IHJlbSA9XG4gIG1hdGNoIHggd2l0aFxuICB8IEUuVFNlcSAoeSwgeiwga2luZCkgLT5cbiAgICBsZXQgeScgPSBkZXJpdl80IGFsbF9jaGFycyBjYXRlZ29yaWVzIGNhdCB5IFsgYWxsX2NoYXJzLCBbXSBdIGluXG4gICAgZGVyaXZfc2VxIGFsbF9jaGFycyBjYXRlZ29yaWVzIGNhdCBraW5kIHknIHogcmVtXG4gIHwgRS5URXhwIChtYXJrcywgZSkgLT4gZGVyaXZfMSBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgZSByZW1cbiAgfCBFLlRNYXRjaCBfIC0+IENzZXQucHJlcGVuZCBhbGxfY2hhcnMgWyB4IF0gcmVtXG5cbmFuZCBkZXJpdl80IGFsbF9jaGFycyBjYXRlZ29yaWVzIGNhdCBsIHJlbSA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IHJlbVxuICB8IHkgOjogciAtPiBkZXJpdl8zIGFsbF9jaGFycyBjYXRlZ29yaWVzIGNhdCB5IChkZXJpdl80IGFsbF9jaGFycyBjYXRlZ29yaWVzIGNhdCByIHJlbSlcbjs7XG5cbmxldCBkZXJpdiB0YmxfcmVmIGFsbF9jaGFycyBjYXRlZ29yaWVzIChzdCA6IFN0YXRlLnQpID1cbiAgbGV0IGRlciA9IGRlcml2XzQgYWxsX2NoYXJzIGNhdGVnb3JpZXMgc3QuY2F0ZWdvcnkgc3QuZGVzYyBbIGFsbF9jaGFycywgW10gXSBpblxuICBzaW1wbF90clxuICAgIChMaXN0LmZvbGRfcmlnaHQgZGVyIH5pbml0OltdIH5mOihmdW4gKHMsIGV4cHIpIHJlbSAtPlxuICAgICAgIGxldCBleHByJywgXyA9IHJlbW92ZV9kdXBsaWNhdGVzIFtdIGV4cHIgZXBzX2V4cHIgaW5cbiAgICAgICAoKlxuICAgICAgICAgIEZvcm1hdC5lcHJpbnRmIFwiQFs8Mz5AWyVhQF06ICVhIC8gJWFAXUAuXCIgQ3NldC5wcmludCBzIHByaW50X3N0YXRlIGV4cHIgcHJpbnRfc3RhdGUgZXhwcic7XG4gICAgICAgKilcbiAgICAgICBsZXQgaWR4ID0gV29ya2luZ19hcmVhLmZyZWVfaW5kZXggdGJsX3JlZiBleHByJyBpblxuICAgICAgIGxldCBleHByJycgPSBEZXNjLnNldF9pZHggaWR4IGV4cHInIGluXG4gICAgICAgTGlzdC5mb2xkX3JpZ2h0IGNhdGVnb3JpZXMgfmluaXQ6cmVtIH5mOihmdW4gKGNhdCcsIHMnKSByZW0gLT5cbiAgICAgICAgIGxldCBzJycgPSBDc2V0LmludGVyIHMgcycgaW5cbiAgICAgICAgIGlmIENzZXQuaXNfZW1wdHkgcycnIHRoZW4gcmVtIGVsc2UgKHMnJywgU3RhdGUubWsgaWR4IGNhdCcgZXhwcicnKSA6OiByZW0pKSlcbjs7XG5cbigqKioqKVxuIiwiKCogSW4gcmVhbGl0eSwgdGhpcyBjYW4gcmVhbGx5IGJlIHJlcHJlc2VudGVkIGFzIGEgYm9vbCBhcnJheS5cblxuICAgVGhlIHJlcHJlc2VudGF0aW9uIGlzIGJlc3QgdGhvdWdodCBvZiBhcyBhIGxpc3Qgb2YgYWxsIGNoYXJzIGFsb25nIHdpdGggYVxuICAgZmxhZzpcblxuICAgKGEsIDApLCAoYiwgMSksIChjLCAwKSwgKGQsIDApLCAuLi5cblxuICAgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUgY29sb3IgYXJlIHJlcHJlc2VudGVkIGJ5IHNlcXVuY2VzIG9mXG4gICBjaGFyYWN0ZXJzIHdpdGggdGhlIGZsYWcgc2V0IHRvIDAuXG4qKVxuXG50eXBlIHQgPSBCeXRlcy50XG5cbm1vZHVsZSBSZXByID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZ1xuXG4gIGxldCByZXByIHQgY29sb3IgPSB0LltDc2V0LnRvX2ludCBjb2xvcl1cbiAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGhcbmVuZFxuXG5tb2R1bGUgVGFibGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nXG5cbiAgbGV0IGdldF9jaGFyIHQgYyA9IHQuW0NzZXQudG9faW50IGNdXG4gIGxldCBnZXQgdCBjID0gQ3NldC5vZl9pbnQgQEAgQ2hhci5jb2RlIHQuW0NoYXIuY29kZSBjXVxuXG4gIGxldCB0cmFuc2xhdGVfY29sb3JzIChjbSA6IHQpIGNzZXQgPVxuICAgIENzZXQuZm9sZF9yaWdodCBjc2V0IH5pbml0OkNzZXQuZW1wdHkgfmY6KGZ1biAoaSwgaikgbCAtPlxuICAgICAgbGV0IHN0YXJ0ID0gZ2V0X2NoYXIgY20gaSBpblxuICAgICAgbGV0IHN0b3AgPSBnZXRfY2hhciBjbSBqIGluXG4gICAgICBDc2V0LnVuaW9uIChDc2V0LmNzZXEgc3RhcnQgc3RvcCkgbClcbiAgOztcbmVuZFxuXG5sZXQgbWFrZSAoKSA9IEJ5dGVzLm1ha2UgMjU3ICdcXDAwMCdcblxubGV0IGZsYXR0ZW4gY20gPVxuICBsZXQgYyA9IEJ5dGVzLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IGNvbG9yX3JlcHIgPSBCeXRlcy5jcmVhdGUgMjU2IGluXG4gIGxldCB2ID0gcmVmIDAgaW5cbiAgQnl0ZXMuc2V0IGMgMCAnXFwwMDAnO1xuICBCeXRlcy5zZXQgY29sb3JfcmVwciAwICdcXDAwMCc7XG4gIGZvciBpID0gMSB0byAyNTUgZG9cbiAgICBpZiBCeXRlcy5nZXQgY20gaSA8PiAnXFwwMDAnIHRoZW4gaW5jciB2O1xuICAgIEJ5dGVzLnNldCBjIGkgKENoYXIuY2hyICF2KTtcbiAgICBCeXRlcy5zZXQgY29sb3JfcmVwciAhdiAoQ2hhci5jaHIgaSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjLCBCeXRlcy5zdWJfc3RyaW5nIGNvbG9yX3JlcHIgMCAoIXYgKyAxKVxuOztcblxuKCogbWFyayBhbGwgdGhlIGVuZHBvaW50cyBvZiB0aGUgaW50ZXJ2YWxzIG9mIHRoZSBjaGFyIHNldCB3aXRoIHRoZSAxIGJ5dGUgKilcbmxldCBzcGxpdCB0IHNldCA9XG4gIENzZXQuaXRlciBzZXQgfmY6KGZ1biBpIGogLT5cbiAgICBCeXRlcy5zZXQgdCAoQ3NldC50b19pbnQgaSkgJ1xcMDAxJztcbiAgICBCeXRlcy5zZXQgdCAoQ3NldC50b19pbnQgaiArIDEpICdcXDAwMScpXG47O1xuIiwib3BlbiBJbXBvcnRcblxudHlwZSAoJ2EsIF8pIGFzdCA9XG4gIHwgQWx0ZXJuYXRpdmUgOiAnYSBsaXN0IC0+ICgnYSwgWz4gYFVuY2FzZWQgXSkgYXN0XG4gIHwgTm9fY2FzZSA6ICdhIC0+ICgnYSwgWz4gYENhc2VkIF0pIGFzdFxuICB8IENhc2UgOiAnYSAtPiAoJ2EsIFs+IGBDYXNlZCBdKSBhc3RcblxubGV0IGVtcHR5X2FsdGVybmF0aXZlIDogKCdhLCAnYikgYXN0ID0gQWx0ZXJuYXRpdmUgW11cblxubGV0IGVxdWFsX2FzdCAodHlwZSBhKSBlcSAoeCA6IChhLCBbIGBVbmNhc2VkIF0pIGFzdCkgKHkgOiAoYSwgWyBgVW5jYXNlZCBdKSBhc3QpID1cbiAgbWF0Y2ggeCwgeSB3aXRoXG4gIHwgQWx0ZXJuYXRpdmUgYSwgQWx0ZXJuYXRpdmUgYiAtPiBMaXN0LmVxdWFsIH5lcSBhIGJcbjs7XG5cbmxldCBwcF9hc3QgKHR5cGUgYSBiKSBmIGZtdCAoYXN0IDogKGEsIGIpIGFzdCkgPVxuICBsZXQgb3BlbiBGbXQgaW5cbiAgbGV0IHZhciBzIHJlID0gc2V4cCBmbXQgcyBmIHJlIGluXG4gIG1hdGNoIGFzdCB3aXRoXG4gIHwgQWx0ZXJuYXRpdmUgYWx0IC0+IHNleHAgZm10IFwiQWx0ZXJuYXRpdmVcIiAobGlzdCBmKSBhbHRcbiAgfCBDYXNlIGMgLT4gdmFyIFwiQ2FzZVwiIGNcbiAgfCBOb19jYXNlIGMgLT4gdmFyIFwiTm9fY2FzZVwiIGNcbjs7XG5cbnR5cGUgY3NldCA9XG4gIHwgQ3NldCBvZiBDc2V0LnRcbiAgfCBJbnRlcnNlY3Rpb24gb2YgY3NldCBsaXN0XG4gIHwgQ29tcGxlbWVudCBvZiBjc2V0IGxpc3RcbiAgfCBEaWZmZXJlbmNlIG9mIGNzZXQgKiBjc2V0XG4gIHwgQ2FzdCBvZiAoY3NldCwgWyBgQ2FzZWQgfCBgVW5jYXNlZCBdKSBhc3RcblxudHlwZSAoJ2EsICdjYXNlKSBnZW4gPVxuICB8IFNldCBvZiAnYVxuICB8IEFzdCBvZiAoKCdhLCAnY2FzZSkgZ2VuLCAnY2FzZSkgYXN0XG4gIHwgU2VxdWVuY2Ugb2YgKCdhLCAnY2FzZSkgZ2VuIGxpc3RcbiAgfCBSZXBlYXQgb2YgKCdhLCAnY2FzZSkgZ2VuICogaW50ICogaW50IG9wdGlvblxuICB8IEJlZ19vZl9saW5lXG4gIHwgRW5kX29mX2xpbmVcbiAgfCBCZWdfb2Zfd29yZFxuICB8IEVuZF9vZl93b3JkXG4gIHwgTm90X2JvdW5kXG4gIHwgQmVnX29mX3N0clxuICB8IEVuZF9vZl9zdHJcbiAgfCBMYXN0X2VuZF9vZl9saW5lXG4gIHwgU3RhcnRcbiAgfCBTdG9wXG4gIHwgR3JvdXAgb2Ygc3RyaW5nIG9wdGlvbiAqICgnYSwgJ2Nhc2UpIGdlblxuICB8IE5vX2dyb3VwIG9mICgnYSwgJ2Nhc2UpIGdlblxuICB8IE5lc3Qgb2YgKCdhLCAnY2FzZSkgZ2VuXG4gIHwgUG1hcmsgb2YgUG1hcmsudCAqICgnYSwgJ2Nhc2UpIGdlblxuICB8IFNlbSBvZiBBdXRvbWF0YS5TZW0udCAqICgnYSwgJ2Nhc2UpIGdlblxuICB8IFNlbV9ncmVlZHkgb2YgQXV0b21hdGEuUmVwX2tpbmQudCAqICgnYSwgJ2Nhc2UpIGdlblxuXG5sZXQgcmVjIHBwX2dlbiBwcF9jc2V0IGZtdCB0ID1cbiAgbGV0IG9wZW4gRm9ybWF0IGluXG4gIGxldCBvcGVuIEZtdCBpblxuICBsZXQgcHAgPSBwcF9nZW4gcHBfY3NldCBpblxuICBsZXQgdmFyIHMgcmUgPSBzZXhwIGZtdCBzIHBwIHJlIGluXG4gIGxldCBzZXEgcyByZWwgPSBzZXhwIGZtdCBzIChsaXN0IHBwKSByZWwgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2V0IGNzZXQgLT4gcHBfY3NldCBmbXQgY3NldFxuICB8IFNlcXVlbmNlIHNxIC0+IHNlcSBcIlNlcXVlbmNlXCIgc3FcbiAgfCBSZXBlYXQgKHJlLCBzdGFydCwgc3RvcCkgLT5cbiAgICBsZXQgcHAnIGZtdCAoKSA9IGZwcmludGYgZm10IFwiJWFAICVkJWFcIiBwcCByZSBzdGFydCBvcHRpbnQgc3RvcCBpblxuICAgIHNleHAgZm10IFwiUmVwZWF0XCIgcHAnICgpXG4gIHwgQmVnX29mX2xpbmUgLT4gc3RyIGZtdCBcIkJlZ19vZl9saW5lXCJcbiAgfCBFbmRfb2ZfbGluZSAtPiBzdHIgZm10IFwiRW5kX29mX2xpbmVcIlxuICB8IEJlZ19vZl93b3JkIC0+IHN0ciBmbXQgXCJCZWdfb2Zfd29yZFwiXG4gIHwgRW5kX29mX3dvcmQgLT4gc3RyIGZtdCBcIkVuZF9vZl93b3JkXCJcbiAgfCBOb3RfYm91bmQgLT4gc3RyIGZtdCBcIk5vdF9ib3VuZFwiXG4gIHwgQmVnX29mX3N0ciAtPiBzdHIgZm10IFwiQmVnX29mX3N0clwiXG4gIHwgRW5kX29mX3N0ciAtPiBzdHIgZm10IFwiRW5kX29mX3N0clwiXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSAtPiBzdHIgZm10IFwiTGFzdF9lbmRfb2ZfbGluZVwiXG4gIHwgU3RhcnQgLT4gc3RyIGZtdCBcIlN0YXJ0XCJcbiAgfCBTdG9wIC0+IHN0ciBmbXQgXCJTdG9wXCJcbiAgfCBHcm91cCAoTm9uZSwgYykgLT4gdmFyIFwiR3JvdXBcIiBjXG4gIHwgR3JvdXAgKFNvbWUgbiwgYykgLT4gc2V4cCBmbXQgXCJOYW1lZF9ncm91cFwiIChwYWlyIHN0ciBwcCkgKG4sIGMpXG4gIHwgTmVzdCBjIC0+IHZhciBcIk5lc3RcIiBjXG4gIHwgUG1hcmsgKG0sIHIpIC0+IHNleHAgZm10IFwiUG1hcmtcIiAocGFpciBQbWFyay5wcCBwcCkgKG0sIHIpXG4gIHwgQXN0IGEgLT4gcHBfYXN0IHBwIGZtdCBhXG4gIHwgU2VtIChzZW0sIGEpIC0+IHNleHAgZm10IFwiU2VtXCIgKHBhaXIgQXV0b21hdGEuU2VtLnBwIHBwKSAoc2VtLCBhKVxuICB8IFNlbV9ncmVlZHkgKGssIHJlKSAtPiBzZXhwIGZtdCBcIlNlbV9ncmVlZHlcIiAocGFpciBBdXRvbWF0YS5SZXBfa2luZC5wcCBwcCkgKGssIHJlKVxuICB8IE5vX2dyb3VwIGMgLT4gdmFyIFwiTm9fZ3JvdXBcIiBjXG47O1xuXG5sZXQgcmVjIHBwX2NzZXQgZm10IGNzZXQgPVxuICBsZXQgb3BlbiBGbXQgaW5cbiAgbGV0IHNlcSBzIHJlbCA9IHNleHAgZm10IHMgKGxpc3QgcHBfY3NldCkgcmVsIGluXG4gIG1hdGNoIGNzZXQgd2l0aFxuICB8IENhc3QgcyAtPiBwcF9hc3QgcHBfY3NldCBmbXQgc1xuICB8IENzZXQgcyAtPiBzZXhwIGZtdCBcIlNldFwiIENzZXQucHAgc1xuICB8IEludGVyc2VjdGlvbiBjIC0+IHNlcSBcIkludGVyc2VjdGlvblwiIGNcbiAgfCBDb21wbGVtZW50IGMgLT4gc2VxIFwiQ29tcGxlbWVudFwiIGNcbiAgfCBEaWZmZXJlbmNlIChhLCBiKSAtPiBzZXhwIGZtdCBcIkRpZmZlcmVuY2VcIiAocGFpciBwcF9jc2V0IHBwX2NzZXQpIChhLCBiKVxuOztcblxubGV0IHJlYyBlcXVhbCBjc2V0IHgxIHgyID1cbiAgbWF0Y2ggeDEsIHgyIHdpdGhcbiAgfCBTZXQgczEsIFNldCBzMiAtPiBjc2V0IHMxIHMyXG4gIHwgU2VxdWVuY2UgbDEsIFNlcXVlbmNlIGwyIC0+IExpc3QuZXF1YWwgfmVxOihlcXVhbCBjc2V0KSBsMSBsMlxuICB8IFJlcGVhdCAoeDEnLCBpMSwgajEpLCBSZXBlYXQgKHgyJywgaTIsIGoyKSAtPlxuICAgIEludC5lcXVhbCBpMSBpMiAmJiBPcHRpb24uZXF1YWwgSW50LmVxdWFsIGoxIGoyICYmIGVxdWFsIGNzZXQgeDEnIHgyJ1xuICB8IEJlZ19vZl9saW5lLCBCZWdfb2ZfbGluZVxuICB8IEVuZF9vZl9saW5lLCBFbmRfb2ZfbGluZVxuICB8IEJlZ19vZl93b3JkLCBCZWdfb2Zfd29yZFxuICB8IEVuZF9vZl93b3JkLCBFbmRfb2Zfd29yZFxuICB8IE5vdF9ib3VuZCwgTm90X2JvdW5kXG4gIHwgQmVnX29mX3N0ciwgQmVnX29mX3N0clxuICB8IEVuZF9vZl9zdHIsIEVuZF9vZl9zdHJcbiAgfCBMYXN0X2VuZF9vZl9saW5lLCBMYXN0X2VuZF9vZl9saW5lXG4gIHwgU3RhcnQsIFN0YXJ0XG4gIHwgU3RvcCwgU3RvcCAtPiB0cnVlXG4gIHwgR3JvdXAgXywgR3JvdXAgXyAtPlxuICAgICgqIERvIG5vdCBtZXJnZSBncm91cHMhICopXG4gICAgZmFsc2VcbiAgfCBQbWFyayAobTEsIHIxKSwgUG1hcmsgKG0yLCByMikgLT4gUG1hcmsuZXF1YWwgbTEgbTIgJiYgZXF1YWwgY3NldCByMSByMlxuICB8IE5lc3QgeCwgTmVzdCB5IC0+IGVxdWFsIGNzZXQgeCB5XG4gIHwgQXN0IHgsIEFzdCB5IC0+IGVxdWFsX2FzdCAoZXF1YWwgY3NldCkgeCB5XG4gIHwgU2VtIChzZW0sIGEpLCBTZW0gKHNlbScsIGEnKSAtPiBQb2x5LmVxdWFsIHNlbSBzZW0nICYmIGVxdWFsIGNzZXQgYSBhJ1xuICB8IFNlbV9ncmVlZHkgKHJlcCwgYSksIFNlbV9ncmVlZHkgKHJlcCcsIGEnKSAtPiBQb2x5LmVxdWFsIHJlcCByZXAnICYmIGVxdWFsIGNzZXQgYSBhJ1xuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbnR5cGUgdCA9IChjc2V0LCBbIGBDYXNlZCB8IGBVbmNhc2VkIF0pIGdlblxudHlwZSBub19jYXNlID0gKENzZXQudCwgWyBgVW5jYXNlZCBdKSBnZW5cblxubGV0IHBwID0gcHBfZ2VuIHBwX2NzZXRcbmxldCBjc2V0IGNzZXQgPSBTZXQgKENzZXQgY3NldClcblxubGV0IHJlYyBoYW5kbGVfY2FzZV9jc2V0IGlnbl9jYXNlID0gZnVuY3Rpb25cbiAgfCBDc2V0IHMgLT4gaWYgaWduX2Nhc2UgdGhlbiBDc2V0LmNhc2VfaW5zZW5zIHMgZWxzZSBzXG4gIHwgQ2FzdCAoQWx0ZXJuYXRpdmUgbCkgLT4gTGlzdC5tYXAgfmY6KGhhbmRsZV9jYXNlX2NzZXQgaWduX2Nhc2UpIGwgfD4gQ3NldC51bmlvbl9hbGxcbiAgfCBDb21wbGVtZW50IGwgLT5cbiAgICBMaXN0Lm1hcCB+ZjooaGFuZGxlX2Nhc2VfY3NldCBpZ25fY2FzZSkgbCB8PiBDc2V0LnVuaW9uX2FsbCB8PiBDc2V0LmRpZmYgQ3NldC5jYW55XG4gIHwgRGlmZmVyZW5jZSAociwgcicpIC0+XG4gICAgQ3NldC5pbnRlclxuICAgICAgKGhhbmRsZV9jYXNlX2NzZXQgaWduX2Nhc2UgcilcbiAgICAgIChDc2V0LmRpZmYgQ3NldC5jYW55IChoYW5kbGVfY2FzZV9jc2V0IGlnbl9jYXNlIHInKSlcbiAgfCBJbnRlcnNlY3Rpb24gbCAtPiBMaXN0Lm1hcCB+ZjooaGFuZGxlX2Nhc2VfY3NldCBpZ25fY2FzZSkgbCB8PiBDc2V0LmludGVyc2VjdF9hbGxcbiAgfCBDYXN0IChOb19jYXNlIGEpIC0+IGhhbmRsZV9jYXNlX2NzZXQgdHJ1ZSBhXG4gIHwgQ2FzdCAoQ2FzZSBhKSAtPiBoYW5kbGVfY2FzZV9jc2V0IGZhbHNlIGFcbjs7XG5cbmxldCByZWMgaGFuZGxlX2Nhc2UgaWduX2Nhc2UgOiB0IC0+IChDc2V0LnQsIFsgYFVuY2FzZWQgXSkgZ2VuID0gZnVuY3Rpb25cbiAgfCBTZXQgcyAtPiBTZXQgKGhhbmRsZV9jYXNlX2NzZXQgaWduX2Nhc2UgcylcbiAgfCBTZXF1ZW5jZSBsIC0+IFNlcXVlbmNlIChMaXN0Lm1hcCB+ZjooaGFuZGxlX2Nhc2UgaWduX2Nhc2UpIGwpXG4gIHwgQXN0IChBbHRlcm5hdGl2ZSBsKSAtPlxuICAgIGxldCBsID0gTGlzdC5tYXAgfmY6KGhhbmRsZV9jYXNlIGlnbl9jYXNlKSBsIGluXG4gICAgQXN0IChBbHRlcm5hdGl2ZSBsKVxuICB8IFJlcGVhdCAociwgaSwgaikgLT4gUmVwZWF0IChoYW5kbGVfY2FzZSBpZ25fY2FzZSByLCBpLCBqKVxuICB8ICggQmVnX29mX2xpbmVcbiAgICB8IEVuZF9vZl9saW5lXG4gICAgfCBCZWdfb2Zfd29yZFxuICAgIHwgRW5kX29mX3dvcmRcbiAgICB8IE5vdF9ib3VuZFxuICAgIHwgQmVnX29mX3N0clxuICAgIHwgRW5kX29mX3N0clxuICAgIHwgTGFzdF9lbmRfb2ZfbGluZVxuICAgIHwgU3RhcnRcbiAgICB8IFN0b3AgKSBhcyByIC0+IHJcbiAgfCBTZW0gKGssIHIpIC0+IFNlbSAoaywgaGFuZGxlX2Nhc2UgaWduX2Nhc2UgcilcbiAgfCBTZW1fZ3JlZWR5IChrLCByKSAtPiBTZW1fZ3JlZWR5IChrLCBoYW5kbGVfY2FzZSBpZ25fY2FzZSByKVxuICB8IEdyb3VwIChuLCByKSAtPiBHcm91cCAobiwgaGFuZGxlX2Nhc2UgaWduX2Nhc2UgcilcbiAgfCBOb19ncm91cCByIC0+IE5vX2dyb3VwIChoYW5kbGVfY2FzZSBpZ25fY2FzZSByKVxuICB8IE5lc3QgciAtPiBOZXN0IChoYW5kbGVfY2FzZSBpZ25fY2FzZSByKVxuICB8IEFzdCAoQ2FzZSByKSAtPiBoYW5kbGVfY2FzZSBmYWxzZSByXG4gIHwgQXN0IChOb19jYXNlIHIpIC0+IGhhbmRsZV9jYXNlIHRydWUgclxuICB8IFBtYXJrIChpLCByKSAtPiBQbWFyayAoaSwgaGFuZGxlX2Nhc2UgaWduX2Nhc2Ugcilcbjs7XG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgcHAgPSBwcFxuXG4gIGxldCBzZXEgPSBmdW5jdGlvblxuICAgIHwgWyByIF0gLT4gclxuICAgIHwgbCAtPiBTZXF1ZW5jZSBsXG4gIDs7XG5cbiAgbGV0IHN0ciBzID1cbiAgICBsZXQgbCA9IHJlZiBbXSBpblxuICAgIGZvciBpID0gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgICAgbCA6PSBTZXQgKENzZXQgKENzZXQuY3NpbmdsZSBzLltpXSkpIDo6ICFsXG4gICAgZG9uZTtcbiAgICBzZXEgIWxcbiAgOztcblxuICBsZXQgYXNfc2V0X2VsZW1zIGVsZW1zID1cbiAgICBtYXRjaFxuICAgICAgTGlzdC5tYXAgZWxlbXMgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgU2V0IGUgLT4gZVxuICAgICAgICB8IF8gLT4gcmFpc2Vfbm90cmFjZSBFeGl0KVxuICAgIHdpdGhcbiAgICB8IGV4Y2VwdGlvbiBFeGl0IC0+IE5vbmVcbiAgICB8IGUgLT4gU29tZSBlXG4gIDs7XG5cbiAgbGV0IGVtcHR5IDogdCA9IEFzdCBlbXB0eV9hbHRlcm5hdGl2ZVxuXG4gIGxldCBhbHQgKGVsZW1zIDogdCBsaXN0KSA6IHQgPVxuICAgIG1hdGNoIGVsZW1zIHdpdGhcbiAgICB8IFtdIC0+IGVtcHR5XG4gICAgfCBbIHggXSAtPiB4XG4gICAgfCBfIC0+XG4gICAgICAobWF0Y2ggYXNfc2V0X2VsZW1zIGVsZW1zIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gQXN0IChBbHRlcm5hdGl2ZSBlbGVtcylcbiAgICAgICB8IFNvbWUgZWxlbXMgLT4gU2V0IChDYXN0IChBbHRlcm5hdGl2ZSBlbGVtcykpKVxuICA7O1xuXG4gIGxldCBlcHNpbG9uID0gc2VxIFtdXG5cbiAgbGV0IHJlcG4gciBpIGogPVxuICAgIGlmIGkgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5yZXBuXCI7XG4gICAgbWF0Y2ggaiwgaSB3aXRoXG4gICAgfCBTb21lIGosIF8gd2hlbiBqIDwgaSAtPiBpbnZhbGlkX2FyZyBcIlJlLnJlcG5cIlxuICAgIHwgU29tZSAwLCAwIC0+IGVwc2lsb25cbiAgICB8IFNvbWUgMSwgMSAtPiByXG4gICAgfCBfIC0+IFJlcGVhdCAociwgaSwgailcbiAgOztcblxuICBsZXQgcmVwIHIgPSByZXBuIHIgMCBOb25lXG4gIGxldCByZXAxIHIgPSByZXBuIHIgMSBOb25lXG4gIGxldCBvcHQgciA9IHJlcG4gciAwIChTb21lIDEpXG4gIGxldCBib2wgPSBCZWdfb2ZfbGluZVxuICBsZXQgZW9sID0gRW5kX29mX2xpbmVcbiAgbGV0IGJvdyA9IEJlZ19vZl93b3JkXG4gIGxldCBlb3cgPSBFbmRfb2Zfd29yZFxuICBsZXQgd29yZCByID0gc2VxIFsgYm93OyByOyBlb3cgXVxuICBsZXQgbm90X2JvdW5kYXJ5ID0gTm90X2JvdW5kXG4gIGxldCBib3MgPSBCZWdfb2Zfc3RyXG4gIGxldCBlb3MgPSBFbmRfb2Zfc3RyXG4gIGxldCB3aG9sZV9zdHJpbmcgciA9IHNlcSBbIGJvczsgcjsgZW9zIF1cbiAgbGV0IGxlb2wgPSBMYXN0X2VuZF9vZl9saW5lXG4gIGxldCBzdGFydCA9IFN0YXJ0XG4gIGxldCBzdG9wID0gU3RvcFxuXG4gIHR5cGUgJ2IgZiA9IHsgZiA6ICdhLiAnYSAtPiAoJ2EsICdiKSBhc3QgfVxuXG4gIGxldCBtYWtlX3NldCBmIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgU2V0IHggLT4gU2V0IChDYXN0IChmLmYgeCkpXG4gICAgfCBfIC0+IEFzdCAoZi5mIHQpXG4gIDs7XG5cbiAgbGV0IHByZXNlcnZlX3NldCBmIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgU2V0IF8gLT4gdFxuICAgIHwgXyAtPiBmIHRcbiAgOztcblxuICBsZXQgbG9uZ2VzdCA9IHByZXNlcnZlX3NldCAoZnVuIHQgLT4gU2VtIChgTG9uZ2VzdCwgdCkpXG4gIGxldCBzaG9ydGVzdCA9IHByZXNlcnZlX3NldCAoZnVuIHQgLT4gU2VtIChgU2hvcnRlc3QsIHQpKVxuICBsZXQgZmlyc3QgPSBwcmVzZXJ2ZV9zZXQgKGZ1biB0IC0+IFNlbSAoYEZpcnN0LCB0KSlcbiAgbGV0IGdyZWVkeSA9IHByZXNlcnZlX3NldCAoZnVuIHQgLT4gU2VtX2dyZWVkeSAoYEdyZWVkeSwgdCkpXG4gIGxldCBub25fZ3JlZWR5ID0gcHJlc2VydmVfc2V0IChmdW4gdCAtPiBTZW1fZ3JlZWR5IChgTm9uX2dyZWVkeSwgdCkpXG4gIGxldCBncm91cCA/bmFtZSByID0gR3JvdXAgKG5hbWUsIHIpXG4gIGxldCBub19ncm91cCA9IHByZXNlcnZlX3NldCAoZnVuIHQgLT4gTm9fZ3JvdXAgdClcbiAgbGV0IG5lc3QgciA9IE5lc3QgclxuICBsZXQgc2V0IHN0ciA9IGNzZXQgKENzZXQuc2V0IHN0cilcblxuICBsZXQgbWFyayByID1cbiAgICBsZXQgaSA9IFBtYXJrLmdlbiAoKSBpblxuICAgIGksIFBtYXJrIChpLCByKVxuICA7O1xuXG4gICgqKioqIENoYXJhY3RlciBzZXRzICoqKiopXG4gIGxldCBhc19zZXRfb3JfZXJyb3IgbmFtZSBlbGVtcyA9XG4gICAgbWF0Y2ggYXNfc2V0X2VsZW1zIGVsZW1zIHdpdGhcbiAgICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgbmFtZVxuICAgIHwgU29tZSBzIC0+IHNcbiAgOztcblxuICBsZXQgaW50ZXIgZWxlbXMgPSBTZXQgKEludGVyc2VjdGlvbiAoYXNfc2V0X29yX2Vycm9yIFwiUmUuaW50ZXJcIiBlbGVtcykpXG4gIGxldCBjb21wbCBlbGVtcyA9IFNldCAoQ29tcGxlbWVudCAoYXNfc2V0X29yX2Vycm9yIFwiUmUuY29tcGxcIiBlbGVtcykpXG5cbiAgbGV0IGRpZmYgciByJyA9XG4gICAgbWF0Y2ggciwgcicgd2l0aFxuICAgIHwgU2V0IHIsIFNldCByJyAtPiBTZXQgKERpZmZlcmVuY2UgKHIsIHInKSlcbiAgICB8IF8sIF8gLT4gaW52YWxpZF9hcmcgXCJSZS5kaWZmXCJcbiAgOztcblxuICBsZXQgY2FzZSA9XG4gICAgbGV0IGYgPSB7IGYgPSAoZnVuIHIgLT4gQ2FzZSByKSB9IGluXG4gICAgZnVuIHQgLT4gbWFrZV9zZXQgZiB0XG4gIDs7XG5cbiAgbGV0IG5vX2Nhc2UgPVxuICAgIGxldCBmID0geyBmID0gKGZ1biByIC0+IE5vX2Nhc2UgcikgfSBpblxuICAgIGZ1biB0IC0+IG1ha2Vfc2V0IGYgdFxuICA7O1xuXG4gIGxldCB3aXRuZXNzIHQgPVxuICAgIGxldCByZWMgd2l0bmVzcyAodCA6IG5vX2Nhc2UpID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBTZXQgYyAtPiBTdHJpbmcubWFrZSAxIChDc2V0LnRvX2NoYXIgKENzZXQucGljayBjKSlcbiAgICAgIHwgU2VxdWVuY2UgeHMgLT4gU3RyaW5nLmNvbmNhdCBcIlwiIChMaXN0Lm1hcCB+Zjp3aXRuZXNzIHhzKVxuICAgICAgfCBBc3QgKEFsdGVybmF0aXZlICh4IDo6IF8pKSAtPiB3aXRuZXNzIHhcbiAgICAgIHwgQXN0IChBbHRlcm5hdGl2ZSBbXSkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IFJlcGVhdCAociwgZnJvbSwgX3RvKSAtPlxuICAgICAgICBsZXQgdyA9IHdpdG5lc3MgciBpblxuICAgICAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKFN0cmluZy5sZW5ndGggdyAqIGZyb20pIGluXG4gICAgICAgIGZvciBfaSA9IDEgdG8gZnJvbSBkb1xuICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGIgd1xuICAgICAgICBkb25lO1xuICAgICAgICBCdWZmZXIuY29udGVudHMgYlxuICAgICAgfCBOb19ncm91cCByIC0+IHdpdG5lc3MgclxuICAgICAgfCBTZW1fZ3JlZWR5IChfLCByKSB8IFNlbSAoXywgcikgfCBOZXN0IHIgfCBQbWFyayAoXywgcikgfCBHcm91cCAoXywgcikgLT4gd2l0bmVzcyByXG4gICAgICB8IEJlZ19vZl9saW5lXG4gICAgICB8IEVuZF9vZl9saW5lXG4gICAgICB8IEJlZ19vZl93b3JkXG4gICAgICB8IEVuZF9vZl93b3JkXG4gICAgICB8IE5vdF9ib3VuZFxuICAgICAgfCBCZWdfb2Zfc3RyXG4gICAgICB8IExhc3RfZW5kX29mX2xpbmVcbiAgICAgIHwgU3RhcnRcbiAgICAgIHwgU3RvcFxuICAgICAgfCBFbmRfb2Zfc3RyIC0+IFwiXCJcbiAgICBpblxuICAgIHdpdG5lc3MgKGhhbmRsZV9jYXNlIGZhbHNlIHQpXG4gIDs7XG5lbmRcblxub3BlbiBFeHBvcnRcblxubGV0IHJlYyBtZXJnZV9zZXF1ZW5jZXMgPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgQXN0IChBbHRlcm5hdGl2ZSBsJykgOjogciAtPiBtZXJnZV9zZXF1ZW5jZXMgKGwnIEAgcilcbiAgfCBTZXF1ZW5jZSAoeCA6OiB5KSA6OiByIC0+XG4gICAgKG1hdGNoIG1lcmdlX3NlcXVlbmNlcyByIHdpdGhcbiAgICAgfCBTZXF1ZW5jZSAoeCcgOjogeScpIDo6IHInIHdoZW4gZXF1YWwgQ3NldC5lcXVhbCB4IHgnIC0+XG4gICAgICAgU2VxdWVuY2UgWyB4OyBBc3QgKEFsdGVybmF0aXZlIFsgc2VxIHk7IHNlcSB5JyBdKSBdIDo6IHInXG4gICAgIHwgcicgLT4gU2VxdWVuY2UgKHggOjogeSkgOjogcicpXG4gIHwgeCA6OiByIC0+IHggOjogbWVyZ2Vfc2VxdWVuY2VzIHJcbjs7XG5cbigqWFhYIFVzZSBhIGJldHRlciBhbGdvcml0aG0gYWxsb3dpbmcgbm9uLWNvbnRpZ3VvdXMgcmVnaW9ucz8gKilcblxubGV0IGNvbG9yaXplIGNvbG9yX21hcCAocmVnZXhwIDogbm9fY2FzZSkgPVxuICBsZXQgbG5sID0gcmVmIGZhbHNlIGluXG4gIGxldCByZWMgY29sb3JpemUgcmVnZXhwID1cbiAgICBtYXRjaCAocmVnZXhwIDogbm9fY2FzZSkgd2l0aFxuICAgIHwgU2V0IHMgLT4gQ29sb3JfbWFwLnNwbGl0IGNvbG9yX21hcCBzXG4gICAgfCBTZXF1ZW5jZSBsIC0+IExpc3QuaXRlciB+Zjpjb2xvcml6ZSBsXG4gICAgfCBBc3QgKEFsdGVybmF0aXZlIGwpIC0+IExpc3QuaXRlciB+Zjpjb2xvcml6ZSBsXG4gICAgfCBSZXBlYXQgKHIsIF8sIF8pIC0+IGNvbG9yaXplIHJcbiAgICB8IEJlZ19vZl9saW5lIHwgRW5kX29mX2xpbmUgLT4gQ29sb3JfbWFwLnNwbGl0IGNvbG9yX21hcCBDc2V0Lm5sXG4gICAgfCBCZWdfb2Zfd29yZCB8IEVuZF9vZl93b3JkIHwgTm90X2JvdW5kIC0+IENvbG9yX21hcC5zcGxpdCBjb2xvcl9tYXAgQ3NldC5jd29yZFxuICAgIHwgQmVnX29mX3N0ciB8IEVuZF9vZl9zdHIgfCBTdGFydCB8IFN0b3AgLT4gKClcbiAgICB8IExhc3RfZW5kX29mX2xpbmUgLT4gbG5sIDo9IHRydWVcbiAgICB8IE5vX2dyb3VwIHIgfCBHcm91cCAoXywgcikgfCBOZXN0IHIgfCBQbWFyayAoXywgcikgLT4gY29sb3JpemUgclxuICAgIHwgU2VtIChfLCByKSB8IFNlbV9ncmVlZHkgKF8sIHIpIC0+IGNvbG9yaXplIHJcbiAgaW5cbiAgY29sb3JpemUgcmVnZXhwO1xuICAhbG5sXG47O1xuXG5sZXQgcmVjIGFuY2hvcmVkX2FzdCA6ICh0LCBfKSBhc3QgLT4gYm9vbCA9IGZ1bmN0aW9uXG4gIHwgQWx0ZXJuYXRpdmUgYWxzIC0+IExpc3QuZm9yX2FsbCB+ZjphbmNob3JlZCBhbHNcbiAgfCBOb19jYXNlIHIgfCBDYXNlIHIgLT4gYW5jaG9yZWQgclxuXG5hbmQgYW5jaG9yZWQgOiB0IC0+IGJvb2wgPSBmdW5jdGlvblxuICB8IEFzdCBhIC0+IGFuY2hvcmVkX2FzdCBhXG4gIHwgU2VxdWVuY2UgbCAtPiBMaXN0LmV4aXN0cyB+ZjphbmNob3JlZCBsXG4gIHwgUmVwZWF0IChyLCBpLCBfKSAtPiBpID4gMCAmJiBhbmNob3JlZCByXG4gIHwgTm9fZ3JvdXAgciB8IFNlbSAoXywgcikgfCBTZW1fZ3JlZWR5IChfLCByKSB8IEdyb3VwIChfLCByKSB8IE5lc3QgciB8IFBtYXJrIChfLCByKSAtPlxuICAgIGFuY2hvcmVkIHJcbiAgfCBTZXQgX1xuICB8IEJlZ19vZl9saW5lXG4gIHwgRW5kX29mX2xpbmVcbiAgfCBCZWdfb2Zfd29yZFxuICB8IEVuZF9vZl93b3JkXG4gIHwgTm90X2JvdW5kXG4gIHwgRW5kX29mX3N0clxuICB8IExhc3RfZW5kX29mX2xpbmVcbiAgfCBTdG9wIC0+IGZhbHNlXG4gIHwgQmVnX29mX3N0ciB8IFN0YXJ0IC0+IHRydWVcbjs7XG5cbmxldCB0X29mX2NzZXQgeCA9IFNldCB4XG4iLCJvcGVuIEltcG9ydFxuXG50eXBlIHQgPVxuICB8IFNldCBvZiBDc2V0LnRcbiAgfCBTZXF1ZW5jZSBvZiBBc3QudCBsaXN0XG4gIHwgQWx0ZXJuYXRpdmUgb2YgQXN0LnQgbGlzdFxuICB8IFJlcGVhdCBvZiBBc3QudCAqIGludCAqIGludCBvcHRpb25cbiAgfCBCZWdfb2ZfbGluZVxuICB8IEVuZF9vZl9saW5lXG4gIHwgQmVnX29mX3dvcmRcbiAgfCBFbmRfb2Zfd29yZFxuICB8IE5vdF9ib3VuZFxuICB8IEJlZ19vZl9zdHJcbiAgfCBFbmRfb2Zfc3RyXG4gIHwgTGFzdF9lbmRfb2ZfbGluZVxuICB8IFN0YXJ0XG4gIHwgU3RvcFxuICB8IFNlbSBvZiBBdXRvbWF0YS5TZW0udCAqIEFzdC50XG4gIHwgU2VtX2dyZWVkeSBvZiBBdXRvbWF0YS5SZXBfa2luZC50ICogQXN0LnRcbiAgfCBHcm91cCBvZiBzdHJpbmcgb3B0aW9uICogQXN0LnRcbiAgfCBOb19ncm91cCBvZiBBc3QudFxuICB8IE5lc3Qgb2YgQXN0LnRcbiAgfCBDYXNlIG9mIEFzdC50XG4gIHwgTm9fY2FzZSBvZiBBc3QudFxuICB8IEludGVyc2VjdGlvbiBvZiBBc3QudCBsaXN0XG4gIHwgQ29tcGxlbWVudCBvZiBBc3QudCBsaXN0XG4gIHwgRGlmZmVyZW5jZSBvZiBBc3QudCAqIEFzdC50XG4gIHwgUG1hcmsgb2YgUG1hcmsudCAqIEFzdC50XG5cbmxldCB2aWV3X2FzdCBmICh0IDogXyBBc3QuYXN0KSA6IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBBbHRlcm5hdGl2ZSBhIC0+IEFsdGVybmF0aXZlIChMaXN0Lm1hcCB+ZiBhKVxuICB8IE5vX2Nhc2UgYSAtPiBOb19jYXNlIChmIGEpXG4gIHwgQ2FzZSBhIC0+IENhc2UgKGYgYSlcbjs7XG5cbmxldCB2aWV3X3NldCAoY3NldCA6IEFzdC5jc2V0KSA6IHQgPVxuICBtYXRjaCBjc2V0IHdpdGhcbiAgfCBDc2V0IHNldCAtPiBTZXQgc2V0XG4gIHwgSW50ZXJzZWN0aW9uIHNldHMgLT4gSW50ZXJzZWN0aW9uIChMaXN0Lm1hcCBzZXRzIH5mOkFzdC50X29mX2NzZXQpXG4gIHwgQ29tcGxlbWVudCBzZXRzIC0+IENvbXBsZW1lbnQgKExpc3QubWFwIHNldHMgfmY6QXN0LnRfb2ZfY3NldClcbiAgfCBEaWZmZXJlbmNlICh4LCB5KSAtPiBEaWZmZXJlbmNlIChBc3QudF9vZl9jc2V0IHgsIEFzdC50X29mX2NzZXQgeSlcbiAgfCBDYXN0IGFzdCAtPiB2aWV3X2FzdCBBc3QudF9vZl9jc2V0IGFzdFxuOztcblxubGV0IHZpZXcgOiBBc3QudCAtPiB0ID0gZnVuY3Rpb25cbiAgfCBTZXQgcyAtPiB2aWV3X3NldCBzXG4gIHwgQXN0IHMgLT4gdmlld19hc3QgKGZ1biB4IC0+IHgpIHNcbiAgfCBTZW0gKHNlbSwgYSkgLT4gU2VtIChzZW0sIGEpXG4gIHwgU2VtX2dyZWVkeSAoc2VtLCBhKSAtPiBTZW1fZ3JlZWR5IChzZW0sIGEpXG4gIHwgU2VxdWVuY2UgcyAtPiBTZXF1ZW5jZSBzXG4gIHwgUmVwZWF0ICh0LCB4LCB5KSAtPiBSZXBlYXQgKHQsIHgsIHkpXG4gIHwgQmVnX29mX2xpbmUgLT4gQmVnX29mX2xpbmVcbiAgfCBFbmRfb2ZfbGluZSAtPiBFbmRfb2ZfbGluZVxuICB8IEJlZ19vZl93b3JkIC0+IEJlZ19vZl93b3JkXG4gIHwgRW5kX29mX3dvcmQgLT4gRW5kX29mX3dvcmRcbiAgfCBOb3RfYm91bmQgLT4gTm90X2JvdW5kXG4gIHwgQmVnX29mX3N0ciAtPiBCZWdfb2Zfc3RyXG4gIHwgRW5kX29mX3N0ciAtPiBFbmRfb2Zfc3RyXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSAtPiBMYXN0X2VuZF9vZl9saW5lXG4gIHwgU3RhcnQgLT4gU3RhcnRcbiAgfCBTdG9wIC0+IFN0b3BcbiAgfCBOb19ncm91cCBhIC0+IE5vX2dyb3VwIGFcbiAgfCBHcm91cCAobmFtZSwgdCkgLT4gR3JvdXAgKG5hbWUsIHQpXG4gIHwgTmVzdCB0IC0+IE5lc3QgdFxuICB8IFBtYXJrIChwbWFyaywgdCkgLT4gUG1hcmsgKHBtYXJrLCB0KVxuOztcbiIsIigqIFJlc3VsdCBvZiBhIHN1Y2Nlc3NmdWwgbWF0Y2guICopXG50eXBlIHQgPVxuICB7IHMgOiBzdHJpbmdcbiAgOyBtYXJrcyA6IE1hcmtfaW5mb3MudFxuICA7IHBtYXJrcyA6IFBtYXJrLlNldC50XG4gIDsgZ3BvcyA6IGludCBhcnJheVxuICA7IGdjb3VudCA6IGludFxuICB9XG5cbmxldCBvZmZzZXQgdCBpID1cbiAgbWF0Y2ggTWFya19pbmZvcy5vZmZzZXQgdC5tYXJrcyBpIHdpdGhcbiAgfCBOb25lIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IFNvbWUgKHN0YXJ0LCBzdG9wKSAtPiB0Lmdwb3MuKHN0YXJ0KSwgdC5ncG9zLihzdG9wKVxuOztcblxubGV0IGdldCB0IGkgPVxuICBsZXQgcDEsIHAyID0gb2Zmc2V0IHQgaSBpblxuICBTdHJpbmcuc3ViIHQucyBwMSAocDIgLSBwMSlcbjs7XG5cbmxldCBzdGFydCBzdWJzIGkgPSBmc3QgKG9mZnNldCBzdWJzIGkpXG5sZXQgc3RvcCBzdWJzIGkgPSBzbmQgKG9mZnNldCBzdWJzIGkpXG5sZXQgdGVzdCB0IGkgPSBNYXJrX2luZm9zLnRlc3QgdC5tYXJrcyBpXG5sZXQgZ2V0X29wdCB0IGkgPSBpZiB0ZXN0IHQgaSB0aGVuIFNvbWUgKGdldCB0IGkpIGVsc2UgTm9uZVxubGV0IGR1bW15X29mZnNldCA9IC0xLCAtMVxuXG5sZXQgYWxsX29mZnNldCB0ID1cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgdC5nY291bnQgZHVtbXlfb2Zmc2V0IGluXG4gIE1hcmtfaW5mb3MuaXRlcmkgdC5tYXJrcyB+ZjooZnVuIGkgc3RhcnQgc3RvcCAtPlxuICAgIGxldCBwMSA9IHQuZ3Bvcy4oc3RhcnQpIGluXG4gICAgbGV0IHAyID0gdC5ncG9zLihzdG9wKSBpblxuICAgIHJlcy4oaSkgPC0gcDEsIHAyKTtcbiAgcmVzXG47O1xuXG5sZXQgZHVtbXlfc3RyaW5nID0gXCJcIlxuXG5sZXQgYWxsIHQgPVxuICBsZXQgcmVzID0gQXJyYXkubWFrZSB0Lmdjb3VudCBkdW1teV9zdHJpbmcgaW5cbiAgTWFya19pbmZvcy5pdGVyaSB0Lm1hcmtzIH5mOihmdW4gaSBzdGFydCBzdG9wIC0+XG4gICAgbGV0IHAxID0gdC5ncG9zLihzdGFydCkgaW5cbiAgICBsZXQgcDIgPSB0Lmdwb3MuKHN0b3ApIGluXG4gICAgcmVzLihpKSA8LSBTdHJpbmcuc3ViIHQucyBwMSAocDIgLSBwMSkpO1xuICByZXNcbjs7XG5cbmxldCBwcCBmbXQgdCA9XG4gIGxldCBtYXRjaGVzID1cbiAgICBsZXQgb2Zmc2V0cyA9IGFsbF9vZmZzZXQgdCBpblxuICAgIGxldCBzdHJzID0gYWxsIHQgaW5cbiAgICBBcnJheS50b19saXN0IChBcnJheS5pbml0IChBcnJheS5sZW5ndGggc3RycykgKGZ1biBpIC0+IHN0cnMuKGkpLCBvZmZzZXRzLihpKSkpXG4gIGluXG4gIGxldCBvcGVuIEZvcm1hdCBpblxuICBsZXQgb3BlbiBGbXQgaW5cbiAgbGV0IHBwX21hdGNoIGZtdCAoc3RyLCAoc3RhcnQsIHN0b3ApKSA9IGZwcmludGYgZm10IFwiQFsoJXMgKCVkICVkKSlAXVwiIHN0ciBzdGFydCBzdG9wIGluXG4gIHNleHAgZm10IFwiR3JvdXBcIiAobGlzdCBwcF9tYXRjaCkgbWF0Y2hlc1xuOztcblxubGV0IG5iX2dyb3VwcyB0ID0gdC5nY291bnRcbiIsIm9wZW4gSW1wb3J0XG5cbmxldCByZWMgaXRlciBuIGYgdiA9IGlmIEludC5lcXVhbCBuIDAgdGhlbiB2IGVsc2UgaXRlciAobiAtIDEpIGYgKGYgdilcbmxldCB1bmtub3duID0gLTJcbmxldCBicmVhayA9IC0zXG5cbnR5cGUgbWF0Y2hfaW5mbyA9XG4gIHwgTWF0Y2ggb2YgR3JvdXAudFxuICB8IEZhaWxlZFxuICB8IFJ1bm5pbmcgb2YgeyBub19tYXRjaF9zdGFydHNfYmVmb3JlIDogaW50IH1cblxudHlwZSBzdGF0ZV9pbmZvID1cbiAgeyBpZHggOiBpbnRcbiAgOyAoKiBJbmRleCBvZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgcG9zaXRpb24gdGFibGUuXG4gICAgICAgTm90IHlldCBjb21wdXRlZCB0cmFuc2l0aW9ucyBwb2ludCB0byBhIGR1bW15IHN0YXRlIHdoZXJlXG4gICAgICAgW2lkeF0gaXMgc2V0IHRvIFt1bmtub3duXTtcbiAgICAgICBJZiBbaWR4XSBpcyBzZXQgdG8gW2JyZWFrXSBmb3Igc3RhdGVzIHRoYXQgZWl0aGVyIGFsd2F5c1xuICAgICAgIHN1Y2NlZWQgb3IgYWx3YXlzIGZhaWwuICopXG4gICAgcmVhbF9pZHggOiBpbnRcbiAgOyAoKiBUaGUgcmVhbCBpbmRleCwgaW4gY2FzZSBbaWR4XSBpcyBzZXQgdG8gW2JyZWFrXSAqKVxuICAgIG11dGFibGUgZmluYWwgOiAoQ2F0ZWdvcnkudCAqIChBdXRvbWF0YS5pZHggKiBBdXRvbWF0YS5zdGF0dXMpKSBsaXN0XG4gIDsgKCogTWFwcGluZyBmcm9tIHRoZSBjYXRlZ29yeSBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG9cbiAgICAgICAtIHRoZSBpbmRleCB3aGVyZSB0aGUgbmV4dCBwb3NpdGlvbiBzaG91bGQgYmUgc2F2ZWRcbiAgICAgICAtIHBvc3NpYmx5LCB0aGUgbGlzdCBvZiBtYXJrcyAoYW5kIHRoZSBjb3JyZXNwb25kaW5nIGluZGljZXMpXG4gICAgICAgICBjb3JyZXNwb25kaW5nIHRvIHRoZSBiZXN0IG1hdGNoICopXG4gICAgZGVzYyA6IEF1dG9tYXRhLlN0YXRlLnQgKCogRGVzY3JpcHRpb24gb2YgdGhpcyBzdGF0ZSBvZiB0aGUgYXV0b21hdGEgKilcbiAgfVxuXG4oKiBBIHN0YXRlIFt0XSBpcyBhIHBhaXIgY29tcG9zZWQgb2Ygc29tZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAgIHN0YXRlIFtzdGF0ZV9pbmZvXSBhbmQgYSB0cmFuc2l0aW9uIHRhYmxlIFt0IGFycmF5XSwgaW5kZXhlZCBieVxuICAgY29sb3IuIEZvciBwZXJmb3JtYW5jZSByZWFzb24sIHRvIGF2b2lkIGFuIGluZGlyZWN0aW9uLCB3ZSBtYW51YWxseVxuICAgdW5ib3ggdGhlIHRyYW5zaXRpb24gdGFibGU6IHdlIGFsbG9jYXRlIGEgc2luZ2xlIGFycmF5LCB3aXRoIHRoZVxuICAgc3RhdGUgaW5mb3JtYXRpb24gYXQgaW5kZXggMCwgZm9sbG93ZWQgYnkgdGhlIHRyYW5zaXRpb25zLiAqKVxubW9kdWxlIFN0YXRlIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBtYWtlIDogbmNvbDppbnQgLT4gc3RhdGVfaW5mbyAtPiB0XG4gIHZhbCBnZXRfaW5mbyA6IHQgLT4gc3RhdGVfaW5mb1xuICB2YWwgZm9sbG93X3RyYW5zaXRpb24gOiB0IC0+IGNvbG9yOkNzZXQuYyAtPiB0XG4gIHZhbCBzZXRfdHJhbnNpdGlvbiA6IHQgLT4gY29sb3I6Q3NldC5jIC0+IHQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IFRhYmxlIG9mIHQgYXJyYXkgW0BAdW5ib3hlZF1cblxuICBsZXQgZ2V0X2luZm8gKFRhYmxlIHN0KSA6IHN0YXRlX2luZm8gPSBPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgc3QgMClcbiAgW0BAaW5saW5lIGFsd2F5c11cbiAgOztcblxuICBsZXQgc2V0X2luZm8gKFRhYmxlIHN0KSAoaW5mbyA6IHN0YXRlX2luZm8pID0gc3QuKDApIDwtIE9iai5tYWdpYyBpbmZvXG5cbiAgbGV0IGZvbGxvd190cmFuc2l0aW9uIChUYWJsZSBzdCkgfmNvbG9yID0gQXJyYXkudW5zYWZlX2dldCBzdCAoMSArIENzZXQudG9faW50IGNvbG9yKVxuICBbQEBpbmxpbmUgYWx3YXlzXVxuICA7O1xuXG4gIGxldCBzZXRfdHJhbnNpdGlvbiAoVGFibGUgc3QpIH5jb2xvciBzdCcgPSBzdC4oMSArIENzZXQudG9faW50IGNvbG9yKSA8LSBzdCdcbiAgbGV0IGR1bW15IChpbmZvIDogc3RhdGVfaW5mbykgPSBUYWJsZSBbfCBPYmoubWFnaWMgaW5mbyB8XVxuXG4gIGxldCB1bmtub3duX3N0YXRlID1cbiAgICBkdW1teSB7IGlkeCA9IHVua25vd247IHJlYWxfaWR4ID0gMDsgZmluYWwgPSBbXTsgZGVzYyA9IEF1dG9tYXRhLlN0YXRlLmR1bW15IH1cbiAgOztcblxuICBsZXQgbWFrZSB+bmNvbCBzdGF0ZSA9XG4gICAgbGV0IHN0ID0gVGFibGUgKEFycmF5Lm1ha2UgKG5jb2wgKyAxKSB1bmtub3duX3N0YXRlKSBpblxuICAgIHNldF9pbmZvIHN0IHN0YXRlO1xuICAgIHN0XG4gIDs7XG5lbmRcblxuKCogQXV0b21hdGEgKGNvbXBpbGVkIHJlZ3VsYXIgZXhwcmVzc2lvbikgKilcbnR5cGUgcmUgPVxuICB7IGluaXRpYWwgOiBBdXRvbWF0YS5leHByXG4gIDsgKCogVGhlIHdob2xlIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKVxuICAgIG11dGFibGUgaW5pdGlhbF9zdGF0ZXMgOiAoQ2F0ZWdvcnkudCAqIFN0YXRlLnQpIGxpc3RcbiAgOyAoKiBJbml0aWFsIHN0YXRlcywgaW5kZXhlZCBieSBpbml0aWFsIGNhdGVnb3J5ICopXG4gICAgY29sb3JzIDogQ29sb3JfbWFwLlRhYmxlLnRcbiAgOyAoKiBDb2xvciB0YWJsZSAqKVxuICAgIGNvbG9yX3JlcHIgOiBDb2xvcl9tYXAuUmVwci50XG4gIDsgKCogVGFibGUgZnJvbSBjb2xvcnMgdG8gb25lIGNoYXJhY3RlciBvZiB0aGlzIGNvbG9yICopXG4gICAgbmNvbG9yIDogaW50XG4gIDsgKCogTnVtYmVyIG9mIGNvbG9ycy4gKilcbiAgICBsbmwgOiBpbnRcbiAgOyAoKiBDb2xvciBvZiB0aGUgbGFzdCBuZXdsaW5lLiAtMSBpZiB1bm5lY2Vzc2FyeSAqKVxuICAgIHRibCA6IEF1dG9tYXRhLldvcmtpbmdfYXJlYS50XG4gIDsgKCogVGVtcG9yYXJ5IHRhYmxlIHVzZWQgdG8gY29tcHV0ZSB0aGUgZmlyc3QgYXZhaWxhYmxlIGluZGV4XG4gICAgICAgd2hlbiBjb21wdXRpbmcgYSBuZXcgc3RhdGUgKilcbiAgICBzdGF0ZXMgOiBTdGF0ZS50IEF1dG9tYXRhLlN0YXRlLlRhYmxlLnRcbiAgOyAoKiBTdGF0ZXMgb2YgdGhlIGRldGVybWluaXN0aWMgYXV0b21hdGEgKilcbiAgICBncm91cF9uYW1lcyA6IChzdHJpbmcgKiBpbnQpIGxpc3RcbiAgOyAoKiBOYW1lZCBncm91cHMgaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKVxuICAgIGdyb3VwX2NvdW50IDogaW50ICgqIE51bWJlciBvZiBncm91cHMgaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKVxuICB9XG5cbmxldCBwcF9yZSBjaCByZSA9IEF1dG9tYXRhLnBwIGNoIHJlLmluaXRpYWxcbmxldCBwcmludF9yZSA9IHBwX3JlXG5sZXQgZ3JvdXBfY291bnQgcmUgPSByZS5ncm91cF9jb3VudFxubGV0IGdyb3VwX25hbWVzIHJlID0gcmUuZ3JvdXBfbmFtZXNcblxuKCogSW5mb3JtYXRpb24gdXNlZCBkdXJpbmcgbWF0Y2hpbmcgKilcbnR5cGUgaW5mbyA9XG4gIHsgcmUgOiByZVxuICA7ICgqIFRoZSBhdXRvbWF0YSAqKVxuICAgIG11dGFibGUgcG9zaXRpb25zIDogaW50IGFycmF5XG4gIDsgKCogQXJyYXkgb2YgbWFyayBwb3NpdGlvbnNcbiAgICAgICBUaGUgbWFyayBhcmUgb2ZmIGJ5IG9uZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAqKVxuICAgIHBvcyA6IGludFxuICA7ICgqIFBvc2l0aW9uIHdoZXJlIHRoZSBtYXRjaCBpcyBzdGFydGVkICopXG4gICAgbGFzdCA6IGludCAoKiBQb3NpdGlvbiB3aGVyZSB0aGUgbWF0Y2ggc2hvdWxkIHN0b3AgKilcbiAgfVxuXG4oKioqKilcblxubGV0IGNhdGVnb3J5IHJlIH5jb2xvciA9XG4gIGlmIENzZXQudG9faW50IGNvbG9yID0gLTFcbiAgdGhlbiBDYXRlZ29yeS5pbmV4aXN0YW50ICgqIFNwZWNpYWwgY2F0ZWdvcnkgZm9yIHRoZSBsYXN0IG5ld2xpbmUgKilcbiAgZWxzZSBpZiBDc2V0LnRvX2ludCBjb2xvciA9IHJlLmxubFxuICB0aGVuIENhdGVnb3J5LihsYXN0bmV3bGluZSArKyBuZXdsaW5lICsrIG5vdF9sZXR0ZXIpXG4gIGVsc2UgQ2F0ZWdvcnkuZnJvbV9jaGFyIChDb2xvcl9tYXAuUmVwci5yZXByIHJlLmNvbG9yX3JlcHIgY29sb3IpXG47O1xuXG4oKioqKilcblxubGV0IG1rX3N0YXRlIG5jb2wgZGVzYyA9XG4gIGxldCBicmVha19zdGF0ZSA9XG4gICAgbWF0Y2ggQXV0b21hdGEuU3RhdGUuc3RhdHVzIGRlc2Mgd2l0aFxuICAgIHwgQXV0b21hdGEuUnVubmluZyAtPiBmYWxzZVxuICAgIHwgQXV0b21hdGEuRmFpbGVkIHwgQXV0b21hdGEuTWF0Y2ggXyAtPiB0cnVlXG4gIGluXG4gIGxldCBzdCA9XG4gICAgbGV0IHJlYWxfaWR4ID0gQXV0b21hdGEuU3RhdGUuaWR4IGRlc2MgaW5cbiAgICB7IGlkeCA9IChpZiBicmVha19zdGF0ZSB0aGVuIGJyZWFrIGVsc2UgcmVhbF9pZHgpOyByZWFsX2lkeDsgZmluYWwgPSBbXTsgZGVzYyB9XG4gIGluXG4gIFN0YXRlLm1ha2Ugfm5jb2w6KGlmIGJyZWFrX3N0YXRlIHRoZW4gMCBlbHNlIG5jb2wpIHN0XG47O1xuXG5sZXQgZmluZF9zdGF0ZSByZSBkZXNjID1cbiAgdHJ5IEF1dG9tYXRhLlN0YXRlLlRhYmxlLmZpbmQgcmUuc3RhdGVzIGRlc2Mgd2l0aFxuICB8IE5vdF9mb3VuZCAtPlxuICAgIGxldCBzdCA9IG1rX3N0YXRlIHJlLm5jb2xvciBkZXNjIGluXG4gICAgQXV0b21hdGEuU3RhdGUuVGFibGUuYWRkIHJlLnN0YXRlcyBkZXNjIHN0O1xuICAgIHN0XG47O1xuXG4oKioqKiBNYXRjaCB3aXRoIG1hcmtzICoqKiopXG5cbmxldCBkZWx0YSBpbmZvIGNhdCB+Y29sb3Igc3QgPVxuICBsZXQgZGVzYyA9IEF1dG9tYXRhLmRlbHRhIGluZm8ucmUudGJsIGNhdCBjb2xvciBzdC5kZXNjIGluXG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaW5mby5wb3NpdGlvbnMgaW5cbiAgaWYgQXV0b21hdGEuU3RhdGUuaWR4IGRlc2MgPSBsZW4gJiYgbGVuID4gMFxuICB0aGVuIChcbiAgICBsZXQgcG9zID0gaW5mby5wb3NpdGlvbnMgaW5cbiAgICBpbmZvLnBvc2l0aW9ucyA8LSBBcnJheS5tYWtlICgyICogbGVuKSAwO1xuICAgIEFycmF5LmJsaXQgcG9zIDAgaW5mby5wb3NpdGlvbnMgMCBsZW4pO1xuICBkZXNjXG47O1xuXG5sZXQgdmFsaWRhdGUgaW5mbyAocyA6IHN0cmluZykgfnBvcyBzdCA9XG4gIGxldCBjb2xvciA9IENvbG9yX21hcC5UYWJsZS5nZXQgaW5mby5yZS5jb2xvcnMgcy5bcG9zXSBpblxuICBsZXQgc3QnID1cbiAgICBsZXQgZGVzYycgPVxuICAgICAgbGV0IGNhdCA9IGNhdGVnb3J5IGluZm8ucmUgfmNvbG9yIGluXG4gICAgICBkZWx0YSBpbmZvIGNhdCB+Y29sb3IgKFN0YXRlLmdldF9pbmZvIHN0KVxuICAgIGluXG4gICAgZmluZF9zdGF0ZSBpbmZvLnJlIGRlc2MnXG4gIGluXG4gIFN0YXRlLnNldF90cmFuc2l0aW9uIHN0IH5jb2xvciBzdCdcbjs7XG5cbmxldCBuZXh0IGNvbG9ycyBzdCBzIHBvcyA9XG4gIFN0YXRlLmZvbGxvd190cmFuc2l0aW9uIHN0IH5jb2xvcjooQ29sb3JfbWFwLlRhYmxlLmdldCBjb2xvcnMgKFN0cmluZy51bnNhZmVfZ2V0IHMgcG9zKSlcbjs7XG5cbmxldCByZWMgbG9vcCBpbmZvIH5jb2xvcnMgfnBvc2l0aW9ucyBzIH5wb3Mgfmxhc3Qgc3QwIHN0ID1cbiAgaWYgcG9zIDwgbGFzdFxuICB0aGVuIChcbiAgICBsZXQgc3QnID0gbmV4dCBjb2xvcnMgc3QgcyBwb3MgaW5cbiAgICBsZXQgc3RhdGVfaW5mbyA9IFN0YXRlLmdldF9pbmZvIHN0JyBpblxuICAgIGxldCBpZHggPSBzdGF0ZV9pbmZvLmlkeCBpblxuICAgIGlmIGlkeCA+PSAwXG4gICAgdGhlbiAoXG4gICAgICBBcnJheS51bnNhZmVfc2V0IHBvc2l0aW9ucyBpZHggcG9zO1xuICAgICAgbG9vcCBpbmZvIH5jb2xvcnMgfnBvc2l0aW9ucyBzIH5wb3M6KHBvcyArIDEpIH5sYXN0IHN0JyBzdCcpXG4gICAgZWxzZSBpZiBpZHggPSBicmVha1xuICAgIHRoZW4gKFxuICAgICAgQXJyYXkudW5zYWZlX3NldCBwb3NpdGlvbnMgc3RhdGVfaW5mby5yZWFsX2lkeCBwb3M7XG4gICAgICBzdCcpXG4gICAgZWxzZSAoXG4gICAgICAoKiBVbmtub3duICopXG4gICAgICB2YWxpZGF0ZSBpbmZvIHMgfnBvcyBzdDA7XG4gICAgICBsb29wIGluZm8gfmNvbG9ycyB+cG9zaXRpb25zOmluZm8ucG9zaXRpb25zIHMgfnBvcyB+bGFzdCBzdDAgc3QwKSlcbiAgZWxzZSBzdFxuOztcblxubGV0IHJlYyBsb29wX25vX21hcmsgaW5mbyB+Y29sb3JzIHMgfnBvcyB+bGFzdCBzdDAgc3QgPVxuICBpZiBwb3MgPCBsYXN0XG4gIHRoZW4gKFxuICAgIGxldCBzdCcgPSBuZXh0IGNvbG9ycyBzdCBzIHBvcyBpblxuICAgIGxldCBzdGF0ZV9pbmZvID0gU3RhdGUuZ2V0X2luZm8gc3QnIGluXG4gICAgbGV0IGlkeCA9IHN0YXRlX2luZm8uaWR4IGluXG4gICAgaWYgaWR4ID49IDBcbiAgICB0aGVuIGxvb3Bfbm9fbWFyayBpbmZvIH5jb2xvcnMgcyB+cG9zOihwb3MgKyAxKSB+bGFzdCBzdCcgc3QnXG4gICAgZWxzZSBpZiBpZHggPSBicmVha1xuICAgIHRoZW4gc3QnXG4gICAgZWxzZSAoXG4gICAgICAoKiBVbmtub3duICopXG4gICAgICB2YWxpZGF0ZSBpbmZvIHMgfnBvcyBzdDA7XG4gICAgICBsb29wX25vX21hcmsgaW5mbyB+Y29sb3JzIHMgfnBvcyB+bGFzdCBzdDAgc3QwKSlcbiAgZWxzZSBzdFxuOztcblxubGV0IGZpbmFsIGluZm8gc3QgY2F0ID1cbiAgdHJ5IExpc3QuYXNzcSBjYXQgc3QuZmluYWwgd2l0aFxuICB8IE5vdF9mb3VuZCAtPlxuICAgIGxldCBzdCcgPSBkZWx0YSBpbmZvIGNhdCB+Y29sb3I6KENzZXQub2ZfaW50ICgtMSkpIHN0IGluXG4gICAgbGV0IHJlcyA9IEF1dG9tYXRhLlN0YXRlLmlkeCBzdCcsIEF1dG9tYXRhLlN0YXRlLnN0YXR1cyBzdCcgaW5cbiAgICBzdC5maW5hbCA8LSAoY2F0LCByZXMpIDo6IHN0LmZpbmFsO1xuICAgIHJlc1xuOztcblxubGV0IGZpbmRfaW5pdGlhbF9zdGF0ZSByZSBjYXQgPVxuICB0cnkgTGlzdC5hc3NxIGNhdCByZS5pbml0aWFsX3N0YXRlcyB3aXRoXG4gIHwgTm90X2ZvdW5kIC0+XG4gICAgbGV0IHN0ID0gZmluZF9zdGF0ZSByZSAoQXV0b21hdGEuU3RhdGUuY3JlYXRlIGNhdCByZS5pbml0aWFsKSBpblxuICAgIHJlLmluaXRpYWxfc3RhdGVzIDwtIChjYXQsIHN0KSA6OiByZS5pbml0aWFsX3N0YXRlcztcbiAgICBzdFxuOztcblxubGV0IGdldF9jb2xvciByZSAocyA6IHN0cmluZykgcG9zID1cbiAgaWYgcG9zIDwgMFxuICB0aGVuIENzZXQub2ZfaW50IEBAIC0xXG4gIGVsc2UgKFxuICAgIGxldCBzbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgaWYgcG9zID49IHNsZW5cbiAgICB0aGVuIENzZXQub2ZfaW50ICgtMSlcbiAgICBlbHNlIGlmIHBvcyA9IHNsZW4gLSAxICYmIHJlLmxubCA8PiAtMSAmJiBDaGFyLmVxdWFsIHMuW3Bvc10gJ1xcbidcbiAgICB0aGVuICgqIFNwZWNpYWwgY2FzZSBmb3IgdGhlIGxhc3QgbmV3bGluZSAqKVxuICAgICAgQ3NldC5vZl9pbnQgcmUubG5sXG4gICAgZWxzZSBDb2xvcl9tYXAuVGFibGUuZ2V0IHJlLmNvbG9ycyBzLltwb3NdKVxuOztcblxubGV0IHJlYyBoYW5kbGVfbGFzdF9uZXdsaW5lIGluZm8gfnBvcyBzdCB+Z3JvdXBzID1cbiAgbGV0IHN0JyA9IFN0YXRlLmZvbGxvd190cmFuc2l0aW9uIHN0IH5jb2xvcjooQ3NldC5vZl9pbnQgaW5mby5yZS5sbmwpIGluXG4gIGxldCBpbmZvJyA9IFN0YXRlLmdldF9pbmZvIHN0JyBpblxuICBpZiBpbmZvJy5pZHggPj0gMFxuICB0aGVuIChcbiAgICBpZiBncm91cHMgdGhlbiBpbmZvLnBvc2l0aW9ucy4oaW5mbycuaWR4KSA8LSBwb3M7XG4gICAgc3QnKVxuICBlbHNlIGlmIGluZm8nLmlkeCA9IGJyZWFrXG4gIHRoZW4gKFxuICAgIGlmIGdyb3VwcyB0aGVuIGluZm8ucG9zaXRpb25zLihpbmZvJy5yZWFsX2lkeCkgPC0gcG9zO1xuICAgIHN0JylcbiAgZWxzZSAoXG4gICAgKCogVW5rbm93biAqKVxuICAgIGxldCBjb2xvciA9IENzZXQub2ZfaW50IGluZm8ucmUubG5sIGluXG4gICAgbGV0IHN0JyA9XG4gICAgICBsZXQgZGVzYycgPVxuICAgICAgICBsZXQgY2F0ID0gY2F0ZWdvcnkgaW5mby5yZSB+Y29sb3IgaW5cbiAgICAgICAgbGV0IHJlYWxfYyA9IENvbG9yX21hcC5UYWJsZS5nZXQgaW5mby5yZS5jb2xvcnMgJ1xcbicgaW5cbiAgICAgICAgZGVsdGEgaW5mbyBjYXQgfmNvbG9yOnJlYWxfYyAoU3RhdGUuZ2V0X2luZm8gc3QpXG4gICAgICBpblxuICAgICAgZmluZF9zdGF0ZSBpbmZvLnJlIGRlc2MnXG4gICAgaW5cbiAgICBTdGF0ZS5zZXRfdHJhbnNpdGlvbiBzdCB+Y29sb3Igc3QnO1xuICAgIGhhbmRsZV9sYXN0X25ld2xpbmUgaW5mbyB+cG9zIHN0IH5ncm91cHMpXG47O1xuXG5sZXQgcmVjIHNjYW5fc3RyIGluZm8gKHMgOiBzdHJpbmcpIGluaXRpYWxfc3RhdGUgfmdyb3VwcyA9XG4gIGxldCBwb3MgPSBpbmZvLnBvcyBpblxuICBsZXQgbGFzdCA9IGluZm8ubGFzdCBpblxuICBpZiBsYXN0ID0gU3RyaW5nLmxlbmd0aCBzXG4gICAgICYmIGluZm8ucmUubG5sIDw+IC0xXG4gICAgICYmIGxhc3QgPiBwb3NcbiAgICAgJiYgQ2hhci5lcXVhbCAoU3RyaW5nLmdldCBzIChsYXN0IC0gMSkpICdcXG4nXG4gIHRoZW4gKFxuICAgIGxldCBpbmZvID0geyBpbmZvIHdpdGggbGFzdCA9IGxhc3QgLSAxIH0gaW5cbiAgICBsZXQgc3QgPSBzY2FuX3N0ciBpbmZvIHMgaW5pdGlhbF9zdGF0ZSB+Z3JvdXBzIGluXG4gICAgaWYgKFN0YXRlLmdldF9pbmZvIHN0KS5pZHggPSBicmVha1xuICAgIHRoZW4gc3RcbiAgICBlbHNlIGhhbmRsZV9sYXN0X25ld2xpbmUgaW5mbyB+cG9zOihsYXN0IC0gMSkgc3Qgfmdyb3VwcylcbiAgZWxzZSBpZiBncm91cHNcbiAgdGhlblxuICAgIGxvb3BcbiAgICAgIGluZm9cbiAgICAgIH5jb2xvcnM6aW5mby5yZS5jb2xvcnNcbiAgICAgIH5wb3NpdGlvbnM6aW5mby5wb3NpdGlvbnNcbiAgICAgIHNcbiAgICAgIH5wb3NcbiAgICAgIH5sYXN0XG4gICAgICBpbml0aWFsX3N0YXRlXG4gICAgICBpbml0aWFsX3N0YXRlXG4gIGVsc2UgbG9vcF9ub19tYXJrIGluZm8gfmNvbG9yczppbmZvLnJlLmNvbG9ycyBzIH5wb3Mgfmxhc3QgaW5pdGlhbF9zdGF0ZSBpbml0aWFsX3N0YXRlXG47O1xuXG4oKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYSBmaW5hbCBib3VuZGFyeSBjaGVjayBvbiB0aGUgaW5wdXQuXG4gICBUaGlzIGlzIHVzZWZ1bCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBvdXRwdXQgZmFpbGVkIGJlY2F1c2VcbiAgIG9mIGluc3VmZmljaWVudCBpbnB1dCwgb3IgdG8gdmVyaWZ5IHRoYXQgdGhlIG91dHB1dCBhY3R1YWxseVxuICAgbWF0Y2hlcyBmb3IgcmVnZXggdGhhdCBoYXZlIGJvdW5kYXJ5IGNvbmRpdGlvbnMgd2l0aCByZXNwZWN0XG4gICB0byB0aGUgaW5wdXQgc3RyaW5nLlxuKilcbmxldCBmaW5hbF9ib3VuZGFyeV9jaGVjayB+bGFzdCB+c2xlbiByZSBzIH5pbmZvIH5zdCB+Z3JvdXBzID1cbiAgbGV0IGlkeCwgcmVzID1cbiAgICBsZXQgZmluYWxfY2F0ID1cbiAgICAgIENhdGVnb3J5LihcbiAgICAgICAgc2VhcmNoX2JvdW5kYXJ5XG4gICAgICAgICsrIGlmIGxhc3QgPSBzbGVuIHRoZW4gaW5leGlzdGFudCBlbHNlIGNhdGVnb3J5IHJlIH5jb2xvcjooZ2V0X2NvbG9yIHJlIHMgbGFzdCkpXG4gICAgaW5cbiAgICBmaW5hbCBpbmZvIChTdGF0ZS5nZXRfaW5mbyBzdCkgZmluYWxfY2F0XG4gIGluXG4gIChtYXRjaCBncm91cHMsIHJlcyB3aXRoXG4gICB8IHRydWUsIE1hdGNoIF8gLT4gaW5mby5wb3NpdGlvbnMuKGlkeCkgPC0gbGFzdFxuICAgfCBfIC0+ICgpKTtcbiAgcmVzXG47O1xuXG5sZXQgbWF0Y2hfc3RyIH5ncm91cHMgfnBhcnRpYWwgcmUgcyB+cG9zIH5sZW4gPVxuICBsZXQgc2xlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGFzdCA9IGlmIGxlbiA9IC0xIHRoZW4gc2xlbiBlbHNlIHBvcyArIGxlbiBpblxuICBsZXQgaW5mbyA9XG4gICAgeyByZVxuICAgIDsgcG9zXG4gICAgOyBsYXN0XG4gICAgOyBwb3NpdGlvbnMgPVxuICAgICAgICAoaWYgZ3JvdXBzXG4gICAgICAgICB0aGVuIChcbiAgICAgICAgICAgbGV0IG4gPSBBdXRvbWF0YS5Xb3JraW5nX2FyZWEuaW5kZXhfY291bnQgcmUudGJsICsgMSBpblxuICAgICAgICAgICBpZiBuIDw9IDEwIHRoZW4gW3wgMDsgMDsgMDsgMDsgMDsgMDsgMDsgMDsgMDsgMCB8XSBlbHNlIEFycmF5Lm1ha2UgbiAwKVxuICAgICAgICAgZWxzZSBbfHxdKVxuICAgIH1cbiAgaW5cbiAgbGV0IHN0ID1cbiAgICBsZXQgaW5pdGlhbF9zdGF0ZSA9XG4gICAgICBsZXQgaW5pdGlhbF9jYXQgPVxuICAgICAgICBDYXRlZ29yeS4oXG4gICAgICAgICAgc2VhcmNoX2JvdW5kYXJ5XG4gICAgICAgICAgKysgaWYgcG9zID0gMCB0aGVuIGluZXhpc3RhbnQgZWxzZSBjYXRlZ29yeSByZSB+Y29sb3I6KGdldF9jb2xvciByZSBzIChwb3MgLSAxKSkpXG4gICAgICBpblxuICAgICAgZmluZF9pbml0aWFsX3N0YXRlIHJlIGluaXRpYWxfY2F0XG4gICAgaW5cbiAgICBzY2FuX3N0ciBpbmZvIHMgaW5pdGlhbF9zdGF0ZSB+Z3JvdXBzXG4gIGluXG4gIG1hdGNoXG4gICAgbGV0IHN0YXRlX2luZm8gPSBTdGF0ZS5nZXRfaW5mbyBzdCBpblxuICAgIGlmIHN0YXRlX2luZm8uaWR4ID0gYnJlYWsgfHwgKHBhcnRpYWwgJiYgbm90IGdyb3VwcylcbiAgICB0aGVuIEF1dG9tYXRhLlN0YXRlLnN0YXR1cyBzdGF0ZV9pbmZvLmRlc2NcbiAgICBlbHNlIGlmIHBhcnRpYWwgJiYgZ3JvdXBzXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBBdXRvbWF0YS5TdGF0ZS5zdGF0dXMgc3RhdGVfaW5mby5kZXNjIHdpdGhcbiAgICAgIHwgKE1hdGNoIF8gfCBGYWlsZWQpIGFzIHN0YXR1cyAtPiBzdGF0dXNcbiAgICAgIHwgUnVubmluZyAtPlxuICAgICAgICAoKiBUaGlzIGNvdWxkIGJlIGJlY2F1c2UgaXQncyBzdGlsbCBub3QgZnVsbHkgbWF0Y2hlZCwgb3IgaXRcbiAgICAgICAgICAgY291bGQgYmUgdGhhdCBiZWNhdXNlIHdlIG5lZWQgdG8gcnVuIHNwZWNpYWwgZW5kIG9mIGlucHV0XG4gICAgICAgICAgIGNoZWNrcy4gKilcbiAgICAgICAgKG1hdGNoIGZpbmFsX2JvdW5kYXJ5X2NoZWNrIH5sYXN0IH5zbGVuIHJlIHMgfmluZm8gfnN0IH5ncm91cHMgd2l0aFxuICAgICAgICAgfCBNYXRjaCBfIGFzIHN0YXR1cyAtPiBzdGF0dXNcbiAgICAgICAgIHwgRmFpbGVkIHwgUnVubmluZyAtPlxuICAgICAgICAgICAoKiBBIGZhaWx1cmUgaGVyZSBqdXN0IG1lYW5zIHRoYXQgd2UgbmVlZCBtb3JlIGRhdGEsIGkuZS5cbiAgICAgICAgICAgICAgaXQncyBhIHBhcnRpYWwgbWF0Y2guICopXG4gICAgICAgICAgIFJ1bm5pbmcpKVxuICAgIGVsc2UgZmluYWxfYm91bmRhcnlfY2hlY2sgfmxhc3QgfnNsZW4gcmUgcyB+aW5mbyB+c3Qgfmdyb3Vwc1xuICB3aXRoXG4gIHwgTWF0Y2ggKG1hcmtzLCBwbWFya3MpIC0+XG4gICAgTWF0Y2ggeyBzOyBtYXJrczsgcG1hcmtzOyBncG9zID0gaW5mby5wb3NpdGlvbnM7IGdjb3VudCA9IHJlLmdyb3VwX2NvdW50IH1cbiAgfCBGYWlsZWQgLT4gRmFpbGVkXG4gIHwgUnVubmluZyAtPlxuICAgIGxldCBub19tYXRjaF9zdGFydHNfYmVmb3JlID0gaWYgZ3JvdXBzIHRoZW4gaW5mby5wb3NpdGlvbnMuKDApIGVsc2UgMCBpblxuICAgIFJ1bm5pbmcgeyBub19tYXRjaF9zdGFydHNfYmVmb3JlIH1cbjs7XG5cbmxldCBta19yZSB+aW5pdGlhbCB+Y29sb3JzIH5jb2xvcl9yZXByIH5uY29sb3IgfmxubCB+Z3JvdXBfbmFtZXMgfmdyb3VwX2NvdW50ID1cbiAgeyBpbml0aWFsXG4gIDsgaW5pdGlhbF9zdGF0ZXMgPSBbXVxuICA7IGNvbG9yc1xuICA7IGNvbG9yX3JlcHJcbiAgOyBuY29sb3JcbiAgOyBsbmxcbiAgOyB0YmwgPSBBdXRvbWF0YS5Xb3JraW5nX2FyZWEuY3JlYXRlICgpXG4gIDsgc3RhdGVzID0gQXV0b21hdGEuU3RhdGUuVGFibGUuY3JlYXRlIDk3XG4gIDsgZ3JvdXBfbmFtZXNcbiAgOyBncm91cF9jb3VudFxuICB9XG47O1xuXG4oKioqKiBDb21waWxhdGlvbiAqKioqKVxuXG5tb2R1bGUgQSA9IEF1dG9tYXRhXG5cbmxldCBlbmZvcmNlX2tpbmQgaWRzIGtpbmQga2luZCcgY3IgPVxuICBtYXRjaCBraW5kLCBraW5kJyB3aXRoXG4gIHwgYEZpcnN0LCBgRmlyc3QgLT4gY3JcbiAgfCBgRmlyc3QsIGsgLT4gQS5zZXEgaWRzIGsgY3IgKEEuZXBzIGlkcylcbiAgfCBfIC0+IGNyXG47O1xuXG50eXBlIGNvbnRleHQgPVxuICB7IGlkcyA6IEEuSWRzLnRcbiAgOyBraW5kIDogQS5TZW0udFxuICA7IGlnbl9ncm91cCA6IGJvb2xcbiAgOyBncmVlZHkgOiBBLlJlcF9raW5kLnRcbiAgOyBwb3MgOiBBLk1hcmsudCByZWZcbiAgOyBuYW1lcyA6IChzdHJpbmcgKiBpbnQpIGxpc3QgcmVmXG4gIDsgY2FjaGUgOiBDc2V0LnQgQ3NldC5DU2V0TWFwLnQgcmVmXG4gIDsgY29sb3JzIDogQ29sb3JfbWFwLlRhYmxlLnRcbiAgfVxuXG5sZXQgdHJhbnNfc2V0IGNhY2hlIChjbSA6IENvbG9yX21hcC5UYWJsZS50KSBzID1cbiAgbWF0Y2ggQ3NldC5vbmVfY2hhciBzIHdpdGhcbiAgfCBTb21lIGkgLT4gQ3NldC5jc2luZ2xlIChDb2xvcl9tYXAuVGFibGUuZ2V0X2NoYXIgY20gaSlcbiAgfCBOb25lIC0+XG4gICAgbGV0IHYgPSBDc2V0Lmhhc2hfcmVjIHMsIHMgaW5cbiAgICAodHJ5IENzZXQuQ1NldE1hcC5maW5kIHYgIWNhY2hlIHdpdGhcbiAgICAgfCBOb3RfZm91bmQgLT5cbiAgICAgICBsZXQgbCA9IENvbG9yX21hcC5UYWJsZS50cmFuc2xhdGVfY29sb3JzIGNtIHMgaW5cbiAgICAgICBjYWNoZSA6PSBDc2V0LkNTZXRNYXAuYWRkIHYgbCAhY2FjaGU7XG4gICAgICAgbClcbjs7XG5cbmxldCBtYWtlX3JlcGVhdGVyIGlkcyBjciBraW5kIGdyZWVkeSA9XG4gIG1hdGNoIGdyZWVkeSB3aXRoXG4gIHwgYEdyZWVkeSAtPiBmdW4gcmVtIC0+IEEuYWx0IGlkcyBbIEEuc2VxIGlkcyBraW5kIChBLnJlbmFtZSBpZHMgY3IpIHJlbTsgQS5lcHMgaWRzIF1cbiAgfCBgTm9uX2dyZWVkeSAtPlxuICAgIGZ1biByZW0gLT4gQS5hbHQgaWRzIFsgQS5lcHMgaWRzOyBBLnNlcSBpZHMga2luZCAoQS5yZW5hbWUgaWRzIGNyKSByZW0gXVxuOztcblxuKCogWFhYIHNob3VsZCBwcm9iYWJseSBjb21wdXRlIGEgY2F0ZWdvcnkgbWFzayAqKVxubGV0IHJlYyB0cmFuc2xhdGVcbiAgKHsgaWRzOyBraW5kOyBpZ25fZ3JvdXA7IGdyZWVkeTsgcG9zOyBuYW1lczsgY2FjaGU7IGNvbG9ycyB9IGFzIGN0eClcbiAgKGFzdCA6IEFzdC5ub19jYXNlKVxuICA9XG4gIG1hdGNoIGFzdCB3aXRoXG4gIHwgU2V0IHMgLT4gQS5jc3QgaWRzICh0cmFuc19zZXQgY2FjaGUgY29sb3JzIHMpLCBraW5kXG4gIHwgU2VxdWVuY2UgbCAtPiB0cmFuc19zZXEgY3R4IGwsIGtpbmRcbiAgfCBBc3QgKEFsdGVybmF0aXZlIGwpIC0+XG4gICAgKG1hdGNoIEFzdC5tZXJnZV9zZXF1ZW5jZXMgbCB3aXRoXG4gICAgIHwgWyByJyBdIC0+XG4gICAgICAgbGV0IGNyLCBraW5kJyA9IHRyYW5zbGF0ZSBjdHggcicgaW5cbiAgICAgICBlbmZvcmNlX2tpbmQgaWRzIGtpbmQga2luZCcgY3IsIGtpbmRcbiAgICAgfCBtZXJnZWRfc2VxdWVuY2VzIC0+XG4gICAgICAgKCBBLmFsdFxuICAgICAgICAgICBpZHNcbiAgICAgICAgICAgKExpc3QubWFwIG1lcmdlZF9zZXF1ZW5jZXMgfmY6KGZ1biByJyAtPlxuICAgICAgICAgICAgICBsZXQgY3IsIGtpbmQnID0gdHJhbnNsYXRlIGN0eCByJyBpblxuICAgICAgICAgICAgICBlbmZvcmNlX2tpbmQgaWRzIGtpbmQga2luZCcgY3IpKVxuICAgICAgICwga2luZCApKVxuICB8IFJlcGVhdCAocicsIGksIGopIC0+XG4gICAgbGV0IGNyLCBraW5kJyA9IHRyYW5zbGF0ZSBjdHggcicgaW5cbiAgICBsZXQgcmVtID1cbiAgICAgIG1hdGNoIGogd2l0aFxuICAgICAgfCBOb25lIC0+IEEucmVwIGlkcyBncmVlZHkga2luZCcgY3JcbiAgICAgIHwgU29tZSBqIC0+XG4gICAgICAgIGxldCBmID0gbWFrZV9yZXBlYXRlciBpZHMgY3Iga2luZCcgZ3JlZWR5IGluXG4gICAgICAgIGl0ZXIgKGogLSBpKSBmIChBLmVwcyBpZHMpXG4gICAgaW5cbiAgICBpdGVyIGkgKGZ1biByZW0gLT4gQS5zZXEgaWRzIGtpbmQnIChBLnJlbmFtZSBpZHMgY3IpIHJlbSkgcmVtLCBraW5kXG4gIHwgQmVnX29mX2xpbmUgLT4gQS5hZnRlciBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbmV3bGluZSksIGtpbmRcbiAgfCBFbmRfb2ZfbGluZSAtPiBBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbmV3bGluZSksIGtpbmRcbiAgfCBCZWdfb2Zfd29yZCAtPlxuICAgICggQS5zZXFcbiAgICAgICAgaWRzXG4gICAgICAgIGBGaXJzdFxuICAgICAgICAoQS5hZnRlciBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbm90X2xldHRlcikpXG4gICAgICAgIChBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkubGV0dGVyKVxuICAgICwga2luZCApXG4gIHwgRW5kX29mX3dvcmQgLT5cbiAgICAoIEEuc2VxXG4gICAgICAgIGlkc1xuICAgICAgICBgRmlyc3RcbiAgICAgICAgKEEuYWZ0ZXIgaWRzIENhdGVnb3J5LmxldHRlcilcbiAgICAgICAgKEEuYmVmb3JlIGlkcyBDYXRlZ29yeS4oaW5leGlzdGFudCArKyBub3RfbGV0dGVyKSlcbiAgICAsIGtpbmQgKVxuICB8IE5vdF9ib3VuZCAtPlxuICAgICggQS5hbHRcbiAgICAgICAgaWRzXG4gICAgICAgIFsgQS5zZXEgaWRzIGBGaXJzdCAoQS5hZnRlciBpZHMgQ2F0ZWdvcnkubGV0dGVyKSAoQS5iZWZvcmUgaWRzIENhdGVnb3J5LmxldHRlcilcbiAgICAgICAgOyAobGV0IGNhdCA9IENhdGVnb3J5LihpbmV4aXN0YW50ICsrIG5vdF9sZXR0ZXIpIGluXG4gICAgICAgICAgIEEuc2VxIGlkcyBgRmlyc3QgKEEuYWZ0ZXIgaWRzIGNhdCkgKEEuYmVmb3JlIGlkcyBjYXQpKVxuICAgICAgICBdXG4gICAgLCBraW5kIClcbiAgfCBCZWdfb2Zfc3RyIC0+IEEuYWZ0ZXIgaWRzIENhdGVnb3J5LmluZXhpc3RhbnQsIGtpbmRcbiAgfCBFbmRfb2Zfc3RyIC0+IEEuYmVmb3JlIGlkcyBDYXRlZ29yeS5pbmV4aXN0YW50LCBraW5kXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSAtPiBBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbGFzdG5ld2xpbmUpLCBraW5kXG4gIHwgU3RhcnQgLT4gQS5hZnRlciBpZHMgQ2F0ZWdvcnkuc2VhcmNoX2JvdW5kYXJ5LCBraW5kXG4gIHwgU3RvcCAtPiBBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuc2VhcmNoX2JvdW5kYXJ5LCBraW5kXG4gIHwgU2VtIChraW5kJywgcicpIC0+XG4gICAgbGV0IGNyLCBraW5kJycgPSB0cmFuc2xhdGUgeyBjdHggd2l0aCBraW5kID0ga2luZCcgfSByJyBpblxuICAgIGVuZm9yY2Vfa2luZCBpZHMga2luZCcga2luZCcnIGNyLCBraW5kJ1xuICB8IFNlbV9ncmVlZHkgKGdyZWVkeScsIHInKSAtPiB0cmFuc2xhdGUgeyBjdHggd2l0aCBncmVlZHkgPSBncmVlZHknIH0gcidcbiAgfCBHcm91cCAobiwgcicpIC0+XG4gICAgaWYgaWduX2dyb3VwXG4gICAgdGhlbiB0cmFuc2xhdGUgY3R4IHInXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcCA9ICFwb3MgaW5cbiAgICAgIGxldCAoKSA9XG4gICAgICAgIG1hdGNoIG4gd2l0aFxuICAgICAgICB8IFNvbWUgbmFtZSAtPiBuYW1lcyA6PSAobmFtZSwgQS5NYXJrLmdyb3VwX2NvdW50IHApIDo6ICFuYW1lc1xuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgIGluXG4gICAgICBwb3MgOj0gQS5NYXJrLm5leHQyICFwb3M7XG4gICAgICBsZXQgY3IsIGtpbmQnID0gdHJhbnNsYXRlIGN0eCByJyBpblxuICAgICAgKCBBLnNlcSBpZHMgYEZpcnN0IChBLm1hcmsgaWRzIHApIChBLnNlcSBpZHMgYEZpcnN0IGNyIChBLm1hcmsgaWRzIChBLk1hcmsubmV4dCBwKSkpXG4gICAgICAsIGtpbmQnICkpXG4gIHwgTm9fZ3JvdXAgcicgLT4gdHJhbnNsYXRlIHsgY3R4IHdpdGggaWduX2dyb3VwID0gdHJ1ZSB9IHInXG4gIHwgTmVzdCByJyAtPlxuICAgIGxldCBiID0gIXBvcyBpblxuICAgIGxldCBjciwga2luZCcgPSB0cmFuc2xhdGUgY3R4IHInIGluXG4gICAgbGV0IGUgPSBBLk1hcmsucHJldiAhcG9zIGluXG4gICAgaWYgZSA8IGIgdGhlbiBjciwga2luZCcgZWxzZSBBLnNlcSBpZHMgYEZpcnN0IChBLmVyYXNlIGlkcyBiIGUpIGNyLCBraW5kJ1xuICB8IFBtYXJrIChpLCByJykgLT5cbiAgICBsZXQgY3IsIGtpbmQnID0gdHJhbnNsYXRlIGN0eCByJyBpblxuICAgIEEuc2VxIGlkcyBgRmlyc3QgKEEucG1hcmsgaWRzIGkpIGNyLCBraW5kJ1xuXG5hbmQgdHJhbnNfc2VxICh7IGlkczsga2luZDsgXyB9IGFzIGN0eCkgPSBmdW5jdGlvblxuICB8IFtdIC0+IEEuZXBzIGlkc1xuICB8IFsgciBdIC0+XG4gICAgbGV0IGNyJywga2luZCcgPSB0cmFuc2xhdGUgY3R4IHIgaW5cbiAgICBlbmZvcmNlX2tpbmQgaWRzIGtpbmQga2luZCcgY3InXG4gIHwgciA6OiByZW0gLT5cbiAgICBsZXQgY3InLCBraW5kJyA9IHRyYW5zbGF0ZSBjdHggciBpblxuICAgIGxldCBjcicnID0gdHJhbnNfc2VxIGN0eCByZW0gaW5cbiAgICBpZiBBLmlzX2VwcyBjcicnIHRoZW4gY3InIGVsc2UgaWYgQS5pc19lcHMgY3InIHRoZW4gY3InJyBlbHNlIEEuc2VxIGlkcyBraW5kJyBjcicgY3InJ1xuOztcblxubGV0IGNvbXBpbGVfMSByZWdleHAgPVxuICBsZXQgcmVnZXhwID0gQXN0LmhhbmRsZV9jYXNlIGZhbHNlIHJlZ2V4cCBpblxuICBsZXQgY29sb3JfbWFwID0gQ29sb3JfbWFwLm1ha2UgKCkgaW5cbiAgbGV0IG5lZWRfbG5sID0gQXN0LmNvbG9yaXplIGNvbG9yX21hcCByZWdleHAgaW5cbiAgbGV0IGNvbG9ycywgY29sb3JfcmVwciA9IENvbG9yX21hcC5mbGF0dGVuIGNvbG9yX21hcCBpblxuICBsZXQgbmNvbG9yID0gQ29sb3JfbWFwLlJlcHIubGVuZ3RoIGNvbG9yX3JlcHIgaW5cbiAgbGV0IGxubCA9IGlmIG5lZWRfbG5sIHRoZW4gbmNvbG9yIGVsc2UgLTEgaW5cbiAgbGV0IG5jb2xvciA9IGlmIG5lZWRfbG5sIHRoZW4gbmNvbG9yICsgMSBlbHNlIG5jb2xvciBpblxuICBsZXQgY3R4ID1cbiAgICB7IGlkcyA9IEEuSWRzLmNyZWF0ZSAoKVxuICAgIDsga2luZCA9IGBGaXJzdFxuICAgIDsgaWduX2dyb3VwID0gZmFsc2VcbiAgICA7IGdyZWVkeSA9IGBHcmVlZHlcbiAgICA7IHBvcyA9IHJlZiBBLk1hcmsuc3RhcnRcbiAgICA7IG5hbWVzID0gcmVmIFtdXG4gICAgOyBjYWNoZSA9IHJlZiBDc2V0LkNTZXRNYXAuZW1wdHlcbiAgICA7IGNvbG9yc1xuICAgIH1cbiAgaW5cbiAgbGV0IHIsIGtpbmQgPSB0cmFuc2xhdGUgY3R4IHJlZ2V4cCBpblxuICBsZXQgciA9IGVuZm9yY2Vfa2luZCBjdHguaWRzIGBGaXJzdCBraW5kIHIgaW5cbiAgKCpGb3JtYXQuZXByaW50ZiBcIjwlZCAlZD5ALlwiICFpZHMgbmNvbDsqKVxuICBta19yZVxuICAgIH5pbml0aWFsOnJcbiAgICB+Y29sb3JzXG4gICAgfmNvbG9yX3JlcHJcbiAgICB+bmNvbG9yXG4gICAgfmxubFxuICAgIH5ncm91cF9uYW1lczooTGlzdC5yZXYgIShjdHgubmFtZXMpKVxuICAgIH5ncm91cF9jb3VudDooQS5NYXJrLmdyb3VwX2NvdW50ICEoY3R4LnBvcykpXG47O1xuXG5sZXQgY29tcGlsZSByID1cbiAgbGV0IG9wZW4gQXN0LkV4cG9ydCBpblxuICBjb21waWxlXzFcbiAgICAoaWYgQXN0LmFuY2hvcmVkIHJcbiAgICAgdGhlbiBncm91cCByXG4gICAgIGVsc2Ugc2VxIFsgc2hvcnRlc3QgKHJlcCAoQXN0LmNzZXQgQ3NldC5jYW55KSk7IGdyb3VwIHIgXSlcbjs7XG4iLCJsZXQgYWxsID8ocG9zID0gMCkgP2xlbiByZSBzIDogXyBTZXEudCA9XG4gIGlmIHBvcyA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLmFsbFwiO1xuICAoKiBpbmRleCBvZiB0aGUgZmlyc3QgcG9zaXRpb24gd2UgZG8gbm90IGNvbnNpZGVyLlxuICAgICAhcG9zIDwgbGltaXQgaXMgYW4gaW52YXJpYW50ICopXG4gIGxldCBsaW1pdCA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IE5vbmUgLT4gU3RyaW5nLmxlbmd0aCBzXG4gICAgfCBTb21lIGwgLT5cbiAgICAgIGlmIGwgPCAwIHx8IHBvcyArIGwgPiBTdHJpbmcubGVuZ3RoIHMgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLmFsbFwiO1xuICAgICAgcG9zICsgbFxuICBpblxuICAoKiBpdGVyYXRlIG9uIG1hdGNoZXMuIFdoZW4gYSBtYXRjaCBpcyBmb3VuZCwgc2VhcmNoIGZvciB0aGUgbmV4dFxuICAgICBvbmUganVzdCBhZnRlciBpdHMgZW5kICopXG4gIGxldCByZWMgYXV4IHBvcyBvbl9tYXRjaCAoKSA9XG4gICAgaWYgcG9zID4gbGltaXRcbiAgICB0aGVuIFNlcS5OaWwgKCogbm8gbW9yZSBtYXRjaGVzICopXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaFxuICAgICAgICBDb21waWxlLm1hdGNoX3N0ciB+Z3JvdXBzOnRydWUgfnBhcnRpYWw6ZmFsc2UgcmUgcyB+cG9zIH5sZW46KGxpbWl0IC0gcG9zKVxuICAgICAgd2l0aFxuICAgICAgfCBNYXRjaCBzdWJzdHIgLT5cbiAgICAgICAgbGV0IHAxLCBwMiA9IEdyb3VwLm9mZnNldCBzdWJzdHIgMCBpblxuICAgICAgICBpZiBvbl9tYXRjaCAmJiBwMSA9IHBvcyAmJiBwMSA9IHAyXG4gICAgICAgIHRoZW4gKCogc2tpcCBlbXB0eSBtYXRjaCByaWdodCBhZnRlciBhIG1hdGNoICopXG4gICAgICAgICAgYXV4IChwb3MgKyAxKSBmYWxzZSAoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgcG9zID0gaWYgcDEgPSBwMiB0aGVuIHAyICsgMSBlbHNlIHAyIGluXG4gICAgICAgICAgU2VxLkNvbnMgKHN1YnN0ciwgYXV4IHBvcyAocDEgPD4gcDIpKSlcbiAgICAgIHwgUnVubmluZyBfIHwgRmFpbGVkIC0+IFNlcS5OaWwpXG4gIGluXG4gIGF1eCBwb3MgZmFsc2Vcbjs7XG5cbmxldCBtYXRjaGVzID9wb3MgP2xlbiByZSBzIDogXyBTZXEudCA9XG4gIGFsbCA/cG9zID9sZW4gcmUgcyB8PiBTZXEubWFwIChmdW4gc3ViIC0+IEdyb3VwLmdldCBzdWIgMClcbjs7XG5cbmxldCBzcGxpdF9mdWxsID8ocG9zID0gMCkgP2xlbiByZSBzIDogXyBTZXEudCA9XG4gIGlmIHBvcyA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLnNwbGl0XCI7XG4gIGxldCBsaW1pdCA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IE5vbmUgLT4gU3RyaW5nLmxlbmd0aCBzXG4gICAgfCBTb21lIGwgLT5cbiAgICAgIGlmIGwgPCAwIHx8IHBvcyArIGwgPiBTdHJpbmcubGVuZ3RoIHMgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLnNwbGl0XCI7XG4gICAgICBwb3MgKyBsXG4gIGluXG4gICgqIGk6IHN0YXJ0IG9mIGRlbGltaXRlZCBzdHJpbmdcbiAgICAgcG9zOiBmaXJzdCBwb3NpdGlvbiBhZnRlciBsYXN0IG1hdGNoIG9mIFtyZV1cbiAgICAgbGltaXQ6IGZpcnN0IGluZGV4IHdlIGlnbm9yZSAoIXBvcyA8IGxpbWl0IGlzIGFuIGludmFyaWFudCkgKilcbiAgbGV0IHBvczAgPSBwb3MgaW5cbiAgbGV0IHJlYyBhdXggc3RhdGUgaSBwb3MgKCkgPVxuICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICB8IGBJZGxlIHdoZW4gcG9zID4gbGltaXQgLT5cbiAgICAgICgqIFdlIGhhZCBhbiBlbXB0eSBtYXRjaCBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgKilcbiAgICAgIGFzc2VydCAoaSA9IGxpbWl0KTtcbiAgICAgIFNlcS5OaWxcbiAgICB8IGBJZGxlIC0+XG4gICAgICAobWF0Y2hcbiAgICAgICAgIENvbXBpbGUubWF0Y2hfc3RyIH5ncm91cHM6dHJ1ZSB+cGFydGlhbDpmYWxzZSByZSBzIH5wb3MgfmxlbjoobGltaXQgLSBwb3MpXG4gICAgICAgd2l0aFxuICAgICAgIHwgTWF0Y2ggc3Vic3RyIC0+XG4gICAgICAgICBsZXQgcDEsIHAyID0gR3JvdXAub2Zmc2V0IHN1YnN0ciAwIGluXG4gICAgICAgICBsZXQgcG9zID0gaWYgcDEgPSBwMiB0aGVuIHAyICsgMSBlbHNlIHAyIGluXG4gICAgICAgICBsZXQgb2xkX2kgPSBpIGluXG4gICAgICAgICBsZXQgaSA9IHAyIGluXG4gICAgICAgICBpZiBvbGRfaSA9IHAxICYmIHAxID0gcDIgJiYgcDEgPiBwb3MwXG4gICAgICAgICB0aGVuICgqIFNraXAgZW1wdHkgbWF0Y2ggcmlnaHQgYWZ0ZXIgYSBkZWxpbWl0ZXIgKilcbiAgICAgICAgICAgYXV4IHN0YXRlIGkgcG9zICgpXG4gICAgICAgICBlbHNlIGlmIHAxID4gcG9zMFxuICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICgqIHN0cmluZyBkb2VzIG5vdCBzdGFydCBieSBhIGRlbGltaXRlciAqKVxuICAgICAgICAgICBsZXQgdGV4dCA9IFN0cmluZy5zdWIgcyBvbGRfaSAocDEgLSBvbGRfaSkgaW5cbiAgICAgICAgICAgbGV0IHN0YXRlID0gYFlpZWxkIChgRGVsaW0gc3Vic3RyKSBpblxuICAgICAgICAgICBTZXEuQ29ucyAoYFRleHQgdGV4dCwgYXV4IHN0YXRlIGkgcG9zKSlcbiAgICAgICAgIGVsc2UgU2VxLkNvbnMgKGBEZWxpbSBzdWJzdHIsIGF1eCBzdGF0ZSBpIHBvcylcbiAgICAgICB8IFJ1bm5pbmcgXyAtPiBTZXEuTmlsXG4gICAgICAgfCBGYWlsZWQgLT5cbiAgICAgICAgIGlmIGkgPCBsaW1pdFxuICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgIGxldCB0ZXh0ID0gU3RyaW5nLnN1YiBzIGkgKGxpbWl0IC0gaSkgaW5cbiAgICAgICAgICAgKCogeWllbGQgbGFzdCBzdHJpbmcgKilcbiAgICAgICAgICAgU2VxLkNvbnMgKGBUZXh0IHRleHQsIGF1eCBzdGF0ZSBsaW1pdCBwb3MpKVxuICAgICAgICAgZWxzZSBTZXEuTmlsKVxuICAgIHwgYFlpZWxkIHggLT4gU2VxLkNvbnMgKHgsIGF1eCBgSWRsZSBpIHBvcylcbiAgaW5cbiAgYXV4IGBJZGxlIHBvcyBwb3Ncbjs7XG5cbmxldCBzcGxpdCA/cG9zID9sZW4gcmUgcyA6IF8gU2VxLnQgPVxuICBsZXQgc2VxID0gc3BsaXRfZnVsbCA/cG9zID9sZW4gcmUgcyBpblxuICBsZXQgcmVjIGZpbHRlciBzZXEgKCkgPVxuICAgIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBTZXEuTmlsIC0+IFNlcS5OaWxcbiAgICB8IFNlcS5Db25zIChgRGVsaW0gXywgdGwpIC0+IGZpbHRlciB0bCAoKVxuICAgIHwgU2VxLkNvbnMgKGBUZXh0IHMsIHRsKSAtPiBTZXEuQ29ucyAocywgZmlsdGVyIHRsKVxuICBpblxuICBmaWx0ZXIgc2VxXG47O1xuXG5sZXQgc3BsaXRfZGVsaW0gP3BvcyA/bGVuIHJlIHMgOiBfIFNlcS50ID1cbiAgbGV0IHNlcSA9IHNwbGl0X2Z1bGwgP3BvcyA/bGVuIHJlIHMgaW5cbiAgbGV0IHJlYyBmaWx0ZXIgfmRlbGltIHNlcSAoKSA9XG4gICAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IFNlcS5OaWwgLT4gaWYgZGVsaW0gdGhlbiBTZXEuQ29ucyAoXCJcIiwgZnVuICgpIC0+IFNlcS5OaWwpIGVsc2UgU2VxLk5pbFxuICAgIHwgU2VxLkNvbnMgKGBEZWxpbSBfLCB0bCkgLT5cbiAgICAgIGlmIGRlbGltXG4gICAgICB0aGVuIFNlcS5Db25zIChcIlwiLCBmdW4gKCkgLT4gZmlsdGVyIH5kZWxpbTp0cnVlIHRsICgpKVxuICAgICAgZWxzZSBmaWx0ZXIgfmRlbGltOnRydWUgdGwgKClcbiAgICB8IFNlcS5Db25zIChgVGV4dCBzLCB0bCkgLT4gU2VxLkNvbnMgKHMsIGZpbHRlciB+ZGVsaW06ZmFsc2UgdGwpXG4gIGluXG4gIGZpbHRlciB+ZGVsaW06dHJ1ZSBzZXFcbjs7XG4iLCIoKlxuICAgUkUgLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaWJyYXJ5XG5cbiAgIENvcHlyaWdodCAoQykgMjAwMSBKZXJvbWUgVm91aWxsb25cbiAgIGVtYWlsOiBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnJcblxuICAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aFxuICAgbGlua2luZyBleGNlcHRpb247IGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0XG4gICB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gICBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gICBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBXG4qKVxuXG5vcGVuIEltcG9ydFxuXG5pbmNsdWRlIHN0cnVjdFxuICBsZXQgY3NldCA9IEFzdC5jc2V0XG4gIGxldCBjaGFyIGMgPSBjc2V0IChDc2V0LmNzaW5nbGUgYylcbiAgbGV0IHJnIGMgYycgPSBjc2V0IChDc2V0LmNzZXEgYyBjJylcbiAgbGV0IGFueSA9IGNzZXQgQ3NldC5jYW55XG4gIGxldCBub3RubCA9IGNzZXQgQ3NldC5ub3RubFxuICBsZXQgbG93ZXIgPSBjc2V0IENzZXQubG93ZXJcbiAgbGV0IHVwcGVyID0gY3NldCBDc2V0LnVwcGVyXG4gIGxldCBhbHBoYSA9IGNzZXQgQ3NldC5hbHBoYVxuICBsZXQgZGlnaXQgPSBjc2V0IENzZXQuY2RpZ2l0XG4gIGxldCBhbG51bSA9IGNzZXQgQ3NldC5hbG51bVxuICBsZXQgd29yZGMgPSBjc2V0IENzZXQud29yZGNcbiAgbGV0IGFzY2lpID0gY3NldCBDc2V0LmFzY2lpXG4gIGxldCBibGFuayA9IGNzZXQgQ3NldC5ibGFua1xuICBsZXQgY250cmwgPSBjc2V0IENzZXQuY250cmxcbiAgbGV0IGdyYXBoID0gY3NldCBDc2V0LmdyYXBoXG4gIGxldCBwcmludCA9IGNzZXQgQ3NldC5wcmludFxuICBsZXQgcHVuY3QgPSBjc2V0IENzZXQucHVuY3RcbiAgbGV0IHNwYWNlID0gY3NldCBDc2V0LnNwYWNlXG4gIGxldCB4ZGlnaXQgPSBjc2V0IENzZXQueGRpZ2l0XG5lbmRcblxuaW5jbHVkZSBBc3QuRXhwb3J0XG5cbmxldCBleGVjX2ludGVybmFsID8ocG9zID0gMCkgPyhsZW4gPSAtMSkgfnBhcnRpYWwgfmdyb3VwcyByZSBzID1cbiAgQ29tcGlsZS5tYXRjaF9zdHIgfmdyb3VwcyB+cGFydGlhbCByZSBzIH5wb3MgfmxlblxuOztcblxubGV0IGV4ZWMgP3BvcyA/bGVuIHJlIHMgPVxuICBtYXRjaCBleGVjX2ludGVybmFsID9wb3MgP2xlbiB+Z3JvdXBzOnRydWUgfnBhcnRpYWw6ZmFsc2UgcmUgcyB3aXRoXG4gIHwgTWF0Y2ggc3Vic3RyIC0+IHN1YnN0clxuICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG47O1xuXG5sZXQgZXhlY19vcHQgP3BvcyA/bGVuIHJlIHMgPVxuICBtYXRjaCBleGVjX2ludGVybmFsID9wb3MgP2xlbiB+Z3JvdXBzOnRydWUgfnBhcnRpYWw6ZmFsc2UgcmUgcyB3aXRoXG4gIHwgTWF0Y2ggc3Vic3RyIC0+IFNvbWUgc3Vic3RyXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgZXhlY3AgP3BvcyA/bGVuIHJlIHMgPVxuICBtYXRjaCBleGVjX2ludGVybmFsIH5ncm91cHM6ZmFsc2UgfnBhcnRpYWw6ZmFsc2UgP3BvcyA/bGVuIHJlIHMgd2l0aFxuICB8IE1hdGNoIF9zdWJzdHIgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBleGVjX3BhcnRpYWwgP3BvcyA/bGVuIHJlIHMgPVxuICBtYXRjaCBleGVjX2ludGVybmFsIH5ncm91cHM6ZmFsc2UgfnBhcnRpYWw6dHJ1ZSA/cG9zID9sZW4gcmUgcyB3aXRoXG4gIHwgTWF0Y2ggXyAtPiBgRnVsbFxuICB8IFJ1bm5pbmcgXyAtPiBgUGFydGlhbFxuICB8IEZhaWxlZCAtPiBgTWlzbWF0Y2hcbjs7XG5cbmxldCBleGVjX3BhcnRpYWxfZGV0YWlsZWQgP3BvcyA/bGVuIHJlIHMgPVxuICBtYXRjaCBleGVjX2ludGVybmFsIH5ncm91cHM6dHJ1ZSB+cGFydGlhbDp0cnVlID9wb3MgP2xlbiByZSBzIHdpdGhcbiAgfCBNYXRjaCBncm91cCAtPiBgRnVsbCBncm91cFxuICB8IFJ1bm5pbmcgeyBub19tYXRjaF9zdGFydHNfYmVmb3JlIH0gLT4gYFBhcnRpYWwgbm9fbWF0Y2hfc3RhcnRzX2JlZm9yZVxuICB8IEZhaWxlZCAtPiBgTWlzbWF0Y2hcbjs7XG5cbm1vZHVsZSBNYXJrID0gc3RydWN0XG4gIHR5cGUgdCA9IFBtYXJrLnRcblxuICBsZXQgdGVzdCAoZyA6IEdyb3VwLnQpIHAgPSBQbWFyay5TZXQubWVtIHAgZy5wbWFya3NcbiAgbGV0IGFsbCAoZyA6IEdyb3VwLnQpID0gZy5wbWFya3NcblxuICBtb2R1bGUgU2V0ID0gUG1hcmsuU2V0XG5cbiAgbGV0IGVxdWFsID0gUG1hcmsuZXF1YWxcbiAgbGV0IGNvbXBhcmUgPSBQbWFyay5jb21wYXJlXG5lbmRcblxudHlwZSBzcGxpdF90b2tlbiA9XG4gIFsgYFRleHQgb2Ygc3RyaW5nXG4gIHwgYERlbGltIG9mIEdyb3VwLnRcbiAgXVxuXG5tb2R1bGUgR2VuID0gc3RydWN0XG4gIHR5cGUgJ2EgZ2VuID0gdW5pdCAtPiAnYSBvcHRpb25cblxuICBsZXQgZ2VuX29mX3NlcSAocyA6ICdhIFNlcS50KSA6ICdhIGdlbiA9XG4gICAgbGV0IHIgPSByZWYgcyBpblxuICAgIGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggIXIgKCkgd2l0aFxuICAgICAgfCBTZXEuTmlsIC0+IE5vbmVcbiAgICAgIHwgU2VxLkNvbnMgKHgsIHRsKSAtPlxuICAgICAgICByIDo9IHRsO1xuICAgICAgICBTb21lIHhcbiAgOztcblxuICBsZXQgc3BsaXQgP3BvcyA/bGVuIHJlIHMgOiBfIGdlbiA9IFNlYXJjaC5zcGxpdCA/cG9zID9sZW4gcmUgcyB8PiBnZW5fb2Zfc2VxXG4gIGxldCBzcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzIDogXyBnZW4gPSBTZWFyY2guc3BsaXRfZnVsbCA/cG9zID9sZW4gcmUgcyB8PiBnZW5fb2Zfc2VxXG4gIGxldCBhbGwgP3BvcyA/bGVuIHJlIHMgPSBTZWFyY2guYWxsID9wb3MgP2xlbiByZSBzIHw+IGdlbl9vZl9zZXFcbiAgbGV0IG1hdGNoZXMgP3BvcyA/bGVuIHJlIHMgPSBTZWFyY2gubWF0Y2hlcyA/cG9zID9sZW4gcmUgcyB8PiBnZW5fb2Zfc2VxXG5lbmRcblxubW9kdWxlIEdyb3VwID0gR3JvdXBcblxuKCoqIHsyIERlcHJlY2F0ZWQgZnVuY3Rpb25zfSAqKVxuXG5sZXQgc3BsaXRfZnVsbF9zZXEgPSBTZWFyY2guc3BsaXRfZnVsbFxubGV0IHNwbGl0X3NlcSA9IFNlYXJjaC5zcGxpdFxubGV0IG1hdGNoZXNfc2VxID0gU2VhcmNoLm1hdGNoZXNcbmxldCBhbGxfc2VxID0gU2VhcmNoLmFsbFxuXG50eXBlICdhIGdlbiA9ICdhIEdlbi5nZW5cblxubGV0IGFsbF9nZW4gPSBHZW4uYWxsXG5sZXQgbWF0Y2hlc19nZW4gPSBHZW4ubWF0Y2hlc1xubGV0IHNwbGl0X2dlbiA9IEdlbi5zcGxpdFxubGV0IHNwbGl0X2Z1bGxfZ2VuID0gR2VuLnNwbGl0X2Z1bGxcblxudHlwZSBzdWJzdHJpbmdzID0gR3JvdXAudFxuXG5sZXQgZ2V0ID0gR3JvdXAuZ2V0XG5sZXQgZ2V0X29mcyA9IEdyb3VwLm9mZnNldFxubGV0IGdldF9hbGwgPSBHcm91cC5hbGxcbmxldCBnZXRfYWxsX29mcyA9IEdyb3VwLmFsbF9vZmZzZXRcbmxldCB0ZXN0ID0gR3JvdXAudGVzdFxuXG50eXBlIG1hcmtpZCA9IE1hcmsudFxuXG5sZXQgbWFya2VkID0gTWFyay50ZXN0XG5sZXQgbWFya19zZXQgPSBNYXJrLmFsbFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCpcbiAgIEluZm9ybWF0aW9uIGFib3V0IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXI6XG4gICAtIGRvZXMgbm90IGV4aXN0c1xuICAgLSBpcyBhIGxldHRlclxuICAgLSBpcyBub3QgYSBsZXR0ZXJcbiAgIC0gaXMgYSBuZXdsaW5lXG4gICAtIGlzIGxhc3QgbmV3bGluZVxuXG4gICBCZWdpbm5pbmcgb2Ygd29yZDpcbiAgIC0gcHJldmlvdXMgaXMgbm90IGEgbGV0dGVyIG9yIGRvZXMgbm90IGV4aXN0XG4gICAtIGN1cnJlbnQgaXMgYSBsZXR0ZXIgb3IgZG9lcyBub3QgZXhpc3RcblxuICAgRW5kIG9mIHdvcmQ6XG4gICAtIHByZXZpb3VzIGlzIGEgbGV0dGVyIG9yIGRvZXMgbm90IGV4aXN0XG4gICAtIGN1cnJlbnQgaXMgbm90IGEgbGV0dGVyIG9yIGRvZXMgbm90IGV4aXN0XG5cbiAgIEJlZ2lubmluZyBvZiBsaW5lOlxuICAgLSBwcmV2aW91cyBpcyBhIG5ld2xpbmUgb3IgZG9lcyBub3QgZXhpc3RcblxuICAgQmVnaW5uaW5nIG9mIGJ1ZmZlcjpcbiAgIC0gcHJldmlvdXMgZG9lcyBub3QgZXhpc3RcblxuICAgRW5kIG9mIGJ1ZmZlclxuICAgLSBjdXJyZW50IGRvZXMgbm90IGV4aXN0XG5cbiAgIEVuZCBvZiBsaW5lXG4gICAtIGN1cnJlbnQgaXMgYSBuZXdsaW5lIG9yIGRvZXMgbm90IGV4aXN0XG4qKVxuXG4oKlxuICAgUmVwOiBlID0gVCxlIHwgKClcbiAgLSBzZW1hbnRpY3Mgb2YgdGhlIGNvbW1hIChzaG9ydGVzdC9sb25nZXN0L2ZpcnN0KVxuICAtIHNlbWFudGljcyBvZiB0aGUgdW5pb24gKGdyZWVkeS9ub24tZ3JlZWR5KVxuXG5Cb3VuZGVkIHJlcGV0aXRpb25cbiAgYXswLDN9ID0gKGEsKGEsYT8pPyk/XG4qKVxuXG50eXBlIGdyb3VwcyA9IEdyb3VwLnRcblxubW9kdWxlIExpc3QgPSBzdHJ1Y3RcbiAgbGV0IGxpc3Rfb2Zfc2VxIChzIDogJ2EgU2VxLnQpIDogJ2EgbGlzdCA9XG4gICAgU2VxLmZvbGRfbGVmdCAoZnVuIGwgeCAtPiB4IDo6IGwpIFtdIHMgfD4gTGlzdC5yZXZcbiAgOztcblxuICBsZXQgYWxsID9wb3MgP2xlbiByZSBzID0gU2VhcmNoLmFsbCA/cG9zID9sZW4gcmUgcyB8PiBsaXN0X29mX3NlcVxuICBsZXQgbWF0Y2hlcyA/cG9zID9sZW4gcmUgcyA9IFNlYXJjaC5tYXRjaGVzID9wb3MgP2xlbiByZSBzIHw+IGxpc3Rfb2Zfc2VxXG4gIGxldCBzcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzID0gU2VhcmNoLnNwbGl0X2Z1bGwgP3BvcyA/bGVuIHJlIHMgfD4gbGlzdF9vZl9zZXFcbiAgbGV0IHNwbGl0ID9wb3MgP2xlbiByZSBzID0gU2VhcmNoLnNwbGl0ID9wb3MgP2xlbiByZSBzIHw+IGxpc3Rfb2Zfc2VxXG4gIGxldCBzcGxpdF9kZWxpbSA/cG9zID9sZW4gcmUgcyA9IFNlYXJjaC5zcGxpdF9kZWxpbSA/cG9zID9sZW4gcmUgcyB8PiBsaXN0X29mX3NlcVxuZW5kXG5cbmluY2x1ZGUgTGlzdFxuXG5pbmNsdWRlIHN0cnVjdFxuICBvcGVuIENvbXBpbGVcblxuICB0eXBlIG5vbnJlYyByZSA9IHJlXG5cbiAgbGV0IGNvbXBpbGUgPSBjb21waWxlXG4gIGxldCBwcF9yZSA9IHBwX3JlXG4gIGxldCBwcmludF9yZSA9IHByaW50X3JlXG4gIGxldCBncm91cF9uYW1lcyA9IGdyb3VwX25hbWVzXG4gIGxldCBncm91cF9jb3VudCA9IGdyb3VwX2NvdW50XG5lbmRcblxubW9kdWxlIFNlcSA9IFNlYXJjaFxuIiwidHlwZSB0ID1cbiAgeyBzdHIgOiBzdHJpbmdcbiAgOyBtdXRhYmxlIHBvcyA6IGludFxuICB9XG5cbmV4Y2VwdGlvbiBQYXJzZV9lcnJvclxuXG5sZXQgY3JlYXRlIHN0ciA9IHsgc3RyOyBwb3MgPSAwIH1cbmxldCB1bmdldCB0ID0gdC5wb3MgPC0gdC5wb3MgLSAxXG5sZXQganVuayB0ID0gdC5wb3MgPC0gdC5wb3MgKyAxXG5sZXQgZW9zIHQgPSB0LnBvcyA9IFN0cmluZy5sZW5ndGggdC5zdHJcbmxldCB0ZXN0IHQgYyA9IChub3QgKGVvcyB0KSkgJiYgdC5zdHIuW3QucG9zXSA9IGNcblxubGV0IHRlc3QyIHQgYyBjJyA9XG4gIHQucG9zICsgMSA8IFN0cmluZy5sZW5ndGggdC5zdHIgJiYgdC5zdHIuW3QucG9zXSA9IGMgJiYgdC5zdHIuW3QucG9zICsgMV0gPSBjJ1xuOztcblxubGV0IGFjY2VwdCB0IGMgPVxuICBsZXQgciA9IHRlc3QgdCBjIGluXG4gIGlmIHIgdGhlbiB0LnBvcyA8LSB0LnBvcyArIDE7XG4gIHJcbjs7XG5cbmxldCBhY2NlcHQyIHQgYyBjJyA9XG4gIGxldCByID0gdGVzdDIgdCBjIGMnIGluXG4gIGlmIHIgdGhlbiB0LnBvcyA8LSB0LnBvcyArIDI7XG4gIHJcbjs7XG5cbmxldCBnZXQgdCA9XG4gIGxldCByID0gdC5zdHIuW3QucG9zXSBpblxuICB0LnBvcyA8LSB0LnBvcyArIDE7XG4gIHJcbjs7XG5cbmxldCBhY2NlcHRfcyB0IHMnID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcycgaW5cbiAgdHJ5XG4gICAgZm9yIGogPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIHRyeSBpZiBzJy5bal0gPD4gdC5zdHIuW3QucG9zICsgal0gdGhlbiByYWlzZV9ub3RyYWNlIEV4aXQgd2l0aFxuICAgICAgfCBfIC0+IHJhaXNlX25vdHJhY2UgRXhpdFxuICAgIGRvbmU7XG4gICAgdC5wb3MgPC0gdC5wb3MgKyBsZW47XG4gICAgdHJ1ZVxuICB3aXRoXG4gIHwgRXhpdCAtPiBmYWxzZVxuOztcblxubGV0IHJlYyBpbnRlZ2VyJyB0IGkgPVxuICBpZiBlb3MgdFxuICB0aGVuIFNvbWUgaVxuICBlbHNlIChcbiAgICBtYXRjaCBnZXQgdCB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGQgLT5cbiAgICAgIGxldCBpJyA9ICgxMCAqIGkpICsgKENoYXIuY29kZSBkIC0gQ2hhci5jb2RlICcwJykgaW5cbiAgICAgIGlmIGknIDwgaSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgaW50ZWdlcicgdCBpJ1xuICAgIHwgXyAtPlxuICAgICAgdW5nZXQgdDtcbiAgICAgIFNvbWUgaSlcbjs7XG5cbmxldCBpbnRlZ2VyIHQgPVxuICBpZiBlb3MgdFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbWF0Y2ggZ2V0IHQgd2l0aFxuICAgIHwgJzAnIC4uICc5JyBhcyBkIC0+IGludGVnZXInIHQgKENoYXIuY29kZSBkIC0gQ2hhci5jb2RlICcwJylcbiAgICB8IF8gLT5cbiAgICAgIHVuZ2V0IHQ7XG4gICAgICBOb25lKVxuOztcbiIsIigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbm1vZHVsZSBSZSA9IENvcmVcblxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5leGNlcHRpb24gTm90X3N1cHBvcnRlZFxuXG5sZXQgcGFyc2UgcyA9XG4gIGxldCBidWYgPSBQYXJzZV9idWZmZXIuY3JlYXRlIHMgaW5cbiAgbGV0IGFjY2VwdCA9IFBhcnNlX2J1ZmZlci5hY2NlcHQgYnVmIGluXG4gIGxldCBhY2NlcHQyID0gUGFyc2VfYnVmZmVyLmFjY2VwdDIgYnVmIGluXG4gIGxldCBlb3MgKCkgPSBQYXJzZV9idWZmZXIuZW9zIGJ1ZiBpblxuICBsZXQgdGVzdDIgPSBQYXJzZV9idWZmZXIudGVzdDIgYnVmIGluXG4gIGxldCBnZXQgKCkgPSBQYXJzZV9idWZmZXIuZ2V0IGJ1ZiBpblxuICBsZXQgcmVjIHJlZ2V4cCAoKSA9IHJlZ2V4cCcgKGJyYW5jaCAoKSlcbiAgYW5kIHJlZ2V4cCcgbGVmdCA9XG4gICAgaWYgYWNjZXB0MiAnXFxcXCcgJ3wnIHRoZW4gcmVnZXhwJyAoUmUuYWx0IFsgbGVmdDsgYnJhbmNoICgpIF0pIGVsc2UgbGVmdFxuICBhbmQgYnJhbmNoICgpID0gYnJhbmNoJyBbXVxuICBhbmQgYnJhbmNoJyBsZWZ0ID1cbiAgICBpZiBlb3MgKCkgfHwgdGVzdDIgJ1xcXFwnICd8JyB8fCB0ZXN0MiAnXFxcXCcgJyknXG4gICAgdGhlbiBSZS5zZXEgKExpc3QucmV2IGxlZnQpXG4gICAgZWxzZSBicmFuY2gnIChwaWVjZSAoKSA6OiBsZWZ0KVxuICBhbmQgcGllY2UgKCkgPVxuICAgIGxldCByID0gYXRvbSAoKSBpblxuICAgIGlmIGFjY2VwdCAnKidcbiAgICB0aGVuIFJlLnJlcCByXG4gICAgZWxzZSBpZiBhY2NlcHQgJysnXG4gICAgdGhlbiBSZS5yZXAxIHJcbiAgICBlbHNlIGlmIGFjY2VwdCAnPydcbiAgICB0aGVuIFJlLm9wdCByXG4gICAgZWxzZSByXG4gIGFuZCBhdG9tICgpID1cbiAgICBpZiBhY2NlcHQgJy4nXG4gICAgdGhlbiBSZS5ub3RubFxuICAgIGVsc2UgaWYgYWNjZXB0ICdeJ1xuICAgIHRoZW4gUmUuYm9sXG4gICAgZWxzZSBpZiBhY2NlcHQgJyQnXG4gICAgdGhlbiBSZS5lb2xcbiAgICBlbHNlIGlmIGFjY2VwdCAnWydcbiAgICB0aGVuIGlmIGFjY2VwdCAnXicgdGhlbiBSZS5jb21wbCAoYnJhY2tldCBbXSkgZWxzZSBSZS5hbHQgKGJyYWNrZXQgW10pXG4gICAgZWxzZSBpZiBhY2NlcHQgJ1xcXFwnXG4gICAgdGhlblxuICAgICAgaWYgYWNjZXB0ICcoJ1xuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICAgIGlmIG5vdCAoYWNjZXB0MiAnXFxcXCcgJyknKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICBSZS5ncm91cCByKVxuICAgICAgZWxzZSBpZiBhY2NlcHQgJ2AnXG4gICAgICB0aGVuIFJlLmJvc1xuICAgICAgZWxzZSBpZiBhY2NlcHQgJ1xcJydcbiAgICAgIHRoZW4gUmUuZW9zXG4gICAgICBlbHNlIGlmIGFjY2VwdCAnPSdcbiAgICAgIHRoZW4gUmUuc3RhcnRcbiAgICAgIGVsc2UgaWYgYWNjZXB0ICdiJ1xuICAgICAgdGhlbiBSZS5hbHQgWyBSZS5ib3c7IFJlLmVvdyBdXG4gICAgICBlbHNlIGlmIGFjY2VwdCAnQidcbiAgICAgIHRoZW4gUmUubm90X2JvdW5kYXJ5XG4gICAgICBlbHNlIGlmIGFjY2VwdCAnPCdcbiAgICAgIHRoZW4gUmUuYm93XG4gICAgICBlbHNlIGlmIGFjY2VwdCAnPidcbiAgICAgIHRoZW4gUmUuZW93XG4gICAgICBlbHNlIGlmIGFjY2VwdCAndydcbiAgICAgIHRoZW4gUmUuYWx0IFsgUmUuYWxudW07IFJlLmNoYXIgJ18nIF1cbiAgICAgIGVsc2UgaWYgYWNjZXB0ICdXJ1xuICAgICAgdGhlbiBSZS5jb21wbCBbIFJlLmFsbnVtOyBSZS5jaGFyICdfJyBdXG4gICAgICBlbHNlIChcbiAgICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICAgIHwgKCcqJyB8ICcrJyB8ICc/JyB8ICdbJyB8ICddJyB8ICcuJyB8ICdeJyB8ICckJyB8ICdcXFxcJykgYXMgYyAtPiBSZS5jaGFyIGNcbiAgICAgICAgfCAnMCcgLi4gJzknIC0+IHJhaXNlIE5vdF9zdXBwb3J0ZWRcbiAgICAgICAgfCBfIC0+IHJhaXNlIFBhcnNlX2Vycm9yKVxuICAgIGVsc2UgKFxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAnKicgfCAnKycgfCAnPycgLT4gcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgIHwgYyAtPiBSZS5jaGFyIGMpXG4gIGFuZCBicmFja2V0IHMgPVxuICAgIGlmIHMgPD4gW10gJiYgYWNjZXB0ICddJ1xuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IGMgPSBjaGFyICgpIGluXG4gICAgICBpZiBhY2NlcHQgJy0nXG4gICAgICB0aGVuXG4gICAgICAgIGlmIGFjY2VwdCAnXSdcbiAgICAgICAgdGhlbiBSZS5jaGFyIGMgOjogUmUuY2hhciAnLScgOjogc1xuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgYycgPSBjaGFyICgpIGluXG4gICAgICAgICAgYnJhY2tldCAoUmUucmcgYyBjJyA6OiBzKSlcbiAgICAgIGVsc2UgYnJhY2tldCAoUmUuY2hhciBjIDo6IHMpKVxuICBhbmQgY2hhciAoKSA9XG4gICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgZ2V0ICgpXG4gIGluXG4gIGxldCByZXMgPSByZWdleHAgKCkgaW5cbiAgaWYgbm90IChlb3MgKCkpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gIHJlc1xuOztcblxubGV0IHJlID8oY2FzZSA9IHRydWUpIHMgPVxuICBsZXQgciA9IHBhcnNlIHMgaW5cbiAgaWYgY2FzZSB0aGVuIHIgZWxzZSBSZS5ub19jYXNlIHJcbjs7XG5cbmxldCBjb21waWxlID0gUmUuY29tcGlsZVxubGV0IGNvbXBpbGVfcGF0ID8oY2FzZSA9IHRydWUpIHMgPSBjb21waWxlIChyZSB+Y2FzZSBzKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqKVxuKCogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqKVxuKCogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAqKVxuKCogIGxpbmtpbmcgZXhjZXB0aW9uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2RpZmllZCBieSBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnIgZm9yIGludGVncmF0aW9uIGluIFJFICopXG5cbigqICRJZDogcmVfc3RyLm1sLHYgMS4zIDIwMDIvMDcvMDMgMTU6NDc6NTQgdm91aWxsb24gRXhwICQgKilcblxubW9kdWxlIFJlID0gQ29yZVxuXG50eXBlIHJlZ2V4cCA9XG4gIHsgcmUgOiBSZS50XG4gIDsgbXRjaCA6IFJlLnJlIExhenkudFxuICA7IHNyY2ggOiBSZS5yZSBMYXp5LnRcbiAgfVxuXG5sZXQgY29tcGlsZV9yZWdleHAgcyBjID1cbiAgbGV0IHJlID0gRW1hY3MucmUgfmNhc2U6KG5vdCBjKSBzIGluXG4gIHsgcmU7IG10Y2ggPSBsYXp5IChSZS5jb21waWxlIChSZS5zZXEgWyBSZS5zdGFydDsgcmUgXSkpOyBzcmNoID0gbGF6eSAoUmUuY29tcGlsZSByZSkgfVxuOztcblxubGV0IHN0YXRlID0gcmVmIE5vbmVcblxubGV0IHN0cmluZ19tYXRjaCByZSBzIHAgPVxuICB0cnlcbiAgICBzdGF0ZSA6PSBTb21lIChSZS5leGVjIH5wb3M6cCAoTGF6eS5mb3JjZSByZS5tdGNoKSBzKTtcbiAgICB0cnVlXG4gIHdpdGhcbiAgfCBOb3RfZm91bmQgLT5cbiAgICBzdGF0ZSA6PSBOb25lO1xuICAgIGZhbHNlXG47O1xuXG5sZXQgc3RyaW5nX3BhcnRpYWxfbWF0Y2ggcmUgcyBwID1cbiAgbWF0Y2ggUmUuZXhlY19wYXJ0aWFsIH5wb3M6cCAoTGF6eS5mb3JjZSByZS5tdGNoKSBzIHdpdGhcbiAgfCBgRnVsbCAtPiBzdHJpbmdfbWF0Y2ggcmUgcyBwXG4gIHwgYFBhcnRpYWwgLT4gdHJ1ZVxuICB8IGBNaXNtYXRjaCAtPiBmYWxzZVxuOztcblxubGV0IHNlYXJjaF9mb3J3YXJkIHJlIHMgcCA9XG4gIHRyeVxuICAgIGxldCByZXMgPSBSZS5leGVjIH5wb3M6cCAoTGF6eS5mb3JjZSByZS5zcmNoKSBzIGluXG4gICAgc3RhdGUgOj0gU29tZSByZXM7XG4gICAgZnN0IChSZS5Hcm91cC5vZmZzZXQgcmVzIDApXG4gIHdpdGhcbiAgfCBOb3RfZm91bmQgLT5cbiAgICBzdGF0ZSA6PSBOb25lO1xuICAgIHJhaXNlIE5vdF9mb3VuZFxuOztcblxubGV0IHJlYyBzZWFyY2hfYmFja3dhcmQgcmUgcyBwID1cbiAgdHJ5XG4gICAgbGV0IHJlcyA9IFJlLmV4ZWMgfnBvczpwIChMYXp5LmZvcmNlIHJlLm10Y2gpIHMgaW5cbiAgICBzdGF0ZSA6PSBTb21lIHJlcztcbiAgICBwXG4gIHdpdGhcbiAgfCBOb3RfZm91bmQgLT5cbiAgICBzdGF0ZSA6PSBOb25lO1xuICAgIGlmIHAgPSAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2Ugc2VhcmNoX2JhY2t3YXJkIHJlIHMgKHAgLSAxKVxuOztcblxubGV0IHZhbGlkX2dyb3VwIG4gPVxuICBuID49IDBcbiAgJiYgbiA8IDEwXG4gICYmXG4gIG1hdGNoICFzdGF0ZSB3aXRoXG4gIHwgTm9uZSAtPiBmYWxzZVxuICB8IFNvbWUgbSAtPiBuIDwgUmUuR3JvdXAubmJfZ3JvdXBzIG1cbjs7XG5cbmxldCBvZmZzZXRfZ3JvdXAgaSA9XG4gIG1hdGNoICFzdGF0ZSB3aXRoXG4gIHwgU29tZSBtIC0+IFJlLkdyb3VwLm9mZnNldCBtIGlcbiAgfCBOb25lIC0+IHJhaXNlIE5vdF9mb3VuZFxuOztcblxubGV0IGdyb3VwX2xlbiBpID1cbiAgdHJ5XG4gICAgbGV0IGIsIGUgPSBvZmZzZXRfZ3JvdXAgaSBpblxuICAgIGUgLSBiXG4gIHdpdGhcbiAgfCBOb3RfZm91bmQgLT4gMFxuOztcblxubGV0IHJlYyByZXBsX2xlbmd0aCByZXBsIHAgcSBsZW4gPVxuICBpZiBwIDwgbGVuXG4gIHRoZW5cbiAgICBpZiByZXBsLltwXSA8PiAnXFxcXCdcbiAgICB0aGVuIHJlcGxfbGVuZ3RoIHJlcGwgKHAgKyAxKSAocSArIDEpIGxlblxuICAgIGVsc2UgKFxuICAgICAgbGV0IHAgPSBwICsgMSBpblxuICAgICAgaWYgcCA9IGxlbiB0aGVuIGZhaWx3aXRoIFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCI7XG4gICAgICBsZXQgcSA9XG4gICAgICAgIG1hdGNoIHJlcGwuW3BdIHdpdGhcbiAgICAgICAgfCAnXFxcXCcgLT4gcSArIDFcbiAgICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gcSArIGdyb3VwX2xlbiAoQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnKVxuICAgICAgICB8IF8gLT4gcSArIDJcbiAgICAgIGluXG4gICAgICByZXBsX2xlbmd0aCByZXBsIChwICsgMSkgcSBsZW4pXG4gIGVsc2UgcVxuOztcblxubGV0IHJlYyByZXBsYWNlIG9yaWcgcmVwbCBwIHJlcyBxIGxlbiA9XG4gIGlmIHAgPCBsZW5cbiAgdGhlbiAoXG4gICAgbGV0IGMgPSByZXBsLltwXSBpblxuICAgIGlmIGMgPD4gJ1xcXFwnXG4gICAgdGhlbiAoXG4gICAgICBCeXRlcy5zZXQgcmVzIHEgYztcbiAgICAgIHJlcGxhY2Ugb3JpZyByZXBsIChwICsgMSkgcmVzIChxICsgMSkgbGVuKVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggcmVwbC5bcCArIDFdIHdpdGhcbiAgICAgIHwgJ1xcXFwnIC0+XG4gICAgICAgIEJ5dGVzLnNldCByZXMgcSAnXFxcXCc7XG4gICAgICAgIHJlcGxhY2Ugb3JpZyByZXBsIChwICsgMikgcmVzIChxICsgMSkgbGVuXG4gICAgICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgICAgICBsZXQgZCA9XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQgYiwgZSA9IG9mZnNldF9ncm91cCAoQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnKSBpblxuICAgICAgICAgICAgbGV0IGQgPSBlIC0gYiBpblxuICAgICAgICAgICAgaWYgZCA+IDAgdGhlbiBTdHJpbmcuYmxpdCBvcmlnIGIgcmVzIHEgZDtcbiAgICAgICAgICAgIGRcbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBOb3RfZm91bmQgLT4gMFxuICAgICAgICBpblxuICAgICAgICByZXBsYWNlIG9yaWcgcmVwbCAocCArIDIpIHJlcyAocSArIGQpIGxlblxuICAgICAgfCBjIC0+XG4gICAgICAgIEJ5dGVzLnNldCByZXMgcSAnXFxcXCc7XG4gICAgICAgIEJ5dGVzLnNldCByZXMgKHEgKyAxKSBjO1xuICAgICAgICByZXBsYWNlIG9yaWcgcmVwbCAocCArIDIpIHJlcyAocSArIDIpIGxlbikpXG47O1xuXG5sZXQgcmVwbGFjZW1lbnRfdGV4dCByZXBsIG9yaWcgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCByZXBsIGluXG4gIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgKHJlcGxfbGVuZ3RoIHJlcGwgMCAwIGxlbikgaW5cbiAgcmVwbGFjZSBvcmlnIHJlcGwgMCByZXMgMCAoU3RyaW5nLmxlbmd0aCByZXBsKTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbjs7XG5cbmxldCBxdW90ZSBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAoMiAqIGxlbikgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgfCAoJ1snIHwgJ10nIHwgJyonIHwgJy4nIHwgJ1xcXFwnIHwgJz8nIHwgJysnIHwgJ14nIHwgJyQnKSBhcyBjIC0+XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXFxcJztcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgY1xuICAgIHwgYyAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmIGNcbiAgZG9uZTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuOztcblxubGV0IHN0cmluZ19iZWZvcmUgcyBuID0gU3RyaW5nLnN1YiBzIDAgblxubGV0IHN0cmluZ19hZnRlciBzIG4gPSBTdHJpbmcuc3ViIHMgbiAoU3RyaW5nLmxlbmd0aCBzIC0gbilcbmxldCBmaXJzdF9jaGFycyBzIG4gPSBTdHJpbmcuc3ViIHMgMCBuXG5sZXQgbGFzdF9jaGFycyBzIG4gPSBTdHJpbmcuc3ViIHMgKFN0cmluZy5sZW5ndGggcyAtIG4pIG5cbmxldCByZWdleHAgZSA9IGNvbXBpbGVfcmVnZXhwIGUgZmFsc2VcbmxldCByZWdleHBfY2FzZV9mb2xkIGUgPSBjb21waWxlX3JlZ2V4cCBlIHRydWVcbmxldCByZWdleHBfc3RyaW5nIHMgPSBjb21waWxlX3JlZ2V4cCAocXVvdGUgcykgZmFsc2VcbmxldCByZWdleHBfc3RyaW5nX2Nhc2VfZm9sZCBzID0gY29tcGlsZV9yZWdleHAgKHF1b3RlIHMpIHRydWVcblxubGV0IGdyb3VwX2JlZ2lubmluZyBuID1cbiAgaWYgbm90ICh2YWxpZF9ncm91cCBuKSB0aGVuIGludmFsaWRfYXJnIFwiU3RyLmdyb3VwX2JlZ2lubmluZ1wiO1xuICBsZXQgcG9zID0gZnN0IChvZmZzZXRfZ3JvdXAgbikgaW5cbiAgaWYgcG9zID0gLTEgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZSBwb3Ncbjs7XG5cbmxldCBncm91cF9lbmQgbiA9XG4gIGlmIG5vdCAodmFsaWRfZ3JvdXAgbikgdGhlbiBpbnZhbGlkX2FyZyBcIlN0ci5ncm91cF9lbmRcIjtcbiAgbGV0IHBvcyA9IHNuZCAob2Zmc2V0X2dyb3VwIG4pIGluXG4gIGlmIHBvcyA9IC0xIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2UgcG9zXG47O1xuXG5sZXQgbWF0Y2hlZF9ncm91cCBuIHR4dCA9XG4gIGxldCBiLCBlID0gb2Zmc2V0X2dyb3VwIG4gaW5cbiAgU3RyaW5nLnN1YiB0eHQgYiAoZSAtIGIpXG47O1xuXG5sZXQgcmVwbGFjZV9tYXRjaGVkIHJlcGwgbWF0Y2hlZCA9IHJlcGxhY2VtZW50X3RleHQgcmVwbCBtYXRjaGVkXG5cbmxldCBtYXRjaF9iZWdpbm5pbmcgKCkgPSBncm91cF9iZWdpbm5pbmcgMFxuYW5kIG1hdGNoX2VuZCAoKSA9IGdyb3VwX2VuZCAwXG5hbmQgbWF0Y2hlZF9zdHJpbmcgdHh0ID0gbWF0Y2hlZF9ncm91cCAwIHR4dFxuXG5sZXQgc3Vic3RpdHV0ZV9maXJzdCBleHByIHJlcGxfZnVuIHRleHQgPVxuICB0cnlcbiAgICBsZXQgcG9zID0gc2VhcmNoX2ZvcndhcmQgZXhwciB0ZXh0IDAgaW5cbiAgICBTdHJpbmcuY29uY2F0XG4gICAgICBcIlwiXG4gICAgICBbIHN0cmluZ19iZWZvcmUgdGV4dCBwb3M7IHJlcGxfZnVuIHRleHQ7IHN0cmluZ19hZnRlciB0ZXh0IChtYXRjaF9lbmQgKCkpIF1cbiAgd2l0aFxuICB8IE5vdF9mb3VuZCAtPiB0ZXh0XG47O1xuXG5sZXQgZ2xvYmFsX3N1YnN0aXR1dGUgZXhwciByZXBsX2Z1biB0ZXh0ID1cbiAgbGV0IHJlYyByZXBsYWNlIGFjY3Ugc3RhcnQgbGFzdF93YXNfZW1wdHkgPVxuICAgIGxldCBzdGFydHBvcyA9IGlmIGxhc3Rfd2FzX2VtcHR5IHRoZW4gc3RhcnQgKyAxIGVsc2Ugc3RhcnQgaW5cbiAgICBpZiBzdGFydHBvcyA+IFN0cmluZy5sZW5ndGggdGV4dFxuICAgIHRoZW4gc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQgOjogYWNjdVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggc2VhcmNoX2ZvcndhcmQgZXhwciB0ZXh0IHN0YXJ0cG9zIHdpdGhcbiAgICAgIHwgcG9zIC0+XG4gICAgICAgIGxldCBlbmRfcG9zID0gbWF0Y2hfZW5kICgpIGluXG4gICAgICAgIGxldCByZXBsX3RleHQgPSByZXBsX2Z1biB0ZXh0IGluXG4gICAgICAgIHJlcGxhY2VcbiAgICAgICAgICAocmVwbF90ZXh0IDo6IFN0cmluZy5zdWIgdGV4dCBzdGFydCAocG9zIC0gc3RhcnQpIDo6IGFjY3UpXG4gICAgICAgICAgZW5kX3Bvc1xuICAgICAgICAgIChlbmRfcG9zID0gcG9zKVxuICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IHN0cmluZ19hZnRlciB0ZXh0IHN0YXJ0IDo6IGFjY3UpXG4gIGluXG4gIFN0cmluZy5jb25jYXQgXCJcIiAoTGlzdC5yZXYgKHJlcGxhY2UgW10gMCBmYWxzZSkpXG47O1xuXG5sZXQgZ2xvYmFsX3JlcGxhY2UgZXhwciByZXBsIHRleHQgPSBnbG9iYWxfc3Vic3RpdHV0ZSBleHByIChyZXBsYWNlbWVudF90ZXh0IHJlcGwpIHRleHRcbmFuZCByZXBsYWNlX2ZpcnN0IGV4cHIgcmVwbCB0ZXh0ID0gc3Vic3RpdHV0ZV9maXJzdCBleHByIChyZXBsYWNlbWVudF90ZXh0IHJlcGwpIHRleHRcblxubGV0IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIHJlIHMgcCA9XG4gIGxldCBwb3MgPSBzZWFyY2hfZm9yd2FyZCByZSBzIHAgaW5cbiAgaWYgbWF0Y2hfZW5kICgpID4gcFxuICB0aGVuIHBvc1xuICBlbHNlIGlmIHAgPCBTdHJpbmcubGVuZ3RoIHNcbiAgdGhlbiBzZWFyY2hfZm9yd2FyZCByZSBzIChwICsgMSlcbiAgZWxzZSByYWlzZSBOb3RfZm91bmRcbjs7XG5cbmxldCBib3VuZGVkX3NwbGl0IGV4cHIgdGV4dCBudW0gPVxuICBsZXQgc3RhcnQgPSBpZiBzdHJpbmdfbWF0Y2ggZXhwciB0ZXh0IDAgdGhlbiBtYXRjaF9lbmQgKCkgZWxzZSAwIGluXG4gIGxldCByZWMgc3BsaXQgYWNjdSBzdGFydCBuID1cbiAgICBpZiBzdGFydCA+PSBTdHJpbmcubGVuZ3RoIHRleHRcbiAgICB0aGVuIGFjY3VcbiAgICBlbHNlIGlmIG4gPSAxXG4gICAgdGhlbiBzdHJpbmdfYWZ0ZXIgdGV4dCBzdGFydCA6OiBhY2N1XG4gICAgZWxzZSAoXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHBvcyA9IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIGV4cHIgdGV4dCBzdGFydCBpblxuICAgICAgICBzcGxpdCAoU3RyaW5nLnN1YiB0ZXh0IHN0YXJ0IChwb3MgLSBzdGFydCkgOjogYWNjdSkgKG1hdGNoX2VuZCAoKSkgKG4gLSAxKVxuICAgICAgd2l0aFxuICAgICAgfCBOb3RfZm91bmQgLT4gc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQgOjogYWNjdSlcbiAgaW5cbiAgTGlzdC5yZXYgKHNwbGl0IFtdIHN0YXJ0IG51bSlcbjs7XG5cbmxldCBzcGxpdCBleHByIHRleHQgPSBib3VuZGVkX3NwbGl0IGV4cHIgdGV4dCAwXG5cbmxldCBib3VuZGVkX3NwbGl0X2RlbGltIGV4cHIgdGV4dCBudW0gPVxuICBsZXQgcmVjIHNwbGl0IGFjY3Ugc3RhcnQgbiA9XG4gICAgaWYgc3RhcnQgPiBTdHJpbmcubGVuZ3RoIHRleHRcbiAgICB0aGVuIGFjY3VcbiAgICBlbHNlIGlmIG4gPSAxXG4gICAgdGhlbiBzdHJpbmdfYWZ0ZXIgdGV4dCBzdGFydCA6OiBhY2N1XG4gICAgZWxzZSAoXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHBvcyA9IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIGV4cHIgdGV4dCBzdGFydCBpblxuICAgICAgICBzcGxpdCAoU3RyaW5nLnN1YiB0ZXh0IHN0YXJ0IChwb3MgLSBzdGFydCkgOjogYWNjdSkgKG1hdGNoX2VuZCAoKSkgKG4gLSAxKVxuICAgICAgd2l0aFxuICAgICAgfCBOb3RfZm91bmQgLT4gc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQgOjogYWNjdSlcbiAgaW5cbiAgaWYgdGV4dCA9IFwiXCIgdGhlbiBbXSBlbHNlIExpc3QucmV2IChzcGxpdCBbXSAwIG51bSlcbjs7XG5cbmxldCBzcGxpdF9kZWxpbSBleHByIHRleHQgPSBib3VuZGVkX3NwbGl0X2RlbGltIGV4cHIgdGV4dCAwXG5cbnR5cGUgc3BsaXRfcmVzdWx0ID1cbiAgfCBUZXh0IG9mIHN0cmluZ1xuICB8IERlbGltIG9mIHN0cmluZ1xuXG5sZXQgYm91bmRlZF9mdWxsX3NwbGl0IGV4cHIgdGV4dCBudW0gPVxuICBsZXQgcmVjIHNwbGl0IGFjY3Ugc3RhcnQgbiA9XG4gICAgaWYgc3RhcnQgPj0gU3RyaW5nLmxlbmd0aCB0ZXh0XG4gICAgdGhlbiBhY2N1XG4gICAgZWxzZSBpZiBuID0gMVxuICAgIHRoZW4gVGV4dCAoc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQpIDo6IGFjY3VcbiAgICBlbHNlIChcbiAgICAgIHRyeVxuICAgICAgICBsZXQgcG9zID0gc2VhcmNoX2ZvcndhcmRfcHJvZ3Jlc3MgZXhwciB0ZXh0IHN0YXJ0IGluXG4gICAgICAgIGxldCBzID0gbWF0Y2hlZF9zdHJpbmcgdGV4dCBpblxuICAgICAgICBpZiBwb3MgPiBzdGFydFxuICAgICAgICB0aGVuXG4gICAgICAgICAgc3BsaXRcbiAgICAgICAgICAgIChEZWxpbSBzIDo6IFRleHQgKFN0cmluZy5zdWIgdGV4dCBzdGFydCAocG9zIC0gc3RhcnQpKSA6OiBhY2N1KVxuICAgICAgICAgICAgKG1hdGNoX2VuZCAoKSlcbiAgICAgICAgICAgIChuIC0gMSlcbiAgICAgICAgZWxzZSBzcGxpdCAoRGVsaW0gcyA6OiBhY2N1KSAobWF0Y2hfZW5kICgpKSAobiAtIDEpXG4gICAgICB3aXRoXG4gICAgICB8IE5vdF9mb3VuZCAtPiBUZXh0IChzdHJpbmdfYWZ0ZXIgdGV4dCBzdGFydCkgOjogYWNjdSlcbiAgaW5cbiAgTGlzdC5yZXYgKHNwbGl0IFtdIDAgbnVtKVxuOztcblxubGV0IGZ1bGxfc3BsaXQgZXhwciB0ZXh0ID0gYm91bmRlZF9mdWxsX3NwbGl0IGV4cHIgdGV4dCAwXG4iLCJsZXQgcmVwbGFjZSA/KHBvcyA9IDApID9sZW4gPyhhbGwgPSB0cnVlKSByZSB+ZiBzID1cbiAgaWYgcG9zIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiUmUucmVwbGFjZVwiO1xuICBsZXQgbGltaXQgPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lIC0+IFN0cmluZy5sZW5ndGggc1xuICAgIHwgU29tZSBsIC0+XG4gICAgICBpZiBsIDwgMCB8fCBwb3MgKyBsID4gU3RyaW5nLmxlbmd0aCBzIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5yZXBsYWNlXCI7XG4gICAgICBwb3MgKyBsXG4gIGluXG4gICgqIGJ1ZmZlciBpbnRvIHdoaWNoIHdlIHdyaXRlIHRoZSByZXN1bHQgKilcbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgKFN0cmluZy5sZW5ndGggcykgaW5cbiAgKCogaXRlcmF0ZSBvbiBtYXRjaGVkIHN1YnN0cmluZ3MuICopXG4gIGxldCByZWMgaXRlciBwb3Mgb25fbWF0Y2ggPVxuICAgIGlmIHBvcyA8PSBsaW1pdFxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2hcbiAgICAgICAgQ29tcGlsZS5tYXRjaF9zdHIgfmdyb3Vwczp0cnVlIH5wYXJ0aWFsOmZhbHNlIHJlIHMgfnBvcyB+bGVuOihsaW1pdCAtIHBvcylcbiAgICAgIHdpdGhcbiAgICAgIHwgTWF0Y2ggc3Vic3RyIC0+XG4gICAgICAgIGxldCBwMSwgcDIgPSBHcm91cC5vZmZzZXQgc3Vic3RyIDAgaW5cbiAgICAgICAgaWYgcG9zID0gcDEgJiYgcDEgPSBwMiAmJiBvbl9tYXRjaFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBpZiB3ZSBtYXRjaGVkIGFuIGVtcHR5IHN0cmluZyByaWdodCBhZnRlciBhIG1hdGNoLFxuICAgICAgICAgICAgIHdlIG11c3QgbWFudWFsbHkgYWR2YW5jZSBieSAxICopXG4gICAgICAgICAgaWYgcDIgPCBsaW1pdCB0aGVuIEJ1ZmZlci5hZGRfY2hhciBidWYgcy5bcDJdO1xuICAgICAgICAgIGl0ZXIgKHAyICsgMSkgZmFsc2UpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIGFkZCBzdHJpbmcgYmV0d2VlbiBwcmV2aW91cyBtYXRjaCBhbmQgY3VycmVudCBtYXRjaCAqKVxuICAgICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzIHBvcyAocDEgLSBwb3MpO1xuICAgICAgICAgICgqIHdoYXQgc2hvdWxkIHdlIHJlcGxhY2UgdGhlIG1hdGNoZWQgZ3JvdXAgd2l0aD8gKilcbiAgICAgICAgICBsZXQgcmVwbGFjaW5nID0gZiBzdWJzdHIgaW5cbiAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgcmVwbGFjaW5nO1xuICAgICAgICAgIGlmIGFsbFxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICgqIGlmIHdlIG1hdGNoZWQgYW4gZW1wdHkgc3RyaW5nLCB3ZSBtdXN0IG1hbnVhbGx5IGFkdmFuY2UgYnkgMSAqKVxuICAgICAgICAgICAgaXRlclxuICAgICAgICAgICAgICAoaWYgcDEgPSBwMlxuICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICgqIGEgbm9uIGNoYXIgY291bGQgYmUgcGFzdCB0aGUgZW5kIG9mIHN0cmluZy4gZS5nLiAkICopXG4gICAgICAgICAgICAgICAgIGlmIHAyIDwgbGltaXQgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmIHMuW3AyXTtcbiAgICAgICAgICAgICAgICAgcDIgKyAxKVxuICAgICAgICAgICAgICAgZWxzZSBwMilcbiAgICAgICAgICAgICAgKHAxIDw+IHAyKVxuICAgICAgICAgIGVsc2UgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIHMgcDIgKGxpbWl0IC0gcDIpKVxuICAgICAgfCBSdW5uaW5nIF8gLT4gKClcbiAgICAgIHwgRmFpbGVkIC0+IEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzIHBvcyAobGltaXQgLSBwb3MpKVxuICBpblxuICBpdGVyIHBvcyBmYWxzZTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuOztcblxubGV0IHJlcGxhY2Vfc3RyaW5nID9wb3MgP2xlbiA/YWxsIHJlIH5ieSBzID0gcmVwbGFjZSA/cG9zID9sZW4gP2FsbCByZSBzIH5mOihmdW4gXyAtPiBieSlcbiIsIigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbm1vZHVsZSBSZSA9IENvcmVcblxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5cbnR5cGUgZW5jbG9zZWQgPVxuICB8IENoYXIgb2YgY2hhclxuICB8IFJhbmdlIG9mIGNoYXIgKiBjaGFyXG5cbnR5cGUgcGllY2UgPVxuICB8IEV4YWN0bHkgb2YgY2hhclxuICB8IEFueV9vZiBvZiBlbmNsb3NlZCBsaXN0XG4gIHwgQW55X2J1dCBvZiBlbmNsb3NlZCBsaXN0XG4gIHwgT25lXG4gIHwgTWFueVxuICB8IE1hbnlNYW55XG5cbnR5cGUgdCA9IHBpZWNlIGxpc3RcblxubGV0IG9mX3N0cmluZyB+ZG91YmxlX2FzdGVyaXNrIHMgOiB0ID1cbiAgbGV0IGJ1ZiA9IFBhcnNlX2J1ZmZlci5jcmVhdGUgcyBpblxuICBsZXQgZW9zICgpID0gUGFyc2VfYnVmZmVyLmVvcyBidWYgaW5cbiAgbGV0IHJlYWQgYyA9IFBhcnNlX2J1ZmZlci5hY2NlcHQgYnVmIGMgaW5cbiAgbGV0IGNoYXIgKCkgPVxuICAgIGlnbm9yZSAocmVhZCAnXFxcXCcgOiBib29sKTtcbiAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICBQYXJzZV9idWZmZXIuZ2V0IGJ1ZlxuICBpblxuICBsZXQgZW5jbG9zZWQgKCkgOiBlbmNsb3NlZCBsaXN0ID1cbiAgICBsZXQgcmVjIGxvb3AgcyA9XG4gICAgICAoKiBUaGlzIHJldHVybnMgdGhlIGxpc3QgaW4gcmV2ZXJzZSBvcmRlciwgYnV0IG9yZGVyIGlzbid0IGltcG9ydGFudFxuICAgICAgICAgYW55d2F5ICopXG4gICAgICBpZiBzIDw+IFtdICYmIHJlYWQgJ10nXG4gICAgICB0aGVuIHNcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgYyA9IGNoYXIgKCkgaW5cbiAgICAgICAgaWYgbm90IChyZWFkICctJylcbiAgICAgICAgdGhlbiBsb29wIChDaGFyIGMgOjogcylcbiAgICAgICAgZWxzZSBpZiByZWFkICddJ1xuICAgICAgICB0aGVuIENoYXIgYyA6OiBDaGFyICctJyA6OiBzXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBjJyA9IGNoYXIgKCkgaW5cbiAgICAgICAgICBsb29wIChSYW5nZSAoYywgYycpIDo6IHMpKSlcbiAgICBpblxuICAgIGxvb3AgW11cbiAgaW5cbiAgbGV0IHBpZWNlIGFjYyA9XG4gICAgaWYgZG91YmxlX2FzdGVyaXNrICYmIFBhcnNlX2J1ZmZlci5hY2NlcHRfcyBidWYgXCIvKipcIlxuICAgIHRoZW4gTWFueU1hbnkgOjogKGlmIGVvcyAoKSB0aGVuIEV4YWN0bHkgJy8nIDo6IGFjYyBlbHNlIGFjYylcbiAgICBlbHNlIGlmIHJlYWQgJyonXG4gICAgdGhlbiAoaWYgZG91YmxlX2FzdGVyaXNrICYmIHJlYWQgJyonIHRoZW4gTWFueU1hbnkgZWxzZSBNYW55KSA6OiBhY2NcbiAgICBlbHNlIGlmIHJlYWQgJz8nXG4gICAgdGhlbiBPbmUgOjogYWNjXG4gICAgZWxzZSBpZiBub3QgKHJlYWQgJ1snKVxuICAgIHRoZW4gRXhhY3RseSAoY2hhciAoKSkgOjogYWNjXG4gICAgZWxzZSBpZiByZWFkICdeJyB8fCByZWFkICchJ1xuICAgIHRoZW4gQW55X2J1dCAoZW5jbG9zZWQgKCkpIDo6IGFjY1xuICAgIGVsc2UgQW55X29mIChlbmNsb3NlZCAoKSkgOjogYWNjXG4gIGluXG4gIGxldCByZWMgbG9vcCBwaWVjZXMgPSBpZiBlb3MgKCkgdGhlbiBMaXN0LnJldiBwaWVjZXMgZWxzZSBsb29wIChwaWVjZSBwaWVjZXMpIGluXG4gIGxvb3AgW11cbjs7XG5cbmxldCBtdWwgbCBsJyA9IExpc3QuZmxhdHRlbiAoTGlzdC5tYXAgKGZ1biBzIC0+IExpc3QubWFwIChmdW4gcycgLT4gcyBeIHMnKSBsJykgbClcblxubGV0IGV4cGxvZGUgc3RyID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVjIGV4cGwgaW5uZXIgcyBpIGFjYyBiZWcgPVxuICAgIGlmIGkgPj0gbFxuICAgIHRoZW4gKFxuICAgICAgaWYgaW5uZXIgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIG11bCBiZWcgWyBTdHJpbmcuc3ViIHN0ciBzIChpIC0gcykgXSwgaSlcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgfCAnXFxcXCcgLT4gZXhwbCBpbm5lciBzIChpICsgMikgYWNjIGJlZ1xuICAgICAgfCAneycgLT5cbiAgICAgICAgbGV0IHQsIGknID0gZXhwbCB0cnVlIChpICsgMSkgKGkgKyAxKSBbXSBbIFwiXCIgXSBpblxuICAgICAgICBleHBsIGlubmVyIGknIGknIGFjYyAobXVsIGJlZyAobXVsIFsgU3RyaW5nLnN1YiBzdHIgcyAoaSAtIHMpIF0gdCkpXG4gICAgICB8ICcsJyB3aGVuIGlubmVyIC0+XG4gICAgICAgIGV4cGwgaW5uZXIgKGkgKyAxKSAoaSArIDEpIChtdWwgYmVnIFsgU3RyaW5nLnN1YiBzdHIgcyAoaSAtIHMpIF0gQCBhY2MpIFsgXCJcIiBdXG4gICAgICB8ICd9JyB3aGVuIGlubmVyIC0+IG11bCBiZWcgWyBTdHJpbmcuc3ViIHN0ciBzIChpIC0gcykgXSBAIGFjYywgaSArIDFcbiAgICAgIHwgXyAtPiBleHBsIGlubmVyIHMgKGkgKyAxKSBhY2MgYmVnKVxuICBpblxuICBMaXN0LnJldiAoZnN0IChleHBsIGZhbHNlIDAgMCBbXSBbIFwiXCIgXSkpXG47O1xuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHJlX3BpZWNlcyA6IFJlLnQgbGlzdCAoKiBsYXN0IHBpZWNlIGF0IGhlYWQgb2YgbGlzdC4gKilcbiAgICA7IHJlbWFpbmluZyA6IHBpZWNlIGxpc3QgKCogbGFzdCBwaWVjZSBhdCB0YWlsIG9mIGxpc3QuICopXG4gICAgOyBhbV9hdF9zdGFydF9vZl9wYXR0ZXJuIDogYm9vbCAoKiB0cnVlIGF0IHN0YXJ0IG9mIHBhdHRlcm4gKilcbiAgICA7IGFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudCA6IGJvb2xcbiAgICAgICAgKCogdHJ1ZSBhdCBzdGFydCBvZiBwYXR0ZXJuIG9yIGltbWVkaWF0ZWx5XG4gICAgICAgICAgIGFmdGVyICcvJyAqKVxuICAgIDsgcGF0aG5hbWUgOiBib29sXG4gICAgOyBtYXRjaF9iYWNrc2xhc2hlcyA6IGJvb2xcbiAgICA7IHBlcmlvZCA6IGJvb2xcbiAgICB9XG5cbiAgbGV0IGNyZWF0ZSB+cGVyaW9kIH5wYXRobmFtZSB+bWF0Y2hfYmFja3NsYXNoZXMgcmVtYWluaW5nID1cbiAgICB7IHJlX3BpZWNlcyA9IFtdXG4gICAgOyBhbV9hdF9zdGFydF9vZl9wYXR0ZXJuID0gdHJ1ZVxuICAgIDsgYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50ID0gdHJ1ZVxuICAgIDsgcGF0aG5hbWVcbiAgICA7IG1hdGNoX2JhY2tzbGFzaGVzXG4gICAgOyBwZXJpb2RcbiAgICA7IHJlbWFpbmluZ1xuICAgIH1cbiAgOztcblxuICBsZXQgZXhwbGljaXRfcGVyaW9kIHQgPVxuICAgIHQucGVyaW9kICYmICh0LmFtX2F0X3N0YXJ0X29mX3BhdHRlcm4gfHwgKHQuYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50ICYmIHQucGF0aG5hbWUpKVxuICA7O1xuXG4gIGxldCBleHBsaWNpdF9zbGFzaCB0ID0gdC5wYXRobmFtZVxuICBsZXQgc2xhc2hlcyB0ID0gaWYgdC5tYXRjaF9iYWNrc2xhc2hlcyB0aGVuIFsgJy8nOyAnXFxcXCcgXSBlbHNlIFsgJy8nIF1cblxuICBsZXQgYXBwZW5kID8oYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50ID0gZmFsc2UpIHQgcGllY2UgPVxuICAgIHsgdCB3aXRoXG4gICAgICByZV9waWVjZXMgPSBwaWVjZSA6OiB0LnJlX3BpZWNlc1xuICAgIDsgYW1fYXRfc3RhcnRfb2ZfcGF0dGVybiA9IGZhbHNlXG4gICAgOyBhbV9hdF9zdGFydF9vZl9jb21wb25lbnRcbiAgICB9XG4gIDs7XG5cbiAgbGV0IHRvX3JlIHQgPSBSZS5zZXEgKExpc3QucmV2IHQucmVfcGllY2VzKVxuXG4gIGxldCBuZXh0IHQgPVxuICAgIG1hdGNoIHQucmVtYWluaW5nIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHBpZWNlIDo6IHJlbWFpbmluZyAtPiBTb21lIChwaWVjZSwgeyB0IHdpdGggcmVtYWluaW5nIH0pXG4gIDs7XG5lbmRcblxubGV0IG9uZSB+ZXhwbGljaXRfc2xhc2ggfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZCA9XG4gIFJlLmNvbXBsXG4gICAgKExpc3QuY29uY2F0XG4gICAgICAgWyAoaWYgZXhwbGljaXRfc2xhc2ggdGhlbiBMaXN0Lm1hcCBSZS5jaGFyIHNsYXNoZXMgZWxzZSBbXSlcbiAgICAgICA7IChpZiBleHBsaWNpdF9wZXJpb2QgdGhlbiBbIFJlLmNoYXIgJy4nIF0gZWxzZSBbXSlcbiAgICAgICBdKVxuOztcblxubGV0IGVuY2xvc2VkIGVuY2xvc2VkID1cbiAgbWF0Y2ggZW5jbG9zZWQgd2l0aFxuICB8IENoYXIgYyAtPiBSZS5jaGFyIGNcbiAgfCBSYW5nZSAobG93LCBoaWdoKSAtPiBSZS5yZyBsb3cgaGlnaFxuOztcblxubGV0IGVuY2xvc2VkX3NldCB+ZXhwbGljaXRfc2xhc2ggfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZCBraW5kIHNldCA9XG4gIGxldCBzZXQgPSBMaXN0Lm1hcCBlbmNsb3NlZCBzZXQgaW5cbiAgbGV0IGVuY2xvc3VyZSA9XG4gICAgbWF0Y2gga2luZCB3aXRoXG4gICAgfCBgQW55X29mIC0+IFJlLmFsdCBzZXRcbiAgICB8IGBBbnlfYnV0IC0+IFJlLmNvbXBsIHNldFxuICBpblxuICBSZS5pbnRlciBbIGVuY2xvc3VyZTsgb25lIH5leHBsaWNpdF9zbGFzaCB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kIF1cbjs7XG5cbmxldCBleGFjdGx5IHN0YXRlIGMgPVxuICBsZXQgc2xhc2hlcyA9IFN0YXRlLnNsYXNoZXMgc3RhdGUgaW5cbiAgbGV0IGFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudCA9IExpc3QubWVtIGMgc2xhc2hlcyBpblxuICBsZXQgY2hhcnMgPSBpZiBhbV9hdF9zdGFydF9vZl9jb21wb25lbnQgdGhlbiBzbGFzaGVzIGVsc2UgWyBjIF0gaW5cbiAgU3RhdGUuYXBwZW5kIHN0YXRlIChSZS5hbHQgKExpc3QubWFwIFJlLmNoYXIgY2hhcnMpKSB+YW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50XG47O1xuXG5sZXQgbWFueV9tYW55IHN0YXRlID1cbiAgbGV0IGV4cGxpY2l0X3BlcmlvZCA9IHN0YXRlLlN0YXRlLnBlcmlvZCAmJiBzdGF0ZS5TdGF0ZS5wYXRobmFtZSBpblxuICBsZXQgZmlyc3RfZXhwbGljaXRfcGVyaW9kID0gU3RhdGUuZXhwbGljaXRfcGVyaW9kIHN0YXRlIGluXG4gIGxldCBzbGFzaGVzID0gU3RhdGUuc2xhc2hlcyBzdGF0ZSBpblxuICBsZXQgbWF0Y2hfY29tcG9uZW50IH5leHBsaWNpdF9wZXJpb2QgPVxuICAgIFJlLnNlcVxuICAgICAgWyBvbmUgfmV4cGxpY2l0X3NsYXNoOnRydWUgfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZFxuICAgICAgOyBSZS5yZXAgKG9uZSB+ZXhwbGljaXRfc2xhc2g6dHJ1ZSB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kOmZhbHNlKVxuICAgICAgXVxuICBpblxuICAoKiBXZSBtdXN0IG1hdGNoIGNvbXBvbmVudHMgaW5kaXZpZHVhbGx5IHdoZW4gW3BlcmlvZF0gZmxhZyBpcyBzZXQsXG4gICAgIG1ha2luZyBzdXJlIHRvIG5vdCBtYXRjaCBbXCJmb28vLmJhclwiXS4gKilcbiAgU3RhdGUuYXBwZW5kXG4gICAgc3RhdGVcbiAgICAoUmUuc2VxXG4gICAgICAgWyBSZS5vcHQgKG1hdGNoX2NvbXBvbmVudCB+ZXhwbGljaXRfcGVyaW9kOmZpcnN0X2V4cGxpY2l0X3BlcmlvZClcbiAgICAgICA7IFJlLnJlcFxuICAgICAgICAgICAoUmUuc2VxXG4gICAgICAgICAgICAgIFsgUmUuYWx0IChMaXN0Lm1hcCBSZS5jaGFyIHNsYXNoZXMpXG4gICAgICAgICAgICAgIDsgUmUub3B0IChtYXRjaF9jb21wb25lbnQgfmV4cGxpY2l0X3BlcmlvZClcbiAgICAgICAgICAgICAgXSlcbiAgICAgICBdKVxuOztcblxubGV0IG1hbnkgKHN0YXRlIDogU3RhdGUudCkgPVxuICBsZXQgZXhwbGljaXRfc2xhc2ggPSBTdGF0ZS5leHBsaWNpdF9zbGFzaCBzdGF0ZSBpblxuICBsZXQgZXhwbGljaXRfcGVyaW9kID0gU3RhdGUuZXhwbGljaXRfcGVyaW9kIHN0YXRlIGluXG4gIGxldCBzbGFzaGVzID0gU3RhdGUuc2xhc2hlcyBzdGF0ZSBpblxuICAoKiBXaGV0aGVyIHdlIG11c3QgZXhwbGljaXRseSBtYXRjaCBwZXJpb2QgZGVwZW5kcyBvbiB0aGUgc3Vycm91bmRpbmdcbiAgICAgY2hhcmFjdGVycywgYnV0IHNsYXNoZXMgYXJlIGVhc3kgdG8gZXhwbGljaXQgbWF0Y2guIFRoaXMgY29uZGl0aW9uYWxcbiAgICAgc3BsaXRzIG91dCBzb21lIHNpbXBsZSBjYXNlcy4gKilcbiAgaWYgbm90IGV4cGxpY2l0X3BlcmlvZFxuICB0aGVuIFN0YXRlLmFwcGVuZCBzdGF0ZSAoUmUucmVwIChvbmUgfmV4cGxpY2l0X3NsYXNoIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2QpKVxuICBlbHNlIGlmIG5vdCBleHBsaWNpdF9zbGFzaFxuICB0aGVuXG4gICAgKCogSW4gdGhpcyBzdGF0ZSwgd2UgZXhwbGljaXRseSBtYXRjaCBwZXJpb2RzIG9ubHkgYXQgdGhlIHZlcnkgYmVnaW5uaW5nICopXG4gICAgU3RhdGUuYXBwZW5kXG4gICAgICBzdGF0ZVxuICAgICAgKFJlLm9wdFxuICAgICAgICAgKFJlLnNlcVxuICAgICAgICAgICAgWyBvbmUgfmV4cGxpY2l0X3NsYXNoOmZhbHNlIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2RcbiAgICAgICAgICAgIDsgUmUucmVwIChvbmUgfmV4cGxpY2l0X3NsYXNoOmZhbHNlIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2Q6ZmFsc2UpXG4gICAgICAgICAgICBdKSlcbiAgZWxzZSAoXG4gICAgbGV0IG5vdF9lbXB0eSA9XG4gICAgICBSZS5zZXFcbiAgICAgICAgWyBvbmUgfmV4cGxpY2l0X3NsYXNoOnRydWUgfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZDp0cnVlXG4gICAgICAgIDsgUmUucmVwIChvbmUgfmV4cGxpY2l0X3NsYXNoOnRydWUgfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZDpmYWxzZSlcbiAgICAgICAgXVxuICAgIGluXG4gICAgKCogW21heWJlX2VtcHR5XSBpcyB0aGUgZGVmYXVsdCB0cmFuc2xhdGlvbiBvZiBNYW55LCBleGNlcHQgaW4gc29tZSBzcGVjaWFsXG4gICAgICAgY2FzZXMuICopXG4gICAgbGV0IG1heWJlX2VtcHR5ID0gUmUub3B0IG5vdF9lbXB0eSBpblxuICAgIGxldCBlbmNsb3NlZF9zZXQgc3RhdGUga2luZCBzZXQgPVxuICAgICAgU3RhdGUuYXBwZW5kXG4gICAgICAgIHN0YXRlXG4gICAgICAgIChSZS5hbHRcbiAgICAgICAgICAgWyBlbmNsb3NlZF9zZXQga2luZCBzZXQgfmV4cGxpY2l0X3NsYXNoOnRydWUgfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZDp0cnVlXG4gICAgICAgICAgIDsgUmUuc2VxXG4gICAgICAgICAgICAgICBbIG5vdF9lbXB0eVxuICAgICAgICAgICAgICAgOyAoKiBTaW5jZSBbbm90X2VtcHR5XSBtYXRjaGVkLCBzdWJzZXF1ZW50IGRvdHMgYXJlIG5vdCBsZWFkaW5nLiAqKVxuICAgICAgICAgICAgICAgICBlbmNsb3NlZF9zZXRcbiAgICAgICAgICAgICAgICAgICBraW5kXG4gICAgICAgICAgICAgICAgICAgc2V0XG4gICAgICAgICAgICAgICAgICAgfmV4cGxpY2l0X3NsYXNoOnRydWVcbiAgICAgICAgICAgICAgICAgICB+c2xhc2hlc1xuICAgICAgICAgICAgICAgICAgIH5leHBsaWNpdF9wZXJpb2Q6ZmFsc2VcbiAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgXSlcbiAgICBpblxuICAgIGxldCByZWMgbG9va2FoZWFkIHN0YXRlID1cbiAgICAgIG1hdGNoIFN0YXRlLm5leHQgc3RhdGUgd2l0aFxuICAgICAgfCBOb25lIC0+IFN0YXRlLmFwcGVuZCBzdGF0ZSBtYXliZV9lbXB0eVxuICAgICAgKCogZ2xvYiAqKiA9PT0gZ2xvYiAqIC4gKilcbiAgICAgIHwgU29tZSAoTWFueSwgc3RhdGUpIC0+IGxvb2thaGVhZCBzdGF0ZVxuICAgICAgfCBTb21lIChFeGFjdGx5IGMsIHN0YXRlKSAtPlxuICAgICAgICBsZXQgc3RhdGUgPSBTdGF0ZS5hcHBlbmQgc3RhdGUgKGlmIGMgPSAnLicgdGhlbiBub3RfZW1wdHkgZWxzZSBtYXliZV9lbXB0eSkgaW5cbiAgICAgICAgZXhhY3RseSBzdGF0ZSBjXG4gICAgICAoKiBnbG9iICo/ID09PSBnbG9iID8qICopXG4gICAgICB8IFNvbWUgKE9uZSwgc3RhdGUpIC0+IFN0YXRlLmFwcGVuZCBzdGF0ZSBub3RfZW1wdHlcbiAgICAgIHwgU29tZSAoQW55X29mIGVuY2xvc2VkLCBzdGF0ZSkgLT4gZW5jbG9zZWRfc2V0IHN0YXRlIGBBbnlfb2YgZW5jbG9zZWRcbiAgICAgIHwgU29tZSAoQW55X2J1dCBlbmNsb3NlZCwgc3RhdGUpIC0+IGVuY2xvc2VkX3NldCBzdGF0ZSBgQW55X2J1dCBlbmNsb3NlZFxuICAgICAgKCogKiB0aGVuICoqID09PSAqKiAqKVxuICAgICAgfCBTb21lIChNYW55TWFueSwgc3RhdGUpIC0+IG1hbnlfbWFueSBzdGF0ZVxuICAgIGluXG4gICAgbG9va2FoZWFkIHN0YXRlKVxuOztcblxubGV0IHBpZWNlIHN0YXRlIHBpZWNlID1cbiAgbGV0IGV4cGxpY2l0X3NsYXNoID0gU3RhdGUuZXhwbGljaXRfc2xhc2ggc3RhdGUgaW5cbiAgbGV0IGV4cGxpY2l0X3BlcmlvZCA9IFN0YXRlLmV4cGxpY2l0X3BlcmlvZCBzdGF0ZSBpblxuICBsZXQgc2xhc2hlcyA9IFN0YXRlLnNsYXNoZXMgc3RhdGUgaW5cbiAgbWF0Y2ggcGllY2Ugd2l0aFxuICB8IE9uZSAtPiBTdGF0ZS5hcHBlbmQgc3RhdGUgKG9uZSB+ZXhwbGljaXRfc2xhc2ggfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZClcbiAgfCBNYW55IC0+IG1hbnkgc3RhdGVcbiAgfCBBbnlfb2YgZW5jbG9zZWQgLT5cbiAgICBTdGF0ZS5hcHBlbmRcbiAgICAgIHN0YXRlXG4gICAgICAoZW5jbG9zZWRfc2V0IGBBbnlfb2YgfmV4cGxpY2l0X3NsYXNoIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2QgZW5jbG9zZWQpXG4gIHwgQW55X2J1dCBlbmNsb3NlZCAtPlxuICAgIFN0YXRlLmFwcGVuZFxuICAgICAgc3RhdGVcbiAgICAgIChlbmNsb3NlZF9zZXQgYEFueV9idXQgfmV4cGxpY2l0X3NsYXNoIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2QgZW5jbG9zZWQpXG4gIHwgRXhhY3RseSBjIC0+IGV4YWN0bHkgc3RhdGUgY1xuICB8IE1hbnlNYW55IC0+IG1hbnlfbWFueSBzdGF0ZVxuOztcblxubGV0IGdsb2IgfnBhdGhuYW1lIH5tYXRjaF9iYWNrc2xhc2hlcyB+cGVyaW9kIGdsb2IgPVxuICBsZXQgcmVjIGxvb3Agc3RhdGUgPVxuICAgIG1hdGNoIFN0YXRlLm5leHQgc3RhdGUgd2l0aFxuICAgIHwgTm9uZSAtPiBTdGF0ZS50b19yZSBzdGF0ZVxuICAgIHwgU29tZSAocCwgc3RhdGUpIC0+IGxvb3AgKHBpZWNlIHN0YXRlIHApXG4gIGluXG4gIGxvb3AgKFN0YXRlLmNyZWF0ZSB+cGF0aG5hbWUgfm1hdGNoX2JhY2tzbGFzaGVzIH5wZXJpb2QgZ2xvYilcbjs7XG5cbmxldCBnbG9iXG4gID8oYW5jaG9yZWQgPSBmYWxzZSlcbiAgPyhwYXRobmFtZSA9IHRydWUpXG4gID8obWF0Y2hfYmFja3NsYXNoZXMgPSBmYWxzZSlcbiAgPyhwZXJpb2QgPSB0cnVlKVxuICA/KGV4cGFuZF9icmFjZXMgPSBmYWxzZSlcbiAgPyhkb3VibGVfYXN0ZXJpc2sgPSB0cnVlKVxuICBzXG4gID1cbiAgbGV0IHRvX3JlIHMgPVxuICAgIGxldCByZSA9IGdsb2IgfnBhdGhuYW1lIH5tYXRjaF9iYWNrc2xhc2hlcyB+cGVyaW9kIChvZl9zdHJpbmcgfmRvdWJsZV9hc3RlcmlzayBzKSBpblxuICAgIGlmIGFuY2hvcmVkIHRoZW4gUmUud2hvbGVfc3RyaW5nIHJlIGVsc2UgcmVcbiAgaW5cbiAgaWYgZXhwYW5kX2JyYWNlcyB0aGVuIFJlLmFsdCAoTGlzdC5tYXAgdG9fcmUgKGV4cGxvZGUgcykpIGVsc2UgdG9fcmUgc1xuOztcblxubGV0IGdsb2InID9hbmNob3JlZCBwZXJpb2QgcyA9IGdsb2IgP2FuY2hvcmVkIH5wZXJpb2Qgc1xubGV0IGdsb2J4ID9hbmNob3JlZCBzID0gZ2xvYiA/YW5jaG9yZWQgfmV4cGFuZF9icmFjZXM6dHJ1ZSBzXG5sZXQgZ2xvYngnID9hbmNob3JlZCBwZXJpb2QgcyA9IGdsb2IgP2FuY2hvcmVkIH5leHBhbmRfYnJhY2VzOnRydWUgfnBlcmlvZCBzXG4iLCJtb2R1bGUgUmUgPSBDb3JlXG5cbmxldCBvZl9uYW1lID0gZnVuY3Rpb25cbiAgfCBcImFscGhhXCIgLT4gUmUuYWxwaGFcbiAgfCBcImFsbnVtXCIgLT4gUmUuYWxudW1cbiAgfCBcImFzY2lpXCIgLT4gUmUuYXNjaWlcbiAgfCBcImJsYW5rXCIgLT4gUmUuYmxhbmtcbiAgfCBcImNudHJsXCIgLT4gUmUuY250cmxcbiAgfCBcImRpZ2l0XCIgLT4gUmUuZGlnaXRcbiAgfCBcImxvd2VyXCIgLT4gUmUubG93ZXJcbiAgfCBcInByaW50XCIgLT4gUmUucHJpbnRcbiAgfCBcInNwYWNlXCIgLT4gUmUuc3BhY2VcbiAgfCBcInVwcGVyXCIgLT4gUmUudXBwZXJcbiAgfCBcIndvcmRcIiAtPiBSZS53b3JkY1xuICB8IFwicHVuY3RcIiAtPiBSZS5wdW5jdFxuICB8IFwiZ3JhcGhcIiAtPiBSZS5ncmFwaFxuICB8IFwieGRpZ2l0XCIgLT4gUmUueGRpZ2l0XG4gIHwgY2xhc3NfIC0+IGludmFsaWRfYXJnIChcIkludmFsaWQgcGNyZSBjbGFzczogXCIgXiBjbGFzc18pXG47O1xuXG5sZXQgbmFtZXMgPVxuICBbIFwiYWxwaGFcIlxuICA7IFwiYWxudW1cIlxuICA7IFwiYXNjaWlcIlxuICA7IFwiYmxhbmtcIlxuICA7IFwiY250cmxcIlxuICA7IFwiZGlnaXRcIlxuICA7IFwibG93ZXJcIlxuICA7IFwicHJpbnRcIlxuICA7IFwic3BhY2VcIlxuICA7IFwidXBwZXJcIlxuICA7IFwid29yZFwiXG4gIDsgXCJwdW5jdFwiXG4gIDsgXCJncmFwaFwiXG4gIDsgXCJ4ZGlnaXRcIlxuICBdXG47O1xuXG5sZXQgcGFyc2UgYnVmID1cbiAgbGV0IGFjY2VwdCA9IFBhcnNlX2J1ZmZlci5hY2NlcHQgYnVmIGluXG4gIGxldCBhY2NlcHRfcyA9IFBhcnNlX2J1ZmZlci5hY2NlcHRfcyBidWYgaW5cbiAgbWF0Y2ggYWNjZXB0ICc6JyB3aXRoXG4gIHwgZmFsc2UgLT4gTm9uZVxuICB8IHRydWUgLT5cbiAgICBsZXQgY29tcGwgPSBhY2NlcHQgJ14nIGluXG4gICAgbGV0IGNscyA9XG4gICAgICB0cnkgTGlzdC5maW5kIGFjY2VwdF9zIG5hbWVzIHdpdGhcbiAgICAgIHwgTm90X2ZvdW5kIC0+IHJhaXNlIFBhcnNlX2J1ZmZlci5QYXJzZV9lcnJvclxuICAgIGluXG4gICAgaWYgbm90IChhY2NlcHRfcyBcIjpdXCIpIHRoZW4gcmFpc2UgUGFyc2VfYnVmZmVyLlBhcnNlX2Vycm9yO1xuICAgIGxldCBwb3NpeF9jbGFzcyA9IG9mX25hbWUgY2xzIGluXG4gICAgU29tZSAoaWYgY29tcGwgdGhlbiBSZS5jb21wbCBbIHBvc2l4X2NsYXNzIF0gZWxzZSBwb3NpeF9jbGFzcylcbjs7XG4iLCIoKlxuICAgUkUgLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaWJyYXJ5XG5cbiAgIENvcHlyaWdodCAoQykgMjAwMSBKZXJvbWUgVm91aWxsb25cbiAgIGVtYWlsOiBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnJcblxuICAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aFxuICAgbGlua2luZyBleGNlcHRpb247IGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0XG4gICB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gICBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gICBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBXG4qKVxuXG5tb2R1bGUgUmUgPSBDb3JlXG5cbmV4Y2VwdGlvbiBQYXJzZV9lcnJvciA9IFBhcnNlX2J1ZmZlci5QYXJzZV9lcnJvclxuZXhjZXB0aW9uIE5vdF9zdXBwb3J0ZWRcblxubGV0IHBhcnNlIG11bHRpbGluZSBkb2xsYXJfZW5kb25seSBkb3RhbGwgdW5ncmVlZHkgcyA9XG4gIGxldCBidWYgPSBQYXJzZV9idWZmZXIuY3JlYXRlIHMgaW5cbiAgbGV0IGFjY2VwdCA9IFBhcnNlX2J1ZmZlci5hY2NlcHQgYnVmIGluXG4gIGxldCBlb3MgKCkgPSBQYXJzZV9idWZmZXIuZW9zIGJ1ZiBpblxuICBsZXQgdGVzdCBjID0gUGFyc2VfYnVmZmVyLnRlc3QgYnVmIGMgaW5cbiAgbGV0IHVuZ2V0ICgpID0gUGFyc2VfYnVmZmVyLnVuZ2V0IGJ1ZiBpblxuICBsZXQgZ2V0ICgpID0gUGFyc2VfYnVmZmVyLmdldCBidWYgaW5cbiAgbGV0IGdyZWVkeV9tb2QgciA9XG4gICAgbGV0IGdyID0gYWNjZXB0ICc/JyBpblxuICAgIGxldCBnciA9IGlmIHVuZ3JlZWR5IHRoZW4gbm90IGdyIGVsc2UgZ3IgaW5cbiAgICBpZiBnciB0aGVuIFJlLm5vbl9ncmVlZHkgciBlbHNlIFJlLmdyZWVkeSByXG4gIGluXG4gIGxldCByZWMgcmVnZXhwICgpID0gcmVnZXhwJyAoYnJhbmNoICgpKVxuICBhbmQgcmVnZXhwJyBsZWZ0ID0gaWYgYWNjZXB0ICd8JyB0aGVuIHJlZ2V4cCcgKFJlLmFsdCBbIGxlZnQ7IGJyYW5jaCAoKSBdKSBlbHNlIGxlZnRcbiAgYW5kIGJyYW5jaCAoKSA9IGJyYW5jaCcgW11cbiAgYW5kIGJyYW5jaCcgbGVmdCA9XG4gICAgaWYgZW9zICgpIHx8IHRlc3QgJ3wnIHx8IHRlc3QgJyknXG4gICAgdGhlbiBSZS5zZXEgKExpc3QucmV2IGxlZnQpXG4gICAgZWxzZSBicmFuY2gnIChwaWVjZSAoKSA6OiBsZWZ0KVxuICBhbmQgcGllY2UgKCkgPVxuICAgIGxldCByID0gYXRvbSAoKSBpblxuICAgIGlmIGFjY2VwdCAnKidcbiAgICB0aGVuIGdyZWVkeV9tb2QgKFJlLnJlcCByKVxuICAgIGVsc2UgaWYgYWNjZXB0ICcrJ1xuICAgIHRoZW4gZ3JlZWR5X21vZCAoUmUucmVwMSByKVxuICAgIGVsc2UgaWYgYWNjZXB0ICc/J1xuICAgIHRoZW4gZ3JlZWR5X21vZCAoUmUub3B0IHIpXG4gICAgZWxzZSBpZiBhY2NlcHQgJ3snXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBQYXJzZV9idWZmZXIuaW50ZWdlciBidWYgd2l0aFxuICAgICAgfCBTb21lIGkgLT5cbiAgICAgICAgbGV0IGogPSBpZiBhY2NlcHQgJywnIHRoZW4gUGFyc2VfYnVmZmVyLmludGVnZXIgYnVmIGVsc2UgU29tZSBpIGluXG4gICAgICAgIGlmIG5vdCAoYWNjZXB0ICd9JykgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgICAgKG1hdGNoIGogd2l0aFxuICAgICAgICAgfCBTb21lIGogd2hlbiBqIDwgaSAtPiByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgICAgfCBfIC0+ICgpKTtcbiAgICAgICAgZ3JlZWR5X21vZCAoUmUucmVwbiByIGkgailcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICB1bmdldCAoKTtcbiAgICAgICAgcilcbiAgICBlbHNlIHJcbiAgYW5kIGF0b20gKCkgPVxuICAgIGlmIGFjY2VwdCAnLidcbiAgICB0aGVuIGlmIGRvdGFsbCB0aGVuIFJlLmFueSBlbHNlIFJlLm5vdG5sXG4gICAgZWxzZSBpZiBhY2NlcHQgJygnXG4gICAgdGhlblxuICAgICAgaWYgYWNjZXB0ICc/J1xuICAgICAgdGhlblxuICAgICAgICBpZiBhY2NlcHQgJzonXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICAgICAgaWYgbm90IChhY2NlcHQgJyknKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICAgIHIpXG4gICAgICAgIGVsc2UgaWYgYWNjZXB0ICcjJ1xuICAgICAgICB0aGVuIGNvbW1lbnQgKClcbiAgICAgICAgZWxzZSBpZiBhY2NlcHQgJzwnXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBuYW1lID0gbmFtZSAoKSBpblxuICAgICAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICAgICAgaWYgbm90IChhY2NlcHQgJyknKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICAgIFJlLmdyb3VwIH5uYW1lIHIpXG4gICAgICAgIGVsc2UgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgciA9IHJlZ2V4cCAoKSBpblxuICAgICAgICBpZiBub3QgKGFjY2VwdCAnKScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIFJlLmdyb3VwIHIpXG4gICAgZWxzZSBpZiBhY2NlcHQgJ14nXG4gICAgdGhlbiBpZiBtdWx0aWxpbmUgdGhlbiBSZS5ib2wgZWxzZSBSZS5ib3NcbiAgICBlbHNlIGlmIGFjY2VwdCAnJCdcbiAgICB0aGVuIGlmIG11bHRpbGluZSB0aGVuIFJlLmVvbCBlbHNlIGlmIGRvbGxhcl9lbmRvbmx5IHRoZW4gUmUubGVvbCBlbHNlIFJlLmVvc1xuICAgIGVsc2UgaWYgYWNjZXB0ICdbJ1xuICAgIHRoZW4gaWYgYWNjZXB0ICdeJyB0aGVuIFJlLmNvbXBsIChicmFja2V0IFtdKSBlbHNlIFJlLmFsdCAoYnJhY2tldCBbXSlcbiAgICBlbHNlIGlmIGFjY2VwdCAnXFxcXCdcbiAgICB0aGVuIChcbiAgICAgICgqIFhYWFxuICAgICAgICAgLSBCYWNrLXJlZmVyZW5jZXNcbiAgICAgICAgIC0gXFxjeCAoY29udHJvbC14KSwgXFxkZGRcbiAgICAgICopXG4gICAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICB8ICd3JyAtPiBSZS5hbHQgWyBSZS5hbG51bTsgUmUuY2hhciAnXycgXVxuICAgICAgfCAnVycgLT4gUmUuY29tcGwgWyBSZS5hbG51bTsgUmUuY2hhciAnXycgXVxuICAgICAgfCAncycgLT4gUmUuc3BhY2VcbiAgICAgIHwgJ1MnIC0+IFJlLmNvbXBsIFsgUmUuc3BhY2UgXVxuICAgICAgfCAnZCcgLT4gUmUuZGlnaXRcbiAgICAgIHwgJ0QnIC0+IFJlLmNvbXBsIFsgUmUuZGlnaXQgXVxuICAgICAgfCAnYicgLT4gUmUuYWx0IFsgUmUuYm93OyBSZS5lb3cgXVxuICAgICAgfCAnQicgLT4gUmUubm90X2JvdW5kYXJ5XG4gICAgICB8ICdBJyAtPiBSZS5ib3NcbiAgICAgIHwgJ1onIC0+IFJlLmxlb2xcbiAgICAgIHwgJ3onIC0+IFJlLmVvc1xuICAgICAgfCAnRycgLT4gUmUuc3RhcnRcbiAgICAgIHwgJ2UnIC0+IFJlLmNoYXIgJ1xceDFiJ1xuICAgICAgfCAnZicgLT4gUmUuY2hhciAnXFx4MGMnXG4gICAgICB8ICduJyAtPiBSZS5jaGFyICdcXG4nXG4gICAgICB8ICdyJyAtPiBSZS5jaGFyICdcXHInXG4gICAgICB8ICd0JyAtPiBSZS5jaGFyICdcXHQnXG4gICAgICB8ICd4JyAtPlxuICAgICAgICBsZXQgYzEgPSBoZXhkaWdpdCAoKSBpblxuICAgICAgICBsZXQgYzIgPSBoZXhkaWdpdCAoKSBpblxuICAgICAgICBsZXQgY29kZSA9IChjMSAqIDE2KSArIGMyIGluXG4gICAgICAgIFJlLmNoYXIgKGNoYXJfb2ZfaW50IGNvZGUpXG4gICAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIC0+IHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgICB8ICcwJyAuLiAnOScgLT4gcmFpc2UgTm90X3N1cHBvcnRlZFxuICAgICAgfCBjIC0+IFJlLmNoYXIgYylcbiAgICBlbHNlIChcbiAgICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgbWF0Y2ggZ2V0ICgpIHdpdGhcbiAgICAgIHwgJyonIHwgJysnIHwgJz8nIHwgJ3snIHwgJ1xcXFwnIC0+IHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgICB8IGMgLT4gUmUuY2hhciBjKVxuICBhbmQgaGV4ZGlnaXQgKCkgPVxuICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGQgLT4gQ2hhci5jb2RlIGQgLSBDaGFyLmNvZGUgJzAnXG4gICAgfCAnYScgLi4gJ2YnIGFzIGQgLT4gQ2hhci5jb2RlIGQgLSBDaGFyLmNvZGUgJ2EnICsgMTBcbiAgICB8ICdBJyAuLiAnRicgYXMgZCAtPiBDaGFyLmNvZGUgZCAtIENoYXIuY29kZSAnQScgKyAxMFxuICAgIHwgXyAtPiByYWlzZSBQYXJzZV9lcnJvclxuICBhbmQgbmFtZSAoKSA9XG4gICAgaWYgZW9zICgpXG4gICAgdGhlbiByYWlzZSBQYXJzZV9lcnJvclxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggZ2V0ICgpIHdpdGhcbiAgICAgIHwgKCdfJyB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onKSBhcyBjIC0+XG4gICAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAzMiBpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiBjO1xuICAgICAgICBuYW1lJyBiXG4gICAgICB8IF8gLT4gcmFpc2UgUGFyc2VfZXJyb3IpXG4gIGFuZCBuYW1lJyBiID1cbiAgICBpZiBlb3MgKClcbiAgICB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAoJ18nIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknKSBhcyBjIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiIGM7XG4gICAgICAgIG5hbWUnIGJcbiAgICAgIHwgJz4nIC0+IEJ1ZmZlci5jb250ZW50cyBiXG4gICAgICB8IF8gLT4gcmFpc2UgUGFyc2VfZXJyb3IpXG4gIGFuZCBicmFja2V0IHMgPVxuICAgIGlmIHMgPD4gW10gJiYgYWNjZXB0ICddJ1xuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggY2hhciAoKSB3aXRoXG4gICAgICB8IGBTZXQgc3QgLT4gYnJhY2tldCAoc3QgOjogcylcbiAgICAgIHwgYENoYXIgYyAtPlxuICAgICAgICBpZiBhY2NlcHQgJy0nXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiBhY2NlcHQgJ10nXG4gICAgICAgICAgdGhlbiBSZS5jaGFyIGMgOjogUmUuY2hhciAnLScgOjogc1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyYWNrZXRcbiAgICAgICAgICAgICAgKG1hdGNoIGNoYXIgKCkgd2l0aFxuICAgICAgICAgICAgICAgfCBgQ2hhciBjJyAtPiBSZS5yZyBjIGMnIDo6IHNcbiAgICAgICAgICAgICAgIHwgYFNldCBzdCcgLT4gUmUuY2hhciBjIDo6IFJlLmNoYXIgJy0nIDo6IHN0JyA6OiBzKVxuICAgICAgICBlbHNlIGJyYWNrZXQgKFJlLmNoYXIgYyA6OiBzKSlcbiAgYW5kIGNoYXIgKCkgPVxuICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgIGxldCBjID0gZ2V0ICgpIGluXG4gICAgaWYgYyA9ICdbJ1xuICAgIHRoZW4gKFxuICAgICAgaWYgYWNjZXB0ICc9JyB0aGVuIHJhaXNlIE5vdF9zdXBwb3J0ZWQ7XG4gICAgICBtYXRjaCBQb3NpeF9jbGFzcy5wYXJzZSBidWYgd2l0aFxuICAgICAgfCBTb21lIHNldCAtPiBgU2V0IHNldFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIGlmIGFjY2VwdCAnLidcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgICAgbGV0IGMgPSBnZXQgKCkgaW5cbiAgICAgICAgICBpZiBub3QgKGFjY2VwdCAnLicpIHRoZW4gcmFpc2UgTm90X3N1cHBvcnRlZDtcbiAgICAgICAgICBpZiBub3QgKGFjY2VwdCAnXScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgICAgYENoYXIgYylcbiAgICAgICAgZWxzZSBgQ2hhciBjKVxuICAgIGVsc2UgaWYgYyA9ICdcXFxcJ1xuICAgIHRoZW4gKFxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBsZXQgYyA9IGdldCAoKSBpblxuICAgICAgKCogWFhYXG4gICAgICAgICBcXDEyNywgLi4uXG4gICAgICAqKVxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICdiJyAtPiBgQ2hhciAnXFwwMDgnXG4gICAgICB8ICduJyAtPiBgQ2hhciAnXFxuJyAoKlhYWCopXG4gICAgICB8ICdyJyAtPiBgQ2hhciAnXFxyJyAoKlhYWCopXG4gICAgICB8ICd0JyAtPiBgQ2hhciAnXFx0JyAoKlhYWCopXG4gICAgICB8ICd3JyAtPiBgU2V0IChSZS5hbHQgWyBSZS5hbG51bTsgUmUuY2hhciAnXycgXSlcbiAgICAgIHwgJ1cnIC0+IGBTZXQgKFJlLmNvbXBsIFsgUmUuYWxudW07IFJlLmNoYXIgJ18nIF0pXG4gICAgICB8ICdzJyAtPiBgU2V0IFJlLnNwYWNlXG4gICAgICB8ICdTJyAtPiBgU2V0IChSZS5jb21wbCBbIFJlLnNwYWNlIF0pXG4gICAgICB8ICdkJyAtPiBgU2V0IFJlLmRpZ2l0XG4gICAgICB8ICdEJyAtPiBgU2V0IChSZS5jb21wbCBbIFJlLmRpZ2l0IF0pXG4gICAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIC0+IHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgICB8ICcwJyAuLiAnOScgLT4gcmFpc2UgTm90X3N1cHBvcnRlZFxuICAgICAgfCBfIC0+IGBDaGFyIGMpXG4gICAgZWxzZSBgQ2hhciBjXG4gIGFuZCBjb21tZW50ICgpID1cbiAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICBpZiBhY2NlcHQgJyknXG4gICAgdGhlbiBSZS5lcHNpbG9uXG4gICAgZWxzZSAoXG4gICAgICBQYXJzZV9idWZmZXIuanVuayBidWY7XG4gICAgICBjb21tZW50ICgpKVxuICBpblxuICBsZXQgcmVzID0gcmVnZXhwICgpIGluXG4gIGlmIG5vdCAoZW9zICgpKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICByZXNcbjs7XG5cbnR5cGUgb3B0ID1cbiAgWyBgVW5ncmVlZHlcbiAgfCBgRG90YWxsXG4gIHwgYERvbGxhcl9lbmRvbmx5XG4gIHwgYE11bHRpbGluZVxuICB8IGBBbmNob3JlZFxuICB8IGBDYXNlbGVzc1xuICBdXG5cbmxldCByZSA/KG9wdHMgPSBbXSkgcyA9XG4gIGxldCByID1cbiAgICBwYXJzZVxuICAgICAgKExpc3QubWVtcSBgTXVsdGlsaW5lIG9wdHMpXG4gICAgICAoTGlzdC5tZW1xIGBEb2xsYXJfZW5kb25seSBvcHRzKVxuICAgICAgKExpc3QubWVtcSBgRG90YWxsIG9wdHMpXG4gICAgICAoTGlzdC5tZW1xIGBVbmdyZWVkeSBvcHRzKVxuICAgICAgc1xuICBpblxuICBsZXQgciA9IGlmIExpc3QubWVtcSBgQW5jaG9yZWQgb3B0cyB0aGVuIFJlLnNlcSBbIFJlLnN0YXJ0OyByIF0gZWxzZSByIGluXG4gIGxldCByID0gaWYgTGlzdC5tZW1xIGBDYXNlbGVzcyBvcHRzIHRoZW4gUmUubm9fY2FzZSByIGVsc2UgciBpblxuICByXG47O1xuXG5sZXQgY29tcGlsZSA9IFJlLmNvbXBpbGVcbmxldCBjb21waWxlX3BhdCA/KG9wdHMgPSBbXSkgcyA9IGNvbXBpbGUgKHJlIH5vcHRzIHMpXG4iLCJtb2R1bGUgUmUgPSBDb3JlXG5cbmV4Y2VwdGlvbiBQYXJzZV9lcnJvciA9IFBlcmwuUGFyc2VfZXJyb3JcbmV4Y2VwdGlvbiBOb3Rfc3VwcG9ydGVkID0gUGVybC5Ob3Rfc3VwcG9ydGVkXG5cbnR5cGUgcmVnZXhwID0gUmUucmVcblxudHlwZSBmbGFnID1cbiAgWyBgQ0FTRUxFU1NcbiAgfCBgTVVMVElMSU5FXG4gIHwgYEFOQ0hPUkVEXG4gIHwgYERPVEFMTFxuICBdXG5cbnR5cGUgc3BsaXRfcmVzdWx0ID1cbiAgfCBUZXh0IG9mIHN0cmluZ1xuICB8IERlbGltIG9mIHN0cmluZ1xuICB8IEdyb3VwIG9mIGludCAqIHN0cmluZ1xuICB8IE5vR3JvdXBcblxudHlwZSBncm91cHMgPSBDb3JlLkdyb3VwLnRcblxubGV0IHJlID8oZmxhZ3MgPSBbXSkgcGF0ID1cbiAgbGV0IG9wdHMgPVxuICAgIExpc3QubWFwXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBgQ0FTRUxFU1MgLT4gYENhc2VsZXNzXG4gICAgICAgIHwgYE1VTFRJTElORSAtPiBgTXVsdGlsaW5lXG4gICAgICAgIHwgYEFOQ0hPUkVEIC0+IGBBbmNob3JlZFxuICAgICAgICB8IGBET1RBTEwgLT4gYERvdGFsbClcbiAgICAgIGZsYWdzXG4gIGluXG4gIFBlcmwucmUgfm9wdHMgcGF0XG47O1xuXG5sZXQgcmVnZXhwID9mbGFncyBwYXQgPSBSZS5jb21waWxlIChyZSA/ZmxhZ3MgcGF0KVxubGV0IGV4dHJhY3QgfnJleCBzID0gUmUuR3JvdXAuYWxsIChSZS5leGVjIHJleCBzKVxubGV0IGV4ZWMgfnJleCA/cG9zIHMgPSBSZS5leGVjIHJleCA/cG9zIHNcbmxldCBnZXRfc3Vic3RyaW5nIHMgaSA9IFJlLkdyb3VwLmdldCBzIGlcbmxldCBuYW1lcyByZXggPSBSZS5ncm91cF9uYW1lcyByZXggfD4gTGlzdC5tYXAgZnN0IHw+IEFycmF5Lm9mX2xpc3RcblxubGV0IGdldF9uYW1lZF9zdWJzdHJpbmcgcmV4IG5hbWUgcyA9XG4gIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICB8IChuLCBpKSA6OiByZW0gd2hlbiBuID0gbmFtZSAtPlxuICAgICAgKHRyeSBnZXRfc3Vic3RyaW5nIHMgaSB3aXRoXG4gICAgICAgfCBOb3RfZm91bmQgLT4gbG9vcCByZW0pXG4gICAgfCBfIDo6IHJlbSAtPiBsb29wIHJlbVxuICBpblxuICBsb29wIChSZS5ncm91cF9uYW1lcyByZXgpXG47O1xuXG5sZXQgZ2V0X3N1YnN0cmluZ19vZnMgcyBpID0gUmUuR3JvdXAub2Zmc2V0IHMgaVxubGV0IHBtYXRjaCB+cmV4IHMgPSBSZS5leGVjcCByZXggc1xuXG5sZXQgc3Vic3RpdHV0ZSB+cmV4IH5zdWJzdCBzdHIgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTAyNCBpblxuICBsZXQgcmVjIGxvb3AgcG9zIG9uX21hdGNoID1cbiAgICBpZiBSZS5leGVjcCB+cG9zIHJleCBzdHJcbiAgICB0aGVuIChcbiAgICAgIGxldCBzcyA9IFJlLmV4ZWMgfnBvcyByZXggc3RyIGluXG4gICAgICBsZXQgc3RhcnQsIGZpbiA9IFJlLkdyb3VwLm9mZnNldCBzcyAwIGluXG4gICAgICBpZiBvbl9tYXRjaCAmJiBzdGFydCA9IHBvcyAmJiBzdGFydCA9IGZpblxuICAgICAgdGhlbiAoXG4gICAgICAgIGlmICgqIEVtcHR5IG1hdGNoIGZvbGxvd2luZyBhIG1hdGNoICopXG4gICAgICAgICAgIHBvcyA8IFN0cmluZy5sZW5ndGggc3RyXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiIHN0ci5bcG9zXTtcbiAgICAgICAgICBsb29wIChwb3MgKyAxKSBmYWxzZSkpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHBhdCA9IFJlLkdyb3VwLmdldCBzcyAwIGluXG4gICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIgc3RyIHBvcyAoc3RhcnQgLSBwb3MpO1xuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBiIChzdWJzdCBwYXQpO1xuICAgICAgICBpZiBzdGFydCA9IGZpblxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBpZiAoKiBNYW51YWxseSBhZHZhbmNlIGJ5IG9uZSBhZnRlciBhbiBlbXB0eSBtYXRjaCAqKVxuICAgICAgICAgICAgIGZpbiA8IFN0cmluZy5sZW5ndGggc3RyXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiBzdHIuW2Zpbl07XG4gICAgICAgICAgICBsb29wIChmaW4gKyAxKSBmYWxzZSkpXG4gICAgICAgIGVsc2UgbG9vcCBmaW4gdHJ1ZSkpXG4gICAgZWxzZSBCdWZmZXIuYWRkX3N1YnN0cmluZyBiIHN0ciBwb3MgKFN0cmluZy5sZW5ndGggc3RyIC0gcG9zKVxuICBpblxuICBsb29wIDAgZmFsc2U7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG47O1xuXG5sZXQgc3BsaXQgfnJleCBzdHIgPVxuICBsZXQgZmluaXNoIHN0ciBsYXN0IGFjY3UgPVxuICAgIGxldCBhY2N1ID0gU3RyaW5nLnN1YiBzdHIgbGFzdCAoU3RyaW5nLmxlbmd0aCBzdHIgLSBsYXN0KSA6OiBhY2N1IGluXG4gICAgTGlzdC5yZXYgYWNjdVxuICBpblxuICBsZXQgcmVjIGxvb3AgYWNjdSBsYXN0IHBvcyBvbl9tYXRjaCA9XG4gICAgaWYgUmUuZXhlY3AgfnBvcyByZXggc3RyXG4gICAgdGhlbiAoXG4gICAgICBsZXQgc3MgPSBSZS5leGVjIH5wb3MgcmV4IHN0ciBpblxuICAgICAgbGV0IHN0YXJ0LCBmaW4gPSBSZS5Hcm91cC5vZmZzZXQgc3MgMCBpblxuICAgICAgaWYgb25fbWF0Y2ggJiYgc3RhcnQgPSBwb3MgJiYgc3RhcnQgPSBmaW5cbiAgICAgIHRoZW5cbiAgICAgICAgaWYgKCogRW1wdHkgbWF0Y2ggZm9sbG93aW5nIGEgbWF0Y2ggKilcbiAgICAgICAgICAgcG9zID0gU3RyaW5nLmxlbmd0aCBzdHJcbiAgICAgICAgdGhlbiBmaW5pc2ggc3RyIGxhc3QgYWNjdVxuICAgICAgICBlbHNlIGxvb3AgYWNjdSBsYXN0IChwb3MgKyAxKSBmYWxzZVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBhY2N1ID0gU3RyaW5nLnN1YiBzdHIgbGFzdCAoc3RhcnQgLSBsYXN0KSA6OiBhY2N1IGluXG4gICAgICAgIGlmIHN0YXJ0ID0gZmluXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiAoKiBNYW51YWxseSBhZHZhbmNlIGJ5IG9uZSBhZnRlciBhbiBlbXB0eSBtYXRjaCAqKVxuICAgICAgICAgICAgIGZpbiA9IFN0cmluZy5sZW5ndGggc3RyXG4gICAgICAgICAgdGhlbiBmaW5pc2ggc3RyIGZpbiBhY2N1XG4gICAgICAgICAgZWxzZSBsb29wIGFjY3UgZmluIChmaW4gKyAxKSBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgYWNjdSBmaW4gZmluIHRydWUpKVxuICAgIGVsc2UgZmluaXNoIHN0ciBsYXN0IGFjY3VcbiAgaW5cbiAgbG9vcCBbXSAwIDAgZmFsc2Vcbjs7XG5cbigqIEZyb20gUENSRSAqKVxubGV0IHN0cmluZ191bnNhZmVfc3ViIHMgb2ZzIGxlbiA9XG4gIGxldCByID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICBCeXRlcy51bnNhZmVfYmxpdCBzIG9mcyByIDAgbGVuO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJcbjs7XG5cbmxldCBxdW90ZSBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIChsZW4gbHNsIDEpIGluXG4gIGxldCBwb3MgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgfCAoJ1xcXFwnIHwgJ14nIHwgJyQnIHwgJy4nIHwgJ1snIHwgJ3wnIHwgJygnIHwgJyknIHwgJz8nIHwgJyonIHwgJysnIHwgJ3snKSBhcyBjIC0+XG4gICAgICBCeXRlcy51bnNhZmVfc2V0IGJ1ZiAhcG9zICdcXFxcJztcbiAgICAgIGluY3IgcG9zO1xuICAgICAgQnl0ZXMudW5zYWZlX3NldCBidWYgIXBvcyBjO1xuICAgICAgaW5jciBwb3NcbiAgICB8IGMgLT5cbiAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgYnVmICFwb3MgYztcbiAgICAgIGluY3IgcG9zXG4gIGRvbmU7XG4gIHN0cmluZ191bnNhZmVfc3ViIGJ1ZiAwICFwb3Ncbjs7XG5cbmxldCBmdWxsX3NwbGl0ID8obWF4ID0gMCkgfnJleCBzID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzID0gMFxuICB0aGVuIFtdXG4gIGVsc2UgaWYgbWF4ID0gMVxuICB0aGVuIFsgVGV4dCBzIF1cbiAgZWxzZSAoXG4gICAgbGV0IHJlc3VsdHMgPSBSZS5zcGxpdF9mdWxsIHJleCBzIGluXG4gICAgbGV0IG1hdGNoZXMgPVxuICAgICAgTGlzdC5tYXBcbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBgVGV4dCBzIC0+IFsgVGV4dCBzIF1cbiAgICAgICAgICB8IGBEZWxpbSBkIC0+XG4gICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IFJlLkdyb3VwLmFsbF9vZmZzZXQgZCBpblxuICAgICAgICAgICAgbGV0IGRlbGltID0gUmUuR3JvdXAuZ2V0IGQgMCBpblxuICAgICAgICAgICAgRGVsaW0gZGVsaW1cbiAgICAgICAgICAgIDo6XG4gICAgICAgICAgICAobGV0IGwgPSByZWYgW10gaW5cbiAgICAgICAgICAgICBmb3IgaSA9IDEgdG8gQXJyYXkubGVuZ3RoIG1hdGNoZXMgLSAxIGRvXG4gICAgICAgICAgICAgICBsXG4gICAgICAgICAgICAgICA6PSAoaWYgbWF0Y2hlcy4oaSkgPSAoLTEsIC0xKSB0aGVuIE5vR3JvdXAgZWxzZSBHcm91cCAoaSwgUmUuR3JvdXAuZ2V0IGQgaSkpXG4gICAgICAgICAgICAgICAgICA6OiAhbFxuICAgICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgICAgTGlzdC5yZXYgIWwpKVxuICAgICAgICByZXN1bHRzXG4gICAgaW5cbiAgICBMaXN0LmNvbmNhdCBtYXRjaGVzKVxuOztcblxudHlwZSBzdWJzdHJpbmdzID0gR3JvdXAudFxuIiwiKCpcbiAgIFJFIC0gQSByZWd1bGFyIGV4cHJlc3Npb24gbGlicmFyeVxuXG4gICBDb3B5cmlnaHQgKEMpIDIwMDEgSmVyb21lIFZvdWlsbG9uXG4gICBlbWFpbDogSmVyb21lLlZvdWlsbG9uQHBwcy5qdXNzaWV1LmZyXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGhcbiAgIGxpbmtpbmcgZXhjZXB0aW9uOyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdFxuICAgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuICAgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICAgRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQVxuKilcblxuKCpcbiAgIFdoYXQgd2UgY291bGQgKHNob3VsZD8pIGRvOlxuICAgLSBhKiA9PT4gbG9uZ2VzdCAoKHNob3J0ZXN0IChub19ncm91cCBhKSogKSwgYSB8ICgpKSAgKCEhISlcbiAgIC0gYWJjIHVuZGVyc3Rvb2QgYXMgKGFiKWNcbiAgIC0gXCIoKGE/KXxiKVwiIGFnYWluc3QgXCJhYlwiIHNob3VsZCBub3QgYmluZCB0aGUgZmlyc3Qgc3VicGF0dGVybiB0byBhbnl0aGluZ1xuXG4gICBOb3RlIHRoYXQgaXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIGhhbmRsZSBcIigoKGFiKWMpZCllXCIgZWZmaWNpZW50bHlcbiopXG5tb2R1bGUgUmUgPSBDb3JlXG5cbmV4Y2VwdGlvbiBQYXJzZV9lcnJvciA9IFBhcnNlX2J1ZmZlci5QYXJzZV9lcnJvclxuZXhjZXB0aW9uIE5vdF9zdXBwb3J0ZWRcblxubGV0IHBhcnNlIG5ld2xpbmUgcyA9XG4gIGxldCBidWYgPSBQYXJzZV9idWZmZXIuY3JlYXRlIHMgaW5cbiAgbGV0IGFjY2VwdCA9IFBhcnNlX2J1ZmZlci5hY2NlcHQgYnVmIGluXG4gIGxldCBlb3MgKCkgPSBQYXJzZV9idWZmZXIuZW9zIGJ1ZiBpblxuICBsZXQgdGVzdCBjID0gUGFyc2VfYnVmZmVyLnRlc3QgYnVmIGMgaW5cbiAgbGV0IHVuZ2V0ICgpID0gUGFyc2VfYnVmZmVyLnVuZ2V0IGJ1ZiBpblxuICBsZXQgZ2V0ICgpID0gUGFyc2VfYnVmZmVyLmdldCBidWYgaW5cbiAgbGV0IHJlYyByZWdleHAgKCkgPSByZWdleHAnIChicmFuY2ggKCkpXG4gIGFuZCByZWdleHAnIGxlZnQgPSBpZiBhY2NlcHQgJ3wnIHRoZW4gcmVnZXhwJyAoUmUuYWx0IFsgbGVmdDsgYnJhbmNoICgpIF0pIGVsc2UgbGVmdFxuICBhbmQgYnJhbmNoICgpID0gYnJhbmNoJyBbXVxuICBhbmQgYnJhbmNoJyBsZWZ0ID1cbiAgICBpZiBlb3MgKCkgfHwgdGVzdCAnfCcgfHwgdGVzdCAnKSdcbiAgICB0aGVuIFJlLnNlcSAoTGlzdC5yZXYgbGVmdClcbiAgICBlbHNlIGJyYW5jaCcgKHBpZWNlICgpIDo6IGxlZnQpXG4gIGFuZCBwaWVjZSAoKSA9XG4gICAgbGV0IHIgPSBhdG9tICgpIGluXG4gICAgaWYgYWNjZXB0ICcqJ1xuICAgIHRoZW4gUmUucmVwIChSZS5uZXN0IHIpXG4gICAgZWxzZSBpZiBhY2NlcHQgJysnXG4gICAgdGhlbiBSZS5yZXAxIChSZS5uZXN0IHIpXG4gICAgZWxzZSBpZiBhY2NlcHQgJz8nXG4gICAgdGhlbiBSZS5vcHQgclxuICAgIGVsc2UgaWYgYWNjZXB0ICd7J1xuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggUGFyc2VfYnVmZmVyLmludGVnZXIgYnVmIHdpdGhcbiAgICAgIHwgU29tZSBpIC0+XG4gICAgICAgIGxldCBqID0gaWYgYWNjZXB0ICcsJyB0aGVuIFBhcnNlX2J1ZmZlci5pbnRlZ2VyIGJ1ZiBlbHNlIFNvbWUgaSBpblxuICAgICAgICBpZiBub3QgKGFjY2VwdCAnfScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIChtYXRjaCBqIHdpdGhcbiAgICAgICAgIHwgU29tZSBqIHdoZW4gaiA8IGkgLT4gcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgICAgIHwgXyAtPiAoKSk7XG4gICAgICAgIFJlLnJlcG4gKFJlLm5lc3QgcikgaSBqXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgdW5nZXQgKCk7XG4gICAgICAgIHIpXG4gICAgZWxzZSByXG4gIGFuZCBhdG9tICgpID1cbiAgICBpZiBhY2NlcHQgJy4nXG4gICAgdGhlbiBpZiBuZXdsaW5lIHRoZW4gUmUubm90bmwgZWxzZSBSZS5hbnlcbiAgICBlbHNlIGlmIGFjY2VwdCAnKCdcbiAgICB0aGVuIChcbiAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICBpZiBub3QgKGFjY2VwdCAnKScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBSZS5ncm91cCByKVxuICAgIGVsc2UgaWYgYWNjZXB0ICdeJ1xuICAgIHRoZW4gaWYgbmV3bGluZSB0aGVuIFJlLmJvbCBlbHNlIFJlLmJvc1xuICAgIGVsc2UgaWYgYWNjZXB0ICckJ1xuICAgIHRoZW4gaWYgbmV3bGluZSB0aGVuIFJlLmVvbCBlbHNlIFJlLmVvc1xuICAgIGVsc2UgaWYgYWNjZXB0ICdbJ1xuICAgIHRoZW5cbiAgICAgIGlmIGFjY2VwdCAnXidcbiAgICAgIHRoZW4gUmUuZGlmZiAoUmUuY29tcGwgKGJyYWNrZXQgW10pKSAoUmUuY2hhciAnXFxuJylcbiAgICAgIGVsc2UgUmUuYWx0IChicmFja2V0IFtdKVxuICAgIGVsc2UgaWYgYWNjZXB0ICdcXFxcJ1xuICAgIHRoZW4gKFxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAoJ3wnIHwgJygnIHwgJyknIHwgJyonIHwgJysnIHwgJz8nIHwgJ1snIHwgJy4nIHwgJ14nIHwgJyQnIHwgJ3snIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgIFJlLmNoYXIgY1xuICAgICAgfCBfIC0+IHJhaXNlIFBhcnNlX2Vycm9yKVxuICAgIGVsc2UgKFxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAnKicgfCAnKycgfCAnPycgfCAneycgfCAnXFxcXCcgLT4gcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgIHwgYyAtPiBSZS5jaGFyIGMpXG4gIGFuZCBicmFja2V0IHMgPVxuICAgIGlmIHMgPD4gW10gJiYgYWNjZXB0ICddJ1xuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggY2hhciAoKSB3aXRoXG4gICAgICB8IGBTZXQgc3QgLT4gYnJhY2tldCAoc3QgOjogcylcbiAgICAgIHwgYENoYXIgYyAtPlxuICAgICAgICBpZiBhY2NlcHQgJy0nXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiBhY2NlcHQgJ10nXG4gICAgICAgICAgdGhlbiBSZS5jaGFyIGMgOjogUmUuY2hhciAnLScgOjogc1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyYWNrZXRcbiAgICAgICAgICAgICAgKG1hdGNoIGNoYXIgKCkgd2l0aFxuICAgICAgICAgICAgICAgfCBgQ2hhciBjJyAtPiBSZS5yZyBjIGMnIDo6IHNcbiAgICAgICAgICAgICAgIHwgYFNldCBzdCcgLT4gUmUuY2hhciBjIDo6IFJlLmNoYXIgJy0nIDo6IHN0JyA6OiBzKVxuICAgICAgICBlbHNlIGJyYWNrZXQgKFJlLmNoYXIgYyA6OiBzKSlcbiAgYW5kIGNoYXIgKCkgPVxuICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgIGxldCBjID0gZ2V0ICgpIGluXG4gICAgaWYgYyA9ICdbJ1xuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggUG9zaXhfY2xhc3MucGFyc2UgYnVmIHdpdGhcbiAgICAgIHwgU29tZSBzZXQgLT4gYFNldCBzZXRcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBpZiBhY2NlcHQgJy4nXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICAgIGxldCBjID0gZ2V0ICgpIGluXG4gICAgICAgICAgaWYgbm90IChhY2NlcHQgJy4nKSB0aGVuIHJhaXNlIE5vdF9zdXBwb3J0ZWQ7XG4gICAgICAgICAgaWYgbm90IChhY2NlcHQgJ10nKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICAgIGBDaGFyIGMpXG4gICAgICAgIGVsc2UgYENoYXIgYylcbiAgICBlbHNlIGBDaGFyIGNcbiAgaW5cbiAgbGV0IHJlcyA9IHJlZ2V4cCAoKSBpblxuICBpZiBub3QgKGVvcyAoKSkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgcmVzXG47O1xuXG50eXBlIG9wdCA9XG4gIFsgYElDYXNlXG4gIHwgYE5vU3ViXG4gIHwgYE5ld2xpbmVcbiAgXVxuXG5sZXQgcmUgPyhvcHRzID0gW10pIHMgPVxuICBsZXQgciA9IHBhcnNlIChMaXN0Lm1lbXEgYE5ld2xpbmUgb3B0cykgcyBpblxuICBsZXQgciA9IGlmIExpc3QubWVtcSBgSUNhc2Ugb3B0cyB0aGVuIFJlLm5vX2Nhc2UgciBlbHNlIHIgaW5cbiAgbGV0IHIgPSBpZiBMaXN0Lm1lbXEgYE5vU3ViIG9wdHMgdGhlbiBSZS5ub19ncm91cCByIGVsc2UgciBpblxuICByXG47O1xuXG5sZXQgY29tcGlsZSByZSA9IFJlLmNvbXBpbGUgKFJlLmxvbmdlc3QgcmUpXG5sZXQgY29tcGlsZV9wYXQgPyhvcHRzID0gW10pIHMgPSBjb21waWxlIChyZSB+b3B0cyBzKVxuIl19
