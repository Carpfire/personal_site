// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Base64_rfc2045
//# unitInfo: Requires: Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Format, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    cst_Expected_Await_encode = "Expected `Await encode",
    cst_src_base64_rfc2045_ml = "src/base64_rfc2045.ml",
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    default_alphabet = cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Format = global_data.Stdlib__Format,
    _d_ = [0, cst_src_base64_rfc2045_ml, 451, 9],
    _c_ = [0, [11, cst_Expected_Await_encode, 0], cst_Expected_Await_encode],
    _b_ = [0, cst_src_base64_rfc2045_ml, 151, 9],
    _a_ =
      [0,
       [11,
        "Invalid bounds (off: ",
        [4, 0, 0, 0, [11, ", len: ", [4, 0, 0, 0, [12, 41, 0]]]]],
       "Invalid bounds (off: %d, len: %d)"];
   function invalid_arg(fmt){
    function _J_(s){return caml_call1(Stdlib[1], s);}
    return caml_call2(Stdlib_Format[147], _J_, fmt);
   }
   function invalid_bounds(off, len){
    return caml_call2(invalid_arg(_a_), off, len);
   }
   function malformed(chr){
    return [0, 659980059, caml_call2(Stdlib_String[1], 1, chr)];
   }
   function unsafe_byte(source, off, pos){
    return runtime.caml_bytes_unsafe_get(source, off + pos | 0);
   }
   function unsafe_set_chr(source, off, chr){
    runtime.caml_bytes_unsafe_set(source, off, chr);
    return;
   }
   function continue$0(state, param){
    var size = param[2], quantum = param[1];
    return [0, 192584839, [0, quantum, size, state[3]]];
   }
   function r_repr(state, chr){
    var
     size = state[2],
     quantum = state[1],
     code =
       caml_string_get
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\xff\xff\xff?456789:;<=\xff\xff\xff\xff\xff\xff\xff\0\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0b\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\xff\xff\xff\xff\xff\xff\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123\xff\xff\xff\xff\xff",
         chr);
    if(3 < size >>> 0) return malformed(chr);
    switch(size){
      case 0:
       return continue$0(state, [0, code, 1]);
      case 1:
       return continue$0(state, [0, quantum << 6 | code, 2]);
      case 2:
       return continue$0(state, [0, quantum << 6 | code, 3]);
      default:
       unsafe_set_chr(state[3], 0, (quantum >>> 10 | 0) & 255);
       unsafe_set_chr(state[3], 1, (quantum >>> 2 | 0) & 255);
       unsafe_set_chr(state[3], 2, (quantum << 6 | code) & 255);
       return [0, 365482660, [0, 0, 0, state[3]]];
    }
   }
   function i_rem(decoder){return (decoder[5] - decoder[4] | 0) + 1 | 0;}
   function end_of_input(decoder){
    decoder[2] = Stdlib_Bytes[3];
    decoder[3] = 0;
    decoder[4] = 0;
    decoder[5] = Stdlib[20];
    return 0;
   }
   function src(decoder, source, off, len){
    if
     (0 <= off && 0 <= len && caml_ml_bytes_length(source) >= (off + len | 0))
     return 0 === len
             ? end_of_input(decoder)
             : (decoder
                [2]
               = source,
               decoder[3] = off,
               decoder[4] = 0,
               decoder[5] = len - 1 | 0,
               0);
    return invalid_bounds(off, len);
   }
   function refill(k, decoder){
    var match = decoder[1];
    if(typeof match === "number"){decoder[12] = k; return 1006505782;}
    if(438511779 <= match[1]){
     var
      ic = match[2],
      len =
        caml_call4
         (Stdlib[84], ic, decoder[2], 0, caml_ml_bytes_length(decoder[2]));
     src(decoder, decoder[2], 0, len);
     return caml_call1(k, decoder);
    }
    end_of_input(decoder);
    return caml_call1(k, decoder);
   }
   function ret(k, v, byte_count, decoder){
    decoder[12] = k;
    decoder[9] = decoder[9] + byte_count | 0;
    decoder[10] = decoder[10] + byte_count | 0;
    if(78 < decoder[10]) decoder[8] = 1;
    return caml_call2(decoder[11], decoder, v);
   }
   function decode_base64_lf_after_cr(decoder){
    var rem = i_rem(decoder);
    return 0 <= rem
            ? 0
              === rem
              ? refill(decode_base64_lf_after_cr, decoder)
              : 10
                === unsafe_byte(decoder[2], decoder[3], decoder[4])
                ? (decoder
                   [4]
                  = decoder[4] + 1 | 0,
                  ret(decode_base64, -879233260, 2, decoder))
                : ret(decode_base64, malformed(13), 1, decoder)
            : ret(decode_base64, malformed(13), 1, decoder);
   }
   function decode_base64(decoder){
    var rem = i_rem(decoder);
    if(0 >= rem){
     if(0 <= rem) return refill(decode_base64, decoder);
     var
      param = decoder[6],
      buffer = param[3],
      size = param[2],
      quantum = param[1],
      _G_ = 0;
     if(2 < size >>> 0){
      if(3 !== size)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      var quantum$0 = quantum >>> 2 | 0;
      unsafe_set_chr(buffer, 0, (quantum$0 >>> 8 | 0) & 255);
      unsafe_set_chr(buffer, 1, quantum$0 & 255);
      var
       _H_ =
         [0,
          365482660,
          [0, quantum$0, size, caml_call3(Stdlib_Bytes[7], buffer, 0, 2)]];
     }
     else if(2 <= size)
      var
       quantum$1 = quantum >>> 4 | 0,
       _H_ =
         [0,
          365482660,
          [0,
           quantum$1,
           size,
           caml_call2(Stdlib_Bytes[1], 1, quantum$1 & 255)]];
     else
      var _H_ = [0, 365482660, [0, quantum, size, Stdlib_Bytes[3]]];
     return ret
             (function(decoder){
               var padding = decoder[7], size = decoder[6][2];
               a:
               {
                if(3 >= size >>> 0)
                 switch(size){
                   case 0:
                    if(0 === padding){var _I_ = 1; break a;} break;
                   case 1:
                    var _I_ = 0; break a;
                   case 2:
                    if(2 === padding){var _I_ = 1; break a;} break;
                   default: if(1 === padding){var _I_ = 1; break a;}
                 }
                var _I_ = 0;
               }
               if(_I_) return 3455931;
               function k(param){return 3455931;}
               decoder[12] = k;
               return -445616801;
              },
              _H_,
              _G_,
              decoder);
    }
    var chr$0 = unsafe_byte(decoder[2], decoder[3], decoder[4]);
    a:
    {
     b:
     {
      if(44 > chr$0){
       if(14 <= chr$0){
        if(32 !== chr$0){if(43 <= chr$0) break b; break a;}
       }
       else if(9 !== chr$0){
        if(13 > chr$0) break a;
        decoder[4] = decoder[4] + 1 | 0;
        return decode_base64_lf_after_cr(decoder);
       }
       decoder[4] = decoder[4] + 1 | 0;
       return ret(decode_base64, 4352180, 1, decoder);
      }
      if(62 <= chr$0){
       if(91 <= chr$0){
        if(25 < chr$0 - 97 >>> 0) break a;
       }
       else if(65 > chr$0) break a;
      }
      else{
       if(58 <= chr$0){
        if(61 > chr$0) break a;
        decoder[7] = decoder[7] + 1 | 0;
        decoder[4] = decoder[4] + 1 | 0;
        return ret(decode_base64, 500072881, 1, decoder);
       }
       if(47 > chr$0) break a;
      }
     }
     if(0 !== decoder[7]){
      decoder[4] = decoder[4] + 1 | 0;
      return ret(decode_base64, malformed(chr$0), 1, decoder);
     }
     var v$1 = r_repr(decoder[6], chr$0);
     b:
     {
      c:
      {
       var pos = 1, v = v$1;
       for(;;){
        if(365482660 <= v[1]){
         decoder[4] = decoder[4] + pos | 0;
         return ret(decode_base64, v, pos, decoder);
        }
        var state = v[2];
        if(0 >= ((decoder[5] - (decoder[4] + pos | 0) | 0) + 1 | 0)){
         decoder[4] = decoder[4] + pos | 0;
         decoder[9] = decoder[9] + pos | 0;
         decoder[10] = decoder[10] + pos | 0;
         decoder[6] = state;
         return refill(decode_base64, decoder);
        }
        var chr = unsafe_byte(decoder[2], decoder[3], decoder[4] + pos | 0);
        if(44 <= chr)
         if(62 <= chr){
          if(91 <= chr){
           if(25 < chr - 97 >>> 0) break b;
          }
          else if(65 > chr) break b;
         }
         else{
          if(58 <= chr){
           if(61 > chr) break b;
           decoder[7] = decoder[7] + 1 | 0;
           decoder[4] = (decoder[4] + pos | 0) + 1 | 0;
           decoder[6] = state;
           return ret(decode_base64, 500072881, pos + 1 | 0, decoder);
          }
          if(47 > chr) break b;
         }
        else{if(14 > chr) break; if(32 === chr) break c; if(43 > chr) break b;
        }
        var
         v$0 = r_repr(state, chr),
         pos$0 = pos + 1 | 0,
         pos = pos$0,
         v = v$0;
       }
       if(9 !== chr){
        if(13 > chr) break b;
        decoder[4] = (decoder[4] + pos | 0) + 1 | 0;
        decoder[6] = state;
        return decode_base64_lf_after_cr(decoder);
       }
      }
      decoder[4] = (decoder[4] + pos | 0) + 1 | 0;
      decoder[6] = state;
      return ret(decode_base64, 4352180, pos + 1 | 0, decoder);
     }
     decoder[4] = (decoder[4] + pos | 0) + 1 | 0;
     decoder[6] = state;
     return ret(decode_base64, malformed(chr), pos + 1 | 0, decoder);
    }
    decoder[4] = decoder[4] + 1 | 0;
    return ret(decode_base64, malformed(chr$0), 1, decoder);
   }
   function pp_base64(decoder, v){
    if(typeof v === "number")
     return 4352180 <= v
             ? caml_call1(decoder[12], decoder)
             : (decoder[10] = 0, caml_call1(decoder[12], decoder));
    if(659980059 <= v[1]) return v;
    var state = v[2];
    decoder[6] = state;
    return [0, 365482660, caml_call1(Stdlib_Bytes[6], state[3])];
   }
   function decoder(src){
    if(typeof src === "number")
     var i_len = 0, i_pos = 1, i_off = 0, i = Stdlib_Bytes[3];
    else if(438511779 <= src[1])
     var i_len = 0, i_pos = 1, i_off = 0, i = caml_create_bytes(65536);
    else
     var
      s = src[2],
      i_len$0 = runtime.caml_ml_string_length(s) - 1 | 0,
      i$0 = caml_call1(Stdlib_Bytes[45], s),
      i_len = i_len$0,
      i_pos = 0,
      i_off = 0,
      i = i$0;
    return [0,
            src,
            i,
            i_off,
            i_pos,
            i_len,
            [0, 0, 0, caml_create_bytes(3)],
            0,
            0,
            0,
            0,
            pp_base64,
            decode_base64];
   }
   function decode(decoder){return caml_call1(decoder[12], decoder);}
   function decoder_byte_count(decoder){return decoder[9];}
   function decoder_src(decoder){return decoder[1];}
   function decoder_dangerous(decoder){return decoder[8];}
   function o_rem(encoder){return (encoder[5] - encoder[4] | 0) + 1 | 0;}
   function dst(encoder, source, off, len){
    var _D_ = off < 0 ? 1 : 0;
    if(_D_)
     var _E_ = _D_;
    else
     var
      _F_ = len < 0 ? 1 : 0,
      _E_ = _F_ || (caml_ml_bytes_length(source) < (off + len | 0) ? 1 : 0);
    if(_E_) invalid_bounds(off, len);
    encoder[2] = source;
    encoder[3] = off;
    encoder[4] = 0;
    encoder[5] = len - 1 | 0;
    return 0;
   }
   function flush(k, encoder){
    var match = encoder[1];
    if(typeof match === "number"){
     encoder[12] =
      function(encoder, param){
       if(typeof param === "number" && 1006505782 <= param)
        return caml_call1(k, encoder);
       return invalid_arg(_c_);
      };
     return 939392865;
    }
    if(438511779 <= match[1]){
     var oc = match[2];
     caml_call4(Stdlib[68], oc, encoder[2], encoder[3], encoder[4]);
     encoder[4] = 0;
     return caml_call1(k, encoder);
    }
    var b = match[2], o = caml_call1(Stdlib_Bytes[44], encoder[2]);
    caml_call4(Stdlib_Buffer[18], b, o, encoder[3], encoder[4]);
    encoder[4] = 0;
    return caml_call1(k, encoder);
   }
   function t_range(encoder, len){encoder[10] = 0; encoder[11] = len; return;}
   function t_flush(k, encoder){
    function blit(encoder, len){
     runtime.caml_blit_bytes
      (encoder[9], encoder[10], encoder[2], encoder[4], len);
     encoder[4] = encoder[4] + len | 0;
     encoder[10] = encoder[10] + len | 0;
     return;
    }
    var rem = o_rem(encoder), len = (encoder[11] - encoder[10] | 0) + 1 | 0;
    return rem < len
            ? (blit
               (encoder, rem),
              flush(function(_C_){return t_flush(k, _C_);}, encoder))
            : (blit(encoder, len), caml_call1(k, encoder));
   }
   function encode_line_break(k, encoder){
    var rem = o_rem(encoder);
    if(2 <= rem){
     var j = encoder[4];
     encoder[4] = encoder[4] + 2 | 0;
     var
      j$0 = encoder[3] + j | 0,
      s = encoder[2],
      k$0 = k,
      j$1 = j$0,
      s$0 = s;
    }
    else{
     t_range(encoder, 2);
     var
      _A_ = function(_B_){return t_flush(k, _B_);},
      k$0 = _A_,
      j$1 = 0,
      s$0 = encoder[9];
    }
    unsafe_set_chr(s$0, j$1, 13);
    unsafe_set_chr(s$0, j$1 + 1 | 0, 10);
    encoder[6] = 0;
    return caml_call1(k$0, encoder);
   }
   function encode_base64(encoder, v){
    function k$5(col_count, encoder){
     encoder[6] = encoder[6] + col_count | 0;
     encoder[12] = encode_base64;
     return 17724;
    }
    if(typeof v === "number"){
     if(1006505782 <= v) return k$5(0, encoder);
     if(76 === encoder[6])
      return encode_line_break
              (function(encoder){return encode_base64(encoder, v);}, encoder);
     var _i_ = encoder[8];
     if(2 < _i_ >>> 0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     switch(_i_){
       case 0:
        return k$5(0, encoder);
       case 1:
        var c$0 = unsafe_byte(encoder[7], 0, 0);
        encoder[8] = 0;
        var
         quantum$0 = c$0 << 4,
         c$1 = (quantum$0 >>> 6 | 0) & 63,
         d$0 = quantum$0 & 63,
         rem$0 = o_rem(encoder);
        if(4 <= rem$0){
         var j$2 = encoder[4];
         encoder[4] = encoder[4] + 4 | 0;
         var
          _j_ = 4,
          k$1 = function(_x_){return k$5(_j_, _x_);},
          j$3 = encoder[3] + j$2 | 0,
          s$1 = encoder[2],
          k$2 = k$1,
          j$4 = j$3,
          s$2 = s$1;
        }
        else{
         t_range(encoder, 4);
         var
          _k_ = 4,
          _l_ = function(_z_){return k$5(_k_, _z_);},
          _m_ = function(_y_){return t_flush(_l_, _y_);},
          k$2 = _m_,
          j$4 = 0,
          s$2 = encoder[9];
        }
        unsafe_set_chr
         (s$2, j$4, caml_string_get(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ, c$1));
        unsafe_set_chr
         (s$2,
          j$4 + 1 | 0,
          caml_string_get(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ, d$0));
        unsafe_set_chr(s$2, j$4 + 2 | 0, 61);
        unsafe_set_chr(s$2, j$4 + 3 | 0, 61);
        return flush(k$2, encoder);
       default:
        var
         c$2 = unsafe_byte(encoder[7], 0, 1),
         b$1 = unsafe_byte(encoder[7], 0, 0);
        encoder[8] = 0;
        var
         quantum$1 = (b$1 << 10) + (c$2 << 2) | 0,
         b$2 = (quantum$1 >>> 12 | 0) & 63,
         c$3 = (quantum$1 >>> 6 | 0) & 63,
         d$1 = quantum$1 & 63,
         rem$1 = o_rem(encoder);
        if(4 <= rem$1){
         var j$5 = encoder[4];
         encoder[4] = encoder[4] + 4 | 0;
         var
          _n_ = 4,
          k$3 = function(_u_){return k$5(_n_, _u_);},
          j$6 = encoder[3] + j$5 | 0,
          s$3 = encoder[2],
          k$4 = k$3,
          j$7 = j$6,
          s$4 = s$3;
        }
        else{
         t_range(encoder, 4);
         var
          _o_ = 4,
          _p_ = function(_w_){return k$5(_o_, _w_);},
          _q_ = function(_v_){return t_flush(_p_, _v_);},
          k$4 = _q_,
          j$7 = 0,
          s$4 = encoder[9];
        }
        unsafe_set_chr
         (s$4, j$7, caml_string_get(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ, b$2));
        unsafe_set_chr
         (s$4,
          j$7 + 1 | 0,
          caml_string_get(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ, c$3));
        unsafe_set_chr
         (s$4,
          j$7 + 2 | 0,
          caml_string_get(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ, d$1));
        unsafe_set_chr(s$4, j$7 + 3 | 0, 61);
        return flush(k$4, encoder);
     }
    }
    var chr = v[2], rem$2 = o_rem(encoder);
    if(1 > rem$2)
     return flush
             (function(encoder){return encode_base64(encoder, v);}, encoder);
    if(76 === encoder[6])
     return encode_line_break
             (function(encoder){return encode_base64(encoder, v);}, encoder);
    if(2 > encoder[8]){
     unsafe_set_chr(encoder[7], encoder[8], chr);
     encoder[8] = encoder[8] + 1 | 0;
     return k$5(0, encoder);
    }
    var b = unsafe_byte(encoder[7], 0, 1), a = unsafe_byte(encoder[7], 0, 0);
    encoder[8] = 0;
    var
     quantum = ((a << 16) + (b << 8) | 0) + chr | 0,
     a$0 = quantum >>> 18 | 0,
     b$0 = (quantum >>> 12 | 0) & 63,
     c = (quantum >>> 6 | 0) & 63,
     d = quantum & 63,
     rem = o_rem(encoder);
    if(4 <= rem){
     var j = encoder[4];
     encoder[4] = encoder[4] + 4 | 0;
     var
      _e_ = 4,
      k = function(_r_){return k$5(_e_, _r_);},
      j$0 = encoder[3] + j | 0,
      s = encoder[2],
      k$0 = k,
      j$1 = j$0,
      s$0 = s;
    }
    else{
     t_range(encoder, 4);
     var
      _f_ = 4,
      _g_ = function(_t_){return k$5(_f_, _t_);},
      _h_ = function(_s_){return t_flush(_g_, _s_);},
      k$0 = _h_,
      j$1 = 0,
      s$0 = encoder[9];
    }
    unsafe_set_chr
     (s$0, j$1, caml_string_get(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ, a$0));
    unsafe_set_chr
     (s$0, j$1 + 1 | 0, caml_string_get(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ, b$0));
    unsafe_set_chr
     (s$0, j$1 + 2 | 0, caml_string_get(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ, c));
    unsafe_set_chr
     (s$0, j$1 + 3 | 0, caml_string_get(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ, d));
    return flush(k$0, encoder);
   }
   function encoder(dst){
    if(typeof dst === "number")
     var o_len = 0, o_pos = 0, o_off = 1, o = Stdlib_Bytes[3];
    else
     var
      o$0 = caml_create_bytes(65536),
      o_len = 65535,
      o_pos = 0,
      o_off = 0,
      o = o$0;
    return [0,
            dst,
            o,
            o_off,
            o_pos,
            o_len,
            0,
            caml_create_bytes(3),
            0,
            caml_create_bytes(4),
            1,
            0,
            encode_base64];
   }
   function encode(encoder){return caml_call1(encoder[12], encoder);}
   function encoder_dst(encoder){return encoder[1];}
   var
    Base64_rfc2045 =
      [0,
       default_alphabet,
       src,
       decoder,
       decode,
       decoder_byte_count,
       decoder_src,
       decoder_dangerous,
       encoder,
       encode,
       encoder_dst,
       dst,
       o_rem];
   runtime.caml_register_global(12, Base64_rfc2045, "Base64_rfc2045");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlNjRfcmZjMjA0NS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZGVmYXVsdF9hbHBoYWJldCIsImludmFsaWRfYXJnIiwiZm10IiwicyIsImludmFsaWRfYm91bmRzIiwib2ZmIiwibGVuIiwibWFsZm9ybWVkIiwiY2hyIiwidW5zYWZlX2J5dGUiLCJzb3VyY2UiLCJwb3MiLCJ1bnNhZmVfc2V0X2NociIsImNvbnRpbnVlJDAiLCJzdGF0ZSIsInNpemUiLCJxdWFudHVtIiwicl9yZXByIiwiY29kZSIsImlfcmVtIiwiZGVjb2RlciIsImVuZF9vZl9pbnB1dCIsInNyYyIsInJlZmlsbCIsImsiLCJpYyIsInJldCIsInYiLCJieXRlX2NvdW50IiwiZGVjb2RlX2Jhc2U2NF9sZl9hZnRlcl9jciIsInJlbSIsImRlY29kZV9iYXNlNjQiLCJidWZmZXIiLCJxdWFudHVtJDAiLCJxdWFudHVtJDEiLCJwYWRkaW5nIiwiY2hyJDAiLCJwcF9iYXNlNjQiLCJpX2xlbiIsImlfcG9zIiwiaV9vZmYiLCJpIiwiaV9sZW4kMCIsImkkMCIsImRlY29kZSIsImRlY29kZXJfYnl0ZV9jb3VudCIsImRlY29kZXJfc3JjIiwiZGVjb2Rlcl9kYW5nZXJvdXMiLCJvX3JlbSIsImVuY29kZXIiLCJkc3QiLCJmbHVzaCIsIm9jIiwiYiIsIm8iLCJ0X3JhbmdlIiwidF9mbHVzaCIsImJsaXQiLCJlbmNvZGVfbGluZV9icmVhayIsImoiLCJqJDAiLCJrJDAiLCJqJDEiLCJzJDAiLCJlbmNvZGVfYmFzZTY0IiwiayQ1IiwiY29sX2NvdW50IiwiYyQwIiwiYyQxIiwiZCQwIiwicmVtJDAiLCJqJDIiLCJrJDEiLCJqJDMiLCJzJDEiLCJrJDIiLCJqJDQiLCJzJDIiLCJjJDIiLCJiJDEiLCJiJDIiLCJjJDMiLCJkJDEiLCJyZW0kMSIsImokNSIsImskMyIsImokNiIsInMkMyIsImskNCIsImokNyIsInMkNCIsInJlbSQyIiwiYSIsImEkMCIsImIkMCIsImMiLCJkIiwib19sZW4iLCJvX3BvcyIsIm9fb2ZmIiwibyQwIiwiZW5jb2RlIiwiZW5jb2Rlcl9kc3QiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9iYXNlNjQvcmZjMjA0NS9iYXNlNjRfcmZjMjA0NS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lBaUJJQTs7Ozs7Ozs7Ozs7Ozs7OztZQUtBQyxZQUFZQztpQkFBMkJDLEdBQUssT0FBQSxzQkFBTEEsR0FBa0I7SUFBdkMsT0FBQSxvQ0FBTkQ7R0FBa0Q7WUFFOURFLGVBQWVDLEtBQUlDO0lBQ3JCLE9BQUEsV0FIRUwsa0JBRWVJLEtBQUlDO0dBQ2tDO1lBRXJEQyxVQUFVQztJQUFNLHNCQUFXLGdDQUFqQkE7R0FBb0M7WUFFOUNDLFlBQVlDLFFBQU9MLEtBQUlNO0lBQU0scUNBQWpCRCxRQUFPTCxNQUFJTTtHQUF5QztZQU1oRUMsZUFBZUYsUUFBT0wsS0FBSUc7SUFBTSw4QkFBakJFLFFBQU9MLEtBQUlHOztHQUFxQztZQUkvREssV0FBU0M7UUFBZ0JDLGlCQUFUQztJQUFpQiwwQkFBakJBLFNBQVNELE1BQWhCRDs7WUFPVEcsT0FBT0gsT0FBZ0NOO0lBR3BCO0tBSEFPLE9BQVpEO0tBQUdFLFVBQUhGO0tBR0xJO09BQWlCOztTQUhvQlY7SUFJekMsT0FKcUJPLFlBY2QsT0FqQ0xSLFVBbUJ1Q0M7V0FBcEJPOztPQUtDLE9BWnBCRixXQU9PQyxXQUdMSTs7T0FHa0IsT0FicEJMLFdBT09DLFdBQUdFLGVBR1JFOztPQUlrQixPQWRwQkwsV0FPT0MsV0FBR0UsZUFHUkU7O09BZEZOLGVBV09FLGNBQUdFO09BWFZKLGVBV09FLGNBQUdFO09BWFZKLGVBV09FLGNBQUdFLGVBR1JFO09BUlksZ0NBS1BKOzs7WUF1Q1BLLE1BQU1DLFNBQVUsUUFBVkEsYUFBQUEsd0JBQTJDO1lBRWpEQyxhQUFhRDtJQUFBQTtJQUFBQTtJQUFBQTtJQUFBQTs7R0FJ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dUJBd0I7T0FFQUM7T0FFQUM7T0FFQUM7T0E0TEFFO09BcUJBb0Q7T0FFQUM7T0F4TEFwRDtPQUZBRjs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IFJvbWFpbiBDYWxhc2NpYmV0dGEgPHJvbWFpbi5jYWxhc2NpYmV0dGFAZ21haWwuY29tPlxuICpcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZCBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuICogV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1JcbiAqIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbiAqIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuICogQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0ZcbiAqIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gKlxuICopXG5cbmxldCBkZWZhdWx0X2FscGhhYmV0ID1cbiAgXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCJcblxubGV0IGlvX2J1ZmZlcl9zaXplID0gNjU1MzZcblxubGV0IGludmFsaWRfYXJnIGZtdCA9IEZvcm1hdC5rc3ByaW50ZiAoZnVuIHMgLT4gaW52YWxpZF9hcmcgcykgZm10XG5cbmxldCBpbnZhbGlkX2JvdW5kcyBvZmYgbGVuID1cbiAgaW52YWxpZF9hcmcgXCJJbnZhbGlkIGJvdW5kcyAob2ZmOiAlZCwgbGVuOiAlZClcIiBvZmYgbGVuXG5cbmxldCBtYWxmb3JtZWQgY2hyID0gYE1hbGZvcm1lZCAoU3RyaW5nLm1ha2UgMSBjaHIpXG5cbmxldCB1bnNhZmVfYnl0ZSBzb3VyY2Ugb2ZmIHBvcyA9IEJ5dGVzLnVuc2FmZV9nZXQgc291cmNlIChvZmYgKyBwb3MpXG5cbmxldCB1bnNhZmVfYmxpdCA9IEJ5dGVzLnVuc2FmZV9ibGl0XG5cbmxldCB1bnNhZmVfY2hyID0gQ2hhci51bnNhZmVfY2hyXG5cbmxldCB1bnNhZmVfc2V0X2NociBzb3VyY2Ugb2ZmIGNociA9IEJ5dGVzLnVuc2FmZV9zZXQgc291cmNlIG9mZiBjaHJcblxudHlwZSBzdGF0ZSA9IHsgcXVhbnR1bSA6IGludDsgc2l6ZSA6IGludDsgYnVmZmVyIDogQnl0ZXMudCB9XG5cbmxldCBjb250aW51ZSBzdGF0ZSAocXVhbnR1bSwgc2l6ZSkgPSBgQ29udGludWUgeyBzdGF0ZSB3aXRoIHF1YW50dW07IHNpemUgfVxuXG5sZXQgZmx1c2ggc3RhdGUgPSBgRmx1c2ggeyBzdGF0ZSB3aXRoIHF1YW50dW0gPSAwOyBzaXplID0gMCB9XG5cbmxldCB0YWJsZSA9XG4gIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2MlxcMjU1XFwyNTVcXDI1NVxcMDYzXFwwNTJcXDA1M1xcMDU0XFwwNTVcXDA1NlxcMDU3XFwwNThcXDA1OVxcMDYwXFwwNjFcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDFcXDAwMlxcMDAzXFwwMDRcXDAwNVxcMDA2XFwwMDdcXDAwOFxcMDA5XFwwMTBcXDAxMVxcMDEyXFwwMTNcXDAxNFxcMDE1XFwwMTZcXDAxN1xcMDE4XFwwMTlcXDAyMFxcMDIxXFwwMjJcXDAyM1xcMDI0XFwwMjVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAyNlxcMDI3XFwwMjhcXDAyOVxcMDMwXFwwMzFcXDAzMlxcMDMzXFwwMzRcXDAzNVxcMDM2XFwwMzdcXDAzOFxcMDM5XFwwNDBcXDA0MVxcMDQyXFwwNDNcXDA0NFxcMDQ1XFwwNDZcXDA0N1xcMDQ4XFwwNDlcXDA1MFxcMDUxXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVwiXG5cbmxldCByX3JlcHIgKHsgcXVhbnR1bTsgc2l6ZTsgXyB9IGFzIHN0YXRlKSBjaHIgPVxuICAoKiBhc3NlcnQgKDAgPD0gb2ZmICYmIDAgPD0gbGVuICYmIG9mZiArIGxlbiA8PSBTdHJpbmcubGVuZ3RoIHNvdXJjZSk7ICopXG4gICgqIGFzc2VydCAobGVuID49IDEpOyAqKVxuICBsZXQgY29kZSA9IENoYXIuY29kZSB0YWJsZS5bQ2hhci5jb2RlIGNocl0gaW5cbiAgbWF0Y2ggc2l6ZSB3aXRoXG4gIHwgMCAtPiBjb250aW51ZSBzdGF0ZSAoY29kZSwgMSlcbiAgfCAxIC0+IGNvbnRpbnVlIHN0YXRlICgocXVhbnR1bSBsc2wgNikgbG9yIGNvZGUsIDIpXG4gIHwgMiAtPiBjb250aW51ZSBzdGF0ZSAoKHF1YW50dW0gbHNsIDYpIGxvciBjb2RlLCAzKVxuICB8IDMgLT5cbiAgICAgIHVuc2FmZV9zZXRfY2hyIHN0YXRlLmJ1ZmZlciAwICh1bnNhZmVfY2hyICgocXVhbnR1bSBsc3IgMTApIGxhbmQgMjU1KSkgO1xuICAgICAgdW5zYWZlX3NldF9jaHIgc3RhdGUuYnVmZmVyIDEgKHVuc2FmZV9jaHIgKChxdWFudHVtIGxzciAyKSBsYW5kIDI1NSkpIDtcbiAgICAgIHVuc2FmZV9zZXRfY2hyIHN0YXRlLmJ1ZmZlciAyXG4gICAgICAgICh1bnNhZmVfY2hyICgocXVhbnR1bSBsc2wgNikgbG9yIGNvZGUgbGFuZCAyNTUpKSA7XG4gICAgICBmbHVzaCBzdGF0ZVxuICB8IF8gLT4gbWFsZm9ybWVkIGNoclxuXG50eXBlIHNyYyA9IFsgYENoYW5uZWwgb2YgaW5fY2hhbm5lbCB8IGBTdHJpbmcgb2Ygc3RyaW5nIHwgYE1hbnVhbCBdXG5cbnR5cGUgZGVjb2RlID1cbiAgWyBgQXdhaXQgfCBgRW5kIHwgYFdyb25nX3BhZGRpbmcgfCBgTWFsZm9ybWVkIG9mIHN0cmluZyB8IGBGbHVzaCBvZiBzdHJpbmcgXVxuXG50eXBlIGlucHV0ID1cbiAgWyBgTGluZV9icmVhayB8IGBXc3AgfCBgUGFkZGluZyB8IGBNYWxmb3JtZWQgb2Ygc3RyaW5nIHwgYEZsdXNoIG9mIHN0YXRlIF1cblxudHlwZSBkZWNvZGVyID0ge1xuICBzcmMgOiBzcmM7XG4gIG11dGFibGUgaSA6IEJ5dGVzLnQ7XG4gIG11dGFibGUgaV9vZmYgOiBpbnQ7XG4gIG11dGFibGUgaV9wb3MgOiBpbnQ7XG4gIG11dGFibGUgaV9sZW4gOiBpbnQ7XG4gIG11dGFibGUgcyA6IHN0YXRlO1xuICBtdXRhYmxlIHBhZGRpbmcgOiBpbnQ7XG4gIG11dGFibGUgdW5zYWZlIDogYm9vbDtcbiAgbXV0YWJsZSBieXRlX2NvdW50IDogaW50O1xuICBtdXRhYmxlIGxpbWl0X2NvdW50IDogaW50O1xuICBtdXRhYmxlIHBwIDogZGVjb2RlciAtPiBpbnB1dCAtPiBkZWNvZGU7XG4gIG11dGFibGUgayA6IGRlY29kZXIgLT4gZGVjb2RlO1xufVxuXG5sZXQgaV9yZW0gZGVjb2RlciA9IGRlY29kZXIuaV9sZW4gLSBkZWNvZGVyLmlfcG9zICsgMVxuXG5sZXQgZW5kX29mX2lucHV0IGRlY29kZXIgPVxuICBkZWNvZGVyLmkgPC0gQnl0ZXMuZW1wdHkgO1xuICBkZWNvZGVyLmlfb2ZmIDwtIDAgO1xuICBkZWNvZGVyLmlfcG9zIDwtIDAgO1xuICBkZWNvZGVyLmlfbGVuIDwtIG1pbl9pbnRcblxubGV0IHNyYyBkZWNvZGVyIHNvdXJjZSBvZmYgbGVuID1cbiAgaWYgb2ZmIDwgMCB8fCBsZW4gPCAwIHx8IG9mZiArIGxlbiA+IEJ5dGVzLmxlbmd0aCBzb3VyY2VcbiAgdGhlbiBpbnZhbGlkX2JvdW5kcyBvZmYgbGVuXG4gIGVsc2UgaWYgbGVuID0gMFxuICB0aGVuIGVuZF9vZl9pbnB1dCBkZWNvZGVyXG4gIGVsc2UgKFxuICAgIGRlY29kZXIuaSA8LSBzb3VyY2UgO1xuICAgIGRlY29kZXIuaV9vZmYgPC0gb2ZmIDtcbiAgICBkZWNvZGVyLmlfcG9zIDwtIDAgO1xuICAgIGRlY29kZXIuaV9sZW4gPC0gbGVuIC0gMSlcblxubGV0IHJlZmlsbCBrIGRlY29kZXIgPVxuICBtYXRjaCBkZWNvZGVyLnNyYyB3aXRoXG4gIHwgYE1hbnVhbCAtPlxuICAgICAgZGVjb2Rlci5rIDwtIGsgO1xuICAgICAgYEF3YWl0XG4gIHwgYFN0cmluZyBfIC0+XG4gICAgICBlbmRfb2ZfaW5wdXQgZGVjb2RlciA7XG4gICAgICBrIGRlY29kZXJcbiAgfCBgQ2hhbm5lbCBpYyAtPlxuICAgICAgbGV0IGxlbiA9IGlucHV0IGljIGRlY29kZXIuaSAwIChCeXRlcy5sZW5ndGggZGVjb2Rlci5pKSBpblxuICAgICAgc3JjIGRlY29kZXIgZGVjb2Rlci5pIDAgbGVuIDtcbiAgICAgIGsgZGVjb2RlclxuXG5sZXQgZGFuZ2Vyb3VzIGRlY29kZXIgdiA9IGRlY29kZXIudW5zYWZlIDwtIHZcblxubGV0IHJlc2V0IGRlY29kZXIgPSBkZWNvZGVyLmxpbWl0X2NvdW50IDwtIDBcblxubGV0IHJldCBrIHYgYnl0ZV9jb3VudCBkZWNvZGVyID1cbiAgZGVjb2Rlci5rIDwtIGsgO1xuICBkZWNvZGVyLmJ5dGVfY291bnQgPC0gZGVjb2Rlci5ieXRlX2NvdW50ICsgYnl0ZV9jb3VudCA7XG4gIGRlY29kZXIubGltaXRfY291bnQgPC0gZGVjb2Rlci5saW1pdF9jb3VudCArIGJ5dGVfY291bnQgO1xuICBpZiBkZWNvZGVyLmxpbWl0X2NvdW50ID4gNzggdGhlbiBkYW5nZXJvdXMgZGVjb2RlciB0cnVlIDtcbiAgZGVjb2Rlci5wcCBkZWNvZGVyIHZcblxudHlwZSBmbHVzaF9hbmRfbWFsZm9ybWVkID0gWyBgRmx1c2ggb2Ygc3RhdGUgfCBgTWFsZm9ybWVkIG9mIHN0cmluZyBdXG5cbmxldCBwYWRkaW5nIHsgc2l6ZTsgXyB9IHBhZGRpbmcgPVxuICBtYXRjaCAoc2l6ZSwgcGFkZGluZykgd2l0aFxuICB8IDAsIDAgLT4gdHJ1ZVxuICB8IDEsIF8gLT4gZmFsc2VcbiAgfCAyLCAyIC0+IHRydWVcbiAgfCAzLCAxIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0X2ZsdXNoIHsgcXVhbnR1bTsgc2l6ZTsgYnVmZmVyIH0gPVxuICBtYXRjaCBzaXplIHdpdGhcbiAgfCAwIHwgMSAtPiBgRmx1c2ggeyBxdWFudHVtOyBzaXplOyBidWZmZXIgPSBCeXRlcy5lbXB0eSB9XG4gIHwgMiAtPlxuICAgICAgbGV0IHF1YW50dW0gPSBxdWFudHVtIGxzciA0IGluXG4gICAgICBgRmx1c2hcbiAgICAgICAgeyBxdWFudHVtOyBzaXplOyBidWZmZXIgPSBCeXRlcy5tYWtlIDEgKHVuc2FmZV9jaHIgKHF1YW50dW0gbGFuZCAyNTUpKSB9XG4gIHwgMyAtPlxuICAgICAgbGV0IHF1YW50dW0gPSBxdWFudHVtIGxzciAyIGluXG4gICAgICB1bnNhZmVfc2V0X2NociBidWZmZXIgMCAodW5zYWZlX2NociAoKHF1YW50dW0gbHNyIDgpIGxhbmQgMjU1KSkgO1xuICAgICAgdW5zYWZlX3NldF9jaHIgYnVmZmVyIDEgKHVuc2FmZV9jaHIgKHF1YW50dW0gbGFuZCAyNTUpKSA7XG4gICAgICBgRmx1c2ggeyBxdWFudHVtOyBzaXplOyBidWZmZXIgPSBCeXRlcy5zdWIgYnVmZmVyIDAgMiB9XG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuKCogdGhpcyBicmFuY2ggaXMgaW1wb3NzaWJsZSwgc2l6ZSBjYW4gb25seSBldmVyIGJlIGluIHRoZSByYW5nZSBbMC4uM10uICopXG5cbmxldCB3cm9uZ19wYWRkaW5nIGRlY29kZXIgPVxuICBsZXQgayBfID0gYEVuZCBpblxuICBkZWNvZGVyLmsgPC0gayA7XG4gIGBXcm9uZ19wYWRkaW5nXG5cbmxldCByZWMgdF9kZWNvZGVfYmFzZTY0IGNociBkZWNvZGVyID1cbiAgaWYgZGVjb2Rlci5wYWRkaW5nID0gMFxuICB0aGVuXG4gICAgbGV0IHJlYyBnbyBwb3MgPSBmdW5jdGlvblxuICAgICAgfCBgQ29udGludWUgc3RhdGUgLT5cbiAgICAgICAgICBpZiBkZWNvZGVyLmlfbGVuIC0gKGRlY29kZXIuaV9wb3MgKyBwb3MpICsgMSA+IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIG1hdGNoIHVuc2FmZV9ieXRlIGRlY29kZXIuaSBkZWNvZGVyLmlfb2ZmIChkZWNvZGVyLmlfcG9zICsgcG9zKSB3aXRoXG4gICAgICAgICAgICB8ICgnQScgLi4gJ1onIHwgJ2EnIC4uICd6JyB8ICcwJyAuLiAnOScgfCAnKycgfCAnLycpIGFzIGNociAtPlxuICAgICAgICAgICAgICAgIGdvIChzdWNjIHBvcykgKHJfcmVwciBzdGF0ZSBjaHIpXG4gICAgICAgICAgICB8ICc9JyAtPlxuICAgICAgICAgICAgICAgIGRlY29kZXIucGFkZGluZyA8LSBkZWNvZGVyLnBhZGRpbmcgKyAxIDtcbiAgICAgICAgICAgICAgICBkZWNvZGVyLmlfcG9zIDwtIGRlY29kZXIuaV9wb3MgKyBwb3MgKyAxIDtcbiAgICAgICAgICAgICAgICBkZWNvZGVyLnMgPC0gc3RhdGUgO1xuICAgICAgICAgICAgICAgIHJldCBkZWNvZGVfYmFzZTY0IGBQYWRkaW5nIChwb3MgKyAxKSBkZWNvZGVyXG4gICAgICAgICAgICB8ICcgJyB8ICdcXHQnIC0+XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5pX3BvcyA8LSBkZWNvZGVyLmlfcG9zICsgcG9zICsgMSA7XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5zIDwtIHN0YXRlIDtcbiAgICAgICAgICAgICAgICByZXQgZGVjb2RlX2Jhc2U2NCBgV3NwIChwb3MgKyAxKSBkZWNvZGVyXG4gICAgICAgICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5pX3BvcyA8LSBkZWNvZGVyLmlfcG9zICsgcG9zICsgMSA7XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5zIDwtIHN0YXRlIDtcbiAgICAgICAgICAgICAgICBkZWNvZGVfYmFzZTY0X2xmX2FmdGVyX2NyIGRlY29kZXJcbiAgICAgICAgICAgIHwgY2hyIC0+XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5pX3BvcyA8LSBkZWNvZGVyLmlfcG9zICsgcG9zICsgMSA7XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5zIDwtIHN0YXRlIDtcbiAgICAgICAgICAgICAgICByZXQgZGVjb2RlX2Jhc2U2NCAobWFsZm9ybWVkIGNocikgKHBvcyArIDEpIGRlY29kZXIpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBkZWNvZGVyLmlfcG9zIDwtIGRlY29kZXIuaV9wb3MgKyBwb3MgO1xuICAgICAgICAgICAgZGVjb2Rlci5ieXRlX2NvdW50IDwtIGRlY29kZXIuYnl0ZV9jb3VudCArIHBvcyA7XG4gICAgICAgICAgICBkZWNvZGVyLmxpbWl0X2NvdW50IDwtIGRlY29kZXIubGltaXRfY291bnQgKyBwb3MgO1xuICAgICAgICAgICAgZGVjb2Rlci5zIDwtIHN0YXRlIDtcbiAgICAgICAgICAgIHJlZmlsbCBkZWNvZGVfYmFzZTY0IGRlY29kZXIpXG4gICAgICB8ICNmbHVzaF9hbmRfbWFsZm9ybWVkIGFzIHYgLT5cbiAgICAgICAgICBkZWNvZGVyLmlfcG9zIDwtIGRlY29kZXIuaV9wb3MgKyBwb3MgO1xuICAgICAgICAgIHJldCBkZWNvZGVfYmFzZTY0IHYgcG9zIGRlY29kZXIgaW5cbiAgICBnbyAxIChyX3JlcHIgZGVjb2Rlci5zIGNocilcbiAgZWxzZSAoXG4gICAgZGVjb2Rlci5pX3BvcyA8LSBkZWNvZGVyLmlfcG9zICsgMSA7XG4gICAgcmV0IGRlY29kZV9iYXNlNjQgKG1hbGZvcm1lZCBjaHIpIDEgZGVjb2RlcilcblxuYW5kIGRlY29kZV9iYXNlNjRfbGZfYWZ0ZXJfY3IgZGVjb2RlciA9XG4gIGxldCByZW0gPSBpX3JlbSBkZWNvZGVyIGluXG4gIGlmIHJlbSA8IDBcbiAgdGhlbiByZXQgZGVjb2RlX2Jhc2U2NCAobWFsZm9ybWVkICdcXHInKSAxIGRlY29kZXJcbiAgZWxzZSBpZiByZW0gPSAwXG4gIHRoZW4gcmVmaWxsIGRlY29kZV9iYXNlNjRfbGZfYWZ0ZXJfY3IgZGVjb2RlclxuICBlbHNlXG4gICAgbWF0Y2ggdW5zYWZlX2J5dGUgZGVjb2Rlci5pIGRlY29kZXIuaV9vZmYgZGVjb2Rlci5pX3BvcyB3aXRoXG4gICAgfCAnXFxuJyAtPlxuICAgICAgICBkZWNvZGVyLmlfcG9zIDwtIGRlY29kZXIuaV9wb3MgKyAxIDtcbiAgICAgICAgcmV0IGRlY29kZV9iYXNlNjQgYExpbmVfYnJlYWsgMiBkZWNvZGVyXG4gICAgfCBfIC0+IHJldCBkZWNvZGVfYmFzZTY0IChtYWxmb3JtZWQgJ1xccicpIDEgZGVjb2RlclxuXG5hbmQgZGVjb2RlX2Jhc2U2NCBkZWNvZGVyID1cbiAgbGV0IHJlbSA9IGlfcmVtIGRlY29kZXIgaW5cbiAgaWYgcmVtIDw9IDBcbiAgdGhlblxuICAgIGlmIHJlbSA8IDBcbiAgICB0aGVuXG4gICAgICByZXRcbiAgICAgICAgKGZ1biBkZWNvZGVyIC0+XG4gICAgICAgICAgaWYgcGFkZGluZyBkZWNvZGVyLnMgZGVjb2Rlci5wYWRkaW5nXG4gICAgICAgICAgdGhlbiBgRW5kXG4gICAgICAgICAgZWxzZSB3cm9uZ19wYWRkaW5nIGRlY29kZXIpXG4gICAgICAgICh0X2ZsdXNoIGRlY29kZXIucykgMCBkZWNvZGVyXG4gICAgZWxzZSByZWZpbGwgZGVjb2RlX2Jhc2U2NCBkZWNvZGVyXG4gIGVsc2VcbiAgICBtYXRjaCB1bnNhZmVfYnl0ZSBkZWNvZGVyLmkgZGVjb2Rlci5pX29mZiBkZWNvZGVyLmlfcG9zIHdpdGhcbiAgICB8ICgnQScgLi4gJ1onIHwgJ2EnIC4uICd6JyB8ICcwJyAuLiAnOScgfCAnKycgfCAnLycpIGFzIGNociAtPlxuICAgICAgICB0X2RlY29kZV9iYXNlNjQgY2hyIGRlY29kZXJcbiAgICB8ICc9JyAtPlxuICAgICAgICBkZWNvZGVyLnBhZGRpbmcgPC0gZGVjb2Rlci5wYWRkaW5nICsgMSA7XG4gICAgICAgIGRlY29kZXIuaV9wb3MgPC0gZGVjb2Rlci5pX3BvcyArIDEgO1xuICAgICAgICByZXQgZGVjb2RlX2Jhc2U2NCBgUGFkZGluZyAxIGRlY29kZXJcbiAgICB8ICcgJyB8ICdcXHQnIC0+XG4gICAgICAgIGRlY29kZXIuaV9wb3MgPC0gZGVjb2Rlci5pX3BvcyArIDEgO1xuICAgICAgICByZXQgZGVjb2RlX2Jhc2U2NCBgV3NwIDEgZGVjb2RlclxuICAgIHwgJ1xccicgLT5cbiAgICAgICAgZGVjb2Rlci5pX3BvcyA8LSBkZWNvZGVyLmlfcG9zICsgMSA7XG4gICAgICAgIGRlY29kZV9iYXNlNjRfbGZfYWZ0ZXJfY3IgZGVjb2RlclxuICAgIHwgY2hyIC0+XG4gICAgICAgIGRlY29kZXIuaV9wb3MgPC0gZGVjb2Rlci5pX3BvcyArIDEgO1xuICAgICAgICByZXQgZGVjb2RlX2Jhc2U2NCAobWFsZm9ybWVkIGNocikgMSBkZWNvZGVyXG5cbmxldCBwcF9iYXNlNjQgZGVjb2RlciA9IGZ1bmN0aW9uXG4gIHwgYExpbmVfYnJlYWsgLT5cbiAgICAgIHJlc2V0IGRlY29kZXIgO1xuICAgICAgZGVjb2Rlci5rIGRlY29kZXJcbiAgfCBgV3NwIHwgYFBhZGRpbmcgLT4gZGVjb2Rlci5rIGRlY29kZXJcbiAgfCBgRmx1c2ggc3RhdGUgLT5cbiAgICAgIGRlY29kZXIucyA8LSBzdGF0ZSA7XG4gICAgICBgRmx1c2ggKEJ5dGVzLnRvX3N0cmluZyBzdGF0ZS5idWZmZXIpXG4gIHwgYE1hbGZvcm1lZCBfIGFzIHYgLT4gdlxuXG5sZXQgZGVjb2RlciBzcmMgPVxuICBsZXQgcHAgPSBwcF9iYXNlNjQgaW5cbiAgbGV0IGsgPSBkZWNvZGVfYmFzZTY0IGluXG4gIGxldCBpLCBpX29mZiwgaV9wb3MsIGlfbGVuID1cbiAgICBtYXRjaCBzcmMgd2l0aFxuICAgIHwgYE1hbnVhbCAtPiAoQnl0ZXMuZW1wdHksIDAsIDEsIDApXG4gICAgfCBgQ2hhbm5lbCBfIC0+IChCeXRlcy5jcmVhdGUgaW9fYnVmZmVyX3NpemUsIDAsIDEsIDApXG4gICAgfCBgU3RyaW5nIHMgLT4gKEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgcywgMCwgMCwgU3RyaW5nLmxlbmd0aCBzIC0gMSkgaW5cbiAge1xuICAgIHNyYztcbiAgICBpX29mZjtcbiAgICBpX3BvcztcbiAgICBpX2xlbjtcbiAgICBpO1xuICAgIHMgPSB7IHF1YW50dW0gPSAwOyBzaXplID0gMDsgYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDMgfTtcbiAgICBwYWRkaW5nID0gMDtcbiAgICB1bnNhZmUgPSBmYWxzZTtcbiAgICBieXRlX2NvdW50ID0gMDtcbiAgICBsaW1pdF9jb3VudCA9IDA7XG4gICAgcHA7XG4gICAgaztcbiAgfVxuXG5sZXQgZGVjb2RlIGRlY29kZXIgPSBkZWNvZGVyLmsgZGVjb2RlclxuXG5sZXQgZGVjb2Rlcl9ieXRlX2NvdW50IGRlY29kZXIgPSBkZWNvZGVyLmJ5dGVfY291bnRcblxubGV0IGRlY29kZXJfc3JjIGRlY29kZXIgPSBkZWNvZGVyLnNyY1xuXG5sZXQgZGVjb2Rlcl9kYW5nZXJvdXMgZGVjb2RlciA9IGRlY29kZXIudW5zYWZlXG5cbigqIC8gKilcblxubGV0IGludmFsaWRfZW5jb2RlICgpID0gaW52YWxpZF9hcmcgXCJFeHBlY3RlZCBgQXdhaXQgZW5jb2RlXCJcblxudHlwZSBkc3QgPSBbIGBDaGFubmVsIG9mIG91dF9jaGFubmVsIHwgYEJ1ZmZlciBvZiBCdWZmZXIudCB8IGBNYW51YWwgXVxuXG50eXBlIGVuY29kZSA9IFsgYEF3YWl0IHwgYEVuZCB8IGBDaGFyIG9mIGNoYXIgXVxuXG50eXBlIGVuY29kZXIgPSB7XG4gIGRzdCA6IGRzdDtcbiAgbXV0YWJsZSBvIDogQnl0ZXMudDtcbiAgbXV0YWJsZSBvX29mZiA6IGludDtcbiAgbXV0YWJsZSBvX3BvcyA6IGludDtcbiAgbXV0YWJsZSBvX2xlbiA6IGludDtcbiAgbXV0YWJsZSBjX2NvbCA6IGludDtcbiAgaSA6IEJ5dGVzLnQ7XG4gIG11dGFibGUgcyA6IGludDtcbiAgdCA6IEJ5dGVzLnQ7XG4gIG11dGFibGUgdF9wb3MgOiBpbnQ7XG4gIG11dGFibGUgdF9sZW4gOiBpbnQ7XG4gIG11dGFibGUgayA6IGVuY29kZXIgLT4gZW5jb2RlIC0+IFsgYE9rIHwgYFBhcnRpYWwgXTtcbn1cblxubGV0IG9fcmVtIGVuY29kZXIgPSBlbmNvZGVyLm9fbGVuIC0gZW5jb2Rlci5vX3BvcyArIDFcblxubGV0IGRzdCBlbmNvZGVyIHNvdXJjZSBvZmYgbGVuID1cbiAgaWYgb2ZmIDwgMCB8fCBsZW4gPCAwIHx8IG9mZiArIGxlbiA+IEJ5dGVzLmxlbmd0aCBzb3VyY2VcbiAgdGhlbiBpbnZhbGlkX2JvdW5kcyBvZmYgbGVuIDtcbiAgZW5jb2Rlci5vIDwtIHNvdXJjZSA7XG4gIGVuY29kZXIub19vZmYgPC0gb2ZmIDtcbiAgZW5jb2Rlci5vX3BvcyA8LSAwIDtcbiAgZW5jb2Rlci5vX2xlbiA8LSBsZW4gLSAxXG5cbmxldCBkc3RfcmVtID0gb19yZW1cblxubGV0IHBhcnRpYWwgayBlbmNvZGVyID0gZnVuY3Rpb25cbiAgfCBgQXdhaXQgLT4gayBlbmNvZGVyXG4gIHwgYENoYXIgXyB8IGBFbmQgLT4gaW52YWxpZF9lbmNvZGUgKClcblxubGV0IGZsdXNoIGsgZW5jb2RlciA9XG4gIG1hdGNoIGVuY29kZXIuZHN0IHdpdGhcbiAgfCBgTWFudWFsIC0+XG4gICAgICBlbmNvZGVyLmsgPC0gcGFydGlhbCBrIDtcbiAgICAgIGBQYXJ0aWFsXG4gIHwgYENoYW5uZWwgb2MgLT5cbiAgICAgIG91dHB1dCBvYyBlbmNvZGVyLm8gZW5jb2Rlci5vX29mZiBlbmNvZGVyLm9fcG9zIDtcbiAgICAgIGVuY29kZXIub19wb3MgPC0gMCA7XG4gICAgICBrIGVuY29kZXJcbiAgfCBgQnVmZmVyIGIgLT5cbiAgICAgIGxldCBvID0gQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBlbmNvZGVyLm8gaW5cbiAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIgbyBlbmNvZGVyLm9fb2ZmIGVuY29kZXIub19wb3MgO1xuICAgICAgZW5jb2Rlci5vX3BvcyA8LSAwIDtcbiAgICAgIGsgZW5jb2RlclxuXG5sZXQgdF9yYW5nZSBlbmNvZGVyIGxlbiA9XG4gIGVuY29kZXIudF9wb3MgPC0gMCA7XG4gIGVuY29kZXIudF9sZW4gPC0gbGVuXG5cbmxldCByZWMgdF9mbHVzaCBrIGVuY29kZXIgPVxuICBsZXQgYmxpdCBlbmNvZGVyIGxlbiA9XG4gICAgdW5zYWZlX2JsaXQgZW5jb2Rlci50IGVuY29kZXIudF9wb3MgZW5jb2Rlci5vIGVuY29kZXIub19wb3MgbGVuIDtcbiAgICBlbmNvZGVyLm9fcG9zIDwtIGVuY29kZXIub19wb3MgKyBsZW4gO1xuICAgIGVuY29kZXIudF9wb3MgPC0gZW5jb2Rlci50X3BvcyArIGxlbiBpblxuICBsZXQgcmVtID0gb19yZW0gZW5jb2RlciBpblxuICBsZXQgbGVuID0gZW5jb2Rlci50X2xlbiAtIGVuY29kZXIudF9wb3MgKyAxIGluXG4gIGlmIHJlbSA8IGxlblxuICB0aGVuIChcbiAgICBibGl0IGVuY29kZXIgcmVtIDtcbiAgICBmbHVzaCAodF9mbHVzaCBrKSBlbmNvZGVyKVxuICBlbHNlIChcbiAgICBibGl0IGVuY29kZXIgbGVuIDtcbiAgICBrIGVuY29kZXIpXG5cbmxldCByZWMgZW5jb2RlX2xpbmVfYnJlYWsgayBlbmNvZGVyID1cbiAgbGV0IHJlbSA9IG9fcmVtIGVuY29kZXIgaW5cbiAgbGV0IHMsIGosIGsgPVxuICAgIGlmIHJlbSA8IDJcbiAgICB0aGVuIChcbiAgICAgIHRfcmFuZ2UgZW5jb2RlciAyIDtcbiAgICAgIChlbmNvZGVyLnQsIDAsIHRfZmx1c2ggaykpXG4gICAgZWxzZVxuICAgICAgbGV0IGogPSBlbmNvZGVyLm9fcG9zIGluXG4gICAgICBlbmNvZGVyLm9fcG9zIDwtIGVuY29kZXIub19wb3MgKyAyIDtcbiAgICAgIChlbmNvZGVyLm8sIGVuY29kZXIub19vZmYgKyBqLCBrKSBpblxuICB1bnNhZmVfc2V0X2NociBzIGogJ1xccicgO1xuICB1bnNhZmVfc2V0X2NociBzIChqICsgMSkgJ1xcbicgO1xuICBlbmNvZGVyLmNfY29sIDwtIDAgO1xuICBrIGVuY29kZXJcblxuYW5kIGVuY29kZV9jaGFyIGNociBrIChlbmNvZGVyIDogZW5jb2RlcikgPVxuICBpZiBlbmNvZGVyLnMgPj0gMlxuICB0aGVuIChcbiAgICBsZXQgYSwgYiwgYyA9ICh1bnNhZmVfYnl0ZSBlbmNvZGVyLmkgMCAwLCB1bnNhZmVfYnl0ZSBlbmNvZGVyLmkgMCAxLCBjaHIpIGluXG4gICAgZW5jb2Rlci5zIDwtIDAgO1xuICAgIGxldCBxdWFudHVtID0gKENoYXIuY29kZSBhIGxzbCAxNikgKyAoQ2hhci5jb2RlIGIgbHNsIDgpICsgQ2hhci5jb2RlIGMgaW5cbiAgICBsZXQgYSA9IHF1YW50dW0gbHNyIDE4IGluXG4gICAgbGV0IGIgPSAocXVhbnR1bSBsc3IgMTIpIGxhbmQgNjMgaW5cbiAgICBsZXQgYyA9IChxdWFudHVtIGxzciA2KSBsYW5kIDYzIGluXG4gICAgbGV0IGQgPSBxdWFudHVtIGxhbmQgNjMgaW5cbiAgICBsZXQgcmVtID0gb19yZW0gZW5jb2RlciBpblxuICAgIGxldCBzLCBqLCBrID1cbiAgICAgIGlmIHJlbSA8IDRcbiAgICAgIHRoZW4gKFxuICAgICAgICB0X3JhbmdlIGVuY29kZXIgNCA7XG4gICAgICAgIChlbmNvZGVyLnQsIDAsIHRfZmx1c2ggKGsgNCkpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgaiA9IGVuY29kZXIub19wb3MgaW5cbiAgICAgICAgZW5jb2Rlci5vX3BvcyA8LSBlbmNvZGVyLm9fcG9zICsgNCA7XG4gICAgICAgIChlbmNvZGVyLm8sIGVuY29kZXIub19vZmYgKyBqLCBrIDQpIGluXG4gICAgdW5zYWZlX3NldF9jaHIgcyBqIGRlZmF1bHRfYWxwaGFiZXQuW2FdIDtcbiAgICB1bnNhZmVfc2V0X2NociBzIChqICsgMSkgZGVmYXVsdF9hbHBoYWJldC5bYl0gO1xuICAgIHVuc2FmZV9zZXRfY2hyIHMgKGogKyAyKSBkZWZhdWx0X2FscGhhYmV0LltjXSA7XG4gICAgdW5zYWZlX3NldF9jaHIgcyAoaiArIDMpIGRlZmF1bHRfYWxwaGFiZXQuW2RdIDtcbiAgICBmbHVzaCBrIGVuY29kZXIpXG4gIGVsc2UgKFxuICAgIHVuc2FmZV9zZXRfY2hyIGVuY29kZXIuaSBlbmNvZGVyLnMgY2hyIDtcbiAgICBlbmNvZGVyLnMgPC0gZW5jb2Rlci5zICsgMSA7XG4gICAgayAwIGVuY29kZXIpXG5cbmFuZCBlbmNvZGVfdHJhaWxpbmcgayBlbmNvZGVyID1cbiAgbWF0Y2ggZW5jb2Rlci5zIHdpdGhcbiAgfCAyIC0+XG4gICAgICBsZXQgYiwgYyA9ICh1bnNhZmVfYnl0ZSBlbmNvZGVyLmkgMCAwLCB1bnNhZmVfYnl0ZSBlbmNvZGVyLmkgMCAxKSBpblxuICAgICAgZW5jb2Rlci5zIDwtIDAgO1xuICAgICAgbGV0IHF1YW50dW0gPSAoQ2hhci5jb2RlIGIgbHNsIDEwKSArIChDaGFyLmNvZGUgYyBsc2wgMikgaW5cbiAgICAgIGxldCBiID0gKHF1YW50dW0gbHNyIDEyKSBsYW5kIDYzIGluXG4gICAgICBsZXQgYyA9IChxdWFudHVtIGxzciA2KSBsYW5kIDYzIGluXG4gICAgICBsZXQgZCA9IHF1YW50dW0gbGFuZCA2MyBpblxuICAgICAgbGV0IHJlbSA9IG9fcmVtIGVuY29kZXIgaW5cbiAgICAgIGxldCBzLCBqLCBrID1cbiAgICAgICAgaWYgcmVtIDwgNFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICB0X3JhbmdlIGVuY29kZXIgNCA7XG4gICAgICAgICAgKGVuY29kZXIudCwgMCwgdF9mbHVzaCAoayA0KSkpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgaiA9IGVuY29kZXIub19wb3MgaW5cbiAgICAgICAgICBlbmNvZGVyLm9fcG9zIDwtIGVuY29kZXIub19wb3MgKyA0IDtcbiAgICAgICAgICAoZW5jb2Rlci5vLCBlbmNvZGVyLm9fb2ZmICsgaiwgayA0KSBpblxuICAgICAgdW5zYWZlX3NldF9jaHIgcyBqIGRlZmF1bHRfYWxwaGFiZXQuW2JdIDtcbiAgICAgIHVuc2FmZV9zZXRfY2hyIHMgKGogKyAxKSBkZWZhdWx0X2FscGhhYmV0LltjXSA7XG4gICAgICB1bnNhZmVfc2V0X2NociBzIChqICsgMikgZGVmYXVsdF9hbHBoYWJldC5bZF0gO1xuICAgICAgdW5zYWZlX3NldF9jaHIgcyAoaiArIDMpICc9JyA7XG4gICAgICBmbHVzaCBrIGVuY29kZXJcbiAgfCAxIC0+XG4gICAgICBsZXQgYyA9IHVuc2FmZV9ieXRlIGVuY29kZXIuaSAwIDAgaW5cbiAgICAgIGVuY29kZXIucyA8LSAwIDtcbiAgICAgIGxldCBxdWFudHVtID0gQ2hhci5jb2RlIGMgbHNsIDQgaW5cbiAgICAgIGxldCBjID0gKHF1YW50dW0gbHNyIDYpIGxhbmQgNjMgaW5cbiAgICAgIGxldCBkID0gcXVhbnR1bSBsYW5kIDYzIGluXG4gICAgICBsZXQgcmVtID0gb19yZW0gZW5jb2RlciBpblxuICAgICAgbGV0IHMsIGosIGsgPVxuICAgICAgICBpZiByZW0gPCA0XG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHRfcmFuZ2UgZW5jb2RlciA0IDtcbiAgICAgICAgICAoZW5jb2Rlci50LCAwLCB0X2ZsdXNoIChrIDQpKSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCBqID0gZW5jb2Rlci5vX3BvcyBpblxuICAgICAgICAgIGVuY29kZXIub19wb3MgPC0gZW5jb2Rlci5vX3BvcyArIDQgO1xuICAgICAgICAgIChlbmNvZGVyLm8sIGVuY29kZXIub19vZmYgKyBqLCBrIDQpIGluXG4gICAgICB1bnNhZmVfc2V0X2NociBzIGogZGVmYXVsdF9hbHBoYWJldC5bY10gO1xuICAgICAgdW5zYWZlX3NldF9jaHIgcyAoaiArIDEpIGRlZmF1bHRfYWxwaGFiZXQuW2RdIDtcbiAgICAgIHVuc2FmZV9zZXRfY2hyIHMgKGogKyAyKSAnPScgO1xuICAgICAgdW5zYWZlX3NldF9jaHIgcyAoaiArIDMpICc9JyA7XG4gICAgICBmbHVzaCBrIGVuY29kZXJcbiAgfCAwIC0+IGsgMCBlbmNvZGVyXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuYW5kIGVuY29kZV9iYXNlNjQgZW5jb2RlciB2ID1cbiAgbGV0IGsgY29sX2NvdW50IGVuY29kZXIgPVxuICAgIGVuY29kZXIuY19jb2wgPC0gZW5jb2Rlci5jX2NvbCArIGNvbF9jb3VudCA7XG4gICAgZW5jb2Rlci5rIDwtIGVuY29kZV9iYXNlNjQgO1xuICAgIGBPayBpblxuICBtYXRjaCB2IHdpdGhcbiAgfCBgQXdhaXQgLT4gayAwIGVuY29kZXJcbiAgfCBgRW5kIC0+XG4gICAgICBpZiBlbmNvZGVyLmNfY29sID0gNzZcbiAgICAgIHRoZW4gZW5jb2RlX2xpbmVfYnJlYWsgKGZ1biBlbmNvZGVyIC0+IGVuY29kZV9iYXNlNjQgZW5jb2RlciB2KSBlbmNvZGVyXG4gICAgICBlbHNlIGVuY29kZV90cmFpbGluZyBrIGVuY29kZXJcbiAgfCBgQ2hhciBjaHIgLT5cbiAgICAgIGxldCByZW0gPSBvX3JlbSBlbmNvZGVyIGluXG4gICAgICBpZiByZW0gPCAxXG4gICAgICB0aGVuIGZsdXNoIChmdW4gZW5jb2RlciAtPiBlbmNvZGVfYmFzZTY0IGVuY29kZXIgdikgZW5jb2RlclxuICAgICAgZWxzZSBpZiBlbmNvZGVyLmNfY29sID0gNzZcbiAgICAgIHRoZW4gZW5jb2RlX2xpbmVfYnJlYWsgKGZ1biBlbmNvZGVyIC0+IGVuY29kZV9iYXNlNjQgZW5jb2RlciB2KSBlbmNvZGVyXG4gICAgICBlbHNlIGVuY29kZV9jaGFyIGNociBrIGVuY29kZXJcblxubGV0IGVuY29kZXIgZHN0ID1cbiAgbGV0IG8sIG9fb2ZmLCBvX3Bvcywgb19sZW4gPVxuICAgIG1hdGNoIGRzdCB3aXRoXG4gICAgfCBgTWFudWFsIC0+IChCeXRlcy5lbXB0eSwgMSwgMCwgMClcbiAgICB8IGBCdWZmZXIgXyB8IGBDaGFubmVsIF8gLT5cbiAgICAgICAgKEJ5dGVzLmNyZWF0ZSBpb19idWZmZXJfc2l6ZSwgMCwgMCwgaW9fYnVmZmVyX3NpemUgLSAxKSBpblxuICB7XG4gICAgZHN0O1xuICAgIG9fb2ZmO1xuICAgIG9fcG9zO1xuICAgIG9fbGVuO1xuICAgIG87XG4gICAgdCA9IEJ5dGVzLmNyZWF0ZSA0O1xuICAgIHRfcG9zID0gMTtcbiAgICB0X2xlbiA9IDA7XG4gICAgY19jb2wgPSAwO1xuICAgIGkgPSBCeXRlcy5jcmVhdGUgMztcbiAgICBzID0gMDtcbiAgICBrID0gZW5jb2RlX2Jhc2U2NDtcbiAgfVxuXG5sZXQgZW5jb2RlIGVuY29kZXIgPSBlbmNvZGVyLmsgZW5jb2RlclxuXG5sZXQgZW5jb2Rlcl9kc3QgZW5jb2RlciA9IGVuY29kZXIuZHN0XG4iXX0=
