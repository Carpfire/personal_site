// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Domain_name
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Format, Stdlib__List, Stdlib__Map, Stdlib__Set, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_invalid_domain_name$2 = "invalid domain name",
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = ".",
    cst = cst$1,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Set = global_data.Stdlib__Set,
    root = caml_make_vect(0, cst$1),
    cst_invalid_domain_name$1 = cst_invalid_domain_name$2,
    _b_ = [1, [0, 3854881, "couldn't concatenate domain names"]],
    cst_invalid_domain_name$0 = cst_invalid_domain_name$2,
    _a_ = [1, [0, 3854881, "couldn't drop labels"]],
    cst_invalid_domain_name = cst_invalid_domain_name$2,
    cst_label_not_found = "label not found",
    cst_bad_index_for_domain_name = "bad index for domain name",
    cst_invalid_service_name = "invalid service name",
    cst_invalid_host_name = "invalid host name";
   function is_ldh(param){
    a:
    {
     if(58 <= param){
      if(91 <= param){
       if(25 < param - 97 >>> 0) break a;
      }
      else if(65 > param) break a;
     }
     else if(45 !== param && 48 > param) break a;
     return 1;
    }
    return 0;
   }
   function for_all(p, s){
    var n = caml_ml_string_length(s), i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, caml_string_unsafe_get(s, i))) return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function check_host_label(s){
    var _aB_ = 45 !== runtime.caml_string_get(s, 0) ? 1 : 0;
    return _aB_ ? for_all(is_ldh, s) : _aB_;
   }
   function host_exn(t){
    if(0 < t.length - 1){
     var s = caml_check_bound(t, 0)[1], n = caml_ml_string_length(s), i = 0;
     for(;;){
      if(i === n)
       var _az_ = 0;
      else{
       var param = caml_string_unsafe_get(s, i);
       a:
       {
        b:
        {
         if(91 <= param){
          if(25 < param - 97 >>> 0) break b;
         }
         else if(65 > param) break b;
         var _ay_ = 1;
         break a;
        }
        var _ay_ = 0;
       }
       if(! _ay_){var i$0 = i + 1 | 0, i = i$0; continue;}
       var _az_ = 1;
      }
      var _aA_ = _az_;
      break;
     }
    }
    else
     var _aA_ = 1;
    if(_aA_ && caml_call2(Stdlib_Array[22], check_host_label, t)) return t;
    return caml_call1(Stdlib[1], cst_invalid_host_name);
   }
   function host(t){
    try{var _ax_ = [0, host_exn(t)]; return _ax_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var e = exn[2];
     return [1, [0, 3854881, e]];
    }
   }
   function check_label_length(s){
    var
     l = caml_ml_string_length(s),
     _av_ = l < 64 ? 1 : 0,
     _aw_ = _av_ ? 0 < l ? 1 : 0 : _av_;
    return _aw_;
   }
   function check_total_length(t){
    var _at_ = 1;
    function _au_(acc, s){
     return (acc + 1 | 0) + caml_ml_string_length(s) | 0;
    }
    return caml_call3(Stdlib_Array[17], _au_, _at_, t) <= 255 ? 1 : 0;
   }
   function service_exn(t){
    var l = t.length - 1;
    if(2 < l){
     var
      name = caml_call3(Stdlib_Array[5], t, 0, l - 2 | 0),
      _al_ = l - 1 | 0,
      s = caml_check_bound(t, _al_)[1 + _al_];
     a:
     {
      if(0 < caml_ml_string_length(s) && 95 === caml_string_unsafe_get(s, 0)){
       var
        srv =
          caml_call3
           (Stdlib_String[16], s, 1, caml_ml_string_length(s) - 1 | 0),
        slen = caml_ml_string_length(srv),
        _aa_ = 0 < slen ? 1 : 0;
       if(_aa_){
        var _ab_ = slen <= 15 ? 1 : 0;
        if(_ab_){
         var _ac_ = for_all(is_ldh, srv);
         if(_ac_){
          var _ad_ = 45 !== caml_string_unsafe_get(srv, 0) ? 1 : 0;
          if(_ad_){
           var
            _ae_ = 45 !== caml_string_unsafe_get(srv, slen - 1 | 0) ? 1 : 0;
           if(_ae_){
            var
             _af_ = caml_call2(Stdlib_String[17], 45, srv),
             _ag_ = function(l){return caml_string_notequal(l, cst$1);},
             _am_ = caml_call2(Stdlib_List[33], _ag_, _af_);
            break a;
           }
           var _ah_ = _ae_;
          }
          else
           var _ah_ = _ad_;
         }
         else
          var _ah_ = _ac_;
        }
        else
         var _ah_ = _ab_;
       }
       else
        var _ah_ = _aa_;
       var _am_ = _ah_;
       break a;
      }
      var _am_ = 0;
     }
     if(_am_){
      var
       _an_ = l - 2 | 0,
       s$0 = caml_check_bound(t, _an_)[1 + _an_],
       _ai_ = caml_string_equal(s$0, "_tcp");
      if(_ai_)
       var _aj_ = _ai_;
      else
       var
        _ak_ = caml_string_equal(s$0, "_udp"),
        _aj_ = _ak_ || caml_string_equal(s$0, "_sctp");
      if(_aj_){
       var _ao_ = caml_call2(Stdlib_Array[22], check_label_length, name);
       if(_ao_){
        var _ap_ = check_total_length(t);
        if(_ap_)
         var _aq_ = 0 === host(name)[0] ? 1 : 0, _ar_ = _aq_;
        else
         var _ar_ = _ap_;
       }
       else
        var _ar_ = _ao_;
      }
      else
       var _ar_ = _aj_;
     }
     else
      var _ar_ = _am_;
     var _as_ = _ar_;
    }
    else
     var _as_ = 0;
    return _as_ ? t : caml_call1(Stdlib[1], cst_invalid_service_name);
   }
   function service(t){
    try{var _$_ = [0, service_exn(t)]; return _$_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var e = exn[2];
     return [1, [0, 3854881, e]];
    }
   }
   function raw(t){return t;}
   function get_label_exn(opt, xs, idx){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    var idx$0 = rev ? idx : (xs.length - 1 - 1 | 0) - idx | 0;
    try{var _Z_ = caml_check_bound(xs, idx$0)[1 + idx$0]; return _Z_;}
    catch(___){
     var _Y_ = caml_wrap_exception(___);
     if(_Y_[1] === Stdlib[6])
      return caml_call1(Stdlib[1], cst_bad_index_for_domain_name);
     throw caml_maybe_attach_backtrace(_Y_, 0);
    }
   }
   function get_label(rev, xs, idx){
    try{var _X_ = [0, get_label_exn(rev, xs, idx)]; return _X_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var e = exn[2];
     return [1, [0, 3854881, e]];
    }
   }
   function find_label_exn(opt, xs, p){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    var l = xs.length - 1 - 1 | 0;
    if(rev)
     var _U_ = 0, start = _U_, next = function(_V_){return _V_ + 1 | 0;};
    else
     var
      next$0 = function(_W_){return _W_ - 1 | 0;},
      start = l,
      next = next$0;
    var idx = start;
    for(;;){
     var _S_ = 0 <= idx ? 1 : 0, _T_ = _S_ ? idx <= l ? 1 : 0 : _S_;
     if(_T_){
      if(! caml_call1(p, caml_check_bound(xs, idx)[1 + idx])){var idx$0 = next(idx), idx = idx$0; continue;}
      var r = idx;
     }
     else
      var r = caml_call1(Stdlib[1], cst_label_not_found);
     return l - r | 0;
    }
   }
   function find_label(rev, xs, p){
    try{var _Q_ = [0, find_label_exn(rev, xs, p)]; return _Q_;}
    catch(_R_){
     var _P_ = caml_wrap_exception(_R_);
     if(_P_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_P_, 0);
    }
   }
   function count_labels(xs){return xs.length - 1;}
   function prepend_label_exn(xs, lbl){
    var n = caml_make_vect(1, lbl), n$0 = caml_call2(Stdlib_Array[3], xs, n);
    if(check_label_length(lbl) && check_total_length(n$0)) return n$0;
    return caml_call1(Stdlib[1], cst_invalid_domain_name);
   }
   function prepend_label(xs, lbl){
    try{var _O_ = [0, prepend_label_exn(xs, lbl)]; return _O_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var e = exn[2];
     return [1, [0, 3854881, e]];
    }
   }
   function drop_label_exn(opt, _N_, t){
    if(opt) var sth = opt[1], rev = sth; else var rev = 0;
    if(_N_) var sth$0 = _N_[1], amount = sth$0; else var amount = 1;
    var len = t.length - 1 - amount | 0, start = rev ? amount : 0;
    return caml_call3(Stdlib_Array[5], t, start, len);
   }
   function drop_label(rev, amount, t){
    try{var _L_ = [0, drop_label_exn(rev, amount, t)]; return _L_;}
    catch(_M_){
     var _K_ = caml_wrap_exception(_M_);
     if(_K_[1] === Stdlib[6]) return _a_;
     throw caml_maybe_attach_backtrace(_K_, 0);
    }
   }
   function append_exn(pre, post){
    var r = caml_call2(Stdlib_Array[3], post, pre);
    return check_total_length(r)
            ? r
            : caml_call1(Stdlib[1], cst_invalid_domain_name$0);
   }
   function append(pre, post){
    try{var _I_ = [0, append_exn(pre, post)]; return _I_;}
    catch(_J_){
     var _H_ = caml_wrap_exception(_J_);
     if(_H_[1] === Stdlib[6]) return _b_;
     throw caml_maybe_attach_backtrace(_H_, 0);
    }
   }
   function of_strings_exn(xs){
    var rst = caml_call1(Stdlib_List[10], xs);
    a:
    {
     if(rst && ! caml_string_notequal(rst[1], cst$1)){var rst$0 = rst[2], labels = rst$0; break a;}
     var labels = rst;
    }
    var
     t = caml_call1(Stdlib_Array[10], labels),
     _F_ = caml_call2(Stdlib_Array[22], check_label_length, t),
     _G_ = _F_ ? check_total_length(t) : _F_;
    return _G_ ? t : caml_call1(Stdlib[1], cst_invalid_domain_name$1);
   }
   function of_strings(xs){
    try{var _E_ = [0, of_strings_exn(xs)]; return _E_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var e = exn[2];
     return [1, [0, 3854881, e]];
    }
   }
   function of_string(s){
    return of_strings(caml_call2(Stdlib_String[17], 46, s));
   }
   function of_string_exn(s){
    return of_strings_exn(caml_call2(Stdlib_String[17], 46, s));
   }
   function of_array(a){return a;}
   function to_array(a){return a;}
   function to_strings(opt, dn){
    if(opt) var sth = opt[1], trailing = sth; else var trailing = 0;
    var
     labels = caml_call1(Stdlib_Array[9], dn),
     _D_ = trailing ? [0, cst, labels] : labels;
    return caml_call1(Stdlib_List[10], _D_);
   }
   function to_string(trailing, dn){
    var _C_ = to_strings(trailing, dn);
    return caml_call2(Stdlib_String[7], cst$0, _C_);
   }
   function canonical(t){
    var str = to_string(0, t);
    return of_string_exn(caml_call1(Stdlib_String[27], str));
   }
   function pp(ppf, xs){
    var _B_ = to_string(0, xs);
    return caml_call2(Stdlib_Format[13], ppf, _B_);
   }
   function compare_label(a, b){
    var
     _z_ = caml_call1(Stdlib_String[27], b),
     _A_ = caml_call1(Stdlib_String[27], a);
    return caml_call2(Stdlib_String[10], _A_, _z_);
   }
   function compare_domain(cmp_sub, a, b){
    var al = a.length - 1, bl = b.length - 1, idx = 0;
    for(;;){
     if(al === bl && al === idx) return 0;
     if(al === idx) return -1;
     if(bl === idx) return 1;
     var
      _y_ = caml_check_bound(b, idx)[1 + idx],
      x = caml_call2(cmp_sub, caml_check_bound(a, idx)[1 + idx], _y_);
     if(0 !== x) return x;
     var idx$0 = idx + 1 | 0, idx = idx$0;
    }
   }
   function compare(_w_, _x_){return compare_domain(compare_label, _w_, _x_);}
   function equal_label(opt, a, b){
    if(opt)
     var sth = opt[1], case_sensitive = sth;
    else
     var case_sensitive = 0;
    var cmp = case_sensitive ? Stdlib_String[10] : compare_label;
    return 0 === caml_call2(cmp, a, b) ? 1 : 0;
   }
   function equal(opt, a, b){
    if(opt)
     var sth = opt[1], case_sensitive = sth;
    else
     var case_sensitive = 0;
    var cmp = case_sensitive ? Stdlib_String[10] : compare_label;
    return 0 === compare_domain(cmp, a, b) ? 1 : 0;
   }
   function is_subdomain(subdomain, domain){
    var supl = domain.length - 1;
    if(subdomain.length - 1 < supl) return 0;
    var idx = 0;
    for(;;){
     if(idx === supl) return 1;
     var
      _u_ = caml_check_bound(subdomain, idx)[1 + idx],
      _v_ =
        0 === compare_label(caml_check_bound(domain, idx)[1 + idx], _u_)
         ? 1
         : 0;
     if(! _v_) return _v_;
     var idx$0 = idx + 1 | 0, idx = idx$0;
    }
   }
   function compare$0(_s_, _t_){
    return compare_domain(compare_label, _s_, _t_);
   }
   var Ordered = [0, compare$0];
   function compare$1(_q_, _r_){
    return compare_domain(compare_label, _q_, _r_);
   }
   var Host_ordered = [0, compare$1];
   function compare$2(_o_, _p_){
    return compare_domain(compare_label, _o_, _p_);
   }
   var
    Service_ordered = [0, compare$2],
    include = caml_call1(Stdlib_Map[1], Host_ordered),
    empty = include[1],
    add = include[2],
    add_to_list = include[3],
    update = include[4],
    singleton = include[5],
    remove = include[6],
    merge = include[7],
    union = include[8],
    cardinal = include[9],
    bindings = include[10],
    min_binding = include[11],
    min_binding_opt = include[12],
    max_binding = include[13],
    max_binding_opt = include[14],
    choose = include[15],
    choose_opt = include[16],
    find_opt = include[18],
    find_first = include[19],
    find_first_opt = include[20],
    find_last = include[21],
    find_last_opt = include[22],
    iter = include[23],
    fold = include[24],
    map = include[25],
    mapi = include[26],
    filter = include[27],
    filter_map = include[28],
    partition = include[29],
    split = include[30],
    is_empty = include[31],
    mem = include[32],
    equal$0 = include[33],
    compare$3 = include[34],
    for_all$0 = include[35],
    exists = include[36],
    to_list = include[37],
    of_list = include[38],
    to_seq = include[39],
    to_rev_seq = include[40],
    to_seq_from = include[41],
    add_seq = include[42],
    of_seq = include[43],
    _c_ = include[17];
   function find(k, m){
    try{var _m_ = [0, caml_call2(_c_, k, m)]; return _m_;}
    catch(_n_){
     var _l_ = caml_wrap_exception(_n_);
     if(_l_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_l_, 0);
    }
   }
   var
    Host_map =
      [0,
       empty,
       add,
       add_to_list,
       update,
       singleton,
       remove,
       merge,
       union,
       cardinal,
       bindings,
       min_binding,
       min_binding_opt,
       max_binding,
       max_binding_opt,
       choose,
       choose_opt,
       find_opt,
       find_first,
       find_first_opt,
       find_last,
       find_last_opt,
       iter,
       fold,
       map,
       mapi,
       filter,
       filter_map,
       partition,
       split,
       is_empty,
       mem,
       equal$0,
       compare$3,
       for_all$0,
       exists,
       to_list,
       of_list,
       to_seq,
       to_rev_seq,
       to_seq_from,
       add_seq,
       of_seq,
       find],
    Host_set = caml_call1(Stdlib_Set[1], Host_ordered),
    include$0 = caml_call1(Stdlib_Map[1], Service_ordered),
    empty$0 = include$0[1],
    add$0 = include$0[2],
    add_to_list$0 = include$0[3],
    update$0 = include$0[4],
    singleton$0 = include$0[5],
    remove$0 = include$0[6],
    merge$0 = include$0[7],
    union$0 = include$0[8],
    cardinal$0 = include$0[9],
    bindings$0 = include$0[10],
    min_binding$0 = include$0[11],
    min_binding_opt$0 = include$0[12],
    max_binding$0 = include$0[13],
    max_binding_opt$0 = include$0[14],
    choose$0 = include$0[15],
    choose_opt$0 = include$0[16],
    find_opt$0 = include$0[18],
    find_first$0 = include$0[19],
    find_first_opt$0 = include$0[20],
    find_last$0 = include$0[21],
    find_last_opt$0 = include$0[22],
    iter$0 = include$0[23],
    fold$0 = include$0[24],
    map$0 = include$0[25],
    mapi$0 = include$0[26],
    filter$0 = include$0[27],
    filter_map$0 = include$0[28],
    partition$0 = include$0[29],
    split$0 = include$0[30],
    is_empty$0 = include$0[31],
    mem$0 = include$0[32],
    equal$1 = include$0[33],
    compare$4 = include$0[34],
    for_all$1 = include$0[35],
    exists$0 = include$0[36],
    to_list$0 = include$0[37],
    of_list$0 = include$0[38],
    to_seq$0 = include$0[39],
    to_rev_seq$0 = include$0[40],
    to_seq_from$0 = include$0[41],
    add_seq$0 = include$0[42],
    of_seq$0 = include$0[43],
    _d_ = include$0[17];
   function find$0(k, m){
    try{var _j_ = [0, caml_call2(_d_, k, m)]; return _j_;}
    catch(_k_){
     var _i_ = caml_wrap_exception(_k_);
     if(_i_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_i_, 0);
    }
   }
   var
    Service_map =
      [0,
       empty$0,
       add$0,
       add_to_list$0,
       update$0,
       singleton$0,
       remove$0,
       merge$0,
       union$0,
       cardinal$0,
       bindings$0,
       min_binding$0,
       min_binding_opt$0,
       max_binding$0,
       max_binding_opt$0,
       choose$0,
       choose_opt$0,
       find_opt$0,
       find_first$0,
       find_first_opt$0,
       find_last$0,
       find_last_opt$0,
       iter$0,
       fold$0,
       map$0,
       mapi$0,
       filter$0,
       filter_map$0,
       partition$0,
       split$0,
       is_empty$0,
       mem$0,
       equal$1,
       compare$4,
       for_all$1,
       exists$0,
       to_list$0,
       of_list$0,
       to_seq$0,
       to_rev_seq$0,
       to_seq_from$0,
       add_seq$0,
       of_seq$0,
       find$0],
    Service_set = caml_call1(Stdlib_Set[1], Service_ordered),
    include$1 = caml_call1(Stdlib_Map[1], Ordered),
    empty$1 = include$1[1],
    add$1 = include$1[2],
    add_to_list$1 = include$1[3],
    update$1 = include$1[4],
    singleton$1 = include$1[5],
    remove$1 = include$1[6],
    merge$1 = include$1[7],
    union$1 = include$1[8],
    cardinal$1 = include$1[9],
    bindings$1 = include$1[10],
    min_binding$1 = include$1[11],
    min_binding_opt$1 = include$1[12],
    max_binding$1 = include$1[13],
    max_binding_opt$1 = include$1[14],
    choose$1 = include$1[15],
    choose_opt$1 = include$1[16],
    find_opt$1 = include$1[18],
    find_first$1 = include$1[19],
    find_first_opt$1 = include$1[20],
    find_last$1 = include$1[21],
    find_last_opt$1 = include$1[22],
    iter$1 = include$1[23],
    fold$1 = include$1[24],
    map$1 = include$1[25],
    mapi$1 = include$1[26],
    filter$1 = include$1[27],
    filter_map$1 = include$1[28],
    partition$1 = include$1[29],
    split$1 = include$1[30],
    is_empty$1 = include$1[31],
    mem$1 = include$1[32],
    equal$2 = include$1[33],
    compare$5 = include$1[34],
    for_all$2 = include$1[35],
    exists$1 = include$1[36],
    to_list$1 = include$1[37],
    of_list$1 = include$1[38],
    to_seq$1 = include$1[39],
    to_rev_seq$1 = include$1[40],
    to_seq_from$1 = include$1[41],
    add_seq$1 = include$1[42],
    of_seq$1 = include$1[43],
    _e_ = include$1[17];
   function find$1(k, m){
    try{var _g_ = [0, caml_call2(_e_, k, m)]; return _g_;}
    catch(_h_){
     var _f_ = caml_wrap_exception(_h_);
     if(_f_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_f_, 0);
    }
   }
   var
    Map =
      [0,
       empty$1,
       add$1,
       add_to_list$1,
       update$1,
       singleton$1,
       remove$1,
       merge$1,
       union$1,
       cardinal$1,
       bindings$1,
       min_binding$1,
       min_binding_opt$1,
       max_binding$1,
       max_binding_opt$1,
       choose$1,
       choose_opt$1,
       find_opt$1,
       find_first$1,
       find_first_opt$1,
       find_last$1,
       find_last_opt$1,
       iter$1,
       fold$1,
       map$1,
       mapi$1,
       filter$1,
       filter_map$1,
       partition$1,
       split$1,
       is_empty$1,
       mem$1,
       equal$2,
       compare$5,
       for_all$2,
       exists$1,
       to_list$1,
       of_list$1,
       to_seq$1,
       to_rev_seq$1,
       to_seq_from$1,
       add_seq$1,
       of_seq$1,
       find$1],
    Set = caml_call1(Stdlib_Set[1], Ordered),
    Domain_name =
      [0,
       root,
       of_string,
       of_string_exn,
       to_string,
       canonical,
       host,
       host_exn,
       service,
       service_exn,
       raw,
       count_labels,
       is_subdomain,
       get_label,
       get_label_exn,
       find_label,
       find_label_exn,
       prepend_label,
       prepend_label_exn,
       drop_label,
       drop_label_exn,
       append,
       append_exn,
       equal,
       compare,
       equal_label,
       compare_label,
       Host_map,
       Host_set,
       Service_map,
       Service_set,
       Map,
       Set,
       of_strings,
       of_strings_exn,
       to_strings,
       pp,
       of_array,
       to_array];
   runtime.caml_register_global(24, Domain_name, "Domain_name");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJkb21haW5fbmFtZS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsicm9vdCIsImlzX2xkaCIsImZvcl9hbGwiLCJwIiwicyIsIm4iLCJpIiwiaSQwIiwiY2hlY2tfaG9zdF9sYWJlbCIsImhvc3RfZXhuIiwidCIsImhvc3QiLCJlIiwiY2hlY2tfbGFiZWxfbGVuZ3RoIiwibCIsImNoZWNrX3RvdGFsX2xlbmd0aCIsImFjYyIsInNlcnZpY2VfZXhuIiwibmFtZSIsInNydiIsInNsZW4iLCJzJDAiLCJzZXJ2aWNlIiwicmF3IiwiZ2V0X2xhYmVsX2V4biIsIm9wdCIsInhzIiwiaWR4Iiwic3RoIiwicmV2IiwiaWR4JDAiLCJnZXRfbGFiZWwiLCJmaW5kX2xhYmVsX2V4biIsInN0YXJ0IiwibmV4dCIsIm5leHQkMCIsInIiLCJmaW5kX2xhYmVsIiwiY291bnRfbGFiZWxzIiwicHJlcGVuZF9sYWJlbF9leG4iLCJsYmwiLCJuJDAiLCJwcmVwZW5kX2xhYmVsIiwiZHJvcF9sYWJlbF9leG4iLCJzdGgkMCIsImFtb3VudCIsImxlbiIsImRyb3BfbGFiZWwiLCJhcHBlbmRfZXhuIiwicHJlIiwicG9zdCIsImFwcGVuZCIsIm9mX3N0cmluZ3NfZXhuIiwicnN0IiwicnN0JDAiLCJsYWJlbHMiLCJvZl9zdHJpbmdzIiwib2Zfc3RyaW5nIiwib2Zfc3RyaW5nX2V4biIsIm9mX2FycmF5IiwiYSIsInRvX2FycmF5IiwidG9fc3RyaW5ncyIsImRuIiwidHJhaWxpbmciLCJ0b19zdHJpbmciLCJjYW5vbmljYWwiLCJzdHIiLCJwcCIsInBwZiIsImNvbXBhcmVfbGFiZWwiLCJiIiwiY29tcGFyZV9kb21haW4iLCJjbXBfc3ViIiwiYWwiLCJibCIsIngiLCJjb21wYXJlIiwiZXF1YWxfbGFiZWwiLCJjYXNlX3NlbnNpdGl2ZSIsImNtcCIsImVxdWFsIiwiaXNfc3ViZG9tYWluIiwic3ViZG9tYWluIiwiZG9tYWluIiwic3VwbCIsImNvbXBhcmUkMCIsImNvbXBhcmUkMSIsImNvbXBhcmUkMiIsImZpbmQiLCJrIiwibSIsImZpbmQkMCIsImZpbmQkMSJdLCJzb3VyY2VzIjpbIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL2RvbWFpbi1uYW1lL2RvbWFpbl9uYW1lLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHQUlXOzs7Ozs7Ozs7OztJQUFQQSxPQUFPOzs7Ozs7Ozs7O1lBTVVDO0lBQVM7Ozs7Ozs7OztLQUNjOztJQUNuQztHQUFLO1lBR1ZDLFFBQVFDLEdBQUVDO0lBQ1osSUFBSUMsMEJBRFFELElBRUNFO0lBQ1g7UUFEV0EsTUFEVEQsR0FFWTtLQUNOLEtBQUEsV0FKQUYsMEJBQUVDLEdBRUNFLEtBR047S0FEa0MsSUFGNUJDLE1BQUFELFdBQUFBLElBQUFDOztHQUlQO1lBVWFDLGlCQUFpQko7SUFDcEMsa0JBQUEsd0JBRG9DQTtrQkFoQmxDRixRQUxpQkQsUUFxQmlCRztHQUVwQjtZQUVkSyxTQUFTQztJQUVYLE9BRldBO0tBSVcsSUFoQlhOLHFCQVlBTSxVQVhQTCwwQkFET0QsSUFFRUU7S0FDWDtTQURXQSxNQURURDs7OzBDQURPRCxHQUVFRTs7Ozs7Ozs7Ozs7Ozs7T0FFSCxXQUNILElBSE1DLE1BQUFELFdBQUFBLElBQUFDOzs7Ozs7Ozs7SUFnQlgsV0FBQSw2QkFWaUJDLGtCQUlSRSxJQVFULE9BUlNBO0lBVVQsT0FBQTtHQUErQjtZQUUvQkMsS0FBS0Q7SUFDUCxJQUFJLGVBYkZELFNBWUtDLEtBQ0g7Ozs7U0FDZUU7S0FBSyx3QkFBTEE7O0dBQW1CO1lBbUJuQkMsbUJBQW1CVDtJQUN0QztLQUFJVSwwQkFEa0NWO1lBQ2xDVTt1QkFBQUE7O0dBQ1c7WUFFSUMsbUJBQW1CTDtJQUN0QztrQkFBcUJNLEtBQUlaO0tBQUssUUFBVFkscUNBQUlaO0lBQThCO1dBQXZELHlDQURzQ007R0FDNkI7WUFFakVPLFlBQVlQO0lBQ2QsSUFBSUksSUFEVUo7SUFFZCxPQURJSTtL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VSxTQUFWQztJLE9BakRGaEIsZUFIQUY7O0dBa0RxQjtJQUFBLHNCQUVuQmtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFRQUMsS0FBS0MsR0FBRUM7SUFBSSxJQUFJLGNBQUssZ0JBQWZELEdBQUVDLEtBQVE7OzsyQkFBa0M7OztHQUFJO0dBSHpDO0lBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BR1pGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBUUFHLE9BQUtGLEdBQUVDO0lBQUksSUFBSSxjQUFLLGdCQUFmRCxHQUFFQyxLQUFROzs7MkJBQWtDOzs7R0FBSTtHQUh0QztJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQUdmQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQVFBQyxPQUFLSCxHQUFFQztJQUFJLElBQUksY0FBSyxnQkFBZkQsR0FBRUMsS0FBUTs7OzJCQUFrQzs7O0dBQUk7R0FIOUM7SUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FHUEU7Ozs7T0E1UUY3RjtPQTRLQXlEO09BRUFDO09BVUFPO09BRUFDO09BL0lBdkQ7T0FaQUY7T0F5REFhO09BakJBTDtPQXFCQU07T0FtQ0FlO09BMkZBNEM7T0FuSEFuRDtPQUxBUDtPQXlCQWE7T0FoQkFMO09BNEJBVTtPQU5BSDtPQWdCQVE7T0FOQUo7T0FjQVE7T0FKQUg7T0FpRUFpQztPQU5BSjtPQUVBQztPQWxCQVI7Ozs7Ozs7T0F4QkFkO09BWEFKO09BdUJBVTtPQVVBTTtPQWRBVDtPQUVBRTs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiAoYykgMjAxNyBIYW5uZXMgTWVobmVydCwgYWxsIHJpZ2h0cyByZXNlcnZlZCAqKVxuXG50eXBlICdhIHMgPSBzdHJpbmcgYXJyYXlcblxubGV0IHJvb3QgPSBBcnJheS5tYWtlIDAgXCJcIlxuXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19sZXR0ZXIgPSBmdW5jdGlvblxuICB8ICdhJy4uJ3onIHwgJ0EnLi4nWicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IFtAaW5saW5lIGFsd2F5c10gaXNfbGRoID0gZnVuY3Rpb25cbiAgfCAnMCcuLic5JyB8ICdhJy4uJ3onIHwgJ0EnLi4nWicgfCAnLScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuKCogZnJvbSBPQ2FtbCA0LjEzIGJ5dGVzLm1sICopXG5sZXQgZm9yX2FsbCBwIHMgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwIChTdHJpbmcudW5zYWZlX2dldCBzIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBleGlzdHMgcCBzID1cbiAgbGV0IG4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKFN0cmluZy51bnNhZmVfZ2V0IHMgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBjaGVja19ob3N0X2xhYmVsIHMgPVxuICBTdHJpbmcuZ2V0IHMgMCA8PiAnLScgJiYgKCogbGVhZGluZyBtYXkgbm90IGJlICctJyAqKVxuICBmb3JfYWxsIGlzX2xkaCBzICgqIG9ubHkgTERIIChsZXR0ZXJzLCBkaWdpdHMsIGh5cGhlbikhICopXG5cbmxldCBob3N0X2V4biB0ID1cbiAgKCogVExEIHNob3VsZCBub3QgYmUgYWxsLW51bWVyaWMhICopXG4gIGlmXG4gICAgKGlmIEFycmF5Lmxlbmd0aCB0ID4gMCB0aGVuXG4gICAgICAgZXhpc3RzIGlzX2xldHRlciAoQXJyYXkuZ2V0IHQgMClcbiAgICAgZWxzZSB0cnVlKSAmJlxuICAgIEFycmF5LmZvcl9hbGwgY2hlY2tfaG9zdF9sYWJlbCB0XG4gIHRoZW5cbiAgICB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZyBcImludmFsaWQgaG9zdCBuYW1lXCJcblxubGV0IGhvc3QgdCA9XG4gIHRyeSBPayAoaG9zdF9leG4gdCkgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgZSAtPiBFcnJvciAoYE1zZyBlKVxuXG5sZXQgY2hlY2tfc2VydmljZV9sYWJlbCBzID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzID4gMCAmJiBTdHJpbmcudW5zYWZlX2dldCBzIDAgPSAnXycgdGhlblxuICAgIGxldCBzcnYgPSBTdHJpbmcuc3ViIHMgMSAoU3RyaW5nLmxlbmd0aCBzIC0gMSkgaW5cbiAgICBsZXQgc2xlbiA9IFN0cmluZy5sZW5ndGggc3J2IGluXG4gICAgKCogc2VydmljZSBsYWJlbDogMS0xNSBjaGFyYWN0ZXJzOyBMREg7IGh5cGhlbiBfbm90XyBhdCBiZWdpbiBub3IgZW5kOyBubyBoeXBoZW4gZm9sbG93aW5nIGEgaHlwaGVuICopXG4gICAgc2xlbiA+IDAgJiYgc2xlbiA8PSAxNSAmJlxuICAgIGZvcl9hbGwgaXNfbGRoIHNydiAmJlxuICAgIFN0cmluZy51bnNhZmVfZ2V0IHNydiAwIDw+ICctJyAmJlxuICAgIFN0cmluZy51bnNhZmVfZ2V0IHNydiAoc2xlbiAtIDEpIDw+ICctJyAmJlxuICAgIExpc3QuZm9yX2FsbCAoZnVuIGwgLT4gbCA8PiBcIlwiKVxuICAgICAgKFN0cmluZy5zcGxpdF9vbl9jaGFyICctJyBzcnYpXG4gIGVsc2VcbiAgICBmYWxzZVxuXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19wcm90byBzID1cbiAgcyA9IFwiX3RjcFwiIHx8IHMgPSBcIl91ZHBcIiB8fCBzID0gXCJfc2N0cFwiXG5cbmxldCBbQGlubGluZSBhbHdheXNdIGNoZWNrX2xhYmVsX2xlbmd0aCBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbCA8IDY0ICYmIGwgPiAwXG5cbmxldCBbQGlubGluZSBhbHdheXNdIGNoZWNrX3RvdGFsX2xlbmd0aCB0ID1cbiAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gYWNjIHMgLT4gYWNjICsgMSArIFN0cmluZy5sZW5ndGggcykgMSB0IDw9IDI1NVxuXG5sZXQgc2VydmljZV9leG4gdCA9XG4gIGxldCBsID0gQXJyYXkubGVuZ3RoIHQgaW5cbiAgaWZcbiAgICBpZiBsID4gMiB0aGVuXG4gICAgICBsZXQgbmFtZSA9IEFycmF5LnN1YiB0IDAgKGwgLSAyKSBpblxuICAgICAgY2hlY2tfc2VydmljZV9sYWJlbCAoQXJyYXkuZ2V0IHQgKGwgLSAxKSkgJiZcbiAgICAgIGlzX3Byb3RvIChBcnJheS5nZXQgdCAobCAtIDIpKSAmJlxuICAgICAgQXJyYXkuZm9yX2FsbCBjaGVja19sYWJlbF9sZW5ndGggbmFtZSAmJlxuICAgICAgY2hlY2tfdG90YWxfbGVuZ3RoIHQgJiZcbiAgICAgIG1hdGNoIGhvc3QgbmFtZSB3aXRoIE9rIF8gLT4gdHJ1ZSB8IEVycm9yIF8gLT4gZmFsc2VcbiAgICBlbHNlXG4gICAgICBmYWxzZVxuICB0aGVuXG4gICAgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmcgXCJpbnZhbGlkIHNlcnZpY2UgbmFtZVwiXG5cbmxldCBzZXJ2aWNlIHQgPVxuICB0cnkgT2sgKHNlcnZpY2VfZXhuIHQpIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IGUgLT4gRXJyb3IgKGBNc2cgZSlcblxubGV0IHJhdyB0ID0gdFxuXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBjaGVjayB0ID1cbiAgQXJyYXkuZm9yX2FsbCBjaGVja19sYWJlbF9sZW5ndGggdCAmJlxuICBjaGVja190b3RhbF9sZW5ndGggdFxuXG5sZXQgZ2V0X2xhYmVsX2V4biA/KHJldiA9IGZhbHNlKSB4cyBpZHggPVxuICBsZXQgaWR4JyA9IGlmIHJldiB0aGVuIGlkeCBlbHNlIHByZWQgKEFycmF5Lmxlbmd0aCB4cykgLSBpZHggaW5cbiAgdHJ5IEFycmF5LmdldCB4cyBpZHgnIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gaW52YWxpZF9hcmcgXCJiYWQgaW5kZXggZm9yIGRvbWFpbiBuYW1lXCJcblxubGV0IGdldF9sYWJlbCA/cmV2IHhzIGlkeCA9XG4gIHRyeSBPayAoZ2V0X2xhYmVsX2V4biA/cmV2IHhzIGlkeCkgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgZSAtPiBFcnJvciAoYE1zZyBlKVxuXG5sZXQgZmluZF9sYWJlbF9leG4gPyhyZXYgPSBmYWxzZSkgeHMgcCA9XG4gIGxldCBsID0gcHJlZCAoQXJyYXkubGVuZ3RoIHhzKSBpblxuICBsZXQgY2hlY2sgeCA9IHggPj0gMCAmJiB4IDw9IGwgaW5cbiAgbGV0IHJlYyBnbyBuZXh0IGlkeCA9XG4gICAgaWYgY2hlY2sgaWR4IHRoZW5cbiAgICAgIGlmIHAgKEFycmF5LmdldCB4cyBpZHgpIHRoZW5cbiAgICAgICAgaWR4XG4gICAgICBlbHNlXG4gICAgICAgIGdvIG5leHQgKG5leHQgaWR4KVxuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnIFwibGFiZWwgbm90IGZvdW5kXCJcbiAgaW5cbiAgbGV0IG5leHQsIHN0YXJ0ID0gaWYgcmV2IHRoZW4gKHN1Y2MsIDApIGVsc2UgKHByZWQsIGwpIGluXG4gIGxldCByID0gZ28gbmV4dCBzdGFydCBpblxuICBsIC0gclxuXG5sZXQgZmluZF9sYWJlbCA/cmV2IHhzIHAgPVxuICB0cnkgU29tZSAoZmluZF9sYWJlbF9leG4gP3JldiB4cyBwKSB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGNvdW50X2xhYmVscyB4cyA9IEFycmF5Lmxlbmd0aCB4c1xuXG5sZXQgcHJlcGVuZF9sYWJlbF9leG4geHMgbGJsID1cbiAgbGV0IG4gPSBBcnJheS5tYWtlIDEgbGJsIGluXG4gIGxldCBuID0gQXJyYXkuYXBwZW5kIHhzIG4gaW5cbiAgaWYgY2hlY2tfbGFiZWxfbGVuZ3RoIGxibCAmJiBjaGVja190b3RhbF9sZW5ndGggbiB0aGVuIG5cbiAgZWxzZSBpbnZhbGlkX2FyZyBcImludmFsaWQgZG9tYWluIG5hbWVcIlxuXG5sZXQgcHJlcGVuZF9sYWJlbCB4cyBsYmwgPVxuICB0cnkgT2sgKHByZXBlbmRfbGFiZWxfZXhuIHhzIGxibCkgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgZSAtPiBFcnJvciAoYE1zZyBlKVxuXG5sZXQgZHJvcF9sYWJlbF9leG4gPyhyZXYgPSBmYWxzZSkgPyhhbW91bnQgPSAxKSB0ID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0IC0gYW1vdW50XG4gIGFuZCBzdGFydCA9IGlmIHJldiB0aGVuIGFtb3VudCBlbHNlIDBcbiAgaW5cbiAgQXJyYXkuc3ViIHQgc3RhcnQgbGVuXG5cbmxldCBkcm9wX2xhYmVsID9yZXYgP2Ftb3VudCB0ID1cbiAgdHJ5IE9rIChkcm9wX2xhYmVsX2V4biA/cmV2ID9hbW91bnQgdCkgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBFcnJvciAoYE1zZyBcImNvdWxkbid0IGRyb3AgbGFiZWxzXCIpXG5cbmxldCBhcHBlbmRfZXhuIHByZSBwb3N0ID1cbiAgbGV0IHIgPSBBcnJheS5hcHBlbmQgcG9zdCBwcmUgaW5cbiAgaWYgY2hlY2tfdG90YWxfbGVuZ3RoIHIgdGhlbiByIGVsc2UgaW52YWxpZF9hcmcgXCJpbnZhbGlkIGRvbWFpbiBuYW1lXCJcblxubGV0IGFwcGVuZCBwcmUgcG9zdCA9XG4gIHRyeSBPayAoYXBwZW5kX2V4biBwcmUgcG9zdCkgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBFcnJvciAoYE1zZyBcImNvdWxkbid0IGNvbmNhdGVuYXRlIGRvbWFpbiBuYW1lc1wiKVxuXG5sZXQgb2Zfc3RyaW5nc19leG4geHMgPVxuICBsZXQgbGFiZWxzID1cbiAgICAoKiB3ZSBzdXBwb3J0IGJvdGggZXhhbXBsZS5jb20uIGFuZCBleGFtcGxlLmNvbSAqKVxuICAgIG1hdGNoIExpc3QucmV2IHhzIHdpdGhcbiAgICB8IFwiXCI6OnJzdCAtPiByc3RcbiAgICB8IHJzdCAtPiByc3RcbiAgaW5cbiAgbGV0IHQgPSBBcnJheS5vZl9saXN0IGxhYmVscyBpblxuICBpZiBjaGVjayB0IHRoZW4gdFxuICBlbHNlIGludmFsaWRfYXJnIFwiaW52YWxpZCBkb21haW4gbmFtZVwiXG5cbmxldCBvZl9zdHJpbmdzIHhzID1cbiAgdHJ5IE9rIChvZl9zdHJpbmdzX2V4biB4cykgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgZSAtPiBFcnJvciAoYE1zZyBlKVxuXG5sZXQgb2Zfc3RyaW5nIHMgPSBvZl9zdHJpbmdzIChTdHJpbmcuc3BsaXRfb25fY2hhciAnLicgcylcblxubGV0IG9mX3N0cmluZ19leG4gcyA9IG9mX3N0cmluZ3NfZXhuIChTdHJpbmcuc3BsaXRfb25fY2hhciAnLicgcylcblxubGV0IG9mX2FycmF5IGEgPSBhXG5cbmxldCB0b19hcnJheSBhID0gYVxuXG5sZXQgdG9fc3RyaW5ncyA/KHRyYWlsaW5nID0gZmFsc2UpIGRuID1cbiAgbGV0IGxhYmVscyA9IEFycmF5LnRvX2xpc3QgZG4gaW5cbiAgTGlzdC5yZXYgKGlmIHRyYWlsaW5nIHRoZW4gXCJcIiA6OiBsYWJlbHMgZWxzZSBsYWJlbHMpXG5cbmxldCB0b19zdHJpbmcgP3RyYWlsaW5nIGRuID0gU3RyaW5nLmNvbmNhdCBcIi5cIiAodG9fc3RyaW5ncyA/dHJhaWxpbmcgZG4pXG5cbmxldCBjYW5vbmljYWwgdCA9XG4gIGxldCBzdHIgPSB0b19zdHJpbmcgdCBpblxuICBvZl9zdHJpbmdfZXhuIChTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN0cilcblxubGV0IHBwIHBwZiB4cyA9IEZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmICh0b19zdHJpbmcgeHMpXG5cbmxldCBjb21wYXJlX2xhYmVsIGEgYiA9XG4gIFN0cmluZy5jb21wYXJlIChTdHJpbmcubG93ZXJjYXNlX2FzY2lpIGEpIChTdHJpbmcubG93ZXJjYXNlX2FzY2lpIGIpXG5cbmxldCBjb21wYXJlX2RvbWFpbiBjbXBfc3ViIGEgYiA9XG4gIGxldCBhbCA9IEFycmF5Lmxlbmd0aCBhIGFuZCBibCA9IEFycmF5Lmxlbmd0aCBiIGluXG4gIGxldCByZWMgY21wIGlkeCA9XG4gICAgaWYgYWwgPSBibCAmJiBhbCA9IGlkeCB0aGVuIDBcbiAgICBlbHNlIGlmIGFsID0gaWR4IHRoZW4gLTFcbiAgICBlbHNlIGlmIGJsID0gaWR4IHRoZW4gMVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGNtcF9zdWIgKEFycmF5LmdldCBhIGlkeCkgKEFycmF5LmdldCBiIGlkeCkgd2l0aFxuICAgICAgfCAwIC0+IGNtcCAoc3VjYyBpZHgpXG4gICAgICB8IHggLT4geFxuICBpblxuICBjbXAgMFxuXG5sZXQgY29tcGFyZSA9IGNvbXBhcmVfZG9tYWluIGNvbXBhcmVfbGFiZWxcblxubGV0IGVxdWFsX2xhYmVsID8oY2FzZV9zZW5zaXRpdmUgPSBmYWxzZSkgYSBiID1cbiAgbGV0IGNtcCA9IGlmIGNhc2Vfc2Vuc2l0aXZlIHRoZW4gU3RyaW5nLmNvbXBhcmUgZWxzZSBjb21wYXJlX2xhYmVsIGluXG4gIGNtcCBhIGIgPSAwXG5cbmxldCBlcXVhbCA/KGNhc2Vfc2Vuc2l0aXZlID0gZmFsc2UpIGEgYiA9XG4gIGxldCBjbXAgPSBpZiBjYXNlX3NlbnNpdGl2ZSB0aGVuIFN0cmluZy5jb21wYXJlIGVsc2UgY29tcGFyZV9sYWJlbCBpblxuICBjb21wYXJlX2RvbWFpbiBjbXAgYSBiID0gMFxuXG5sZXQgaXNfc3ViZG9tYWluIH5zdWJkb21haW4gfmRvbWFpbiA9XG4gIGxldCBzdXBsID0gQXJyYXkubGVuZ3RoIGRvbWFpbiBpblxuICBsZXQgcmVjIGNtcCBpZHggPVxuICAgIGlmIGlkeCA9IHN1cGwgdGhlblxuICAgICAgdHJ1ZVxuICAgIGVsc2VcbiAgICAgIGNvbXBhcmVfbGFiZWwgKEFycmF5LmdldCBkb21haW4gaWR4KSAoQXJyYXkuZ2V0IHN1YmRvbWFpbiBpZHgpID0gMCAmJlxuICAgICAgY21wIChzdWNjIGlkeClcbiAgaW5cbiAgaWYgQXJyYXkubGVuZ3RoIHN1YmRvbWFpbiA8IHN1cGwgdGhlblxuICAgIGZhbHNlXG4gIGVsc2VcbiAgICBjbXAgMFxuXG5tb2R1bGUgT3JkZXJlZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBbIGByYXcgXSBzXG4gIGxldCBjb21wYXJlID0gY29tcGFyZV9kb21haW4gY29tcGFyZV9sYWJlbFxuZW5kXG5cbm1vZHVsZSBIb3N0X29yZGVyZWQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gWyBgaG9zdCBdIHNcbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlX2RvbWFpbiBjb21wYXJlX2xhYmVsXG5lbmRcblxubW9kdWxlIFNlcnZpY2Vfb3JkZXJlZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBbIGBzZXJ2aWNlIF0gc1xuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVfZG9tYWluIGNvbXBhcmVfbGFiZWxcbmVuZFxuXG50eXBlICdhIHQgPSAnYSBzXG5cbm1vZHVsZSBIb3N0X21hcCA9IHN0cnVjdFxuICBpbmNsdWRlIE1hcC5NYWtlKEhvc3Rfb3JkZXJlZClcblxuICBsZXQgZmluZCBrIG0gPSB0cnkgU29tZSAoZmluZCBrIG0pIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcbmVuZFxuXG5tb2R1bGUgSG9zdF9zZXQgPSBTZXQuTWFrZShIb3N0X29yZGVyZWQpXG5cbm1vZHVsZSBTZXJ2aWNlX21hcCA9IHN0cnVjdFxuICBpbmNsdWRlIE1hcC5NYWtlKFNlcnZpY2Vfb3JkZXJlZClcblxuICBsZXQgZmluZCBrIG0gPSB0cnkgU29tZSAoZmluZCBrIG0pIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcbmVuZFxuXG5tb2R1bGUgU2VydmljZV9zZXQgPSBTZXQuTWFrZShTZXJ2aWNlX29yZGVyZWQpXG5cbm1vZHVsZSBNYXAgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYXAuTWFrZShPcmRlcmVkKVxuXG4gIGxldCBmaW5kIGsgbSA9IHRyeSBTb21lIChmaW5kIGsgbSkgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuZW5kXG5cbm1vZHVsZSBTZXQgPSBTZXQuTWFrZShPcmRlcmVkKVxuIl19
