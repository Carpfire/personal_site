// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Faraday
//# unitInfo: Requires: Bigstringaf, Stdlib, Stdlib__Array, Stdlib__Bytes, Stdlib__Int32, Stdlib__Int64, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_faraday_ml = "lib/faraday.ml",
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_check_bound = runtime.caml_check_bound,
    caml_int32_bits_of_float = runtime.caml_int32_bits_of_float,
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    deadbeef = "\xde\xad\xbe\xef",
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_String = global_data.Stdlib__String,
    Dequeue_empty =
      [248, "Faraday.Dequeue_empty", runtime.caml_fresh_oo_id(0)],
    _d_ = [0, cst_lib_faraday_ml, 378, 4],
    _g_ = [0, cst_lib_faraday_ml, 480, 14],
    _h_ = [0, cst_lib_faraday_ml, 477, 4],
    _e_ = [0, cst_lib_faraday_ml, 462, 14],
    _f_ = [0, cst_lib_faraday_ml, 459, 4],
    cst_cannot_write_to_closed_wri = "cannot write to closed writer",
    _b_ = [0, cst_lib_faraday_ml, 131, 4],
    _a_ = [0, cst_lib_faraday_ml, 111, 4];
   function Deque(T){
    var sentinel = T[1];
    function create(size){return [0, caml_make_vect(size, sentinel), 0, 0];}
    function is_empty(t){return t[2] === t[3] ? 1 : 0;}
    function enqueue(e, t){
     if(t[3] === (t[1].length - 1 - 1 | 0)){
      var len = t[3] - t[2] | 0;
      if(0 < t[2]){
       caml_call5(Stdlib_Array[8], t[1], t[2], t[1], 0, len);
       caml_call4(Stdlib_Array[7], t[1], len, t[2], sentinel);
      }
      else{
       var
        old = t[1],
        new$0 = caml_make_vect(2 * (old.length - 1) | 0, sentinel);
       caml_call5(Stdlib_Array[8], old, t[2], new$0, 0, len);
       t[1] = new$0;
      }
      t[2] = 0;
      t[3] = len;
     }
     var _E_ = t[3];
     caml_check_bound(t[1], _E_)[1 + _E_] = e;
     t[3] = t[3] + 1 | 0;
     return 0;
    }
    function dequeue_exn(t){
     if(is_empty(t)) throw Dequeue_empty;
     var result = t[1][1 + t[2]];
     t[1][1 + t[2]] = sentinel;
     t[2] = t[2] + 1 | 0;
     return result;
    }
    function enqueue_front(e, t){
     if(0 >= t[2])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     t[2] = t[2] - 1 | 0;
     var _D_ = t[2];
     caml_check_bound(t[1], _D_)[1 + _D_] = e;
     return 0;
    }
    function map_to_list(t, f){
     var result = [0, 0], _z_ = t[3] - 1 | 0, _A_ = t[2];
     if(_z_ >= _A_){
      var i = _z_;
      for(;;){
       var _B_ = result[1];
       result[1] = [0, caml_call1(f, caml_check_bound(t[1], i)[1 + i]), _B_];
       var _C_ = i - 1 | 0;
       if(_A_ === i) break;
       var i = _C_;
      }
     }
     return result[1];
    }
    return [0,
            create,
            is_empty,
            enqueue,
            dequeue_exn,
            enqueue_front,
            map_to_list];
   }
   function lengthv(ts){
    var ts$0 = ts, acc = 0;
    for(;;){
     if(! ts$0) return acc;
     var
      ts$1 = ts$0[2],
      iovec = ts$0[1],
      acc$0 = iovec[3] + acc | 0,
      ts$0 = ts$1,
      acc = acc$0;
    }
   }
   var Flushed_reason = [0], buffer = caml_call1(Bigstringaf[1], 4), len = 4;
   function _c_(_x_, _y_){return caml_ba_set_1(buffer, _x_, _y_);}
   caml_call2(Stdlib_String[31], _c_, deadbeef);
   var
    sentinel = [0, buffer, 0, len],
    Buffers = Deque([0, sentinel]),
    sentinel$0 = [0, 0, function(param){return 0;}],
    Flushes = Deque([0, sentinel$0]);
   function of_bigstring(buffer){
    var _w_ = Flushes[1].call(null, 1);
    return [0, buffer, 0, 0, Buffers[1].call(null, 4), _w_, 0, 0, 0, 0];
   }
   function create(size){
    return of_bigstring(caml_call1(Bigstringaf[1], size));
   }
   function writable_exn(t){
    var _v_ = t[8];
    return _v_ ? caml_call1(Stdlib[2], cst_cannot_write_to_closed_wri) : _v_;
   }
   function schedule_iovec(t, opt, len, buffer){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    t[6] = t[6] + len | 0;
    return Buffers[3].call(null, [0, buffer, off, len], t[4]);
   }
   function flush_buffer(t){
    var len = t[3] - t[2] | 0, _t_ = 0 < len ? 1 : 0;
    if(_t_){
     var off = t[2];
     schedule_iovec(t, [0, off], len, t[1]);
     t[2] = t[3];
     var _u_ = 0;
    }
    else
     var _u_ = _t_;
    return _u_;
   }
   function flush_with_reason(t, f){
    t[9] = 0;
    flush_buffer(t);
    return Buffers[2].call(null, t[4])
            ? caml_call1(f, 2)
            : Flushes[3].call(null, [0, t[6], f], t[5]);
   }
   function flush(t, f){
    return flush_with_reason(t, function(param){return caml_call1(f, 0);});
   }
   function free_bytes_in_buffer(t){
    var buf_len = caml_call1(Bigstringaf[6], t[1]);
    return buf_len - t[3] | 0;
   }
   function schedule_bigstring(t, opt, len, a){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    writable_exn(t);
    flush_buffer(t);
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(Bigstringaf[6], a) - off | 0;
    var _s_ = 0 < len$1 ? 1 : 0;
    return _s_ ? schedule_iovec(t, [0, off], len$1, a) : _s_;
   }
   function ensure_space(t, len){
    if(free_bytes_in_buffer(t) < len){
     flush_buffer(t);
     var
      _q_ = caml_call1(Bigstringaf[6], t[1]),
      _r_ = caml_call2(Stdlib[17], _q_, len);
     t[1] = caml_call1(Bigstringaf[1], _r_);
     t[3] = 0;
     t[2] = 0;
    }
    return;
   }
   function write_gen(t, length, blit, opt, len, a){
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    writable_exn(t);
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_call1(length, a) - off | 0;
    ensure_space(t, len$1);
    caml_call5(blit, a, off, t[1], t[3], len$1);
    t[3] = t[3] + len$1 | 0;
    return 0;
   }
   var length = runtime.caml_ml_string_length, blit = Bigstringaf[45];
   function write_string(t, off, len, a){
    return write_gen(t, length, blit, off, len, a);
   }
   var length$0 = runtime.caml_ml_bytes_length, blit$0 = Bigstringaf[46];
   function write_bytes(t, off, len, a){
    return write_gen(t, length$0, blit$0, off, len, a);
   }
   var length$1 = Bigstringaf[6], blit$1 = Bigstringaf[44];
   function write_bigstring(t, off, len, a){
    return write_gen(t, length$1, blit$1, off, len, a);
   }
   function write_char(t, c){
    writable_exn(t);
    ensure_space(t, 1);
    caml_ba_set_1(t[1], t[3], c);
    t[3] = t[3] + 1 | 0;
    return 0;
   }
   function write_uint8(t, b){
    writable_exn(t);
    ensure_space(t, 1);
    caml_ba_set_1(t[1], t[3], b);
    t[3] = t[3] + 1 | 0;
    return 0;
   }
   function write_uint16(t, i){
    writable_exn(t);
    ensure_space(t, 2);
    caml_call3(Bigstringaf[35], t[1], t[3], i);
    t[3] = t[3] + 2 | 0;
    return 0;
   }
   function write_uint32(t, i){
    writable_exn(t);
    ensure_space(t, 4);
    caml_call3(Bigstringaf[39], t[1], t[3], i);
    t[3] = t[3] + 4 | 0;
    return 0;
   }
   function write_uint48(t, i){
    writable_exn(t);
    ensure_space(t, 6);
    caml_call3
     (Bigstringaf[39],
      t[1],
      t[3],
      caml_int64_to_int32(caml_int64_shift_right_unsigne(i, 4)));
    caml_call3(Bigstringaf[35], t[1], t[3] + 2 | 0, caml_int64_to_int32(i));
    t[3] = t[3] + 6 | 0;
    return 0;
   }
   function write_uint64(t, i){
    writable_exn(t);
    ensure_space(t, 8);
    caml_call3(Bigstringaf[43], t[1], t[3], i);
    t[3] = t[3] + 8 | 0;
    return 0;
   }
   function write_float(t, f){
    writable_exn(t);
    ensure_space(t, 4);
    caml_call3(Bigstringaf[39], t[1], t[3], caml_int32_bits_of_float(f));
    t[3] = t[3] + 4 | 0;
    return 0;
   }
   function write_double(t, d){
    writable_exn(t);
    ensure_space(t, 8);
    caml_call3(Bigstringaf[43], t[1], t[3], caml_int64_bits_of_float(d));
    t[3] = t[3] + 8 | 0;
    return 0;
   }
   var
    BE =
      [0,
       write_uint16,
       write_uint32,
       write_uint48,
       write_uint64,
       write_float,
       write_double];
   function write_uint16$0(t, i){
    writable_exn(t);
    ensure_space(t, 2);
    caml_call3(Bigstringaf[34], t[1], t[3], i);
    t[3] = t[3] + 2 | 0;
    return 0;
   }
   function write_uint32$0(t, i){
    writable_exn(t);
    ensure_space(t, 4);
    caml_call3(Bigstringaf[38], t[1], t[3], i);
    t[3] = t[3] + 4 | 0;
    return 0;
   }
   function write_uint48$0(t, i){
    writable_exn(t);
    ensure_space(t, 6);
    caml_call3(Bigstringaf[34], t[1], t[3], caml_int64_to_int32(i));
    caml_call3
     (Bigstringaf[38],
      t[1],
      t[3] + 2 | 0,
      caml_int64_to_int32(caml_int64_shift_right_unsigne(i, 2)));
    t[3] = t[3] + 6 | 0;
    return 0;
   }
   function write_uint64$0(t, i){
    writable_exn(t);
    ensure_space(t, 8);
    caml_call3(Bigstringaf[42], t[1], t[3], i);
    t[3] = t[3] + 8 | 0;
    return 0;
   }
   function write_float$0(t, f){
    writable_exn(t);
    ensure_space(t, 4);
    caml_call3(Bigstringaf[38], t[1], t[3], caml_int32_bits_of_float(f));
    t[3] = t[3] + 4 | 0;
    return 0;
   }
   function write_double$0(t, d){
    writable_exn(t);
    ensure_space(t, 8);
    caml_call3(Bigstringaf[42], t[1], t[3], caml_int64_bits_of_float(d));
    t[3] = t[3] + 8 | 0;
    return 0;
   }
   var
    LE =
      [0,
       write_uint16$0,
       write_uint32$0,
       write_uint48$0,
       write_uint64$0,
       write_float$0,
       write_double$0];
   function close(t){t[8] = 1; return flush_buffer(t);}
   function is_closed(t){return t[8];}
   function pending_bytes(t){
    return (t[3] - t[2] | 0) + (t[6] - t[7] | 0) | 0;
   }
   function has_pending_output(t){return 0 !== pending_bytes(t) ? 1 : 0;}
   function yield$0(t){t[9] = 1; return 0;}
   function shift_internal(t, written$1, reason){
    a:
    {
     b:
     {
      var written = written$1;
      for(;;){
       try{var iovec = Buffers[4].call(null, t[4]);}
       catch(_p_){var _l_ = caml_wrap_exception(_p_); break;}
       var len$0 = iovec[3];
       if(len$0 > written) break b;
       var written$0 = written - len$0 | 0, written = written$0;
      }
      if(_l_ !== Dequeue_empty) throw caml_maybe_attach_backtrace(_l_, 0);
      if(0 !== written)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      if(t[2] === t[3]){t[2] = 0; t[3] = 0;}
      break a;
     }
     var len = iovec[3], off = iovec[2], buffer = iovec[1], _m_ = t[4];
     if(written >= len)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     Buffers[5].call
      (null, [0, buffer, off + written | 0, len - written | 0], _m_);
    }
    t[7] = t[7] + written$1 | 0;
    for(;;){
     try{var flush = Flushes[4].call(null, t[5]);}
     catch(_o_){
      var _n_ = caml_wrap_exception(_o_);
      if(_n_ === Dequeue_empty) return 0;
      throw caml_maybe_attach_backtrace(_n_, 0);
     }
     var f = flush[2], threshold = flush[1];
     if((threshold - Stdlib[20] | 0) > (t[7] - Stdlib[20] | 0))
      return Flushes[5].call(null, flush, t[5]);
     caml_call1(f, reason);
    }
   }
   function shift(t, written){return shift_internal(t, written, 0);}
   function operation(t){
    if(t[8]) t[9] = 0;
    flush_buffer(t);
    var nothing_to_do = 1 - has_pending_output(t);
    if(t[8] && nothing_to_do) return -611285096;
    if(! t[9] && ! nothing_to_do){
     var
      _k_ = function(x){return x;},
      iovecs = Buffers[6].call(null, t[4], _k_);
     return [0, 846875351, iovecs];
    }
    t[9] = 0;
    return 73271853;
   }
   function serialize(t, writev){
    for(;;){
     var next = operation(t);
     if(typeof next === "number") return next;
     var iovecs = next[2], match = caml_call1(writev, iovecs);
     if(typeof match === "number")
      close(t);
     else{
      var n = match[2];
      shift(t, n);
      if(1 - Buffers[2].call(null, t[4])) yield$0(t);
     }
    }
   }
   function serialize_to_string(t){
    close(t);
    var match = operation(t);
    if(typeof match === "number"){
     if(73271853 <= match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     return cst;
    }
    var
     iovecs = match[2],
     len = lengthv(iovecs),
     bytes = runtime.caml_create_bytes(len),
     pos = [0, 0];
    function _j_(param){
     var len = param[3], off = param[2], buffer = param[1];
     caml_call5(Bigstringaf[47], buffer, off, bytes, pos[1], len);
     pos[1] = pos[1] + len | 0;
     return 0;
    }
    caml_call2(Stdlib_List[18], _j_, iovecs);
    shift(t, len);
    if(-611285096 === operation(t))
     return caml_call1(Stdlib_Bytes[44], bytes);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function serialize_to_bigstring(t){
    close(t);
    var match = operation(t);
    if(typeof match === "number"){
     if(73271853 <= match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     return caml_call1(Bigstringaf[1], 0);
    }
    var
     iovecs = match[2],
     len = lengthv(iovecs),
     bs = caml_call1(Bigstringaf[1], len),
     pos = [0, 0];
    function _i_(param){
     var len = param[3], off = param[2], buffer = param[1];
     caml_call5(Bigstringaf[44], buffer, off, bs, pos[1], len);
     pos[1] = pos[1] + len | 0;
     return 0;
    }
    caml_call2(Stdlib_List[18], _i_, iovecs);
    shift(t, len);
    if(-611285096 === operation(t)) return bs;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   }
   function drain(t){
    var acc = 0;
    for(;;){
     var match = operation(t);
     if(typeof match === "number"){
      if(73271853 > match) return acc;
     }
     else{
      var iovecs = match[2], len = lengthv(iovecs);
      shift_internal(t, len, 1);
      var acc$0 = len + acc | 0, acc = acc$0;
     }
    }
   }
   var
    Faraday =
      [0,
       create,
       of_bigstring,
       write_string,
       write_bytes,
       write_bigstring,
       write_gen,
       write_char,
       write_uint8,
       BE,
       LE,
       schedule_bigstring,
       free_bytes_in_buffer,
       has_pending_output,
       pending_bytes,
       yield$0,
       flush,
       Flushed_reason,
       flush_with_reason,
       close,
       is_closed,
       shift,
       drain,
       operation,
       serialize,
       serialize_to_string,
       serialize_to_bigstring];
   runtime.caml_register_global(18, Faraday, "Faraday");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJmYXJhZGF5LmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJkZWFkYmVlZiIsInNlbnRpbmVsIiwiY3JlYXRlIiwic2l6ZSIsImlzX2VtcHR5IiwidCIsImVucXVldWUiLCJlIiwibGVuIiwib2xkIiwibmV3JDAiLCJkZXF1ZXVlX2V4biIsInJlc3VsdCIsImVucXVldWVfZnJvbnQiLCJtYXBfdG9fbGlzdCIsImYiLCJpIiwibGVuZ3RodiIsInRzIiwidHMkMCIsImFjYyIsInRzJDEiLCJpb3ZlYyIsImFjYyQwIiwiYnVmZmVyIiwic2VudGluZWwkMCIsIm9mX2JpZ3N0cmluZyIsIndyaXRhYmxlX2V4biIsInNjaGVkdWxlX2lvdmVjIiwib3B0Iiwic3RoIiwib2ZmIiwiZmx1c2hfYnVmZmVyIiwiZmx1c2hfd2l0aF9yZWFzb24iLCJmbHVzaCIsImZyZWVfYnl0ZXNfaW5fYnVmZmVyIiwiYnVmX2xlbiIsInNjaGVkdWxlX2JpZ3N0cmluZyIsImEiLCJsZW4kMCIsImxlbiQxIiwiZW5zdXJlX3NwYWNlIiwid3JpdGVfZ2VuIiwibGVuZ3RoIiwiYmxpdCIsIndyaXRlX3N0cmluZyIsImxlbmd0aCQwIiwiYmxpdCQwIiwid3JpdGVfYnl0ZXMiLCJsZW5ndGgkMSIsImJsaXQkMSIsIndyaXRlX2JpZ3N0cmluZyIsIndyaXRlX2NoYXIiLCJjIiwid3JpdGVfdWludDgiLCJiIiwid3JpdGVfdWludDE2Iiwid3JpdGVfdWludDMyIiwid3JpdGVfdWludDQ4Iiwid3JpdGVfdWludDY0Iiwid3JpdGVfZmxvYXQiLCJ3cml0ZV9kb3VibGUiLCJkIiwid3JpdGVfdWludDE2JDAiLCJ3cml0ZV91aW50MzIkMCIsIndyaXRlX3VpbnQ0OCQwIiwid3JpdGVfdWludDY0JDAiLCJ3cml0ZV9mbG9hdCQwIiwid3JpdGVfZG91YmxlJDAiLCJjbG9zZSIsImlzX2Nsb3NlZCIsInBlbmRpbmdfYnl0ZXMiLCJoYXNfcGVuZGluZ19vdXRwdXQiLCJ5aWVsZCQwIiwic2hpZnRfaW50ZXJuYWwiLCJ3cml0dGVuJDEiLCJyZWFzb24iLCJ3cml0dGVuIiwid3JpdHRlbiQwIiwidGhyZXNob2xkIiwic2hpZnQiLCJvcGVyYXRpb24iLCJub3RoaW5nX3RvX2RvIiwieCIsImlvdmVjcyIsInNlcmlhbGl6ZSIsIndyaXRldiIsIm5leHQiLCJuIiwic2VyaWFsaXplX3RvX3N0cmluZyIsImJ5dGVzIiwicG9zIiwic2VyaWFsaXplX3RvX2JpZ3N0cmluZyIsImJzIiwiZHJhaW4iXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9mYXJhZGF5L2ZhcmFkYXkubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0dBeUNBOzs7O0lBNEdRQTs7Ozs7Ozs7SUE1R1I7Ozs7Ozs7Ozs7O1FBd0JNQzthQUVBQyxPQUFPQyxNQUNULFdBQWEsZUFESkEsTUFGUEYsaUJBRzBEO2FBRTFERyxTQUFTQyxHQUNYLE9BRFdBLFNBQUFBLGFBQ0s7YUFvQmRDLFFBQVFDLEdBQUVGO0tBQ1osR0FEWUEsVUFBQUE7VUFoQk5HLE1BZ0JNSCxPQUFBQTthQUFBQTtPQVpSLDRCQVlRQSxNQUFBQSxNQUFBQSxTQWhCTkc7T0FLRiw0QkFXUUgsTUFoQk5HLEtBZ0JNSCxNQTFCVko7OztPQWtCb0I7UUFEZFEsTUFTSUo7UUFSSkssUUFBYyxvQkFEZEQscUJBakJOUjtPQW1CRSw0QkFGSVEsS0FTSUosTUFSSkssVUFSRkY7T0FnQk1ILE9BUkpLOztNQVFJTDtNQUFBQSxPQWhCTkc7O2VBZ0JNSDtLQUVaLGlCQUZZQSxzQkFBRkU7S0FBRUYsT0FBQUE7O0lBR1E7YUFFbEJNLFlBQVlOO0tBQ2QsR0EzQkVELFNBMEJZQyxJQUVaO0tBRWEsSUFBVE8sU0FKUVAsU0FBQUE7S0FBQUEsU0FBQUEsUUEvQlpKO0tBK0JZSSxPQUFBQTtLQU9aLE9BSElPO0lBR0U7YUFFTkMsY0FBY04sR0FBRUY7S0FLbEIsUUFM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S0FBTSxZQWhFTjZELFVBd0VFNUU7OzJCQUhrQixPQU5QZTs7O01BR0QsSUFERmdFLG1CQUNKNUUsTUFoV0pTLFFBK1ZRbUU7TUF6RVZWLGVBZ0ZFckUsR0FOSUc7VUFIT2UsUUFHUGYsTUFIT1ksU0FBQUEsTUFBQUc7OztHQVNFOzs7O09BOVNmckI7T0FYQXdCO09BdUVBbUI7T0FLQUc7T0FLQUc7T0FyQkFUO09BMEJBVTtPQU1BRTs7O09BbERBakI7T0FKQUY7T0F3SkFxQztPQUhBRDtPQU1BRTtPQTdKQXZDOztPQU5BRDtPQXNKQW9DO09BSUFDO09BdURBVTtPQWdFQWM7T0E5REFiO09BZ0JJSTtPQVVKSTtPQWtCQUc7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ29weXJpZ2h0IChjKSAyMDE2IEluaGFiaXRlZCBUeXBlIExMQy5cblxuICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIG5vciB0aGUgbmFtZXMgb2YgaGlzIGNvbnRyaWJ1dG9yc1xuICAgICAgIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICAgICAgIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09OVFJJQlVUT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NcbiAgICBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICAgIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAgICBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbiAgICBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gICAgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAgICBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTilcbiAgICBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXG4gICAgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOXG4gICAgQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gICAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG5cbnR5cGUgYmlnc3RyaW5nID0gQmlnc3RyaW5nYWYudFxuXG50eXBlICdhIGlvdmVjID1cbiAgeyBidWZmZXIgOiAnYVxuICA7IG9mZiAgICA6IGludFxuICA7IGxlbiAgICA6IGludCB9XG5cbmV4Y2VwdGlvbiBEZXF1ZXVlX2VtcHR5XG5cbm1vZHVsZSBEZXF1ZShUOnNpZyB0eXBlIHQgdmFsIHNlbnRpbmVsIDogdCBlbmQpIDogc2lnXG4gIHR5cGUgZWxlbSA9IFQudFxuXG4gIHR5cGUgdFxuXG4gIHZhbCBjcmVhdGUgOiBpbnQgLT4gdFxuXG4gIHZhbCBpc19lbXB0eSA6IHQgLT4gYm9vbFxuXG4gIHZhbCBlbnF1ZXVlIDogZWxlbSAtPiB0IC0+IHVuaXRcbiAgdmFsIGRlcXVldWVfZXhuIDogdCAtPiBlbGVtXG4gIHZhbCBlbnF1ZXVlX2Zyb250IDogZWxlbSAtPiB0IC0+IHVuaXRcblxuICB2YWwgbWFwX3RvX2xpc3QgOiB0IC0+IGY6KGVsZW0gLT4gJ2IpIC0+ICdiIGxpc3RcbmVuZCA9IHN0cnVjdFxuICB0eXBlIGVsZW0gPSBULnRcblxuICB0eXBlIHQgPVxuICAgIHsgbXV0YWJsZSBlbGVtZW50cyA6IGVsZW0gYXJyYXlcbiAgICA7IG11dGFibGUgZnJvbnQgICAgOiBpbnRcbiAgICA7IG11dGFibGUgYmFjayAgICAgOiBpbnQgfVxuXG4gIGxldCBzZW50aW5lbCA9IFQuc2VudGluZWxcblxuICBsZXQgY3JlYXRlIHNpemUgPVxuICAgIHsgZWxlbWVudHMgPSBBcnJheS5tYWtlIHNpemUgc2VudGluZWw7IGZyb250ID0gMDsgYmFjayA9IDAgfVxuXG4gIGxldCBpc19lbXB0eSB0ID1cbiAgICB0LmZyb250ID0gdC5iYWNrXG5cbiAgbGV0IGVuc3VyZV9zcGFjZSB0ID1cbiAgICBpZiB0LmJhY2sgPSBBcnJheS5sZW5ndGggdC5lbGVtZW50cyAtIDEgdGhlbiBiZWdpblxuICAgICAgbGV0IGxlbiA9IHQuYmFjayAtIHQuZnJvbnQgaW5cbiAgICAgIGlmIHQuZnJvbnQgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgKCogU2hpZnQgZXZlcnl0aGluZyB0byB0aGUgZnJvbnQgb2YgdGhlIGFycmF5IGFuZCB0aGVuIGNsZWFyIG91dFxuICAgICAgICAgKiBkYW5nbGluZyBwb2ludGVycyB0byBlbGVtZW50cyBmcm9tIHRoZWlyIHByZXZpb3VzIGxvY2F0aW9ucy4gKilcbiAgICAgICAgQXJyYXkuYmxpdCB0LmVsZW1lbnRzIHQuZnJvbnQgdC5lbGVtZW50cyAwIGxlbjtcbiAgICAgICAgQXJyYXkuZmlsbCB0LmVsZW1lbnRzIGxlbiB0LmZyb250IHNlbnRpbmVsXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgb2xkICA9IHQuZWxlbWVudHMgaW5cbiAgICAgICAgbGV0IG5ld18gPSBBcnJheS4obWFrZSAoMiAqIGxlbmd0aCBvbGQpIHNlbnRpbmVsKSBpblxuICAgICAgICBBcnJheS5ibGl0IG9sZCB0LmZyb250IG5ld18gMCBsZW47XG4gICAgICAgIHQuZWxlbWVudHMgPC0gbmV3X1xuICAgICAgZW5kO1xuICAgICAgdC5mcm9udCA8LSAwO1xuICAgICAgdC5iYWNrIDwtIGxlblxuICAgIGVuZFxuXG4gIGxldCBlbnF1ZXVlIGUgdCA9XG4gICAgZW5zdXJlX3NwYWNlIHQ7XG4gICAgdC5lbGVtZW50cy4odC5iYWNrKSA8LSBlO1xuICAgIHQuYmFjayA8LSB0LmJhY2sgKyAxXG5cbiAgbGV0IGRlcXVldWVfZXhuIHQgPVxuICAgIGlmIGlzX2VtcHR5IHQgdGhlblxuICAgICAgcmFpc2Vfbm90cmFjZSBEZXF1ZXVlX2VtcHR5XG4gICAgZWxzZVxuICAgICAgbGV0IHJlc3VsdCA9IEFycmF5LnVuc2FmZV9nZXQgdC5lbGVtZW50cyB0LmZyb250IGluXG4gICAgICBBcnJheS51bnNhZmVfc2V0IHQuZWxlbWVudHMgdC5mcm9udCBzZW50aW5lbDtcbiAgICAgIHQuZnJvbnQgPC0gdC5mcm9udCArIDE7XG4gICAgICByZXN1bHRcblxuICBsZXQgZW5xdWV1ZV9mcm9udCBlIHQgPVxuICAgICgqIFRoaXMgaXMgaW4gZ2VuZXJhbCBub3QgdHJ1ZSBmb3IgRGVxdWUgZGF0YSBzdHJ1Y3R1cmVzLCBidXQgdGhlIHVzYWdlXG4gICAgICogYmVsb3cgZW5zdXJlcyB0aGF0IHRoZXJlIGlzIGFsd2F5cyBzcGFjZSB0byBwdXNoIGFuIGVsZW1lbnQgYmFjayBvbiB0aGVcbiAgICAgKiBmcm9udC4gQW4gW2VucXVldWVfZnJvbnRdIGlzIGFsd2F5cyBwcmVjZWRlZCBieSBhIFtkZXF1ZXVlXSwgd2l0aCBub1xuICAgICAqIGludGVydmVuaW5nIG9wZXJhdGlvbnMuICopXG4gICAgYXNzZXJ0ICh0LmZyb250ID4gMCk7XG4gICAgdC5mcm9udCA8LSB0LmZyb250IC0gMTtcbiAgICB0LmVsZW1lbnRzLih0LmZyb250KSA8LSBlXG5cbiAgbGV0IG1hcF90b19saXN0IHQgfmYgPVxuICAgIGxldCByZXN1bHQgPSByZWYgW10gaW5cbiAgICBmb3IgaSA9IHQuYmFjayAtIDEgZG93bnRvIHQuZnJvbnQgZG9cbiAgICAgIHJlc3VsdCA6PSBmIHQuZWxlbWVudHMuKGkpIDo6ICFyZXN1bHRcbiAgICBkb25lO1xuICAgICFyZXN1bHRcbmVuZFxuXG5tb2R1bGUgSU9WZWMgPSBzdHJ1Y3RcbiAgbGV0IGNyZWF0ZSBidWZmZXIgfm9mZiB+bGVuID1cbiAgICB7IGJ1ZmZlcjsgb2ZmOyBsZW4gfVxuXG4gIGxldCBsZW5ndGggdCA9XG4gICAgdC5sZW5cblxuICBsZXQgc2hpZnQgeyBidWZmZXI7IG9mZjsgbGVuIH0gbiA9XG4gICAgYXNzZXJ0IChuIDwgbGVuKTtcbiAgICB7IGJ1ZmZlcjsgb2ZmID0gb2ZmICsgbjsgbGVuID0gbGVuIC0gbiB9XG5cbiAgbGV0IGxlbmd0aHYgdHMgPVxuICAgIGxldCByZWMgbG9vcCB0cyBhY2MgPVxuICAgICAgbWF0Y2ggdHMgd2l0aFxuICAgICAgfCBbXSAgICAgICAgLT4gYWNjXG4gICAgICB8IGlvdmVjOjp0cyAtPiBsb29wIHRzIChsZW5ndGggaW92ZWMgKyBhY2MpXG4gICAgaW5cbiAgICBsb29wIHRzIDBcbmVuZFxuXG5tb2R1bGUgRmx1c2hlZF9yZWFzb24gPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gU2hpZnQgfCBEcmFpbiB8IE5vdGhpbmdfcGVuZGluZ1xuZW5kXG5cbm1vZHVsZSBCdWZmZXJzID0gRGVxdWUoc3RydWN0XG4gIHR5cGUgdCA9IGJpZ3N0cmluZyBpb3ZlY1xuICBsZXQgc2VudGluZWwgPVxuICAgIGxldCBkZWFkYmVlZiA9IFwiXFwyMjJcXDE3M1xcMTkwXFwyMzlcIiBpblxuICAgIGxldCBsZW4gICAgICA9IFN0cmluZy5sZW5ndGggZGVhZGJlZWYgaW5cbiAgICBsZXQgYnVmZmVyICAgPSBCaWdzdHJpbmdhZi5jcmVhdGUgbGVuIGluXG4gICAgU3RyaW5nLml0ZXJpIChCaWdzdHJpbmdhZi51bnNhZmVfc2V0IGJ1ZmZlcikgZGVhZGJlZWY7XG4gICAgeyBidWZmZXI7IG9mZiA9IDA7IGxlbiB9XG5lbmQpXG5tb2R1bGUgRmx1c2hlcyA9IERlcXVlKHN0cnVjdFxuICB0eXBlIHQgPSBpbnQgKiAoRmx1c2hlZF9yZWFzb24udCAtPiB1bml0KVxuICBsZXQgc2VudGluZWwgPSAwLCBmdW4gXyAtPiAoKVxuZW5kKVxuXG50eXBlIHQgPVxuICB7IG11dGFibGUgYnVmZmVyICAgICAgICAgOiBiaWdzdHJpbmdcbiAgOyBtdXRhYmxlIHNjaGVkdWxlZF9wb3MgIDogaW50XG4gIDsgbXV0YWJsZSB3cml0ZV9wb3MgICAgICA6IGludFxuICA7IHNjaGVkdWxlZCAgICAgICAgICAgICAgOiBCdWZmZXJzLnRcbiAgOyBmbHVzaGVkICAgICAgICAgICAgICAgIDogRmx1c2hlcy50XG4gIDsgbXV0YWJsZSBieXRlc19yZWNlaXZlZCA6IGludFxuICA7IG11dGFibGUgYnl0ZXNfd3JpdHRlbiAgOiBpbnRcbiAgOyBtdXRhYmxlIGNsb3NlZCAgICAgICAgIDogYm9vbFxuICA7IG11dGFibGUgeWllbGQgICAgICAgICAgOiBib29sXG4gIH1cblxudHlwZSBvcGVyYXRpb24gPSBbXG4gIHwgYFdyaXRldiBvZiBiaWdzdHJpbmcgaW92ZWMgbGlzdFxuICB8IGBZaWVsZFxuICB8IGBDbG9zZVxuICBdXG5cbmxldCBvZl9iaWdzdHJpbmcgYnVmZmVyID1cbiAgeyBidWZmZXJcbiAgOyB3cml0ZV9wb3MgICAgICAgPSAwXG4gIDsgc2NoZWR1bGVkX3BvcyAgID0gMFxuICA7IHNjaGVkdWxlZCAgICAgICA9IEJ1ZmZlcnMuY3JlYXRlIDRcbiAgOyBmbHVzaGVkICAgICAgICAgPSBGbHVzaGVzLmNyZWF0ZSAxXG4gIDsgYnl0ZXNfcmVjZWl2ZWQgID0gMFxuICA7IGJ5dGVzX3dyaXR0ZW4gICA9IDBcbiAgOyBjbG9zZWQgICAgICAgICAgPSBmYWxzZVxuICA7IHlpZWxkICAgICAgICAgICA9IGZhbHNlIH1cblxubGV0IGNyZWF0ZSBzaXplID1cbiAgb2ZfYmlnc3RyaW5nIChCaWdzdHJpbmdhZi5jcmVhdGUgc2l6ZSlcblxubGV0IHdyaXRhYmxlX2V4biB0ID1cbiAgaWYgdC5jbG9zZWQgdGhlblxuICAgIGZhaWx3aXRoIFwiY2Fubm90IHdyaXRlIHRvIGNsb3NlZCB3cml0ZXJcIlxuXG5sZXQgc2NoZWR1bGVfaW92ZWMgdCA/KG9mZj0wKSB+bGVuIGJ1ZmZlciA9XG4gIHQuYnl0ZXNfcmVjZWl2ZWQgPC0gdC5ieXRlc19yZWNlaXZlZCArIGxlbjtcbiAgQnVmZmVycy5lbnF1ZXVlIChJT1ZlYy5jcmVhdGUgYnVmZmVyIH5vZmYgfmxlbikgdC5zY2hlZHVsZWRcblxubGV0IGZsdXNoX2J1ZmZlciB0ID1cbiAgbGV0IGxlbiA9IHQud3JpdGVfcG9zIC0gdC5zY2hlZHVsZWRfcG9zIGluXG4gIGlmIGxlbiA+IDAgdGhlbiBiZWdpblxuICAgIGxldCBvZmYgPSB0LnNjaGVkdWxlZF9wb3MgaW5cbiAgICBzY2hlZHVsZV9pb3ZlYyB0IH5vZmYgfmxlbiB0LmJ1ZmZlcjtcbiAgICB0LnNjaGVkdWxlZF9wb3MgPC0gdC53cml0ZV9wb3NcbiAgZW5kXG5cbmxldCBmbHVzaF93aXRoX3JlYXNvbiB0IGYgPVxuICB0LnlpZWxkIDwtIGZhbHNlO1xuICBmbHVzaF9idWZmZXIgdDtcbiAgaWYgQnVmZmVycy5pc19lbXB0eSB0LnNjaGVkdWxlZCB0aGVuIGYgRmx1c2hlZF9yZWFzb24uTm90aGluZ19wZW5kaW5nXG4gIGVsc2UgRmx1c2hlcy5lbnF1ZXVlICh0LmJ5dGVzX3JlY2VpdmVkLCBmKSB0LmZsdXNoZWRcblxubGV0IGZsdXNoIHQgZiA9IGZsdXNoX3dpdGhfcmVhc29uIHQgKGZ1biBfIC0+IGYgKCkpXG5cbmxldCBmcmVlX2J5dGVzX2luX2J1ZmZlciB0ID1cbiAgbGV0IGJ1Zl9sZW4gPSBCaWdzdHJpbmdhZi5sZW5ndGggdC5idWZmZXIgaW5cbiAgYnVmX2xlbiAtIHQud3JpdGVfcG9zXG5cbmxldCBzY2hlZHVsZV9iaWdzdHJpbmcgdCA/KG9mZj0wKSA/bGVuIGEgPVxuICB3cml0YWJsZV9leG4gdDtcbiAgZmx1c2hfYnVmZmVyIHQ7XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lICAgICAtPiBCaWdzdHJpbmdhZi5sZW5ndGggYSAtIG9mZlxuICAgIHwgU29tZSBsZW4gLT4gbGVuXG4gIGluXG4gIGlmIGxlbiA+IDAgdGhlbiBzY2hlZHVsZV9pb3ZlYyB0IH5vZmYgfmxlbiBhXG5cbmxldCBlbnN1cmVfc3BhY2UgdCBsZW4gPVxuICBpZiBmcmVlX2J5dGVzX2luX2J1ZmZlciB0IDwgbGVuIHRoZW4gYmVnaW5cbiAgICBmbHVzaF9idWZmZXIgdDtcbiAgICB0LmJ1ZmZlciA8LSBCaWdzdHJpbmdhZi5jcmVhdGUgKG1heCAoQmlnc3RyaW5nYWYubGVuZ3RoIHQuYnVmZmVyKSBsZW4pO1xuICAgIHQud3JpdGVfcG9zIDwtIDA7XG4gICAgdC5zY2hlZHVsZWRfcG9zIDwtIDBcbiAgZW5kXG5cbmxldCB3cml0ZV9nZW4gdCB+bGVuZ3RoIH5ibGl0ID8ob2ZmPTApID9sZW4gYSA9XG4gIHdyaXRhYmxlX2V4biB0O1xuICBsZXQgbGVuID1cbiAgICBtYXRjaCBsZW4gd2l0aFxuICAgIHwgTm9uZSAgICAgLT4gbGVuZ3RoIGEgLSBvZmZcbiAgICB8IFNvbWUgbGVuIC0+IGxlblxuICBpblxuICBlbnN1cmVfc3BhY2UgdCBsZW47XG4gIGJsaXQgYSB+c3JjX29mZjpvZmYgdC5idWZmZXIgfmRzdF9vZmY6dC53cml0ZV9wb3MgfmxlbjtcbiAgdC53cml0ZV9wb3MgPC0gdC53cml0ZV9wb3MgKyBsZW5cblxubGV0IHdyaXRlX3N0cmluZyA9XG4gIGxldCBsZW5ndGggICA9IFN0cmluZy5sZW5ndGggaW5cbiAgbGV0IGJsaXQgICAgID0gQmlnc3RyaW5nYWYudW5zYWZlX2JsaXRfZnJvbV9zdHJpbmcgaW5cbiAgZnVuIHQgP29mZiA/bGVuIGEgLT4gd3JpdGVfZ2VuIHQgfmxlbmd0aCB+YmxpdCA/b2ZmID9sZW4gYVxuXG5sZXQgd3JpdGVfYnl0ZXMgPVxuICBsZXQgbGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGluXG4gIGxldCBibGl0ICAgPSBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdF9mcm9tX2J5dGVzIGluXG4gIGZ1biB0ID9vZmYgP2xlbiBhIC0+IHdyaXRlX2dlbiB0IH5sZW5ndGggfmJsaXQgP29mZiA/bGVuIGFcblxubGV0IHdyaXRlX2JpZ3N0cmluZyA9XG4gIGxldCBsZW5ndGggPSBCaWdzdHJpbmdhZi5sZW5ndGggaW5cbiAgbGV0IGJsaXQgICA9IEJpZ3N0cmluZ2FmLnVuc2FmZV9ibGl0IGluXG4gIGZ1biB0ID9vZmYgP2xlbiBhIC0+IHdyaXRlX2dlbiB0IH5sZW5ndGggfmJsaXQgP29mZiA/bGVuIGFcblxubGV0IHdyaXRlX2NoYXIgdCBjID1cbiAgd3JpdGFibGVfZXhuIHQ7XG4gIGVuc3VyZV9zcGFjZSB0IDE7XG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9zZXQgdC5idWZmZXIgdC53cml0ZV9wb3MgYztcbiAgdC53cml0ZV9wb3MgPC0gdC53cml0ZV9wb3MgKyAxXG5cbmxldCB3cml0ZV91aW50OCB0IGIgPVxuICB3cml0YWJsZV9leG4gdDtcbiAgZW5zdXJlX3NwYWNlIHQgMTtcbiAgQmlnc3RyaW5nYWYudW5zYWZlX3NldCB0LmJ1ZmZlciB0LndyaXRlX3BvcyAoQ2hhci51bnNhZmVfY2hyIGIpO1xuICB0LndyaXRlX3BvcyA8LSB0LndyaXRlX3BvcyArIDFcblxubW9kdWxlIEJFID0gc3RydWN0XG4gIGxldCB3cml0ZV91aW50MTYgdCBpID1cbiAgICB3cml0YWJsZV9leG4gdDtcbiAgICBlbnN1cmVfc3BhY2UgdCAyO1xuICAgIEJpZ3N0cmluZ2FmLnVuc2FmZV9zZXRfaW50MTZfYmUgdC5idWZmZXIgdC53cml0ZV9wb3MgaTtcbiAgICB0LndyaXRlX3BvcyA8LSB0LndyaXRlX3BvcyArIDJcblxuICBsZXQgd3JpdGVfdWludDMyIHQgaSA9XG4gICAgd3JpdGFibGVfZXhuIHQ7XG4gICAgZW5zdXJlX3NwYWNlIHQgNDtcbiAgICBCaWdzdHJpbmdhZi51bnNhZmVfc2V0X2ludDMyX2JlIHQuYnVmZmVyIHQud3JpdGVfcG9zIGk7XG4gICAgdC53cml0ZV9wb3MgPC0gdC53cml0ZV9wb3MgKyA0XG5cbiAgbGV0IHdyaXRlX3VpbnQ0OCB0IGkgPVxuICAgIHdyaXRhYmxlX2V4biB0O1xuICAgIGVuc3VyZV9zcGFjZSB0IDY7XG4gICAgQmlnc3RyaW5nYWYudW5zYWZlX3NldF9pbnQzMl9iZSB0LmJ1ZmZlciB0LndyaXRlX3Bvc1xuICAgICAgSW50NjQuKHRvX2ludDMyIChzaGlmdF9yaWdodF9sb2dpY2FsIGkgNCkpO1xuICAgIEJpZ3N0cmluZ2FmLnVuc2FmZV9zZXRfaW50MTZfYmUgdC5idWZmZXIgKHQud3JpdGVfcG9zICsgMilcbiAgICAgIEludDY0Lih0b19pbnQgaSk7XG4gICAgdC53cml0ZV9wb3MgPC0gdC53cml0ZV9wb3MgKyA2XG5cbiAgbGV0IHdyaXRlX3VpbnQ2NCB0IGkgPVxuICAgIHdyaXRhYmxlX2V4biB0O1xuICAgIGVuc3VyZV9zcGFjZSB0IDg7XG4gICAgQmlnc3RyaW5nYWYudW5zYWZlX3NldF9pbnQ2NF9iZSB0LmJ1ZmZlciB0LndyaXRlX3BvcyBpO1xuICAgIHQud3JpdGVfcG9zIDwtIHQud3JpdGVfcG9zICsgOFxuXG4gIGxldCB3cml0ZV9mbG9hdCB0IGYgPVxuICAgIHdyaXRhYmxlX2V4biB0O1xuICAgIGVuc3VyZV9zcGFjZSB0IDQ7XG4gICAgQmlnc3RyaW5nYWYudW5zYWZlX3NldF9pbnQzMl9iZSB0LmJ1ZmZlciB0LndyaXRlX3BvcyAoSW50MzIuYml0c19vZl9mbG9hdCBmKTtcbiAgICB0LndyaXRlX3BvcyA8LSB0LndyaXRlX3BvcyArIDRcblxuICBsZXQgd3JpdGVfZG91YmxlIHQgZCA9XG4gICAgd3JpdGFibGVfZXhuIHQ7XG4gICAgZW5zdXJlX3NwYWNlIHQgODtcbiAgICBCaWdzdHJpbmdhZi51bnNhZmVfc2V0X2ludDY0X2JlIHQuYnVmZmVyIHQud3JpdGVfcG9zIChJbnQ2NC5iaXRzX29mX2Zsb2F0IGQpO1xuICAgIHQud3JpdGVfcG9zIDwtIHQud3JpdGVfcG9zICsgOFxuZW5kXG5cbm1vZHVsZSBMRSA9IHN0cnVjdFxuICBsZXQgd3JpdGVfdWludDE2IHQgaSA9XG4gICAgd3JpdGFibGVfZXhuIHQ7XG4gICAgZW5zdXJlX3NwYWNlIHQgMjtcbiAgICBCaWdzdHJpbmdhZi51bnNhZmVfc2V0X2ludDE2X2xlIHQuYnVmZmVyIHQud3JpdGVfcG9zIGk7XG4gICAgdC53cml0ZV9wb3MgPC0gdC53cml0ZV9wb3MgKyAyXG5cbiAgbGV0IHdyaXRlX3VpbnQzMiB0IGkgPVxuICAgIHdyaXRhYmxlX2V4biB0O1xuICAgIGVuc3VyZV9zcGFjZSB0IDQ7XG4gICAgQmlnc3RyaW5nYWYudW5zYWZlX3NldF9pbnQzMl9sZSB0LmJ1ZmZlciB0LndyaXRlX3BvcyBpO1xuICAgIHQud3JpdGVfcG9zIDwtIHQud3JpdGVfcG9zICsgNFxuXG4gIGxldCB3cml0ZV91aW50NDggdCBpID1cbiAgICB3cml0YWJsZV9leG4gdDtcbiAgICBlbnN1cmVfc3BhY2UgdCA2O1xuICAgIEJpZ3N0cmluZ2FmLnVuc2FmZV9zZXRfaW50MTZfbGUgdC5idWZmZXIgdC53cml0ZV9wb3NcbiAgICAgIEludDY0Lih0b19pbnQgaSk7XG4gICAgQmlnc3RyaW5nYWYudW5zYWZlX3NldF9pbnQzMl9sZSB0LmJ1ZmZlciAodC53cml0ZV9wb3MgKyAyKVxuICAgICAgSW50NjQuKHRvX2ludDMyIChzaGlmdF9yaWdodF9sb2dpY2FsIGkgMikpO1xuICAgIHQud3JpdGVfcG9zIDwtIHQud3JpdGVfcG9zICsgNlxuXG4gIGxldCB3cml0ZV91aW50NjQgdCBpID1cbiAgICB3cml0YWJsZV9leG4gdDtcbiAgICBlbnN1cmVfc3BhY2UgdCA4O1xuICAgIEJpZ3N0cmluZ2FmLnVuc2FmZV9zZXRfaW50NjRfbGUgdC5idWZmZXIgdC53cml0ZV9wb3MgaTtcbiAgICB0LndyaXRlX3BvcyA8LSB0LndyaXRlX3BvcyArIDhcblxuICBsZXQgd3JpdGVfZmxvYXQgdCBmID1cbiAgICB3cml0YWJsZV9leG4gdDtcbiAgICBlbnN1cmVfc3BhY2UgdCA0O1xuICAgIEJpZ3N0cmluZ2FmLnVuc2FmZV9zZXRfaW50MzJfbGUgdC5idWZmZXIgdC53cml0ZV9wb3MgKEludDMyLmJpdHNfb2ZfZmxvYXQgZik7XG4gICAgdC53cml0ZV9wb3MgPC0gdC53cml0ZV9wb3MgKyA0XG5cbiAgbGV0IHdyaXRlX2RvdWJsZSB0IGQgPVxuICAgIHdyaXRhYmxlX2V4biB0O1xuICAgIGVuc3VyZV9zcGFjZSB0IDg7XG4gICAgQmlnc3RyaW5nYWYudW5zYWZlX3NldF9pbnQ2NF9sZSB0LmJ1ZmZlciB0LndyaXRlX3BvcyAoSW50NjQuYml0c19vZl9mbG9hdCBkKTtcbiAgICB0LndyaXRlX3BvcyA8LSB0LndyaXRlX3BvcyArIDhcbmVuZFxuXG5sZXQgY2xvc2UgdCA9XG4gIHQuY2xvc2VkIDwtIHRydWU7XG4gIGZsdXNoX2J1ZmZlciB0XG5cbmxldCBpc19jbG9zZWQgdCA9XG4gIHQuY2xvc2VkXG5cbmxldCBwZW5kaW5nX2J5dGVzIHQgPVxuICAodC53cml0ZV9wb3MgLSB0LnNjaGVkdWxlZF9wb3MpICsgKHQuYnl0ZXNfcmVjZWl2ZWQgLSB0LmJ5dGVzX3dyaXR0ZW4pXG5cbmxldCBoYXNfcGVuZGluZ19vdXRwdXQgdCA9XG4gIHBlbmRpbmdfYnl0ZXMgdCA8PiAwXG5cbmxldCB5aWVsZCB0ID1cbiAgdC55aWVsZCA8LSB0cnVlXG5cbmxldCByZWMgc2hpZnRfYnVmZmVycyB0IHdyaXR0ZW4gPVxuICBtYXRjaCBCdWZmZXJzLmRlcXVldWVfZXhuIHQuc2NoZWR1bGVkIHdpdGhcbiAgfCBleGNlcHRpb24gRGVxdWV1ZV9lbXB0eSAtPlxuICAgIGFzc2VydCAod3JpdHRlbiA9IDApO1xuICAgIGlmIHQuc2NoZWR1bGVkX3BvcyA9IHQud3JpdGVfcG9zIHRoZW4gYmVnaW5cbiAgICAgIHQuc2NoZWR1bGVkX3BvcyA8LSAwO1xuICAgICAgdC53cml0ZV9wb3MgPC0gMFxuICAgIGVuZFxuICB8IHsgbGVuOyBfIH0gYXMgaW92ZWMgLT5cbiAgICBpZiBsZW4gPD0gd3JpdHRlbiB0aGVuIGJlZ2luXG4gICAgICBzaGlmdF9idWZmZXJzIHQgKHdyaXR0ZW4gLSBsZW4pXG4gICAgZW5kIGVsc2VcbiAgICAgIEJ1ZmZlcnMuZW5xdWV1ZV9mcm9udCAoSU9WZWMuc2hpZnQgaW92ZWMgd3JpdHRlbikgdC5zY2hlZHVsZWRcblxubGV0IHJlYyBzaGlmdF9mbHVzaGVzIHQgfnJlYXNvbiA9XG4gIG1hdGNoIEZsdXNoZXMuZGVxdWV1ZV9leG4gdC5mbHVzaGVkIHdpdGhcbiAgfCBleGNlcHRpb24gRGVxdWV1ZV9lbXB0eSAtPiAoKVxuICB8ICh0aHJlc2hvbGQsIGYpIGFzIGZsdXNoIC0+XG4gICAgKCogRWRpdGVkIG5vdGVzIGZyb20gQGRpbm9zYXVyZTpcbiAgICAgKlxuICAgICAqIFRoZSBxdWFudGl0aWVzIFt0LmJ5dGVzX3dyaXR0ZW5dIGFuZCBbdGhyZXNob2xkXSBhcmUgYWx3YXlzIGdvaW5nIHRvIGJlXG4gICAgICogcG9zaXRpdmUgaW50ZWdlcnMuIFRoZXJlZm9yZSwgd2UgY2FuIHRyZWF0IHRoZW0gYXMgdW5zaW5nZWQgaW50ZWdlcnMgZm9yXG4gICAgICogdGhlIHB1cnBvc2VzIG9mIGNvbXBhcmlzaW9uLiBEb2luZyBzbyBhbGxvd3MgdXMgdG8gaGFuZGxlIG92ZXJmbG93cyBpblxuICAgICAqIGVpdGhlciBxdWFudGl0eSBhcyBsb25nIGFzIHRoZXkncmUgYm90aCB3aXRoaW4gb25lIG92ZXJmbG93IG9mIGVhY2ggb3RoZXIuXG4gICAgICogV2UgY2FuIGFjY29tcGxpc2ggdGhpcyBieSBzdWJyYWN0aW5nIFttaW5faW50XSBmcm9tIGJvdGggcXVhbnRpdGllcyBiZWZvcmVcbiAgICAgKiBjb21wYXJpc2lvbi4gVGhpcyBzaGlmdCBhIHF1YW50aXR5IHRoYXQgaGFzIG5vdCBvdmVyZmxvd2VkIGludG8gdGhlXG4gICAgICogbmVnYXRpdmUgaW50ZWdlciByYW5nZSB3aGlsZSBzaGlmdGluZyBhIHF1YW50aXR5IHRoYXQgaGFzIG92ZXJmbG93IGludG9cbiAgICAgKiB0aGUgcG9zaXRpdmUgaW50ZWdlciByYW5nZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZWZmZWN0aXZlbHkgcmVzdGFibGlzaGVzIHRoZSByZWxhdGl2ZSBkaWZmZXJlbmNlIHdoZW4gYW4gb3ZlcmZsb3dcbiAgICAgKiBoYXMgb2NjdXJyZWQsIGFuZCBvdGhlcndpc2UganVzdCBjb21wYXJlcyBudW1iZXJzIHRoYXQgaGF2ZW4ndFxuICAgICAqIG92ZXJmbG93ZWQgYXMgc2ltaWxhcmx5LCBqdXN0IHNoaWZ0ZWQgZG93biBhIGJpdC5cbiAgICAgKilcbiAgICBpZiB0LmJ5dGVzX3dyaXR0ZW4gLSBtaW5faW50ID49IHRocmVzaG9sZCAtIG1pbl9pbnRcbiAgICB0aGVuIGJlZ2luIGYgcmVhc29uOyBzaGlmdF9mbHVzaGVzIHQgfnJlYXNvbiBlbmRcbiAgICBlbHNlIEZsdXNoZXMuZW5xdWV1ZV9mcm9udCBmbHVzaCB0LmZsdXNoZWRcblxubGV0IHNoaWZ0X2ludGVybmFsIHQgd3JpdHRlbiB+cmVhc29uID1cbiAgc2hpZnRfYnVmZmVycyB0IHdyaXR0ZW47XG4gIHQuYnl0ZXNfd3JpdHRlbiA8LSB0LmJ5dGVzX3dyaXR0ZW4gKyB3cml0dGVuO1xuICBzaGlmdF9mbHVzaGVzIHQgfnJlYXNvblxuOztcblxubGV0IHNoaWZ0IHQgd3JpdHRlbiA9IHNoaWZ0X2ludGVybmFsIHQgd3JpdHRlbiB+cmVhc29uOlNoaWZ0XG5cbmxldCBvcGVyYXRpb24gdCA9XG4gIGlmIHQuY2xvc2VkIHRoZW4gYmVnaW5cbiAgICB0LnlpZWxkIDwtIGZhbHNlXG4gIGVuZDtcbiAgZmx1c2hfYnVmZmVyIHQ7XG4gIGxldCBub3RoaW5nX3RvX2RvID0gbm90IChoYXNfcGVuZGluZ19vdXRwdXQgdCkgaW5cbiAgaWYgdC5jbG9zZWQgJiYgbm90aGluZ190b19kbyB0aGVuXG4gICAgYENsb3NlXG4gIGVsc2UgaWYgdC55aWVsZCB8fCBub3RoaW5nX3RvX2RvIHRoZW4gYmVnaW5cbiAgICB0LnlpZWxkIDwtIGZhbHNlO1xuICAgIGBZaWVsZFxuICBlbmQgZWxzZSBiZWdpblxuICAgIGxldCBpb3ZlY3MgPSBCdWZmZXJzLm1hcF90b19saXN0IHQuc2NoZWR1bGVkIH5mOihmdW4geCAtPiB4KSBpblxuICAgIGBXcml0ZXYgaW92ZWNzXG4gIGVuZFxuXG5sZXQgcmVjIHNlcmlhbGl6ZSB0IHdyaXRldiA9XG4gIG1hdGNoIG9wZXJhdGlvbiB0IHdpdGhcbiAgfCBgV3JpdGV2IGlvdmVjcyAtPlxuICAgIGJlZ2luIG1hdGNoIHdyaXRldiBpb3ZlY3Mgd2l0aFxuICAgIHwgYE9rICAgbiAtPiBzaGlmdCB0IG47IGlmIG5vdCAoQnVmZmVycy5pc19lbXB0eSB0LnNjaGVkdWxlZCkgdGhlbiB5aWVsZCB0XG4gICAgfCBgQ2xvc2VkIC0+IGNsb3NlIHRcbiAgICBlbmQ7XG4gICAgc2VyaWFsaXplIHQgd3JpdGV2XG4gIHwgKGBDbG9zZXxgWWllbGQpIGFzIG5leHQgLT4gbmV4dFxuXG5sZXQgc2VyaWFsaXplX3RvX3N0cmluZyB0ID1cbiAgY2xvc2UgdDtcbiAgbWF0Y2ggb3BlcmF0aW9uIHQgd2l0aFxuICB8IGBXcml0ZXYgaW92ZWNzIC0+XG4gICAgbGV0IGxlbiA9IElPVmVjLmxlbmd0aHYgaW92ZWNzIGluXG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBwb3MgPSByZWYgMCBpblxuICAgIExpc3QuaXRlciAoZnVuY3Rpb25cbiAgICAgIHwgeyBidWZmZXI7IG9mZjsgbGVuIH0gLT5cbiAgICAgICAgQmlnc3RyaW5nYWYudW5zYWZlX2JsaXRfdG9fYnl0ZXMgYnVmZmVyIH5zcmNfb2ZmOm9mZiBieXRlcyB+ZHN0X29mZjohcG9zIH5sZW47XG4gICAgICAgIHBvcyA6PSAhcG9zICsgbGVuKVxuICAgIGlvdmVjcztcbiAgICBzaGlmdCB0IGxlbjtcbiAgICBhc3NlcnQgKG9wZXJhdGlvbiB0ID0gYENsb3NlKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ5dGVzXG4gIHwgYENsb3NlIC0+IFwiXCJcbiAgfCBgWWllbGQgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBzZXJpYWxpemVfdG9fYmlnc3RyaW5nIHQgPVxuICBjbG9zZSB0O1xuICBtYXRjaCBvcGVyYXRpb24gdCB3aXRoXG4gIHwgYFdyaXRldiBpb3ZlY3MgLT5cbiAgICBsZXQgbGVuID0gSU9WZWMubGVuZ3RodiBpb3ZlY3MgaW5cbiAgICBsZXQgYnMgPSBCaWdzdHJpbmdhZi5jcmVhdGUgbGVuIGluXG4gICAgbGV0IHBvcyA9IHJlZiAwIGluXG4gICAgTGlzdC5pdGVyIChmdW5jdGlvblxuICAgICAgfCB7IGJ1ZmZlcjsgb2ZmOyBsZW4gfSAtPlxuICAgICAgICBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdCBidWZmZXIgfnNyY19vZmY6b2ZmIGJzIH5kc3Rfb2ZmOiFwb3MgfmxlbjtcbiAgICAgICAgcG9zIDo9ICFwb3MgKyBsZW4pXG4gICAgaW92ZWNzO1xuICAgIHNoaWZ0IHQgbGVuO1xuICAgIGFzc2VydCAob3BlcmF0aW9uIHQgPSBgQ2xvc2UpO1xuICAgIGJzXG4gIHwgYENsb3NlIC0+IEJpZ3N0cmluZ2FmLmNyZWF0ZSAwXG4gIHwgYFlpZWxkIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgZHJhaW4gPVxuICBsZXQgcmVjIGxvb3AgdCBhY2MgPVxuICAgIG1hdGNoIG9wZXJhdGlvbiB0IHdpdGhcbiAgICB8IGBXcml0ZXYgaW92ZWNzIC0+XG4gICAgICBsZXQgbGVuID0gSU9WZWMubGVuZ3RodiBpb3ZlY3MgaW5cbiAgICAgIHNoaWZ0X2ludGVybmFsIHQgbGVuIH5yZWFzb246RHJhaW47XG4gICAgICBsb29wIHQgKGxlbiArIGFjYylcbiAgICB8IGBDbG9zZSAgICAgICAgIC0+IGFjY1xuICAgIHwgYFlpZWxkICAgICAgICAgLT4gbG9vcCB0IGFjY1xuICBpblxuICBmdW4gdCAtPiBsb29wIHQgMFxuIl19
