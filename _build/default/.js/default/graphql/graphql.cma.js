// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Graphql_schema
//# unitInfo: Requires: CamlinternalLazy, Rresult, Stdlib, Stdlib__Format, Stdlib__List, Stdlib__Map, Stdlib__Printf, Stdlib__Set, Stdlib__String, Yojson__Basic
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_is_not_defined_on_type = "' is not defined on type '",
    cst$3 = ", ",
    cst_Boolean$1 = "Boolean",
    cst_Field$0 = "Field '",
    cst_Field_s_is_not_defined_on_ = "Field '%s' is not defined on type '%s'",
    cst_Float$1 = "Float",
    cst_ID$1 = "ID",
    cst_Int$1 = "Int",
    cst_String$1 = "String",
    cst_s = "[%s]",
    cst_typename = "__typename",
    cst_on_field = "` on field `",
    cst_args$1 = "args",
    cst_data$2 = "data",
    cst_deprecationReason$1 = "deprecationReason",
    cst_description$4 = "description",
    cst_errors$1 = "errors",
    cst_if$1 = "if",
    cst_include$0 = "include",
    cst_isDeprecated$1 = "isDeprecated",
    cst_name$5 = "name",
    cst_skip$0 = "skip",
    cst_type$2 = "type",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$3,
    cst = cst$3,
    cst$0 = cst$3,
    cst$1 = "",
    partial = [12, 46, 0],
    type_kind =
      [4,
       [0,
        "__TypeKind",
        0,
        [0,
         [0, "SCALAR", 0, 0, -256222388],
         [0,
          [0, "OBJECT", 0, 0, -908856609],
          [0,
           [0, "INTERFACE", 0, 0, -609414759],
           [0,
            [0, "UNION", 0, 0, 974443759],
            [0,
             [0, "ENUM", 0, 0, 770676513],
             [0,
              [0, "INPUT_OBJECT", 0, 0, -291114423],
              [0,
               [0, "LIST", 0, 0, 848054398],
               [0, [0, "NON_NULL", 0, 0, 388158996], 0]]]]]]]]]],
    directive_location =
      [4,
       [0,
        "__DirectiveLocation",
        0,
        [0,
         [0, "QUERY", 0, 0, -250086680],
         [0,
          [0, "MUTATION", 0, 0, 1035765577],
          [0,
           [0, "SUBSCRIPTION", 0, 0, -32289987],
           [0,
            [0, "FIELD", 0, 0, 331416730],
            [0,
             [0, "FRAGMENT_DEFINITION", 0, 0, 342305986],
             [0,
              [0, "FRAGMENT_SPREAD", 0, 0, -861465054],
              [0,
               [0, "INLINE_FRAGMENT", 0, 0, 962724246],
               [0, [0, "VARIABLE_DEFINITION", 0, 0, -1013253674], 0]]]]]]]]]],
    Stdlib_Format = global_data.Stdlib__Format,
    Rresult = global_data.Rresult,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Yojson_Basic = global_data.Yojson__Basic,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Set = global_data.Stdlib__Set,
    Stdlib_List = global_data.Stdlib__List,
    cons = Stdlib_List[5],
    rev = Stdlib_List[10],
    append = Stdlib_List[12],
    concat = Stdlib_List[14],
    iter = Stdlib_List[18],
    map = Stdlib_List[20],
    mapi = Stdlib_List[21],
    fold_left = Stdlib_List[26],
    exists = Stdlib_List[34],
    find_exn = Stdlib_List[39],
    filter = Stdlib_List[44],
    partition = Stdlib_List[47],
    assoc_exn = Stdlib_List[49],
    _D_ = [0, [11, "Unknown directive: ", [2, 0, 0]], "Unknown directive: %s"],
    _E_ = [0, 1],
    _F_ = [0, 0],
    _G_ = [0, "directive"],
    _J_ = [0, 0],
    _H_ = [0, 0],
    _I_ = [0, 0],
    _K_ = [0, 0],
    _N_ = [0, 870828711, 0],
    _O_ =
      [0,
       [11,
        cst_Field$0,
        [2, 0, [11, cst_is_not_defined_on_type, [2, 0, [12, 39, 0]]]]],
       cst_Field_s_is_not_defined_on_],
    _U_ =
      [0,
       [11, "Fragment cycle detected: ", [2, 0, 0]],
       "Fragment cycle detected: %s"],
    _V_ = [1, -1002274466],
    _W_ = [1, -784750693],
    _X_ = [1, 80281036],
    _T_ =
      [0,
       [11,
        cst_Field$0,
        [2, 0, [11, cst_is_not_defined_on_type, [2, 0, [12, 39, 0]]]]],
       cst_Field_s_is_not_defined_on_],
    _S_ =
      [0,
       -560894942,
       "Subscriptions only allow exactly one selection for the operation."],
    _R_ = [0, 0],
    cst_Mutations_not_configured = "Mutations not configured",
    cst_Subscriptions_not_configur = "Subscriptions not configured",
    cst_No_operation_found = "No operation found",
    cst_Operation_not_found = "Operation not found",
    cst_Operation_name_required = "Operation name required",
    _P_ = [0, 870828711],
    _Q_ = [0, 870828711],
    cst_data$0 = cst_data$2,
    cst_errors$0 = cst_errors$1,
    cst_data$1 = cst_data$2,
    cst_errors = cst_errors$1,
    cst_data = cst_data$2,
    cst_path = "path",
    cst_extensions = "extensions",
    cst_message = "message",
    _M_ = [0, 0],
    _L_ = [0, 870828711, 0],
    cst_Abstracts_can_t_have_argum = "Abstracts can't have argument types",
    cst_schema = "__schema",
    cst_name$4 = cst_name$5,
    cst_type$1 = "__type",
    cst_directives = "directives",
    cst_subscriptionType = "subscriptionType",
    cst_mutationType = "mutationType",
    cst_queryType = "queryType",
    cst_types = "types",
    cst_args$0 = cst_args$1,
    cst_locations = "locations",
    cst_description$3 = cst_description$4,
    cst_name$3 = cst_name$5,
    cst_deprecationReason$0 = cst_deprecationReason$1,
    cst_isDeprecated$0 = cst_isDeprecated$1,
    cst_type$0 = cst_type$2,
    cst_args = cst_args$1,
    cst_description$2 = cst_description$4,
    cst_name$2 = cst_name$5,
    cst_enumValues = "enumValues",
    cst_inputFields = "inputFields",
    cst_ofType = "ofType",
    cst_possibleTypes = "possibleTypes",
    cst_interfaces = "interfaces",
    cst_fields = "fields",
    cst_description$1 = cst_description$4,
    cst_name$1 = cst_name$5,
    cst_kind = "kind",
    cst_defaultValue = "defaultValue",
    cst_type = cst_type$2,
    cst_description$0 = cst_description$4,
    cst_name$0 = cst_name$5,
    cst_deprecationReason = cst_deprecationReason$1,
    cst_isDeprecated = cst_isDeprecated$1,
    cst_description = cst_description$4,
    cst_name = cst_name$5,
    cst_Arguments_must_be_Interfac =
      "Arguments must be Interface/Union and Object",
    cst_mutation = "mutation",
    cst_subscription = "subscription",
    cst_query = "query",
    _a_ = [0, [2, 0, [11, ": ", [2, 0, 0]]], "%s: %s"],
    _b_ = [0, [12, 123, [2, 0, [12, 125, 0]]], "{%s}"],
    _c_ = [0, [12, 91, [2, 0, [12, 93, 0]]], cst_s],
    _d_ = [0, [12, 91, [2, 0, [12, 93, 0]]], cst_s],
    _e_ = [0, [2, 0, [12, 33, 0]], "%s!"],
    _m_ = [0, 0],
    _n_ = [0, 0],
    _o_ = [0, 0],
    _p_ = [0, 0],
    _q_ = [0, 0],
    _s_ =
      [0,
       [11,
        "Invalid enum value for argument `",
        [2, 0, [11, cst_on_field, [2, 0, [12, 96, 0]]]]],
       "Invalid enum value for argument `%s` on field `%s`"],
    _r_ =
      [0,
       [11,
        "Expected enum for argument `",
        [2, 0, [11, cst_on_field, [2, 0, [12, 96, 0]]]]],
       "Expected enum for argument `%s` on field `%s`"],
    _t_ = [0, 0],
    _u_ = [0, 0],
    _v_ = [0, 0],
    _w_ =
      [0,
       [11,
        "Invalid default provided for arg name=",
        [2, 0, [11, ", default=", [2, 0, 0]]]],
       "Invalid default provided for arg name=%s, default=%s"],
    _l_ = [1, "Invalid ID"],
    _k_ = [1, "Invalid boolean"],
    _j_ = [1, "Invalid float"],
    _i_ = [1, "Invalid string"],
    _h_ = [1, "Invalid int"],
    cst_field = "field",
    _f_ = [0, [11, "found ", [2, 0, 0]], "found %s"],
    cst_but_not_provided = "but not provided",
    _g_ =
      [0,
       [11,
        "Argument `",
        [2,
         0,
         [11,
          "` of type `",
          [2,
           0,
           [11,
            "` expected on ",
            [2, 0, [11, " `", [2, 0, [11, "`, ", [2, 0, partial]]]]]]]]]],
       "Argument `%s` of type `%s` expected on %s `%s`, %s."],
    cst_Graphql_schema_Make_Io_Fie =
      "Graphql_schema.Make(Io)(Field_error).StringMap.Missing_key",
    cst_Int = cst_Int$1,
    cst_String = cst_String$1,
    cst_Float = cst_Float$1,
    cst_Boolean = cst_Boolean$1,
    cst_ID = cst_ID$1,
    cst_Int$0 = cst_Int$1,
    cst_String$0 = cst_String$1,
    cst_Boolean$0 = cst_Boolean$1,
    cst_Float$0 = cst_Float$1,
    cst_ID$0 = cst_ID$1,
    cst_if = cst_if$1,
    _x_ = [0, "Skipped when true."],
    _y_ = [0, 331416730, [0, -861465054, [0, 962724246, 0]]],
    _z_ =
      [0,
       "Directs the executor to skip this field or fragment when the `if` argument is true."],
    cst_skip = cst_skip$0,
    cst_if$0 = cst_if$1,
    _A_ = [0, "Included when true."],
    _B_ = [0, 331416730, [0, -861465054, [0, 962724246, 0]]],
    _C_ =
      [0,
       "Directs the executor to include this field or fragment only when the `if` argument is true."],
    cst_include = cst_include$0,
    cst_EnumValue = "__EnumValue",
    cst_InputValue = "__InputValue",
    cst_Type = "__Type",
    cst_Field = "__Field",
    cst_Directive = "__Directive",
    cst_Schema = "__Schema",
    cst_Graphql_schema_Make_Io_Fie$0 =
      "Graphql_schema.Make(Io)(Field_error).FragmentCycle";
   function find(cond, xs){
    try{var _eV_ = [0, caml_call2(find_exn, cond, xs)]; return _eV_;}
    catch(_eW_){
     var _eU_ = caml_wrap_exception(_eW_);
     if(_eU_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_eU_, 0);
    }
   }
   function join(opt, param){
    var opt$0 = opt, param$0 = param;
    for(;;){
     if(opt$0) var sth = opt$0[1], memo = sth; else var memo = 0;
     if(! param$0) return [0, caml_call1(Stdlib_List[10], memo)];
     var err = param$0[1];
     if(0 !== err[0]) return err;
     var
      xs = param$0[2],
      x = err[1],
      opt$1 = [0, [0, x, memo]],
      opt$0 = opt$1,
      param$0 = xs;
    }
   }
   function map$0(t, f){
    if(! t) return 0;
    var y = t[1];
    return [0, caml_call1(f, y)];
   }
   function Make(Io, Field_error){
    var return$0 = Io[1], bind = Io[2], Stream = Io[3];
    function map$1(x, f){
     return caml_call2
             (bind,
              x,
              function(x){return caml_call1(return$0, caml_call1(f, x));});
    }
    function ok(x){return caml_call1(Io[1], [0, x]);}
    function error(x){return caml_call1(Io[1], [1, x]);}
    function all(param){
     if(! param) return caml_call1(Io[1], 0);
     var xs = param[2], x = param[1];
     function _eT_(xs){return map$1(x, function(x){return [0, x, xs];});}
     return caml_call2(bind, all(xs), _eT_);
    }
    function bind$0(x, f){
     return caml_call2
             (bind,
              x,
              function(err){
               if(0 !== err[0]) return caml_call1(Io[1], err);
               var x = err[1];
               return caml_call1(f, x);
              });
    }
    function map_error(x, f){
     return map$1
             (x,
              function(ok){
               if(0 === ok[0]) return ok;
               var err = ok[1];
               return [1, caml_call1(f, err)];
              });
    }
    function map$2(x, f){
     return map$1
             (x,
              function(err){
               if(0 !== err[0]) return err;
               var x = err[1];
               return [0, caml_call1(f, x)];
              });
    }
    var Result = [0, bind$0, map_error, map$2];
    function map_s(opt, f, param){
     if(opt) var sth = opt[1], memo = sth; else var memo = 0;
     if(param){
      var
       xs = param[2],
       x = param[1],
       _eR_ = function(x){return map_s([0, [0, x, memo]], f, xs);};
      return caml_call2(bind, caml_call1(f, x), _eR_);
     }
     var _eS_ = caml_call1(rev, memo);
     return caml_call1(Io[1], _eS_);
    }
    function map_p(f, xs){return all(caml_call2(map, f, xs));}
    function symbol_map(x, f){return map$1(x, f);}
    var
     symbol = Result[1],
     Infix = [0, symbol_map, symbol],
     Io$0 =
       [0,
        return$0,
        bind,
        Stream,
        map$1,
        ok,
        error,
        all,
        Result,
        map_s,
        map_p,
        Infix],
     include = caml_call1(Stdlib_Map[1], [0, Stdlib_String[10]]),
     empty = include[1],
     add = include[2],
     add_to_list = include[3],
     update = include[4],
     singleton = include[5],
     remove = include[6],
     merge = include[7],
     union = include[8],
     cardinal = include[9],
     bindings = include[10],
     min_binding = include[11],
     min_binding_opt = include[12],
     max_binding = include[13],
     max_binding_opt = include[14],
     choose = include[15],
     choose_opt = include[16],
     find_opt = include[18],
     find_first = include[19],
     find_first_opt = include[20],
     find_last = include[21],
     find_last_opt = include[22],
     iter$0 = include[23],
     fold = include[24],
     map$3 = include[25],
     mapi$0 = include[26],
     filter$0 = include[27],
     filter_map = include[28],
     partition$0 = include[29],
     split = include[30],
     is_empty = include[31],
     mem = include[32],
     equal = include[33],
     compare = include[34],
     for_all = include[35],
     exists$0 = include[36],
     to_list = include[37],
     of_list = include[38],
     to_seq = include[39],
     to_rev_seq = include[40],
     to_seq_from = include[41],
     add_seq = include[42],
     of_seq = include[43],
     Missing_key = [248, cst_Graphql_schema_Make_Io_Fie, caml_fresh_oo_id(0)],
     _ab_ = include[17];
    function find_exn$0(key, t){
     try{var _eP_ = caml_call2(_ab_, key, t); return _eP_;}
     catch(_eQ_){
      var _eO_ = caml_wrap_exception(_eQ_);
      if(_eO_ === Stdlib[8])
       throw caml_maybe_attach_backtrace([0, Missing_key, key], 1);
      throw caml_maybe_attach_backtrace(_eO_, 0);
     }
    }
    function find$0(k, t){
     try{var _eM_ = [0, find_exn$0(k, t)]; return _eM_;}
     catch(_eN_){
      var _eL_ = caml_wrap_exception(_eN_);
      if(_eL_[1] === Missing_key) return 0;
      throw caml_maybe_attach_backtrace(_eL_, 0);
     }
    }
    var
     StringMap =
       [0,
        empty,
        add,
        add_to_list,
        update,
        singleton,
        remove,
        merge,
        union,
        cardinal,
        bindings,
        min_binding,
        min_binding_opt,
        max_binding,
        max_binding_opt,
        choose,
        choose_opt,
        find_opt,
        find_first,
        find_first_opt,
        find_last,
        find_last_opt,
        iter$0,
        fold,
        map$3,
        mapi$0,
        filter$0,
        filter_map,
        partition$0,
        split,
        is_empty,
        mem,
        equal,
        compare,
        for_all,
        exists$0,
        to_list,
        of_list,
        to_seq,
        to_rev_seq,
        to_seq_from,
        add_seq,
        of_seq,
        Missing_key,
        find_exn$0,
        find$0],
     StringSet = caml_call1(Stdlib_Set[1], [0, Stdlib_String[10]]);
    function enum_value(doc, opt, name, value){
     if(opt) var sth = opt[1], deprecated = sth; else var deprecated = 0;
     return [0, name, doc, deprecated, value];
    }
    function id(x){return x;}
    function fix(f){
     var recursive = [], r = [];
     caml_update_dummy
      (recursive,
       [0,
        function(doc, name, fields){
         var
          _eG_ =
            [246,
             function(_eI_){
              var _eJ_ = caml_obj_tag(r);
              a:
              if(250 === _eJ_)
               var _eK_ = r[1];
              else{
               if(246 !== _eJ_ && 244 !== _eJ_){var _eK_ = r; break a;}
               var _eK_ = caml_call1(CamlinternalLazy[2], r);
              }
              return caml_call1(fields, _eK_);
             }];
         return function(_eH_){return [1, name, doc, _eG_, _eH_];};
        }]);
     caml_update_dummy
      (r, [246, function(_eF_){return caml_call1(f, recursive);}]);
     var _eE_ = caml_obj_tag(r);
     if(250 === _eE_) return r[1];
     if(246 !== _eE_ && 244 !== _eE_) return r;
     return caml_call1(CamlinternalLazy[2], r);
    }
    function string_of_const_value(param){
     if(typeof param === "number")
      return caml_call5(Yojson_Basic[1], 0, 0, 0, 0, 870828711);
     var _eA_ = param[1];
     if(737456202 > _eA_){
      if(3654863 === _eA_){
       var i = param[2];
       return caml_call5(Yojson_Basic[1], 0, 0, 0, 0, [0, 3654863, i]);
      }
      if(365180284 <= _eA_){
       var f = param[2];
       return caml_call5(Yojson_Basic[1], 0, 0, 0, 0, [0, 365180284, f]);
      }
      var s = param[2];
      return caml_call5(Yojson_Basic[1], 0, 0, 0, 0, [0, -976970511, s]);
     }
     if(848054398 <= _eA_){
      if(963043957 <= _eA_){
       var
        a = param[2],
        values =
          caml_call2
           (map,
            function(param){
             var v = param[2], k = param[1], _eD_ = string_of_const_value(v);
             return caml_call3(Stdlib_Printf[4], _a_, k, _eD_);
            },
            a),
        _eB_ = caml_call2(Stdlib_String[7], cst, values);
       return caml_call2(Stdlib_Printf[4], _b_, _eB_);
      }
      var
       l = param[2],
       values$0 =
         caml_call2(map, function(i){return string_of_const_value(i);}, l),
       _eC_ = caml_call2(Stdlib_String[7], cst$0, values$0);
      return caml_call2(Stdlib_Printf[4], _c_, _eC_);
     }
     if(770676513 <= _eA_){var e = param[2]; return e;}
     var b = param[2];
     return caml_call5(Yojson_Basic[1], 0, 0, 0, 0, [0, 737456202, b]);
    }
    function string_of_arg_typ(param){
     switch(param[0]){
       case 0:
        return param[1];
       case 1:
        return param[1];
       case 2:
        return param[1];
       case 3:
        var a = param[1], _ey_ = string_of_arg_typ(a);
        return caml_call2(Stdlib_Printf[4], _d_, _ey_);
       default:
        var a$0 = param[1], _ez_ = string_of_arg_typ(a$0);
        return caml_call2(Stdlib_Printf[4], _e_, _ez_);
     }
    }
    function eval_arg_error(opt, field_name, arg_name, arg_typ, value){
     if(opt)
      var sth = opt[1], field_type = sth;
     else
      var field_type = cst_field;
     if(value)
      var
       v = value[1],
       _ew_ = string_of_const_value(v),
       found_str = caml_call2(Stdlib_Printf[4], _f_, _ew_);
     else
      var found_str = cst_but_not_provided;
     var _ex_ = string_of_arg_typ(arg_typ);
     return caml_call6
             (Stdlib_Printf[4],
              _g_,
              arg_name,
              _ex_,
              field_type,
              field_name,
              found_str);
    }
    var
     int$0 =
       [0,
        cst_Int,
        0,
        function(param){
         if(typeof param !== "number" && 3654863 === param[1]){var n = param[2]; return [0, n];}
         return _h_;
        }],
     string =
       [0,
        cst_String,
        0,
        function(param){
         if(typeof param !== "number" && -976970511 === param[1]){var s = param[2]; return [0, s];}
         return _i_;
        }],
     float$0 =
       [0,
        cst_Float,
        0,
        function(param){
         if(typeof param !== "number"){
          var _ev_ = param[1];
          if(3654863 === _ev_){var n = param[2]; return [0, n];}
          if(365180284 === _ev_){var f = param[2]; return [0, f];}
         }
         return _j_;
        }],
     bool =
       [0,
        cst_Boolean,
        0,
        function(param){
         if(typeof param !== "number" && 737456202 === param[1]){var b = param[2]; return [0, b];}
         return _k_;
        }],
     guid =
       [0,
        cst_ID,
        0,
        function(param){
         if(typeof param !== "number"){
          var _eu_ = param[1];
          if(-976970511 === _eu_){var s = param[2]; return [0, s];}
          if(3654863 === _eu_){
           var n = param[2];
           return [0, caml_call1(Stdlib[33], n)];
          }
         }
         return _l_;
        }];
    function non_null(typ){return [4, typ];}
    function list(typ){return [3, typ];}
    function value_to_const_value(variable_map, i){
     if(typeof i === "number") return 870828711;
     var _es_ = i[1];
     if(737456202 > _es_){
      if(3654863 <= _es_) return 365180284 <= _es_ ? i : i;
      if(-976970511 <= _es_) return i;
      var
       v = i[2],
       t = caml_call2(StringMap[45], v, variable_map),
       default$0 = 870828711;
      if(! t) return default$0;
      var x = t[1];
      return x;
     }
     if(848054398 > _es_) return 770676513 <= _es_ ? i : i;
     if(963043957 <= _es_){
      var
       props = i[2],
       props$0 =
         caml_call2
          (map,
           function(param){
            var value = param[2], name = param[1];
            return [0, name, value_to_const_value(variable_map, value)];
           },
           props);
      return [0, 963043957, props$0];
     }
     var xs = i[2];
     return [0,
             848054398,
             caml_call2
              (map,
               function(_et_){
                return value_to_const_value(variable_map, _et_);
               },
               xs)];
    }
    function eval_arglist
    (variable_map, field_type, field_name, arglist, key_values, f){
     var arglist$0 = arglist, f$0 = f;
     for(;;){
      if(! arglist$0) return [0, f$0];
      var match = arglist$0[1];
      if(0 === match[0]){
       var arglist$1 = arglist$0[2], x = match[1];
       try{var _en_ = [0, caml_call2(assoc_exn, x, key_values)], value = _en_;
       }
       catch(_er_){
        var _em_ = caml_wrap_exception(_er_);
        if(_em_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_em_, 0);
        var value = 0;
       }
       var
        const_value =
          map$0
           (value,
            function(_eq_){return value_to_const_value(variable_map, _eq_);}),
        _eo_ =
          function(coerced){
           return eval_arglist
                   (variable_map,
                    field_type,
                    field_name,
                    arglist$1,
                    key_values,
                    caml_call1(f$0, coerced));
          },
        _ep_ =
          eval_arg
           (variable_map,
            field_type,
            field_name,
            match[1],
            match[3],
            const_value);
       return caml_call2(Rresult[1], _ep_, _eo_);
      }
      var
       arglist$2 = arglist$0[2],
       arglist$3 = [0, [0, match[1], match[2], match[3]], arglist$2],
       f$2 =
         function(f, match){
          function f$0(param){
           if(! param) return caml_call1(f, match[4]);
           var value = param[1];
           return caml_call1(f, value);
          }
          return f$0;
         },
       f$1 = f$2(f$0, match),
       arglist$0 = arglist$3,
       f$0 = f$1;
     }
    }
    function eval_arg
    (variable_map, field_type, field_name, arg_name, typ, value){
     switch(typ[0]){
       case 0:
        if(! value) return _n_;
        var value$0 = value[1];
        if(typeof value$0 === "number" && 870828711 === value$0) return _m_;
        var match = caml_call1(typ[3], value$0);
        if(0 !== match[0])
         return [1,
                 eval_arg_error
                  (field_type, field_name, arg_name, typ, [0, value$0])];
        var coerced = match[1];
        return [0, [0, coerced]];
       case 1:
        if(! value) return _p_;
        var value$1 = value[1];
        if(typeof value$1 === "number" && 870828711 === value$1) return _o_;
        if(typeof value$1 !== "number" && 963043957 === value$1[1]){
         var
          props = value$1[2],
          _d9_ = function(coerced){return [0, coerced];},
          _d$_ = typ[3],
          _d__ = typ[4],
          _ea_ = caml_obj_tag(_d$_);
         a:
         if(250 === _ea_)
          var _eb_ = _d$_[1];
         else{
          if(246 !== _ea_ && 244 !== _ea_){var _eb_ = _d$_; break a;}
          var _eb_ = caml_call1(CamlinternalLazy[2], _d$_);
         }
         var
          _ec_ =
            eval_arglist
             (variable_map, field_type, field_name, _eb_, props, _d__);
         return caml_call2(Rresult[2], _ec_, _d9_);
        }
        return [1,
                eval_arg_error
                 (field_type, field_name, arg_name, typ, [0, value$1])];
       case 2:
        if(! value) return _t_;
        var value$2 = value[1];
        if(typeof value$2 === "number" && 870828711 === value$2) return _q_;
        a:
        if(typeof value$2 !== "number"){
         var _ed_ = value$2[1];
         if(-976970511 !== _ed_ && 770676513 !== _ed_) break a;
         var
          v = value$2[2],
          _ee_ = typ[3],
          match$0 =
            find
             (function(enum_value){
               return caml_string_equal(enum_value[1], v);
              },
              _ee_);
         if(! match$0)
          return [1, caml_call3(Stdlib_Printf[4], _s_, arg_name, field_name)];
         var enum_value = match$0[1];
         return [0, [0, enum_value[4]]];
        }
        return [1, caml_call3(Stdlib_Printf[4], _r_, arg_name, field_name)];
       case 3:
        var typ$0 = typ[1];
        if(! value) return _v_;
        var value$3 = value[1];
        if(typeof value$3 === "number" && 870828711 === value$3) return _u_;
        if(typeof value$3 !== "number" && 848054398 === value$3[1]){
         var
          values = value$3[2],
          option_values = caml_call2(map, function(x){return [0, x];}, values),
          _eh_ = function(coerced){return [0, coerced];},
          f =
            function(_el_){
             return eval_arg
                     (variable_map,
                      field_type,
                      field_name,
                      arg_name,
                      typ$0,
                      _el_);
            },
          _d8_ = join(0, caml_call2(Stdlib_List[20], f, option_values));
         return caml_call2(Rresult[2], _d8_, _eh_);
        }
        var
         _ef_ = function(coerced){return [0, [0, coerced, 0]];},
         _eg_ =
           eval_arg
            (variable_map,
             field_type,
             field_name,
             arg_name,
             typ$0,
             [0, value$3]);
        return caml_call2(Rresult[2], _eg_, _ef_);
       default:
        var typ$1 = typ[1];
        if(! value)
         return [1,
                 eval_arg_error(field_type, field_name, arg_name, typ, value)];
        var _ei_ = value[1];
        if(typeof _ei_ === "number" && 870828711 === _ei_)
         return [1,
                 eval_arg_error(field_type, field_name, arg_name, typ, value)];
        var
         _ej_ =
           function(param){
            if(! param)
             return [1,
                     eval_arg_error(field_type, field_name, arg_name, typ$1, 0)];
            var value = param[1];
            return [0, value];
           },
         _ek_ =
           eval_arg
            (variable_map, field_type, field_name, arg_name, typ$1, value);
        return caml_call2(Rresult[1], _ek_, _ej_);
     }
    }
    function arg(doc, name, typ){return [0, name, doc, typ];}
    function arg$0(doc, name, typ, default$0){
     var match = eval_arg(StringMap[1], 0, cst$1, name, typ, [0, default$0]);
     if(0 === match[0]){
      var match$0 = match[1];
      if(match$0){
       var v = match$0[1];
       return [1, name, doc, typ, v, default$0];
      }
     }
     var
      _d6_ = string_of_const_value(default$0),
      _d7_ = caml_call3(Stdlib_Printf[4], _w_, name, _d6_);
     throw caml_maybe_attach_backtrace([0, Stdlib[7], _d7_], 1);
    }
    function scalar(doc, name, coerce){return [0, name, doc, coerce];}
    function enum$0(doc, name, values){return [2, name, doc, values];}
    function obj(doc, name, fields, coerce){return [1, name, doc, fields, coerce];
    }
    var
     Arg =
       [0,
        fix,
        string_of_const_value,
        string_of_arg_typ,
        eval_arg_error,
        int$0,
        string,
        float$0,
        bool,
        guid,
        non_null,
        list,
        value_to_const_value,
        eval_arglist,
        eval_arg,
        arg,
        arg$0,
        scalar,
        enum$0,
        obj];
    function _ac_(doc, name, fields){
     return [0, [0, name, doc, fields, [0, 0]]];
    }
    function union$0(doc, name){return [5, [0, name, doc, 974443759, 0]];}
    function interface$0(doc, name, fields){
     var i = [], _d4_ = 0;
     caml_update_dummy
      (i,
       [5,
        [0,
         name,
         doc,
         [0, -609414759, [246, function(_d5_){return caml_call1(fields, i);}]],
         _d4_]]);
     return i;
    }
    function fix$0(f){
     var recursive = [], r = [];
     function _dU_(doc, name, fields){
      var _d0_ = 0;
      return [5,
              [0,
               name,
               doc,
               [0,
                -609414759,
                [246,
                 function(_d1_){
                  var _d2_ = caml_obj_tag(r);
                  a:
                  if(250 === _d2_)
                   var _d3_ = r[1];
                  else{
                   if(246 !== _d2_ && 244 !== _d2_){var _d3_ = r; break a;}
                   var _d3_ = caml_call1(CamlinternalLazy[2], r);
                  }
                  return caml_call1(fields, _d3_);
                 }]],
               _d0_]];
     }
     caml_update_dummy
      (recursive,
       [0,
        function(doc, name, fields){
         return _ac_
                 (doc,
                  name,
                  [246,
                   function(_dX_){
                    var _dY_ = caml_obj_tag(r);
                    a:
                    if(250 === _dY_)
                     var _dZ_ = r[1];
                    else{
                     if(246 !== _dY_ && 244 !== _dY_){var _dZ_ = r; break a;}
                     var _dZ_ = caml_call1(CamlinternalLazy[2], r);
                    }
                    return caml_call1(fields, _dZ_);
                   }]);
        },
        _dU_]);
     caml_update_dummy
      (r, [246, function(_dW_){return caml_call1(f, recursive);}]);
     var _dV_ = caml_obj_tag(r);
     if(250 === _dV_) return r[1];
     if(246 !== _dV_ && 244 !== _dV_) return r;
     return caml_call1(CamlinternalLazy[2], r);
    }
    function schema(opt, mutations, _dS_, subscriptions, _dR_, fields){
     if(opt)
      var sth = opt[1], mutation_name = sth;
     else
      var mutation_name = cst_mutation;
     if(_dS_)
      var sth$0 = _dS_[1], subscription_name = sth$0;
     else
      var subscription_name = cst_subscription;
     if(_dR_)
      var sth$1 = _dR_[1], query_name = sth$1;
     else
      var query_name = cst_query;
     var
      _dT_ =
        map$0
         (subscriptions,
          function(fields){return [0, subscription_name, 0, fields];});
     return [0,
             [0, query_name, 0, fields, [0, 0]],
             map$0
              (mutations,
               function(fields){return [0, mutation_name, 0, fields, [0, 0]];}),
             _dT_];
    }
    function obj$0(doc, name, fields){return _ac_(doc, name, fields);}
    function field(doc, opt, name, typ, args, resolve){
     if(opt) var sth = opt[1], deprecated = sth; else var deprecated = 0;
     return [0, name, doc, deprecated, typ, args, resolve, Io$0[5]];
    }
    function io_field(doc, opt, name, typ, args, resolve){
     if(opt) var sth = opt[1], deprecated = sth; else var deprecated = 0;
     return [0, name, doc, deprecated, typ, args, resolve, id];
    }
    function abstract_field(doc, opt, name, typ, args){
     if(opt) var sth = opt[1], deprecated = sth; else var deprecated = 0;
     return [0, [0, name, doc, deprecated, typ, args, 0, Io$0[5]]];
    }
    function subscription_field(doc, opt, name, typ, args, resolve){
     if(opt) var sth = opt[1], deprecated = sth; else var deprecated = 0;
     return [0, name, doc, deprecated, typ, args, resolve];
    }
    function enum$1(doc, name, values){return [4, [0, name, doc, values]];}
    function scalar$0(doc, name, coerce){return [3, [0, name, doc, coerce]];}
    function list$0(typ){return [1, typ];}
    function non_null$0(typ){return [2, typ];}
    function add_type(abstract_typ, typ){
     if(5 === abstract_typ[0] && 0 === typ[0]){
      var o = typ[1], a = abstract_typ[1];
      a[4] = [0, [0, typ], a[4]];
      o[4][1] = [0, a, o[4][1]];
      return function(src){return [0, typ, src];};
     }
     return caml_call1(Stdlib[1], cst_Arguments_must_be_Interfac);
    }
    function obj_of_subscription_obj(param){
     var
      fields = param[3],
      doc = param[2],
      name = param[1],
      fields$0 =
        caml_call2
         (map,
          function(param){
           var
            resolve = param[6],
            args = param[5],
            typ = param[4],
            deprecated = param[3],
            doc = param[2],
            name = param[1],
            _dQ_ = 0;
           return [0,
                   name,
                   doc,
                   deprecated,
                   typ,
                   args,
                   function(ctx, param){return caml_call1(resolve, ctx);},
                   _dQ_];
          },
          fields);
     return [0, name, doc, fields$0, [0, 0]];
    }
    var
     int$1 = [3, [0, cst_Int$0, 0, function(i){return [0, 3654863, i];}]],
     string$0 =
       [3, [0, cst_String$0, 0, function(s){return [0, -976970511, s];}]],
     bool$0 =
       [3, [0, cst_Boolean$0, 0, function(b){return [0, 737456202, b];}]],
     float$1 =
       [3, [0, cst_Float$0, 0, function(f){return [0, 365180284, f];}]],
     guid$0 = [3, [0, cst_ID$0, 0, function(x){return [0, -976970511, x];}]];
    function _ad_(param){return param ? 925778591 : 524822024;}
    var
     _ae_ = Arg[10].call(null, Arg[8]),
     skip_directive =
       [0,
        cst_skip,
        _z_,
        _y_,
        [0, Arg[15].call(null, _x_, cst_if, _ae_), 0],
        _ad_];
    function _af_(param){return param ? 524822024 : 925778591;}
    var
     _ag_ = Arg[10].call(null, Arg[8]),
     include_directive =
       [0,
        cst_include,
        _C_,
        _B_,
        [0, Arg[15].call(null, _A_, cst_if$0, _ag_), 0],
        _af_];
    function unless_visited(param, name, f){
     var visited = param[2], result = param[1];
     return caml_call2(StringSet[31], name, visited)
             ? [0, result, visited]
             : caml_call1(f, [0, result, visited]);
    }
    function types(opt, typ){
     var opt$0 = opt, typ$0 = typ;
     for(;;){
      if(opt$0)
       var sth = opt$0[1], memo = sth;
      else
       var memo = [0, 0, StringSet[1]];
      switch(typ$0[0]){
        case 0:
         var
          o = typ$0[1],
          _dH_ =
            function(param){
             var
              visited = param[2],
              result = param[1],
              result$0 = [0, [0, typ$0], result],
              visited$0 = caml_call2(StringSet[2], o[1], visited);
             function reducer(memo, param){
              var memo$0 = types([0, memo], param[4]);
              return arg_list_types(memo$0, param[5]);
             }
             var _dN_ = o[3], _dO_ = caml_obj_tag(_dN_);
             a:
             if(250 === _dO_)
              var _dP_ = _dN_[1];
             else{
              if(246 !== _dO_ && 244 !== _dO_){var _dP_ = _dN_; break a;}
              var _dP_ = caml_call1(CamlinternalLazy[2], _dN_);
             }
             return caml_call3
                     (fold_left, reducer, [0, result$0, visited$0], _dP_);
            };
         return unless_visited(memo, o[1], _dH_);
        case 1:
         var
          typ$1 = typ$0[1],
          opt$1 = [0, memo],
          opt$0 = opt$1,
          typ$0 = typ$1;
         break;
        case 2:
         var
          typ$2 = typ$0[1],
          opt$2 = [0, memo],
          opt$0 = opt$2,
          typ$0 = typ$2;
         break;
        case 3:
         var
          s = typ$0[1],
          _dI_ =
            function(param){
             var visited = param[2], result = param[1];
             return [0,
                     [0, [0, typ$0], result],
                     caml_call2(StringSet[2], s[1], visited)];
            };
         return unless_visited(memo, s[1], _dI_);
        case 4:
         var
          e = typ$0[1],
          _dJ_ =
            function(param){
             var visited = param[2], result = param[1];
             return [0,
                     [0, [0, typ$0], result],
                     caml_call2(StringSet[2], e[1], visited)];
            };
         return unless_visited(memo, e[1], _dJ_);
        default:
         var
          a = typ$0[1],
          _dK_ =
            function(param){
             var
              visited = param[2],
              result = param[1],
              result$0 = [0, [0, typ$0], result],
              visited$0 = caml_call2(StringSet[2], a[1], visited),
              _dL_ = a[4],
              _dM_ = [0, result$0, visited$0];
             return caml_call3
                     (fold_left,
                      function(memo, typ){
                       if(0 !== typ[0])
                        return caml_call1(Stdlib[2], cst_Abstracts_can_t_have_argum);
                       var typ$0 = typ[1];
                       return types([0, memo], typ$0);
                      },
                      _dM_,
                      _dL_);
            };
         return unless_visited(memo, a[1], _dK_);
      }
     }
    }
    function arg_types(memo, argtyp){
     var argtyp$0 = argtyp;
     for(;;)
      switch(argtyp$0[0]){
        case 0:
         var
          _dB_ =
            function(param){
             var visited = param[2], result = param[1];
             return [0,
                     [0, [1, argtyp$0], result],
                     caml_call2(StringSet[2], argtyp$0[1], visited)];
            };
         return unless_visited(memo, argtyp$0[1], _dB_);
        case 1:
         var
          _dC_ =
            function(param){
             var
              visited = param[2],
              result = param[1],
              memo =
                [0,
                 [0, [1, argtyp$0], result],
                 caml_call2(StringSet[2], argtyp$0[1], visited)],
              _dE_ = argtyp$0[3],
              _dF_ = caml_obj_tag(_dE_);
             a:
             if(250 === _dF_)
              var _dG_ = _dE_[1];
             else{
              if(246 !== _dF_ && 244 !== _dF_){var _dG_ = _dE_; break a;}
              var _dG_ = caml_call1(CamlinternalLazy[2], _dE_);
             }
             return arg_list_types(memo, _dG_);
            };
         return unless_visited(memo, argtyp$0[1], _dC_);
        case 2:
         var
          _dD_ =
            function(param){
             var visited = param[2], result = param[1];
             return [0,
                     [0, [1, argtyp$0], result],
                     caml_call2(StringSet[2], argtyp$0[1], visited)];
            };
         return unless_visited(memo, argtyp$0[1], _dD_);
        case 3:
         var argtyp$1 = argtyp$0[1], argtyp$0 = argtyp$1; break;
        default: var argtyp$2 = argtyp$0[1], argtyp$0 = argtyp$2;
      }
    }
    function arg_list_types(memo, arglist){
     var memo$0 = memo, arglist$0 = arglist;
     for(;;){
      if(! arglist$0) return memo$0;
      var
       arglist$1 = arglist$0[2],
       arg = arglist$0[1],
       memo$1 =
         0 === arg[0] ? arg_types(memo$0, arg[3]) : arg_types(memo$0, arg[3]),
       memo$0 = memo$1,
       arglist$0 = arglist$1;
     }
    }
    function types_of_schema(s){
     var
      _dy_ = [0, map$0(s[3], obj_of_subscription_obj), 0],
      _dz_ = [0, [0, s[1]], [0, s[2], _dy_]],
      _dA_ = [0, 0, StringSet[1]],
      types$0 =
        caml_call3
          (fold_left,
           function(memo, op){
            if(! op) return memo;
            var op$0 = op[1];
            return types([0, memo], [0, op$0]);
           },
           _dA_,
           _dz_)
         [1];
     return types$0;
    }
    function args_to_list(opt, arglist){
     var opt$0 = opt, arglist$0 = arglist;
     for(;;){
      if(opt$0) var sth = opt$0[1], memo = sth; else var memo = 0;
      if(! arglist$0) return memo;
      var
       arglist$1 = arglist$0[2],
       arg = arglist$0[1],
       memo$0 = caml_call2(cons, [0, arg], memo),
       opt$1 = [0, memo$0],
       opt$0 = opt$1,
       arglist$0 = arglist$1;
     }
    }
    var
     no_abstracts = [0, 0],
     enum_value$0 =
       [0,
        [0,
         cst_EnumValue,
         0,
         [246,
          function(_dl_){
           var
            _dm_ = 0,
            _dn_ = Io$0[5],
            _do_ =
              [0,
               [0,
                cst_deprecationReason,
                0,
                0,
                string$0,
                0,
                function(param, _dx_){
                 var enum_value = _dx_[1], match = enum_value[3];
                 if(! match) return 0;
                 var reason = match[1];
                 return reason;
                },
                _dn_],
               _dm_],
            _dp_ = Io$0[5],
            _dq_ =
              [0,
               [0,
                cst_isDeprecated,
                0,
                0,
                [2, bool$0],
                0,
                function(param, _dw_){
                 var enum_value = _dw_[1];
                 return 0 !== enum_value[3] ? 1 : 0;
                },
                _dp_],
               _do_],
            _dr_ = Io$0[5],
            _ds_ =
              [0,
               [0,
                cst_description,
                0,
                0,
                string$0,
                0,
                function(param, _dv_){
                 var enum_value = _dv_[1];
                 return enum_value[2];
                },
                _dr_],
               _dq_],
            _dt_ = Io$0[5];
           return [0,
                   [0,
                    cst_name,
                    0,
                    0,
                    [2, string$0],
                    0,
                    function(param, _du_){
                     var enum_value = _du_[1];
                     return enum_value[1];
                    },
                    _dt_],
                   _ds_];
          }],
         no_abstracts]],
     input_value = [],
     type = [],
     field$0 = [];
    caml_update_dummy
     (input_value,
      [0,
       [0,
        cst_InputValue,
        0,
        [246,
         function(_c__){
          var
           _c$_ = 0,
           _da_ = Io$0[5],
           _db_ =
             [0,
              [0,
               cst_defaultValue,
               0,
               0,
               string$0,
               0,
               function(param, _dk_){
                var arg = _dk_[1];
                return 0 === arg[0] ? 0 : [0, Arg[2].call(null, arg[5])];
               },
               _da_],
              _c$_],
           _dc_ = Io$0[5],
           _dd_ =
             [0,
              [0,
               cst_type,
               0,
               0,
               [2, type],
               0,
               function(param, _dj_){
                var arg = _dj_[1];
                return 0 === arg[0] ? [1, arg[3]] : [1, arg[3]];
               },
               _dc_],
              _db_],
           _de_ = Io$0[5],
           _df_ =
             [0,
              [0,
               cst_description$0,
               0,
               0,
               string$0,
               0,
               function(param, _di_){
                var arg = _di_[1];
                return 0 === arg[0] ? arg[2] : arg[2];
               },
               _de_],
              _dd_],
           _dg_ = Io$0[5];
          return [0,
                  [0,
                   cst_name$0,
                   0,
                   0,
                   [2, string$0],
                   0,
                   function(param, _dh_){
                    var arg = _dh_[1];
                    return 0 === arg[0] ? arg[1] : arg[1];
                   },
                   _dg_],
                  _df_];
         }],
        no_abstracts]]);
    caml_update_dummy
     (type,
      [0,
       [0,
        cst_Type,
        0,
        [246,
         function(_cB_){
          var
           _cC_ = 0,
           _cD_ = Io$0[5],
           _cE_ =
             [0,
              [0,
               cst_enumValues,
               0,
               0,
               [1, [2, enum_value$0]],
               0,
               function(param, t){
                if(0 === t[0]){
                 var match = t[1];
                 if(4 === match[0]){
                  var e = match[1], _c8_ = e[3];
                  return [0,
                          caml_call2(map, function(x){return [0, x];}, _c8_)];
                 }
                }
                else{
                 var match$0 = t[1];
                 if(2 === match$0[0]){
                  var _c9_ = match$0[3];
                  return [0,
                          caml_call2(map, function(x){return [0, x];}, _c9_)];
                 }
                }
                return 0;
               },
               _cD_],
              _cC_],
           _cF_ = Io$0[5],
           _cG_ =
             [0,
              [0,
               cst_inputFields,
               0,
               0,
               [1, [2, input_value]],
               0,
               function(param, t){
                if(1 === t[0]){
                 var match = t[1];
                 if(1 === match[0]){
                  var _c5_ = match[3], _c6_ = caml_obj_tag(_c5_);
                  a:
                  if(250 === _c6_)
                   var _c7_ = _c5_[1];
                  else{
                   if(246 !== _c6_ && 244 !== _c6_){var _c7_ = _c5_; break a;}
                   var _c7_ = caml_call1(CamlinternalLazy[2], _c5_);
                  }
                  return [0, args_to_list(0, _c7_)];
                 }
                }
                return 0;
               },
               _cF_],
              _cE_],
           _cH_ = Io$0[5],
           _cI_ =
             [0,
              [0,
               cst_ofType,
               0,
               0,
               type,
               0,
               function(param, t){
                if(0 === t[0]){
                 var match = t[1];
                 switch(match[0]){
                   case 1:
                    var typ = match[1]; return [0, [0, typ]];
                   case 2:
                    var typ$0 = match[1]; return [0, [0, typ$0]];
                 }
                }
                else{
                 var match$0 = t[1];
                 switch(match$0[0]){
                   case 3:
                    var typ$1 = match$0[1]; return [0, [1, typ$1]];
                   case 4:
                    var typ$2 = match$0[1]; return [0, [1, typ$2]];
                 }
                }
                return 0;
               },
               _cH_],
              _cG_],
           _cJ_ = Io$0[5],
           _cK_ =
             [0,
              [0,
               cst_possibleTypes,
               0,
               0,
               [1, [2, type]],
               0,
               function(param, t){
                if(0 === t[0]){
                 var match = t[1];
                 if(5 === match[0]){var a = match[1]; return [0, a[4]];}
                }
                return 0;
               },
               _cJ_],
              _cI_],
           _cL_ = Io$0[5],
           _cM_ =
             [0,
              [0,
               cst_interfaces,
               0,
               0,
               [1, [2, type]],
               0,
               function(param, t){
                if(0 === t[0]){
                 var match = t[1];
                 if(0 === match[0]){
                  var
                   o = match[1],
                   _c3_ = o[4][1],
                   interfaces =
                     caml_call2
                      (filter,
                       function(param){
                        var _c4_ = param[3];
                        if(typeof _c4_ !== "number" && -609414759 === _c4_[1])
                         return 1;
                        return 0;
                       },
                       _c3_);
                  return [0,
                          caml_call2
                           (map, function(i){return [0, [5, i]];}, interfaces)];
                 }
                }
                return 0;
               },
               _cL_],
              _cK_],
           _cN_ = Io$0[5],
           _cO_ =
             [0,
              [0,
               cst_fields,
               0,
               0,
               [1, [2, field$0]],
               0,
               function(param, t){
                if(0 === t[0]){
                 var match = t[1];
                 switch(match[0]){
                   case 0:
                    var o = match[1], _cV_ = o[3], _cW_ = caml_obj_tag(_cV_);
                    a:
                    if(250 === _cW_)
                     var _cX_ = _cV_[1];
                    else{
                     if(246 !== _cW_ && 244 !== _cW_){var _cX_ = _cV_; break a;}
                     var _cX_ = caml_call1(CamlinternalLazy[2], _cV_);
                    }
                    return [0,
                            caml_call2(map, function(f){return [0, f];}, _cX_)];
                   case 5:
                    var match$0 = match[1][3];
                    if(typeof match$0 !== "number" && -609414759 === match$0[1]){
                     var fields = match$0[2], _cY_ = caml_obj_tag(fields);
                     a:
                     if(250 === _cY_)
                      var _cZ_ = fields[1];
                     else{
                      if(246 !== _cY_ && 244 !== _cY_){var _cZ_ = fields; break a;}
                      var _cZ_ = caml_call1(CamlinternalLazy[2], fields);
                     }
                     return [0,
                             caml_call2
                              (map,
                               function(param){var f = param[1]; return [0, f];},
                               _cZ_)];
                    }
                    break;
                 }
                }
                else{
                 var match$1 = t[1];
                 if(1 === match$1[0]){
                  var _c0_ = match$1[3], _c1_ = caml_obj_tag(_c0_);
                  a:
                  if(250 === _c1_)
                   var _c2_ = _c0_[1];
                  else{
                   if(246 !== _c1_ && 244 !== _c1_){var _c2_ = _c0_; break a;}
                   var _c2_ = caml_call1(CamlinternalLazy[2], _c0_);
                  }
                  var arg_list = args_to_list(0, _c2_);
                  return [0,
                          caml_call2
                           (map,
                            function(param){var f = param[1]; return [1, f];},
                            arg_list)];
                 }
                }
                return 0;
               },
               _cN_],
              _cM_],
           _cP_ = Io$0[5],
           _cQ_ =
             [0,
              [0,
               cst_description$1,
               0,
               0,
               string$0,
               0,
               function(param, t){
                if(0 === t[0]){
                 var match = t[1];
                 switch(match[0]){
                   case 0:
                    var o = match[1]; return o[2];
                   case 3:
                    var s = match[1]; return s[2];
                   case 4:
                    var e = match[1]; return e[2];
                   case 5:
                    var a = match[1]; return a[2];
                 }
                }
                else{
                 var match$0 = t[1];
                 switch(match$0[0]){
                   case 0:
                    return match$0[2];
                   case 1:
                    return match$0[2];
                   case 2:
                    return match$0[2];
                 }
                }
                return 0;
               },
               _cP_],
              _cO_],
           _cR_ = Io$0[5],
           _cS_ =
             [0,
              [0,
               cst_name$1,
               0,
               0,
               string$0,
               0,
               function(param, t){
                if(0 === t[0]){
                 var match = t[1];
                 switch(match[0]){
                   case 0:
                    var o = match[1]; return [0, o[1]];
                   case 3:
                    var s = match[1]; return [0, s[1]];
                   case 4:
                    var e = match[1]; return [0, e[1]];
                   case 5:
                    var a = match[1]; return [0, a[1]];
                 }
                }
                else{
                 var match$0 = t[1];
                 switch(match$0[0]){
                   case 0:
                    return [0, match$0[1]];
                   case 1:
                    return [0, match$0[1]];
                   case 2:
                    return [0, match$0[1]];
                 }
                }
                return 0;
               },
               _cR_],
              _cQ_],
           _cT_ = Io$0[5];
          return [0,
                  [0,
                   cst_kind,
                   0,
                   0,
                   [2, type_kind],
                   0,
                   function(param, t){
                    if(0 !== t[0])
                     switch(t[1][0]){
                       case 0:
                        return -256222388;
                       case 1:
                        return -291114423;
                       case 2:
                        return 770676513;
                       case 3:
                        return 848054398;
                       default: return 388158996;
                     }
                    var _cU_ = t[1];
                    switch(_cU_[0]){
                      case 0:
                       return -908856609;
                      case 1:
                       return 848054398;
                      case 2:
                       return 388158996;
                      case 3:
                       return -256222388;
                      case 4:
                       return 770676513;
                      default:
                       return typeof _cU_[1][3] === "number"
                               ? 974443759
                               : -609414759;
                    }
                   },
                   _cT_],
                  _cS_];
         }],
        no_abstracts]]);
    caml_update_dummy
     (field$0,
      [0,
       [0,
        cst_Field,
        0,
        [246,
         function(_co_){
          var
           _cp_ = 0,
           _cq_ = Io$0[5],
           _cr_ =
             [0,
              [0,
               cst_deprecationReason$0,
               0,
               0,
               string$0,
               0,
               function(param, f){
                if(0 === f[0]){
                 var match = f[1][3];
                 if(match){var reason = match[1]; return reason;}
                }
                return 0;
               },
               _cq_],
              _cp_],
           _cs_ = Io$0[5],
           _ct_ =
             [0,
              [0,
               cst_isDeprecated$0,
               0,
               0,
               [2, bool$0],
               0,
               function(param, f){
                if(0 === f[0] && f[1][3]) return 1;
                return 0;
               },
               _cs_],
              _cr_],
           _cu_ = Io$0[5],
           _cv_ =
             [0,
              [0,
               cst_type$0,
               0,
               0,
               [2, type],
               0,
               function(param, f){
                if(0 === f[0]) return [0, f[1][4]];
                var match = f[1];
                return 0 === match[0] ? [1, match[3]] : [1, match[3]];
               },
               _cu_],
              _ct_],
           _cw_ = Io$0[5],
           _cx_ =
             [0,
              [0,
               cst_args,
               0,
               0,
               [2, [1, [2, input_value]]],
               0,
               function(param, f){
                return 0 === f[0] ? args_to_list(0, f[1][5]) : 0;
               },
               _cw_],
              _cv_],
           _cy_ = Io$0[5],
           _cz_ =
             [0,
              [0,
               cst_description$2,
               0,
               0,
               string$0,
               0,
               function(param, f){
                if(0 === f[0]) return f[1][2];
                var match = f[1];
                return 0 === match[0] ? match[2] : match[2];
               },
               _cy_],
              _cx_],
           _cA_ = Io$0[5];
          return [0,
                  [0,
                   cst_name$2,
                   0,
                   0,
                   [2, string$0],
                   0,
                   function(param, f){
                    if(0 === f[0]) return f[1][1];
                    var match = f[1];
                    return 0 === match[0] ? match[1] : match[1];
                   },
                   _cA_],
                  _cz_];
         }],
        no_abstracts]]);
    var
     directive =
       [0,
        [0,
         cst_Directive,
         0,
         [246,
          function(_cf_){
           var
            _cg_ = 0,
            _ch_ = Io$0[5],
            _ci_ =
              [0,
               [0,
                cst_args$0,
                0,
                0,
                [2, [1, [2, input_value]]],
                0,
                function(param, d){return args_to_list(0, d[4]);},
                _ch_],
               _cg_],
            _cj_ = Io$0[5],
            _ck_ =
              [0,
               [0,
                cst_locations,
                0,
                0,
                [2, [1, [2, directive_location]]],
                0,
                function(param, d){return d[3];},
                _cj_],
               _ci_],
            _cl_ = Io$0[5],
            _cm_ =
              [0,
               [0,
                cst_description$3,
                0,
                0,
                string$0,
                0,
                function(param, d){return d[2];},
                _cl_],
               _ck_],
            _cn_ = Io$0[5];
           return [0,
                   [0,
                    cst_name$3,
                    0,
                    0,
                    [2, string$0],
                    0,
                    function(param, d){return d[1];},
                    _cn_],
                   _cm_];
          }],
         no_abstracts]],
     schema$0 =
       [0,
        [0,
         cst_Schema,
         0,
         [246,
          function(_bZ_){
           var
            _b0_ = 0,
            _b1_ = Io$0[5],
            _b2_ =
              [0,
               [0,
                cst_directives,
                0,
                0,
                [2, [1, [2, directive]]],
                0,
                function(param, _ce_){return 0;},
                _b1_],
               _b0_],
            _b3_ = Io$0[5],
            _b4_ =
              [0,
               [0,
                cst_subscriptionType,
                0,
                0,
                type,
                0,
                function(param, _cc_){
                 var schema = _cc_[1];
                 function _cd_(subs){
                  return [0, [0, obj_of_subscription_obj(subs)]];
                 }
                 return map$0(schema[3], _cd_);
                },
                _b3_],
               _b2_],
            _b5_ = Io$0[5],
            _b6_ =
              [0,
               [0,
                cst_mutationType,
                0,
                0,
                type,
                0,
                function(param, _ca_){
                 var schema = _ca_[1];
                 function _cb_(mut){return [0, [0, mut]];}
                 return map$0(schema[2], _cb_);
                },
                _b5_],
               _b4_],
            _b7_ = Io$0[5],
            _b8_ =
              [0,
               [0,
                cst_queryType,
                0,
                0,
                [2, type],
                0,
                function(param, _b$_){
                 var schema = _b$_[1];
                 return [0, [0, schema[1]]];
                },
                _b7_],
               _b6_],
            _b9_ = Io$0[5];
           return [0,
                   [0,
                    cst_types,
                    0,
                    0,
                    [2, [1, [2, type]]],
                    0,
                    function(param, _b__){var types = _b__[2]; return types;},
                    _b9_],
                   _b8_];
          }],
         no_abstracts]];
    function add_built_in_fields(schema){
     var
      types = types_of_schema(schema),
      _bO_ = Io$0[5],
      schema_field =
        [0,
         cst_schema,
         0,
         0,
         [2, schema$0],
         0,
         function(param, _bY_){return [0, schema, types];},
         _bO_],
      _bP_ = Io$0[5];
     function _bQ_(param, _bX_, name){
      return find
              (function(typ){
                if(0 === typ[0]){
                 var match = typ[1];
                 switch(match[0]){
                   case 0:
                    var o = match[1]; return caml_string_equal(o[1], name);
                   case 1:
                    return 0;
                   case 2:
                    return 0;
                   case 3:
                    var s = match[1]; return caml_string_equal(s[1], name);
                   case 4:
                    var e = match[1]; return caml_string_equal(e[1], name);
                   default:
                    var a = match[1]; return caml_string_equal(a[1], name);
                 }
                }
                var match$0 = typ[1];
                switch(match$0[0]){
                  case 0:
                   return caml_string_equal(match$0[1], name);
                  case 1:
                   return caml_string_equal(match$0[1], name);
                  case 2:
                   return caml_string_equal(match$0[1], name);
                  case 3:
                   return 0;
                  default: return 0;
                }
               },
               types);
     }
     var
      _bR_ = Arg[10].call(null, Arg[6]),
      type_field =
        [0,
         cst_type$1,
         0,
         0,
         type,
         [0, Arg[15].call(null, 0, cst_name$4, _bR_), 0],
         _bQ_,
         _bP_],
      fields =
        [246,
         function(_bT_){
          var _bU_ = schema[1][3], _bV_ = caml_obj_tag(_bU_);
          a:
          if(250 === _bV_)
           var _bW_ = _bU_[1];
          else{
           if(246 !== _bV_ && 244 !== _bV_){var _bW_ = _bU_; break a;}
           var _bW_ = caml_call1(CamlinternalLazy[2], _bU_);
          }
          return [0, schema_field, [0, type_field, _bW_]];
         }],
      _bS_ = schema[1];
     return [0, [0, _bS_[1], _bS_[2], fields, _bS_[4]], schema[2], schema[3]];
    }
    var
     Introspection = [0, , , , , , , , , , , , , , , , add_built_in_fields];
    function matches_type_condition(type_condition, obj){
     var _bM_ = caml_string_equal(obj[1], type_condition);
     if(_bM_) return _bM_;
     var _bN_ = obj[4][1];
     return caml_call2
             (exists,
              function(abstract$0){
               return caml_string_equal(abstract$0[1], type_condition);
              },
              _bN_);
    }
    function should_include_field(ctx, directives){
     if(! directives) return _E_;
     var match = directives[1], name = match[1];
     if(! caml_string_notequal(name, cst_include$0)){
      var rest$0 = directives[2], arguments$1 = match[2];
      return eval_directive(ctx, include_directive, arguments$1, rest$0);
     }
     if(caml_string_notequal(name, cst_skip$0)){
      var err = caml_call2(Stdlib_Format[140], _D_, name);
      return [1, err];
     }
     var rest = directives[2], arguments$0 = match[2];
     return eval_directive(ctx, skip_directive, arguments$0, rest);
    }
    function eval_directive(ctx, param, arguments$0, rest){
     var resolve = param[5], args = param[4], name = param[1];
     function _bK_(param){
      return 925778591 <= param ? _F_ : should_include_field(ctx, rest);
     }
     var
      _bL_ = Arg[13].call(null, ctx[1], _G_, name, args, arguments$0, resolve);
     return caml_call2(Rresult[1], _bL_, _bK_);
    }
    function alias_or_name(field){
     var match = field[1];
     if(! match) return field[2];
     var alias = match[1];
     return alias;
    }
    function merge_selections(opt, param){
     var opt$0 = opt, param$0 = param;
     for(;;){
      if(opt$0) var sth = opt$0[1], memo = sth; else var memo = 0;
      if(! param$0) return caml_call1(rev, memo);
      var
       fields = param$0[2],
       field = param$0[1],
       id = alias_or_name(field),
       match =
         caml_call2
          (partition,
           function(id){
             return function(field){
              return caml_string_equal(id, alias_or_name(field));};
            }
            (id),
           fields),
       rest = match[2],
       matching = match[1],
       _bJ_ = [0, field, matching],
       selection_sets =
         caml_call2(map, function(field){return field[5];}, _bJ_),
       selection_set = caml_call1(concat, selection_sets),
       opt$1 =
         [0,
          [0,
           [0, field[1], field[2], field[3], field[4], selection_set],
           memo]],
       opt$0 = opt$1,
       param$0 = rest;
     }
    }
    function collect_fields(ctx, obj, fields){
     var
      _bA_ =
        join
         (0,
          caml_call2
           (map,
            function(param){
             switch(param[0]){
               case 0:
                var
                 field = param[1],
                 _bD_ =
                   function(include_field){
                    return include_field ? [0, field, 0] : 0;
                   },
                 _bE_ = should_include_field(ctx, field[4]);
                return caml_call2(Rresult[2], _bE_, _bD_);
               case 1:
                var
                 spread = param[1],
                 match = caml_call2(StringMap[45], spread[1], ctx[2]);
                if(match){
                 var
                  match$0 = match[1],
                  selection_set = match$0[4],
                  type_condition = match$0[2];
                 if(matches_type_condition(type_condition, obj)){
                  var
                   _bF_ =
                     function(include_field){
                      return include_field
                              ? collect_fields(ctx, obj, selection_set)
                              : _H_;
                     },
                   _bG_ = should_include_field(ctx, spread[2]);
                  return caml_call2(Rresult[1], _bG_, _bF_);
                 }
                }
                return _I_;
               default:
                var fragment = param[1], match$1 = fragment[1];
                if(match$1)
                 var
                  condition = match$1[1],
                  matches_type_condition$0 =
                    matches_type_condition(condition, obj);
                else
                 var matches_type_condition$0 = 1;
                if(! matches_type_condition$0) return _K_;
                var
                 _bH_ =
                   function(include_field){
                    return include_field
                            ? collect_fields(ctx, obj, fragment[3])
                            : _J_;
                   },
                 _bI_ = should_include_field(ctx, fragment[2]);
                return caml_call2(Rresult[1], _bI_, _bH_);
             }
            },
            fields)),
      _bB_ = caml_call1(caml_call1(Rresult[3][9], concat), _bA_);
     function _bC_(eta){return merge_selections(0, eta);}
     return caml_call1(caml_call1(Rresult[3][9], _bC_), _bB_);
    }
    function field_from_object(obj, field_name){
     var _bx_ = obj[3], _by_ = caml_obj_tag(_bx_);
     a:
     if(250 === _by_)
      var _bz_ = _bx_[1];
     else{
      if(246 !== _by_ && 244 !== _by_){var _bz_ = _bx_; break a;}
      var _bz_ = caml_call1(CamlinternalLazy[2], _bx_);
     }
     return find
             (function(param){return caml_string_equal(param[1], field_name);},
              _bz_);
    }
    function field_from_subscription_object(obj, field_name){
     var _bw_ = obj[3];
     return find
             (function(param){return caml_string_equal(param[1], field_name);},
              _bw_);
    }
    function coerce_or_null(src, f){
     if(! src) return Io$0[5].call(null, _L_);
     var src$0 = src[1];
     return caml_call1(f, src$0);
    }
    function map_fields_with_order(param){
     if(param) return Io$0[10];
     var _br_ = Io$0[9];
     return function(_bs_, _bt_){
      var _bv_ = _bt_, _bu_ = _bs_;
      return _br_(_M_, _bu_, _bv_);};
    }
    function error_to_json(path, extensions, msg){
     if(path)
      var
       path$0 = path[1],
       props = [0, [0, cst_path, [0, 848054398, caml_call1(rev, path$0)]], 0];
     else
      var props = 0;
     a:
     {
      if(extensions){
       var extensions$0 = extensions[1];
       if(extensions$0){
        var
         extension_props =
           [0, [0, cst_extensions, [0, 963043957, extensions$0]], 0];
        break a;
       }
      }
      var extension_props = 0;
     }
     return [0,
             963043957,
             [0,
              [0, cst_message, [0, -976970511, msg]],
              caml_call2(append, props, extension_props)]];
    }
    function error_response(data, path, extensions, msg){
     var
      errors =
        [0,
         cst_errors,
         [0, 848054398, [0, error_to_json(path, extensions, msg), 0]]];
     if(data)
      var data$0 = data[1], data$1 = [0, [0, cst_data, data$0], 0];
     else
      var data$1 = 0;
     return [0, 963043957, [0, errors, data$1]];
    }
    function present(ctx, src, query_field, typ, path){
     var src$0 = src, typ$0 = typ;
     for(;;)
      switch(typ$0[0]){
        case 0:
         var o = typ$0[1];
         return coerce_or_null
                 (src$0,
                  function(src){
                   var match = collect_fields(ctx, o, query_field[5]);
                   if(0 === match[0]){
                    var fields = match[1];
                    return resolve_fields(ctx, 0, src, o, fields, path);
                   }
                   var e = match[1];
                   return Io$0[6].call(null, [0, -892235418, e]);
                  });
        case 1:
         var t = typ$0[1];
         return coerce_or_null
                 (src$0,
                  function(src){
                   var
                    _bk_ =
                      caml_call2
                       (mapi,
                        function(i, x){
                         return present
                                 (ctx, x, query_field, t, [0, [0, 3654863, i], path]);
                        },
                        src),
                    _bl_ = Io$0[7].call(null, _bk_),
                    func = Io$0[4],
                    _bm_ = func(_bl_, function(eta){return join(0, eta);}),
                    _bn_ = Io$0[8][3];
                   return _bn_
                           (_bm_,
                            function(xs){
                             var
                              _bo_ =
                                caml_call1
                                 (concat,
                                  caml_call2(map, function(_bq_){return _bq_[2];}, xs));
                             return [0,
                                     [0,
                                      848054398,
                                      caml_call2(map, function(_bp_){return _bp_[1];}, xs)],
                                     _bo_];
                            });
                  });
        case 2:
         var
          typ$1 = typ$0[1],
          src$1 = [0, src$0],
          src$0 = src$1,
          typ$0 = typ$1;
         break;
        case 3:
         var s = typ$0[1];
         return coerce_or_null
                 (src$0,
                  function(x){
                   var _bj_ = [0, caml_call1(s[3], x), 0];
                   return Io$0[5].call(null, _bj_);
                  });
        case 4:
         var e = typ$0[1];
         return coerce_or_null
                 (src$0,
                  function(src){
                   var
                    _bi_ = e[3],
                    match =
                      find
                       (function(enum_value){return src === enum_value[4] ? 1 : 0;},
                        _bi_);
                   if(! match) return Io$0[5].call(null, _N_);
                   var enum_value = match[1];
                   return Io$0[5].call
                           (null, [0, [0, -976970511, enum_value[1]], 0]);
                  });
        default:
         return coerce_or_null
                 (src$0,
                  function(param){
                   var src = param[2], typ = param[1];
                   return present(ctx, [0, src], query_field, typ, path);
                  });
      }
    }
    function resolve_field(ctx, src, query_field, field, path){
     var
      name = alias_or_name(query_field),
      path$0 = [0, [0, -976970511, name], path],
      resolve_info = [0, ctx[3], query_field, ctx[2], ctx[1]],
      resolver = caml_call2(field[6], resolve_info, src),
      match =
        Arg[13].call
         (null, ctx[1], 0, field[1], field[5], query_field[3], resolver);
     if(0 === match[0]){
      var
       unlifted_value = match[1],
       _bd_ =
         function(resolved){
          return present(ctx, resolved, query_field, field[4], path$0);
         },
       _be_ = caml_call1(field[7], unlifted_value),
       _bf_ = Io$0[8][2],
       _bg_ =
         _bf_(_be_, function(err){return [0, 1048866517, [0, err, path$0]];}),
       lifted_value = Io$0[11][2].call(null, _bg_, _bd_),
       _bh_ =
         function(error){
          if(0 === error[0]){
           var match = error[1], errors = match[2], value = match[1];
           return [0, [0, [0, name, value], errors]];
          }
          var match$0 = error[1];
          if(1048866517 > match$0[1]) return error;
          var err = match$0[2];
          return 2 === field[4][0]
                  ? error
                  : [0, [0, [0, name, 870828711], [0, err, 0]]];
         };
      return Io$0[11][1].call(null, lifted_value, _bh_);
     }
     var err = match[1];
     return Io$0[6].call(null, [0, -892235418, err]);
    }
    function resolve_fields(ctx, opt, src, obj, fields, path){
     if(opt)
      var sth = opt[1], execution_order = sth;
     else
      var execution_order = 1;
     function _a8_(query_field){
      var name = alias_or_name(query_field);
      if(caml_string_equal(query_field[2], cst_typename))
       return Io$0[5].call(null, [0, [0, name, [0, -976970511, obj[1]]], 0]);
      var match = field_from_object(obj, query_field[2]);
      if(match){
       var field = match[1];
       return resolve_field(ctx, src, query_field, field, path);
      }
      var err = caml_call3(Stdlib_Printf[4], _O_, query_field[2], obj[1]);
      return Io$0[6].call(null, [0, -560894942, err]);
     }
     var
      _a9_ = caml_call2(map_fields_with_order(execution_order), _a8_, fields),
      func = Io$0[4],
      _a__ = func(_a9_, function(eta){return join(0, eta);}),
      _a$_ = Io$0[8][3];
     return _a$_
             (_a__,
              function(xs){
               var
                _ba_ =
                  caml_call1
                   (concat,
                    caml_call2(map, function(_bc_){return _bc_[2];}, xs));
               return [0,
                       [0,
                        963043957,
                        caml_call2(map, function(_bb_){return _bb_[1];}, xs)],
                       _ba_];
              });
    }
    function data_to_json(param){
     var data = param[1];
     if(! param[2]) return [0, 963043957, [0, [0, cst_data$1, data], 0]];
     var
      errors = param[2],
      errors$0 =
        caml_call2
         (map,
          function(param){
           var
            path = param[2],
            field_error = param[1],
            extensions = caml_call1(Field_error[2], field_error),
            msg = caml_call1(Field_error[1], field_error);
           return error_to_json([0, path], extensions, msg);
          },
          errors);
     return [0,
             963043957,
             [0,
              [0, cst_errors$0, [0, 848054398, errors$0]],
              [0, [0, cst_data$0, data], 0]]];
    }
    function to_response(res){
     if(0 === res[0]) return res;
     var match = res[1];
     if(typeof match === "number")
      return -784750693 === match
              ? [1, error_response(0, 0, 0, cst_Operation_name_required)]
              : 218856819
                <= match
                ? 928682367
                  <= match
                  ? [1, error_response(0, 0, 0, cst_Mutations_not_configured)]
                  : [1,
                    error_response(0, 0, 0, cst_Subscriptions_not_configur)]
                : 80281036
                  <= match
                  ? [1, error_response(0, 0, 0, cst_No_operation_found)]
                  : [1, error_response(0, 0, 0, cst_Operation_not_found)];
     var _a7_ = match[1];
     if(-560894942 === _a7_){
      var msg = match[2];
      return [1, error_response(0, 0, 0, msg)];
     }
     if(1048866517 <= _a7_){
      var
       match$0 = match[2],
       path = match$0[2],
       field_error = match$0[1],
       extensions = caml_call1(Field_error[2], field_error),
       msg$0 = caml_call1(Field_error[1], field_error);
      return [1, error_response(_P_, [0, path], extensions, msg$0)];
     }
     var msg$1 = match[2];
     return [1, error_response(_Q_, 0, 0, msg$1)];
    }
    function subscribe(ctx, subs_field, field){
     var
      name = alias_or_name(field),
      path = [0, [0, -976970511, name], 0],
      resolve_info = [0, ctx[3], field, ctx[2], ctx[1]],
      resolver = caml_call1(subs_field[6], resolve_info),
      match =
        Arg[13].call
         (null, ctx[1], 0, subs_field[1], subs_field[5], field[3], resolver);
     if(0 === match[0]){
      var
       result = match[1],
       _a0_ = Io$0[8][3],
       _a1_ =
         _a0_
          (result,
           function(source_stream){
            function _a3_(value){
             var
              _a4_ = present(ctx, value, field, subs_field[4], path),
              _a5_ = Io$0[8][3],
              _a6_ =
                _a5_
                 (_a4_,
                  function(param){
                   var errors = param[2], data = param[1];
                   return data_to_json
                           ([0, [0, 963043957, [0, [0, name, data], 0]], errors]);
                  });
             return Io$0[11][1].call(null, _a6_, to_response);
            }
            return caml_call2(Io$0[3][1], source_stream, _a3_);
           }),
       _a2_ = Io$0[8][2];
      return _a2_
              (_a1_, function(err){return [0, 1048866517, [0, err, path]];});
     }
     var err = match[1];
     return Io$0[6].call(null, [0, -892235418, err]);
    }
    function execute_operation(schema, ctx, operation){
     switch(operation[1]){
       case 0:
        var
         query = schema[1],
         _aD_ =
           function(fields){
            var
             _aY_ = resolve_fields(ctx, 0, 0, query, fields, 0),
             _aZ_ = Io$0[8][3];
            return _aZ_
                    (_aY_,
                     function(data_errs){
                      return [0, -71406943, data_to_json(data_errs)];
                     });
           },
         _aE_ = collect_fields(ctx, query, operation[5]),
         _aF_ = caml_call1(Io$0[1], _aE_),
         _aG_ = Io$0[8][2],
         _aH_ = _aG_(_aF_, function(e){return [0, -892235418, e];});
        return Io$0[11][2].call(null, _aH_, _aD_);
       case 1:
        var match = schema[2];
        if(! match) return Io$0[6].call(null, 928682367);
        var
         mut = match[1],
         _aI_ =
           function(fields){
            var
             _aW_ = resolve_fields(ctx, _R_, 0, mut, fields, 0),
             _aX_ = Io$0[8][3];
            return _aX_
                    (_aW_,
                     function(data_errs){
                      return [0, -71406943, data_to_json(data_errs)];
                     });
           },
         _aJ_ = collect_fields(ctx, mut, operation[5]),
         _aK_ = caml_call1(Io$0[1], _aJ_),
         _aL_ = Io$0[8][2],
         _aM_ = _aL_(_aK_, function(e){return [0, -892235418, e];});
        return Io$0[11][2].call(null, _aM_, _aI_);
       default:
        var match$0 = schema[3];
        if(! match$0) return Io$0[6].call(null, 218856819);
        var
         subs = match$0[1],
         _aN_ =
           function(fields){
            if(fields && ! fields[2]){
             var field = fields[1];
             if(caml_string_equal(field[2], cst_typename)){
              var
               _aT_ =
                 [0,
                  -71406943,
                  data_to_json
                   ([0,
                     [0,
                      963043957,
                      [0, [0, field[2], [0, -976970511, subs[1]]], 0]],
                     0])];
              return Io$0[5].call(null, _aT_);
             }
             var match = field_from_subscription_object(subs, field[2]);
             if(match){
              var
               subscription_field = match[1],
               _aU_ = subscribe(ctx, subscription_field, field),
               _aV_ = Io$0[8][3];
              return _aV_
                      (_aU_, function(stream){return [0, -977172320, stream];});
             }
             var err = caml_call3(Stdlib_Printf[4], _T_, field[2], subs[1]);
             return Io$0[6].call(null, [0, -560894942, err]);
            }
            return Io$0[6].call(null, _S_);
           },
         _aO_ = operation[5],
         _aP_ = collect_fields(ctx, obj_of_subscription_obj(subs), _aO_),
         _aQ_ = caml_call1(Io$0[1], _aP_),
         _aR_ = Io$0[8][2],
         _aS_ = _aR_(_aQ_, function(e){return [0, -892235418, e];});
        return Io$0[11][2].call(null, _aS_, _aN_);
     }
    }
    function collect_fragments(doc){
     var _aC_ = StringMap[1];
     return caml_call3
             (fold_left,
              function(memo, param){
               if(0 === param[0]) return memo;
               var f = param[1];
               return caml_call3(StringMap[2], f[1], f, memo);
              },
              _aC_,
              doc);
    }
    var
     FragmentCycle =
       [248, cst_Graphql_schema_Make_Io_Fie$0, caml_fresh_oo_id(0)];
    function validate_fragments(fragment_map){
     try{
      var
       _aA_ =
         function(name, param){
          return validate_fragment(fragment_map, StringSet[1], name);
         };
      caml_call2(StringMap[22], _aA_, fragment_map);
      var _aB_ = [0, fragment_map];
      return _aB_;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn[1] !== FragmentCycle) throw caml_maybe_attach_backtrace(exn, 0);
      var
       fragment_names = exn[2],
       cycle = caml_call2(Stdlib_String[7], cst$2, fragment_names),
       err = caml_call2(Stdlib_Format[140], _U_, cycle);
      return [1, [0, -560894942, err]];
     }
    }
    function validate_fragment(fragment_map, visited, name){
     var match = caml_call2(StringMap[45], name, fragment_map);
     if(! match) return 0;
     var fragment = match[1];
     if(caml_call2(StringSet[31], fragment[1], visited))
      throw caml_maybe_attach_backtrace
             ([0, FragmentCycle, caml_call1(StringSet[10], visited)], 1);
     var
      visited$0 = caml_call2(StringSet[2], fragment[1], visited),
      _ay_ = fragment[4];
     return caml_call2
             (iter,
              function(_az_){
               return validate_fragment_selection
                       (fragment_map, visited$0, _az_);
              },
              _ay_);
    }
    function validate_fragment_selection(fragment_map, visited, selection){
     switch(selection[0]){
       case 0:
        var field = selection[1], _au_ = field[5];
        return caml_call2
                (iter,
                 function(_ax_){
                  return validate_fragment_selection
                          (fragment_map, visited, _ax_);
                 },
                 _au_);
       case 1:
        var fragment_spread = selection[1];
        return validate_fragment(fragment_map, visited, fragment_spread[1]);
       default:
        var inline_fragment = selection[1], _av_ = inline_fragment[3];
        return caml_call2
                (iter,
                 function(_aw_){
                  return validate_fragment_selection
                          (fragment_map, visited, _aw_);
                 },
                 _av_);
     }
    }
    function collect_and_validate_fragments(doc){
     var fragments = collect_fragments(doc);
     return validate_fragments(fragments);
    }
    function collect_operations(doc){
     var _at_ = 0;
     return caml_call3
             (fold_left,
              function(memo, param){
               if(0 !== param[0]) return memo;
               var op = param[1];
               return [0, op, memo];
              },
              _at_,
              doc);
    }
    function select_operation(operation_name, doc){
     var operations = collect_operations(doc);
     if(! operations) return _X_;
     if(! operation_name){
      var op = operations[1];
      return operations[2] ? _W_ : [0, op];
     }
     var name = operation_name[1];
     try{
      var
       _ar_ =
         [0,
          caml_call2
           (find_exn,
            function(op){return runtime.caml_equal(op[2], [0, name]);},
            operations)];
      return _ar_;
     }
     catch(_as_){
      var _aq_ = caml_wrap_exception(_as_);
      if(_aq_ === Stdlib[8]) return _V_;
      throw caml_maybe_attach_backtrace(_aq_, 0);
     }
    }
    function execute(schema, ctx, opt, operation_name, doc){
     if(opt) var sth = opt[1], variables = sth; else var variables = 0;
     function _ah_(fragments){
      var schema$0 = Introspection[16].call(null, schema);
      function _al_(op){
       var
        _ao_ = op[3],
        _ap_ = StringMap[1],
        default_variables =
          caml_call3
           (fold_left,
            function(memo, param){
             var default_value = param[3], name = param[1];
             if(! default_value) return memo;
             var value = default_value[1];
             return caml_call3(StringMap[2], name, value, memo);
            },
            _ap_,
            _ao_),
        variables$0 =
          caml_call3
           (fold_left,
            function(memo, param){
             var value = param[2], name = param[1];
             return caml_call3(StringMap[2], name, value, memo);
            },
            default_variables,
            variables),
        execution_ctx = [0, variables$0, fragments, ctx];
       return execute_operation(schema$0, execution_ctx, op);
      }
      var
       _am_ = select_operation(operation_name, doc),
       _an_ = caml_call1(Io$0[1], _am_);
      return Io$0[11][2].call(null, _an_, _al_);
     }
     var
      _ai_ = collect_and_validate_fragments(doc),
      _aj_ = caml_call1(Io$0[1], _ai_),
      _ak_ = Io$0[11][2].call(null, _aj_, _ah_);
     return Io$0[11][1].call(null, _ak_, to_response);
    }
    return [0,
            Io$0,
            StringMap,
            ,
            enum_value,
            ,
            Arg,
            union$0,
            interface$0,
            fix$0,
            schema,
            obj$0,
            field,
            io_field,
            abstract_field,
            subscription_field,
            enum$1,
            scalar$0,
            list$0,
            non_null$0,
            add_type,
            ,
            int$1,
            string$0,
            bool$0,
            float$1,
            guid$0,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            execute];
   }
   var
    Graphql_schema =
      [0,
       function(_Z_, _Y_){
        var ___ = Make(_Z_, _Y_), _$_ = ___[6], _aa_ = ___[1];
        return [0,
                [0, _aa_[1], _aa_[2], _aa_[3]],
                ___[2],
                ___[10],
                ___[4],
                ___[11],
                [0,
                 _$_[15],
                 _$_[16],
                 _$_[1],
                 _$_[17],
                 _$_[18],
                 _$_[19],
                 _$_[5],
                 _$_[6],
                 _$_[8],
                 _$_[7],
                 _$_[9],
                 _$_[11],
                 _$_[10]],
                ___[12],
                ___[13],
                ___[15],
                ___[16],
                ___[17],
                ___[18],
                ___[19],
                ___[7],
                ___[14],
                ___[8],
                ___[20],
                ___[9],
                ___[22],
                ___[23],
                ___[26],
                ___[24],
                ___[25],
                ___[57]];
       }];
   runtime.caml_register_global(147, Graphql_schema, "Graphql_schema");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Graphql_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Graphql_intf = [0];
   runtime.caml_register_global(0, Graphql_intf, "Graphql_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Graphql
//# unitInfo: Requires: Graphql_schema, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Graphql_schema = global_data.Graphql_schema;
   function message_of_field_error(t){return t;}
   function extensions_of_field_error(t){return 0;}
   var _a_ = [0, message_of_field_error, extensions_of_field_error];
   function bind(t, f){return caml_call1(f, t);}
   function return$0(t){return t;}
   function map(t, f){return caml_call2(Stdlib_Seq[29], f, t);}
   function iter(t, f){return caml_call2(Stdlib_Seq[4], f, t);}
   function close(t){return 0;}
   var
    Stream = [0, map, iter, close],
    Schema =
      caml_call1
       (caml_call1(Graphql_schema[1], [0, return$0, bind, Stream]), _a_),
    Graphql = [0, Schema];
   runtime.caml_register_global(2, Graphql, "Graphql");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJncmFwaHFsLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJ0eXBlX2tpbmQiLCJkaXJlY3RpdmVfbG9jYXRpb24iLCJmaW5kX2V4biIsImFzc29jX2V4biIsImZpbmQiLCJjb25kIiwieHMiLCJvcHQiLCJvcHQkMCIsInN0aCIsIm1lbW8iLCJlcnIiLCJ4Iiwib3B0JDEiLCJtYXAkMCIsInQiLCJmIiwieSIsInJldHVybiQwIiwiYmluZCIsIm1hcCQxIiwib2siLCJlcnJvciIsImFsbCIsImJpbmQkMCIsIm1hcF9lcnJvciIsIm1hcCQyIiwibWFwX3MiLCJtYXBfcCIsInN5bWJvbF9tYXAiLCJzeW1ib2wiLCJmaW5kX2V4biQwIiwia2V5IiwiZmluZCQwIiwiayIsImVudW1fdmFsdWUiLCJkb2MiLCJuYW1lIiwidmFsdWUiLCJkZXByZWNhdGVkIiwiaWQiLCJmaXgiLCJyZWN1cnNpdmUiLCJyIiwiZmllbGRzIiwic3RyaW5nX29mX2NvbnN0X3ZhbHVlIiwiaSIsInMiLCJhIiwidmFsdWVzIiwidiIsImwiLCJ2YWx1ZXMkMCIsImUiLCJiIiwic3RyaW5nX29mX2FyZ190eXAiLCJwYXJhbSIsImEkMCIsImV2YWxfYXJnX2Vycm9yIiwiZmllbGRfbmFtZSIsImFyZ19uYW1lIiwiYXJnX3R5cCIsImZpZWxkX3R5cGUiLCJmb3VuZF9zdHIiLCJpbnQkMCIsIm4iLCJzdHJpbmciLCJmbG9hdCQwIiwiYm9vbCIsImd1aWQiLCJub25fbnVsbCIsInR5cCIsImxpc3QiLCJ2YWx1ZV90b19jb25zdF92YWx1ZSIsInZhcmlhYmxlX21hcCIsImRlZmF1bHQkMCIsInByb3BzIiwicHJvcHMkMCIsImV2YWxfYXJnbGlzdCIsImFyZ2xpc3QiLCJrZXlfdmFsdWVzIiwiYXJnbGlzdCQwIiwiZiQwIiwibWF0Y2giLCJhcmdsaXN0JDEiLCJjb25zdF92YWx1ZSIsImNvZXJjZWQiLCJldmFsX2FyZyIsImFyZ2xpc3QkMiIsImFyZ2xpc3QkMyIsImYkMiIsImYkMSIsInZhbHVlJDAiLCJ2YWx1ZSQxIiwidmFsdWUkMiIsInR5cCQwIiwidmFsdWUkMyIsIm9wdGlvbl92YWx1ZXMiLCJ0eXAkMSIsImFyZyIsImFyZyQwIiwic2NhbGFyIiwiY29lcmNlIiwiZW51bSQwIiwib2JqIiwidW5pb24kMCIsImludGVyZmFjZSQwIiwiZml4JDAiLCJzY2hlbWEiLCJtdXRhdGlvbnMiLCJzdWJzY3JpcHRpb25zIiwibXV0YXRpb25fbmFtZSIsInN0aCQwIiwic3Vic2NyaXB0aW9uX25hbWUiLCJzdGgkMSIsInF1ZXJ5X25hbWUiLCJvYmokMCIsImZpZWxkIiwiYXJncyIsInJlc29sdmUiLCJpb19maWVsZCIsImFic3RyYWN0X2ZpZWxkIiwic3Vic2NyaXB0aW9uX2ZpZWxkIiwiZW51bSQxIiwic2NhbGFyJDAiLCJsaXN0JDAiLCJub25fbnVsbCQwIiwiYWRkX3R5cGUiLCJhYnN0cmFjdF90eXAiLCJvIiwic3JjIiwib2JqX29mX3N1YnNjcmlwdGlvbl9vYmoiLCJmaWVsZHMkMCIsImN0eCIsImludCQxIiwic3RyaW5nJDAiLCJib29sJDAiLCJmbG9hdCQxIiwiZ3VpZCQwIiwic2tpcF9kaXJlY3RpdmUiLCJpbmNsdWRlX2RpcmVjdGl2ZSIsInVubGVzc192aXNpdGVkIiwidmlzaXRlZCIsInJlc3VsdCIsInR5cGVzIiwicmVzdWx0JDAiLCJ2aXNpdGVkJDAiLCJyZWR1Y2VyIiwibWVtbyQwIiwiYXJnX2xpc3RfdHlwZXMiLCJ0eXAkMiIsIm9wdCQyIiwiYXJnX3R5cGVzIiwiYXJndHlwIiwiYXJndHlwJDAiLCJhcmd0eXAkMSIsImFyZ3R5cCQyIiwibWVtbyQxIiwidHlwZXNfb2Zfc2NoZW1hIiwidHlwZXMkMCIsIm9wIiwib3AkMCIsImFyZ3NfdG9fbGlzdCIsIm5vX2Fic3RyYWN0cyIsImVudW1fdmFsdWUkMCIsInJlYXNvbiIsImlucHV0X3ZhbHVlIiwidHlwZSIsImZpZWxkJDAiLCJtYXRjaCQwIiwiaW50ZXJmYWNlcyIsIm1hdGNoJDEiLCJhcmdfbGlzdCIsImRpcmVjdGl2ZSIsImQiLCJzY2hlbWEkMCIsInN1YnMiLCJtdXQiLCJhZGRfYnVpbHRfaW5fZmllbGRzIiwic2NoZW1hX2ZpZWxkIiwidHlwZV9maWVsZCIsIm1hdGNoZXNfdHlwZV9jb25kaXRpb24iLCJ0eXBlX2NvbmRpdGlvbiIsImFic3RyYWN0JDAiLCJzaG91bGRfaW5jbHVkZV9maWVsZCIsImRpcmVjdGl2ZXMiLCJyZXN0JDAiLCJhcmd1bWVudHMkMSIsImV2YWxfZGlyZWN0aXZlIiwicmVzdCIsImFyZ3VtZW50cyQwIiwiYWxpYXNfb3JfbmFtZSIsImFsaWFzIiwibWVyZ2Vfc2VsZWN0aW9ucyIsIm1hdGNoaW5nIiwic2VsZWN0aW9uX3NldHMiLCJzZWxlY3Rpb25fc2V0IiwiY29sbGVjdF9maWVsZHMiLCJpbmNsdWRlX2ZpZWxkIiwic3ByZWFkIiwiZnJhZ21lbnQiLCJjb25kaXRpb24iLCJtYXRjaGVzX3R5cGVfY29uZGl0aW9uJDAiLCJmaWVsZF9mcm9tX29iamVjdCIsImZpZWxkX2Zyb21fc3Vic2NyaXB0aW9uX29iamVjdCIsImNvZXJjZV9vcl9udWxsIiwic3JjJDAiLCJtYXBfZmllbGRzX3dpdGhfb3JkZXIiLCJlcnJvcl90b19qc29uIiwicGF0aCIsImV4dGVuc2lvbnMiLCJtc2ciLCJwYXRoJDAiLCJleHRlbnNpb25zJDAiLCJleHRlbnNpb25fcHJvcHMiLCJlcnJvcl9yZXNwb25zZSIsImRhdGEiLCJlcnJvcnMiLCJkYXRhJDAiLCJkYXRhJDEiLCJwcmVzZW50IiwicXVlcnlfZmllbGQiLCJyZXNvbHZlX2ZpZWxkcyIsInNyYyQxIiwicmVzb2x2ZV9maWVsZCIsInJlc29sdmVfaW5mbyIsInJlc29sdmVyIiwidW5saWZ0ZWRfdmFsdWUiLCJyZXNvbHZlZCIsImxpZnRlZF92YWx1ZSIsImV4ZWN1dGlvbl9vcmRlciIsImRhdGFfdG9fanNvbiIsImVycm9ycyQwIiwiZmllbGRfZXJyb3IiLCJ0b19yZXNwb25zZSIsInJlcyIsIm1zZyQwIiwibXNnJDEiLCJzdWJzY3JpYmUiLCJzdWJzX2ZpZWxkIiwic291cmNlX3N0cmVhbSIsImV4ZWN1dGVfb3BlcmF0aW9uIiwib3BlcmF0aW9uIiwicXVlcnkiLCJkYXRhX2VycnMiLCJzdHJlYW0iLCJjb2xsZWN0X2ZyYWdtZW50cyIsInZhbGlkYXRlX2ZyYWdtZW50cyIsImZyYWdtZW50X21hcCIsInZhbGlkYXRlX2ZyYWdtZW50IiwiZnJhZ21lbnRfbmFtZXMiLCJjeWNsZSIsInZhbGlkYXRlX2ZyYWdtZW50X3NlbGVjdGlvbiIsInNlbGVjdGlvbiIsImZyYWdtZW50X3NwcmVhZCIsImlubGluZV9mcmFnbWVudCIsImNvbGxlY3RfYW5kX3ZhbGlkYXRlX2ZyYWdtZW50cyIsImZyYWdtZW50cyIsImNvbGxlY3Rfb3BlcmF0aW9ucyIsInNlbGVjdF9vcGVyYXRpb24iLCJvcGVyYXRpb25fbmFtZSIsIm9wZXJhdGlvbnMiLCJleGVjdXRlIiwidmFyaWFibGVzIiwiZGVmYXVsdF92YXJpYWJsZXMiLCJkZWZhdWx0X3ZhbHVlIiwidmFyaWFibGVzJDAiLCJleGVjdXRpb25fY3R4IiwibWVzc2FnZV9vZl9maWVsZF9lcnJvciIsImV4dGVuc2lvbnNfb2ZfZmllbGRfZXJyb3IiLCJtYXAiLCJpdGVyIiwiY2xvc2UiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi9ncmFwaHFsL2dyYXBocWxfc2NoZW1hLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvZ3JhcGhxbC9ncmFwaHFsLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7SUFnMEJRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrZUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUExeENGQzs7O0lBSkFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QztZQUdBRztZQUdBQztZQWFBQztZQUlBQztZQUVBQztZQUVBQztZQUVBQztZQUVBQzs7WUE0QkFPO1lBR0FDO1lBR0FDO1lBR0FDO1lBR0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBNnlDQTRIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7WUNyOERJTSx1QkFBdUI3UCxHQUFJLE9BQUpBLEVBQUs7WUFFNUI4UCwwQkFBMEI5UCxHQUFLLFNBQUk7R0FMeEMsY0FHSzZQLHdCQUVBQztZQW5CQTFQLEtBQUtKLEdBQUVDLEdBQUksT0FBQSxXQUFKQSxHQUFGRCxHQUFTO1lBRWRHLFNBQU9ILEdBQUksT0FBSkEsRUFBSztZQUtWK1AsSUFBSS9QLEdBQUVDLEdBQUksT0FBQSwyQkFBSkEsR0FBRkQsR0FBaUI7WUFFckJnUSxLQUFLaFEsR0FBRUMsR0FBSSxPQUFBLDBCQUFKQSxHQUFGRCxHQUFrQjtZQUV2QmlRLE1BQU1qUSxHQUFLLFNBQUU7R0FQSDtJQUFBLGFBR1YrUCxLQUVBQyxNQUVBQzs7OzBDQVRGOVAsVUFGQUM7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIEhlbHBlciBtb2R1bGVzICopXG5tb2R1bGUgTGlzdCA9IHN0cnVjdFxuICBpbmNsdWRlIExpc3RcblxuICBsZXQgYXNzb2NfZXhuID0gYXNzb2NcblxuICBsZXQgYXNzb2MgeCB5cyA9IHRyeSBTb21lIChhc3NvY19leG4geCB5cykgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuXG4gIGxldCBmaW5kX2V4biA9IGZpbmRcblxuICBsZXQgZmluZCBjb25kIHhzID0gdHJ5IFNvbWUgKGZpbmRfZXhuIGNvbmQgeHMpIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcblxuICBtb2R1bGUgUmVzdWx0ID0gc3RydWN0XG4gICAgbGV0IHJlYyBqb2luID8obWVtbyA9IFtdKSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IE9rIChMaXN0LnJldiBtZW1vKVxuICAgICAgfCAoRXJyb3IgXyBhcyBlcnIpIDo6IF8gLT4gZXJyXG4gICAgICB8IE9rIHggOjogeHMgLT4gam9pbiB+bWVtbzooeCA6OiBtZW1vKSB4c1xuXG4gICAgbGV0IGFsbCBmIHhzID0gTGlzdC5tYXAgZiB4cyB8PiBqb2luXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBPcHRpb24gPSBzdHJ1Y3RcbiAgbGV0IHZhbHVlIHQgfmRlZmF1bHQgPSBtYXRjaCB0IHdpdGggTm9uZSAtPiBkZWZhdWx0IHwgU29tZSB4IC0+IHhcbiAgbGV0IG1hcCB0IH5mID0gbWF0Y2ggdCB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgeSAtPiBTb21lIChmIHkpXG5lbmRcblxuKCogSU8gKilcbm1vZHVsZSB0eXBlIElPID0gc2lnXG4gIHR5cGUgKydhIHRcblxuICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuXG4gIG1vZHVsZSBTdHJlYW0gOiBzaWdcbiAgICB0eXBlICsnYSBpb1xuXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgbWFwIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgaW8pIC0+ICdiIHRcblxuICAgIHZhbCBpdGVyIDogJ2EgdCAtPiAoJ2EgLT4gdW5pdCBpbykgLT4gdW5pdCBpb1xuXG4gICAgdmFsIGNsb3NlIDogJ2EgdCAtPiB1bml0XG4gIGVuZFxuICB3aXRoIHR5cGUgJ2EgaW8gOj0gJ2EgdFxuZW5kXG5cbigqIEZpZWxkX2Vycm9yICopXG5tb2R1bGUgdHlwZSBGaWVsZF9lcnJvciA9IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgbWVzc2FnZV9vZl9maWVsZF9lcnJvciA6IHQgLT4gc3RyaW5nXG5cbiAgdmFsIGV4dGVuc2lvbnNfb2ZfZmllbGRfZXJyb3IgOlxuICAgIHQgLT4gKHN0cmluZyAqIFlvanNvbi5CYXNpYy50KSBsaXN0IG9wdGlvblxuZW5kXG5cbigqIFNjaGVtYSAqKVxubW9kdWxlIE1ha2UgKElvIDogSU8pIChGaWVsZF9lcnJvciA6IEZpZWxkX2Vycm9yKSA9IHN0cnVjdFxuICBtb2R1bGUgSW8gPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIElvXG5cbiAgICBsZXQgbWFwIHggfmYgPSBiaW5kIHggKGZ1biB4JyAtPiByZXR1cm4gKGYgeCcpKVxuXG4gICAgbGV0IG9rIHggPSBJby5yZXR1cm4gKE9rIHgpXG5cbiAgICBsZXQgZXJyb3IgeCA9IElvLnJldHVybiAoRXJyb3IgeClcblxuICAgIGxldCByZWMgYWxsID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gSW8ucmV0dXJuIFtdXG4gICAgICB8IHggOjogeHMgLT4gYmluZCAoYWxsIHhzKSAoZnVuIHhzJyAtPiBtYXAgeCB+ZjooZnVuIHgnIC0+IHgnIDo6IHhzJykpXG5cbiAgICBtb2R1bGUgUmVzdWx0ID0gc3RydWN0XG4gICAgICBsZXQgYmluZCB4IGYgPVxuICAgICAgICBiaW5kIHggKGZ1bmN0aW9uIE9rIHgnIC0+IGYgeCcgfCBFcnJvciBfIGFzIGVyciAtPiBJby5yZXR1cm4gZXJyKVxuXG4gICAgICBsZXQgbWFwX2Vycm9yIHggfmYgPVxuICAgICAgICBtYXAgeCB+ZjooZnVuY3Rpb24gT2sgXyBhcyBvayAtPiBvayB8IEVycm9yIGVyciAtPiBFcnJvciAoZiBlcnIpKVxuXG4gICAgICBsZXQgbWFwIHggfmYgPVxuICAgICAgICBtYXAgeCB+ZjooZnVuY3Rpb24gT2sgeCcgLT4gT2sgKGYgeCcpIHwgRXJyb3IgXyBhcyBlcnIgLT4gZXJyKVxuICAgIGVuZFxuXG4gICAgbGV0IHJlYyBtYXBfcyA/KG1lbW8gPSBbXSkgZiA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IElvLnJldHVybiAoTGlzdC5yZXYgbWVtbylcbiAgICAgIHwgeCA6OiB4cyAtPiBiaW5kIChmIHgpIChmdW4geCcgLT4gbWFwX3Mgfm1lbW86KHgnIDo6IG1lbW8pIGYgeHMpXG5cbiAgICBsZXQgbWFwX3AgZiB4cyA9IExpc3QubWFwIGYgeHMgfD4gYWxsXG5cbiAgICBtb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgICAgIGxldCAoID4+fCApIHggZiA9IG1hcCB4IH5mXG5cbiAgICAgIGxldCAoID4+PT8gKSA9IFJlc3VsdC5iaW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIG1vZHVsZSBTdHJpbmdNYXAgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1hcC5NYWtlIChTdHJpbmcpXG5cbiAgICBleGNlcHRpb24gTWlzc2luZ19rZXkgb2Ygc3RyaW5nXG5cbiAgICBsZXQgZmluZF9leG4ga2V5IHQgPVxuICAgICAgdHJ5IGZpbmQga2V5IHQgd2l0aCBOb3RfZm91bmQgLT4gcmFpc2UgKE1pc3Npbmdfa2V5IGtleSlcblxuICAgIGxldCBmaW5kIGsgdCA9IHRyeSBTb21lIChmaW5kX2V4biBrIHQpIHdpdGggTWlzc2luZ19rZXkgXyAtPiBOb25lXG4gIGVuZFxuXG4gIG1vZHVsZSBTdHJpbmdTZXQgPSBTZXQuTWFrZSAoU3RyaW5nKVxuXG4gIHR5cGUgZmllbGRfZXJyb3IgPSBGaWVsZF9lcnJvci50XG5cbiAgdHlwZSB2YXJpYWJsZV9tYXAgPSBHcmFwaHFsX3BhcnNlci5jb25zdF92YWx1ZSBTdHJpbmdNYXAudFxuXG4gIHR5cGUgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQgfCBEZXByZWNhdGVkIG9mIHN0cmluZyBvcHRpb25cblxuICB0eXBlICdhIGVudW1fdmFsdWUgPSB7XG4gICAgbmFtZSA6IHN0cmluZztcbiAgICBkb2MgOiBzdHJpbmcgb3B0aW9uO1xuICAgIGRlcHJlY2F0ZWQgOiBkZXByZWNhdGVkO1xuICAgIHZhbHVlIDogJ2E7XG4gIH1cblxuICB0eXBlIGpzb24gPSBZb2pzb24uQmFzaWMudFxuXG4gIGxldCBlbnVtX3ZhbHVlID9kb2MgPyhkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZCkgbmFtZSB+dmFsdWUgPVxuICAgIHsgbmFtZTsgZG9jOyBkZXByZWNhdGVkOyB2YWx1ZSB9XG5cbiAgbGV0IGlkIDogJ2EuICdhIC0+ICdhID0gZnVuIHggLT4geFxuXG4gIG1vZHVsZSBBcmcgPSBzdHJ1Y3RcbiAgICBvcGVuIFJyZXN1bHRcblxuICAgIHR5cGUgXyBhcmdfdHlwID1cbiAgICAgIHwgU2NhbGFyIDoge1xuICAgICAgICAgIG5hbWUgOiBzdHJpbmc7XG4gICAgICAgICAgZG9jIDogc3RyaW5nIG9wdGlvbjtcbiAgICAgICAgICBjb2VyY2UgOiBHcmFwaHFsX3BhcnNlci5jb25zdF92YWx1ZSAtPiAoJ2EsIHN0cmluZykgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgICAgLT4gJ2Egb3B0aW9uIGFyZ190eXBcbiAgICAgIHwgT2JqZWN0IDoge1xuICAgICAgICAgIG5hbWUgOiBzdHJpbmc7XG4gICAgICAgICAgZG9jIDogc3RyaW5nIG9wdGlvbjtcbiAgICAgICAgICBmaWVsZHMgOiAoJ2EsICdiKSBhcmdfbGlzdCBMYXp5LnQ7XG4gICAgICAgICAgY29lcmNlIDogJ2I7XG4gICAgICAgIH1cbiAgICAgICAgICAtPiAnYSBvcHRpb24gYXJnX3R5cFxuICAgICAgfCBFbnVtIDoge1xuICAgICAgICAgIG5hbWUgOiBzdHJpbmc7XG4gICAgICAgICAgZG9jIDogc3RyaW5nIG9wdGlvbjtcbiAgICAgICAgICB2YWx1ZXMgOiAnYSBlbnVtX3ZhbHVlIGxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgICAtPiAnYSBvcHRpb24gYXJnX3R5cFxuICAgICAgfCBMaXN0IDogJ2EgYXJnX3R5cCAtPiAnYSBsaXN0IG9wdGlvbiBhcmdfdHlwXG4gICAgICB8IE5vbk51bGxhYmxlIDogJ2Egb3B0aW9uIGFyZ190eXAgLT4gJ2EgYXJnX3R5cFxuXG4gICAgYW5kIF8gYXJnID1cbiAgICAgIHwgQXJnIDoge1xuICAgICAgICAgIG5hbWUgOiBzdHJpbmc7XG4gICAgICAgICAgZG9jIDogc3RyaW5nIG9wdGlvbjtcbiAgICAgICAgICB0eXAgOiAnYSBhcmdfdHlwO1xuICAgICAgICB9XG4gICAgICAgICAgLT4gJ2EgYXJnXG4gICAgICB8IERlZmF1bHRBcmcgOiB7XG4gICAgICAgICAgbmFtZSA6IHN0cmluZztcbiAgICAgICAgICBkb2MgOiBzdHJpbmcgb3B0aW9uO1xuICAgICAgICAgIHR5cCA6ICdhIG9wdGlvbiBhcmdfdHlwO1xuICAgICAgICAgIGRlZmF1bHQgOiAnYTtcbiAgICAgICAgICBkZWZhdWx0X3ZhbHVlIDogR3JhcGhxbF9wYXJzZXIuY29uc3RfdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgICAtPiAnYSBhcmdcblxuICAgIGFuZCAoXywgXykgYXJnX2xpc3QgPVxuICAgICAgfCBbXSA6ICgnYSwgJ2EpIGFyZ19saXN0XG4gICAgICB8ICggOjogKSA6ICdhIGFyZyAqICgnYiwgJ2MpIGFyZ19saXN0IC0+ICgnYiwgJ2EgLT4gJ2MpIGFyZ19saXN0XG5cbiAgICB0eXBlICdhIGZpeHBvaW50ID0ge1xuICAgICAgb2JqOiAnc3JjICd0ICdhcmdzLlxuICAgICAgICAgID9kb2M6c3RyaW5nXG4gICAgICAgICAgLT4gc3RyaW5nXG4gICAgICAgICAgLT4gZmllbGRzOignYSAtPiAoJ3QsICdhcmdzKSBhcmdfbGlzdClcbiAgICAgICAgICAtPiBjb2VyY2U6J2FyZ3NcbiAgICAgICAgICAtPiAndCBvcHRpb24gYXJnX3R5cFxuICAgIH1cblxuICAgIGxldCBvYmogP2RvYyBuYW1lIH5maWVsZHMgfmNvZXJjZSA9XG4gICAgICBPYmplY3QgeyBuYW1lOyBkb2M7IGZpZWxkczsgY29lcmNlIH1cblxuICAgIGxldCBmaXggOiAoJ2EgZml4cG9pbnQgLT4gJ2EpIC0+ICdhID0gZnVuIGYgLT5cbiAgICAgIGxldCByZWMgcmVjdXJzaXZlID0ge1xuICAgICAgICBvYmogPSBmdW4gP2RvYyBuYW1lIH5maWVsZHMgLT5cbiAgICAgICAgICBvYmogP2RvYyBuYW1lIH5maWVsZHM6KGxhenkgKGZpZWxkcyAoTGF6eS5mb3JjZSByKSkpXG4gICAgICB9XG4gICAgICBhbmQgciA9IGxhenkgKGYgcmVjdXJzaXZlKVxuICAgICAgaW4gTGF6eS5mb3JjZSByXG5cbiAgICBsZXQgcmVjIHN0cmluZ19vZl9jb25zdF92YWx1ZSA6IEdyYXBocWxfcGFyc2VyLmNvbnN0X3ZhbHVlIC0+IHN0cmluZyA9XG4gICAgICBmdW5jdGlvblxuICAgICAgfCBgTnVsbCAtPiBZb2pzb24uQmFzaWMudG9fc3RyaW5nIGBOdWxsXG4gICAgICB8IGBJbnQgaSAtPiBZb2pzb24uQmFzaWMudG9fc3RyaW5nIChgSW50IGkpXG4gICAgICB8IGBGbG9hdCBmIC0+IFlvanNvbi5CYXNpYy50b19zdHJpbmcgKGBGbG9hdCBmKVxuICAgICAgfCBgU3RyaW5nIHMgLT4gWW9qc29uLkJhc2ljLnRvX3N0cmluZyAoYFN0cmluZyBzKVxuICAgICAgfCBgQm9vbCBiIC0+IFlvanNvbi5CYXNpYy50b19zdHJpbmcgKGBCb29sIGIpXG4gICAgICB8IGBFbnVtIGUgLT4gZVxuICAgICAgfCBgTGlzdCBsIC0+XG4gICAgICAgICAgbGV0IHZhbHVlcyA9IExpc3QubWFwIChmdW4gaSAtPiBzdHJpbmdfb2ZfY29uc3RfdmFsdWUgaSkgbCBpblxuICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiWyVzXVwiIChTdHJpbmcuY29uY2F0IFwiLCBcIiB2YWx1ZXMpXG4gICAgICB8IGBBc3NvYyBhIC0+XG4gICAgICAgICAgbGV0IHZhbHVlcyA9XG4gICAgICAgICAgICBMaXN0Lm1hcFxuICAgICAgICAgICAgICAoZnVuIChrLCB2KSAtPlxuICAgICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiJXM6ICVzXCIgayAoc3RyaW5nX29mX2NvbnN0X3ZhbHVlIHYpKVxuICAgICAgICAgICAgICBhXG4gICAgICAgICAgaW5cbiAgICAgICAgICBQcmludGYuc3ByaW50ZiBcInslc31cIiAoU3RyaW5nLmNvbmNhdCBcIiwgXCIgdmFsdWVzKVxuXG4gICAgbGV0IHJlYyBzdHJpbmdfb2ZfYXJnX3R5cCA6IHR5cGUgYS4gYSBhcmdfdHlwIC0+IHN0cmluZyA9IGZ1bmN0aW9uXG4gICAgICB8IFNjYWxhciBhIC0+IGEubmFtZVxuICAgICAgfCBPYmplY3QgYSAtPiBhLm5hbWVcbiAgICAgIHwgRW51bSBhIC0+IGEubmFtZVxuICAgICAgfCBMaXN0IGEgLT4gUHJpbnRmLnNwcmludGYgXCJbJXNdXCIgKHN0cmluZ19vZl9hcmdfdHlwIGEpXG4gICAgICB8IE5vbk51bGxhYmxlIGEgLT4gUHJpbnRmLnNwcmludGYgXCIlcyFcIiAoc3RyaW5nX29mX2FyZ190eXAgYSlcblxuICAgIGxldCBldmFsX2FyZ19lcnJvciA/KGZpZWxkX3R5cGUgPSBcImZpZWxkXCIpIH5maWVsZF9uYW1lIH5hcmdfbmFtZSBhcmdfdHlwXG4gICAgICAgIHZhbHVlID1cbiAgICAgIGxldCBmb3VuZF9zdHIgPVxuICAgICAgICBtYXRjaCB2YWx1ZSB3aXRoXG4gICAgICAgIHwgU29tZSB2IC0+IFByaW50Zi5zcHJpbnRmIFwiZm91bmQgJXNcIiAoc3RyaW5nX29mX2NvbnN0X3ZhbHVlIHYpXG4gICAgICAgIHwgTm9uZSAtPiBcImJ1dCBub3QgcHJvdmlkZWRcIlxuICAgICAgaW5cbiAgICAgIFByaW50Zi5zcHJpbnRmIFwiQXJndW1lbnQgYCVzYCBvZiB0eXBlIGAlc2AgZXhwZWN0ZWQgb24gJXMgYCVzYCwgJXMuXCJcbiAgICAgICAgYXJnX25hbWVcbiAgICAgICAgKHN0cmluZ19vZl9hcmdfdHlwIGFyZ190eXApXG4gICAgICAgIGZpZWxkX3R5cGUgZmllbGRfbmFtZSBmb3VuZF9zdHJcblxuICAgICgqIEJ1aWx0LWluIGFyZ3VtZW50IHR5cGVzICopXG4gICAgbGV0IGludCA9XG4gICAgICBTY2FsYXJcbiAgICAgICAge1xuICAgICAgICAgIG5hbWUgPSBcIkludFwiO1xuICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgY29lcmNlID0gKGZ1bmN0aW9uIGBJbnQgbiAtPiBPayBuIHwgXyAtPiBFcnJvciBcIkludmFsaWQgaW50XCIpO1xuICAgICAgICB9XG5cbiAgICBsZXQgc3RyaW5nID1cbiAgICAgIFNjYWxhclxuICAgICAgICB7XG4gICAgICAgICAgbmFtZSA9IFwiU3RyaW5nXCI7XG4gICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICBjb2VyY2UgPSAoZnVuY3Rpb24gYFN0cmluZyBzIC0+IE9rIHMgfCBfIC0+IEVycm9yIFwiSW52YWxpZCBzdHJpbmdcIik7XG4gICAgICAgIH1cblxuICAgIGxldCBmbG9hdCA9XG4gICAgICBTY2FsYXJcbiAgICAgICAge1xuICAgICAgICAgIG5hbWUgPSBcIkZsb2F0XCI7XG4gICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICBjb2VyY2UgPVxuICAgICAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGBGbG9hdCBmIC0+IE9rIGZcbiAgICAgICAgICAgIHwgYEludCBuIC0+IE9rIChmbG9hdF9vZl9pbnQgbilcbiAgICAgICAgICAgIHwgXyAtPiBFcnJvciBcIkludmFsaWQgZmxvYXRcIik7XG4gICAgICAgIH1cblxuICAgIGxldCBib29sID1cbiAgICAgIFNjYWxhclxuICAgICAgICB7XG4gICAgICAgICAgbmFtZSA9IFwiQm9vbGVhblwiO1xuICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgY29lcmNlID0gKGZ1bmN0aW9uIGBCb29sIGIgLT4gT2sgYiB8IF8gLT4gRXJyb3IgXCJJbnZhbGlkIGJvb2xlYW5cIik7XG4gICAgICAgIH1cblxuICAgIGxldCBndWlkID1cbiAgICAgIFNjYWxhclxuICAgICAgICB7XG4gICAgICAgICAgbmFtZSA9IFwiSURcIjtcbiAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgIGNvZXJjZSA9XG4gICAgICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgIHwgYFN0cmluZyBzIC0+IE9rIHNcbiAgICAgICAgICAgIHwgYEludCBuIC0+IE9rIChzdHJpbmdfb2ZfaW50IG4pXG4gICAgICAgICAgICB8IF8gLT4gRXJyb3IgXCJJbnZhbGlkIElEXCIpO1xuICAgICAgICB9XG5cbiAgICBsZXQgbm9uX251bGwgdHlwID0gTm9uTnVsbGFibGUgdHlwXG5cbiAgICBsZXQgbGlzdCB0eXAgPSBMaXN0IHR5cFxuXG4gICAgbGV0IHJlYyB2YWx1ZV90b19jb25zdF92YWx1ZSB2YXJpYWJsZV9tYXAgPSBmdW5jdGlvblxuICAgICAgfCBgTnVsbCAtPiBgTnVsbFxuICAgICAgfCBgSW50IF8gYXMgaSAtPiBpXG4gICAgICB8IGBGbG9hdCBfIGFzIGYgLT4gZlxuICAgICAgfCBgU3RyaW5nIF8gYXMgcyAtPiBzXG4gICAgICB8IGBCb29sIF8gYXMgYiAtPiBiXG4gICAgICB8IGBFbnVtIF8gYXMgZSAtPiBlXG4gICAgICB8IGBWYXJpYWJsZSB2IC0+IE9wdGlvbi52YWx1ZSB+ZGVmYXVsdDpgTnVsbCAoU3RyaW5nTWFwLmZpbmQgdiB2YXJpYWJsZV9tYXApXG4gICAgICB8IGBMaXN0IHhzIC0+IGBMaXN0IChMaXN0Lm1hcCAodmFsdWVfdG9fY29uc3RfdmFsdWUgdmFyaWFibGVfbWFwKSB4cylcbiAgICAgIHwgYEFzc29jIHByb3BzIC0+XG4gICAgICAgICAgbGV0IHByb3BzJyA9XG4gICAgICAgICAgICBMaXN0Lm1hcFxuICAgICAgICAgICAgICAoZnVuIChuYW1lLCB2YWx1ZSkgLT5cbiAgICAgICAgICAgICAgICAobmFtZSwgdmFsdWVfdG9fY29uc3RfdmFsdWUgdmFyaWFibGVfbWFwIHZhbHVlKSlcbiAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICBpblxuICAgICAgICAgIGBBc3NvYyBwcm9wcydcblxuICAgIGxldCByZWMgZXZhbF9hcmdsaXN0IDpcbiAgICAgICAgdHlwZSBhIGIuXG4gICAgICAgIHZhcmlhYmxlX21hcCAtPlxuICAgICAgICA/ZmllbGRfdHlwZTpzdHJpbmcgLT5cbiAgICAgICAgZmllbGRfbmFtZTpzdHJpbmcgLT5cbiAgICAgICAgKGEsIGIpIGFyZ19saXN0IC0+XG4gICAgICAgIChzdHJpbmcgKiBHcmFwaHFsX3BhcnNlci52YWx1ZSkgbGlzdCAtPlxuICAgICAgICBiIC0+XG4gICAgICAgIChhLCBzdHJpbmcpIHJlc3VsdCA9XG4gICAgIGZ1biB2YXJpYWJsZV9tYXAgP2ZpZWxkX3R5cGUgfmZpZWxkX25hbWUgYXJnbGlzdCBrZXlfdmFsdWVzIGYgLT5cbiAgICAgIG1hdGNoIGFyZ2xpc3Qgd2l0aFxuICAgICAgfCBbXSAtPiBPayBmXG4gICAgICB8IERlZmF1bHRBcmcgYXJnIDo6IGFyZ2xpc3QnIC0+XG4gICAgICAgICAgbGV0IGFyZ2xpc3QnJyA9XG4gICAgICAgICAgICBBcmcgeyBuYW1lID0gYXJnLm5hbWU7IGRvYyA9IGFyZy5kb2M7IHR5cCA9IGFyZy50eXAgfSA6OiBhcmdsaXN0J1xuICAgICAgICAgIGluXG4gICAgICAgICAgZXZhbF9hcmdsaXN0IHZhcmlhYmxlX21hcCA/ZmllbGRfdHlwZSB+ZmllbGRfbmFtZSBhcmdsaXN0JydcbiAgICAgICAgICAgIGtleV92YWx1ZXMgKGZ1bmN0aW9uXG4gICAgICAgICAgICB8IE5vbmUgLT4gZiBhcmcuZGVmYXVsdFxuICAgICAgICAgICAgfCBTb21lIHZhbHVlIC0+IGYgdmFsdWUpXG4gICAgICB8IEFyZyBhcmcgOjogYXJnbGlzdCcgLT5cbiAgICAgICAgICBsZXQgdmFsdWUgPSBMaXN0LmFzc29jIGFyZy5uYW1lIGtleV92YWx1ZXMgaW5cbiAgICAgICAgICBsZXQgY29uc3RfdmFsdWUgPVxuICAgICAgICAgICAgT3B0aW9uLm1hcCB2YWx1ZSB+ZjoodmFsdWVfdG9fY29uc3RfdmFsdWUgdmFyaWFibGVfbWFwKVxuICAgICAgICAgIGluXG4gICAgICAgICAgZXZhbF9hcmcgdmFyaWFibGVfbWFwID9maWVsZF90eXBlIH5maWVsZF9uYW1lIH5hcmdfbmFtZTphcmcubmFtZVxuICAgICAgICAgICAgYXJnLnR5cCBjb25zdF92YWx1ZVxuICAgICAgICAgID4+PSBmdW4gY29lcmNlZCAtPlxuICAgICAgICAgIGV2YWxfYXJnbGlzdCB2YXJpYWJsZV9tYXAgP2ZpZWxkX3R5cGUgfmZpZWxkX25hbWUgYXJnbGlzdCdcbiAgICAgICAgICAgIGtleV92YWx1ZXMgKGYgY29lcmNlZClcblxuICAgIGFuZCBldmFsX2FyZyA6XG4gICAgICAgIHR5cGUgYS5cbiAgICAgICAgdmFyaWFibGVfbWFwIC0+XG4gICAgICAgID9maWVsZF90eXBlOnN0cmluZyAtPlxuICAgICAgICBmaWVsZF9uYW1lOnN0cmluZyAtPlxuICAgICAgICBhcmdfbmFtZTpzdHJpbmcgLT5cbiAgICAgICAgYSBhcmdfdHlwIC0+XG4gICAgICAgIEdyYXBocWxfcGFyc2VyLmNvbnN0X3ZhbHVlIG9wdGlvbiAtPlxuICAgICAgICAoYSwgc3RyaW5nKSByZXN1bHQgPVxuICAgICBmdW4gdmFyaWFibGVfbWFwID9maWVsZF90eXBlIH5maWVsZF9uYW1lIH5hcmdfbmFtZSB0eXAgdmFsdWUgLT5cbiAgICAgIG1hdGNoICh0eXAsIHZhbHVlKSB3aXRoXG4gICAgICB8IE5vbk51bGxhYmxlIF8sIE5vbmUgLT5cbiAgICAgICAgICBFcnJvciAoZXZhbF9hcmdfZXJyb3IgP2ZpZWxkX3R5cGUgfmZpZWxkX25hbWUgfmFyZ19uYW1lIHR5cCB2YWx1ZSlcbiAgICAgIHwgTm9uTnVsbGFibGUgXywgU29tZSBgTnVsbCAtPlxuICAgICAgICAgIEVycm9yIChldmFsX2FyZ19lcnJvciA/ZmllbGRfdHlwZSB+ZmllbGRfbmFtZSB+YXJnX25hbWUgdHlwIHZhbHVlKVxuICAgICAgfCBTY2FsYXIgXywgTm9uZSAtPiBPayBOb25lXG4gICAgICB8IFNjYWxhciBfLCBTb21lIGBOdWxsIC0+IE9rIE5vbmVcbiAgICAgIHwgT2JqZWN0IF8sIE5vbmUgLT4gT2sgTm9uZVxuICAgICAgfCBPYmplY3QgXywgU29tZSBgTnVsbCAtPiBPayBOb25lXG4gICAgICB8IExpc3QgXywgTm9uZSAtPiBPayBOb25lXG4gICAgICB8IExpc3QgXywgU29tZSBgTnVsbCAtPiBPayBOb25lXG4gICAgICB8IEVudW0gXywgTm9uZSAtPiBPayBOb25lXG4gICAgICB8IEVudW0gXywgU29tZSBgTnVsbCAtPiBPayBOb25lXG4gICAgICB8IFNjYWxhciBzLCBTb21lIHZhbHVlIC0+IChcbiAgICAgICAgICBtYXRjaCBzLmNvZXJjZSB2YWx1ZSB3aXRoXG4gICAgICAgICAgfCBPayBjb2VyY2VkIC0+IE9rIChTb21lIGNvZXJjZWQpXG4gICAgICAgICAgfCBFcnJvciBfIC0+XG4gICAgICAgICAgICAgIEVycm9yXG4gICAgICAgICAgICAgICAgKGV2YWxfYXJnX2Vycm9yID9maWVsZF90eXBlIH5maWVsZF9uYW1lIH5hcmdfbmFtZSB0eXBcbiAgICAgICAgICAgICAgICAgICAoU29tZSB2YWx1ZSkpIClcbiAgICAgIHwgT2JqZWN0IG8sIFNvbWUgdmFsdWUgLT4gKFxuICAgICAgICAgIG1hdGNoIHZhbHVlIHdpdGhcbiAgICAgICAgICB8IGBBc3NvYyBwcm9wcyAtPlxuICAgICAgICAgICAgICBsZXQgcHJvcHMnID0gKHByb3BzIDo+IChzdHJpbmcgKiBHcmFwaHFsX3BhcnNlci52YWx1ZSkgbGlzdCkgaW5cbiAgICAgICAgICAgICAgZXZhbF9hcmdsaXN0IHZhcmlhYmxlX21hcCA/ZmllbGRfdHlwZSB+ZmllbGRfbmFtZSAoTGF6eS5mb3JjZSBvLmZpZWxkcykgcHJvcHMnXG4gICAgICAgICAgICAgICAgby5jb2VyY2VcbiAgICAgICAgICAgICAgPj58IGZ1biBjb2VyY2VkIC0+IFNvbWUgY29lcmNlZFxuICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICBFcnJvclxuICAgICAgICAgICAgICAgIChldmFsX2FyZ19lcnJvciA/ZmllbGRfdHlwZSB+ZmllbGRfbmFtZSB+YXJnX25hbWUgdHlwXG4gICAgICAgICAgICAgICAgICAgKFNvbWUgdmFsdWUpKSApXG4gICAgICB8IExpc3QgdHlwLCBTb21lIHZhbHVlIC0+IChcbiAgICAgICAgICBtYXRjaCB2YWx1ZSB3aXRoXG4gICAgICAgICAgfCBgTGlzdCB2YWx1ZXMgLT5cbiAgICAgICAgICAgICAgbGV0IG9wdGlvbl92YWx1ZXMgPSBMaXN0Lm1hcCAoZnVuIHggLT4gU29tZSB4KSB2YWx1ZXMgaW5cbiAgICAgICAgICAgICAgTGlzdC5SZXN1bHQuYWxsXG4gICAgICAgICAgICAgICAgKGV2YWxfYXJnIHZhcmlhYmxlX21hcCA/ZmllbGRfdHlwZSB+ZmllbGRfbmFtZSB+YXJnX25hbWUgdHlwKVxuICAgICAgICAgICAgICAgIG9wdGlvbl92YWx1ZXNcbiAgICAgICAgICAgICAgPj58IGZ1biBjb2VyY2VkIC0+IFNvbWUgY29lcmNlZFxuICAgICAgICAgIHwgdmFsdWUgLT5cbiAgICAgICAgICAgICAgZXZhbF9hcmcgdmFyaWFibGVfbWFwID9maWVsZF90eXBlIH5maWVsZF9uYW1lIH5hcmdfbmFtZSB0eXBcbiAgICAgICAgICAgICAgICAoU29tZSB2YWx1ZSlcbiAgICAgICAgICAgICAgPj58IGZ1biBjb2VyY2VkIC0+IChTb21lIFsgY29lcmNlZCBdIDogYSkgKVxuICAgICAgfCBOb25OdWxsYWJsZSB0eXAsIHZhbHVlIC0+IChcbiAgICAgICAgICBldmFsX2FyZyB2YXJpYWJsZV9tYXAgP2ZpZWxkX3R5cGUgfmZpZWxkX25hbWUgfmFyZ19uYW1lIHR5cCB2YWx1ZVxuICAgICAgICAgID4+PSBmdW5jdGlvblxuICAgICAgICAgIHwgU29tZSB2YWx1ZSAtPiBPayB2YWx1ZVxuICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBFcnJvciAoZXZhbF9hcmdfZXJyb3IgP2ZpZWxkX3R5cGUgfmZpZWxkX25hbWUgfmFyZ19uYW1lIHR5cCBOb25lKVxuICAgICAgICAgIClcbiAgICAgIHwgRW51bSBlLCBTb21lIHZhbHVlIC0+IChcbiAgICAgICAgICBtYXRjaCB2YWx1ZSB3aXRoXG4gICAgICAgICAgfCBgRW51bSB2IHwgYFN0cmluZyB2IC0+IChcbiAgICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICAgICBMaXN0LmZpbmQgKGZ1biBlbnVtX3ZhbHVlIC0+IGVudW1fdmFsdWUubmFtZSA9IHYpIGUudmFsdWVzXG4gICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIGVudW1fdmFsdWUgLT4gT2sgKFNvbWUgZW51bV92YWx1ZS52YWx1ZSlcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICBFcnJvclxuICAgICAgICAgICAgICAgICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgICAgICAgICAgICAgICAgXCJJbnZhbGlkIGVudW0gdmFsdWUgZm9yIGFyZ3VtZW50IGAlc2Agb24gZmllbGQgYCVzYFwiXG4gICAgICAgICAgICAgICAgICAgICAgIGFyZ19uYW1lIGZpZWxkX25hbWUpIClcbiAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgRXJyb3JcbiAgICAgICAgICAgICAgICAoUHJpbnRmLnNwcmludGYgXCJFeHBlY3RlZCBlbnVtIGZvciBhcmd1bWVudCBgJXNgIG9uIGZpZWxkIGAlc2BcIlxuICAgICAgICAgICAgICAgICAgIGFyZ19uYW1lIGZpZWxkX25hbWUpIClcblxuICAgIGxldCBhcmcgP2RvYyBuYW1lIH50eXAgPSBBcmcgeyBuYW1lOyBkb2M7IHR5cCB9XG5cbiAgICBsZXQgYXJnJyA/ZG9jIG5hbWUgfnR5cCB+ZGVmYXVsdCA9XG4gICAgICBEZWZhdWx0QXJnXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lO1xuICAgICAgICAgIGRvYztcbiAgICAgICAgICB0eXA7XG4gICAgICAgICAgZGVmYXVsdF92YWx1ZSA9IGRlZmF1bHQ7XG4gICAgICAgICAgZGVmYXVsdCA9XG4gICAgICAgICAgICAoIG1hdGNoXG4gICAgICAgICAgICAgICAgZXZhbF9hcmcgU3RyaW5nTWFwLmVtcHR5IH5maWVsZF9uYW1lOlwiXCIgfmFyZ19uYW1lOm5hbWUgdHlwXG4gICAgICAgICAgICAgICAgICAoU29tZSBkZWZhdWx0KVxuICAgICAgICAgICAgICB3aXRoXG4gICAgICAgICAgICB8IE9rIChTb21lIHYpIC0+IHZcbiAgICAgICAgICAgIHwgT2sgTm9uZSB8IEVycm9yIF8gLT5cbiAgICAgICAgICAgICAgICByYWlzZVxuICAgICAgICAgICAgICAgICAgKEZhaWx1cmVcbiAgICAgICAgICAgICAgICAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJJbnZhbGlkIGRlZmF1bHQgcHJvdmlkZWQgZm9yIGFyZyBuYW1lPSVzLCBkZWZhdWx0PSVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdHJpbmdfb2ZfY29uc3RfdmFsdWUgZGVmYXVsdCkpKSApO1xuICAgICAgICB9XG5cbiAgICBsZXQgc2NhbGFyID9kb2MgbmFtZSB+Y29lcmNlID0gU2NhbGFyIHsgbmFtZTsgZG9jOyBjb2VyY2UgfVxuXG4gICAgbGV0IGVudW0gP2RvYyBuYW1lIH52YWx1ZXMgPSBFbnVtIHsgbmFtZTsgZG9jOyB2YWx1ZXMgfVxuXG4gICAgbGV0IG9iaiA/ZG9jIG5hbWUgfmZpZWxkcyB+Y29lcmNlID1cbiAgICAgIG9iaiA/ZG9jIG5hbWUgfmZpZWxkczoobGF6eSBmaWVsZHMpIH5jb2VyY2VcbiAgZW5kXG5cbiAgKCogU2NoZW1hIGRhdGEgdHlwZXMgKilcbiAgdHlwZSAnYSBzY2FsYXIgPSB7IG5hbWUgOiBzdHJpbmc7IGRvYyA6IHN0cmluZyBvcHRpb247IGNvZXJjZSA6ICdhIC0+IGpzb24gfVxuXG4gIHR5cGUgJ2EgZW51bSA9IHtcbiAgICBuYW1lIDogc3RyaW5nO1xuICAgIGRvYyA6IHN0cmluZyBvcHRpb247XG4gICAgdmFsdWVzIDogJ2EgZW51bV92YWx1ZSBsaXN0O1xuICB9XG5cbiAgdHlwZSBmcmFnbWVudF9tYXAgPSBHcmFwaHFsX3BhcnNlci5mcmFnbWVudCBTdHJpbmdNYXAudFxuXG4gIHR5cGUgJ2N0eCByZXNvbHZlX2luZm8gPSB7XG4gICAgY3R4IDogJ2N0eDtcbiAgICBmaWVsZCA6IEdyYXBocWxfcGFyc2VyLmZpZWxkO1xuICAgIGZyYWdtZW50cyA6IGZyYWdtZW50X21hcDtcbiAgICB2YXJpYWJsZXMgOiB2YXJpYWJsZV9tYXA7XG4gIH1cblxuICB0eXBlICgnY3R4LCAnc3JjKSBvYmogPSB7XG4gICAgbmFtZSA6IHN0cmluZztcbiAgICBkb2MgOiBzdHJpbmcgb3B0aW9uO1xuICAgIGZpZWxkcyA6ICgnY3R4LCAnc3JjKSBmaWVsZCBsaXN0IExhenkudDtcbiAgICBhYnN0cmFjdHMgOiBhYnN0cmFjdCBsaXN0IHJlZjtcbiAgfVxuXG4gIGFuZCAoXywgXykgZmllbGQgPVxuICAgIHwgRmllbGQgOiB7XG4gICAgICAgIG5hbWUgOiBzdHJpbmc7XG4gICAgICAgIGRvYyA6IHN0cmluZyBvcHRpb247XG4gICAgICAgIGRlcHJlY2F0ZWQgOiBkZXByZWNhdGVkO1xuICAgICAgICB0eXAgOiAoJ2N0eCwgJ291dCkgdHlwO1xuICAgICAgICBhcmdzIDogKCdhLCAnYXJncykgQXJnLmFyZ19saXN0O1xuICAgICAgICByZXNvbHZlIDogJ2N0eCByZXNvbHZlX2luZm8gLT4gJ3NyYyAtPiAnYXJncztcbiAgICAgICAgbGlmdCA6ICdhIC0+ICgnb3V0LCBmaWVsZF9lcnJvcikgcmVzdWx0IElvLnQ7XG4gICAgICB9XG4gICAgICAgIC0+ICgnY3R4LCAnc3JjKSBmaWVsZFxuXG4gIGFuZCAoXywgXykgdHlwID1cbiAgICB8IE9iamVjdCA6ICgnY3R4LCAnc3JjKSBvYmogLT4gKCdjdHgsICdzcmMgb3B0aW9uKSB0eXBcbiAgICB8IExpc3QgOiAoJ2N0eCwgJ3NyYykgdHlwIC0+ICgnY3R4LCAnc3JjIGxpc3Qgb3B0aW9uKSB0eXBcbiAgICB8IE5vbk51bGxhYmxlIDogKCdjdHgsICdzcmMgb3B0aW9uKSB0eXAgLT4gKCdjdHgsICdzcmMpIHR5cFxuICAgIHwgU2NhbGFyIDogJ3NyYyBzY2FsYXIgLT4gKCdjdHgsICdzcmMgb3B0aW9uKSB0eXBcbiAgICB8IEVudW0gOiAnc3JjIGVudW0gLT4gKCdjdHgsICdzcmMgb3B0aW9uKSB0eXBcbiAgICB8IEFic3RyYWN0IDogYWJzdHJhY3QgLT4gKCdjdHgsICgnY3R4LCAnYSkgYWJzdHJhY3RfdmFsdWUgb3B0aW9uKSB0eXBcblxuICBhbmQgYW55X3R5cCA9XG4gICAgfCBBbnlUeXAgOiAoXywgXykgdHlwIC0+IGFueV90eXBcbiAgICB8IEFueUFyZ1R5cCA6IF8gQXJnLmFyZ190eXAgLT4gYW55X3R5cFxuXG4gIGFuZCBhYnN0cmFjdCA9IHtcbiAgICBuYW1lIDogc3RyaW5nO1xuICAgIGRvYyA6IHN0cmluZyBvcHRpb247XG4gICAga2luZCA6IFsgYFVuaW9uIHwgYEludGVyZmFjZSBvZiBhYnN0cmFjdF9maWVsZCBsaXN0IExhenkudCBdO1xuICAgIG11dGFibGUgdHlwZXMgOiBhbnlfdHlwIGxpc3Q7XG4gIH1cblxuICBhbmQgYWJzdHJhY3RfZmllbGQgPSBBYnN0cmFjdEZpZWxkIDogKF8sIF8pIGZpZWxkIC0+IGFic3RyYWN0X2ZpZWxkXG5cbiAgYW5kICgnY3R4LCAnYSkgYWJzdHJhY3RfdmFsdWUgPVxuICAgIHwgQWJzdHJhY3RWYWx1ZSA6XG4gICAgICAgICgnY3R4LCAnc3JjIG9wdGlvbikgdHlwICogJ3NyY1xuICAgICAgICAtPiAoJ2N0eCwgJ2EpIGFic3RyYWN0X3ZhbHVlXG5cbiAgdHlwZSAnY3R4IHN1YnNjcmlwdGlvbl9maWVsZCA9XG4gICAgfCBTdWJzY3JpcHRpb25GaWVsZCA6IHtcbiAgICAgICAgbmFtZSA6IHN0cmluZztcbiAgICAgICAgZG9jIDogc3RyaW5nIG9wdGlvbjtcbiAgICAgICAgZGVwcmVjYXRlZCA6IGRlcHJlY2F0ZWQ7XG4gICAgICAgIHR5cCA6ICgnY3R4LCAnb3V0KSB0eXA7XG4gICAgICAgIGFyZ3MgOlxuICAgICAgICAgICgoJ291dCBJby5TdHJlYW0udCwgZmllbGRfZXJyb3IpIHJlc3VsdCBJby50LCAnYXJncykgQXJnLmFyZ19saXN0O1xuICAgICAgICByZXNvbHZlIDogJ2N0eCByZXNvbHZlX2luZm8gLT4gJ2FyZ3M7XG4gICAgICB9XG4gICAgICAgIC0+ICdjdHggc3Vic2NyaXB0aW9uX2ZpZWxkXG5cbiAgdHlwZSAnY3R4IHN1YnNjcmlwdGlvbl9vYmogPSB7XG4gICAgbmFtZSA6IHN0cmluZztcbiAgICBkb2MgOiBzdHJpbmcgb3B0aW9uO1xuICAgIGZpZWxkcyA6ICdjdHggc3Vic2NyaXB0aW9uX2ZpZWxkIGxpc3Q7XG4gIH1cblxuICB0eXBlICgnY3R4LCAnYSkgYWJzdHJhY3RfdHlwID0gKCdjdHgsICgnY3R4LCAnYSkgYWJzdHJhY3RfdmFsdWUgb3B0aW9uKSB0eXBcblxuICB0eXBlIGRpcmVjdGl2ZV9sb2NhdGlvbiA9XG4gICAgWyBgUXVlcnlcbiAgICB8IGBNdXRhdGlvblxuICAgIHwgYFN1YnNjcmlwdGlvblxuICAgIHwgYEZpZWxkXG4gICAgfCBgRnJhZ21lbnRfZGVmaW5pdGlvblxuICAgIHwgYEZyYWdtZW50X3NwcmVhZFxuICAgIHwgYElubGluZV9mcmFnbWVudFxuICAgIHwgYFZhcmlhYmxlX2RlZmluaXRpb24gXVxuXG4gIHR5cGUgZGlyZWN0aXZlID1cbiAgICB8IERpcmVjdGl2ZSA6IHtcbiAgICAgICAgbmFtZSA6IHN0cmluZztcbiAgICAgICAgZG9jIDogc3RyaW5nIG9wdGlvbjtcbiAgICAgICAgbG9jYXRpb25zIDogZGlyZWN0aXZlX2xvY2F0aW9uIGxpc3Q7XG4gICAgICAgIGFyZ3MgOiAoWyBgU2tpcCB8IGBJbmNsdWRlIF0sICdhcmdzKSBBcmcuYXJnX2xpc3Q7XG4gICAgICAgIHJlc29sdmUgOiAnYXJncztcbiAgICAgIH1cbiAgICAgICAgLT4gZGlyZWN0aXZlXG5cbiAgdHlwZSAnYSBmaXhwb2ludCA9IHtcbiAgICBvYmo6ICdjdHggJ3NyYyAndHlwICdiLiA/ZG9jOnN0cmluZyAtPiBzdHJpbmcgLT5cbiAgICAgIGZpZWxkczooJ2EgLT4gKCdjdHgsICdzcmMpIGZpZWxkIGxpc3QpIC0+XG4gICAgICAoJ2N0eCwgJ3NyYyBvcHRpb24pIHR5cDtcblxuICAgIGludGVyZmFjZSA6ICdjdHggJ3NyYy4gP2RvYzpzdHJpbmcgLT4gc3RyaW5nIC0+XG4gICAgICBmaWVsZHM6KCdhIC0+IGFic3RyYWN0X2ZpZWxkIGxpc3QpIC0+XG4gICAgICAoJ2N0eCwgJ3NyYykgYWJzdHJhY3RfdHlwXG4gIH1cblxuICBsZXQgb2JqID9kb2MgbmFtZSB+ZmllbGRzID1cbiAgICBPYmplY3QgeyBuYW1lOyBkb2M7IGZpZWxkczsgYWJzdHJhY3RzID0gcmVmIFtdIH1cblxuICBsZXQgdW5pb24gP2RvYyBuYW1lID0gQWJzdHJhY3QgeyBuYW1lOyBkb2M7IHR5cGVzID0gW107IGtpbmQgPSBgVW5pb24gfVxuXG4gIGxldCBpbnRlcmZhY2UgP2RvYyBuYW1lIH5maWVsZHMgPVxuICAgIGxldCByZWMgaSA9XG4gICAgICBBYnN0cmFjdCB7IG5hbWU7IGRvYzsgdHlwZXMgPSBbXTsga2luZCA9IGBJbnRlcmZhY2UgKGxhenkgKGZpZWxkcyBpKSkgfVxuICAgIGluXG4gICAgaVxuXG4gIGxldCBmaXggZiA9XG4gICAgbGV0IHJlYyByZWN1cnNpdmUgPSB7XG4gICAgICBvYmogPSAoZnVuID9kb2MgbmFtZSB+ZmllbGRzIC0+XG4gICAgICAgIG9iaiA/ZG9jIG5hbWUgfmZpZWxkczooIGxhenkgKGZpZWxkcyAoTGF6eS5mb3JjZSByKSkpKTtcblxuICAgICAgaW50ZXJmYWNlID0gZnVuID9kb2MgbmFtZSB+ZmllbGRzIC0+XG4gICAgICAgIEFic3RyYWN0IHsgbmFtZTsgZG9jOyB0eXBlcyA9IFtdOyBraW5kID0gYEludGVyZmFjZSAobGF6eSAoZmllbGRzIChMYXp5LmZvcmNlIHIpKSkgfVxuICAgIH1cbiAgICBhbmQgciA9IGxhenkgKGYgcmVjdXJzaXZlKVxuICAgIGluIExhenkuZm9yY2UgclxuXG4gIHR5cGUgJ2N0eCBzY2hlbWEgPSB7XG4gICAgcXVlcnkgOiAoJ2N0eCwgdW5pdCkgb2JqO1xuICAgIG11dGF0aW9uIDogKCdjdHgsIHVuaXQpIG9iaiBvcHRpb247XG4gICAgc3Vic2NyaXB0aW9uIDogJ2N0eCBzdWJzY3JpcHRpb25fb2JqIG9wdGlvbjtcbiAgfVxuXG4gIGxldCBzY2hlbWEgPyhtdXRhdGlvbl9uYW1lID0gXCJtdXRhdGlvblwiKSA/bXV0YXRpb25zXG4gICAgICA/KHN1YnNjcmlwdGlvbl9uYW1lID0gXCJzdWJzY3JpcHRpb25cIikgP3N1YnNjcmlwdGlvbnNcbiAgICAgID8ocXVlcnlfbmFtZSA9IFwicXVlcnlcIikgZmllbGRzID1cbiAgICB7XG4gICAgICBxdWVyeSA9XG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lID0gcXVlcnlfbmFtZTtcbiAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgIGFic3RyYWN0cyA9IHJlZiBbXTtcbiAgICAgICAgICBmaWVsZHMgPSBsYXp5IGZpZWxkcztcbiAgICAgICAgfTtcbiAgICAgIG11dGF0aW9uID1cbiAgICAgICAgT3B0aW9uLm1hcCBtdXRhdGlvbnMgfmY6KGZ1biBmaWVsZHMgLT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZSA9IG11dGF0aW9uX25hbWU7XG4gICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgIGFic3RyYWN0cyA9IHJlZiBbXTtcbiAgICAgICAgICAgICAgZmllbGRzID0gbGF6eSBmaWVsZHM7XG4gICAgICAgICAgICB9KTtcbiAgICAgIHN1YnNjcmlwdGlvbiA9XG4gICAgICAgIE9wdGlvbi5tYXAgc3Vic2NyaXB0aW9ucyB+ZjooZnVuIGZpZWxkcyAtPlxuICAgICAgICAgICAgeyBuYW1lID0gc3Vic2NyaXB0aW9uX25hbWU7IGRvYyA9IE5vbmU7IGZpZWxkcyB9KTtcbiAgICB9XG5cbiAgKCogQ29uc3RydWN0b3IgZnVuY3Rpb25zICopXG4gIGxldCBvYmogP2RvYyBuYW1lIH5maWVsZHMgPSBvYmogP2RvYyBuYW1lIH5maWVsZHM6KGxhenkgZmllbGRzKVxuXG4gIGxldCBmaWVsZCA/ZG9jID8oZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQpIG5hbWUgfnR5cCB+YXJncyB+cmVzb2x2ZSA9XG4gICAgRmllbGQgeyBuYW1lOyBkb2M7IGRlcHJlY2F0ZWQ7IHR5cDsgYXJnczsgcmVzb2x2ZTsgbGlmdCA9IElvLm9rIH1cblxuICBsZXQgaW9fZmllbGQgP2RvYyA/KGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkKSBuYW1lIH50eXAgfmFyZ3MgfnJlc29sdmUgPVxuICAgIEZpZWxkIHsgbmFtZTsgZG9jOyBkZXByZWNhdGVkOyB0eXA7IGFyZ3M7IHJlc29sdmU7IGxpZnQgPSBpZCB9XG5cbiAgbGV0IGFic3RyYWN0X2ZpZWxkID9kb2MgPyhkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZCkgbmFtZSB+dHlwIH5hcmdzID1cbiAgICBBYnN0cmFjdEZpZWxkXG4gICAgICAoRmllbGRcbiAgICAgICAgIHtcbiAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICBuYW1lO1xuICAgICAgICAgICBkb2M7XG4gICAgICAgICAgIGRlcHJlY2F0ZWQ7XG4gICAgICAgICAgIHR5cDtcbiAgICAgICAgICAgYXJncztcbiAgICAgICAgICAgcmVzb2x2ZSA9IE9iai5tYWdpYyAoKTtcbiAgICAgICAgIH0pXG5cbiAgbGV0IHN1YnNjcmlwdGlvbl9maWVsZCA/ZG9jID8oZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQpIG5hbWUgfnR5cCB+YXJnc1xuICAgICAgfnJlc29sdmUgPVxuICAgIFN1YnNjcmlwdGlvbkZpZWxkIHsgbmFtZTsgZG9jOyBkZXByZWNhdGVkOyB0eXA7IGFyZ3M7IHJlc29sdmUgfVxuXG4gIGxldCBlbnVtID9kb2MgbmFtZSB+dmFsdWVzID0gRW51bSB7IG5hbWU7IGRvYzsgdmFsdWVzIH1cblxuICBsZXQgc2NhbGFyID9kb2MgbmFtZSB+Y29lcmNlID0gU2NhbGFyIHsgbmFtZTsgZG9jOyBjb2VyY2UgfVxuXG4gIGxldCBsaXN0IHR5cCA9IExpc3QgdHlwXG5cbiAgbGV0IG5vbl9udWxsIHR5cCA9IE5vbk51bGxhYmxlIHR5cFxuXG4gIGxldCBhZGRfdHlwZSBhYnN0cmFjdF90eXAgdHlwID1cbiAgICBtYXRjaCAoYWJzdHJhY3RfdHlwLCB0eXApIHdpdGhcbiAgICB8IEFic3RyYWN0IGEsIE9iamVjdCBvIC0+XG4gICAgICAgICgqIFRPRE8gYWRkIHN1YnR5cGUgY2hlY2sgaGVyZSAqKVxuICAgICAgICBhLnR5cGVzIDwtIEFueVR5cCB0eXAgOjogYS50eXBlcztcbiAgICAgICAgby5hYnN0cmFjdHMgOj0gYSA6OiAhKG8uYWJzdHJhY3RzKTtcbiAgICAgICAgZnVuIHNyYyAtPiBBYnN0cmFjdFZhbHVlICh0eXAsIHNyYylcbiAgICB8IF8gLT4gaW52YWxpZF9hcmcgXCJBcmd1bWVudHMgbXVzdCBiZSBJbnRlcmZhY2UvVW5pb24gYW5kIE9iamVjdFwiXG5cbiAgbGV0IG9ial9vZl9zdWJzY3JpcHRpb25fb2JqIHsgbmFtZTsgZG9jOyBmaWVsZHMgfSA9XG4gICAgbGV0IGZpZWxkcyA9XG4gICAgICBMaXN0Lm1hcFxuICAgICAgICAoZnVuIChTdWJzY3JpcHRpb25GaWVsZCB7IG5hbWU7IGRvYzsgZGVwcmVjYXRlZDsgdHlwOyBhcmdzOyByZXNvbHZlIH0pIC0+XG4gICAgICAgICAgRmllbGRcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGlmdCA9IE9iai5tYWdpYyAoKTtcbiAgICAgICAgICAgICAgbmFtZTtcbiAgICAgICAgICAgICAgZG9jO1xuICAgICAgICAgICAgICBkZXByZWNhdGVkO1xuICAgICAgICAgICAgICB0eXA7XG4gICAgICAgICAgICAgIGFyZ3M7XG4gICAgICAgICAgICAgIHJlc29sdmUgPSAoZnVuIGN0eCAoKSAtPiByZXNvbHZlIGN0eCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICBmaWVsZHNcbiAgICBpblxuICAgIHsgbmFtZTsgZG9jOyBhYnN0cmFjdHMgPSByZWYgW107IGZpZWxkcyA9IGxhenkgZmllbGRzIH1cblxuICAoKiBCdWlsdC1pbiBzY2FsYXJzICopXG4gIGxldCBpbnQgOiAnY3R4LiAoJ2N0eCwgaW50IG9wdGlvbikgdHlwID1cbiAgICBTY2FsYXIgeyBuYW1lID0gXCJJbnRcIjsgZG9jID0gTm9uZTsgY29lcmNlID0gKGZ1biBpIC0+IGBJbnQgaSkgfVxuXG4gIGxldCBzdHJpbmcgOiAnY3R4LiAoJ2N0eCwgc3RyaW5nIG9wdGlvbikgdHlwID1cbiAgICBTY2FsYXIgeyBuYW1lID0gXCJTdHJpbmdcIjsgZG9jID0gTm9uZTsgY29lcmNlID0gKGZ1biBzIC0+IGBTdHJpbmcgcykgfVxuXG4gIGxldCBib29sIDogJ2N0eC4gKCdjdHgsIGJvb2wgb3B0aW9uKSB0eXAgPVxuICAgIFNjYWxhciB7IG5hbWUgPSBcIkJvb2xlYW5cIjsgZG9jID0gTm9uZTsgY29lcmNlID0gKGZ1biBiIC0+IGBCb29sIGIpIH1cblxuICBsZXQgZmxvYXQgOiAnY3R4LiAoJ2N0eCwgZmxvYXQgb3B0aW9uKSB0eXAgPVxuICAgIFNjYWxhciB7IG5hbWUgPSBcIkZsb2F0XCI7IGRvYyA9IE5vbmU7IGNvZXJjZSA9IChmdW4gZiAtPiBgRmxvYXQgZikgfVxuXG4gIGxldCBndWlkIDogJ2N0eC4gKCdjdHgsIHN0cmluZyBvcHRpb24pIHR5cCA9XG4gICAgU2NhbGFyIHsgbmFtZSA9IFwiSURcIjsgZG9jID0gTm9uZTsgY29lcmNlID0gKGZ1biB4IC0+IGBTdHJpbmcgeCkgfVxuXG4gICgqIE1hbmRhdG9yeSBkaXJlY3RpdmVzOiBza2lwIGFuZCBpbmNsdWRlICopXG4gIGxldCBza2lwX2RpcmVjdGl2ZSA9XG4gICAgRGlyZWN0aXZlXG4gICAgICB7XG4gICAgICAgIG5hbWUgPSBcInNraXBcIjtcbiAgICAgICAgZG9jID1cbiAgICAgICAgICBTb21lXG4gICAgICAgICAgICBcIkRpcmVjdHMgdGhlIGV4ZWN1dG9yIHRvIHNraXAgdGhpcyBmaWVsZCBvciBmcmFnbWVudCB3aGVuIHRoZSBcXFxuICAgICAgICAgICAgIGBpZmAgYXJndW1lbnQgaXMgdHJ1ZS5cIjtcbiAgICAgICAgbG9jYXRpb25zID0gWyBgRmllbGQ7IGBGcmFnbWVudF9zcHJlYWQ7IGBJbmxpbmVfZnJhZ21lbnQgXTtcbiAgICAgICAgYXJncyA9IEFyZy5bIGFyZyBcImlmXCIgfmRvYzpcIlNraXBwZWQgd2hlbiB0cnVlLlwiIH50eXA6KG5vbl9udWxsIGJvb2wpIF07XG4gICAgICAgIHJlc29sdmUgPSAoZnVuY3Rpb24gdHJ1ZSAtPiBgU2tpcCB8IGZhbHNlIC0+IGBJbmNsdWRlKTtcbiAgICAgIH1cblxuICBsZXQgaW5jbHVkZV9kaXJlY3RpdmUgPVxuICAgIERpcmVjdGl2ZVxuICAgICAge1xuICAgICAgICBuYW1lID0gXCJpbmNsdWRlXCI7XG4gICAgICAgIGRvYyA9XG4gICAgICAgICAgU29tZVxuICAgICAgICAgICAgXCJEaXJlY3RzIHRoZSBleGVjdXRvciB0byBpbmNsdWRlIHRoaXMgZmllbGQgb3IgZnJhZ21lbnQgb25seSB3aGVuIFxcXG4gICAgICAgICAgICAgdGhlIGBpZmAgYXJndW1lbnQgaXMgdHJ1ZS5cIjtcbiAgICAgICAgbG9jYXRpb25zID0gWyBgRmllbGQ7IGBGcmFnbWVudF9zcHJlYWQ7IGBJbmxpbmVfZnJhZ21lbnQgXTtcbiAgICAgICAgYXJncyA9IEFyZy5bIGFyZyBcImlmXCIgfmRvYzpcIkluY2x1ZGVkIHdoZW4gdHJ1ZS5cIiB+dHlwOihub25fbnVsbCBib29sKSBdO1xuICAgICAgICByZXNvbHZlID0gKGZ1bmN0aW9uIHRydWUgLT4gYEluY2x1ZGUgfCBmYWxzZSAtPiBgU2tpcCk7XG4gICAgICB9XG5cbiAgbW9kdWxlIEludHJvc3BlY3Rpb24gPSBzdHJ1Y3RcbiAgICAoKiBhbnlfdHlwLCBhbnlfZmllbGQgYW5kIGFueV9hcmcgaGlkZSB0eXBlIHBhcmFtZXRlcnMgdG8gYXZvaWQgc2NvcGUgZXNjYXBpbmcgZXJyb3JzICopXG4gICAgdHlwZSBhbnlfZmllbGQgPVxuICAgICAgfCBBbnlGaWVsZCA6IChfLCBfKSBmaWVsZCAtPiBhbnlfZmllbGRcbiAgICAgIHwgQW55QXJnRmllbGQgOiBfIEFyZy5hcmcgLT4gYW55X2ZpZWxkXG5cbiAgICB0eXBlIGFueV9hcmcgPSBBbnlBcmcgOiBfIEFyZy5hcmcgLT4gYW55X2FyZ1xuXG4gICAgdHlwZSBhbnlfZW51bV92YWx1ZSA9IEFueUVudW1WYWx1ZSA6IF8gZW51bV92YWx1ZSAtPiBhbnlfZW51bV92YWx1ZVxuXG4gICAgbGV0IHVubGVzc192aXNpdGVkIChyZXN1bHQsIHZpc2l0ZWQpIG5hbWUgZiA9XG4gICAgICBpZiBTdHJpbmdTZXQubWVtIG5hbWUgdmlzaXRlZCB0aGVuIChyZXN1bHQsIHZpc2l0ZWQpXG4gICAgICBlbHNlIGYgKHJlc3VsdCwgdmlzaXRlZClcblxuICAgICgqIEV4dHJhY3RzIGFsbCB0eXBlcyBjb250YWluZWQgaW4gYSBzaW5nbGUgdHlwZSAqKVxuICAgIGxldCByZWMgdHlwZXMgOlxuICAgICAgICB0eXBlIGN0eCBzcmMuXG4gICAgICAgID9tZW1vOmFueV90eXAgbGlzdCAqIFN0cmluZ1NldC50IC0+XG4gICAgICAgIChjdHgsIHNyYykgdHlwIC0+XG4gICAgICAgIGFueV90eXAgbGlzdCAqIFN0cmluZ1NldC50ID1cbiAgICAgZnVuID8obWVtbyA9IChbXSwgU3RyaW5nU2V0LmVtcHR5KSkgdHlwIC0+XG4gICAgICBtYXRjaCB0eXAgd2l0aFxuICAgICAgfCBMaXN0IHR5cCAtPiB0eXBlcyB+bWVtbyB0eXBcbiAgICAgIHwgTm9uTnVsbGFibGUgdHlwIC0+IHR5cGVzIH5tZW1vIHR5cFxuICAgICAgfCBTY2FsYXIgcyBhcyBzY2FsYXIgLT5cbiAgICAgICAgICB1bmxlc3NfdmlzaXRlZCBtZW1vIHMubmFtZSAoZnVuIChyZXN1bHQsIHZpc2l0ZWQpIC0+XG4gICAgICAgICAgICAgIChBbnlUeXAgc2NhbGFyIDo6IHJlc3VsdCwgU3RyaW5nU2V0LmFkZCBzLm5hbWUgdmlzaXRlZCkpXG4gICAgICB8IEVudW0gZSBhcyBlbnVtIC0+XG4gICAgICAgICAgdW5sZXNzX3Zpc2l0ZWQgbWVtbyBlLm5hbWUgKGZ1biAocmVzdWx0LCB2aXNpdGVkKSAtPlxuICAgICAgICAgICAgICAoQW55VHlwIGVudW0gOjogcmVzdWx0LCBTdHJpbmdTZXQuYWRkIGUubmFtZSB2aXNpdGVkKSlcbiAgICAgIHwgT2JqZWN0IG8gYXMgb2JqIC0+XG4gICAgICAgICAgdW5sZXNzX3Zpc2l0ZWQgbWVtbyBvLm5hbWUgKGZ1biAocmVzdWx0LCB2aXNpdGVkKSAtPlxuICAgICAgICAgICAgICBsZXQgcmVzdWx0JyA9IEFueVR5cCBvYmogOjogcmVzdWx0IGluXG4gICAgICAgICAgICAgIGxldCB2aXNpdGVkJyA9IFN0cmluZ1NldC5hZGQgby5uYW1lIHZpc2l0ZWQgaW5cbiAgICAgICAgICAgICAgbGV0IHJlZHVjZXIgbWVtbyAoRmllbGQgZikgPVxuICAgICAgICAgICAgICAgIGxldCBtZW1vJyA9IHR5cGVzIH5tZW1vIGYudHlwIGluXG4gICAgICAgICAgICAgICAgYXJnX2xpc3RfdHlwZXMgbWVtbycgZi5hcmdzXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIExpc3QuZm9sZF9sZWZ0IHJlZHVjZXIgKHJlc3VsdCcsIHZpc2l0ZWQnKSAoTGF6eS5mb3JjZSBvLmZpZWxkcykpXG4gICAgICB8IEFic3RyYWN0IGEgYXMgYWJzdHJhY3QgLT5cbiAgICAgICAgICB1bmxlc3NfdmlzaXRlZCBtZW1vIGEubmFtZSAoZnVuIChyZXN1bHQsIHZpc2l0ZWQpIC0+XG4gICAgICAgICAgICAgIGxldCByZXN1bHQnID0gQW55VHlwIGFic3RyYWN0IDo6IHJlc3VsdCBpblxuICAgICAgICAgICAgICBsZXQgdmlzaXRlZCcgPSBTdHJpbmdTZXQuYWRkIGEubmFtZSB2aXNpdGVkIGluXG4gICAgICAgICAgICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgICAgICAgICAgKGZ1biBtZW1vIHR5cCAtPlxuICAgICAgICAgICAgICAgICAgbWF0Y2ggdHlwIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgQW55VHlwIHR5cCAtPiB0eXBlcyB+bWVtbyB0eXBcbiAgICAgICAgICAgICAgICAgIHwgQW55QXJnVHlwIF8gLT5cbiAgICAgICAgICAgICAgICAgICAgICBmYWlsd2l0aCBcIkFic3RyYWN0cyBjYW4ndCBoYXZlIGFyZ3VtZW50IHR5cGVzXCIpXG4gICAgICAgICAgICAgICAgKHJlc3VsdCcsIHZpc2l0ZWQnKSBhLnR5cGVzKVxuXG4gICAgYW5kIGFyZ190eXBlcyA6XG4gICAgICAgIHR5cGUgYS5cbiAgICAgICAgYW55X3R5cCBsaXN0ICogU3RyaW5nU2V0LnQgLT5cbiAgICAgICAgYSBBcmcuYXJnX3R5cCAtPlxuICAgICAgICBhbnlfdHlwIGxpc3QgKiBTdHJpbmdTZXQudCA9XG4gICAgIGZ1biBtZW1vIGFyZ3R5cCAtPlxuICAgICAgbWF0Y2ggYXJndHlwIHdpdGhcbiAgICAgIHwgQXJnLkxpc3QgdHlwIC0+IGFyZ190eXBlcyBtZW1vIHR5cFxuICAgICAgfCBBcmcuTm9uTnVsbGFibGUgdHlwIC0+IGFyZ190eXBlcyBtZW1vIHR5cFxuICAgICAgfCBBcmcuU2NhbGFyIHMgYXMgc2NhbGFyIC0+XG4gICAgICAgICAgdW5sZXNzX3Zpc2l0ZWQgbWVtbyBzLm5hbWUgKGZ1biAocmVzdWx0LCB2aXNpdGVkKSAtPlxuICAgICAgICAgICAgICAoQW55QXJnVHlwIHNjYWxhciA6OiByZXN1bHQsIFN0cmluZ1NldC5hZGQgcy5uYW1lIHZpc2l0ZWQpKVxuICAgICAgfCBBcmcuRW51bSBlIGFzIGVudW0gLT5cbiAgICAgICAgICB1bmxlc3NfdmlzaXRlZCBtZW1vIGUubmFtZSAoZnVuIChyZXN1bHQsIHZpc2l0ZWQpIC0+XG4gICAgICAgICAgICAgIChBbnlBcmdUeXAgZW51bSA6OiByZXN1bHQsIFN0cmluZ1NldC5hZGQgZS5uYW1lIHZpc2l0ZWQpKVxuICAgICAgfCBBcmcuT2JqZWN0IG8gYXMgb2JqIC0+XG4gICAgICAgICAgdW5sZXNzX3Zpc2l0ZWQgbWVtbyBvLm5hbWUgKGZ1biAocmVzdWx0LCB2aXNpdGVkKSAtPlxuICAgICAgICAgICAgICBsZXQgbWVtbycgPVxuICAgICAgICAgICAgICAgIChBbnlBcmdUeXAgb2JqIDo6IHJlc3VsdCwgU3RyaW5nU2V0LmFkZCBvLm5hbWUgdmlzaXRlZClcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgYXJnX2xpc3RfdHlwZXMgbWVtbycgKExhenkuZm9yY2Ugby5maWVsZHMpKVxuXG4gICAgYW5kIGFyZ19saXN0X3R5cGVzIDpcbiAgICAgICAgdHlwZSBhIGIuXG4gICAgICAgIGFueV90eXAgbGlzdCAqIFN0cmluZ1NldC50IC0+XG4gICAgICAgIChhLCBiKSBBcmcuYXJnX2xpc3QgLT5cbiAgICAgICAgYW55X3R5cCBsaXN0ICogU3RyaW5nU2V0LnQgPVxuICAgICBmdW4gbWVtbyBhcmdsaXN0IC0+XG4gICAgICBsZXQgb3BlbiBBcmcgaW5cbiAgICAgIG1hdGNoIGFyZ2xpc3Qgd2l0aFxuICAgICAgfCBbXSAtPiBtZW1vXG4gICAgICB8IGFyZyA6OiBhcmdzIC0+XG4gICAgICAgICAgbGV0IG1lbW8nID1cbiAgICAgICAgICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgICAgICAgICB8IEFyZyBhIC0+IGFyZ190eXBlcyBtZW1vIGEudHlwXG4gICAgICAgICAgICB8IERlZmF1bHRBcmcgYSAtPiBhcmdfdHlwZXMgbWVtbyBhLnR5cFxuICAgICAgICAgIGluXG4gICAgICAgICAgYXJnX2xpc3RfdHlwZXMgbWVtbycgYXJnc1xuXG4gICAgbGV0IHR5cGVzX29mX3NjaGVtYSBzID1cbiAgICAgIGxldCB0eXBlcywgXyA9XG4gICAgICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgICAgKGZ1biBtZW1vIG9wIC0+XG4gICAgICAgICAgICBtYXRjaCBvcCB3aXRoIE5vbmUgLT4gbWVtbyB8IFNvbWUgb3AgLT4gdHlwZXMgfm1lbW8gKE9iamVjdCBvcCkpXG4gICAgICAgICAgKFtdLCBTdHJpbmdTZXQuZW1wdHkpXG4gICAgICAgICAgW1xuICAgICAgICAgICAgU29tZSBzLnF1ZXJ5O1xuICAgICAgICAgICAgcy5tdXRhdGlvbjtcbiAgICAgICAgICAgIE9wdGlvbi5tYXAgcy5zdWJzY3JpcHRpb24gfmY6b2JqX29mX3N1YnNjcmlwdGlvbl9vYmo7XG4gICAgICAgICAgXVxuICAgICAgaW5cbiAgICAgIHR5cGVzXG5cbiAgICBsZXQgcmVjIGFyZ3NfdG9fbGlzdCA6XG4gICAgICAgIHR5cGUgYSBiLiA/bWVtbzphbnlfYXJnIGxpc3QgLT4gKGEsIGIpIEFyZy5hcmdfbGlzdCAtPiBhbnlfYXJnIGxpc3QgPVxuICAgICBmdW4gPyhtZW1vID0gW10pIGFyZ2xpc3QgLT5cbiAgICAgIGxldCBvcGVuIEFyZyBpblxuICAgICAgbWF0Y2ggYXJnbGlzdCB3aXRoXG4gICAgICB8IFtdIC0+IG1lbW9cbiAgICAgIHwgYXJnIDo6IGFyZ3MgLT5cbiAgICAgICAgICBsZXQgbWVtbycgPSBMaXN0LmNvbnMgKEFueUFyZyBhcmcpIG1lbW8gaW5cbiAgICAgICAgICBhcmdzX3RvX2xpc3Qgfm1lbW86bWVtbycgYXJnc1xuXG4gICAgbGV0IG5vX2Fic3RyYWN0cyA9IHJlZiBbXVxuXG4gICAgbGV0IF9fdHlwZV9raW5kID1cbiAgICAgIEVudW1cbiAgICAgICAge1xuICAgICAgICAgIG5hbWUgPSBcIl9fVHlwZUtpbmRcIjtcbiAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgIHZhbHVlcyA9XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJTQ0FMQVJcIjtcbiAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYFNjYWxhcjtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcIk9CSkVDVFwiO1xuICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgT2JqZWN0O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiSU5URVJGQUNFXCI7XG4gICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGBJbnRlcmZhY2U7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJVTklPTlwiO1xuICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgVW5pb247XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJFTlVNXCI7XG4gICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGBFbnVtO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiSU5QVVRfT0JKRUNUXCI7XG4gICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGBJbnB1dE9iamVjdDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcIkxJU1RcIjtcbiAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYExpc3Q7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJOT05fTlVMTFwiO1xuICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgTm9uTnVsbDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgIGxldCBfX2VudW1fdmFsdWUgOiAnY3R4LiAoJ2N0eCwgYW55X2VudW1fdmFsdWUgb3B0aW9uKSB0eXAgPVxuICAgICAgT2JqZWN0XG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lID0gXCJfX0VudW1WYWx1ZVwiO1xuICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgYWJzdHJhY3RzID0gbm9fYWJzdHJhY3RzO1xuICAgICAgICAgIGZpZWxkcyA9XG4gICAgICAgICAgICBsYXp5XG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJuYW1lXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBOb25OdWxsYWJsZSBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBBcmcuW107XG4gICAgICAgICAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgKGZ1biBfIChBbnlFbnVtVmFsdWUgZW51bV92YWx1ZSkgLT4gZW51bV92YWx1ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmllbGRcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiZGVzY3JpcHRpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cCA9IHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID1cbiAgICAgICAgICAgICAgICAgICAgICAoZnVuIF8gKEFueUVudW1WYWx1ZSBlbnVtX3ZhbHVlKSAtPiBlbnVtX3ZhbHVlLmRvYyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZpZWxkXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcImlzRGVwcmVjYXRlZFwiO1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgdHlwID0gTm9uTnVsbGFibGUgYm9vbDtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID1cbiAgICAgICAgICAgICAgICAgICAgICAoZnVuIF8gKEFueUVudW1WYWx1ZSBlbnVtX3ZhbHVlKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bV92YWx1ZS5kZXByZWNhdGVkIDw+IE5vdERlcHJlY2F0ZWQpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJkZXByZWNhdGlvblJlYXNvblwiO1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgdHlwID0gc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gQXJnLltdO1xuICAgICAgICAgICAgICAgICAgICBsaWZ0ID0gSW8ub2s7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPVxuICAgICAgICAgICAgICAgICAgICAgIChmdW4gXyAoQW55RW51bVZhbHVlIGVudW1fdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBlbnVtX3ZhbHVlLmRlcHJlY2F0ZWQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBEZXByZWNhdGVkIHJlYXNvbiAtPiByZWFzb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHwgTm90RGVwcmVjYXRlZCAtPiBOb25lKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgIGxldCByZWMgX19pbnB1dF92YWx1ZSA6ICdjdHguICgnY3R4LCBhbnlfYXJnIG9wdGlvbikgdHlwID1cbiAgICAgIE9iamVjdFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZSA9IFwiX19JbnB1dFZhbHVlXCI7XG4gICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICBhYnN0cmFjdHMgPSBub19hYnN0cmFjdHM7XG4gICAgICAgICAgZmllbGRzID1cbiAgICAgICAgICAgIGxhenlcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIEZpZWxkXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIm5hbWVcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cCA9IE5vbk51bGxhYmxlIHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID1cbiAgICAgICAgICAgICAgICAgICAgICAoZnVuIF8gKEFueUFyZyBhcmcpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBcmcuRGVmYXVsdEFyZyBhIC0+IGEubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBcmcuQXJnIGEgLT4gYS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmllbGRcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiZGVzY3JpcHRpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cCA9IHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID1cbiAgICAgICAgICAgICAgICAgICAgICAoZnVuIF8gKEFueUFyZyBhcmcpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBcmcuRGVmYXVsdEFyZyBhIC0+IGEuZG9jXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFyZy5BcmcgYSAtPiBhLmRvYyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZpZWxkXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcInR5cGVcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cCA9IE5vbk51bGxhYmxlIF9fdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID1cbiAgICAgICAgICAgICAgICAgICAgICAoZnVuIF8gKEFueUFyZyBhcmcpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBcmcuRGVmYXVsdEFyZyBhIC0+IEFueUFyZ1R5cCBhLnR5cFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBcmcuQXJnIGEgLT4gQW55QXJnVHlwIGEudHlwKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmllbGRcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiZGVmYXVsdFZhbHVlXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBBcmcuW107XG4gICAgICAgICAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IChmdW4gXyAoQW55QXJnIGFyZykgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFyZy5EZWZhdWx0QXJnIGEgLT4gU29tZSAoQXJnLnN0cmluZ19vZl9jb25zdF92YWx1ZSBhLmRlZmF1bHRfdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFyZy5BcmcgXyAtPiBOb25lKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgIGFuZCBfX3R5cGUgOiAnY3R4LiAoJ2N0eCwgYW55X3R5cCBvcHRpb24pIHR5cCA9XG4gICAgICBPYmplY3RcbiAgICAgICAge1xuICAgICAgICAgIG5hbWUgPSBcIl9fVHlwZVwiO1xuICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgYWJzdHJhY3RzID0gbm9fYWJzdHJhY3RzO1xuICAgICAgICAgIGZpZWxkcyA9XG4gICAgICAgICAgICBsYXp5XG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJraW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBOb25OdWxsYWJsZSBfX3R5cGVfa2luZDtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID1cbiAgICAgICAgICAgICAgICAgICAgICAoZnVuIF8gdCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueVR5cCAoT2JqZWN0IF8pIC0+IGBPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55VHlwIChBYnN0cmFjdCB7IGtpbmQgPSBgVW5pb247IF8gfSkgLT4gYFVuaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueVR5cCAoQWJzdHJhY3QgeyBraW5kID0gYEludGVyZmFjZSBfOyBfIH0pIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYEludGVyZmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlUeXAgKExpc3QgXykgLT4gYExpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55VHlwIChTY2FsYXIgXykgLT4gYFNjYWxhclxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlUeXAgKEVudW0gXykgLT4gYEVudW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55VHlwIChOb25OdWxsYWJsZSBfKSAtPiBgTm9uTnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlBcmdUeXAgKEFyZy5PYmplY3QgXykgLT4gYElucHV0T2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueUFyZ1R5cCAoQXJnLkxpc3QgXykgLT4gYExpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55QXJnVHlwIChBcmcuU2NhbGFyIF8pIC0+IGBTY2FsYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55QXJnVHlwIChBcmcuRW51bSBfKSAtPiBgRW51bVxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlBcmdUeXAgKEFyZy5Ob25OdWxsYWJsZSBfKSAtPiBgTm9uTnVsbCk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZpZWxkXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIm5hbWVcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cCA9IHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID1cbiAgICAgICAgICAgICAgICAgICAgICAoZnVuIF8gdCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueVR5cCAoT2JqZWN0IG8pIC0+IFNvbWUgby5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueVR5cCAoU2NhbGFyIHMpIC0+IFNvbWUgcy5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueVR5cCAoRW51bSBlKSAtPiBTb21lIGUubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlUeXAgKEFic3RyYWN0IGEpIC0+IFNvbWUgYS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueUFyZ1R5cCAoQXJnLk9iamVjdCBvKSAtPiBTb21lIG8ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlBcmdUeXAgKEFyZy5TY2FsYXIgcykgLT4gU29tZSBzLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55QXJnVHlwIChBcmcuRW51bSBlKSAtPiBTb21lIGUubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfCBfIC0+IE5vbmUpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJkZXNjcmlwdGlvblwiO1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgdHlwID0gc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gQXJnLltdO1xuICAgICAgICAgICAgICAgICAgICBsaWZ0ID0gSW8ub2s7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPVxuICAgICAgICAgICAgICAgICAgICAgIChmdW4gXyB0IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55VHlwIChPYmplY3QgbykgLT4gby5kb2NcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55VHlwIChTY2FsYXIgcykgLT4gcy5kb2NcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55VHlwIChFbnVtIGUpIC0+IGUuZG9jXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueVR5cCAoQWJzdHJhY3QgYSkgLT4gYS5kb2NcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55QXJnVHlwIChBcmcuT2JqZWN0IG8pIC0+IG8uZG9jXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueUFyZ1R5cCAoQXJnLlNjYWxhciBzKSAtPiBzLmRvY1xuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlBcmdUeXAgKEFyZy5FbnVtIGUpIC0+IGUuZG9jXG4gICAgICAgICAgICAgICAgICAgICAgICB8IF8gLT4gTm9uZSk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZpZWxkXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcImZpZWxkc1wiO1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgdHlwID0gTGlzdCAoTm9uTnVsbGFibGUgX19maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBBcmcuW107XG4gICAgICAgICAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgKGZ1biBfIHQgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlUeXAgKE9iamVjdCBvKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChMaXN0Lm1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1biBmIC0+IEFueUZpZWxkIGYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoTGF6eS5mb3JjZSBvLmZpZWxkcykpXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueVR5cCAoQWJzdHJhY3QgeyBraW5kID0gYEludGVyZmFjZSBmaWVsZHM7IF8gfSkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoTGlzdC5tYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW4gKEFic3RyYWN0RmllbGQgZikgLT4gQW55RmllbGQgZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChMYXp5LmZvcmNlIGZpZWxkcykpXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueUFyZ1R5cCAoQXJnLk9iamVjdCBvKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcmdfbGlzdCA9IGFyZ3NfdG9fbGlzdCAoTGF6eS5mb3JjZSBvLmZpZWxkcykgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoTGlzdC5tYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW4gKEFueUFyZyBmKSAtPiBBbnlBcmdGaWVsZCBmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnX2xpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB8IF8gLT4gTm9uZSk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZpZWxkXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcImludGVyZmFjZXNcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cCA9IExpc3QgKE5vbk51bGxhYmxlIF9fdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBBcmcuW107XG4gICAgICAgICAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgKGZ1biBfIHQgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlUeXAgKE9iamVjdCBvKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnRlcmZhY2VzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3QuZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeyBraW5kID0gYEludGVyZmFjZSBfOyBfIH0gLT4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgXyAtPiBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIShvLmFic3RyYWN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChMaXN0Lm1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1biBpIC0+IEFueVR5cCAoQWJzdHJhY3QgaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmZhY2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfCBfIC0+IE5vbmUpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJwb3NzaWJsZVR5cGVzXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBMaXN0IChOb25OdWxsYWJsZSBfX3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gQXJnLltdO1xuICAgICAgICAgICAgICAgICAgICBsaWZ0ID0gSW8ub2s7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPVxuICAgICAgICAgICAgICAgICAgICAgIChmdW4gXyB0IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55VHlwIChBYnN0cmFjdCBhKSAtPiBTb21lIGEudHlwZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgXyAtPiBOb25lKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmllbGRcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwib2ZUeXBlXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBfX3R5cGU7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBBcmcuW107XG4gICAgICAgICAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgKGZ1biBfIHQgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlUeXAgKE5vbk51bGxhYmxlIHR5cCkgLT4gU29tZSAoQW55VHlwIHR5cClcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55VHlwIChMaXN0IHR5cCkgLT4gU29tZSAoQW55VHlwIHR5cClcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55QXJnVHlwIChBcmcuTm9uTnVsbGFibGUgdHlwKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvbWUgKEFueUFyZ1R5cCB0eXApXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueUFyZ1R5cCAoQXJnLkxpc3QgdHlwKSAtPiBTb21lIChBbnlBcmdUeXAgdHlwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfCBfIC0+IE5vbmUpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJpbnB1dEZpZWxkc1wiO1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgdHlwID0gTGlzdCAoTm9uTnVsbGFibGUgX19pbnB1dF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBBcmcuW107XG4gICAgICAgICAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgKGZ1biBfIHQgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlBcmdUeXAgKEFyZy5PYmplY3QgbykgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTb21lIChhcmdzX3RvX2xpc3QgKExhenkuZm9yY2Ugby5maWVsZHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfCBfIC0+IE5vbmUpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJlbnVtVmFsdWVzXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBMaXN0IChOb25OdWxsYWJsZSBfX2VudW1fdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gQXJnLltdO1xuICAgICAgICAgICAgICAgICAgICBsaWZ0ID0gSW8ub2s7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPVxuICAgICAgICAgICAgICAgICAgICAgIChmdW4gXyB0IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55VHlwIChFbnVtIGUpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU29tZSAoTGlzdC5tYXAgKGZ1biB4IC0+IEFueUVudW1WYWx1ZSB4KSBlLnZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55QXJnVHlwIChBcmcuRW51bSBlKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvbWUgKExpc3QubWFwIChmdW4geCAtPiBBbnlFbnVtVmFsdWUgeCkgZS52YWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB8IF8gLT4gTm9uZSk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICBhbmQgX19maWVsZCA6ICdjdHguICgnY3R4LCBhbnlfZmllbGQgb3B0aW9uKSB0eXAgPVxuICAgICAgT2JqZWN0XG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lID0gXCJfX0ZpZWxkXCI7XG4gICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICBhYnN0cmFjdHMgPSBub19hYnN0cmFjdHM7XG4gICAgICAgICAgZmllbGRzID1cbiAgICAgICAgICAgIGxhenlcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIEZpZWxkXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIm5hbWVcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cCA9IE5vbk51bGxhYmxlIHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID1cbiAgICAgICAgICAgICAgICAgICAgICAoZnVuIF8gZiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggZiB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueUZpZWxkIChGaWVsZCBmKSAtPiBmLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55QXJnRmllbGQgKEFyZy5BcmcgYSkgLT4gYS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueUFyZ0ZpZWxkIChBcmcuRGVmYXVsdEFyZyBhKSAtPiBhLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJkZXNjcmlwdGlvblwiO1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgdHlwID0gc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gQXJnLltdO1xuICAgICAgICAgICAgICAgICAgICBsaWZ0ID0gSW8ub2s7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPVxuICAgICAgICAgICAgICAgICAgICAgIChmdW4gXyBmIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBmIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55RmllbGQgKEZpZWxkIGYpIC0+IGYuZG9jXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueUFyZ0ZpZWxkIChBcmcuQXJnIGEpIC0+IGEuZG9jXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueUFyZ0ZpZWxkIChBcmcuRGVmYXVsdEFyZyBhKSAtPiBhLmRvYyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZpZWxkXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcImFyZ3NcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cCA9IE5vbk51bGxhYmxlIChMaXN0IChOb25OdWxsYWJsZSBfX2lucHV0X3ZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBBcmcuW107XG4gICAgICAgICAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgKGZ1biBfIGYgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoIGYgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlGaWVsZCAoRmllbGQgZikgLT4gYXJnc190b19saXN0IGYuYXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlBcmdGaWVsZCBfIC0+IFtdKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmllbGRcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwidHlwZVwiO1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgdHlwID0gTm9uTnVsbGFibGUgX190eXBlO1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gQXJnLltdO1xuICAgICAgICAgICAgICAgICAgICBsaWZ0ID0gSW8ub2s7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPVxuICAgICAgICAgICAgICAgICAgICAgIChmdW4gXyBmIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBmIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55RmllbGQgKEZpZWxkIGYpIC0+IEFueVR5cCBmLnR5cFxuICAgICAgICAgICAgICAgICAgICAgICAgfCBBbnlBcmdGaWVsZCAoQXJnLkFyZyBhKSAtPiBBbnlBcmdUeXAgYS50eXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55QXJnRmllbGQgKEFyZy5EZWZhdWx0QXJnIGEpIC0+IEFueUFyZ1R5cCBhLnR5cCk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZpZWxkXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcImlzRGVwcmVjYXRlZFwiO1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgdHlwID0gTm9uTnVsbGFibGUgYm9vbDtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID1cbiAgICAgICAgICAgICAgICAgICAgICAoZnVuIF8gZiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggZiB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB8IEFueUZpZWxkIChGaWVsZCB7IGRlcHJlY2F0ZWQgPSBEZXByZWNhdGVkIF87IF8gfSkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB8IF8gLT4gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJkZXByZWNhdGlvblJlYXNvblwiO1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgdHlwID0gc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gQXJnLltdO1xuICAgICAgICAgICAgICAgICAgICBsaWZ0ID0gSW8ub2s7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPVxuICAgICAgICAgICAgICAgICAgICAgIChmdW4gXyBmIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBmIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgQW55RmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoRmllbGQgeyBkZXByZWNhdGVkID0gRGVwcmVjYXRlZCByZWFzb247IF8gfSkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHwgXyAtPiBOb25lKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgIGxldCBfX2RpcmVjdGl2ZV9sb2NhdGlvbiA9XG4gICAgICBFbnVtXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lID0gXCJfX0RpcmVjdGl2ZUxvY2F0aW9uXCI7XG4gICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICB2YWx1ZXMgPVxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiUVVFUllcIjtcbiAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYFF1ZXJ5O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiTVVUQVRJT05cIjtcbiAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYE11dGF0aW9uO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiU1VCU0NSSVBUSU9OXCI7XG4gICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGBTdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJGSUVMRFwiO1xuICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgRmllbGQ7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJGUkFHTUVOVF9ERUZJTklUSU9OXCI7XG4gICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGBGcmFnbWVudF9kZWZpbml0aW9uO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiRlJBR01FTlRfU1BSRUFEXCI7XG4gICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGBGcmFnbWVudF9zcHJlYWQ7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJJTkxJTkVfRlJBR01FTlRcIjtcbiAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYElubGluZV9mcmFnbWVudDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcIlZBUklBQkxFX0RFRklOSVRJT05cIjtcbiAgICAgICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYFZhcmlhYmxlX2RlZmluaXRpb247XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICBsZXQgX19kaXJlY3RpdmUgPVxuICAgICAgT2JqZWN0XG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lID0gXCJfX0RpcmVjdGl2ZVwiO1xuICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgYWJzdHJhY3RzID0gbm9fYWJzdHJhY3RzO1xuICAgICAgICAgIGZpZWxkcyA9XG4gICAgICAgICAgICBsYXp5XG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJuYW1lXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBOb25OdWxsYWJsZSBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBBcmcuW107XG4gICAgICAgICAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IChmdW4gXyAoRGlyZWN0aXZlIGQpIC0+IGQubmFtZSk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZpZWxkXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcImRlc2NyaXB0aW9uXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBBcmcuW107XG4gICAgICAgICAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IChmdW4gXyAoRGlyZWN0aXZlIGQpIC0+IGQuZG9jKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmllbGRcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwibG9jYXRpb25zXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBOb25OdWxsYWJsZSAoTGlzdCAoTm9uTnVsbGFibGUgX19kaXJlY3RpdmVfbG9jYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gKGZ1biBfIChEaXJlY3RpdmUgZCkgLT4gZC5sb2NhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJhcmdzXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBOb25OdWxsYWJsZSAoTGlzdCAoTm9uTnVsbGFibGUgX19pbnB1dF92YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gQXJnLltdO1xuICAgICAgICAgICAgICAgICAgICBsaWZ0ID0gSW8ub2s7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSAoZnVuIF8gKERpcmVjdGl2ZSBkKSAtPiBhcmdzX3RvX2xpc3QgZC5hcmdzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgIGxldCBfX3NjaGVtYSA6ICdjdHguICgnY3R4LCAoJ2N0eCBzY2hlbWEgKiBhbnlfdHlwIGxpc3QpIG9wdGlvbikgdHlwID1cbiAgICAgIE9iamVjdFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZSA9IFwiX19TY2hlbWFcIjtcbiAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgIGFic3RyYWN0cyA9IG5vX2Fic3RyYWN0cztcbiAgICAgICAgICBmaWVsZHMgPVxuICAgICAgICAgICAgbGF6eVxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgRmllbGRcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwidHlwZXNcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cCA9IE5vbk51bGxhYmxlIChMaXN0IChOb25OdWxsYWJsZSBfX3R5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gKGZ1biBfIChfc2NoZW1hLCB0eXBlcykgLT4gdHlwZXMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJxdWVyeVR5cGVcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cCA9IE5vbk51bGxhYmxlIF9fdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgICAgICAgICAgbGlmdCA9IElvLm9rO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID1cbiAgICAgICAgICAgICAgICAgICAgICAoZnVuIF8gKHNjaGVtYSwgX3R5cGVzKSAtPiBBbnlUeXAgKE9iamVjdCBzY2hlbWEucXVlcnkpKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmllbGRcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwibXV0YXRpb25UeXBlXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBfX3R5cGU7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBBcmcuW107XG4gICAgICAgICAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgKGZ1biBfIChzY2hlbWEsIF90eXBlcykgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbi5tYXAgc2NoZW1hLm11dGF0aW9uIH5mOihmdW4gbXV0IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQW55VHlwIChPYmplY3QgbXV0KSkpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGaWVsZFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJzdWJzY3JpcHRpb25UeXBlXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWQgPSBOb3REZXByZWNhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0eXAgPSBfX3R5cGU7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBBcmcuW107XG4gICAgICAgICAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgKGZ1biBfIChzY2hlbWEsIF90eXBlcykgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbi5tYXAgc2NoZW1hLnN1YnNjcmlwdGlvbiB+ZjooZnVuIHN1YnMgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbnlUeXAgKE9iamVjdCAob2JqX29mX3N1YnNjcmlwdGlvbl9vYmogc3VicykpKSk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZpZWxkXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcImRpcmVjdGl2ZXNcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gTm9uZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cCA9IE5vbk51bGxhYmxlIChMaXN0IChOb25OdWxsYWJsZSBfX2RpcmVjdGl2ZSkpO1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gQXJnLltdO1xuICAgICAgICAgICAgICAgICAgICBsaWZ0ID0gSW8ub2s7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSAoZnVuIF8gXyAtPiBbXSk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICBsZXQgYWRkX2J1aWx0X2luX2ZpZWxkcyBzY2hlbWEgPVxuICAgICAgbGV0IHR5cGVzID0gdHlwZXNfb2Zfc2NoZW1hIHNjaGVtYSBpblxuICAgICAgbGV0IHNjaGVtYV9maWVsZCA9XG4gICAgICAgIEZpZWxkXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZSA9IFwiX19zY2hlbWFcIjtcbiAgICAgICAgICAgIGRvYyA9IE5vbmU7XG4gICAgICAgICAgICBkZXByZWNhdGVkID0gTm90RGVwcmVjYXRlZDtcbiAgICAgICAgICAgIHR5cCA9IE5vbk51bGxhYmxlIF9fc2NoZW1hO1xuICAgICAgICAgICAgYXJncyA9IEFyZy5bXTtcbiAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgIHJlc29sdmUgPSAoZnVuIF8gXyAtPiAoc2NoZW1hLCB0eXBlcykpO1xuICAgICAgICAgIH1cbiAgICAgIGluXG4gICAgICBsZXQgdHlwZV9maWVsZCA9XG4gICAgICAgIEZpZWxkXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZSA9IFwiX190eXBlXCI7XG4gICAgICAgICAgICBkb2MgPSBOb25lO1xuICAgICAgICAgICAgZGVwcmVjYXRlZCA9IE5vdERlcHJlY2F0ZWQ7XG4gICAgICAgICAgICB0eXAgPSBfX3R5cGU7XG4gICAgICAgICAgICBhcmdzID0gQXJnLlsgYXJnIFwibmFtZVwiIH50eXA6KG5vbl9udWxsIHN0cmluZykgXTtcbiAgICAgICAgICAgIGxpZnQgPSBJby5vaztcbiAgICAgICAgICAgIHJlc29sdmUgPVxuICAgICAgICAgICAgICAoZnVuIF8gXyBuYW1lIC0+XG4gICAgICAgICAgICAgICAgTGlzdC5maW5kXG4gICAgICAgICAgICAgICAgICAoZnVuIHR5cCAtPlxuICAgICAgICAgICAgICAgICAgICBtYXRjaCB0eXAgd2l0aFxuICAgICAgICAgICAgICAgICAgICB8IEFueVR5cCAoT2JqZWN0IG8pIC0+IG8ubmFtZSA9IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfCBBbnlUeXAgKFNjYWxhciBzKSAtPiBzLm5hbWUgPSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIHwgQW55VHlwIChFbnVtIGUpIC0+IGUubmFtZSA9IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfCBBbnlUeXAgKEFic3RyYWN0IGEpIC0+IGEubmFtZSA9IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfCBBbnlUeXAgKExpc3QgXykgLT4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfCBBbnlUeXAgKE5vbk51bGxhYmxlIF8pIC0+IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHwgQW55QXJnVHlwIChBcmcuT2JqZWN0IG8pIC0+IG8ubmFtZSA9IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfCBBbnlBcmdUeXAgKEFyZy5TY2FsYXIgcykgLT4gcy5uYW1lID0gbmFtZVxuICAgICAgICAgICAgICAgICAgICB8IEFueUFyZ1R5cCAoQXJnLkVudW0gZSkgLT4gZS5uYW1lID0gbmFtZVxuICAgICAgICAgICAgICAgICAgICB8IEFueUFyZ1R5cCAoQXJnLkxpc3QgXykgLT4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfCBBbnlBcmdUeXAgKEFyZy5Ob25OdWxsYWJsZSBfKSAtPiBmYWxzZSlcbiAgICAgICAgICAgICAgICAgIHR5cGVzKTtcbiAgICAgICAgICB9XG4gICAgICBpblxuICAgICAgbGV0IGZpZWxkcyA9XG4gICAgICAgIGxhenkgKHNjaGVtYV9maWVsZCA6OiB0eXBlX2ZpZWxkIDo6IExhenkuZm9yY2Ugc2NoZW1hLnF1ZXJ5LmZpZWxkcylcbiAgICAgIGluXG4gICAgICB7IHNjaGVtYSB3aXRoIHF1ZXJ5ID0geyBzY2hlbWEucXVlcnkgd2l0aCBmaWVsZHMgfSB9XG4gIGVuZFxuXG4gICgqIEV4ZWN1dGlvbiAqKVxuICB0eXBlIHZhcmlhYmxlcyA9IChzdHJpbmcgKiBHcmFwaHFsX3BhcnNlci5jb25zdF92YWx1ZSkgbGlzdFxuXG4gIHR5cGUgZXhlY3V0aW9uX29yZGVyID0gU2VyaWFsIHwgUGFyYWxsZWxcblxuICB0eXBlICdjdHggZXhlY3V0aW9uX2NvbnRleHQgPSB7XG4gICAgdmFyaWFibGVzIDogdmFyaWFibGVfbWFwO1xuICAgIGZyYWdtZW50cyA6IGZyYWdtZW50X21hcDtcbiAgICBjdHggOiAnY3R4O1xuICB9XG5cbiAgdHlwZSBwYXRoID0gWyBgU3RyaW5nIG9mIHN0cmluZyB8IGBJbnQgb2YgaW50IF0gbGlzdFxuXG4gIHR5cGUgZXJyb3IgPSBmaWVsZF9lcnJvciAqIHBhdGhcblxuICB0eXBlIHJlc29sdmVfZXJyb3IgPVxuICAgIFsgYFJlc29sdmVfZXJyb3Igb2YgZXJyb3JcbiAgICB8IGBBcmd1bWVudF9lcnJvciBvZiBzdHJpbmdcbiAgICB8IGBWYWxpZGF0aW9uX2Vycm9yIG9mIHN0cmluZyBdXG5cbiAgdHlwZSBleGVjdXRlX2Vycm9yID1cbiAgICBbIHJlc29sdmVfZXJyb3JcbiAgICB8IGBNdXRhdGlvbnNfbm90X2NvbmZpZ3VyZWRcbiAgICB8IGBTdWJzY3JpcHRpb25zX25vdF9jb25maWd1cmVkXG4gICAgfCBgTm9fb3BlcmF0aW9uX2ZvdW5kXG4gICAgfCBgT3BlcmF0aW9uX25hbWVfcmVxdWlyZWRcbiAgICB8IGBPcGVyYXRpb25fbm90X2ZvdW5kIF1cblxuICB0eXBlICdhIHJlc3BvbnNlID0gKCdhLCBqc29uKSByZXN1bHRcblxuICBsZXQgbWF0Y2hlc190eXBlX2NvbmRpdGlvbiB0eXBlX2NvbmRpdGlvbiAob2JqIDogKCdjdHgsICdzcmMpIG9iaikgPVxuICAgIG9iai5uYW1lID0gdHlwZV9jb25kaXRpb25cbiAgICB8fCBMaXN0LmV4aXN0c1xuICAgICAgICAgKGZ1biAoYWJzdHJhY3QgOiBhYnN0cmFjdCkgLT4gYWJzdHJhY3QubmFtZSA9IHR5cGVfY29uZGl0aW9uKVxuICAgICAgICAgIShvYmouYWJzdHJhY3RzKVxuXG4gIGxldCByZWMgc2hvdWxkX2luY2x1ZGVfZmllbGQgY3R4IChkaXJlY3RpdmVzIDogR3JhcGhxbF9wYXJzZXIuZGlyZWN0aXZlIGxpc3QpXG4gICAgICA9XG4gICAgbWF0Y2ggZGlyZWN0aXZlcyB3aXRoXG4gICAgfCBbXSAtPiBPayB0cnVlXG4gICAgfCB7IG5hbWUgPSBcInNraXBcIjsgYXJndW1lbnRzIH0gOjogcmVzdCAtPlxuICAgICAgICBldmFsX2RpcmVjdGl2ZSBjdHggc2tpcF9kaXJlY3RpdmUgYXJndW1lbnRzIHJlc3RcbiAgICB8IHsgbmFtZSA9IFwiaW5jbHVkZVwiOyBhcmd1bWVudHMgfSA6OiByZXN0IC0+XG4gICAgICAgIGV2YWxfZGlyZWN0aXZlIGN0eCBpbmNsdWRlX2RpcmVjdGl2ZSBhcmd1bWVudHMgcmVzdFxuICAgIHwgeyBuYW1lOyBfIH0gOjogXyAtPlxuICAgICAgICBsZXQgZXJyID0gRm9ybWF0LnNwcmludGYgXCJVbmtub3duIGRpcmVjdGl2ZTogJXNcIiBuYW1lIGluXG4gICAgICAgIEVycm9yIGVyclxuXG4gIGFuZCBldmFsX2RpcmVjdGl2ZSBjdHggKERpcmVjdGl2ZSB7IG5hbWU7IGFyZ3M7IHJlc29sdmU7IF8gfSkgYXJndW1lbnRzIHJlc3RcbiAgICAgID1cbiAgICBsZXQgb3BlbiBScmVzdWx0IGluXG4gICAgQXJnLmV2YWxfYXJnbGlzdCBjdHgudmFyaWFibGVzIH5maWVsZF90eXBlOlwiZGlyZWN0aXZlXCIgfmZpZWxkX25hbWU6bmFtZVxuICAgICAgYXJncyBhcmd1bWVudHMgcmVzb2x2ZVxuICAgID4+PSBmdW5jdGlvblxuICAgIHwgYFNraXAgLT4gT2sgZmFsc2VcbiAgICB8IGBJbmNsdWRlIC0+IHNob3VsZF9pbmNsdWRlX2ZpZWxkIGN0eCByZXN0XG5cbiAgbGV0IGFsaWFzX29yX25hbWUgOiBHcmFwaHFsX3BhcnNlci5maWVsZCAtPiBzdHJpbmcgPVxuICAgZnVuIGZpZWxkIC0+XG4gICAgbWF0Y2ggZmllbGQuYWxpYXMgd2l0aCBTb21lIGFsaWFzIC0+IGFsaWFzIHwgTm9uZSAtPiBmaWVsZC5uYW1lXG5cbiAgbGV0IHJlYyBtZXJnZV9zZWxlY3Rpb25zID8obWVtbyA9IFtdKSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBMaXN0LnJldiBtZW1vXG4gICAgfCBmaWVsZCA6OiBmaWVsZHMgLT5cbiAgICAgICAgbGV0IGlkID0gYWxpYXNfb3JfbmFtZSBmaWVsZCBpblxuICAgICAgICBsZXQgbWF0Y2hpbmcsIHJlc3QgPVxuICAgICAgICAgIExpc3QucGFydGl0aW9uIChmdW4gZmllbGQnIC0+IGlkID0gYWxpYXNfb3JfbmFtZSBmaWVsZCcpIGZpZWxkc1xuICAgICAgICBpblxuICAgICAgICBsZXQgc2VsZWN0aW9uX3NldHMgPVxuICAgICAgICAgIExpc3QubWFwXG4gICAgICAgICAgICAoZnVuIChmaWVsZCA6IEdyYXBocWxfcGFyc2VyLmZpZWxkKSAtPiBmaWVsZC5zZWxlY3Rpb25fc2V0KVxuICAgICAgICAgICAgKGZpZWxkIDo6IG1hdGNoaW5nKVxuICAgICAgICBpblxuICAgICAgICBsZXQgc2VsZWN0aW9uX3NldCA9IExpc3QuY29uY2F0IHNlbGVjdGlvbl9zZXRzIGluXG4gICAgICAgIG1lcmdlX3NlbGVjdGlvbnMgfm1lbW86KHsgZmllbGQgd2l0aCBzZWxlY3Rpb25fc2V0IH0gOjogbWVtbykgcmVzdFxuXG4gIGxldCByZWMgY29sbGVjdF9maWVsZHMgOlxuICAgICAgJ2N0eCBleGVjdXRpb25fY29udGV4dCAtPlxuICAgICAgKCdjdHgsICdzcmMpIG9iaiAtPlxuICAgICAgR3JhcGhxbF9wYXJzZXIuc2VsZWN0aW9uIGxpc3QgLT5cbiAgICAgIChHcmFwaHFsX3BhcnNlci5maWVsZCBsaXN0LCBzdHJpbmcpIHJlc3VsdCA9XG4gICBmdW4gY3R4IG9iaiBmaWVsZHMgLT5cbiAgICBsZXQgb3BlbiBScmVzdWx0IGluXG4gICAgTGlzdC5tYXBcbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IEdyYXBocWxfcGFyc2VyLkZpZWxkIGZpZWxkIC0+XG4gICAgICAgICAgICBzaG91bGRfaW5jbHVkZV9maWVsZCBjdHggZmllbGQuZGlyZWN0aXZlcyA+PnwgZnVuIGluY2x1ZGVfZmllbGQgLT5cbiAgICAgICAgICAgIGlmIGluY2x1ZGVfZmllbGQgdGhlbiBbIGZpZWxkIF0gZWxzZSBbXVxuICAgICAgICB8IEdyYXBocWxfcGFyc2VyLkZyYWdtZW50U3ByZWFkIHNwcmVhZCAtPiAoXG4gICAgICAgICAgICBtYXRjaCBTdHJpbmdNYXAuZmluZCBzcHJlYWQubmFtZSBjdHguZnJhZ21lbnRzIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSB7IHR5cGVfY29uZGl0aW9uOyBzZWxlY3Rpb25fc2V0OyBfIH1cbiAgICAgICAgICAgICAgd2hlbiBtYXRjaGVzX3R5cGVfY29uZGl0aW9uIHR5cGVfY29uZGl0aW9uIG9iaiAtPlxuICAgICAgICAgICAgICAgIHNob3VsZF9pbmNsdWRlX2ZpZWxkIGN0eCBzcHJlYWQuZGlyZWN0aXZlcyA+Pj0gZnVuIGluY2x1ZGVfZmllbGQgLT5cbiAgICAgICAgICAgICAgICBpZiBpbmNsdWRlX2ZpZWxkIHRoZW4gY29sbGVjdF9maWVsZHMgY3R4IG9iaiBzZWxlY3Rpb25fc2V0XG4gICAgICAgICAgICAgICAgZWxzZSBPayBbXVxuICAgICAgICAgICAgfCBfIC0+IE9rIFtdIClcbiAgICAgICAgfCBHcmFwaHFsX3BhcnNlci5JbmxpbmVGcmFnbWVudCBmcmFnbWVudCAtPlxuICAgICAgICAgICAgbGV0IG1hdGNoZXNfdHlwZV9jb25kaXRpb24gPVxuICAgICAgICAgICAgICBtYXRjaCBmcmFnbWVudC50eXBlX2NvbmRpdGlvbiB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICAgICAgICAgIHwgU29tZSBjb25kaXRpb24gLT4gbWF0Y2hlc190eXBlX2NvbmRpdGlvbiBjb25kaXRpb24gb2JqXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgaWYgbWF0Y2hlc190eXBlX2NvbmRpdGlvbiB0aGVuXG4gICAgICAgICAgICAgIHNob3VsZF9pbmNsdWRlX2ZpZWxkIGN0eCBmcmFnbWVudC5kaXJlY3RpdmVzXG4gICAgICAgICAgICAgID4+PSBmdW4gaW5jbHVkZV9maWVsZCAtPlxuICAgICAgICAgICAgICBpZiBpbmNsdWRlX2ZpZWxkIHRoZW5cbiAgICAgICAgICAgICAgICBjb2xsZWN0X2ZpZWxkcyBjdHggb2JqIGZyYWdtZW50LnNlbGVjdGlvbl9zZXRcbiAgICAgICAgICAgICAgZWxzZSBPayBbXVxuICAgICAgICAgICAgZWxzZSBPayBbXSlcbiAgICAgIGZpZWxkc1xuICAgIHw+IExpc3QuUmVzdWx0LmpvaW4gfD4gUnJlc3VsdC5SLm1hcCBMaXN0LmNvbmNhdFxuICAgIHw+IFJyZXN1bHQuUi5tYXAgbWVyZ2Vfc2VsZWN0aW9uc1xuXG4gIGxldCBmaWVsZF9mcm9tX29iamVjdCA6XG4gICAgICAoJ2N0eCwgJ3NyYykgb2JqIC0+IHN0cmluZyAtPiAoJ2N0eCwgJ3NyYykgZmllbGQgb3B0aW9uID1cbiAgIGZ1biBvYmogZmllbGRfbmFtZSAtPlxuICAgIExpc3QuZmluZFxuICAgICAgKGZ1biAoRmllbGQgZmllbGQpIC0+IGZpZWxkLm5hbWUgPSBmaWVsZF9uYW1lKVxuICAgICAgKExhenkuZm9yY2Ugb2JqLmZpZWxkcylcblxuICBsZXQgZmllbGRfZnJvbV9zdWJzY3JpcHRpb25fb2JqZWN0IG9iaiBmaWVsZF9uYW1lID1cbiAgICBMaXN0LmZpbmRcbiAgICAgIChmdW4gKFN1YnNjcmlwdGlvbkZpZWxkIGZpZWxkKSAtPiBmaWVsZC5uYW1lID0gZmllbGRfbmFtZSlcbiAgICAgIG9iai5maWVsZHNcblxuICBsZXQgY29lcmNlX29yX251bGwgOlxuICAgICAgJ2Egb3B0aW9uIC0+XG4gICAgICAoJ2EgLT4gKGpzb24gKiBlcnJvciBsaXN0LCAnYikgcmVzdWx0IElvLnQpIC0+XG4gICAgICAoanNvbiAqIGVycm9yIGxpc3QsICdiKSByZXN1bHQgSW8udCA9XG4gICBmdW4gc3JjIGYgLT5cbiAgICBtYXRjaCBzcmMgd2l0aCBOb25lIC0+IElvLm9rIChgTnVsbCwgW10pIHwgU29tZSBzcmMnIC0+IGYgc3JjJ1xuXG4gIGxldCBtYXBfZmllbGRzX3dpdGhfb3JkZXIgPSBmdW5jdGlvblxuICAgIHwgU2VyaWFsIC0+IElvLm1hcF9zIH5tZW1vOltdXG4gICAgfCBQYXJhbGxlbCAtPiBJby5tYXBfcFxuXG4gIGxldCBlcnJvcl90b19qc29uID9wYXRoID9leHRlbnNpb25zIG1zZyA9XG4gICAgbGV0IHByb3BzID1cbiAgICAgIG1hdGNoIHBhdGggd2l0aFxuICAgICAgfCBTb21lIHBhdGggLT4gWyAoXCJwYXRoXCIsIGBMaXN0IChMaXN0LnJldiBwYXRoIDo+IGpzb24gbGlzdCkpIF1cbiAgICAgIHwgTm9uZSAtPiBbXVxuICAgIGluXG4gICAgbGV0IGV4dGVuc2lvbl9wcm9wcyA9XG4gICAgICBtYXRjaCBleHRlbnNpb25zIHdpdGhcbiAgICAgIHwgTm9uZSB8IFNvbWUgW10gLT4gW11cbiAgICAgIHwgU29tZSBleHRlbnNpb25zIC0+IFsgKFwiZXh0ZW5zaW9uc1wiLCBgQXNzb2MgZXh0ZW5zaW9ucykgXVxuICAgIGluXG4gICAgKCBgQXNzb2MgKChcIm1lc3NhZ2VcIiwgYFN0cmluZyBtc2cpIDo6IExpc3QuYXBwZW5kIHByb3BzIGV4dGVuc2lvbl9wcm9wcylcbiAgICAgIDoganNvbiApXG5cbiAgbGV0IGVycm9yX3Jlc3BvbnNlID9kYXRhID9wYXRoID9leHRlbnNpb25zIG1zZyA9XG4gICAgbGV0IGVycm9ycyA9IChcImVycm9yc1wiLCBgTGlzdCBbIGVycm9yX3RvX2pzb24gP3BhdGggP2V4dGVuc2lvbnMgbXNnIF0pIGluXG4gICAgbGV0IGRhdGEgPVxuICAgICAgbWF0Y2ggZGF0YSB3aXRoIE5vbmUgLT4gW10gfCBTb21lIGRhdGEgLT4gWyAoXCJkYXRhXCIsIGRhdGEpIF1cbiAgICBpblxuICAgIGBBc3NvYyAoZXJyb3JzIDo6IGRhdGEpXG5cbiAgbGV0IHJlYyBwcmVzZW50IDpcbiAgICAgIHR5cGUgY3R4IHNyYy5cbiAgICAgIGN0eCBleGVjdXRpb25fY29udGV4dCAtPlxuICAgICAgc3JjIC0+XG4gICAgICBHcmFwaHFsX3BhcnNlci5maWVsZCAtPlxuICAgICAgKGN0eCwgc3JjKSB0eXAgLT5cbiAgICAgIHBhdGggLT5cbiAgICAgIChqc29uICogZXJyb3IgbGlzdCwgWz4gcmVzb2x2ZV9lcnJvciBdKSByZXN1bHQgSW8udCA9XG4gICBmdW4gY3R4IHNyYyBxdWVyeV9maWVsZCB0eXAgcGF0aCAtPlxuICAgIG1hdGNoIHR5cCB3aXRoXG4gICAgfCBTY2FsYXIgcyAtPiBjb2VyY2Vfb3JfbnVsbCBzcmMgKGZ1biB4IC0+IElvLm9rIChzLmNvZXJjZSB4LCBbXSkpXG4gICAgfCBMaXN0IHQgLT5cbiAgICAgICAgY29lcmNlX29yX251bGwgc3JjIChmdW4gc3JjJyAtPlxuICAgICAgICAgICAgTGlzdC5tYXBpXG4gICAgICAgICAgICAgIChmdW4gaSB4IC0+IHByZXNlbnQgY3R4IHggcXVlcnlfZmllbGQgdCAoYEludCBpIDo6IHBhdGgpKVxuICAgICAgICAgICAgICBzcmMnXG4gICAgICAgICAgICB8PiBJby5hbGwgfD4gSW8ubWFwIH5mOkxpc3QuUmVzdWx0LmpvaW5cbiAgICAgICAgICAgIHw+IElvLlJlc3VsdC5tYXAgfmY6KGZ1biB4cyAtPlxuICAgICAgICAgICAgICAgICAgIChgTGlzdCAoTGlzdC5tYXAgZnN0IHhzKSwgTGlzdC5tYXAgc25kIHhzIHw+IExpc3QuY29uY2F0KSkpXG4gICAgfCBOb25OdWxsYWJsZSB0IC0+IHByZXNlbnQgY3R4IChTb21lIHNyYykgcXVlcnlfZmllbGQgdCBwYXRoXG4gICAgfCBPYmplY3QgbyAtPlxuICAgICAgICBjb2VyY2Vfb3JfbnVsbCBzcmMgKGZ1biBzcmMnIC0+XG4gICAgICAgICAgICBtYXRjaCBjb2xsZWN0X2ZpZWxkcyBjdHggbyBxdWVyeV9maWVsZC5zZWxlY3Rpb25fc2V0IHdpdGhcbiAgICAgICAgICAgIHwgT2sgZmllbGRzIC0+IHJlc29sdmVfZmllbGRzIGN0eCBzcmMnIG8gZmllbGRzIHBhdGhcbiAgICAgICAgICAgIHwgRXJyb3IgZSAtPiBJby5lcnJvciAoYEFyZ3VtZW50X2Vycm9yIGUpKVxuICAgIHwgRW51bSBlIC0+XG4gICAgICAgIGNvZXJjZV9vcl9udWxsIHNyYyAoZnVuIHNyYycgLT5cbiAgICAgICAgICAgIG1hdGNoXG4gICAgICAgICAgICAgIExpc3QuZmluZCAoZnVuIGVudW1fdmFsdWUgLT4gc3JjJyA9PSBlbnVtX3ZhbHVlLnZhbHVlKSBlLnZhbHVlc1xuICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGVudW1fdmFsdWUgLT4gSW8ub2sgKGBTdHJpbmcgZW51bV92YWx1ZS5uYW1lLCBbXSlcbiAgICAgICAgICAgIHwgTm9uZSAtPiBJby5vayAoYE51bGwsIFtdKSlcbiAgICB8IEFic3RyYWN0IF8gLT5cbiAgICAgICAgY29lcmNlX29yX251bGwgc3JjIChmdW4gKEFic3RyYWN0VmFsdWUgKHR5cCcsIHNyYycpKSAtPlxuICAgICAgICAgICAgcHJlc2VudCBjdHggKFNvbWUgc3JjJykgcXVlcnlfZmllbGQgdHlwJyBwYXRoKVxuXG4gIGFuZCByZXNvbHZlX2ZpZWxkIDpcbiAgICAgIHR5cGUgY3R4IHNyYy5cbiAgICAgIGN0eCBleGVjdXRpb25fY29udGV4dCAtPlxuICAgICAgc3JjIC0+XG4gICAgICBHcmFwaHFsX3BhcnNlci5maWVsZCAtPlxuICAgICAgKGN0eCwgc3JjKSBmaWVsZCAtPlxuICAgICAgcGF0aCAtPlxuICAgICAgKChzdHJpbmcgKiBqc29uKSAqIGVycm9yIGxpc3QsIFs+IHJlc29sdmVfZXJyb3IgXSkgcmVzdWx0IElvLnQgPVxuICAgZnVuIGN0eCBzcmMgcXVlcnlfZmllbGQgKEZpZWxkIGZpZWxkKSBwYXRoIC0+XG4gICAgbGV0IG9wZW4gSW8uSW5maXggaW5cbiAgICBsZXQgbmFtZSA9IGFsaWFzX29yX25hbWUgcXVlcnlfZmllbGQgaW5cbiAgICBsZXQgcGF0aCcgPSBgU3RyaW5nIG5hbWUgOjogcGF0aCBpblxuICAgIGxldCByZXNvbHZlX2luZm8gPVxuICAgICAge1xuICAgICAgICBjdHggPSBjdHguY3R4O1xuICAgICAgICBmaWVsZCA9IHF1ZXJ5X2ZpZWxkO1xuICAgICAgICBmcmFnbWVudHMgPSBjdHguZnJhZ21lbnRzO1xuICAgICAgICB2YXJpYWJsZXMgPSBjdHgudmFyaWFibGVzO1xuICAgICAgfVxuICAgIGluXG4gICAgbGV0IHJlc29sdmVyID0gZmllbGQucmVzb2x2ZSByZXNvbHZlX2luZm8gc3JjIGluXG4gICAgbWF0Y2hcbiAgICAgIEFyZy5ldmFsX2FyZ2xpc3QgY3R4LnZhcmlhYmxlcyB+ZmllbGRfbmFtZTpmaWVsZC5uYW1lIGZpZWxkLmFyZ3NcbiAgICAgICAgcXVlcnlfZmllbGQuYXJndW1lbnRzIHJlc29sdmVyXG4gICAgd2l0aFxuICAgIHwgT2sgdW5saWZ0ZWRfdmFsdWUgLT4gKFxuICAgICAgICBsZXQgbGlmdGVkX3ZhbHVlID1cbiAgICAgICAgICBmaWVsZC5saWZ0IHVubGlmdGVkX3ZhbHVlXG4gICAgICAgICAgfD4gSW8uUmVzdWx0Lm1hcF9lcnJvciB+ZjooZnVuIGVyciAtPiBgUmVzb2x2ZV9lcnJvciAoZXJyLCBwYXRoJykpXG4gICAgICAgICAgPj49PyBmdW4gcmVzb2x2ZWQgLT4gcHJlc2VudCBjdHggcmVzb2x2ZWQgcXVlcnlfZmllbGQgZmllbGQudHlwIHBhdGgnXG4gICAgICAgIGluXG4gICAgICAgIGxpZnRlZF92YWx1ZSA+PnwgZnVuY3Rpb25cbiAgICAgICAgfCBPayAodmFsdWUsIGVycm9ycykgLT4gT2sgKChuYW1lLCB2YWx1ZSksIGVycm9ycylcbiAgICAgICAgfCAoRXJyb3IgKGBBcmd1bWVudF9lcnJvciBfKSB8IEVycm9yIChgVmFsaWRhdGlvbl9lcnJvciBfKSkgYXMgZXJyb3IgLT5cbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgIHwgRXJyb3IgKGBSZXNvbHZlX2Vycm9yIGVycikgYXMgZXJyb3IgLT4gKFxuICAgICAgICAgICAgbWF0Y2ggZmllbGQudHlwIHdpdGhcbiAgICAgICAgICAgIHwgTm9uTnVsbGFibGUgXyAtPiBlcnJvclxuICAgICAgICAgICAgfCBfIC0+IE9rICgobmFtZSwgYE51bGwpLCBbIGVyciBdKSApIClcbiAgICB8IEVycm9yIGVyciAtPiBJby5lcnJvciAoYEFyZ3VtZW50X2Vycm9yIGVycilcblxuICBhbmQgcmVzb2x2ZV9maWVsZHMgOlxuICAgICAgdHlwZSBjdHggc3JjLlxuICAgICAgY3R4IGV4ZWN1dGlvbl9jb250ZXh0IC0+XG4gICAgICA/ZXhlY3V0aW9uX29yZGVyOmV4ZWN1dGlvbl9vcmRlciAtPlxuICAgICAgc3JjIC0+XG4gICAgICAoY3R4LCBzcmMpIG9iaiAtPlxuICAgICAgR3JhcGhxbF9wYXJzZXIuZmllbGQgbGlzdCAtPlxuICAgICAgcGF0aCAtPlxuICAgICAgKGpzb24gKiBlcnJvciBsaXN0LCBbPiByZXNvbHZlX2Vycm9yIF0pIHJlc3VsdCBJby50ID1cbiAgIGZ1biBjdHggPyhleGVjdXRpb25fb3JkZXIgPSBQYXJhbGxlbCkgc3JjIG9iaiBmaWVsZHMgcGF0aCAtPlxuICAgIG1hcF9maWVsZHNfd2l0aF9vcmRlciBleGVjdXRpb25fb3JkZXJcbiAgICAgIChmdW4gKHF1ZXJ5X2ZpZWxkIDogR3JhcGhxbF9wYXJzZXIuZmllbGQpIC0+XG4gICAgICAgIGxldCBuYW1lID0gYWxpYXNfb3JfbmFtZSBxdWVyeV9maWVsZCBpblxuICAgICAgICBpZiBxdWVyeV9maWVsZC5uYW1lID0gXCJfX3R5cGVuYW1lXCIgdGhlblxuICAgICAgICAgIElvLm9rICgobmFtZSwgYFN0cmluZyBvYmoubmFtZSksIFtdKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbWF0Y2ggZmllbGRfZnJvbV9vYmplY3Qgb2JqIHF1ZXJ5X2ZpZWxkLm5hbWUgd2l0aFxuICAgICAgICAgIHwgU29tZSBmaWVsZCAtPiByZXNvbHZlX2ZpZWxkIGN0eCBzcmMgcXVlcnlfZmllbGQgZmllbGQgcGF0aFxuICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBsZXQgZXJyID1cbiAgICAgICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIkZpZWxkICclcycgaXMgbm90IGRlZmluZWQgb24gdHlwZSAnJXMnXCJcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5X2ZpZWxkLm5hbWUgb2JqLm5hbWVcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgSW8uZXJyb3IgKGBWYWxpZGF0aW9uX2Vycm9yIGVycikpXG4gICAgICBmaWVsZHNcbiAgICB8PiBJby5tYXAgfmY6TGlzdC5SZXN1bHQuam9pblxuICAgIHw+IElvLlJlc3VsdC5tYXAgfmY6KGZ1biB4cyAtPlxuICAgICAgICAgICAoYEFzc29jIChMaXN0Lm1hcCBmc3QgeHMpLCBMaXN0Lm1hcCBzbmQgeHMgfD4gTGlzdC5jb25jYXQpKVxuXG4gIGxldCBkYXRhX3RvX2pzb24gPSBmdW5jdGlvblxuICAgIHwgZGF0YSwgW10gLT4gYEFzc29jIFsgKFwiZGF0YVwiLCBkYXRhKSBdXG4gICAgfCBkYXRhLCBlcnJvcnMgLT5cbiAgICAgICAgbGV0IGVycm9ycyA9XG4gICAgICAgICAgTGlzdC5tYXBcbiAgICAgICAgICAgIChmdW4gKGZpZWxkX2Vycm9yLCBwYXRoKSAtPlxuICAgICAgICAgICAgICBsZXQgZXh0ZW5zaW9ucyA9XG4gICAgICAgICAgICAgICAgRmllbGRfZXJyb3IuZXh0ZW5zaW9uc19vZl9maWVsZF9lcnJvciBmaWVsZF9lcnJvclxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgbXNnID0gRmllbGRfZXJyb3IubWVzc2FnZV9vZl9maWVsZF9lcnJvciBmaWVsZF9lcnJvciBpblxuICAgICAgICAgICAgICBlcnJvcl90b19qc29uIH5wYXRoID9leHRlbnNpb25zIG1zZylcbiAgICAgICAgICAgIGVycm9yc1xuICAgICAgICBpblxuICAgICAgICBgQXNzb2MgWyAoXCJlcnJvcnNcIiwgYExpc3QgZXJyb3JzKTsgKFwiZGF0YVwiLCBkYXRhKSBdXG5cbiAgbGV0IHRvX3Jlc3BvbnNlID0gZnVuY3Rpb25cbiAgICB8IE9rIF8gYXMgcmVzIC0+IHJlc1xuICAgIHwgRXJyb3IgYE5vX29wZXJhdGlvbl9mb3VuZCAtPiBFcnJvciAoZXJyb3JfcmVzcG9uc2UgXCJObyBvcGVyYXRpb24gZm91bmRcIilcbiAgICB8IEVycm9yIGBPcGVyYXRpb25fbm90X2ZvdW5kIC0+XG4gICAgICAgIEVycm9yIChlcnJvcl9yZXNwb25zZSBcIk9wZXJhdGlvbiBub3QgZm91bmRcIilcbiAgICB8IEVycm9yIGBPcGVyYXRpb25fbmFtZV9yZXF1aXJlZCAtPlxuICAgICAgICBFcnJvciAoZXJyb3JfcmVzcG9uc2UgXCJPcGVyYXRpb24gbmFtZSByZXF1aXJlZFwiKVxuICAgIHwgRXJyb3IgYFN1YnNjcmlwdGlvbnNfbm90X2NvbmZpZ3VyZWQgLT5cbiAgICAgICAgRXJyb3IgKGVycm9yX3Jlc3BvbnNlIFwiU3Vic2NyaXB0aW9ucyBub3QgY29uZmlndXJlZFwiKVxuICAgIHwgRXJyb3IgYE11dGF0aW9uc19ub3RfY29uZmlndXJlZCAtPlxuICAgICAgICBFcnJvciAoZXJyb3JfcmVzcG9uc2UgXCJNdXRhdGlvbnMgbm90IGNvbmZpZ3VyZWRcIilcbiAgICB8IEVycm9yIChgVmFsaWRhdGlvbl9lcnJvciBtc2cpIC0+IEVycm9yIChlcnJvcl9yZXNwb25zZSBtc2cpXG4gICAgfCBFcnJvciAoYEFyZ3VtZW50X2Vycm9yIG1zZykgLT4gRXJyb3IgKGVycm9yX3Jlc3BvbnNlIH5kYXRhOmBOdWxsIG1zZylcbiAgICB8IEVycm9yIChgUmVzb2x2ZV9lcnJvciAoZmllbGRfZXJyb3IsIHBhdGgpKSAtPlxuICAgICAgICBsZXQgZXh0ZW5zaW9ucyA9IEZpZWxkX2Vycm9yLmV4dGVuc2lvbnNfb2ZfZmllbGRfZXJyb3IgZmllbGRfZXJyb3IgaW5cbiAgICAgICAgbGV0IG1zZyA9IEZpZWxkX2Vycm9yLm1lc3NhZ2Vfb2ZfZmllbGRfZXJyb3IgZmllbGRfZXJyb3IgaW5cbiAgICAgICAgRXJyb3IgKGVycm9yX3Jlc3BvbnNlIH5kYXRhOmBOdWxsIH5wYXRoID9leHRlbnNpb25zIG1zZylcblxuICBsZXQgc3Vic2NyaWJlIDpcbiAgICAgIHR5cGUgY3R4LlxuICAgICAgY3R4IGV4ZWN1dGlvbl9jb250ZXh0IC0+XG4gICAgICBjdHggc3Vic2NyaXB0aW9uX2ZpZWxkIC0+XG4gICAgICBHcmFwaHFsX3BhcnNlci5maWVsZCAtPlxuICAgICAgKGpzb24gcmVzcG9uc2UgSW8uU3RyZWFtLnQsIFs+IHJlc29sdmVfZXJyb3IgXSkgcmVzdWx0IElvLnQgPVxuICAgZnVuIGN0eCAoU3Vic2NyaXB0aW9uRmllbGQgc3Vic19maWVsZCkgZmllbGQgLT5cbiAgICBsZXQgb3BlbiBJby5JbmZpeCBpblxuICAgIGxldCBuYW1lID0gYWxpYXNfb3JfbmFtZSBmaWVsZCBpblxuICAgIGxldCBwYXRoID0gWyBgU3RyaW5nIG5hbWUgXSBpblxuICAgIGxldCByZXNvbHZlX2luZm8gPVxuICAgICAge1xuICAgICAgICBjdHggPSBjdHguY3R4O1xuICAgICAgICBmaWVsZDtcbiAgICAgICAgZnJhZ21lbnRzID0gY3R4LmZyYWdtZW50cztcbiAgICAgICAgdmFyaWFibGVzID0gY3R4LnZhcmlhYmxlcztcbiAgICAgIH1cbiAgICBpblxuICAgIGxldCByZXNvbHZlciA9IHN1YnNfZmllbGQucmVzb2x2ZSByZXNvbHZlX2luZm8gaW5cbiAgICBtYXRjaFxuICAgICAgQXJnLmV2YWxfYXJnbGlzdCBjdHgudmFyaWFibGVzIH5maWVsZF9uYW1lOnN1YnNfZmllbGQubmFtZVxuICAgICAgICBzdWJzX2ZpZWxkLmFyZ3MgZmllbGQuYXJndW1lbnRzIHJlc29sdmVyXG4gICAgd2l0aFxuICAgIHwgT2sgcmVzdWx0IC0+XG4gICAgICAgIHJlc3VsdFxuICAgICAgICB8PiBJby5SZXN1bHQubWFwIH5mOihmdW4gc291cmNlX3N0cmVhbSAtPlxuICAgICAgICAgICAgICAgSW8uU3RyZWFtLm1hcCBzb3VyY2Vfc3RyZWFtIChmdW4gdmFsdWUgLT5cbiAgICAgICAgICAgICAgICAgICBwcmVzZW50IGN0eCB2YWx1ZSBmaWVsZCBzdWJzX2ZpZWxkLnR5cCBwYXRoXG4gICAgICAgICAgICAgICAgICAgfD4gSW8uUmVzdWx0Lm1hcCB+ZjooZnVuIChkYXRhLCBlcnJvcnMpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfdG9fanNvbiAoYEFzc29jIFsgKG5hbWUsIGRhdGEpIF0sIGVycm9ycykpXG4gICAgICAgICAgICAgICAgICAgPj58IHRvX3Jlc3BvbnNlKSlcbiAgICAgICAgfD4gSW8uUmVzdWx0Lm1hcF9lcnJvciB+ZjooZnVuIGVyciAtPiBgUmVzb2x2ZV9lcnJvciAoZXJyLCBwYXRoKSlcbiAgICB8IEVycm9yIGVyciAtPiBJby5lcnJvciAoYEFyZ3VtZW50X2Vycm9yIGVycilcblxuICBsZXQgZXhlY3V0ZV9vcGVyYXRpb24gOlxuICAgICAgJ2N0eCBzY2hlbWEgLT5cbiAgICAgICdjdHggZXhlY3V0aW9uX2NvbnRleHQgLT5cbiAgICAgIEdyYXBocWxfcGFyc2VyLm9wZXJhdGlvbiAtPlxuICAgICAgKCBbIGBSZXNwb25zZSBvZiBqc29uIHwgYFN0cmVhbSBvZiBqc29uIHJlc3BvbnNlIElvLlN0cmVhbS50IF0sXG4gICAgICAgIFs+IGV4ZWN1dGVfZXJyb3IgXSApXG4gICAgICByZXN1bHRcbiAgICAgIElvLnQgPVxuICAgZnVuIHNjaGVtYSBjdHggb3BlcmF0aW9uIC0+XG4gICAgbGV0IG9wZW4gSW8uSW5maXggaW5cbiAgICBtYXRjaCBvcGVyYXRpb24ub3B0eXBlIHdpdGhcbiAgICB8IEdyYXBocWxfcGFyc2VyLlF1ZXJ5IC0+XG4gICAgICAgIGxldCBxdWVyeSA9IHNjaGVtYS5xdWVyeSBpblxuICAgICAgICBJby5yZXR1cm4gKGNvbGxlY3RfZmllbGRzIGN0eCBxdWVyeSBvcGVyYXRpb24uc2VsZWN0aW9uX3NldClcbiAgICAgICAgfD4gSW8uUmVzdWx0Lm1hcF9lcnJvciB+ZjooZnVuIGUgLT4gYEFyZ3VtZW50X2Vycm9yIGUpXG4gICAgICAgID4+PT8gZnVuIGZpZWxkcyAtPlxuICAgICAgICAoIHJlc29sdmVfZmllbGRzIGN0eCAoKSBxdWVyeSBmaWVsZHMgW11cbiAgICAgICAgICA6IChqc29uICogZXJyb3IgbGlzdCwgcmVzb2x2ZV9lcnJvcikgcmVzdWx0IElvLnRcbiAgICAgICAgICA6PiAoanNvbiAqIGVycm9yIGxpc3QsIFs+IGV4ZWN1dGVfZXJyb3IgXSkgcmVzdWx0IElvLnQgKVxuICAgICAgICB8PiBJby5SZXN1bHQubWFwIH5mOihmdW4gZGF0YV9lcnJzIC0+XG4gICAgICAgICAgICAgICBgUmVzcG9uc2UgKGRhdGFfdG9fanNvbiBkYXRhX2VycnMpKVxuICAgIHwgR3JhcGhxbF9wYXJzZXIuTXV0YXRpb24gLT4gKFxuICAgICAgICBtYXRjaCBzY2hlbWEubXV0YXRpb24gd2l0aFxuICAgICAgICB8IE5vbmUgLT4gSW8uZXJyb3IgYE11dGF0aW9uc19ub3RfY29uZmlndXJlZFxuICAgICAgICB8IFNvbWUgbXV0IC0+XG4gICAgICAgICAgICBJby5yZXR1cm4gKGNvbGxlY3RfZmllbGRzIGN0eCBtdXQgb3BlcmF0aW9uLnNlbGVjdGlvbl9zZXQpXG4gICAgICAgICAgICB8PiBJby5SZXN1bHQubWFwX2Vycm9yIH5mOihmdW4gZSAtPiBgQXJndW1lbnRfZXJyb3IgZSlcbiAgICAgICAgICAgID4+PT8gZnVuIGZpZWxkcyAtPlxuICAgICAgICAgICAgKCByZXNvbHZlX2ZpZWxkcyB+ZXhlY3V0aW9uX29yZGVyOlNlcmlhbCBjdHggKCkgbXV0IGZpZWxkcyBbXVxuICAgICAgICAgICAgICA6IChqc29uICogZXJyb3IgbGlzdCwgcmVzb2x2ZV9lcnJvcikgcmVzdWx0IElvLnRcbiAgICAgICAgICAgICAgOj4gKGpzb24gKiBlcnJvciBsaXN0LCBbPiBleGVjdXRlX2Vycm9yIF0pIHJlc3VsdCBJby50IClcbiAgICAgICAgICAgIHw+IElvLlJlc3VsdC5tYXAgfmY6KGZ1biBkYXRhX2VycnMgLT5cbiAgICAgICAgICAgICAgICAgICBgUmVzcG9uc2UgKGRhdGFfdG9fanNvbiBkYXRhX2VycnMpKSApXG4gICAgfCBHcmFwaHFsX3BhcnNlci5TdWJzY3JpcHRpb24gLT4gKFxuICAgICAgICBtYXRjaCBzY2hlbWEuc3Vic2NyaXB0aW9uIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IElvLmVycm9yIGBTdWJzY3JpcHRpb25zX25vdF9jb25maWd1cmVkXG4gICAgICAgIHwgU29tZSBzdWJzIC0+IChcbiAgICAgICAgICAgIElvLnJldHVyblxuICAgICAgICAgICAgICAoY29sbGVjdF9maWVsZHMgY3R4XG4gICAgICAgICAgICAgICAgIChvYmpfb2Zfc3Vic2NyaXB0aW9uX29iaiBzdWJzKVxuICAgICAgICAgICAgICAgICBvcGVyYXRpb24uc2VsZWN0aW9uX3NldClcbiAgICAgICAgICAgIHw+IElvLlJlc3VsdC5tYXBfZXJyb3IgfmY6KGZ1biBlIC0+IGBBcmd1bWVudF9lcnJvciBlKVxuICAgICAgICAgICAgPj49PyBmdW4gZmllbGRzIC0+XG4gICAgICAgICAgICBtYXRjaCBmaWVsZHMgd2l0aFxuICAgICAgICAgICAgfCBbIGZpZWxkIF0gLT4gKFxuICAgICAgICAgICAgICAgIGlmIGZpZWxkLm5hbWUgPSBcIl9fdHlwZW5hbWVcIiB0aGVuXG4gICAgICAgICAgICAgICAgICBJby5va1xuICAgICAgICAgICAgICAgICAgICAoYFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgKGRhdGFfdG9fanNvblxuICAgICAgICAgICAgICAgICAgICAgICAgIChgQXNzb2MgWyAoZmllbGQubmFtZSwgYFN0cmluZyBzdWJzLm5hbWUpIF0sIFtdKSkpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbWF0Y2ggZmllbGRfZnJvbV9zdWJzY3JpcHRpb25fb2JqZWN0IHN1YnMgZmllbGQubmFtZSB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFNvbWUgc3Vic2NyaXB0aW9uX2ZpZWxkIC0+XG4gICAgICAgICAgICAgICAgICAgICAgKCBzdWJzY3JpYmUgY3R4IHN1YnNjcmlwdGlvbl9maWVsZCBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoIChqc29uLCBqc29uKSByZXN1bHQgSW8uU3RyZWFtLnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZV9lcnJvciApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJby50XG4gICAgICAgICAgICAgICAgICAgICAgICA6PiAoIChqc29uLCBqc29uKSByZXN1bHQgSW8uU3RyZWFtLnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs+IGV4ZWN1dGVfZXJyb3IgXSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIElvLnQgKVxuICAgICAgICAgICAgICAgICAgICAgIHw+IElvLlJlc3VsdC5tYXAgfmY6KGZ1biBzdHJlYW0gLT4gYFN0cmVhbSBzdHJlYW0pXG4gICAgICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiRmllbGQgJyVzJyBpcyBub3QgZGVmaW5lZCBvbiB0eXBlICclcydcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5uYW1lIHN1YnMubmFtZVxuICAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICAgSW8uZXJyb3IgKGBWYWxpZGF0aW9uX2Vycm9yIGVycikgKVxuICAgICAgICAgICAgKCogc2VlIGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vZ3JhcGhxbC9KdW5lMjAxOC8jc2VjLVJlc3BvbnNlLXJvb3QtZmllbGQgKilcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIElvLmVycm9yXG4gICAgICAgICAgICAgICAgICAoYFZhbGlkYXRpb25fZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgXCJTdWJzY3JpcHRpb25zIG9ubHkgYWxsb3cgZXhhY3RseSBvbmUgc2VsZWN0aW9uIGZvciB0aGUgXFxcbiAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5cIikgKSApXG5cbiAgbGV0IGNvbGxlY3RfZnJhZ21lbnRzIGRvYyA9XG4gICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgIChmdW4gbWVtbyAtPiBmdW5jdGlvbiBHcmFwaHFsX3BhcnNlci5PcGVyYXRpb24gXyAtPiBtZW1vXG4gICAgICAgIHwgR3JhcGhxbF9wYXJzZXIuRnJhZ21lbnQgZiAtPiBTdHJpbmdNYXAuYWRkIGYubmFtZSBmIG1lbW8pXG4gICAgICBTdHJpbmdNYXAuZW1wdHkgZG9jXG5cbiAgZXhjZXB0aW9uIEZyYWdtZW50Q3ljbGUgb2Ygc3RyaW5nIGxpc3RcblxuICBsZXQgcmVjIHZhbGlkYXRlX2ZyYWdtZW50cyBmcmFnbWVudF9tYXAgPVxuICAgIHRyeVxuICAgICAgU3RyaW5nTWFwLml0ZXJcbiAgICAgICAgKGZ1biBuYW1lIF8gLT4gdmFsaWRhdGVfZnJhZ21lbnQgZnJhZ21lbnRfbWFwIFN0cmluZ1NldC5lbXB0eSBuYW1lKVxuICAgICAgICBmcmFnbWVudF9tYXA7XG4gICAgICBPayBmcmFnbWVudF9tYXBcbiAgICB3aXRoIEZyYWdtZW50Q3ljbGUgZnJhZ21lbnRfbmFtZXMgLT5cbiAgICAgIGxldCBjeWNsZSA9IFN0cmluZy5jb25jYXQgXCIsIFwiIGZyYWdtZW50X25hbWVzIGluXG4gICAgICBsZXQgZXJyID0gRm9ybWF0LnNwcmludGYgXCJGcmFnbWVudCBjeWNsZSBkZXRlY3RlZDogJXNcIiBjeWNsZSBpblxuICAgICAgRXJyb3IgKGBWYWxpZGF0aW9uX2Vycm9yIGVycilcblxuICBhbmQgdmFsaWRhdGVfZnJhZ21lbnQgKGZyYWdtZW50X21hcCA6IGZyYWdtZW50X21hcCkgdmlzaXRlZCBuYW1lID1cbiAgICBtYXRjaCBTdHJpbmdNYXAuZmluZCBuYW1lIGZyYWdtZW50X21hcCB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGZyYWdtZW50IHdoZW4gU3RyaW5nU2V0Lm1lbSBmcmFnbWVudC5uYW1lIHZpc2l0ZWQgLT5cbiAgICAgICAgcmFpc2UgKEZyYWdtZW50Q3ljbGUgKFN0cmluZ1NldC5lbGVtZW50cyB2aXNpdGVkKSlcbiAgICB8IFNvbWUgZnJhZ21lbnQgLT5cbiAgICAgICAgbGV0IHZpc2l0ZWQnID0gU3RyaW5nU2V0LmFkZCBmcmFnbWVudC5uYW1lIHZpc2l0ZWQgaW5cbiAgICAgICAgTGlzdC5pdGVyXG4gICAgICAgICAgKHZhbGlkYXRlX2ZyYWdtZW50X3NlbGVjdGlvbiBmcmFnbWVudF9tYXAgdmlzaXRlZCcpXG4gICAgICAgICAgZnJhZ21lbnQuc2VsZWN0aW9uX3NldFxuXG4gIGFuZCB2YWxpZGF0ZV9mcmFnbWVudF9zZWxlY3Rpb24gZnJhZ21lbnRfbWFwIHZpc2l0ZWQgc2VsZWN0aW9uID1cbiAgICBtYXRjaCBzZWxlY3Rpb24gd2l0aFxuICAgIHwgR3JhcGhxbF9wYXJzZXIuRmllbGQgZmllbGQgLT5cbiAgICAgICAgTGlzdC5pdGVyXG4gICAgICAgICAgKHZhbGlkYXRlX2ZyYWdtZW50X3NlbGVjdGlvbiBmcmFnbWVudF9tYXAgdmlzaXRlZClcbiAgICAgICAgICBmaWVsZC5zZWxlY3Rpb25fc2V0XG4gICAgfCBJbmxpbmVGcmFnbWVudCBpbmxpbmVfZnJhZ21lbnQgLT5cbiAgICAgICAgTGlzdC5pdGVyXG4gICAgICAgICAgKHZhbGlkYXRlX2ZyYWdtZW50X3NlbGVjdGlvbiBmcmFnbWVudF9tYXAgdmlzaXRlZClcbiAgICAgICAgICBpbmxpbmVfZnJhZ21lbnQuc2VsZWN0aW9uX3NldFxuICAgIHwgRnJhZ21lbnRTcHJlYWQgZnJhZ21lbnRfc3ByZWFkIC0+XG4gICAgICAgIHZhbGlkYXRlX2ZyYWdtZW50IGZyYWdtZW50X21hcCB2aXNpdGVkIGZyYWdtZW50X3NwcmVhZC5uYW1lXG5cbiAgbGV0IGNvbGxlY3RfYW5kX3ZhbGlkYXRlX2ZyYWdtZW50cyBkb2MgPVxuICAgIGxldCBmcmFnbWVudHMgPSBjb2xsZWN0X2ZyYWdtZW50cyBkb2MgaW5cbiAgICB2YWxpZGF0ZV9mcmFnbWVudHMgZnJhZ21lbnRzXG5cbiAgbGV0IGNvbGxlY3Rfb3BlcmF0aW9ucyBkb2MgPVxuICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAoZnVuIG1lbW8gLT4gZnVuY3Rpb24gR3JhcGhxbF9wYXJzZXIuT3BlcmF0aW9uIG9wIC0+IG9wIDo6IG1lbW9cbiAgICAgICAgfCBHcmFwaHFsX3BhcnNlci5GcmFnbWVudCBfIC0+IG1lbW8pXG4gICAgICBbXSBkb2NcblxuICBsZXQgc2VsZWN0X29wZXJhdGlvbiA/b3BlcmF0aW9uX25hbWUgZG9jID1cbiAgICBsZXQgb3BlcmF0aW9ucyA9IGNvbGxlY3Rfb3BlcmF0aW9ucyBkb2MgaW5cbiAgICBtYXRjaCAob3BlcmF0aW9uX25hbWUsIG9wZXJhdGlvbnMpIHdpdGhcbiAgICB8IF8sIFtdIC0+IEVycm9yIGBOb19vcGVyYXRpb25fZm91bmRcbiAgICB8IE5vbmUsIFsgb3AgXSAtPiBPayBvcFxuICAgIHwgTm9uZSwgXyA6OiBfIC0+IEVycm9yIGBPcGVyYXRpb25fbmFtZV9yZXF1aXJlZFxuICAgIHwgU29tZSBuYW1lLCBvcHMgLT4gKFxuICAgICAgICB0cnlcbiAgICAgICAgICBPayAoTGlzdC5maW5kX2V4biAoZnVuIG9wIC0+IG9wLkdyYXBocWxfcGFyc2VyLm5hbWUgPSBTb21lIG5hbWUpIG9wcylcbiAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gRXJyb3IgYE9wZXJhdGlvbl9ub3RfZm91bmQgKVxuXG4gIGxldCBleGVjdXRlIHNjaGVtYSBjdHggPyh2YXJpYWJsZXMgPSBbXSkgP29wZXJhdGlvbl9uYW1lIGRvYyA9XG4gICAgbGV0IG9wZW4gSW8uSW5maXggaW5cbiAgICBsZXQgZXhlY3V0ZScgc2NoZW1hIGN0eCBkb2MgPVxuICAgICAgSW8ucmV0dXJuIChjb2xsZWN0X2FuZF92YWxpZGF0ZV9mcmFnbWVudHMgZG9jKSA+Pj0/IGZ1biBmcmFnbWVudHMgLT5cbiAgICAgIGxldCBzY2hlbWEnID0gSW50cm9zcGVjdGlvbi5hZGRfYnVpbHRfaW5fZmllbGRzIHNjaGVtYSBpblxuICAgICAgSW8ucmV0dXJuIChzZWxlY3Rfb3BlcmF0aW9uID9vcGVyYXRpb25fbmFtZSBkb2MpID4+PT8gZnVuIG9wIC0+XG4gICAgICBsZXQgZGVmYXVsdF92YXJpYWJsZXMgPVxuICAgICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgICAgIChmdW4gbWVtbyB7IEdyYXBocWxfcGFyc2VyLm5hbWU7IGRlZmF1bHRfdmFsdWU7IF8gfSAtPlxuICAgICAgICAgICAgbWF0Y2ggZGVmYXVsdF92YWx1ZSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gbWVtb1xuICAgICAgICAgICAgfCBTb21lIHZhbHVlIC0+IFN0cmluZ01hcC5hZGQgbmFtZSB2YWx1ZSBtZW1vKVxuICAgICAgICAgIFN0cmluZ01hcC5lbXB0eSBvcC52YXJpYWJsZV9kZWZpbml0aW9uc1xuICAgICAgaW5cbiAgICAgIGxldCB2YXJpYWJsZXMgPVxuICAgICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgICAgIChmdW4gbWVtbyAobmFtZSwgdmFsdWUpIC0+IFN0cmluZ01hcC5hZGQgbmFtZSB2YWx1ZSBtZW1vKVxuICAgICAgICAgIGRlZmF1bHRfdmFyaWFibGVzIHZhcmlhYmxlc1xuICAgICAgaW5cbiAgICAgIGxldCBleGVjdXRpb25fY3R4ID0geyBmcmFnbWVudHM7IGN0eDsgdmFyaWFibGVzIH0gaW5cbiAgICAgIGV4ZWN1dGVfb3BlcmF0aW9uIHNjaGVtYScgZXhlY3V0aW9uX2N0eCBvcFxuICAgIGluXG4gICAgZXhlY3V0ZScgc2NoZW1hIGN0eCBkb2MgPj58IHRvX3Jlc3BvbnNlXG5lbmRcbiIsIm1vZHVsZSBTY2hlbWEgPVxuICBHcmFwaHFsX3NjaGVtYS5NYWtlXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSArJ2EgdCA9ICdhXG5cbiAgICAgIGxldCBiaW5kIHQgZiA9IGYgdFxuXG4gICAgICBsZXQgcmV0dXJuIHQgPSB0XG5cbiAgICAgIG1vZHVsZSBTdHJlYW0gPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAnYSB0ID0gJ2EgU2VxLnRcblxuICAgICAgICBsZXQgbWFwIHQgZiA9IFNlcS5tYXAgZiB0XG5cbiAgICAgICAgbGV0IGl0ZXIgdCBmID0gU2VxLml0ZXIgZiB0XG5cbiAgICAgICAgbGV0IGNsb3NlIF90ID0gKClcbiAgICAgIGVuZFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBzdHJpbmdcblxuICAgICAgbGV0IG1lc3NhZ2Vfb2ZfZmllbGRfZXJyb3IgdCA9IHRcblxuICAgICAgbGV0IGV4dGVuc2lvbnNfb2ZfZmllbGRfZXJyb3IgX3QgPSBOb25lXG4gICAgZW5kKVxuIl19
