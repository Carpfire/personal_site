// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Typerep_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib = [0];
   runtime.caml_register_global(0, Typerep_lib, "Typerep_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Named_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Named_intf = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Named_intf, "Typerep_lib__Named_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, refl = 0;
   function conv(param, x){return x;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   var Typerep_lib_Type_equal = [0, conv, refl, Lift];
   runtime.caml_register_global
    (0, Typerep_lib_Type_equal, "Typerep_lib__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typename
//# unitInfo: Requires: Base, Stdlib, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printf, Typerep_lib__Type_equal
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Base = global_data.Base,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl;
   global_data.Stdlib__List;
   var
    _a_ =
      [0,
       [11, "Typename.Same_witness_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "Typename.Same_witness_exn %S %S"],
    cst_Typename_same_witness_exn = "Typename.same_witness_exn",
    cst_Typename_create = "Typename.create",
    cst_static = "static";
   function compare(a, b){return runtime.caml_int_compare(a[1], b[1]);}
   function equal(a, b){return a[1] === b[1] ? 1 : 0;}
   var uid = [0, 0];
   function next(name){var code = uid[1]; uid[1]++; return [0, code, name];}
   function hash(a){return caml_call1(Stdlib_Hashtbl[28], a[1]);}
   function name(a){return a[2];}
   var static$0 = next(cst_static);
   function compare$0(k1, k2){
    if(k1 === k2) return 0;
    var cmp = compare(k1[1], k2[1]);
    if(0 !== cmp) return cmp;
    var b$0 = k2[2], a$0 = k1[2], a = a$0, b = b$0;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], n = compare$0(x, y);
     if(0 !== n) return n;
     var a = xs, b = ys;
    }
   }
   function equal$0(a, b){return 0 === compare$0(a, b) ? 1 : 0;}
   var hash$0 = Stdlib_Hashtbl[28], static$1 = [0, static$0, 0];
   function key(t){return t;}
   function uid$0(t){return t[1];}
   function name$0(t){return t[1][2];}
   function create(opt, param){
    if(opt) var sth = opt[1], name = sth; else var name = cst_Typename_create;
    return [0, next(name), 0];
   }
   function same(nm1, nm2){return 0 === compare$0(nm1, nm2) ? 1 : 0;}
   function same_witness(nm1, nm2){
    return 0 === compare$0(nm1, nm2) ? [0, Typerep_lib_Type_equal[2]] : 0;
   }
   function same_witness_exn(nm1, nm2){
    return 0 === compare$0(nm1, nm2)
            ? Typerep_lib_Type_equal[2]
            : caml_call1(Stdlib[2], cst_Typename_same_witness_exn);
   }
   var Key_table = caml_call1(Stdlib_Hashtbl[26], [0, equal$0, hash$0]);
   function Table(X){
    function create(int$0){return caml_call1(Key_table[1], int$0);}
    function mem(table, name){return caml_call2(Key_table[11], table, name);}
    function set(table, name, data){
     return caml_call3(Key_table[10], table, name, [0, name, data]);
    }
    function find(table, name){
     try{var _h_ = [0, caml_call2(Key_table[7], table, name)], data = _h_;}
     catch(_i_){
      var _g_ = caml_wrap_exception(_i_);
      if(_g_[1] !== Base[248] && _g_ !== Stdlib[8])
       throw caml_maybe_attach_backtrace(_g_, 0);
      var data = 0;
     }
     if(! data) return 0;
     var match = data[1], data$0 = match[2], name$0 = match[1];
     same_witness_exn(name$0, name);
     return [0, data$0];
    }
    return [0, create, mem, set, find];
   }
   function fail(uid_a, uid_b){
    var msg = caml_call3(Stdlib_Printf[4], _a_, uid_a[2], uid_b[2]);
    return caml_call1(Stdlib[2], msg);
   }
   function Same_witness_exn_1(A, B){
    var
     uid_a = caml_call1(A[1], static$1)[1],
     uid_b = caml_call1(B[1], static$1)[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_2(A, B){
    var
     uid_a = caml_call2(A[1], static$1, static$1)[1],
     uid_b = caml_call2(B[1], static$1, static$1)[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_3(A, B){
    var
     uid_a = caml_call3(A[1], static$1, static$1, static$1)[1],
     uid_b = caml_call3(B[1], static$1, static$1, static$1)[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_4(A, B){
    var
     uid_a = caml_call4(A[1], static$1, static$1, static$1, static$1)[1],
     uid_b = caml_call4(B[1], static$1, static$1, static$1, static$1)[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_5(A, B){
    var
     uid_a =
       caml_call5(A[1], static$1, static$1, static$1, static$1, static$1)[1],
     uid_b =
       caml_call5(B[1], static$1, static$1, static$1, static$1, static$1)[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function _b_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b, c, d, e){
     return [0, uid, [0, a, [0, b, [0, c, [0, d, [0, e, 0]]]]]];
    }
    return [0, typename_of_t];
   }
   function _c_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b, c, d){
     return [0, uid, [0, a, [0, b, [0, c, [0, d, 0]]]]];
    }
    return [0, typename_of_t];
   }
   function _d_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b, c){
     return [0, uid, [0, a, [0, b, [0, c, 0]]]];
    }
    return [0, typename_of_t];
   }
   function _e_(X){
    var uid = next(X[1]);
    function typename_of_t(a, b){return [0, uid, [0, a, [0, b, 0]]];}
    return [0, typename_of_t];
   }
   function _f_(X){
    var uid = next(X[1]);
    function typename_of_t(a){return [0, uid, [0, a, 0]];}
    return [0, typename_of_t];
   }
   var
    Typerep_lib_Typename =
      [0,
       create,
       static$1,
       same,
       same_witness,
       same_witness_exn,
       [0, compare$0, equal$0, hash$0],
       key,
       [0, compare, equal, hash, name],
       uid$0,
       name$0,
       function(X){
        var uid = next(X[1]), typename_of_t = [0, uid, 0];
        return [0, typename_of_t];
       },
       _f_,
       _e_,
       _d_,
       _c_,
       _b_,
       Table,
       Same_witness_exn_1,
       Same_witness_exn_2,
       Same_witness_exn_3,
       Same_witness_exn_4,
       Same_witness_exn_5];
   runtime.caml_register_global
    (10, Typerep_lib_Typename, "Typerep_lib__Typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Variant_and_record_intf
//# unitInfo: Requires: Stdlib__Array
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Array = global_data.Stdlib__Array;
   function M(X){
    var Tag_internal = [0];
    function label(t){return t[1];}
    function arity(t){return t[3];}
    function args_labels(t){return t[4];}
    function index(t){return t[5];}
    function ocaml_repr(t){return t[6];}
    function create(t){return t[8];}
    function tyid(t){return t[7];}
    function traverse(t){return t[2];}
    function internal_use_only(t){return t;}
    var
     Tag =
       [0,
        label,
        arity,
        args_labels,
        index,
        ocaml_repr,
        create,
        tyid,
        traverse,
        internal_use_only],
     Variant_internal = [0];
    function typename_of_t(t){return t[1];}
    function length(t){return t[2].length - 1;}
    function tag(t, index){return caml_check_bound(t[2], index)[1 + index];}
    function is_polymorphic(t){return t[3];}
    function value(t){return t[4];}
    function fold(t, init, f){
     return caml_call3(Stdlib_Array[17], f, init, t[2]);
    }
    function internal_use_only$0(t){return t;}
    var
     Variant =
       [0,
        typename_of_t,
        length,
        tag,
        is_polymorphic,
        value,
        fold,
        internal_use_only$0],
     Field_internal = [0];
    function label$0(t){return t[1];}
    function index$0(t){return t[3];}
    function get(t){return t[5];}
    function is_mutable(t){return t[6];}
    function tyid$0(t){return t[4];}
    function traverse$0(t){return t[2];}
    function internal_use_only$1(t){return t;}
    var
     Field =
       [0,
        label$0,
        index$0,
        get,
        is_mutable,
        tyid$0,
        traverse$0,
        internal_use_only$1],
     Record_internal = [0];
    function typename_of_t$0(t){return t[1];}
    function length$0(t){return t[2].length - 1;}
    function field(t, index){return caml_check_bound(t[2], index)[1 + index];}
    function has_double_array_tag(t){return t[3];}
    function create$0(t){return t[4];}
    function fold$0(t, init, f){
     return caml_call3(Stdlib_Array[17], f, init, t[2]);
    }
    function internal_use_only$2(t){return t;}
    var
     Record =
       [0,
        typename_of_t$0,
        length$0,
        field,
        has_double_array_tag,
        create$0,
        fold$0,
        internal_use_only$2];
    return [0,
            Tag_internal,
            Tag,
            Variant_internal,
            Variant,
            Field_internal,
            Field,
            Record_internal,
            Record];
   }
   var Typerep_lib_Variant_and_record = [0, M];
   runtime.caml_register_global
    (1,
     Typerep_lib_Variant_and_record,
     "Typerep_lib__Variant_and_record_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std_internal
//# unitInfo: Requires: Base__Int63, CamlinternalLazy, CamlinternalMod, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_std_internal_ml = "lib/std_internal.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    name = "int",
    name$0 = "int32",
    name$1 = "int64",
    name$2 = "nativeint",
    name$3 = "char",
    name$4 = "float",
    name$5 = "string",
    name$6 = "bytes",
    name$7 = "bool",
    name$8 = "unit",
    name$9 = "option",
    name$10 = "list",
    name$11 = "array",
    name$12 = "lazy_t",
    name$13 = "ref",
    name$14 = "function",
    name$15 = "tuple0",
    name$16 = "tuple2",
    name$17 = "tuple3",
    name$18 = "tuple4",
    name$19 = "tuple5",
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Assert_failure = global_data.Assert_failure,
    CamlinternalMod = global_data.CamlinternalMod,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf,
    Base_Int63 = global_data.Base__Int63,
    typename_of_int = caml_call1(Typerep_lib_Typename[11], [0, name])[1],
    typename_of_int32 = caml_call1(Typerep_lib_Typename[11], [0, name$0])[1],
    typename_of_int64 = caml_call1(Typerep_lib_Typename[11], [0, name$1])[1],
    typename_of_nativeint =
      caml_call1(Typerep_lib_Typename[11], [0, name$2])[1],
    typename_of_char = caml_call1(Typerep_lib_Typename[11], [0, name$3])[1],
    typename_of_float = caml_call1(Typerep_lib_Typename[11], [0, name$4])[1],
    typename_of_string = caml_call1(Typerep_lib_Typename[11], [0, name$5])[1],
    typename_of_bytes = caml_call1(Typerep_lib_Typename[11], [0, name$6])[1],
    typename_of_bool = caml_call1(Typerep_lib_Typename[11], [0, name$7])[1],
    typename_of_unit = caml_call1(Typerep_lib_Typename[11], [0, name$8])[1],
    M_option = caml_call1(Typerep_lib_Typename[12], [0, name$9]),
    typename_of_option = M_option[1],
    M_list = caml_call1(Typerep_lib_Typename[12], [0, name$10]),
    typename_of_list = M_list[1],
    M_array = caml_call1(Typerep_lib_Typename[12], [0, name$11]),
    typename_of_array = M_array[1],
    M_lazy_t = caml_call1(Typerep_lib_Typename[12], [0, name$12]),
    typename_of_lazy_t = M_lazy_t[1],
    M_ref = caml_call1(Typerep_lib_Typename[12], [0, name$13]),
    typename_of_ref = M_ref[1],
    M_function = caml_call1(Typerep_lib_Typename[13], [0, name$14]),
    typename_of_function = M_function[1],
    M_tuple0 = caml_call1(Typerep_lib_Typename[11], [0, name$15]),
    typename_of_tuple0 = M_tuple0[1],
    M_tuple2 = caml_call1(Typerep_lib_Typename[13], [0, name$16]),
    typename_of_tuple2 = M_tuple2[1],
    M_tuple3 = caml_call1(Typerep_lib_Typename[14], [0, name$17]),
    typename_of_tuple3 = M_tuple3[1],
    M_tuple4 = caml_call1(Typerep_lib_Typename[15], [0, name$18]),
    typename_of_tuple4 = M_tuple4[1],
    M_tuple5 = caml_call1(Typerep_lib_Typename[16], [0, name$19]),
    typename_of_tuple5 = M_tuple5[1],
    Typerep =
      caml_call2
       (CamlinternalMod[1],
        [0, cst_lib_std_internal_ml, 401, 6],
        [0,
         [0,
          [0, [0, 0, 0, 0]],
          [0, [0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          0,
          0,
          0,
          0,
          0]]),
    _a_ = [0, 0],
    _b_ = [0, 0],
    _c_ = [0, 0],
    _d_ = [0, 0],
    _e_ = [0, 0],
    _f_ = [0, 0],
    _g_ = [0, 0],
    _h_ = [0, 0],
    _i_ = [0, 0],
    _j_ = [0, 0],
    _k_ = [0, 0],
    _l_ = [0, 0],
    _m_ = [0, 0],
    _n_ = [0, 0],
    _o_ = [0, 0],
    _p_ = [0, cst_lib_std_internal_ml, 802, 14],
    _q_ =
      [0,
       [0,
        [0, [0, 0, 0, 0]],
        [0, [0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0]],
        [0, [0]],
        [0, [0, 0, 0, 0, 0, 0, 0, 0]],
        0,
        0,
        0,
        0,
        0]];
   function arity(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      case 3:
       return 3;
      case 4:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t(param){
    switch(param[0]){
      case 0:
       var rep = param[1]; return rep[2];
      case 1:
       var rep$0 = param[1]; return rep$0[3];
      case 2:
       var rep$1 = param[1]; return rep$1[4];
      case 3:
       var rep$2 = param[1]; return rep$2[5];
      case 4:
       var rep$3 = param[1]; return rep$3[6];
      default: var rep$4 = param[1]; return rep$4[7];
    }
   }
   function name$20(rep){
    var
     ___ = typename_of_t(rep),
     _$_ = caml_call1(Typerep_lib_Typename[9], ___);
    return caml_call1(Typerep_lib_Typename[8][4], _$_);
   }
   var Named = [0, arity, typename_of_t, name$20];
   function arity$0(param){
    switch(param[0]){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t$0(param){
    switch(param[0]){
      case 0:
       var
        match = param[1],
        b = match[2],
        a = match[1],
        _Q_ = caml_call1(Typerep[14], b);
       return caml_call2(typename_of_tuple2, caml_call1(Typerep[14], a), _Q_);
      case 1:
       var
        match$0 = param[1],
        c = match$0[3],
        b$0 = match$0[2],
        a$0 = match$0[1],
        _R_ = caml_call1(Typerep[14], c),
        _S_ = caml_call1(Typerep[14], b$0);
       return caml_call3
               (typename_of_tuple3, caml_call1(Typerep[14], a$0), _S_, _R_);
      case 2:
       var
        match$1 = param[1],
        d = match$1[4],
        c$0 = match$1[3],
        b$1 = match$1[2],
        a$1 = match$1[1],
        _T_ = caml_call1(Typerep[14], d),
        _U_ = caml_call1(Typerep[14], c$0),
        _V_ = caml_call1(Typerep[14], b$1);
       return caml_call4
               (typename_of_tuple4,
                caml_call1(Typerep[14], a$1),
                _V_,
                _U_,
                _T_);
      default:
       var
        match$2 = param[1],
        e = match$2[5],
        d$0 = match$2[4],
        c$1 = match$2[3],
        b$2 = match$2[2],
        a$2 = match$2[1],
        _W_ = caml_call1(Typerep[14], e),
        _X_ = caml_call1(Typerep[14], d$0),
        _Y_ = caml_call1(Typerep[14], c$1),
        _Z_ = caml_call1(Typerep[14], b$2);
       return caml_call5
               (typename_of_tuple5,
                caml_call1(Typerep[14], a$2),
                _Z_,
                _Y_,
                _X_,
                _W_);
    }
   }
   var
    Tuple = [0, arity$0, typename_of_t$0],
    include = caml_call1(Typerep_lib_Variant_and_record[1], [0]),
    Tag_internal = include[1],
    Tag = include[2],
    Variant_internal = include[3],
    Variant = include[4],
    Field_internal = include[5],
    Field = include[6],
    Record_internal = include[7],
    Record = include[8];
   function typename_of_t$1(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return typename_of_int;
       case 1:
        return typename_of_int32;
       case 2:
        return typename_of_int64;
       case 3:
        return typename_of_nativeint;
       case 4:
        return typename_of_char;
       case 5:
        return typename_of_float;
       case 6:
        return typename_of_string;
       case 7:
        return typename_of_bytes;
       case 8:
        return typename_of_bool;
       default: return typename_of_unit;
     }
    switch(param[0]){
      case 0:
       var rep = param[1];
       return caml_call1(typename_of_option, typename_of_t$1(rep));
      case 1:
       var rep$0 = param[1];
       return caml_call1(typename_of_list, typename_of_t$1(rep$0));
      case 2:
       var rep$1 = param[1];
       return caml_call1(typename_of_array, typename_of_t$1(rep$1));
      case 3:
       var rep$2 = param[1];
       return caml_call1(typename_of_lazy_t, typename_of_t$1(rep$2));
      case 4:
       var rep$3 = param[1];
       return caml_call1(typename_of_ref, typename_of_t$1(rep$3));
      case 5:
       var
        match = param[1],
        rng = match[2],
        dom = match[1],
        _P_ = typename_of_t$1(rng);
       return caml_call2(typename_of_function, typename_of_t$1(dom), _P_);
      case 6:
       var rep$4 = param[1]; return caml_call1(Typerep[2][2], rep$4);
      case 7:
       var rep$5 = param[1]; return caml_call1(Typerep[10][1], rep$5);
      case 8:
       var rep$6 = param[1]; return caml_call1(Typerep[6][1], rep$6);
      default: var name = param[1][1]; return caml_call1(Named[2], name);
    }
   }
   function same_witness(t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     a:
     {
      if(typeof t1$0 === "number")
       switch(t1$0){
         case 0:
          if(typeof t2$0 === "number"){if(0 === t2$0) return _a_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 1:
          if(typeof t2$0 === "number"){if(1 === t2$0) return _b_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 2:
          if(typeof t2$0 === "number"){if(2 === t2$0) return _c_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 3:
          if(typeof t2$0 === "number"){if(3 === t2$0) return _d_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 4:
          if(typeof t2$0 === "number"){if(4 === t2$0) return _e_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 5:
          if(typeof t2$0 === "number"){if(5 === t2$0) return _f_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 6:
          if(typeof t2$0 === "number"){if(6 === t2$0) return _g_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 7:
          if(typeof t2$0 === "number"){if(7 === t2$0) return _h_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 8:
          if(typeof t2$0 === "number"){if(8 === t2$0) return _i_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         default:
          if(typeof t2$0 === "number"){if(9 === t2$0) return _j_; break a;}
          if(9 !== t2$0[0]) break a;
       }
      else
       b:
       switch(t1$0[0]){
         case 0:
          var r1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 0:
              var r2$0 = t2$0[1], x = same_witness(r1, r2$0);
              return x ? x : x;
             case 9:
              break b;
           }
          break a;
         case 1:
          var r1$0 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 1:
              var r2$1 = t2$0[1], x$0 = same_witness(r1$0, r2$1);
              return x$0 ? x$0 : x$0;
             case 9:
              break b;
           }
          break a;
         case 2:
          var r1$1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 2:
              var r2$2 = t2$0[1], x$1 = same_witness(r1$1, r2$2);
              return x$1 ? x$1 : x$1;
             case 9:
              break b;
           }
          break a;
         case 3:
          var r1$2 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 3:
              var r2$3 = t2$0[1], x$2 = same_witness(r1$2, r2$3);
              return x$2 ? x$2 : x$2;
             case 9:
              break b;
           }
          break a;
         case 4:
          var r1$3 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 4:
              var r2$4 = t2$0[1], x$3 = same_witness(r1$3, r2$4);
              return x$3 ? x$3 : x$3;
             case 9:
              break b;
           }
          break a;
         case 5:
          var _w_ = t1$0[1], rng1 = _w_[2], dom1 = _w_[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 5:
              var
               match = t2$0[1],
               rng2 = match[2],
               dom2 = match[1],
               match$0 = same_witness(dom1, dom2),
               match$1 = same_witness(rng1, rng2);
              if(match$0 && match$1) return _k_;
              return 0;
             case 9:
              break b;
           }
          break a;
         case 6:
          var t1$1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 6:
              var t2$2 = t2$0[1];
              switch(t1$1[0]){
                case 0:
                 var _x_ = t1$1[1];
                 if(0 !== t2$2[0]) return 0;
                 var
                  match$2 = t2$2[1],
                  b2 = match$2[2],
                  a2 = match$2[1],
                  b1 = _x_[2],
                  a1 = _x_[1],
                  match$3 = same_witness(a1, a2),
                  match$4 = same_witness(b1, b2);
                 if(match$3 && match$4) return _l_;
                 return 0;
                case 1:
                 var _y_ = t1$1[1];
                 if(1 !== t2$2[0]) return 0;
                 var
                  match$5 = t2$2[1],
                  c2 = match$5[3],
                  b2$0 = match$5[2],
                  a2$0 = match$5[1],
                  c1 = _y_[3],
                  b1$0 = _y_[2],
                  a1$0 = _y_[1],
                  match$6 = same_witness(a1$0, a2$0),
                  match$7 = same_witness(b1$0, b2$0),
                  match$8 = same_witness(c1, c2);
                 if(match$6 && match$7 && match$8) return _m_;
                 return 0;
                case 2:
                 var _z_ = t1$1[1];
                 if(2 !== t2$2[0]) return 0;
                 var
                  match$9 = t2$2[1],
                  d2 = match$9[4],
                  c2$0 = match$9[3],
                  b2$1 = match$9[2],
                  a2$1 = match$9[1],
                  d1 = _z_[4],
                  c1$0 = _z_[3],
                  b1$1 = _z_[2],
                  a1$1 = _z_[1],
                  match$10 = same_witness(a1$1, a2$1),
                  match$11 = same_witness(b1$1, b2$1),
                  match$12 = same_witness(c1$0, c2$0),
                  match$13 = same_witness(d1, d2);
                 if(match$10 && match$11 && match$12 && match$13) return _n_;
                 return 0;
                default:
                 var _A_ = t1$1[1];
                 if(3 !== t2$2[0]) return 0;
                 var
                  match$14 = t2$2[1],
                  e2 = match$14[5],
                  d2$0 = match$14[4],
                  c2$1 = match$14[3],
                  b2$2 = match$14[2],
                  a2$2 = match$14[1],
                  e1 = _A_[5],
                  d1$0 = _A_[4],
                  c1$1 = _A_[3],
                  b1$2 = _A_[2],
                  a1$2 = _A_[1],
                  match$15 = same_witness(a1$2, a2$2),
                  match$16 = same_witness(b1$2, b2$2),
                  match$17 = same_witness(c1$1, c2$1),
                  match$18 = same_witness(d1$0, d2$0),
                  match$19 = same_witness(e1, e2);
                 if(match$15 && match$16 && match$17 && match$18 && match$19)
                  return _o_;
                 return 0;
              }
             case 9:
              break b;
           }
          break a;
         case 7:
          var r1$4 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 7:
              var
               r2$5 = t2$0[1],
               _B_ = caml_call1(Typerep[10][1], r2$5),
               _C_ = caml_call1(Typerep[10][1], r1$4);
              return caml_call2(Typerep_lib_Typename[4], _C_, _B_);
             case 9:
              break b;
           }
          break a;
         case 8:
          var r1$5 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 8:
              var
               r2$6 = t2$0[1],
               _D_ = caml_call1(Typerep[6][1], r2$6),
               _E_ = caml_call1(Typerep[6][1], r1$5);
              return caml_call2(Typerep_lib_Typename[4], _E_, _D_);
             case 9:
              break b;
           }
          break a;
         default:
          var match$20 = t1$0[1], name1 = match$20[1];
          if(typeof t2$0 !== "number" && 9 === t2$0[0]){
           var
            match$21 = t2$0[1],
            r2$7 = match$21[2],
            name2 = match$21[1],
            r1$7 = match$20[2],
            _H_ = caml_call1(Named[2], name2),
            _I_ = caml_call1(Named[2], name1),
            x$4 = caml_call2(Typerep_lib_Typename[4], _I_, _H_);
           if(x$4) return x$4;
           if(r1$7){
            var _J_ = r1$7[1], _K_ = caml_obj_tag(_J_);
            c:
            if(250 === _K_)
             var t1$3 = _J_[1];
            else{
             if(246 !== _K_ && 244 !== _K_){var t1$3 = _J_; break c;}
             var t1$3 = caml_call1(CamlinternalLazy[2], _J_);
            }
            if(! r2$7){var t1$0 = t1$3; continue;}
            var _L_ = r2$7[1], _M_ = caml_obj_tag(_L_);
            c:
            if(250 === _M_)
             var t2$3 = _L_[1];
            else{
             if(246 !== _M_ && 244 !== _M_){var t2$3 = _L_; break c;}
             var t2$3 = caml_call1(CamlinternalLazy[2], _L_);
            }
            var t1$0 = t1$3, t2$0 = t2$3;
            continue;
           }
           if(! r2$7) return 0;
           var _N_ = r2$7[1], _O_ = caml_obj_tag(_N_);
           c:
           if(250 === _O_)
            var t2$4 = _N_[1];
           else{
            if(246 !== _O_ && 244 !== _O_){var t2$4 = _N_; break c;}
            var t2$4 = caml_call1(CamlinternalLazy[2], _N_);
           }
           var t2$0 = t2$4;
           continue;
          }
          var r1$6 = match$20[2];
          if(! r1$6) return 0;
          var _F_ = r1$6[1], _G_ = caml_obj_tag(_F_);
          c:
          if(250 === _G_)
           var t1$2 = _F_[1];
          else{
           if(246 !== _G_ && 244 !== _G_){var t1$2 = _F_; break c;}
           var t1$2 = caml_call1(CamlinternalLazy[2], _F_);
          }
          var t1$0 = t1$2;
          continue;
       }
      var r2 = t2$0[1][2];
      if(! r2) return 0;
      var _u_ = r2[1], _v_ = caml_obj_tag(_u_);
      b:
      if(250 === _v_)
       var t2$1 = _u_[1];
      else{
       if(246 !== _v_ && 244 !== _v_){var t2$1 = _u_; break b;}
       var t2$1 = caml_call1(CamlinternalLazy[2], _u_);
      }
      var t2$0 = t2$1;
      continue;
     }
     if(typeof t1$0 === "number")
      switch(t1$0){
        case 0: break;
        case 1:
         return 0;
        case 2:
         return 0;
        case 3:
         return 0;
        case 4:
         return 0;
        case 5:
         return 0;
        case 6:
         return 0;
        case 7:
         return 0;
        case 8:
         return 0;
        default: return 0;
      }
     else
      switch(t1$0[0]){
        case 9: break;
        case 0:
         return 0;
        case 1:
         return 0;
        case 2:
         return 0;
        case 3:
         return 0;
        case 4:
         return 0;
        case 5:
         return 0;
        case 6:
         return 0;
        case 7:
         return 0;
        default: return 0;
      }
     return 0;
    }
   }
   function same(a, b){return 0 !== same_witness(a, b) ? 1 : 0;}
   function same_witness_exn(a, b){
    var match = same_witness(a, b);
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var proof = match[1];
    return proof;
   }
   function head(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 !== "number" && 9 === t$0[0]){
      var _r_ = t$0[1][2];
      if(_r_){
       var _s_ = _r_[1], _t_ = caml_obj_tag(_s_);
       a:
       if(250 === _t_)
        var t$1 = _s_[1];
       else{
        if(246 !== _t_ && 244 !== _t_){var t$1 = _s_; break a;}
        var t$1 = caml_call1(CamlinternalLazy[2], _s_);
       }
       var t$0 = t$1;
       continue;
      }
     }
     return t$0;
    }
   }
   caml_call3
    (CamlinternalMod[2],
     _q_,
     Typerep,
     [0,
      Named,
      Tuple,
      Tag_internal,
      Tag,
      Variant_internal,
      Variant,
      Field_internal,
      Field,
      Record_internal,
      Record,
      same,
      same_witness,
      same_witness_exn,
      typename_of_t$1,
      head]);
   var
    typerep_of_int = 0,
    typerep_of_int32 = 1,
    typerep_of_int64 = 2,
    typerep_of_nativeint = 3,
    typerep_of_char = 4,
    typerep_of_float = 5,
    typerep_of_string = 6,
    typerep_of_bytes = 7,
    typerep_of_bool = 8,
    typerep_of_unit = 9;
   function typerep_of_option(rep){return [0, rep];}
   function typerep_of_list(rep){return [1, rep];}
   function typerep_of_array(rep){return [2, rep];}
   function typerep_of_lazy_t(rep){return [3, rep];}
   function typerep_of_ref(rep){return [4, rep];}
   function typerep_of_function(dom, rng){return [5, [0, dom, rng]];}
   var typerep_of_tuple0 = 9;
   function typerep_of_tuple2(a, b){return [6, [0, [0, a, b]]];}
   function typerep_of_tuple3(a, b, c){return [6, [1, [0, a, b, c]]];}
   function typerep_of_tuple4(a, b, c, d){return [6, [2, [0, a, b, c, d]]];}
   function typerep_of_tuple5(a, b, c, d, e){return [6, [3, [0, a, b, c, d, e]]];
   }
   var
    value_tuple0 = 0,
    match =
      Base_Int63[118][2]
       ? [0, typerep_of_int64, typename_of_int64]
       : [0, typerep_of_int, typename_of_int],
    typename_of_int63 = match[2],
    typerep_of_int63 = match[1],
    Typerep_lib_Std_internal =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global
    (46, Typerep_lib_Std_internal, "Typerep_lib__Std_internal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerepable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Typerepable = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Typerepable, "Typerep_lib__Typerepable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerep_obj
//# unitInfo: Requires: Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_typerep_obj_ml = "lib/typerep_obj.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Assert_failure = global_data.Assert_failure,
    _b_ = [0, cst_lib_typerep_obj_ml, 9, 4],
    _a_ = [0, cst_lib_typerep_obj_ml, 11, 4],
    cst_Latency_stats = "Latency_stats",
    _h_ = [0, cst_lib_typerep_obj_ml, 28, 9],
    cst_zero = "zero",
    _g_ = [0, cst_lib_typerep_obj_ml, 29, 9],
    _f_ = [0, cst_lib_typerep_obj_ml, 49, 2],
    _e_ = [0, cst_lib_typerep_obj_ml, 50, 2];
   function repr_of_poly_variant(variant){
    if(typeof variant === "number") return variant;
    var size = variant.length - 1;
    if(2 !== size)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var repr = variant[1];
    if(typeof repr === "number") return repr;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function hash_variant(s){
    var
     accu = [0, 0],
     _k_ = runtime.caml_ml_string_length(s) - 1 | 0,
     _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      var _l_ = runtime.caml_string_get(s, i);
      accu[1] = (223 * accu[1] | 0) + _l_ | 0;
      var _m_ = i + 1 | 0;
      if(_k_ === i) break;
      var i = _m_;
     }
    }
    accu[1] = accu[1] & 2147483647;
    return 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
   }
   var _c_ = hash_variant(cst_Latency_stats);
   if(repr_of_poly_variant(-894644482) !== _c_)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   var _d_ = hash_variant(cst_zero);
   if(repr_of_poly_variant(-789508312) !== _d_)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   function double_array_value(param){return 0.;}
   function has_double_array_tag(a){
    var _i_ = runtime.caml_obj_tag(a);
    return Stdlib_Obj[17] === _i_ ? 1 : 0;
   }
   var double$0 = [254, 0., 0.], simple = [0, 0., 0.];
   if(! has_double_array_tag(double$0))
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   if(has_double_array_tag(simple))
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   var
    Typerep_lib_Typerep_obj =
      [0,
       repr_of_poly_variant,
       hash_variant,
       double_array_value,
       has_double_array_tag];
   runtime.caml_register_global
    (11, Typerep_lib_Typerep_obj, "Typerep_lib__Typerep_obj");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function M(X){return [0];}
   var Typerep_lib_Type_generic_intf = [0, M];
   runtime.caml_register_global
    (0, Typerep_lib_Type_generic_intf, "Typerep_lib__Type_generic_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic
//# unitInfo: Requires: Base, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__Lazy, Stdlib__List, Stdlib__Printf, Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Type_generic_intf, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_type_generic_ml = "lib/type_generic.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base = global_data.Base,
    Stdlib = global_data.Stdlib,
    Typerep_lib_Type_generic_intf = global_data.Typerep_lib__Type_generic_intf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Array = global_data.Stdlib__Array,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf,
    cst_Typerep_lib_Type_generic_M$0 =
      "Typerep_lib.Type_generic.Make_S_implementation(X).Not_implemented",
    _c_ =
      [0,
       [11,
        "Type_generic ",
        [3,
         0,
         [11, " requires ", [3, 0, [11, " for uid ", [3, 0, [12, 10, 0]]]]]]],
       "Type_generic %S requires %S for uid %S\n"],
    _a_ = [0, cst_lib_type_generic_ml, 185, 16],
    _b_ = [0, cst_lib_type_generic_ml, 187, 69],
    cst_Typerep_lib_Type_generic_M =
      "Typerep_lib.Type_generic.Make_named_for_closure(X).Undefined",
    cst_Typerep_lib_Type_generic_I =
      "Typerep_lib.Type_generic.Ident.Broken_dependency";
   function Helper(A, B){
    function map_variant(param, variant){
     var
      map = param[1],
      typename = caml_call1(A[4][1], variant),
      polymorphic = caml_call1(A[4][4], variant);
     function _az_(index$0){
      var
       tag$0 = caml_call2(A[4][3], variant, index$0),
       tag = tag$0[1],
       label = caml_call1(A[2][1], tag),
       rep = caml_call1(map, caml_call1(A[2][8], tag)),
       arity = caml_call1(A[2][2], tag),
       args_labels = caml_call1(A[2][3], tag),
       index = caml_call1(A[2][4], tag),
       ocaml_repr = caml_call1(A[2][5], tag),
       tyid = caml_call1(A[2][7], tag),
       param = caml_call1(A[2][6], tag);
      if(0 === param[0])
       var fct = param[1], create = [0, fct];
      else
       var k = param[1], create = [1, k];
      return [0,
              caml_call1
               (B[2][9],
                [0,
                 label,
                 rep,
                 arity,
                 args_labels,
                 index,
                 ocaml_repr,
                 tyid,
                 create])];
     }
     var
      _aA_ = caml_call1(A[4][2], variant),
      tags = caml_call2(Stdlib_Array[1], _aA_, _az_);
     function value(a){
      var
       match = caml_call2(A[4][5], variant, a),
       a$0 = match[2],
       atag = match[1],
       _aB_ = caml_call1(A[2][4], atag),
       btag = caml_check_bound(tags, _aB_)[1 + _aB_][1],
       _aC_ = caml_call1(B[2][7], btag),
       _aD_ = caml_call1(A[2][7], atag);
      caml_call2(Typerep_lib_Typename[5], _aD_, _aC_);
      return [0, btag, a$0];
     }
     return caml_call1(B[4][7], [0, typename, tags, polymorphic, value]);
    }
    function map_record(param, record){
     var
      map = param[1],
      typename = caml_call1(A[8][1], record),
      has_double_array_tag = caml_call1(A[8][4], record);
     function _au_(index$0){
      var
       field$0 = caml_call2(A[8][3], record, index$0),
       field = field$0[1],
       label = caml_call1(A[6][1], field),
       rep = caml_call1(map, caml_call1(A[6][6], field)),
       index = caml_call1(A[6][2], field),
       is_mutable = caml_call1(A[6][4], field),
       tyid = caml_call1(A[6][5], field),
       get = caml_call1(A[6][3], field);
      return [0,
              caml_call1
               (B[6][7], [0, label, rep, index, tyid, get, is_mutable])];
     }
     var
      _av_ = caml_call1(A[8][2], record),
      fields = caml_call2(Stdlib_Array[1], _av_, _au_);
     function create(param){
      var get = param[1];
      function get$0(afield){
       var
        _aw_ = caml_call1(A[6][2], afield),
        bfield = caml_check_bound(fields, _aw_)[1 + _aw_][1],
        _ax_ = caml_call1(B[6][5], bfield),
        _ay_ = caml_call1(A[6][5], afield);
       caml_call2(Typerep_lib_Typename[5], _ay_, _ax_);
       return caml_call1(get, bfield);
      }
      return caml_call2(A[8][5], record, [0, get$0]);
     }
     return caml_call1
             (B[8][7], [0, typename, fields, has_double_array_tag, create]);
    }
    return [0, map_variant, map_record];
   }
   var
    Broken_dependency =
      [248, cst_Typerep_lib_Type_generic_I, caml_fresh_oo_id(0)],
    _d_ = Typerep_lib_Typename[6];
   caml_call1(Stdlib_Hashtbl[26], [0, _d_[2], _d_[3]]);
   function _e_(X){
    var required = X[2], name = X[1];
    caml_call1(Typerep_lib_Type_generic_intf[1], [0]);
    var
     _k_ = Typerep_lib_Typename[8],
     include = caml_call1(Stdlib_Hashtbl[26], [0, _k_[2], _k_[3]]),
     create = include[1],
     replace = include[10],
     mem = include[11],
     _l_ = include[7];
    function find(table, key){
     if(! caml_call1(Stdlib_Lazy[3], table)) return 0;
     var _aq_ = caml_obj_tag(table);
     a:
     if(250 === _aq_)
      var table$0 = table[1];
     else{
      if(246 !== _aq_ && 244 !== _aq_){var table$0 = table; break a;}
      var table$0 = caml_call1(CamlinternalLazy[2], table);
     }
     try{var _as_ = [0, caml_call2(_l_, table$0, key)]; return _as_;}
     catch(_at_){
      var _ar_ = caml_wrap_exception(_at_);
      if(_ar_[1] !== Base[248] && _ar_ !== Stdlib[8])
       throw caml_maybe_attach_backtrace(_ar_, 0);
      return 0;
     }
    }
    var
     check_dependencies =
       required
        ? function
         (uid){
          function _an_(param){
           var
            implements$0 = param[2],
            name$0 = param[1],
            _ao_ = 1 - caml_call1(implements$0, uid);
           if(! _ao_) return _ao_;
           var
            _ap_ = caml_call1(Typerep_lib_Typename[8][4], uid),
            message = caml_call4(Stdlib_Printf[4], _c_, name, name$0, _ap_);
           caml_call1(Stdlib[53], message);
           throw caml_maybe_attach_backtrace
                  ([0, Broken_dependency, message], 1);
          }
          return caml_call2(Stdlib_List[18], _an_, required);
         }
        : function(param){return;};
    function replace$0(table, key, value){
     check_dependencies(key);
     var _al_ = caml_obj_tag(table);
     a:
     if(250 === _al_)
      var _am_ = table[1];
     else{
      if(246 !== _al_ && 244 !== _al_){var _am_ = table; break a;}
      var _am_ = caml_call1(CamlinternalLazy[2], table);
     }
     return caml_call3(replace, _am_, key, value);
    }
    function mem$0(table, key){
     if(! caml_call1(Stdlib_Lazy[3], table)) return 0;
     var _ak_ = caml_obj_tag(table);
     a:
     if(250 === _ak_)
      var table$0 = table[1];
     else{
      if(246 !== _ak_ && 244 !== _ak_){var table$0 = table; break a;}
      var table$0 = caml_call1(CamlinternalLazy[2], table);
     }
     return caml_call2(mem, table$0, key);
    }
    var
     size = 256,
     table0 = [246, function(_aj_){return caml_call1(create, size);}],
     table1 = [246, function(_ai_){return caml_call1(create, size);}],
     table2 = [246, function(_ah_){return caml_call1(create, size);}],
     table3 = [246, function(_ag_){return caml_call1(create, size);}],
     table4 = [246, function(_af_){return caml_call1(create, size);}],
     table5 = [246, function(_ae_){return caml_call1(create, size);}];
    function is_registered(uid){
     var ___ = mem$0(table0, uid);
     if(___)
      var _$_ = ___;
     else{
      var _aa_ = mem$0(table1, uid);
      if(_aa_)
       var _$_ = _aa_;
      else{
       var _ab_ = mem$0(table2, uid);
       if(_ab_)
        var _$_ = _ab_;
       else{
        var _ac_ = mem$0(table3, uid);
        if(_ac_)
         var _$_ = _ac_;
        else{
         var _ad_ = mem$0(table4, uid);
         if(! _ad_) return mem$0(table5, uid);
         var _$_ = _ad_;
        }
       }
      }
     }
     return _$_;
    }
    var ident = [0, name, is_registered], unit = Typerep_lib_Typename[2];
    function register0(compute){
     var uid = caml_call1(Typerep_lib_Typename[9], compute[2]);
     return replace$0(table0, uid, compute);
    }
    function register1(compute){
     var
      _Z_ = caml_call1(compute[2], unit),
      uid = caml_call1(Typerep_lib_Typename[9], _Z_);
     return replace$0(table1, uid, compute);
    }
    function register2(compute){
     var
      _Y_ = caml_call2(compute[2], unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _Y_);
     return replace$0(table2, uid, compute);
    }
    function register3(compute){
     var
      _X_ = caml_call3(compute[2], unit, unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _X_);
     return replace$0(table3, uid, compute);
    }
    function register4(compute){
     var
      _W_ = caml_call4(compute[2], unit, unit, unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _W_);
     return replace$0(table4, uid, compute);
    }
    function register5(compute){
     var
      _V_ = caml_call5(compute[2], unit, unit, unit, unit, unit),
      uid = caml_call1(Typerep_lib_Typename[9], _V_);
     return replace$0(table5, uid, compute);
    }
    function register(typerep_of_a, compute){
     var
      typename_of_t =
        caml_call1(Typerep_lib_Std_internal[1][14], typerep_of_a);
     return register0([0, typerep_of_a, typename_of_t, compute]);
    }
    var
     Not_implemented =
       [248, cst_Typerep_lib_Type_generic_M$0, caml_fresh_oo_id(0)],
     Memo = caml_call1(Typerep_lib_Typename[17], [0]),
     _m_ = Typerep_lib_Std_internal[1],
     Helper$0 =
       Helper
        ([0, _m_[3], _m_[4], _m_[5], _m_[6], _m_[7], _m_[8], _m_[9], _m_[10]],
         [0, X[3], X[4], X[5], X[6], X[7], X[8], X[9], X[10]]);
    function of_typerep(rep){
     var
      context = caml_call1(X[33][1][1], 0),
      memo_table = caml_call1(Memo[1], 32);
     function of_typerep(param){
      var param$0 = param;
      for(;;){
       if(typeof param$0 === "number")
        switch(param$0){
          case 0:
           return X[11];
          case 1:
           return X[12];
          case 2:
           return X[13];
          case 3:
           return X[14];
          case 4:
           return X[15];
          case 5:
           return X[16];
          case 6:
           return X[17];
          case 7:
           return X[18];
          case 8:
           return X[19];
          default: return X[20];
        }
       switch(param$0[0]){
         case 0:
          var rep$11 = param$0[1], _J_ = of_typerep(rep$11);
          return caml_call1(X[21], _J_);
         case 1:
          var rep$12 = param$0[1], _K_ = of_typerep(rep$12);
          return caml_call1(X[22], _K_);
         case 2:
          var rep$13 = param$0[1], _L_ = of_typerep(rep$13);
          return caml_call1(X[23], _L_);
         case 3:
          var rep$14 = param$0[1], _M_ = of_typerep(rep$14);
          return caml_call1(X[24], _M_);
         case 4:
          var rep$15 = param$0[1], _N_ = of_typerep(rep$15);
          return caml_call1(X[25], _N_);
         case 5:
          var
           match$11 = param$0[1],
           rng = match$11[2],
           dom = match$11[1],
           _O_ = of_typerep(rng),
           _P_ = of_typerep(dom);
          return caml_call2(X[26], _P_, _O_);
         case 6:
          var tuple = param$0[1];
          switch(tuple[0]){
            case 0:
             var
              match$12 = tuple[1],
              b = match$12[2],
              a = match$12[1],
              ra = of_typerep(a),
              rb = of_typerep(b);
             return caml_call2(X[27], ra, rb);
            case 1:
             var
              match$13 = tuple[1],
              c = match$13[3],
              b$0 = match$13[2],
              a$0 = match$13[1],
              ra$0 = of_typerep(a$0),
              rb$0 = of_typerep(b$0),
              rc = of_typerep(c);
             return caml_call3(X[28], ra$0, rb$0, rc);
            case 2:
             var
              match$14 = tuple[1],
              d = match$14[4],
              c$0 = match$14[3],
              b$1 = match$14[2],
              a$1 = match$14[1],
              ra$1 = of_typerep(a$1),
              rb$1 = of_typerep(b$1),
              rc$0 = of_typerep(c$0),
              rd = of_typerep(d);
             return caml_call4(X[29], ra$1, rb$1, rc$0, rd);
            default:
             var
              match$15 = tuple[1],
              e = match$15[5],
              d$0 = match$15[4],
              c$1 = match$15[3],
              b$2 = match$15[2],
              a$2 = match$15[1],
              ra$2 = of_typerep(a$2),
              rb$2 = of_typerep(b$2),
              rc$1 = of_typerep(c$1),
              rd$0 = of_typerep(d$0),
              re = of_typerep(e);
             return caml_call5(X[30], ra$2, rb$2, rc$1, rd$0, re);
          }
         case 7:
          var
           record = param$0[1],
           _Q_ = caml_call2(Helper$0[2], [0, of_typerep], record);
          return caml_call1(X[31], _Q_);
         case 8:
          var
           variant = param$0[1],
           _R_ = caml_call2(Helper$0[1], [0, of_typerep], variant);
          return caml_call1(X[32], _R_);
         default:
          var
           match$16 = param$0[1],
           content = match$16[2],
           named = match$16[1],
           typename = caml_call1(Typerep_lib_Std_internal[1][1][2], named),
           match$17 = caml_call2(Memo[4], memo_table, typename);
          if(match$17){
           var shared = match$17[1];
           return caml_call1(X[33][3], shared);
          }
          switch(named[0]){
            case 0:
             var
              rep$5 = named[1],
              match =
                find(table0, caml_call1(Typerep_lib_Typename[9], rep$5[2]));
             if(match)
              var
               rep = match[1],
               witness = caml_call2(Typerep_lib_Typename[5], rep[2], rep$5[1]),
               L = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _n_ = rep[3],
               _o_ = caml_call1(L[1], witness),
               match$5 = [0, caml_call2(Typerep_lib_Type_equal[1], _o_, _n_)];
             else
              var match$5 = 0;
             if(match$5)
              var custom = match$5[1], match$18 = [0, custom];
             else
              var match$18 = 0;
             break;
            case 1:
             var
              rep$6 = named[1],
              match$0 =
                find(table1, caml_call1(Typerep_lib_Typename[9], rep$6[3]));
             if(match$0)
              var
               rep$0 = match$0[1],
               typename_of_t = rep$6[2],
               Conv =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[18], [0, rep$0[2]]),
                   [0, typename_of_t]),
               L$0 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _p_ = rep$0[3],
               _q_ = caml_call1(L$0[1], Conv[1][1]),
               match$6 = [0, caml_call2(Typerep_lib_Type_equal[1], _q_, _p_)];
             else
              var match$6 = 0;
             if(match$6)
              var
               custom$0 = match$6[1],
               custom$1 = caml_call1(custom$0, of_typerep(rep$6[1])),
               match$18 = [0, custom$1];
             else
              var match$18 = 0;
             break;
            case 2:
             var
              rep$7 = named[1],
              match$1 =
                find(table2, caml_call1(Typerep_lib_Typename[9], rep$7[4]));
             if(match$1)
              var
               rep$1 = match$1[1],
               typename_of_t$0 = rep$7[3],
               Conv$0 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[19], [0, rep$1[2]]),
                   [0, typename_of_t$0]),
               L$1 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _r_ = rep$1[3],
               _s_ = caml_call1(L$1[1], Conv$0[1][1]),
               match$7 = [0, caml_call2(Typerep_lib_Type_equal[1], _s_, _r_)];
             else
              var match$7 = 0;
             if(match$7)
              var
               custom$2 = match$7[1],
               _z_ = of_typerep(rep$7[2]),
               custom$3 = caml_call2(custom$2, of_typerep(rep$7[1]), _z_),
               match$18 = [0, custom$3];
             else
              var match$18 = 0;
             break;
            case 3:
             var
              rep$8 = named[1],
              match$2 =
                find(table3, caml_call1(Typerep_lib_Typename[9], rep$8[5]));
             if(match$2)
              var
               rep$2 = match$2[1],
               typename_of_t$1 = rep$8[4],
               Conv$1 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[20], [0, rep$2[2]]),
                   [0, typename_of_t$1]),
               L$2 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _t_ = rep$2[3],
               _u_ = caml_call1(L$2[1], Conv$1[1][1]),
               match$8 = [0, caml_call2(Typerep_lib_Type_equal[1], _u_, _t_)];
             else
              var match$8 = 0;
             if(match$8)
              var
               custom$4 = match$8[1],
               _A_ = of_typerep(rep$8[3]),
               _B_ = of_typerep(rep$8[2]),
               custom$5 = caml_call3(custom$4, of_typerep(rep$8[1]), _B_, _A_),
               match$18 = [0, custom$5];
             else
              var match$18 = 0;
             break;
            case 4:
             var
              rep$9 = named[1],
              match$3 =
                find(table4, caml_call1(Typerep_lib_Typename[9], rep$9[6]));
             if(match$3)
              var
               rep$3 = match$3[1],
               typename_of_t$2 = rep$9[5],
               Conv$2 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[21], [0, rep$3[2]]),
                   [0, typename_of_t$2]),
               L$3 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _v_ = rep$3[3],
               _w_ = caml_call1(L$3[1], Conv$2[1][1]),
               match$9 = [0, caml_call2(Typerep_lib_Type_equal[1], _w_, _v_)];
             else
              var match$9 = 0;
             if(match$9)
              var
               custom$6 = match$9[1],
               _C_ = of_typerep(rep$9[4]),
               _D_ = of_typerep(rep$9[3]),
               _E_ = of_typerep(rep$9[2]),
               custom$7 =
                 caml_call4(custom$6, of_typerep(rep$9[1]), _E_, _D_, _C_),
               match$18 = [0, custom$7];
             else
              var match$18 = 0;
             break;
            default:
             var
              rep$10 = named[1],
              match$4 =
                find(table5, caml_call1(Typerep_lib_Typename[9], rep$10[7]));
             if(match$4)
              var
               rep$4 = match$4[1],
               typename_of_t$3 = rep$10[6],
               Conv$3 =
                 caml_call1
                  (caml_call1(Typerep_lib_Typename[22], [0, rep$4[2]]),
                   [0, typename_of_t$3]),
               L$4 = caml_call1(Typerep_lib_Type_equal[3], [0]),
               _x_ = rep$4[3],
               _y_ = caml_call1(L$4[1], Conv$3[1][1]),
               match$10 = [0, caml_call2(Typerep_lib_Type_equal[1], _y_, _x_)];
             else
              var match$10 = 0;
             if(match$10)
              var
               custom$8 = match$10[1],
               _F_ = of_typerep(rep$10[5]),
               _G_ = of_typerep(rep$10[4]),
               _H_ = of_typerep(rep$10[3]),
               _I_ = of_typerep(rep$10[2]),
               custom$9 =
                 caml_call5
                  (custom$8, of_typerep(rep$10[1]), _I_, _H_, _G_, _F_),
               match$18 = [0, custom$9];
             else
              var match$18 = 0;
          }
          if(match$18){var computation = match$18[1]; return computation;}
          if(! content){
           var
            _U_ = caml_call1(Typerep_lib_Typename[9], typename),
            string = caml_call1(Typerep_lib_Typename[8][4], _U_);
           throw caml_maybe_attach_backtrace
                  ([0, Not_implemented, name, string], 1);
          }
          var _S_ = content[1], _T_ = caml_obj_tag(_S_);
          a:
          if(250 === _T_)
           var content$0 = _S_[1];
          else{
           if(246 !== _T_ && 244 !== _T_){var content$0 = _S_; break a;}
           var content$0 = caml_call1(CamlinternalLazy[2], _S_);
          }
          if(caml_call1(X[33][5], content$0)){
           var shared$0 = caml_call2(X[33][2], context, typename);
           caml_call3(Memo[3], memo_table, typename, shared$0);
           var computation$0 = of_typerep(content$0);
           return caml_call2(X[33][4], shared$0, computation$0);
          }
          var param$0 = content$0;
       }
      }
     }
     var computation = of_typerep(rep);
     return [0, 911962647, computation];
    }
    return [0,
            ident,
            Not_implemented,
            register0,
            register1,
            register2,
            register3,
            register4,
            register5,
            register,
            of_typerep,
            [0,
             X[3],
             X[4],
             X[5],
             X[6],
             X[7],
             X[8],
             X[9],
             X[10],
             X[11],
             X[12],
             X[13],
             X[14],
             X[15],
             X[16],
             X[17],
             X[18],
             X[19],
             X[20],
             X[21],
             X[22],
             X[23],
             X[24],
             X[25],
             X[26],
             X[27],
             X[28],
             X[29],
             X[30],
             X[31],
             X[32],
             X[33]]];
   }
   var
    _f_ = [0],
    Typerep_lib_Type_generic =
      [0,
       Typerep_lib_Variant_and_record,
       Helper,
       function(_g_){
        function create(_j_){return 0;}
        var
         Context = [0, create],
         Undefined =
           [248, cst_Typerep_lib_Type_generic_M, caml_fresh_oo_id(0)];
        function init(param, name){
         var
          _h_ = caml_call1(Typerep_lib_Typename[9], name),
          path = caml_call1(Typerep_lib_Typename[8][4], _h_),
          r =
            [0,
             function(param){
              throw caml_maybe_attach_backtrace([0, Undefined, path], 1);
             }],
          _i_ = [0, 0];
         return [0, function(input){return caml_call1(r[1], input);}, r, _i_];
        }
        function get_wip_computation(shared){
         var match = shared[3][1];
         if(! match) return shared[1];
         var clos = match[1];
         return clos;
        }
        function set_final_computation(shared, computation){
         var compiletime_dereference = shared[3];
         if(compiletime_dereference[1])
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         if(shared[1] === computation)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         compiletime_dereference[1] = [0, computation];
         shared[2][1] = computation;
         return computation;
        }
        function share(param){return 1;}
        return [0,
                Context,
                init,
                get_wip_computation,
                set_final_computation,
                share];
       },
       _f_,
       _e_];
   runtime.caml_register_global
    (20, Typerep_lib_Type_generic, "Typerep_lib__Type_generic");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Make_typename
//# unitInfo: Requires: Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Typename
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename;
   function _a_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[16], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2, of_p3, of_p4, of_p5){
     var
      _p_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p5),
      _q_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
      _r_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
      _s_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _t_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call5(Name_of_x[1], _t_, _s_, _r_, _q_, _p_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [5,
             [0,
              of_p1,
              of_p2,
              of_p3,
              of_p4,
              of_p5,
              typename_of_named,
              typename_of_t,
              witness]];
    }
    return [0, named, typename_of_t];
   }
   function _b_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[15], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2, of_p3, of_p4){
     var
      _l_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
      _m_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
      _n_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _o_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call4(Name_of_x[1], _o_, _n_, _m_, _l_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [4,
             [0,
              of_p1,
              of_p2,
              of_p3,
              of_p4,
              typename_of_named,
              typename_of_t,
              witness]];
    }
    return [0, named, typename_of_t];
   }
   function _c_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[14], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2, of_p3){
     var
      _i_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
      _j_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _k_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call3(Name_of_x[1], _k_, _j_, _i_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [3,
             [0,
              of_p1,
              of_p2,
              of_p3,
              typename_of_named,
              typename_of_t,
              witness]];
    }
    return [0, named, typename_of_t];
   }
   function _d_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[13], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1, of_p2){
     var
      _g_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
      _h_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call2(Name_of_x[1], _h_, _g_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [2, [0, of_p1, of_p2, typename_of_named, typename_of_t, witness]];
    }
    return [0, named, typename_of_t];
   }
   function _e_(X){
    var
     Name_of_x = caml_call1(Typerep_lib_Typename[12], X),
     typename_of_t = Name_of_x[1];
    function named(of_p1){
     var
      _f_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
      typename_of_t = caml_call1(Name_of_x[1], _f_),
      typename_of_named = Name_of_x[1],
      witness = Typerep_lib_Type_equal[2];
     return [1, [0, of_p1, typename_of_named, typename_of_t, witness]];
    }
    return [0, named, typename_of_t];
   }
   var
    Typerep_lib_Make_typename =
      [0,
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[11], X),
         typename_of_t = Name_of_x[1],
         typename_of_named = Name_of_x[1],
         witness = Typerep_lib_Type_equal[2],
         named = [0, [0, typename_of_named, typename_of_t, witness]];
        return [0, named, typename_of_t];
       },
       _e_,
       _d_,
       _c_,
       _b_,
       _a_];
   runtime.caml_register_global
    (3, Typerep_lib_Make_typename, "Typerep_lib__Make_typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_abstract
//# unitInfo: Requires: Typerep_lib__Make_typename
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename;
   function Make0(X){
    var
     M = caml_call1(Typerep_lib_Make_typename[1], X),
     typerep_of_t = [9, [0, M[1], 0]],
     typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make1(X){
    var M = caml_call1(Typerep_lib_Make_typename[2], X);
    function typerep_of_t(of_p1){return [9, [0, caml_call1(M[1], of_p1), 0]];}
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make2(X){
    var M = caml_call1(Typerep_lib_Make_typename[3], X);
    function typerep_of_t(of_p1, of_p2){
     return [9, [0, caml_call2(M[1], of_p1, of_p2), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make3(X){
    var M = caml_call1(Typerep_lib_Make_typename[4], X);
    function typerep_of_t(of_p1, of_p2, of_p3){
     return [9, [0, caml_call3(M[1], of_p1, of_p2, of_p3), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make4(X){
    var M = caml_call1(Typerep_lib_Make_typename[5], X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4){
     return [9, [0, caml_call4(M[1], of_p1, of_p2, of_p3, of_p4), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make5(X){
    var M = caml_call1(Typerep_lib_Make_typename[6], X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4, of_p5){
     return [9, [0, caml_call5(M[1], of_p1, of_p2, of_p3, of_p4, of_p5), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   var
    Typerep_lib_Type_abstract = [0, Make0, Make1, Make2, Make3, Make4, Make5];
   runtime.caml_register_global
    (1, Typerep_lib_Type_abstract, "Typerep_lib__Type_abstract");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std
//# unitInfo: Requires: Typerep_lib__Std_internal
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep = Typerep_lib_Std_internal[1],
    typerep_of_int = Typerep_lib_Std_internal[2],
    typerep_of_int32 = Typerep_lib_Std_internal[3],
    typerep_of_int64 = Typerep_lib_Std_internal[4],
    typerep_of_nativeint = Typerep_lib_Std_internal[5],
    typerep_of_int63 = Typerep_lib_Std_internal[6],
    typerep_of_char = Typerep_lib_Std_internal[7],
    typerep_of_float = Typerep_lib_Std_internal[8],
    typerep_of_string = Typerep_lib_Std_internal[9],
    typerep_of_bytes = Typerep_lib_Std_internal[10],
    typerep_of_bool = Typerep_lib_Std_internal[11],
    typerep_of_unit = Typerep_lib_Std_internal[12],
    value_tuple0 = Typerep_lib_Std_internal[13],
    typerep_of_option = Typerep_lib_Std_internal[14],
    typerep_of_list = Typerep_lib_Std_internal[15],
    typerep_of_array = Typerep_lib_Std_internal[16],
    typerep_of_lazy_t = Typerep_lib_Std_internal[17],
    typerep_of_ref = Typerep_lib_Std_internal[18],
    typerep_of_function = Typerep_lib_Std_internal[19],
    typerep_of_tuple0 = Typerep_lib_Std_internal[20],
    typerep_of_tuple2 = Typerep_lib_Std_internal[21],
    typerep_of_tuple3 = Typerep_lib_Std_internal[22],
    typerep_of_tuple4 = Typerep_lib_Std_internal[23],
    typerep_of_tuple5 = Typerep_lib_Std_internal[24],
    typename_of_int = Typerep_lib_Std_internal[25],
    typename_of_int32 = Typerep_lib_Std_internal[26],
    typename_of_int64 = Typerep_lib_Std_internal[27],
    typename_of_nativeint = Typerep_lib_Std_internal[28],
    typename_of_int63 = Typerep_lib_Std_internal[29],
    typename_of_char = Typerep_lib_Std_internal[30],
    typename_of_float = Typerep_lib_Std_internal[31],
    typename_of_string = Typerep_lib_Std_internal[32],
    typename_of_bytes = Typerep_lib_Std_internal[33],
    typename_of_bool = Typerep_lib_Std_internal[34],
    typename_of_unit = Typerep_lib_Std_internal[35],
    typename_of_option = Typerep_lib_Std_internal[36],
    typename_of_list = Typerep_lib_Std_internal[37],
    typename_of_array = Typerep_lib_Std_internal[38],
    typename_of_lazy_t = Typerep_lib_Std_internal[39],
    typename_of_ref = Typerep_lib_Std_internal[40],
    typename_of_function = Typerep_lib_Std_internal[41],
    typename_of_tuple0 = Typerep_lib_Std_internal[42],
    typename_of_tuple2 = Typerep_lib_Std_internal[43],
    typename_of_tuple3 = Typerep_lib_Std_internal[44],
    typename_of_tuple4 = Typerep_lib_Std_internal[45],
    typename_of_tuple5 = Typerep_lib_Std_internal[46],
    Typerep_lib_Std =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global(1, Typerep_lib_Std, "Typerep_lib__Std");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsicmVmbCIsImNvbnYiLCJ4IiwibGlmdCIsImNvbXBhcmUiLCJhIiwiYiIsImVxdWFsIiwidWlkIiwibmV4dCIsIm5hbWUiLCJjb2RlIiwiaGFzaCIsInN0YXRpYyQwIiwiY29tcGFyZSQwIiwiazEiLCJrMiIsImNtcCIsImIkMCIsImEkMCIsInlzIiwieSIsInhzIiwibiIsImVxdWFsJDAiLCJoYXNoJDAiLCJzdGF0aWMkMSIsImtleSIsInQiLCJ1aWQkMCIsIm5hbWUkMCIsImNyZWF0ZSIsIm9wdCIsInN0aCIsInNhbWUiLCJubTEiLCJubTIiLCJzYW1lX3dpdG5lc3MiLCJzYW1lX3dpdG5lc3NfZXhuIiwiaW50JDAiLCJtZW0iLCJ0YWJsZSIsInNldCIsImRhdGEiLCJmaW5kIiwiZGF0YSQwIiwiZmFpbCIsInVpZF9hIiwidWlkX2IiLCJtc2ciLCJ3aXRuZXNzIiwidHlwZW5hbWVfb2ZfdCIsImMiLCJkIiwiZSIsImxhYmVsIiwiYXJpdHkiLCJhcmdzX2xhYmVscyIsImluZGV4Iiwib2NhbWxfcmVwciIsInR5aWQiLCJ0cmF2ZXJzZSIsImludGVybmFsX3VzZV9vbmx5IiwibGVuZ3RoIiwidGFnIiwiaXNfcG9seW1vcnBoaWMiLCJ2YWx1ZSIsImZvbGQiLCJpbml0IiwiZiIsImludGVybmFsX3VzZV9vbmx5JDAiLCJsYWJlbCQwIiwiaW5kZXgkMCIsImdldCIsImlzX211dGFibGUiLCJ0eWlkJDAiLCJ0cmF2ZXJzZSQwIiwiaW50ZXJuYWxfdXNlX29ubHkkMSIsInR5cGVuYW1lX29mX3QkMCIsImxlbmd0aCQwIiwiZmllbGQiLCJoYXNfZG91YmxlX2FycmF5X3RhZyIsImNyZWF0ZSQwIiwiZm9sZCQwIiwiaW50ZXJuYWxfdXNlX29ubHkkMiIsIm5hbWUkMSIsIm5hbWUkMiIsIm5hbWUkMyIsIm5hbWUkNCIsIm5hbWUkNSIsIm5hbWUkNiIsIm5hbWUkNyIsIm5hbWUkOCIsIm5hbWUkOSIsIm5hbWUkMTAiLCJuYW1lJDExIiwibmFtZSQxMiIsIm5hbWUkMTMiLCJuYW1lJDE0IiwibmFtZSQxNSIsIm5hbWUkMTYiLCJuYW1lJDE3IiwibmFtZSQxOCIsIm5hbWUkMTkiLCJ0eXBlbmFtZV9vZl9pbnQiLCJ0eXBlbmFtZV9vZl9pbnQzMiIsInR5cGVuYW1lX29mX2ludDY0IiwidHlwZW5hbWVfb2ZfbmF0aXZlaW50IiwidHlwZW5hbWVfb2ZfY2hhciIsInR5cGVuYW1lX29mX2Zsb2F0IiwidHlwZW5hbWVfb2Zfc3RyaW5nIiwidHlwZW5hbWVfb2ZfYnl0ZXMiLCJ0eXBlbmFtZV9vZl9ib29sIiwidHlwZW5hbWVfb2ZfdW5pdCIsInR5cGVuYW1lX29mX29wdGlvbiIsInR5cGVuYW1lX29mX2xpc3QiLCJ0eXBlbmFtZV9vZl9hcnJheSIsInR5cGVuYW1lX29mX2xhenlfdCIsInR5cGVuYW1lX29mX3JlZiIsInR5cGVuYW1lX29mX2Z1bmN0aW9uIiwidHlwZW5hbWVfb2ZfdHVwbGUwIiwidHlwZW5hbWVfb2ZfdHVwbGUyIiwidHlwZW5hbWVfb2ZfdHVwbGUzIiwidHlwZW5hbWVfb2ZfdHVwbGU0IiwidHlwZW5hbWVfb2ZfdHVwbGU1IiwicmVwIiwicmVwJDAiLCJyZXAkMSIsInJlcCQyIiwicmVwJDMiLCJyZXAkNCIsIm5hbWUkMjAiLCJhcml0eSQwIiwiYyQwIiwiYiQxIiwiYSQxIiwiZCQwIiwiYyQxIiwiYiQyIiwiYSQyIiwidHlwZW5hbWVfb2ZfdCQxIiwicm5nIiwiZG9tIiwicmVwJDUiLCJyZXAkNiIsInQxIiwidDIiLCJ0MSQwIiwidDIkMCIsInIxIiwicjIkMCIsInIxJDAiLCJyMiQxIiwieCQwIiwicjEkMSIsInIyJDIiLCJ4JDEiLCJyMSQyIiwicjIkMyIsIngkMiIsInIxJDMiLCJyMiQ0IiwieCQzIiwicm5nMSIsImRvbTEiLCJybmcyIiwiZG9tMiIsInQxJDEiLCJ0MiQyIiwiYjIiLCJhMiIsImIxIiwiYTEiLCJjMiIsImIyJDAiLCJhMiQwIiwiYzEiLCJiMSQwIiwiYTEkMCIsImQyIiwiYzIkMCIsImIyJDEiLCJhMiQxIiwiZDEiLCJjMSQwIiwiYjEkMSIsImExJDEiLCJlMiIsImQyJDAiLCJjMiQxIiwiYjIkMiIsImEyJDIiLCJlMSIsImQxJDAiLCJjMSQxIiwiYjEkMiIsImExJDIiLCJyMSQ0IiwicjIkNSIsInIxJDUiLCJyMiQ2IiwibmFtZTEiLCJyMiQ3IiwibmFtZTIiLCJyMSQ3IiwieCQ0IiwidDEkMyIsInQyJDMiLCJ0MiQ0IiwicjEkNiIsInQxJDIiLCJyMiIsInQyJDEiLCJwcm9vZiIsImhlYWQiLCJ0JDAiLCJ0JDEiLCJ0eXBlcmVwX29mX2ludCIsInR5cGVyZXBfb2ZfaW50MzIiLCJ0eXBlcmVwX29mX2ludDY0IiwidHlwZXJlcF9vZl9uYXRpdmVpbnQiLCJ0eXBlcmVwX29mX2NoYXIiLCJ0eXBlcmVwX29mX2Zsb2F0IiwidHlwZXJlcF9vZl9zdHJpbmciLCJ0eXBlcmVwX29mX2J5dGVzIiwidHlwZXJlcF9vZl9ib29sIiwidHlwZXJlcF9vZl91bml0IiwidHlwZXJlcF9vZl9vcHRpb24iLCJ0eXBlcmVwX29mX2xpc3QiLCJ0eXBlcmVwX29mX2FycmF5IiwidHlwZXJlcF9vZl9sYXp5X3QiLCJ0eXBlcmVwX29mX3JlZiIsInR5cGVyZXBfb2ZfZnVuY3Rpb24iLCJ0eXBlcmVwX29mX3R1cGxlMCIsInR5cGVyZXBfb2ZfdHVwbGUyIiwidHlwZXJlcF9vZl90dXBsZTMiLCJ0eXBlcmVwX29mX3R1cGxlNCIsInR5cGVyZXBfb2ZfdHVwbGU1IiwidmFsdWVfdHVwbGUwIiwidHlwZW5hbWVfb2ZfaW50NjMiLCJ0eXBlcmVwX29mX2ludDYzIiwicmVwcl9vZl9wb2x5X3ZhcmlhbnQiLCJ2YXJpYW50Iiwic2l6ZSIsInJlcHIiLCJoYXNoX3ZhcmlhbnQiLCJzIiwiYWNjdSIsImkiLCJkb3VibGVfYXJyYXlfdmFsdWUiLCJkb3VibGUkMCIsInNpbXBsZSIsIm1hcF92YXJpYW50IiwibWFwIiwidHlwZW5hbWUiLCJwb2x5bW9ycGhpYyIsInRhZyQwIiwiZmN0IiwiayIsInRhZ3MiLCJhdGFnIiwiYnRhZyIsIm1hcF9yZWNvcmQiLCJyZWNvcmQiLCJmaWVsZCQwIiwiZmllbGRzIiwiZ2V0JDAiLCJhZmllbGQiLCJiZmllbGQiLCJyZXF1aXJlZCIsInRhYmxlJDAiLCJjaGVja19kZXBlbmRlbmNpZXMiLCJpbXBsZW1lbnRzJDAiLCJtZXNzYWdlIiwicmVwbGFjZSQwIiwibWVtJDAiLCJ0YWJsZTAiLCJ0YWJsZTEiLCJ0YWJsZTIiLCJ0YWJsZTMiLCJ0YWJsZTQiLCJ0YWJsZTUiLCJpc19yZWdpc3RlcmVkIiwiaWRlbnQiLCJ1bml0IiwicmVnaXN0ZXIwIiwiY29tcHV0ZSIsInJlZ2lzdGVyMSIsInJlZ2lzdGVyMiIsInJlZ2lzdGVyMyIsInJlZ2lzdGVyNCIsInJlZ2lzdGVyNSIsInJlZ2lzdGVyIiwidHlwZXJlcF9vZl9hIiwib2ZfdHlwZXJlcCIsImNvbnRleHQiLCJtZW1vX3RhYmxlIiwicmVwJDExIiwicmVwJDEyIiwicmVwJDEzIiwicmVwJDE0IiwicmVwJDE1IiwidHVwbGUiLCJyYSIsInJiIiwicmEkMCIsInJiJDAiLCJyYyIsInJhJDEiLCJyYiQxIiwicmMkMCIsInJkIiwicmEkMiIsInJiJDIiLCJyYyQxIiwicmQkMCIsInJlIiwiY29udGVudCIsIm5hbWVkIiwic2hhcmVkIiwiY3VzdG9tIiwiY3VzdG9tJDAiLCJjdXN0b20kMSIsInJlcCQ3IiwiY3VzdG9tJDIiLCJjdXN0b20kMyIsInJlcCQ4IiwiY3VzdG9tJDQiLCJjdXN0b20kNSIsInJlcCQ5IiwidHlwZW5hbWVfb2ZfdCQyIiwiY3VzdG9tJDYiLCJjdXN0b20kNyIsInJlcCQxMCIsInR5cGVuYW1lX29mX3QkMyIsImN1c3RvbSQ4IiwiY3VzdG9tJDkiLCJjb21wdXRhdGlvbiIsInN0cmluZyIsImNvbnRlbnQkMCIsInNoYXJlZCQwIiwiY29tcHV0YXRpb24kMCIsInBhdGgiLCJyIiwiaW5wdXQiLCJnZXRfd2lwX2NvbXB1dGF0aW9uIiwiY2xvcyIsInNldF9maW5hbF9jb21wdXRhdGlvbiIsImNvbXBpbGV0aW1lX2RlcmVmZXJlbmNlIiwic2hhcmUiLCJvZl9wMSIsIm9mX3AyIiwib2ZfcDMiLCJvZl9wNCIsIm9mX3A1IiwidHlwZW5hbWVfb2ZfbmFtZWQiLCJ0eXBlcmVwX29mX3QiXSwic291cmNlcyI6WyIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi90eXBlcmVwL3R5cGVfZXF1YWwubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi90eXBlcmVwL3R5cGVuYW1lLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvdHlwZXJlcC92YXJpYW50X2FuZF9yZWNvcmRfaW50Zi5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3R5cGVyZXAvc3RkX2ludGVybmFsLm1sIiwiL2hvbWUvbGlhbS1jYXJwZW50ZXIvLm9wYW0vcGVyc29uYWwtc2l0ZS9saWIvdHlwZXJlcC90eXBlcmVwX29iai5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3R5cGVyZXAvdHlwZV9nZW5lcmljX2ludGYubWwiLCIvaG9tZS9saWFtLWNhcnBlbnRlci8ub3BhbS9wZXJzb25hbC1zaXRlL2xpYi90eXBlcmVwL3R5cGVfZ2VuZXJpYy5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3R5cGVyZXAvbWFrZV90eXBlbmFtZS5tbCIsIi9ob21lL2xpYW0tY2FycGVudGVyLy5vcGFtL3BlcnNvbmFsLXNpdGUvbGliL3R5cGVyZXAvdHlwZV9hYnN0cmFjdC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7O0U7Ozs7OzswQ0FHSUE7WUFDQUMsWUFBNENDLEdBQUssT0FBTEEsRUFBTTs2QkFNaERDLFlBQW9ELFNBQUMsRUFEM0QsV0FDTUE7b0NBTkZGLE1BREFEOzs7O0U7Ozs7Ozs7Ozs7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dkI0USxPQUZBM1E7Ozs7OztRQWhCRjs7U0FIRUE7U0FRTWdUO1NBRUFqVDtTQVJONFEsZ0JBTU1xQyxtQkFSTmhULGVBVU1EO21CQVJONFEsT0FGQTNROzs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7SUNBZTs7S0FBZmlUO0tBQ0FqVDtJQUpnRSxXQUdoRWlULGNBQ0FqVDs7OzthQU1BaVQsYUFBYU4sT0FBUSxlQUFlLGlCQUF2QkEsWUFBMkM7UUFDeEQzUztJQUp1RSxXQUd2RWlULGNBQ0FqVDs7OzthQU9BaVQsYUFBYU4sT0FBTUM7S0FBUSxlQUFlLGlCQUE3QkQsT0FBTUM7SUFBaUQ7UUFDcEU1UztJQUpOLFdBR01pVCxjQUNBalQ7Ozs7YUFPQWlULGFBQWFOLE9BQU1DLE9BQU1DO0tBQVEsZUFBZSxpQkFBbkNGLE9BQU1DLE9BQU1DO0lBQXVEO1FBQ2hGN1M7SUFKMEQsV0FHMURpVCxjQUNBalQ7Ozs7YUFPQWlULGFBQWFOLE9BQU1DLE9BQU1DLE9BQU1DO0tBQ2pDLGVBQWUsaUJBREFILE9BQU1DLE9BQU1DLE9BQU1DO0lBQ29CO1FBR25EOVM7SUFQa0UsV0FHbEVpVCxjQUlBalQ7Ozs7YUFPQWlULGFBQWFOLE9BQU1DLE9BQU1DLE9BQU1DLE9BQU1DO0tBQ3ZDLGVBQWUsaUJBREFKLE9BQU1DLE9BQU1DLE9BQU1DLE9BQU1DO0lBQ29CO1FBR3pEL1M7SUFQMEUsV0FHMUVpVCxjQUlBalQ7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJ0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBCYXNlLlR5cGVfZXF1YWwudCA9IFQgOiAoJ2EsICdhKSB0XG50eXBlICgnYSwgJ2IpIGVxdWFsID0gKCdhLCAnYikgdFxuXG5sZXQgcmVmbCA9IFRcbmxldCBjb252IDogdHlwZSBhIGIuIChhLCBiKSB0IC0+IGEgLT4gYiA9IGZ1biBUIHggLT4geFxuXG5tb2R1bGUgTGlmdCAoWCA6IHNpZ1xuICB0eXBlICdhIHRcbmVuZCkgPVxuc3RydWN0XG4gIGxldCBsaWZ0ICh0eXBlIGEgYikgKFQgOiAoYSwgYikgdCkgOiAoYSBYLnQsIGIgWC50KSB0ID0gVFxuZW5kXG4iLCIoKiB0aGlzIGxpYiBzaG91bGQgbm90IGRlcGVuZCBvbiBjb3JlICopXG5tb2R1bGUgTGlzdCA9IHN0cnVjdFxuICBpbmNsdWRlIExpc3RcblxuICBsZXQgY29tcGFyZSBjbXAgYSBiID1cbiAgICBsZXQgcmVjIGxvb3AgYSBiID1cbiAgICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgICAgfCBbXSwgW10gLT4gMFxuICAgICAgfCBbXSwgXyAtPiAtMVxuICAgICAgfCBfLCBbXSAtPiAxXG4gICAgICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICAgICAgbGV0IG4gPSBjbXAgeCB5IGluXG4gICAgICAgIGlmIG4gPSAwIHRoZW4gbG9vcCB4cyB5cyBlbHNlIG5cbiAgICBpblxuICAgIGxvb3AgYSBiXG4gIDs7XG5lbmRcblxubW9kdWxlIFVpZCA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIG5leHQgOiBzdHJpbmcgLT4gdFxuICB2YWwgaGFzaCA6IHQgLT4gaW50XG4gIHZhbCBuYW1lIDogdCAtPiBzdHJpbmdcbiAgdmFsIHN0YXRpYyA6IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgY29kZSA6IGludFxuICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgIH1cblxuICBsZXQgY29tcGFyZSBhIGIgPSBjb21wYXJlIChhLmNvZGUgOiBpbnQpIGIuY29kZVxuICBsZXQgZXF1YWwgYSBiID0gKGEuY29kZSA6IGludCkgPSBiLmNvZGVcbiAgbGV0IHVpZCA9IHJlZiAwXG5cbiAgbGV0IG5leHQgbmFtZSA9XG4gICAgbGV0IGNvZGUgPSAhdWlkIGluXG4gICAgaW5jciB1aWQ7XG4gICAgeyBjb2RlOyBuYW1lIH1cbiAgOztcblxuICBsZXQgaGFzaCBhID0gSGFzaHRibC5oYXNoIGEuY29kZVxuICBsZXQgbmFtZSBhID0gYS5uYW1lXG4gIGxldCBzdGF0aWMgPSBuZXh0IFwic3RhdGljXCJcbmVuZFxuXG5tb2R1bGUgS2V5ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyB1aWQgOiBVaWQudFxuICAgIDsgcGFyYW1zIDogdCBsaXN0XG4gICAgfVxuXG4gIGxldCByZWMgY29tcGFyZSBrMSBrMiA9XG4gICAgaWYgazEgPT0gazJcbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIGxldCBjbXAgPSBVaWQuY29tcGFyZSBrMS51aWQgazIudWlkIGluXG4gICAgICBpZiBjbXAgPD4gMCB0aGVuIGNtcCBlbHNlIExpc3QuY29tcGFyZSBjb21wYXJlIGsxLnBhcmFtcyBrMi5wYXJhbXMpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuICBsZXQgaGFzaCA9IChIYXNodGJsLmhhc2ggOiB0IC0+IGludClcbiAgbGV0IHN0YXRpYyA9IHsgdWlkID0gVWlkLnN0YXRpYzsgcGFyYW1zID0gW10gfVxuZW5kXG5cbnR5cGUgJ2EgdCA9IEtleS50XG50eXBlICdhIHR5cGVuYW1lID0gJ2EgdFxuXG5sZXQga2V5IHQgPSB0XG5sZXQgdWlkIHQgPSB0LktleS51aWRcbmxldCBuYW1lIHQgPSBVaWQubmFtZSB0LktleS51aWRcbmxldCBzdGF0aWMgPSBLZXkuc3RhdGljXG5sZXQgY3JlYXRlID8obmFtZSA9IFwiVHlwZW5hbWUuY3JlYXRlXCIpICgpID0geyBLZXkudWlkID0gVWlkLm5leHQgbmFtZTsgcGFyYW1zID0gW10gfVxuXG5pbmNsdWRlIHN0cnVjdFxuICAoKiBUaGUgYXJndW1lbnQgZm9yIE9iai5tYWdpYyBoZXJlIGlzIHRoZSBzYW1lIGFzIHRoZSBvbmUgaW4gY29yZS90eXBlX2VxdWFsICopXG5cbiAgbGV0IHNhbWUgKHR5cGUgYSBiKSAobm0xIDogYSB0KSAobm0yIDogYiB0KSA9IEtleS5jb21wYXJlIG5tMSBubTIgPSAwXG5cbiAgbGV0IHNhbWVfd2l0bmVzcyAodHlwZSBhIGIpIChubTEgOiBhIHQpIChubTIgOiBiIHQpID1cbiAgICBpZiBLZXkuY29tcGFyZSBubTEgbm0yID0gMFxuICAgIHRoZW4gU29tZSAoT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCA6IChhLCBiKSBUeXBlX2VxdWFsLnQpXG4gICAgZWxzZSBOb25lXG4gIDs7XG5cbiAgbGV0IHNhbWVfd2l0bmVzc19leG4gKHR5cGUgYSBiKSAobm0xIDogYSB0KSAobm0yIDogYiB0KSA9XG4gICAgaWYgS2V5LmNvbXBhcmUgbm0xIG5tMiA9IDBcbiAgICB0aGVuIChPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIDogKGEsIGIpIFR5cGVfZXF1YWwudClcbiAgICBlbHNlIGZhaWx3aXRoIFwiVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4blwiXG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgUzAgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0eXBlbmFtZSAtPiAnYSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0eXBlbmFtZSAtPiAnYiB0eXBlbmFtZSAtPiAoJ2EsICdiKSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdHlwZW5hbWUgLT4gJ2IgdHlwZW5hbWUgLT4gJ2MgdHlwZW5hbWUgLT4gKCdhLCAnYiwgJ2MpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTNCA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90XG4gICAgOiAgJ2EgdHlwZW5hbWVcbiAgICAtPiAnYiB0eXBlbmFtZVxuICAgIC0+ICdjIHR5cGVuYW1lXG4gICAgLT4gJ2QgdHlwZW5hbWVcbiAgICAtPiAoJ2EsICdiLCAnYywgJ2QpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdFxuICAgIDogICdhIHR5cGVuYW1lXG4gICAgLT4gJ2IgdHlwZW5hbWVcbiAgICAtPiAnYyB0eXBlbmFtZVxuICAgIC0+ICdkIHR5cGVuYW1lXG4gICAgLT4gJ2UgdHlwZW5hbWVcbiAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIE1ha2UwIChYIDogTmFtZWRfaW50Zi5TMCkgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHsgS2V5LnVpZDsgcGFyYW1zID0gW10gfVxuZW5kXG5cbm1vZHVsZSBNYWtlMSAoWCA6IE5hbWVkX2ludGYuUzEpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlMiAoWCA6IE5hbWVkX2ludGYuUzIpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGIgXSB9XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogTmFtZWRfaW50Zi5TMykgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhIGIgYyA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhOyBiOyBjIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlNCAoWCA6IE5hbWVkX2ludGYuUzQpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiIGMgZCA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhOyBiOyBjOyBkIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlNSAoWCA6IE5hbWVkX2ludGYuUzUpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiIGMgZCBlID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGI7IGM7IGQ7IGUgXSB9XG5lbmRcblxubW9kdWxlIEtleV90YWJsZSA9IEhhc2h0YmwuTWFrZSAoS2V5KVxuXG5tb2R1bGUgVGFibGUgKFggOiBzaWdcbiAgdHlwZSAnYSB0XG5lbmQpID1cbnN0cnVjdFxuICB0eXBlIGRhdGEgPSBEYXRhIDogJ2EgdCAqICdhIFgudCAtPiBkYXRhXG4gIHR5cGUgdCA9IGRhdGEgS2V5X3RhYmxlLnRcblxuICBsZXQgY3JlYXRlIGludCA9IEtleV90YWJsZS5jcmVhdGUgaW50XG4gIGxldCBtZW0gdGFibGUgbmFtZSA9IEtleV90YWJsZS5tZW0gdGFibGUgKGtleSBuYW1lKVxuICBsZXQgc2V0IHRhYmxlIG5hbWUgZGF0YSA9IEtleV90YWJsZS5yZXBsYWNlIHRhYmxlIChrZXkgbmFtZSkgKERhdGEgKG5hbWUsIGRhdGEpKVxuXG4gIGxldCBmaW5kICh0eXBlIGEpIHRhYmxlIChuYW1lIDogYSB0eXBlbmFtZSkgPVxuICAgIGxldCBkYXRhID1cbiAgICAgIHRyeSBTb21lIChLZXlfdGFibGUuZmluZCB0YWJsZSAoa2V5IG5hbWUpKSB3aXRoXG4gICAgICB8IEJhc2UuTm90X2ZvdW5kX3MgXyB8IFN0ZGxpYi5Ob3RfZm91bmQgLT4gTm9uZVxuICAgIGluXG4gICAgbWF0Y2ggZGF0YSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgKERhdGEgKG5hbWUnLCBkYXRhKSkgLT5cbiAgICAgIChmdW4gKHR5cGUgYikgKG5hbWUnIDogYiB0eXBlbmFtZSkgKGRhdGEgOiBiIFgudCkgLT5cbiAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IChzYW1lX3dpdG5lc3NfZXhuIG5hbWUnIG5hbWUgOiAoYiwgYSkgVHlwZV9lcXVhbC50KSBpblxuICAgICAgICBTb21lIChkYXRhIDogYSBYLnQpKVxuICAgICAgICBuYW1lJ1xuICAgICAgICBkYXRhXG4gIDs7XG5lbmRcblxubGV0IGZhaWwgdWlkX2EgdWlkX2IgPVxuICBsZXQgbXNnID1cbiAgICBQcmludGYuc3ByaW50ZiBcIlR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG4gJVMgJVNcIiAoVWlkLm5hbWUgdWlkX2EpIChVaWQubmFtZSB1aWRfYilcbiAgaW5cbiAgZmFpbHdpdGggbXNnXG47O1xuXG5tb2R1bGUgU2FtZV93aXRuZXNzX2V4bl8xIChBIDogUzEpIChCIDogUzEpID0gc3RydWN0XG4gIHR5cGUgdCA9IHsgZXEgOiAnYS4gKCdhIEEudCwgJ2EgQi50KSBUeXBlX2VxdWFsLnQgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljKSBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgPSBPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fMiAoQSA6IFMyKSAoQiA6IFMyKSA9IHN0cnVjdFxuICB0eXBlIHQgPSB7IGVxIDogJ2EgJ2IuICgoJ2EsICdiKSBBLnQsICgnYSwgJ2IpIEIudCkgVHlwZV9lcXVhbC50IH1cblxuICBsZXQgd2l0bmVzcyA9XG4gICAgbGV0IHVpZF9hID0gdWlkIChBLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljKSBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgPSBPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fMyAoQSA6IFMzKSAoQiA6IFMzKSA9IHN0cnVjdFxuICB0eXBlIHQgPSB7IGVxIDogJ2EgJ2IgJ2MuICgoJ2EsICdiLCAnYykgQS50LCAoJ2EsICdiLCAnYykgQi50KSBUeXBlX2VxdWFsLnQgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBTYW1lX3dpdG5lc3NfZXhuXzQgKEEgOiBTNCkgKEIgOiBTNCkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0geyBlcSA6ICdhICdiICdjICdkLiAoKCdhLCAnYiwgJ2MsICdkKSBBLnQsICgnYSwgJ2IsICdjLCAnZCkgQi50KSBUeXBlX2VxdWFsLnQgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgPSBPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fNSAoQSA6IFM1KSAoQiA6IFM1KSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgZXEgOlxuICAgICAgICAnYSAnYiAnYyAnZCAnZS4gKCgnYSwgJ2IsICdjLCAnZCwgJ2UpIEEudCwgKCdhLCAnYiwgJ2MsICdkLCAnZSkgQi50KSBUeXBlX2VxdWFsLnRcbiAgICB9XG5cbiAgbGV0IHdpdG5lc3MgPVxuICAgIGxldCB1aWRfYSA9IHVpZCAoQS50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG4iLCIoKipcbiAgIFBsYWNlIGhvbGRlciBmb3IgY29tbW9uIFZhcmlhbnRzIGFuZCBGaWVsZHMgaW50ZXJmYWNlXG4qKVxuXG5tb2R1bGUgTSAoWCA6IHNpZ1xuICAoKipcbiAgICAgICBUaGlzIGZ1bmN0b3IgaXMgZXNzZW50aWFsbHkgdGhlcmUgYmVjYXVzZSB3ZSB1c2UgdGhpcyBzYW1lIGludGVyZmFjZSBpbiBkaWZmZXJlbnRcbiAgICAgICBjb250ZXh0cywgd2l0aCBkaWZmZXJlbnQgdHlwZXMgZm9yIFsnYSB0XS5cblxuICAgICAgIDEpIE9uZSB1c2UgY2FzZSBmb3IgaXQgaXMgd2hlcmUgWydhIFgudCA9ICdhIFR5cGVyZXAudF0uICBUaGVzZSBpbnRlcmZhY2VzIGFyZSB0aGVuXG4gICAgICAgcGFydCBvZiB0aGUgdHlwZSB3aXRuZXNzIGJ1aWx0IGZvciBhIHR5cGUgY29udGFpbmluZyBhIHJlY29yZCBvciBhIHZhcmlhbnQgaW4gaXRzXG4gICAgICAgc3RydWN0dXJlLiBbdHJhdmVyc2VdIHdpbGwgZ2l2ZSBhIHdheSBvZiBhY2Nlc3NpbmcgdGhlIHR5cGUgcmVwcmVzZW50YXRpb24gZm9yIHRoZVxuICAgICAgIGFyZ3VtZW50cyBvZiBhIHZhcmlhbnQgb3IgcmVjb3JkIHR5cGUuXG5cbiAgICAgICAyKSBBbm90aGVyIHVzZSBjYXNlIGlzIGZvciBidWlsZGluZyBcInN0YWdlZCBnZW5lcmljIGNvbXB1dGF0aW9uc1wiLiBJbiB0aGF0IGNhc2UsIHRoZVxuICAgICAgIHR5cGUgWydhIFgudF0gaXMgdGhlIHR5cGUgb2YgdGhlIGNvbXB1dGF0aW9uIHRoYXQgaXMgYmVpbmcgYnVpbHQuICBbdHJhdmVyc2VdXG4gICAgICAgcmV0dXJucyB0aGUgY29tcHV0YXRpb24gYnVpbHQgZm9yIHRoZSBhcmd1bWVudC4gVGhlIGludGVyZmFjZSBubyBsb25nZXIgZXhwb3J0c1xuICAgICAgIHRoZSB0eXBlcmVwIG9mIHRoZSBhcmd1bWVudHMgaW4gaG9wZXMgb2YgZW5mb3JjaW5nIHRoYXQgbm8gdHlwZXJlcCB0cmF2ZXJzYWxcbiAgICAgICBoYXBwZW5zIGF0IHJ1bnRpbWUgaWYgdGhlIGNvbXB1dGF0aW9uIGhhcHBlbiB0byBiZSBhIGZ1bmN0aW9uLlxuICAgICopXG4gIHR5cGUgJ2EgdFxuZW5kKSA9XG5zdHJ1Y3RcbiAgKCogVGhlIGZ1bmN0aW9ucyBwcmVmaXhlZCBieSBbaW50ZXJuYWxdIGFzIHdlbGwgYXMgdGhlIG1vZHVsZSBzdWZmaXhlZCBieSBbX2ludGVybmFsXVxuICAgICBhcmUgdXNlZCBieSB0aGUgY29kZSBnZW5lcmF0ZWQgYnkgdGhlIGNhbWxwNCBleHRlbnNpb24gW3dpdGggdHlwZXJlcF0gYXMgd2VsbCBhcyBzb21lXG4gICAgIGludGVybmFscyBvZiB0aGUgdHlwZXJlcCBsaWJyYXJ5LiBEbyBub3QgY29uc2lkZXIgdXNpbmcgdGhlc2Ugc29tZXdoZXJlIGVsc2UuICBUaGV5XG4gICAgIHNob3VsZCBpZGVhbGx5IG5vdCBiZSBleHBvcnRlZCBvdXRzaWRlIHRoZSB0eXBlcmVwIGxpYnJhcnksIGJ1dCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgbmVlZHMgc29tZWhvdyB0byBhY2Nlc3MgdGhpcywgZXZlbiBvdXRzaWRlLiAqKVxuXG4gIG1vZHVsZSBUYWdfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlICgndmFyaWFudCwgJ2FyZ3MpIGNyZWF0ZSA9XG4gICAgICB8IEFyZ3Mgb2YgKCdhcmdzIC0+ICd2YXJpYW50KVxuICAgICAgfCBDb25zdCBvZiAndmFyaWFudFxuXG4gICAgdHlwZSAoJ3ZhcmlhbnQsICdhcmdzKSB0ID1cbiAgICAgIHsgbGFiZWwgOiBzdHJpbmdcbiAgICAgIDsgcmVwIDogJ2FyZ3MgWC50XG4gICAgICA7IGFyaXR5IDogaW50XG4gICAgICA7IGFyZ3NfbGFiZWxzIDogc3RyaW5nIGxpc3RcbiAgICAgIDsgaW5kZXggOiBpbnRcbiAgICAgIDsgb2NhbWxfcmVwciA6IGludFxuICAgICAgOyB0eWlkIDogJ2FyZ3MgVHlwZW5hbWUudFxuICAgICAgOyBjcmVhdGUgOiAoJ3ZhcmlhbnQsICdhcmdzKSBjcmVhdGVcbiAgICAgIH1cbiAgZW5kXG5cbiAgKCoqXG4gICAgIFdpdG5lc3Mgb2YgYSB0YWcsIHRoYXQgaXMgYW4gaXRlbSBpbiBhIHZhcmlhbnQgdHlwZSwgYWxzbyBjYWxsZWQgYW4gXCJhcHBsaWVkXG4gICAgIHZhcmlhbnQgQ29uc3RydWN0b3JcIlxuXG4gICAgIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHZhcmlhbnQgdHlwZSwgdGhlIHNlY29uZCBpcyB0aGUgdHlwZSBvZiB0aGUgdGFnXG4gICAgIHBhcmFtZXRlcnMuICBFeGFtcGxlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID1cbiAgICAgICAgIHwgQSBvZiAoaW50ICogc3RyaW5nKVxuICAgICAgICAgfCBCIG9mIHN0cmluZ1xuICAgICAgICAgfCBDIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgIF19XG5cbiAgICAgdGhpcyB0eXBlIGhhcyB0aHJlZSBjb25zdHJ1Y3RvcnMuIEZvciBlYWNoIG9mIHRoZW0gd2UnbGwgaGF2ZSBhIGNvcnJlc3BvbmRpbmdcbiAgICAgW1RhZy50XTpcblxuICAgICB7W1xuICAgICAgIHZhbCB0YWdfQSA6ICh0LCAoaW50ICogc3RyaW5nKSkgVGFnLnRcbiAgICAgICB2YWwgdGFnX0IgOiAodCwgc3RyaW5nICAgICAgICApIFRhZy50XG4gICAgICAgdmFsIHRhZ19DIDogKHQsIChpbnQgKiBzdHJpbmcpKSBUYWcudFxuICAgICBdfVxuXG4gICAgIE5vdGUsIGlubGluZSByZWNvcmQgaW4gdmFyaWFudCBhcmUgdHlwZWQgYXMgaWYgdGhlaXIgZGVmaW5pdGlvbiB3YXMgdXNpbmcgdHVwbGVzLFxuICAgICB3aXRob3V0IHRoZSBwYXJlbnRoZXNpcy4gIFRoaXMgaXMgY29uc2lzdGVudCB3aXRoIHRoZWlyIHJ1bnRpbWUgcmVwcmVzZW50YXRpb24uICBCdXRcbiAgICAgdGhlIGRpc3RpbmN0aW9uIGlzIGNhcnJpZWQgYW5kIGF2YWlsYWJsZSBmb3IgaW50cm9zcGVjdGlvbiBhcyBwYXJ0IG9mIHRoZSBbVGFnLnRdLlxuICAgICBTZWUgW2FyZ3NfbGFiZWxzXS4gKilcbiAgbW9kdWxlIFRhZyA6IHNpZ1xuICAgIHR5cGUgKCd2YXJpYW50LCAnYXJncykgY3JlYXRlID1cbiAgICAgIHwgQXJncyBvZiAoJ2FyZ3MgLT4gJ3ZhcmlhbnQpXG4gICAgICB8IENvbnN0IG9mICd2YXJpYW50XG5cbiAgICB0eXBlICgndmFyaWFudCwgJ2FyZ3MpIHRcblxuICAgICgqKlxuICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjb25zdHJ1Y3RvciBhcyBpdCBpcyBnaXZlbiBpbiB0aGUgY29uY3JldGUgc3ludGF4XG4gICAgICAgRXhhbXBsZXM6XG5cbiAgICAgICB7dlxuICAgICAgICAgQ29uc3RydWN0b3IgICAgICAgIHwgbGFiZWxcbiAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgIHwgQSBvZiBpbnQgICAgICAgICB8ICBcIkFcIlxuICAgICAgICAgfCBgYSBvZiBpbnQgICAgICAgIHwgIFwiYVwiXG4gICAgICAgICB8IGBBIG9mIGludCAgICAgICAgfCAgXCJBXCJcbiAgICAgICAgIHwgQSBvZiB7IHggOiBpbnQgfSB8ICBcIkFcIlxuICAgICAgIHZ9XG5cbiAgICAgICBmb3Igc3RhbmRhcmQgdmFyaWFudCwgdGhlIG9jYW1sIHN5bnRheCBpbXBsaWVzIHRoYXQgdGhpcyBsYWJlbCB3aWxsIGFsd2F5cyBzdGFydHNcbiAgICAgICB3aXRoIGEgY2FwaXRhbCBsZXR0ZXIuIEZvciBwb2x5bW9ycGhpYyB2YXJpYW50cywgdGhpcyBtaWdodCBiZSBhIGxvd2VyY2FzZSBjaGFyLlxuICAgICAgIEZvciBwb2x5bW9ycGhpYyB2YXJpYW50LCB0aGlzIGxhYmVsIGRvZXMgbm90IGluY2x1ZGUgdGhlIFtgXSBjaGFyYWN0ZXIuXG4gICAgKilcbiAgICB2YWwgbGFiZWwgOiAoXywgXykgdCAtPiBzdHJpbmdcblxuICAgICgqKlxuICAgICAgIFRoZSBzaXplIG9mIHRoZSBvY2FtbCBoZWFwIGJsb2NrIGNvbnRhaW5pbmcgdGhlIGFyZ3VtZW50c1xuXG4gICAgICAgRXhhbXBsZXM6XG4gICAgICAge3ZcbiAgICAgICAgICAwOiB8IEEgfCAnQVxuICAgICAgICAgIDE6IHwgQSBvZiBpbnQgfCBgQSBvZiBpbnQgfCBBIG9mIChpbnQgKiBpbnQpIHwgYEEgb2YgKGludCAqIGludClcbiAgICAgICAgICAgICB8IGBBIG9mIGludCAqIGludFxuICAgICAgICAgICAgIHwgQSBvZiB7IHggOiBpbnR9XG4gICAgICAgICAgMjogfCBBIG9mIGludCAqIGZsb2F0XG4gICAgICAgICAgICAgfCBBIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgICAgICAgZXRjLlxuICAgICAgIHZ9XG4gICAgKilcbiAgICB2YWwgYXJpdHkgOiAoXywgXykgdCAtPiBpbnRcblxuICAgICgqKiBUaGUgbGFiZWwgb2YgdGhlIGZpZWxkcyBmb3IgaW5saW5lIHJlY29yZHMuICBGb3Igb3RoZXIgZm9ybXMgb2YgdGFncywgdGhpcyBpcyB0aGVcbiAgICAgICAgZW1wdHkgbGlzdC4gIFdoZW4gdGhpcyByZXR1cm5zIGEgbm9uIGVtcHR5IGxpc3QsIHRoZSBsZW5ndGggb2YgdGhlIHJldHVybmVkIGxpc3RcbiAgICAgICAgaXMgZXF1YWwgdG8gdGhlIGFyaXR5LlxuXG4gICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAge3ZcbiAgICAgICAgICgxKSBFbXB0eTpcblxuICAgICAgICAgICB8IEEgfCAnQVxuICAgICAgICAgICB8IEEgb2YgaW50IHwgYEEgb2YgaW50IHwgQSBvZiAoaW50ICogaW50KSB8IGBBIG9mIChpbnQgKiBpbnQpXG4gICAgICAgICAgIHwgYEEgb2YgaW50ICogaW50XG4gICAgICAgICAgIHwgQSBvZiBpbnQgKiBmbG9hdFxuXG4gICAgICAgICAoMikgTm9uIGVtcHR5OlxuXG4gICAgICAgICAgIHwgQSBvZiB7IHggOiBpbnQgfSAgICAgICAgICAgICAgIC0+IFsgXCJ4XCIgXVxuICAgICAgICAgICB8IEEgb2YgeyB4IDogaW50OyB5IDogc3RyaW5nIH0gICAtPiBbIFwieFwiIDsgXCJ5XCIgXVxuICAgICAgIHZ9XG4gICAgKilcbiAgICB2YWwgYXJnc19sYWJlbHMgOiAoXywgXykgdCAtPiBzdHJpbmcgbGlzdFxuXG4gICAgKCoqXG4gICAgICAgVGhlIGluZGV4IG9mIHRoZSBjb25zdHJ1Y3RvciBpbiB0aGUgbGlzdCBvZiBhbGwgdGhlIHZhcmlhbnQgdHlwZSdzIGNvbnN0cnVjdG9yc1xuICAgICAgIEV4YW1wbGVzOlxuICAgICAgIHtbXG4gICAgICAgICB0eXBlIHQgPVxuICAgICAgICAgICB8IEEgb2YgaW50ICAgICAgICAgICgqIDAgKilcbiAgICAgICAgICAgfCBCICAgICAgICAgICAgICAgICAoKiAxICopXG4gICAgICAgICAgIHwgQyBvZiBpbnQgICAgICAgICAgKCogMiAqKVxuICAgICAgICAgICB8IEQgb2YgY2hhciAgICAgICAgICgqIDMgKilcbiAgICAgICAgICAgfCBFIG9mIHsgeCA6IGludCB9ICAoKiA0ICopXG4gICAgICAgXX1cbiAgICAqKVxuICAgIHZhbCBpbmRleCA6IChfLCBfKSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgb2NhbWxfcmVwciBpcyByZWxhdGVkIHRvIHRoZSBydW50aW1lIG9mIG9iamVjdHMuIHRoaXMgaXMgZXNzZW50aWFsbHkgYSB3YXkgb2ZcbiAgICAgICBnaXZpbmcgb25lIHRoZSBhYmlsaXR5IHRvIHJlYnVpbGQgZHluYW1pY2FsbHkgYW4gW09iai50XSByZXByZXNlbnRpbmcgYSB0YWcuXG5cbiAgICAgICBQb2x5bW9ycGhpYyB2YXJpYW50czpcbiAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgIFtvY2FtbF9yZXByXSBpcyB0aGUgaGFzaCBvZiB0aGUgbGFiZWwsIGFzIGRvbmUgYnkgdGhlIGNvbXBpbGVyLlxuICAgICAgIEV4YW1wbGU6XG4gICAgICAgcHJpbnRfaW50IChPYmoubWFnaWMgYGJhcikgICgqIDQ4OTUxODcgKilcbiAgICAgICBwcmludF9pbnQgKE9iai5tYWdpYyAnZm9vKSAgKCogNTA5NzIyMiAqKVxuXG4gICAgICAgU3RhbmRhcmRzIHZhcmlhbnRzOlxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgIFtvY2FtbF9yZXByXSBpcyB0aGUgdGFnIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNvbnN0cnVjdG9yIHdpdGhpbiB0aGUgdHlwZS5cbiAgICAgICB0aGUgd2F5IGl0IHdvcmtzIGluIHRoZSBvY2FtbCBydW50aW1lIGlzIGJ5IHBhcnRpdGlvbmluZyB0aGUgY29uc3RydWN0b3JzIHJlZ2FyZGluZ1xuICAgICAgIGlmIHRoZXkgaGF2ZSBzb21lIGFyZ3VtZW50cyBvciBub3QsIHByZXNlcnZpbmcgdGhlIG9yZGVyLCB0aGVuIGFzc2lnbiBpbmNyZWFzaW5nXG4gICAgICAgaW5kZXggd2l0aGluZyBlYWNoIHBhcnRpdGlvbi5cbiAgICAgICBFeGFtcGxlOlxuXG4gICAgICAge1tcbiAgICAgICAgIHR5cGUgdCA9ICAgICAgICAgICAgICAgICAgKCogbm8gYXJnICopICAoKiBhcmdzICopXG4gICAgICAgICAgIHwgQSAgICAgICAgICAgICAgICAgICAgICAgKCogMCAqKVxuICAgICAgICAgICB8IEIgb2YgaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogMCAqKVxuICAgICAgICAgICB8IEMgICAgICAgICAgICAgICAgICAgICAgICgqIDEgKilcbiAgICAgICAgICAgfCBEIG9mIChmbG9hdCAqIHN0cmluZykgICAgICAgICAgICAgICAgICgqIDEgKilcbiAgICAgICAgICAgfCBFICAgICAgICAgICAgICAgICAgICAgICAoKiAyICopXG4gICAgICAgICAgIHwgRiAgICAgICAgICAgICAgICAgICAgICAgKCogMyAqKVxuICAgICAgICAgICB8IEcgb2Ygc3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogMiAqKVxuICAgICAgICAgICB8IEggb2YgeyB4IDogaW50IH0gICAgICAgICAgICAgICAgICAgICAgKCogMyAqKVxuICAgICAgIF19XG4gICAgKilcbiAgICB2YWwgb2NhbWxfcmVwciA6IChfLCBfKSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgR2l2ZSBiYWNrIGEgd2F5IG9mIGNvbnN0cnVjdGluZyBhIHZhbHVlIG9mIHRoYXQgY29uc3RydWN0b3IgZnJvbSBpdHMgYXJndW1lbnRzLlxuXG4gICAgICAgRXhhbXBsZXM6XG5cbiAgICAgICB7W1xuICAgICAgICAgdHlwZSB0ID1cbiAgICAgICAgICAgfCBBIG9mIChpbnQgKiBzdHJpbmcpXG4gICAgICAgICAgIHwgQiBvZiBpbnQgKiBmbG9hdFxuICAgICAgICAgICB8IENcbiAgICAgICAgICAgfCBEIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgICAgXX1cblxuICAgICAgIFtjcmVhdGVdIHdpbGwgcmV0dXJuIHNvbWV0aGluZyBlcXVpdmFsZW50IHRvOlxuICAgICAgIHRhZ19BIDogW0FyZ3MgKGZ1biAoZCA6IChpbnQgKiBzdHJpbmcpIC0+IEEgZCldXG4gICAgICAgdGFnX0IgOiBbQXJncyAoZnVuIChpLCBmKSAtPiBCIChpLCBmKSldXG4gICAgICAgdGFnX0MgOiBbQ29uc3QgQ11cbiAgICAgICB0YWdfRCA6IFtBcmdzIChmdW4gKHgsIHkpIC0+IEQgeyB4OyB5IH0pXVxuICAgICopXG4gICAgdmFsIGNyZWF0ZSA6ICgndmFyaWFudCwgJ2FyZ3MpIHQgLT4gKCd2YXJpYW50LCAnYXJncykgY3JlYXRlXG5cbiAgICAoKiogcmV0dXJuIHRoZSB0eXBlX25hbWUgb2YgdGhlIGFyZ3VtZW50cy4gbWlnaHQgYmUgdXNlZCB0byBwZXJmb3JtIHNvbWUgbG9va3VwIGJhc2VkXG4gICAgICAgIG9uIGl0IHdoaWxlIGJ1aWxkaW5nIGEgY29tcHV0YXRpb24gZm9yIGV4YW1wbGUgKilcbiAgICB2YWwgdHlpZCA6IChfLCAnYXJncykgdCAtPiAnYXJncyBUeXBlbmFtZS50XG5cbiAgICAoKiogZ2V0IHRoZSByZXByZXNlbnRhdGlvbi9jb21wdXRhdGlvbiBvZiB0aGUgYXJndW1lbnRzICopXG4gICAgdmFsIHRyYXZlcnNlIDogKF8sICdhcmdzKSB0IC0+ICdhcmdzIFgudFxuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogKCdhLCAnYikgVGFnX2ludGVybmFsLnQgLT4gKCdhLCAnYikgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRhZ19pbnRlcm5hbFxuXG4gICAgbGV0IGxhYmVsIHQgPSB0LmxhYmVsXG4gICAgbGV0IGFyaXR5IHQgPSB0LmFyaXR5XG4gICAgbGV0IGFyZ3NfbGFiZWxzIHQgPSB0LmFyZ3NfbGFiZWxzXG4gICAgbGV0IGluZGV4IHQgPSB0LmluZGV4XG4gICAgbGV0IG9jYW1sX3JlcHIgdCA9IHQub2NhbWxfcmVwclxuICAgIGxldCBjcmVhdGUgdCA9IHQuY3JlYXRlXG4gICAgbGV0IHR5aWQgdCA9IHQudHlpZFxuICAgIGxldCB0cmF2ZXJzZSB0ID0gdC5yZXBcbiAgICBsZXQgaW50ZXJuYWxfdXNlX29ubHkgdCA9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIFZhcmlhbnRfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlIF8gdGFnID0gVGFnIDogKCd2YXJpYW50LCAnYSkgVGFnLnQgLT4gJ3ZhcmlhbnQgdGFnXG4gICAgdHlwZSBfIHZhbHVlID0gVmFsdWUgOiAoJ3ZhcmlhbnQsICdhKSBUYWcudCAqICdhIC0+ICd2YXJpYW50IHZhbHVlXG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyB0eXBlbmFtZSA6ICdhIFR5cGVuYW1lLnRcbiAgICAgIDsgdGFncyA6ICdhIHRhZyBhcnJheVxuICAgICAgOyBwb2x5bW9ycGhpYyA6IGJvb2xcbiAgICAgIDsgdmFsdWUgOiAnYSAtPiAnYSB2YWx1ZVxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgVmFyaWFudCA6IHNpZ1xuICAgICgqKlxuICAgICAgIEFuIGV4aXN0ZW50aWFsIHR5cGUgdXNlZCB0byBnYXRoZXIgYWxsIHRoZSB0YWdzIGNvbnN0aXR1aW5nIGEgdmFyaWFudFxuICAgICAgIHR5cGUuIHRoZSBbJ3ZhcmlhbnRdIHBhcmFtZXRlciBpcyB0aGUgdmFyaWFudCB0eXBlLCBpdCBpcyB0aGUgc2FtZSBmb3IgYWxsIHRoZVxuICAgICAgIGNvbnN0cnVjdG9ycyBvZiB0aGF0IHZhcmlhbnQgdHlwZS4gVGhlIHR5cGUgb2YgdGhlIHBhcmFtZXRlcnMgbWlnaHQgYmUgZGlmZmVyZW50XG4gICAgICAgZm9yIGVhY2ggY29uc3RydWN0b3IgYW5kIGlzIHRodXMgZXhpc3RlbnRpYWxcbiAgICAqKVxuICAgIHR5cGUgXyB0YWcgPSBUYWcgOiAoJ3ZhcmlhbnQsICdhcmdzKSBUYWcudCAtPiAndmFyaWFudCB0YWdcblxuICAgICgqKlxuICAgICAgIEEgc2ltaWxhciBleGlzdGVudGlhbCBjb25zdHJ1Y3RvciB0byBbXyB0YWddIGJ1dCB0aGlzIG9uZSBob2xkcyBhIHZhbHVlIHdob3NlIHR5cGVcbiAgICAgICBpcyB0aGUgYXJndW1lbnRzIG9mIHRoZSB0YWcgY29uc3RydWN0b3IuICBBIHZhbHVlIG9mIHR5cGUgWydhIHZhbHVlXSBpcyBhIHBhaXIgb2ZcbiAgICAgICAoMSkgYSB2YWx1ZSBvZiB2YXJpYW50IHR5cGUgWydhXSBhbG9uZyB3aXRoICgyKSBzb21lIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICAgICAgIGNvbnN0cnVjdG9yIHdpdGhpbiB0aGUgdHlwZSBbJ2FdXG4gICAgKilcbiAgICB0eXBlIF8gdmFsdWUgPSBWYWx1ZSA6ICgndmFyaWFudCwgJ2FyZ3MpIFRhZy50ICogJ2FyZ3MgLT4gJ3ZhcmlhbnQgdmFsdWVcblxuICAgICgqKlxuICAgICAgIFdpdG5lc3Mgb2YgYSB2YXJpYW50IHR5cGUuIFRoZSBwYXJhbWV0ZXIgaXMgdGhlIHR5cGUgb2YgdGhlIHZhcmlhbnQgdHlwZSB3aXRuZXNzZWQuXG4gICAgKilcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdCAtPiAnYSBUeXBlbmFtZS50XG5cbiAgICAoKipcbiAgICAgICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGFncyBvZiB0aGlzIHZhcmlhbnQgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBHZXQgdGhlIG50aCB0YWcgb2YgdGhpcyB2YXJpYW50IHR5cGUsIGluZGV4ZWQgZnJvbSAwLlxuICAgICopXG4gICAgdmFsIHRhZyA6ICdhIHQgLT4gaW50IC0+ICdhIHRhZ1xuXG4gICAgKCoqXG4gICAgICAgRGlzdGluZ3Vpc2ggcG9seW1vcnBoaWMgdmFyaWFudHMgYW5kIHN0YW5kYXJkIHZhcmlhbnRzLiBUeXBpY2FsbHksIHBvbHltb3JwaGljXG4gICAgICAgdmFyaWFudHMgdGFncyBzdGFydHMgd2l0aCB0aGUgW2BdIGNoYXJhY3Rlci5cbiAgICAgICBFeGFtcGxlXG4gICAgICAgcG9seW1vcnBoaWMgdmFyaWFudDogdHlwZSB0ID0gWyBgQSB8IGBCIF1cbiAgICAgICBzdGFuZGFyZCB2YXJpYW50OiAgICB0eXBlIHQgPSBBIHwgQlxuICAgICopXG4gICAgdmFsIGlzX3BvbHltb3JwaGljIDogXyB0IC0+IGJvb2xcblxuICAgICgqKlxuICAgICAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gYSB2YWx1ZSBvZiB0aGlzIHZhcmlhbnQgdHlwZS5cbiAgICAqKVxuICAgIHZhbCB2YWx1ZSA6ICdhIHQgLT4gJ2EgLT4gJ2EgdmFsdWVcblxuICAgICgqKlxuICAgICAgIGZvbGRpbmcgYWxvbmcgdGhlIHRhZ3Mgb2YgdGhlIHZhcmlhbnQgdHlwZVxuICAgICopXG4gICAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjYyAtPiBmOignYWNjIC0+ICdhIHRhZyAtPiAnYWNjKSAtPiAnYWNjXG5cbiAgICAoKiB1c2VkIGJ5IHRoZSBjYW1scDQgZXh0ZW5zaW9uIHRvIGJ1aWxkIHR5cGUgd2l0bmVzc2VzLCBvciBieSBzb21lIGludGVybmFsIHBhcnRzIG9mXG4gICAgICAgdHlwZXJlcC4geW91IHNob3VsZCBmZWVsIGJhZCBpZiB5b3UgbmVlZCB0byB1c2UgaXQgaW4gc29tZSB1c2VyIGNvZGUgKilcbiAgICB2YWwgaW50ZXJuYWxfdXNlX29ubHkgOiAnYSBWYXJpYW50X2ludGVybmFsLnQgLT4gJ2EgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFZhcmlhbnRfaW50ZXJuYWxcblxuICAgIGxldCB0eXBlbmFtZV9vZl90IHQgPSB0LnR5cGVuYW1lXG4gICAgbGV0IGxlbmd0aCB0ID0gQXJyYXkubGVuZ3RoIHQudGFnc1xuICAgIGxldCB0YWcgdCBpbmRleCA9IHQudGFncy4oaW5kZXgpXG4gICAgbGV0IGlzX3BvbHltb3JwaGljIHQgPSB0LnBvbHltb3JwaGljXG4gICAgbGV0IHZhbHVlIHQgPSB0LnZhbHVlXG4gICAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IEFycmF5LmZvbGRfbGVmdCBmIGluaXQgdC50YWdzXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBGaWVsZF9pbnRlcm5hbCA9IHN0cnVjdFxuICAgIHR5cGUgKCdyZWNvcmQsICdmaWVsZCkgdCA9XG4gICAgICB7IGxhYmVsIDogc3RyaW5nXG4gICAgICA7IHJlcCA6ICdmaWVsZCBYLnRcbiAgICAgIDsgaW5kZXggOiBpbnRcbiAgICAgIDsgdHlpZCA6ICdmaWVsZCBUeXBlbmFtZS50XG4gICAgICA7IGdldCA6ICdyZWNvcmQgLT4gJ2ZpZWxkXG4gICAgICA7ICgqIHNldCA6ICgncmVjb3JkIC0+ICdmaWVsZCAtPiB1bml0KSBvcHRpb247IChcXCogbXV0YWJsZSBmaWVsZCAqXFwpICopXG4gICAgICAgIGlzX211dGFibGUgOiBib29sXG4gICAgICB9XG4gIGVuZFxuXG4gICgqKlxuICAgICBXaXRuZXNzIG9mIGEgZmllbGQsIHRoYXQgaXMgYW4gaXRlbSBpbiBhIHJlY29yZCB0eXBlLlxuICAgICBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSByZWNvcmQgdHlwZSwgdGhlIHNlY29uZCBpcyB0aGUgdHlwZSBvZiB0aGUgZmllbGQuXG4gICAgIEV4YW1wbGU6XG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50IDsgeSA6IHN0cmluZyB9XG4gICAgIF19XG4gICAgIFRoaXMgdHlwZSBoYXMgdHdvIGZpZWxkcy4gZm9yIGVhY2ggb2YgdGhlbSB3ZSdsbCBoYXZlIGEgY29ycmVzcG9uZGluZyBbRmllbGQudF1cblxuICAgICB2YWwgZmllbGRfeCA6ICh0LCBpbnQpIEZpZWxkLnRcbiAgICAgdmFsIGZpZWxkX3kgOiAodCwgc3RyaW5nKSBGaWVsZC50XG4gICopXG4gIG1vZHVsZSBGaWVsZCA6IHNpZ1xuICAgIHR5cGUgKCdyZWNvcmQsICdmaWVsZCkgdFxuXG4gICAgKCoqXG4gICAgICAgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIGFzIGl0IGlzIGdpdmVuIGluIHRoZSBjb25jcmV0ZSBzeW50YXhcbiAgICAgICBFeGFtcGxlczpcbiAgICAgICB7W1xuICAgICAgICAgeyB4ICAgOiBpbnQ7ICAgICAoKiBcInhcIiAqKVxuICAgICAgICAgICBmb28gOiBzdHJpbmc7ICAoKiBcImZvb1wiICopXG4gICAgICAgICAgIGJhciA6IGZsb2F0OyAgICgqIFwiYmFyXCIgKilcbiAgICAgICAgIH1cbiAgICAgICBdfVxuICAgICopXG4gICAgdmFsIGxhYmVsIDogKF8sIF8pIHQgLT4gc3RyaW5nXG5cbiAgICAoKipcbiAgICAgICBUaGUgMC1iYXNlZCBpbmRleCBvZiB0aGUgZmllbGQgaW4gdGhlIGxpc3Qgb2YgYWxsIGZpZWxkcyBmb3IgdGhpcyByZWNvcmQgdHlwZS5cbiAgICAgICBFeGFtcGxlOlxuICAgICAgIHtbXG4gICAgICAgICB0eXBlIHQgPSB7XG4gICAgICAgICAgIHggICA6IGludDsgICAgICgqIDAgKilcbiAgICAgICAgICAgZm9vIDogc3RyaW5nOyAgKCogMSAqKVxuICAgICAgICAgICBiYXIgOiBzdHJpbmc7ICAoKiAyICopXG4gICAgICAgICB9XG4gICAgICAgXX1cbiAgICAqKVxuICAgIHZhbCBpbmRleCA6IChfLCBfKSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgRmllbGQgYWNjZXNzb3JzLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBkb3Qgb3BlcmF0aW9uLlxuICAgICAgIFtGaWVsZC5nZXQgYmFyX2ZpZWxkIHRdIHJldHVybnMgdGhlIGZpZWxkIFtiYXJdIG9mIHRoZSByZWNvcmQgdmFsdWUgW3RdLCBqdXN0IHRoZVxuICAgICAgIHNhbWUgYXMgW3QuYmFyXVxuICAgICopXG4gICAgdmFsIGdldCA6ICgncmVjb3JkLCAnZmllbGQpIHQgLT4gJ3JlY29yZCAtPiAnZmllbGRcblxuICAgICgqKiByZXR1cm4gd2hldGhlciB0aGUgZmllbGQgaXMgbXV0YWJsZSwgaS5lLiB3aGV0aGVyIGl0cyBkZWNsYXJhdGlvbiBpcyBwcmVmaXhlZCB3aXRoXG4gICAgICAgIHRoZSBrZXl3b3JkIFttdXRhYmxlXSAqKVxuICAgIHZhbCBpc19tdXRhYmxlIDogKF8sIF8pIHQgLT4gYm9vbFxuXG4gICAgKCoqIHJldHVybiB0aGUgdHlwZV9uYW1lIG9mIHRoZSBhcmd1bWVudHMuICBNaWdodCBiZSB1c2VkIHRvIHBlcmZvcm0gc29tZSBsb29rdXAgYmFzZWRcbiAgICAgICAgb24gaXQgKilcbiAgICB2YWwgdHlpZCA6IChfLCAnZmllbGQpIHQgLT4gJ2ZpZWxkIFR5cGVuYW1lLnRcblxuICAgICgqKiBnZXQgdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBhcmd1bWVudHMgKilcbiAgICB2YWwgdHJhdmVyc2UgOiAoXywgJ2ZpZWxkKSB0IC0+ICdmaWVsZCBYLnRcblxuICAgICgqIHVzZWQgYnkgdGhlIGNhbWxwNCBleHRlbnNpb24gdG8gYnVpbGQgdHlwZSB3aXRuZXNzZXMsIG9yIGJ5IHNvbWUgaW50ZXJuYWwgcGFydHMgb2ZcbiAgICAgICB0eXBlcmVwLiB5b3Ugc2hvdWxkIGZlZWwgYmFkIGlmIHlvdSBuZWVkIHRvIHVzZSBpdCBpbiBzb21lIHVzZXIgY29kZSAqKVxuICAgIHZhbCBpbnRlcm5hbF91c2Vfb25seSA6ICgnYSwgJ2IpIEZpZWxkX2ludGVybmFsLnQgLT4gKCdhLCAnYikgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEZpZWxkX2ludGVybmFsXG5cbiAgICBsZXQgbGFiZWwgdCA9IHQubGFiZWxcbiAgICBsZXQgaW5kZXggdCA9IHQuaW5kZXhcbiAgICBsZXQgZ2V0IHQgPSB0LmdldFxuICAgIGxldCBpc19tdXRhYmxlIHQgPSB0LmlzX211dGFibGVcbiAgICBsZXQgdHlpZCB0ID0gdC50eWlkXG4gICAgbGV0IHRyYXZlcnNlIHQgPSB0LnJlcFxuICAgIGxldCBpbnRlcm5hbF91c2Vfb25seSB0ID0gdFxuICBlbmRcblxuICBtb2R1bGUgUmVjb3JkX2ludGVybmFsID0gc3RydWN0XG4gICAgdHlwZSBfIGZpZWxkID0gRmllbGQgOiAoJ3JlY29yZCwgJ2EpIEZpZWxkLnQgLT4gJ3JlY29yZCBmaWVsZFxuICAgIHR5cGUgJ3JlY29yZCBmaWVsZHMgPSB7IGdldCA6ICdmaWVsZC4gKCdyZWNvcmQsICdmaWVsZCkgRmllbGQudCAtPiAnZmllbGQgfVxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgdHlwZW5hbWUgOiAnYSBUeXBlbmFtZS50XG4gICAgICA7IGZpZWxkcyA6ICdhIGZpZWxkIGFycmF5XG4gICAgICA7IGhhc19kb3VibGVfYXJyYXlfdGFnIDogYm9vbFxuICAgICAgOyBjcmVhdGUgOiAnYSBmaWVsZHMgLT4gJ2FcbiAgICAgIH1cbiAgZW5kXG5cbiAgbW9kdWxlIFJlY29yZCA6IHNpZ1xuICAgICgqKlxuICAgICAgIEFuIGV4aXN0ZW50aWFsIHR5cGUgdXNlZCB0byBnYXRoZXIgYWxsIHRoZSBmaWVsZHMgY29uc3RpdHVpbmcgYSByZWNvcmQgdHlwZS4gdGhlXG4gICAgICAgWydyZWNvcmRdIHBhcmFtZXRlciBpcyB0aGUgcmVjb3JkIHR5cGUsIGl0IGlzIHRoZSBzYW1lIGZvciBhbGwgdGhlIGZpZWxkIG9mIHRoYXRcbiAgICAgICByZWNvcmQgdHlwZS4gVGhlIHR5cGUgb2YgdGhlIGZpZWxkcyBtaWdodCBiZSBkaWZmZXJlbnQgZm9yIGVhY2ggZmllbGQgYW5kIGlzIHRodXNcbiAgICAgICBleGlzdGVudGlhbC5cbiAgICAqKVxuICAgIHR5cGUgXyBmaWVsZCA9IEZpZWxkIDogKCdyZWNvcmQsICdhKSBGaWVsZC50IC0+ICdyZWNvcmQgZmllbGRcblxuICAgICgqKlxuICAgICAgIFsncmVjb3JkIGZpZWxkc10gaXMgYSB0eXBlIGlzb21vcnBoaWMgdG8gWydyZWNvcmRdLiAgVGhpcyBnaXZlcyBhIHdheSB0byBnZXQgdGhlXG4gICAgICAgZmllbGQgdmFsdWUgZm9yIGVhY2ggZmllbGQgb2YgdGhlIHJlY29yZC4gIFRoZSBhZHZhbnRhZ2Ugb2YgdGhpcyByZXByZXNlbnRhdGlvbiBpc1xuICAgICAgIHRoYXQgaXQgaXMgY29udmVuaWVudCBmb3Igd3JpdGluZyBnZW5lcmljIGNvbXB1dGF0aW9ucy5cbiAgICAqKVxuICAgIHR5cGUgJ3JlY29yZCBmaWVsZHMgPSB7IGdldCA6ICdmaWVsZC4gKCdyZWNvcmQsICdmaWVsZCkgRmllbGQudCAtPiAnZmllbGQgfVxuXG4gICAgKCoqXG4gICAgICAgV2l0bmVzcyBvZiBhIHJlY29yZCB0eXBlLiBUaGUgcGFyYW1ldGVyIGlzIHRoZSB0eXBlIG9mIHRoZSByZWNvcmQgdHlwZSB3aXRuZXNzZWQuXG4gICAgKilcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdCAtPiAnYSBUeXBlbmFtZS50XG5cbiAgICAoKipcbiAgICAgICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZmllbGRzIG9mIHRoaXMgcmVjb3JkIHR5cGUgZGVmaW5pdGlvbi5cbiAgICAqKVxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgR2V0IHRoZSBudGggZmllbGQgb2YgdGhpcyByZWNvcmQgdHlwZSwgaW5kZXhlZCBmcm9tIDAuXG4gICAgKilcbiAgICB2YWwgZmllbGQgOiAnYSB0IC0+IGludCAtPiAnYSBmaWVsZFxuXG4gICAgKCoqXG4gICAgICAgVGhpcyBpcyBhIGxvdyBsZXZlbCBtZXRhZGF0YSByZWdhcmRpbmcgdGhlIHdheSB0aGUgb2NhbWwgY29tcGlsZXIgcmVwcmVzZW50IHRoZVxuICAgICAgIGFycmF5IHVuZGVybmVhdGggdGhhdCBpcyB0aGUgcnVudGltZSB2YWx1ZSBvZiBhIHJlY29yZCBvZiB0eXBlIFsnYV0gZ2l2ZW4gYSB3aXRuZXNzXG4gICAgICAgb2YgdHlwZSBbJ2EgdF0uIFtoYXNfZG91YmxlX2FycmF5X3RhZyB3XSByZXR1cm5zIFt0cnVlXSBpZiB0aGUgYXJyYXkgdGhhdFxuICAgICAgIHJlcHJlc2VudHMgcnVudGltZSB2YWx1ZXMgb2YgdGhpcyB0eXBlIGlzIGFuIG9wdGltaXplZCBvY2FtbCBmbG9hdCBhcnJheS5cbiAgICAgICBUeXBpY2FsbHksIHRoaXMgd2lsbCBiZSB0cnVlIGZvciByZWNvcmQgd2hlcmUgYWxsIGZpZWxkcyBhcmUgc3RhdGljYWxseSBrbm93biBhcyB0b1xuICAgICAgIGJlIFtmbG9hdHNdLlxuXG4gICAgICAgTm90ZSB0aGF0IHlvdSBjYW4ndCBnZXQgdGhpcyBpbmZvcm1hdGlvbiBkeW5hbWljYWxseSBieSBpbnNwZWN0aW5nIHRoZSB0eXBlcmVwIG9uY2VcbiAgICAgICBpdCBpcyBhcHBsaWVkLCBiZWNhdXNlIHRoZXJlIGlzIGF0IHRoaXMgcG9pbnQgbm8gd2F5IHRvIHRlbGwgd2hldGhlciBvbmUgb2YgdGhlXG4gICAgICAgZmllbGQgaXMgcG9seW1vcnBoaWMgaW4gdGhlIHR5cGUgZGVmaW5pdGlvbi5cbiAgICAqKVxuICAgIHZhbCBoYXNfZG91YmxlX2FycmF5X3RhZyA6IF8gdCAtPiBib29sXG5cbiAgICAoKipcbiAgICAgICBFeHBvc2Ugb25lIGRpcmVjdGlvbiBvZiB0aGUgaXNvbW9ycGhpc20gYmV0d2VlbiBhIHZhbHVlIG9mIHR5cGUgWydhXSBhbmQgYSB2YWx1ZSBvZlxuICAgICAgIHR5cGUgWydhIGZpZWxkc10uIEJhc2ljYWxseSwgZ2l2ZW4gYW4gZW5jb2Rpbmcgd2F5IG9mIGFjY2Vzc2luZyB0aGUgdmFsdWUgb2YgYWxsXG4gICAgICAgdGhlIGZpZWxkcyBvZiBhIHJlY29yZCwgY3JlYXRlIHRoYXQgcmVjb3JkIGFuZCByZXR1cm4gaXQuXG4gICAgKilcbiAgICB2YWwgY3JlYXRlIDogJ2EgdCAtPiAnYSBmaWVsZHMgLT4gJ2FcblxuICAgICgqKlxuICAgICAgIGZvbGRpbmcgYWxvbmcgdGhlIHRhZ3Mgb2YgdGhlIHZhcmlhbnQgdHlwZVxuICAgICopXG4gICAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjYyAtPiBmOignYWNjIC0+ICdhIGZpZWxkIC0+ICdhY2MpIC0+ICdhY2NcblxuICAgICgqIHVzZWQgYnkgdGhlIGNhbWxwNCBleHRlbnNpb24gdG8gYnVpbGQgdHlwZSB3aXRuZXNzZXMsIG9yIGJ5IHNvbWUgaW50ZXJuYWwgcGFydHMgb2ZcbiAgICAgICB0eXBlcmVwLiB5b3Ugc2hvdWxkIGZlZWwgYmFkIGlmIHlvdSBuZWVkIHRvIHVzZSBpdCBpbiBzb21lIHVzZXIgY29kZSAqKVxuICAgIHZhbCBpbnRlcm5hbF91c2Vfb25seSA6ICdhIFJlY29yZF9pbnRlcm5hbC50IC0+ICdhIHRcbiAgZW5kID0gc3RydWN0XG4gICAgaW5jbHVkZSBSZWNvcmRfaW50ZXJuYWxcblxuICAgIGxldCB0eXBlbmFtZV9vZl90IHQgPSB0LnR5cGVuYW1lXG4gICAgbGV0IGxlbmd0aCB0ID0gQXJyYXkubGVuZ3RoIHQuZmllbGRzXG4gICAgbGV0IGZpZWxkIHQgaW5kZXggPSB0LmZpZWxkcy4oaW5kZXgpXG4gICAgbGV0IGhhc19kb3VibGVfYXJyYXlfdGFnIHQgPSB0Lmhhc19kb3VibGVfYXJyYXlfdGFnXG4gICAgbGV0IGNyZWF0ZSB0ID0gdC5jcmVhdGVcbiAgICBsZXQgZm9sZCB0IH5pbml0IH5mID0gQXJyYXkuZm9sZF9sZWZ0IGYgaW5pdCB0LmZpZWxkc1xuICAgIGxldCBpbnRlcm5hbF91c2Vfb25seSB0ID0gdFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2YgTSAoc3RydWN0XG4gICAgdHlwZSAnYSByZXAgPSAnYSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgcmVwXG4gIGVuZClcbmVuZFxuIiwibW9kdWxlIE5hbWVfb2YgPSBzdHJ1Y3RcbiAgbGV0IHR5cGVuYW1lX29mX2ludCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gaW50XG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImludFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfaW50MzIgPVxuICAgIGxldCBtb2R1bGUgTSA9XG4gICAgICBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IGludDMyXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImludDMyXCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9pbnQ2NCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gaW50NjRcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50NjRcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX25hdGl2ZWludCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gbmF0aXZlaW50XG5cbiAgICAgICAgbGV0IG5hbWUgPSBcIm5hdGl2ZWludFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfY2hhciA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gY2hhclxuXG4gICAgICAgIGxldCBuYW1lID0gXCJjaGFyXCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9mbG9hdCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gZmxvYXRcblxuICAgICAgICBsZXQgbmFtZSA9IFwiZmxvYXRcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX3N0cmluZyA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gc3RyaW5nXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcInN0cmluZ1wiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfYnl0ZXMgPVxuICAgIGxldCBtb2R1bGUgTSA9XG4gICAgICBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IGJ5dGVzXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImJ5dGVzXCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9ib29sID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBib29sXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImJvb2xcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX3VuaXQgPVxuICAgIGxldCBtb2R1bGUgTSA9XG4gICAgICBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IHVuaXRcblxuICAgICAgICBsZXQgbmFtZSA9IFwidW5pdFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBtb2R1bGUgTV9vcHRpb24gPSBUeXBlbmFtZS5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG5cbiAgICBsZXQgbmFtZSA9IFwib3B0aW9uXCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9vcHRpb24gPSBNX29wdGlvbi50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fbGlzdCA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICBsZXQgbmFtZSA9IFwibGlzdFwiXG4gIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfbGlzdCA9IE1fbGlzdC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fYXJyYXkgPSBUeXBlbmFtZS5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgYXJyYXlcblxuICAgIGxldCBuYW1lID0gXCJhcnJheVwiXG4gIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfYXJyYXkgPSBNX2FycmF5LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9sYXp5X3QgPSBUeXBlbmFtZS5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgbGF6eV90XG5cbiAgICBsZXQgbmFtZSA9IFwibGF6eV90XCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9sYXp5X3QgPSBNX2xhenlfdC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fcmVmID0gVHlwZW5hbWUuTWFrZTEgKHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIHJlZlxuXG4gICAgbGV0IG5hbWUgPSBcInJlZlwiXG4gIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfcmVmID0gTV9yZWYudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX2Z1bmN0aW9uID0gVHlwZW5hbWUuTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIC0+ICdiXG5cbiAgICBsZXQgbmFtZSA9IFwiZnVuY3Rpb25cIlxuICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX2Z1bmN0aW9uID0gTV9mdW5jdGlvbi50eXBlbmFtZV9vZl90XG5cbiAgdHlwZSB0dXBsZTAgPSB1bml0XG5cbiAgbW9kdWxlIE1fdHVwbGUwID0gVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgIHR5cGUgdCA9IHR1cGxlMFxuXG4gICAgbGV0IG5hbWUgPSBcInR1cGxlMFwiXG4gIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdHVwbGUwID0gTV90dXBsZTAudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX3R1cGxlMiA9IFR5cGVuYW1lLk1ha2UyIChzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSAqICdiXG5cbiAgICBsZXQgbmFtZSA9IFwidHVwbGUyXCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTIgPSBNX3R1cGxlMi50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGUzID0gVHlwZW5hbWUuTWFrZTMgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAnYSAqICdiICogJ2NcblxuICAgIGxldCBuYW1lID0gXCJ0dXBsZTNcIlxuICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlMyA9IE1fdHVwbGUzLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV90dXBsZTQgPSBUeXBlbmFtZS5NYWtlNCAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgPSAnYSAqICdiICogJ2MgKiAnZFxuXG4gICAgbGV0IG5hbWUgPSBcInR1cGxlNFwiXG4gIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdHVwbGU0ID0gTV90dXBsZTQudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX3R1cGxlNSA9IFR5cGVuYW1lLk1ha2U1IChzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgPSAnYSAqICdiICogJ2MgKiAnZCAqICdlXG5cbiAgICBsZXQgbmFtZSA9IFwidHVwbGU1XCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTUgPSBNX3R1cGxlNS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIHJlYyBUeXBlcmVwIDogc2lnXG4gIHR5cGUgXyB0ID1cbiAgICB8IEludCA6IGludCB0XG4gICAgfCBJbnQzMiA6IGludDMyIHRcbiAgICB8IEludDY0IDogaW50NjQgdFxuICAgIHwgTmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgICB8IENoYXIgOiBjaGFyIHRcbiAgICB8IEZsb2F0IDogZmxvYXQgdFxuICAgIHwgU3RyaW5nIDogc3RyaW5nIHRcbiAgICB8IEJ5dGVzIDogYnl0ZXMgdFxuICAgIHwgQm9vbCA6IGJvb2wgdFxuICAgIHwgVW5pdCA6IHVuaXQgdFxuICAgIHwgT3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICAgIHwgTGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gICAgfCBBcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICAgIHwgTGF6eSA6ICdhIHQgLT4gJ2EgbGF6eV90IHRcbiAgICB8IFJlZiA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgICB8IEZ1bmN0aW9uIDogKCdkb20gdCAqICdybmcgdCkgLT4gKCdkb20gLT4gJ3JuZykgdFxuICAgIHwgVHVwbGUgOiAnYSBUeXBlcmVwLlR1cGxlLnQgLT4gJ2EgdFxuICAgIHwgUmVjb3JkIDogJ2EgVHlwZXJlcC5SZWNvcmQudCAtPiAnYSB0XG4gICAgfCBWYXJpYW50IDogJ2EgVHlwZXJlcC5WYXJpYW50LnQgLT4gJ2EgdFxuICAgIHwgTmFtZWQgOiAoJ2EgVHlwZXJlcC5OYW1lZC50ICogJ2EgdCBsYXp5X3Qgb3B0aW9uKSAtPiAnYSB0XG5cbiAgdHlwZSBwYWNrZWQgPSBUIDogJ2EgdCAtPiBwYWNrZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICBtb2R1bGUgdHlwZSBUMCA9IHNpZ1xuICAgICAgdHlwZSBuYW1lZFxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6IG5hbWVkIFR5cGVuYW1lLnRcbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMSA9IHNpZ1xuICAgICAgdHlwZSAnYSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2EgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIGEgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDIgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYikgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWQgOiAnYSBUeXBlbmFtZS50IC0+ICdiIFR5cGVuYW1lLnQgLT4gKCdhLCAnYikgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMyA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNCA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGNcblxuICAgICAgdmFsIGMgOiBjIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGRcblxuICAgICAgdmFsIGQgOiBkIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgIDogICdhIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2IgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYyBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdkIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkKSBuYW1lZCBUeXBlbmFtZS50XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYiwgYywgZCkgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDUgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZVxuXG4gICAgICB2YWwgZSA6IGUgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkLCBlKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICAoKiB0aGVyZSB0aGUgbW9kdWxlIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIGEgdHlwZSBbdF0gd2l0aFxuICAgICAgIHBhcmFtZXRlcnMgd2hvc2Uga2luZCBpcyBub3QgcmVwcmVzZW50YWJsZSBhcyBhIHR5cGUgdmFyaWFibGU6IFsnYSAndF0sIGV2ZW4gd2l0aFxuICAgICAgIGEgZ2FkdC4gKilcbiAgICB0eXBlICdhIHQgPVxuICAgICAgfCBUMCBvZiAobW9kdWxlIFQwIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQxIG9mIChtb2R1bGUgVDEgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDIgb2YgKG1vZHVsZSBUMiB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMyBvZiAobW9kdWxlIFQzIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQ0IG9mIChtb2R1bGUgVDQgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDUgb2YgKG1vZHVsZSBUNSB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gICAgdmFsIGFyaXR5IDogXyB0IC0+IGludFxuICAgIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdCAtPiAnYSBUeXBlbmFtZS50XG4gICAgdmFsIG5hbWUgOiBfIHQgLT4gc3RyaW5nXG4gIGVuZFxuXG4gIG1vZHVsZSBUdXBsZSA6IHNpZ1xuICAgICgqIHRoZXNlIGNvbnN0cnVjdG9ycyBjb3VsZCBiZSBwbHVuZ2VkIGF0IHRvcGxldmVsIG9mIFR5cGVyZXAudCwgaG93ZXZlciBpdCBpcyBsZXNzXG4gICAgICAgdmVyYm9zZSB0aGF0IHdheSAqKVxuICAgIHR5cGUgXyB0ID1cbiAgICAgIHwgVDIgOiAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50KSAtPiAoJ2EgKiAnYikgdFxuICAgICAgfCBUMyA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQpIC0+ICgnYSAqICdiICogJ2MpIHRcbiAgICAgIHwgVDQgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkKSB0XG4gICAgICB8IFQ1IDpcbiAgICAgICAgICAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50ICogJ2MgVHlwZXJlcC50ICogJ2QgVHlwZXJlcC50ICogJ2UgVHlwZXJlcC50KVxuICAgICAgICAgIC0+ICgnYSAqICdiICogJ2MgKiAnZCAqICdlKSB0XG5cbiAgICB2YWwgYXJpdHkgOiBfIHQgLT4gaW50XG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcbiAgZW5kXG5cbiAgaW5jbHVkZSBWYXJpYW50X2FuZF9yZWNvcmRfaW50Zi5TIHdpdGggdHlwZSAnYSB0IDo9ICdhIFR5cGVyZXAudFxuXG4gIHZhbCBzYW1lIDogXyB0IC0+IF8gdCAtPiBib29sXG4gIHZhbCBzYW1lX3dpdG5lc3MgOiAnYSB0IC0+ICdiIHQgLT4gKCdhLCAnYikgVHlwZV9lcXVhbC50IG9wdGlvblxuICB2YWwgc2FtZV93aXRuZXNzX2V4biA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBUeXBlX2VxdWFsLnRcbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcbiAgdmFsIGhlYWQgOiAnYSB0IC0+ICdhIHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIF8gdCA9XG4gICAgfCBJbnQgOiBpbnQgdFxuICAgIHwgSW50MzIgOiBpbnQzMiB0XG4gICAgfCBJbnQ2NCA6IGludDY0IHRcbiAgICB8IE5hdGl2ZWludCA6IG5hdGl2ZWludCB0XG4gICAgfCBDaGFyIDogY2hhciB0XG4gICAgfCBGbG9hdCA6IGZsb2F0IHRcbiAgICB8IFN0cmluZyA6IHN0cmluZyB0XG4gICAgfCBCeXRlcyA6IGJ5dGVzIHRcbiAgICB8IEJvb2wgOiBib29sIHRcbiAgICB8IFVuaXQgOiB1bml0IHRcbiAgICB8IE9wdGlvbiA6ICdhIHQgLT4gJ2Egb3B0aW9uIHRcbiAgICB8IExpc3QgOiAnYSB0IC0+ICdhIGxpc3QgdFxuICAgIHwgQXJyYXkgOiAnYSB0IC0+ICdhIGFycmF5IHRcbiAgICB8IExhenkgOiAnYSB0IC0+ICdhIGxhenlfdCB0XG4gICAgfCBSZWYgOiAnYSB0IC0+ICdhIHJlZiB0XG4gICAgfCBGdW5jdGlvbiA6ICgnZG9tIHQgKiAncm5nIHQpIC0+ICgnZG9tIC0+ICdybmcpIHRcbiAgICB8IFR1cGxlIDogJ2EgVHlwZXJlcC5UdXBsZS50IC0+ICdhIHRcbiAgICB8IFJlY29yZCA6ICdhIFR5cGVyZXAuUmVjb3JkLnQgLT4gJ2EgdFxuICAgIHwgVmFyaWFudCA6ICdhIFR5cGVyZXAuVmFyaWFudC50IC0+ICdhIHRcbiAgICB8IE5hbWVkIDogKCdhIFR5cGVyZXAuTmFtZWQudCAqICdhIHQgbGF6eV90IG9wdGlvbikgLT4gJ2EgdFxuXG4gIHR5cGUgcGFja2VkID0gVCA6ICdhIHQgLT4gcGFja2VkXG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgbW9kdWxlIHR5cGUgVDAgPSBzaWdcbiAgICAgIHR5cGUgbmFtZWRcbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWQgOiBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDEgPSBzaWdcbiAgICAgIHR5cGUgJ2EgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWQgOiAnYSBUeXBlbmFtZS50IC0+ICdhIG5hbWVkIFR5cGVuYW1lLnRcbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCBhIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQyID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogJ2EgVHlwZW5hbWUudCAtPiAnYiBUeXBlbmFtZS50IC0+ICgnYSwgJ2IpIG5hbWVkIFR5cGVuYW1lLnRcbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYikgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDMgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGNcblxuICAgICAgdmFsIGMgOiBjIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgIDogICdhIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2IgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYyBUeXBlbmFtZS50XG4gICAgICAgIC0+ICgnYSwgJ2IsICdjKSBuYW1lZCBUeXBlbmFtZS50XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYiwgYykgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDQgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBkXG5cbiAgICAgIHZhbCBkIDogZCBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZCBUeXBlbmFtZS50XG4gICAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCkgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMsIGQpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQ1ID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGNcblxuICAgICAgdmFsIGMgOiBjIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGRcblxuICAgICAgdmFsIGQgOiBkIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGVcblxuICAgICAgdmFsIGUgOiBlIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgIDogICdhIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2IgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYyBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdkIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2UgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSBuYW1lZCBUeXBlbmFtZS50XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYiwgYywgZCwgZSkgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgKCogdGhlcmUgdGhlIG1vZHVsZSBpcyBuZWNlc3NhcnkgYmVjYXVzZSB3ZSBuZWVkIHRvIGRlYWwgd2l0aCBhIHR5cGUgW3RdIHdpdGhcbiAgICAgICBwYXJhbWV0ZXJzIHdob3NlIGtpbmQgaXMgbm90IHJlcHJlc2VudGFibGUgYXMgYSB0eXBlIHZhcmlhYmxlOiBbJ2EgJ3RdLCBldmVuIHdpdGhcbiAgICAgICBhIGdhZHQuICopXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHwgVDAgb2YgKG1vZHVsZSBUMCB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMSBvZiAobW9kdWxlIFQxIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQyIG9mIChtb2R1bGUgVDIgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDMgb2YgKG1vZHVsZSBUMyB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUNCBvZiAobW9kdWxlIFQ0IHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQ1IG9mIChtb2R1bGUgVDUgd2l0aCB0eXBlIHQgPSAnYSlcblxuICAgIGxldCBhcml0eSA9IGZ1bmN0aW9uXG4gICAgICB8IFQwIF8gLT4gMFxuICAgICAgfCBUMSBfIC0+IDFcbiAgICAgIHwgVDIgXyAtPiAyXG4gICAgICB8IFQzIF8gLT4gM1xuICAgICAgfCBUNCBfIC0+IDRcbiAgICAgIHwgVDUgXyAtPiA1XG4gICAgOztcblxuICAgIGxldCB0eXBlbmFtZV9vZl90ICh0eXBlIGEpID0gZnVuY3Rpb25cbiAgICAgIHwgVDAgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDAgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICAgIHwgVDEgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDEgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICAgIHwgVDIgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDIgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICAgIHwgVDMgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDMgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICAgIHwgVDQgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDQgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICAgIHwgVDUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVDUgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgICBULnR5cGVuYW1lX29mX3RcbiAgICA7O1xuXG4gICAgbGV0IG5hbWUgcmVwID0gVHlwZW5hbWUuVWlkLm5hbWUgKFR5cGVuYW1lLnVpZCAodHlwZW5hbWVfb2ZfdCByZXApKVxuICBlbmRcblxuICBtb2R1bGUgVHVwbGUgPSBzdHJ1Y3RcbiAgICAoKiB0aGVzZSBjb25zdHJ1Y3RvcnMgY291bGQgYmUgcGx1bmdlZCBhdCB0b3BsZXZlbCBvZiBUeXBlcmVwLnQsIGhvd2V2ZXIgaXQgaXMgbGVzc1xuICAgICAgIHZlcmJvc2UgdGhpcyB3YXkgKilcbiAgICB0eXBlIF8gdCA9XG4gICAgICB8IFQyIDogKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCkgLT4gKCdhICogJ2IpIHRcbiAgICAgIHwgVDMgOiAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50ICogJ2MgVHlwZXJlcC50KSAtPiAoJ2EgKiAnYiAqICdjKSB0XG4gICAgICB8IFQ0IDpcbiAgICAgICAgICAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50ICogJ2MgVHlwZXJlcC50ICogJ2QgVHlwZXJlcC50KVxuICAgICAgICAgIC0+ICgnYSAqICdiICogJ2MgKiAnZCkgdFxuICAgICAgfCBUNSA6XG4gICAgICAgICAgKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCAqICdkIFR5cGVyZXAudCAqICdlIFR5cGVyZXAudClcbiAgICAgICAgICAtPiAoJ2EgKiAnYiAqICdjICogJ2QgKiAnZSkgdFxuXG4gICAgbGV0IGFyaXR5IDogdHlwZSBhLiBhIHQgLT4gaW50ID0gZnVuY3Rpb25cbiAgICAgIHwgVHlwZXJlcC5UdXBsZS5UMiBfIC0+IDJcbiAgICAgIHwgVHlwZXJlcC5UdXBsZS5UMyBfIC0+IDNcbiAgICAgIHwgVHlwZXJlcC5UdXBsZS5UNCBfIC0+IDRcbiAgICAgIHwgVHlwZXJlcC5UdXBsZS5UNSBfIC0+IDVcbiAgICA7O1xuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgOiB0eXBlIGEuIGEgdCAtPiBhIFR5cGVuYW1lLnQgPSBmdW5jdGlvblxuICAgICAgfCBUMiAoYSwgYikgLT5cbiAgICAgICAgTmFtZV9vZi50eXBlbmFtZV9vZl90dXBsZTIgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKSAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGIpXG4gICAgICB8IFQzIChhLCBiLCBjKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlM1xuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYSlcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGIpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBjKVxuICAgICAgfCBUNCAoYSwgYiwgYywgZCkgLT5cbiAgICAgICAgTmFtZV9vZi50eXBlbmFtZV9vZl90dXBsZTRcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGEpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBiKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYylcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGQpXG4gICAgICB8IFQ1IChhLCBiLCBjLCBkLCBlKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlNVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYSlcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGIpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBjKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZClcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGUpXG4gICAgOztcbiAgZW5kXG5cbiAgaW5jbHVkZSBWYXJpYW50X2FuZF9yZWNvcmRfaW50Zi5NIChzdHJ1Y3RcbiAgICB0eXBlICdhIHJlcCA9ICdhIHRcbiAgICB0eXBlICdhIHQgPSAnYSByZXBcbiAgZW5kKVxuXG4gIGxldCByZWMgdHlwZW5hbWVfb2ZfdCA6IHR5cGUgYS4gYSB0IC0+IGEgVHlwZW5hbWUudCA9IGZ1bmN0aW9uXG4gICAgfCBJbnQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnRcbiAgICB8IEludDMyIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfaW50MzJcbiAgICB8IEludDY0IC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfaW50NjRcbiAgICB8IE5hdGl2ZWludCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX25hdGl2ZWludFxuICAgIHwgQ2hhciAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2NoYXJcbiAgICB8IEZsb2F0IC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfZmxvYXRcbiAgICB8IFN0cmluZyAtPiBOYW1lX29mLnR5cGVuYW1lX29mX3N0cmluZ1xuICAgIHwgQnl0ZXMgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9ieXRlc1xuICAgIHwgQm9vbCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2Jvb2xcbiAgICB8IFVuaXQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl91bml0XG4gICAgfCBPcHRpb24gcmVwIC0+IE5hbWVfb2YudHlwZW5hbWVfb2Zfb3B0aW9uICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IExpc3QgcmVwIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbGlzdCAodHlwZW5hbWVfb2ZfdCByZXApXG4gICAgfCBBcnJheSByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9hcnJheSAodHlwZW5hbWVfb2ZfdCByZXApXG4gICAgfCBMYXp5IHJlcCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2xhenlfdCAodHlwZW5hbWVfb2ZfdCByZXApXG4gICAgfCBSZWYgcmVwIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfcmVmICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IEZ1bmN0aW9uIChkb20sIHJuZykgLT5cbiAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfZnVuY3Rpb24gKHR5cGVuYW1lX29mX3QgZG9tKSAodHlwZW5hbWVfb2ZfdCBybmcpXG4gICAgfCBUdXBsZSByZXAgLT4gVHlwZXJlcC5UdXBsZS50eXBlbmFtZV9vZl90IHJlcFxuICAgIHwgUmVjb3JkIHJlcCAtPiBUeXBlcmVwLlJlY29yZC50eXBlbmFtZV9vZl90IHJlcFxuICAgIHwgVmFyaWFudCByZXAgLT4gVHlwZXJlcC5WYXJpYW50LnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBOYW1lZCAobmFtZSwgXykgLT4gTmFtZWQudHlwZW5hbWVfb2ZfdCBuYW1lXG4gIDs7XG5cbiAgbGV0IHJlYyBzYW1lX3dpdG5lc3MgOiB0eXBlIGEgYi4gYSB0IC0+IGIgdCAtPiAoYSwgYikgVHlwZV9lcXVhbC50IG9wdGlvbiA9XG4gICAgZnVuIHQxIHQyIC0+XG4gICAgbGV0IG1vZHVsZSBFID0gVHlwZV9lcXVhbCBpblxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBOYW1lZCAobmFtZTEsIHIxKSwgTmFtZWQgKG5hbWUyLCByMikgLT5cbiAgICAgIChtYXRjaFxuICAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzIChOYW1lZC50eXBlbmFtZV9vZl90IG5hbWUxKSAoTmFtZWQudHlwZW5hbWVfb2ZfdCBuYW1lMilcbiAgICAgICB3aXRoXG4gICAgICAgfCBTb21lIEUuVCBhcyB4IC0+IHhcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIChtYXRjaCByMSwgcjIgd2l0aFxuICAgICAgICAgIHwgU29tZSAobGF6eSB0MSksIFNvbWUgKGxhenkgdDIpIC0+IHNhbWVfd2l0bmVzcyB0MSB0MlxuICAgICAgICAgIHwgU29tZSAobGF6eSB0MSksIE5vbmUgLT4gc2FtZV93aXRuZXNzIHQxIHQyXG4gICAgICAgICAgfCBOb25lLCBTb21lIChsYXp5IHQyKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgICB8IE5vbmUsIE5vbmUgLT4gTm9uZSkpXG4gICAgfCBOYW1lZCAoXywgcjEpLCB0MiAtPlxuICAgICAgKG1hdGNoIHIxIHdpdGhcbiAgICAgICB8IFNvbWUgKGxhenkgdDEpIC0+IHNhbWVfd2l0bmVzcyB0MSB0MlxuICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIHwgdDEsIE5hbWVkIChfLCByMikgLT5cbiAgICAgIChtYXRjaCByMiB3aXRoXG4gICAgICAgfCBTb21lIChsYXp5IHQyKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IEludCwgSW50IC0+IFNvbWUgRS5UXG4gICAgfCBJbnQzMiwgSW50MzIgLT4gU29tZSBFLlRcbiAgICB8IEludDY0LCBJbnQ2NCAtPiBTb21lIEUuVFxuICAgIHwgTmF0aXZlaW50LCBOYXRpdmVpbnQgLT4gU29tZSBFLlRcbiAgICB8IENoYXIsIENoYXIgLT4gU29tZSBFLlRcbiAgICB8IEZsb2F0LCBGbG9hdCAtPiBTb21lIEUuVFxuICAgIHwgU3RyaW5nLCBTdHJpbmcgLT4gU29tZSBFLlRcbiAgICB8IEJ5dGVzLCBCeXRlcyAtPiBTb21lIEUuVFxuICAgIHwgQm9vbCwgQm9vbCAtPiBTb21lIEUuVFxuICAgIHwgVW5pdCwgVW5pdCAtPiBTb21lIEUuVFxuICAgIHwgT3B0aW9uIHIxLCBPcHRpb24gcjIgLT5cbiAgICAgIChtYXRjaCBzYW1lX3dpdG5lc3MgcjEgcjIgd2l0aFxuICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICB8IExpc3QgcjEsIExpc3QgcjIgLT5cbiAgICAgIChtYXRjaCBzYW1lX3dpdG5lc3MgcjEgcjIgd2l0aFxuICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICB8IEFycmF5IHIxLCBBcnJheSByMiAtPlxuICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgfCBOb25lIGFzIHggLT4geFxuICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgIHwgTGF6eSByMSwgTGF6eSByMiAtPlxuICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgfCBOb25lIGFzIHggLT4geFxuICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgIHwgUmVmIHIxLCBSZWYgcjIgLT5cbiAgICAgIChtYXRjaCBzYW1lX3dpdG5lc3MgcjEgcjIgd2l0aFxuICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICB8IEZ1bmN0aW9uIChkb20xLCBybmcxKSwgRnVuY3Rpb24gKGRvbTIsIHJuZzIpIC0+XG4gICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGRvbTEgZG9tMiwgc2FtZV93aXRuZXNzIHJuZzEgcm5nMiB3aXRoXG4gICAgICAgfCBTb21lIEUuVCwgU29tZSBFLlQgLT4gU29tZSBFLlRcbiAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IE5vbmUpXG4gICAgfCBUdXBsZSB0MSwgVHVwbGUgdDIgLT5cbiAgICAgIGxldCBtb2R1bGUgVCA9IFR5cGVyZXAuVHVwbGUgaW5cbiAgICAgIChtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgIHwgVC5UMiAoYTEsIGIxKSwgVC5UMiAoYTIsIGIyKSAtPlxuICAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyBhMSBhMiwgc2FtZV93aXRuZXNzIGIxIGIyIHdpdGhcbiAgICAgICAgICB8IFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICB8IFQuVDMgKGExLCBiMSwgYzEpLCBULlQzIChhMiwgYjIsIGMyKSAtPlxuICAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyBhMSBhMiwgc2FtZV93aXRuZXNzIGIxIGIyLCBzYW1lX3dpdG5lc3MgYzEgYzIgd2l0aFxuICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgIHwgTm9uZSwgXywgXyB8IF8sIE5vbmUsIF8gfCBfLCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgfCBULlQ0IChhMSwgYjEsIGMxLCBkMSksIFQuVDQgKGEyLCBiMiwgYzIsIGQyKSAtPlxuICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICBzYW1lX3dpdG5lc3MgYTEgYTIsIHNhbWVfd2l0bmVzcyBiMSBiMiwgc2FtZV93aXRuZXNzIGMxIGMyLCBzYW1lX3dpdG5lc3MgZDEgZDJcbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgIHwgTm9uZSwgXywgXywgXyB8IF8sIE5vbmUsIF8sIF8gfCBfLCBfLCBOb25lLCBfIHwgXywgXywgXywgTm9uZSAtPiBOb25lKVxuICAgICAgIHwgVC5UNSAoYTEsIGIxLCBjMSwgZDEsIGUxKSwgVC5UNSAoYTIsIGIyLCBjMiwgZDIsIGUyKSAtPlxuICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAoIHNhbWVfd2l0bmVzcyBhMSBhMlxuICAgICAgICAgICAgLCBzYW1lX3dpdG5lc3MgYjEgYjJcbiAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGMxIGMyXG4gICAgICAgICAgICAsIHNhbWVfd2l0bmVzcyBkMSBkMlxuICAgICAgICAgICAgLCBzYW1lX3dpdG5lc3MgZTEgZTIgKVxuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IFNvbWUgRS5ULCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgIHwgTm9uZSwgXywgXywgXywgX1xuICAgICAgICAgIHwgXywgTm9uZSwgXywgXywgX1xuICAgICAgICAgIHwgXywgXywgTm9uZSwgXywgX1xuICAgICAgICAgIHwgXywgXywgXywgTm9uZSwgX1xuICAgICAgICAgIHwgXywgXywgXywgXywgTm9uZSAtPiBOb25lKVxuICAgICAgIHwgVC5UMiBfLCBfIC0+IE5vbmVcbiAgICAgICB8IFQuVDMgXywgXyAtPiBOb25lXG4gICAgICAgfCBULlQ0IF8sIF8gLT4gTm9uZVxuICAgICAgIHwgVC5UNSBfLCBfIC0+IE5vbmUpXG4gICAgfCBSZWNvcmQgcjEsIFJlY29yZCByMiAtPlxuICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzXG4gICAgICAgIChUeXBlcmVwLlJlY29yZC50eXBlbmFtZV9vZl90IHIxKVxuICAgICAgICAoVHlwZXJlcC5SZWNvcmQudHlwZW5hbWVfb2ZfdCByMilcbiAgICB8IFZhcmlhbnQgcjEsIFZhcmlhbnQgcjIgLT5cbiAgICAgIFR5cGVuYW1lLnNhbWVfd2l0bmVzc1xuICAgICAgICAoVHlwZXJlcC5WYXJpYW50LnR5cGVuYW1lX29mX3QgcjEpXG4gICAgICAgIChUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByMilcbiAgICB8IEludCwgXyAtPiBOb25lXG4gICAgfCBJbnQzMiwgXyAtPiBOb25lXG4gICAgfCBJbnQ2NCwgXyAtPiBOb25lXG4gICAgfCBOYXRpdmVpbnQsIF8gLT4gTm9uZVxuICAgIHwgQ2hhciwgXyAtPiBOb25lXG4gICAgfCBGbG9hdCwgXyAtPiBOb25lXG4gICAgfCBTdHJpbmcsIF8gLT4gTm9uZVxuICAgIHwgQnl0ZXMsIF8gLT4gTm9uZVxuICAgIHwgQm9vbCwgXyAtPiBOb25lXG4gICAgfCBVbml0LCBfIC0+IE5vbmVcbiAgICB8IE9wdGlvbiBfLCBfIC0+IE5vbmVcbiAgICB8IExpc3QgXywgXyAtPiBOb25lXG4gICAgfCBBcnJheSBfLCBfIC0+IE5vbmVcbiAgICB8IExhenkgXywgXyAtPiBOb25lXG4gICAgfCBSZWYgXywgXyAtPiBOb25lXG4gICAgfCBGdW5jdGlvbiBfLCBfIC0+IE5vbmVcbiAgICB8IFR1cGxlIF8sIF8gLT4gTm9uZVxuICAgIHwgUmVjb3JkIF8sIF8gLT4gTm9uZVxuICAgIHwgVmFyaWFudCBfLCBfIC0+IE5vbmVcbiAgOztcblxuICBsZXQgc2FtZSBhIGIgPSBzYW1lX3dpdG5lc3MgYSBiIDw+IE5vbmVcblxuICBsZXQgc2FtZV93aXRuZXNzX2V4biBhIGIgPVxuICAgIG1hdGNoIHNhbWVfd2l0bmVzcyBhIGIgd2l0aFxuICAgIHwgU29tZSBwcm9vZiAtPiBwcm9vZlxuICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgOztcblxuICBsZXQgcmVjIGhlYWQgPSBmdW5jdGlvblxuICAgIHwgVHlwZXJlcC5OYW1lZCAoXywgU29tZSAobGF6eSB0KSkgLT4gaGVhZCB0XG4gICAgfCB0IC0+IHRcbiAgOztcbmVuZFxuXG5sZXQgdHlwZXJlcF9vZl9pbnQgPSBUeXBlcmVwLkludFxubGV0IHR5cGVyZXBfb2ZfaW50MzIgPSBUeXBlcmVwLkludDMyXG5sZXQgdHlwZXJlcF9vZl9pbnQ2NCA9IFR5cGVyZXAuSW50NjRcbmxldCB0eXBlcmVwX29mX25hdGl2ZWludCA9IFR5cGVyZXAuTmF0aXZlaW50XG5sZXQgdHlwZXJlcF9vZl9jaGFyID0gVHlwZXJlcC5DaGFyXG5sZXQgdHlwZXJlcF9vZl9mbG9hdCA9IFR5cGVyZXAuRmxvYXRcbmxldCB0eXBlcmVwX29mX3N0cmluZyA9IFR5cGVyZXAuU3RyaW5nXG5sZXQgdHlwZXJlcF9vZl9ieXRlcyA9IFR5cGVyZXAuQnl0ZXNcbmxldCB0eXBlcmVwX29mX2Jvb2wgPSBUeXBlcmVwLkJvb2xcbmxldCB0eXBlcmVwX29mX3VuaXQgPSBUeXBlcmVwLlVuaXRcbmxldCB0eXBlcmVwX29mX29wdGlvbiByZXAgPSBUeXBlcmVwLk9wdGlvbiByZXBcbmxldCB0eXBlcmVwX29mX2xpc3QgcmVwID0gVHlwZXJlcC5MaXN0IHJlcFxubGV0IHR5cGVyZXBfb2ZfYXJyYXkgcmVwID0gVHlwZXJlcC5BcnJheSByZXBcbmxldCB0eXBlcmVwX29mX2xhenlfdCByZXAgPSBUeXBlcmVwLkxhenkgcmVwXG5sZXQgdHlwZXJlcF9vZl9yZWYgcmVwID0gVHlwZXJlcC5SZWYgcmVwXG5sZXQgdHlwZXJlcF9vZl9mdW5jdGlvbiBkb20gcm5nID0gVHlwZXJlcC5GdW5jdGlvbiAoZG9tLCBybmcpXG5sZXQgdHlwZXJlcF9vZl90dXBsZTAgPSBUeXBlcmVwLlVuaXRcbmxldCB0eXBlcmVwX29mX3R1cGxlMiBhIGIgPSBUeXBlcmVwLlR1cGxlIChUeXBlcmVwLlR1cGxlLlQyIChhLCBiKSlcbmxldCB0eXBlcmVwX29mX3R1cGxlMyBhIGIgYyA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDMgKGEsIGIsIGMpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGU0IGEgYiBjIGQgPSBUeXBlcmVwLlR1cGxlIChUeXBlcmVwLlR1cGxlLlQ0IChhLCBiLCBjLCBkKSlcbmxldCB0eXBlcmVwX29mX3R1cGxlNSBhIGIgYyBkIGUgPSBUeXBlcmVwLlR1cGxlIChUeXBlcmVwLlR1cGxlLlQ1IChhLCBiLCBjLCBkLCBlKSlcblxuaW5jbHVkZSBOYW1lX29mXG5cbmxldCB2YWx1ZV90dXBsZTAgPSAoKVxuXG5sZXQgdHlwZXJlcF9vZl9pbnQ2MywgdHlwZW5hbWVfb2ZfaW50NjMgPVxuICBsZXQgdHlwZXJlcF9hbmRfdHlwZW5hbWVfb2ZfaW50NjNfcmVwclxuICAgIDogdHlwZSBhIGIuIChhLCBiKSBCYXNlLkludDYzLlByaXZhdGUuUmVwci50IC0+IGEgVHlwZXJlcC50ICogYSBUeXBlbmFtZS50XG4gICAgPSBmdW5jdGlvblxuICAgIHwgQmFzZS5JbnQ2My5Qcml2YXRlLlJlcHIuSW50IC0+IHR5cGVyZXBfb2ZfaW50LCB0eXBlbmFtZV9vZl9pbnRcbiAgICB8IEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLkludDY0IC0+IHR5cGVyZXBfb2ZfaW50NjQsIHR5cGVuYW1lX29mX2ludDY0XG4gIGluXG4gIHR5cGVyZXBfYW5kX3R5cGVuYW1lX29mX2ludDYzX3JlcHIgQmFzZS5JbnQ2My5Qcml2YXRlLnJlcHJcbjs7XG4iLCIoKiB1c2luZyB0aGUgaGFzaF92YXJpYW50IG9mIHBhX3R5cGVfY29udiBhdCBjb21waWxlIHRpbWUgKilcbmxldCByZXByX29mX3BvbHlfdmFyaWFudCA6IFs+IF0gLT4gaW50ID1cbiAgZnVuIHZhcmlhbnQgLT5cbiAgbGV0IG9iaiA9IE9iai5yZXByIHZhcmlhbnQgaW5cbiAgaWYgT2JqLmlzX2ludCBvYmpcbiAgdGhlbiBPYmoub2JqIG9ialxuICBlbHNlIChcbiAgICBsZXQgc2l6ZSA9IE9iai5zaXplIG9iaiBpblxuICAgIGFzc2VydCAoc2l6ZSA9IDIpO1xuICAgIGxldCByZXByID0gT2JqLmZpZWxkIG9iaiAwIGluXG4gICAgYXNzZXJ0IChPYmouaXNfaW50IHJlcHIpO1xuICAgIE9iai5vYmogcmVwcilcbjs7XG5cbmxldCBoYXNoX3ZhcmlhbnQgcyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9ICgyMjMgKiAhYWNjdSkgKyBDaGFyLmNvZGUgcy5baV1cbiAgZG9uZTtcbiAgKCogcmVkdWNlIHRvIDMxIGJpdHMgKilcbiAgYWNjdSA6PSAhYWNjdSBsYW5kICgoMSBsc2wgMzEpIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3Vcbjs7XG5cbigqIGEgZmV3IHVuaXQgdGVzdHMgb2YgY2FzZXMgdGhhdCBoYXZlIHRyaWdnZXJlZCBkaWZmcyBpbiB0aGUgcGFzdCBvZiB0aGlzXG4gICBsaWIgKilcbmxldCAoKSA9IGFzc2VydCAocmVwcl9vZl9wb2x5X3ZhcmlhbnQgYExhdGVuY3lfc3RhdHMgPSBoYXNoX3ZhcmlhbnQgXCJMYXRlbmN5X3N0YXRzXCIpXG5sZXQgKCkgPSBhc3NlcnQgKHJlcHJfb2ZfcG9seV92YXJpYW50IGB6ZXJvID0gaGFzaF92YXJpYW50IFwiemVyb1wiKVxubGV0W0BpbmxpbmUgbmV2ZXJdIGRvdWJsZV9hcnJheV92YWx1ZSAoKSA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgKE9iai5tYWdpYyAwLilcbmxldCBoYXNfZG91YmxlX2FycmF5X3RhZyBhID0gT2JqLmRvdWJsZV9hcnJheV90YWcgPSBPYmoudGFnIChPYmoucmVwciBhKVxuXG5sZXQgKCkgPVxuICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICB0eXBlIGRvdWJsZSA9XG4gICAgICB7IGEgOiBmbG9hdFxuICAgICAgOyBiIDogZmxvYXRcbiAgICAgIH1cblxuICAgIHR5cGUgc2ltcGxlID1cbiAgICAgIHsgYyA6IGZsb2F0XG4gICAgICA7IGQgOiBpbnRcbiAgICAgIH1cblxuICAgIGxldCBkb3VibGUgPSB7IGEgPSBkb3VibGVfYXJyYXlfdmFsdWUgKCk7IGIgPSBkb3VibGVfYXJyYXlfdmFsdWUgKCkgfVxuICAgIGxldCBzaW1wbGUgPSB7IGMgPSBkb3VibGVfYXJyYXlfdmFsdWUgKCk7IGQgPSBkb3VibGVfYXJyYXlfdmFsdWUgKCkgfVxuICBlbmRcbiAgaW5cbiAgYXNzZXJ0IChoYXNfZG91YmxlX2FycmF5X3RhZyBNLmRvdWJsZSk7XG4gIGFzc2VydCAobm90IChoYXNfZG91YmxlX2FycmF5X3RhZyBNLnNpbXBsZSkpXG47O1xuIiwibW9kdWxlIE0gKFggOiBzaWdcbiAgdHlwZSAnYSB0XG5lbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIGNvbXB1dGUgOiB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYiBYLnQgLT4gKCdhLCAnYikgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2IgWC50IC0+ICdjIFgudCAtPiAoJ2EsICdiLCAnYykgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzQgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNCB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0IDo9ICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2IgWC50IC0+ICdjIFgudCAtPiAnZCBYLnQgLT4gKCdhLCAnYiwgJ2MsICdkKSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgWC50XG4gICAgICAtPiAnYiBYLnRcbiAgICAgIC0+ICdjIFgudFxuICAgICAgLT4gJ2QgWC50XG4gICAgICAtPiAnZSBYLnRcbiAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgWC50XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBNIChzdHJ1Y3RcbiAgICB0eXBlICdhIGNvbXB1dGF0aW9uID0gJ2EgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGNvbXB1dGF0aW9uXG4gIGVuZClcbmVuZFxuIiwib3BlbiBTdGRfaW50ZXJuYWxcbm1vZHVsZSBWYXJpYW50X2FuZF9yZWNvcmRfaW50ZiA9IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmXG5cbm1vZHVsZSBIZWxwZXIgKEEgOiBWYXJpYW50X2FuZF9yZWNvcmRfaW50Zi5TKSAoQiA6IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMpID0gc3RydWN0XG4gIHR5cGUgbWFwID0geyBtYXAgOiAnYS4gJ2EgQS50IC0+ICdhIEIudCB9XG5cbiAgbGV0IG1hcF92YXJpYW50ICh0eXBlIHZhcmlhbnQpIHsgbWFwIH0gKHZhcmlhbnQgOiB2YXJpYW50IEEuVmFyaWFudC50KSA9XG4gICAgbGV0IG1hcF9jcmVhdGUgPSBmdW5jdGlvblxuICAgICAgfCBBLlRhZy5BcmdzIGZjdCAtPiBCLlRhZ19pbnRlcm5hbC5BcmdzIGZjdFxuICAgICAgfCBBLlRhZy5Db25zdCBrIC0+IEIuVGFnX2ludGVybmFsLkNvbnN0IGtcbiAgICBpblxuICAgIGxldCBtYXBfdGFnIHRhZyA9XG4gICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgfCBBLlZhcmlhbnQuVGFnIHRhZyAtPlxuICAgICAgICBsZXQgbGFiZWwgPSBBLlRhZy5sYWJlbCB0YWcgaW5cbiAgICAgICAgbGV0IHJlcCA9IG1hcCAoQS5UYWcudHJhdmVyc2UgdGFnKSBpblxuICAgICAgICBsZXQgYXJpdHkgPSBBLlRhZy5hcml0eSB0YWcgaW5cbiAgICAgICAgbGV0IGFyZ3NfbGFiZWxzID0gQS5UYWcuYXJnc19sYWJlbHMgdGFnIGluXG4gICAgICAgIGxldCBpbmRleCA9IEEuVGFnLmluZGV4IHRhZyBpblxuICAgICAgICBsZXQgb2NhbWxfcmVwciA9IEEuVGFnLm9jYW1sX3JlcHIgdGFnIGluXG4gICAgICAgIGxldCB0eWlkID0gQS5UYWcudHlpZCB0YWcgaW5cbiAgICAgICAgbGV0IGNyZWF0ZSA9IG1hcF9jcmVhdGUgKEEuVGFnLmNyZWF0ZSB0YWcpIGluXG4gICAgICAgIEIuVmFyaWFudF9pbnRlcm5hbC5UYWdcbiAgICAgICAgICAoQi5UYWcuaW50ZXJuYWxfdXNlX29ubHlcbiAgICAgICAgICAgICB7IEIuVGFnX2ludGVybmFsLmxhYmVsXG4gICAgICAgICAgICAgOyByZXBcbiAgICAgICAgICAgICA7IGFyaXR5XG4gICAgICAgICAgICAgOyBhcmdzX2xhYmVsc1xuICAgICAgICAgICAgIDsgaW5kZXhcbiAgICAgICAgICAgICA7IG9jYW1sX3JlcHJcbiAgICAgICAgICAgICA7IHR5aWRcbiAgICAgICAgICAgICA7IGNyZWF0ZVxuICAgICAgICAgICAgIH0pXG4gICAgaW5cbiAgICBsZXQgdHlwZW5hbWUgPSBBLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCB2YXJpYW50IGluXG4gICAgbGV0IHBvbHltb3JwaGljID0gQS5WYXJpYW50LmlzX3BvbHltb3JwaGljIHZhcmlhbnQgaW5cbiAgICBsZXQgdGFncyA9XG4gICAgICBBcnJheS5pbml0IChBLlZhcmlhbnQubGVuZ3RoIHZhcmlhbnQpIChmdW4gaW5kZXggLT5cbiAgICAgICAgbWFwX3RhZyAoQS5WYXJpYW50LnRhZyB2YXJpYW50IGluZGV4KSlcbiAgICBpblxuICAgIGxldCB2YWx1ZSAoYSA6IHZhcmlhbnQpID1cbiAgICAgIG1hdGNoIEEuVmFyaWFudC52YWx1ZSB2YXJpYW50IGEgd2l0aFxuICAgICAgfCBBLlZhcmlhbnQuVmFsdWUgKGF0YWcsIGEpIC0+XG4gICAgICAgIChmdW4gKHR5cGUgYXJncykgKGF0YWcgOiAodmFyaWFudCwgYXJncykgQS5UYWcudCkgKGEgOiBhcmdzKSAtPlxuICAgICAgICAgIGxldCAoQi5WYXJpYW50X2ludGVybmFsLlRhZyBidGFnKSA9IHRhZ3MuKEEuVGFnLmluZGV4IGF0YWcpIGluXG4gICAgICAgICAgKGZ1biAodHlwZSBleCkgKGJ0YWcgOiAodmFyaWFudCwgZXgpIEIuVGFnLnQpIC0+XG4gICAgICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID1cbiAgICAgICAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4biAoQS5UYWcudHlpZCBhdGFnKSAoQi5UYWcudHlpZCBidGFnKVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxldCBidGFnID0gKGJ0YWcgOiAodmFyaWFudCwgYXJncykgQi5UYWcudCkgaW5cbiAgICAgICAgICAgIEIuVmFyaWFudF9pbnRlcm5hbC5WYWx1ZSAoYnRhZywgYSkpXG4gICAgICAgICAgICBidGFnKVxuICAgICAgICAgIGF0YWdcbiAgICAgICAgICBhXG4gICAgaW5cbiAgICBCLlZhcmlhbnQuaW50ZXJuYWxfdXNlX29ubHkgeyBCLlZhcmlhbnRfaW50ZXJuYWwudHlwZW5hbWU7IHRhZ3M7IHBvbHltb3JwaGljOyB2YWx1ZSB9XG4gIDs7XG5cbiAgbGV0IG1hcF9yZWNvcmQgKHR5cGUgcmVjb3JkKSB7IG1hcCB9IChyZWNvcmQgOiByZWNvcmQgQS5SZWNvcmQudCkgPVxuICAgIGxldCBtYXBfZmllbGQgZmllbGQgPVxuICAgICAgbWF0Y2ggZmllbGQgd2l0aFxuICAgICAgfCBBLlJlY29yZC5GaWVsZCBmaWVsZCAtPlxuICAgICAgICBsZXQgbGFiZWwgPSBBLkZpZWxkLmxhYmVsIGZpZWxkIGluXG4gICAgICAgIGxldCByZXAgPSBtYXAgKEEuRmllbGQudHJhdmVyc2UgZmllbGQpIGluXG4gICAgICAgIGxldCBpbmRleCA9IEEuRmllbGQuaW5kZXggZmllbGQgaW5cbiAgICAgICAgbGV0IGlzX211dGFibGUgPSBBLkZpZWxkLmlzX211dGFibGUgZmllbGQgaW5cbiAgICAgICAgbGV0IHR5aWQgPSBBLkZpZWxkLnR5aWQgZmllbGQgaW5cbiAgICAgICAgbGV0IGdldCA9IEEuRmllbGQuZ2V0IGZpZWxkIGluXG4gICAgICAgIEIuUmVjb3JkX2ludGVybmFsLkZpZWxkXG4gICAgICAgICAgKEIuRmllbGQuaW50ZXJuYWxfdXNlX29ubHlcbiAgICAgICAgICAgICB7IEIuRmllbGRfaW50ZXJuYWwubGFiZWw7IHJlcDsgaW5kZXg7IGlzX211dGFibGU7IHR5aWQ7IGdldCB9KVxuICAgIGluXG4gICAgbGV0IHR5cGVuYW1lID0gQS5SZWNvcmQudHlwZW5hbWVfb2ZfdCByZWNvcmQgaW5cbiAgICBsZXQgaGFzX2RvdWJsZV9hcnJheV90YWcgPSBBLlJlY29yZC5oYXNfZG91YmxlX2FycmF5X3RhZyByZWNvcmQgaW5cbiAgICBsZXQgZmllbGRzID1cbiAgICAgIEFycmF5LmluaXQgKEEuUmVjb3JkLmxlbmd0aCByZWNvcmQpIChmdW4gaW5kZXggLT5cbiAgICAgICAgbWFwX2ZpZWxkIChBLlJlY29yZC5maWVsZCByZWNvcmQgaW5kZXgpKVxuICAgIGluXG4gICAgbGV0IGNyZWF0ZSB7IEIuUmVjb3JkX2ludGVybmFsLmdldCB9ID1cbiAgICAgIGxldCBnZXQgKHR5cGUgYSkgKGFmaWVsZCA6IChfLCBhKSBBLkZpZWxkLnQpID1cbiAgICAgICAgbWF0Y2ggZmllbGRzLihBLkZpZWxkLmluZGV4IGFmaWVsZCkgd2l0aFxuICAgICAgICB8IEIuUmVjb3JkX2ludGVybmFsLkZpZWxkIGJmaWVsZCAtPlxuICAgICAgICAgIChmdW4gKHR5cGUgZXgpIChiZmllbGQgOiAocmVjb3JkLCBleCkgQi5GaWVsZC50KSAtPlxuICAgICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9XG4gICAgICAgICAgICAgIFR5cGVuYW1lLnNhbWVfd2l0bmVzc19leG4gKEEuRmllbGQudHlpZCBhZmllbGQpIChCLkZpZWxkLnR5aWQgYmZpZWxkKVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxldCBiZmllbGQgPSAoYmZpZWxkIDogKHJlY29yZCwgYSkgQi5GaWVsZC50KSBpblxuICAgICAgICAgICAgZ2V0IGJmaWVsZClcbiAgICAgICAgICAgIGJmaWVsZFxuICAgICAgaW5cbiAgICAgIEEuUmVjb3JkLmNyZWF0ZSByZWNvcmQgeyBBLlJlY29yZC5nZXQgfVxuICAgIGluXG4gICAgQi5SZWNvcmQuaW50ZXJuYWxfdXNlX29ubHlcbiAgICAgIHsgQi5SZWNvcmRfaW50ZXJuYWwudHlwZW5hbWU7IGZpZWxkczsgaGFzX2RvdWJsZV9hcnJheV90YWc7IGNyZWF0ZSB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgTmFtZWQgPSBzaWdcbiAgdHlwZSAnYSBjb21wdXRhdGlvblxuXG4gIG1vZHVsZSBDb250ZXh0IDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgY3JlYXRlIDogdW5pdCAtPiB0XG4gIGVuZFxuXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBpbml0IDogQ29udGV4dC50IC0+ICdhIFR5cGVuYW1lLnQgLT4gJ2EgdFxuICB2YWwgZ2V0X3dpcF9jb21wdXRhdGlvbiA6ICdhIHQgLT4gJ2EgY29tcHV0YXRpb25cbiAgdmFsIHNldF9maW5hbF9jb21wdXRhdGlvbiA6ICdhIHQgLT4gJ2EgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgdmFsIHNoYXJlIDogXyBUeXBlcmVwLnQgLT4gYm9vbFxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXB1dGF0aW9uID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgVmFyaWFudF9hbmRfcmVjb3JkX2ludGYuUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIGludCA6IGludCB0XG4gIHZhbCBpbnQzMiA6IGludDMyIHRcbiAgdmFsIGludDY0IDogaW50NjQgdFxuICB2YWwgbmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgdmFsIGNoYXIgOiBjaGFyIHRcbiAgdmFsIGZsb2F0IDogZmxvYXQgdFxuICB2YWwgc3RyaW5nIDogc3RyaW5nIHRcbiAgdmFsIGJ5dGVzIDogYnl0ZXMgdFxuICB2YWwgYm9vbCA6IGJvb2wgdFxuICB2YWwgdW5pdCA6IHVuaXQgdFxuICB2YWwgb3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICB2YWwgbGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gIHZhbCBhcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICB2YWwgbGF6eV90IDogJ2EgdCAtPiAnYSBsYXp5X3QgdFxuICB2YWwgcmVmXyA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgdmFsIGZ1bmN0aW9uXyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgLT4gJ2IpIHRcbiAgdmFsIHR1cGxlMiA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgKiAnYikgdFxuICB2YWwgdHVwbGUzIDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gKCdhICogJ2IgKiAnYykgdFxuICB2YWwgdHVwbGU0IDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gJ2QgdCAtPiAoJ2EgKiAnYiAqICdjICogJ2QpIHRcbiAgdmFsIHR1cGxlNSA6ICdhIHQgLT4gJ2IgdCAtPiAnYyB0IC0+ICdkIHQgLT4gJ2UgdCAtPiAoJ2EgKiAnYiAqICdjICogJ2QgKiAnZSkgdFxuICB2YWwgcmVjb3JkIDogJ2EgUmVjb3JkLnQgLT4gJ2EgdFxuICB2YWwgdmFyaWFudCA6ICdhIFZhcmlhbnQudCAtPiAnYSB0XG5cbiAgbW9kdWxlIE5hbWVkIDogTmFtZWQgd2l0aCB0eXBlICdhIGNvbXB1dGF0aW9uIDo9ICdhIHRcbmVuZFxuXG4oKiBzcGVjaWFsIGZ1bmN0b3IgYXBwbGljYXRpb24gZm9yIGNvbXB1dGF0aW9uIGFzIGNsb3N1cmUgb2YgdGhlIGZvcm0gW2EgLT4gYl0gKilcbm1vZHVsZSBNYWtlX25hbWVkX2Zvcl9jbG9zdXJlIChYIDogc2lnXG4gIHR5cGUgJ2EgaW5wdXRcbiAgdHlwZSAnYSBvdXRwdXRcbiAgdHlwZSAnYSB0ID0gJ2EgaW5wdXQgLT4gJ2Egb3V0cHV0XG5lbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgQ29udGV4dCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IHVuaXRcblxuICAgIGxldCBjcmVhdGUgPSBpZ25vcmVcbiAgZW5kXG5cbiAgdHlwZSAnYSB0ID1cbiAgICB7IHJ1bnRpbWVfZGVyZWZlcmVuY2UgOiAnYSBYLnRcbiAgICA7IHJ1bnRpbWVfcmVmZXJlbmNlIDogJ2EgWC50IHJlZlxuICAgIDsgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgOiAnYSBYLnQgb3B0aW9uIHJlZlxuICAgIH1cblxuICBleGNlcHRpb24gVW5kZWZpbmVkIG9mIHN0cmluZ1xuXG4gIGxldCBpbml0ICgpIG5hbWUgPVxuICAgIGxldCBwYXRoID0gVHlwZW5hbWUuVWlkLm5hbWUgKFR5cGVuYW1lLnVpZCBuYW1lKSBpblxuICAgIGxldCByID0gcmVmIChmdW4gXyAtPiByYWlzZSAoVW5kZWZpbmVkIHBhdGgpKSBpblxuICAgIHsgcnVudGltZV9kZXJlZmVyZW5jZSA9IChmdW4gaW5wdXQgLT4gIXIgaW5wdXQpXG4gICAgOyBydW50aW1lX3JlZmVyZW5jZSA9IHJcbiAgICA7IGNvbXBpbGV0aW1lX2RlcmVmZXJlbmNlID0gcmVmIE5vbmVcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGdldF93aXBfY29tcHV0YXRpb24gc2hhcmVkID1cbiAgICBtYXRjaCBzaGFyZWQuY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UuY29udGVudHMgd2l0aFxuICAgIHwgU29tZSBjbG9zIC0+IGNsb3NcbiAgICB8IE5vbmUgLT4gc2hhcmVkLnJ1bnRpbWVfZGVyZWZlcmVuY2VcbiAgOztcblxuICBsZXQgc2V0X2ZpbmFsX2NvbXB1dGF0aW9uIHNoYXJlZCBjb21wdXRhdGlvbiA9XG4gICAgbGV0IGNvbXBpbGV0aW1lX2RlcmVmZXJlbmNlID0gc2hhcmVkLmNvbXBpbGV0aW1lX2RlcmVmZXJlbmNlIGluXG4gICAgbWF0Y2ggY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UuY29udGVudHMgd2l0aFxuICAgIHwgU29tZSBfIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgTm9uZSAtPlxuICAgICAgaWYgQmFzZS5waHlzX2VxdWFsIHNoYXJlZC5ydW50aW1lX2RlcmVmZXJlbmNlIGNvbXB1dGF0aW9uIHRoZW4gYXNzZXJ0IGZhbHNlO1xuICAgICAgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgOj0gU29tZSBjb21wdXRhdGlvbjtcbiAgICAgIHNoYXJlZC5ydW50aW1lX3JlZmVyZW5jZSA6PSBjb21wdXRhdGlvbjtcbiAgICAgIGNvbXB1dGF0aW9uXG4gIDs7XG5cbiAgbGV0IHNoYXJlIF8gPSB0cnVlXG5lbmRcblxubW9kdWxlIElkZW50ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBuYW1lIDogc3RyaW5nXG4gICAgOyBpbXBsZW1lbnRzIDogVHlwZW5hbWUuVWlkLnQgLT4gYm9vbFxuICAgIH1cblxuICBleGNlcHRpb24gQnJva2VuX2RlcGVuZGVuY3kgb2Ygc3RyaW5nXG5cbiAgbGV0IGNoZWNrX2RlcGVuZGVuY2llcyBuYW1lIHJlcXVpcmVkID1cbiAgICBtYXRjaCByZXF1aXJlZCB3aXRoXG4gICAgfCBbXSAtPiBmdW4gXyAtPiAoKVxuICAgIHwgXyAtPlxuICAgICAgZnVuIHVpZCAtPlxuICAgICAgICBMaXN0Lml0ZXJcbiAgICAgICAgICAoZnVuIHsgbmFtZSA9IG5hbWUnOyBpbXBsZW1lbnRzIH0gLT5cbiAgICAgICAgICAgIGlmIG5vdCAoaW1wbGVtZW50cyB1aWQpXG4gICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgKCogc29tZXRoaW5nIGlzIHdyb25nIHdpdGggdGhlIHNldCB1cCwgdGhpcyBpcyBhbiBlcnJvciBkdXJpbmcgdGhlXG4gICAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvbiBvZiB0aGUgcHJvZ3JhbSwgd2UgcmF0aGVyIGZhaWwgd2l0aCBhIGh1bWFuXG4gICAgICAgICAgICAgICAgICByZWFkYWJsZSBvdXRwdXQgKilcbiAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmXG4gICAgICAgICAgICAgICAgICBcIlR5cGVfZ2VuZXJpYyAlUyByZXF1aXJlcyAlUyBmb3IgdWlkICVTXFxuXCJcbiAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgIG5hbWUnXG4gICAgICAgICAgICAgICAgICAoVHlwZW5hbWUuVWlkLm5hbWUgdWlkKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBwcmVycl9lbmRsaW5lIG1lc3NhZ2U7XG4gICAgICAgICAgICAgIHJhaXNlIChCcm9rZW5fZGVwZW5kZW5jeSBtZXNzYWdlKSkpXG4gICAgICAgICAgcmVxdWlyZWRcbiAgOztcbmVuZFxuXG4oKiBFeHRlbmRpbmcgYW4gZXhpc3RpbmcgZ2VuZXJpYyAqKVxubW9kdWxlIHR5cGUgRXh0ZW5kaW5nID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIGNvbXB1dGF0aW9uID0gJ2EgdFxuXG4gIHZhbCBpZGVudCA6IElkZW50LnRcblxuICAoKiBnZW5lcmljX2lkZW50ICogdHlwZW5hbWUgb3IgaW5mbyAqKVxuICBleGNlcHRpb24gTm90X2ltcGxlbWVudGVkIG9mIHN0cmluZyAqIHN0cmluZ1xuXG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6IHQgY29tcHV0YXRpb25cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBjb21wdXRhdGlvbiAtPiAnYSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wdXRlIDogJ2EgY29tcHV0YXRpb24gLT4gJ2IgY29tcHV0YXRpb24gLT4gKCdhLCAnYikgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gKCdhLCAnYiwgJ2MpIHQgY29tcHV0YXRpb25cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzQgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNCB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0IDo9ICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogICdhIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYiBjb21wdXRhdGlvblxuICAgICAgLT4gJ2MgY29tcHV0YXRpb25cbiAgICAgIC0+ICdkIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYywgJ2QpIHQgY29tcHV0YXRpb25cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzUgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzUgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgOj0gKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogICdhIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYiBjb21wdXRhdGlvblxuICAgICAgLT4gJ2MgY29tcHV0YXRpb25cbiAgICAgIC0+ICdkIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnZSBjb21wdXRhdGlvblxuICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICB2YWwgcmVnaXN0ZXIwIDogKG1vZHVsZSBTKSAtPiB1bml0XG4gIHZhbCByZWdpc3RlcjEgOiAobW9kdWxlIFMxKSAtPiB1bml0XG4gIHZhbCByZWdpc3RlcjIgOiAobW9kdWxlIFMyKSAtPiB1bml0XG4gIHZhbCByZWdpc3RlcjMgOiAobW9kdWxlIFMzKSAtPiB1bml0XG4gIHZhbCByZWdpc3RlcjQgOiAobW9kdWxlIFM0KSAtPiB1bml0XG4gIHZhbCByZWdpc3RlcjUgOiAobW9kdWxlIFM1KSAtPiB1bml0XG5cbiAgKCogc3BlY2lhbCBsZXNzIHNjYXJ5IHR5cGUgd2hlbiB0aGUgdHlwZSBoYXMgbm8gcGFyYW1ldGVycyAqKVxuICB2YWwgcmVnaXN0ZXIgOiAnYSBUeXBlcmVwLnQgLT4gJ2EgY29tcHV0YXRpb24gLT4gdW5pdFxuXG4gICgqXG4gICAgIEVzc2VudGlhbGx5IGJlY2F1c2Ugd2UgY2Fubm90IHRhbGsgYWJvdXQgYSB2YXJpYWJsZSBvZiBraW5kICogLT4ga1xuICAgICB2YWwgcmVnaXN0ZXIxIDogJ2EgJ3QgVHlwZXJlcC50IC0+ICgnYSBjb21wdXRhdGlvbiAtPiAnYSAndCBjb21wdXRhdGlvbikgLT4gdW5pdFxuICAgICAuLi5cbiAgKilcbmVuZFxuXG4oKiBJbXBsZW1lbnRpbmcgYSBuZXcgZ2VuZXJpYyAqKVxubW9kdWxlIHR5cGUgU19pbXBsZW1lbnRhdGlvbiA9IHNpZ1xuICBpbmNsdWRlIEV4dGVuZGluZ1xuXG4gICgqIHJhaXNlIHVzaW5nIHRoZSBjdXJyZW50IGlkZW50ICopXG4gIHZhbCByYWlzZV9ub3RfaW1wbGVtZW50ZWQgOiBzdHJpbmcgLT4gJ2FcblxuICB0eXBlIGltcGxlbWVudGF0aW9uID0geyBnZW5lcmljIDogJ2EuICdhIFR5cGVyZXAudCAtPiAnYSBjb21wdXRhdGlvbiB9XG5cbiAgKCpcbiAgICAgU3RhbmRhcmQgY2FzZSwgZmluZCBhIGV4dGVuZGVkX2ltcGxlbWVudGF0aW9uLCBvciBsb29rIGluIHRoZSBjb250ZW50XG4gICopXG4gIHZhbCBfdXNpbmdfZXh0ZW5kZWRfaW1wbGVtZW50YXRpb25cbiAgICA6ICBpbXBsZW1lbnRhdGlvblxuICAgIC0+ICdhIFR5cGVyZXAuTmFtZWQudFxuICAgIC0+ICdhIFR5cGVyZXAudCBsYXp5X3Qgb3B0aW9uXG4gICAgLT4gJ2EgY29tcHV0YXRpb25cblxuICAoKlxuICAgICBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgbW9yZSBjb250cm9sIG9uIHdoYXQgeW91IHdhbnQgdG8gZG9cbiAgKilcbiAgdmFsIGZpbmRfZXh0ZW5kZWRfaW1wbGVtZW50YXRpb25cbiAgICA6ICBpbXBsZW1lbnRhdGlvblxuICAgIC0+ICdhIFR5cGVyZXAuTmFtZWQudFxuICAgIC0+ICdhIGNvbXB1dGF0aW9uIG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgaW5jbHVkZSBFeHRlbmRpbmdcblxuICB2YWwgb2ZfdHlwZXJlcCA6ICdhIFR5cGVyZXAudCAtPiBbIGBnZW5lcmljIG9mICdhIGNvbXB1dGF0aW9uIF1cblxuICBtb2R1bGUgQ29tcHV0YXRpb24gOiBDb21wdXRhdGlvbiB3aXRoIHR5cGUgJ2EgdCA9ICdhIHRcbmVuZFxuXG5tb2R1bGUgTWFrZV9TX2ltcGxlbWVudGF0aW9uIChYIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBuYW1lIDogc3RyaW5nXG4gIHZhbCByZXF1aXJlZCA6IElkZW50LnQgbGlzdFxuZW5kKSA6IFNfaW1wbGVtZW50YXRpb24gd2l0aCB0eXBlICdhIHQgPSAnYSBYLnQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgWC50XG4gIHR5cGUgJ2EgY29tcHV0YXRpb24gPSAnYSB0XG5cbiAgaW5jbHVkZSBUeXBlX2dlbmVyaWNfaW50Zi5NIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICBlbmQpXG5cbiAgKCogd2UgZG8gbm90IHVzZSBjb3JlIHNpbmNlIHdlIGFyZSBlYXJsaWVyIGluIHRoZSBkZXBlbmRlbmNpZXMgZ3JhcGggKilcbiAgbW9kdWxlIFVpZF90YWJsZSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgSGFzaHRibC5NYWtlIChUeXBlbmFtZS5VaWQpXG5cbiAgICBsZXQgZmluZCB0YWJsZSBrZXkgPVxuICAgICAgaWYgTGF6eS5pc192YWwgdGFibGVcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgdGFibGUgPSBMYXp5LmZvcmNlIHRhYmxlIGluXG4gICAgICAgIHRyeSBTb21lIChmaW5kIHRhYmxlIGtleSkgd2l0aFxuICAgICAgICB8IEJhc2UuTm90X2ZvdW5kX3MgXyB8IFN0ZGxpYi5Ob3RfZm91bmQgLT4gTm9uZSlcbiAgICAgIGVsc2UgTm9uZVxuICAgIDs7XG5cbiAgICBsZXQgY2hlY2tfZGVwZW5kZW5jaWVzID0gSWRlbnQuY2hlY2tfZGVwZW5kZW5jaWVzIFgubmFtZSBYLnJlcXVpcmVkXG5cbiAgICBsZXQgcmVwbGFjZSB0YWJsZSBrZXkgdmFsdWUgPVxuICAgICAgY2hlY2tfZGVwZW5kZW5jaWVzIGtleTtcbiAgICAgIHJlcGxhY2UgKExhenkuZm9yY2UgdGFibGUpIGtleSB2YWx1ZVxuICAgIDs7XG5cbiAgICBsZXQgbWVtIHRhYmxlIGtleSA9XG4gICAgICBpZiBMYXp5LmlzX3ZhbCB0YWJsZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0YWJsZSA9IExhenkuZm9yY2UgdGFibGUgaW5cbiAgICAgICAgbWVtIHRhYmxlIGtleSlcbiAgICAgIGVsc2UgZmFsc2VcbiAgICA7O1xuICBlbmRcblxuICBsZXQgc2l6ZSA9IDI1NlxuICBsZXQgdGFibGUwID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUxID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUyID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUzID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGU0ID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGU1ID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuXG4gIGxldCBpc19yZWdpc3RlcmVkIHVpZCA9XG4gICAgVWlkX3RhYmxlLm1lbSB0YWJsZTAgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTEgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTIgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTMgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTQgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTUgdWlkXG4gIDs7XG5cbiAgbGV0IGlkZW50ID0geyBJZGVudC5uYW1lID0gWC5uYW1lOyBpbXBsZW1lbnRzID0gaXNfcmVnaXN0ZXJlZCB9XG5cbiAgbW9kdWxlIEZpbmQwIChUIDogVHlwZXJlcC5OYW1lZC5UMCkgOiBzaWdcbiAgICB2YWwgY29tcHV0ZSA6IHVuaXQgLT4gVC5uYW1lZCBjb21wdXRhdGlvbiBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGUwIChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFMgPSAodmFsIHJlcCA6IFMpIGluXG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4biBTLnR5cGVuYW1lX29mX3QgVC50eXBlbmFtZV9vZl9uYW1lZCBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSAoVHlwZV9lcXVhbC5jb252IChMLmxpZnQgd2l0bmVzcykgUy5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kMSAoVCA6IFR5cGVyZXAuTmFtZWQuVDEpIDogc2lnXG4gICAgdmFsIGNvbXB1dGUgOiB1bml0IC0+IChULmEgY29tcHV0YXRpb24gLT4gVC5hIFQubmFtZWQgY29tcHV0YXRpb24pIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTEgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzEgPSAodmFsIHJlcCA6IFMxKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fMVxuICAgICAgICAgICAgKFMxKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICdhIHQgPSAnYSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9IFQuYSBjb21wdXRhdGlvbiAtPiAnYSBjb21wdXRhdGlvblxuICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSAoVHlwZV9lcXVhbC5jb252IChMLmxpZnQgQ29udi4od2l0bmVzcy5lcSkpIFMxLmNvbXB1dGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEZpbmQyIChUIDogVHlwZXJlcC5OYW1lZC5UMikgOiBzaWdcbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgdW5pdFxuICAgICAgLT4gKFQuYSBjb21wdXRhdGlvbiAtPiBULmIgY29tcHV0YXRpb24gLT4gKFQuYSwgVC5iKSBULm5hbWVkIGNvbXB1dGF0aW9uKSBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGUyIChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFMyID0gKHZhbCByZXAgOiBTMikgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzJcbiAgICAgICAgICAgIChTMilcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgVC5uYW1lZFxuXG4gICAgICAgICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVC50eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPSBULmEgY29tcHV0YXRpb24gLT4gVC5iIGNvbXB1dGF0aW9uIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzIuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmluZDMgKFQgOiBUeXBlcmVwLk5hbWVkLlQzKSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICB1bml0XG4gICAgICAtPiAoVC5hIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gKFQuYSwgVC5iLCBULmMpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGUzIChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFMzID0gKHZhbCByZXAgOiBTMykgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzNcbiAgICAgICAgICAgIChTMylcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgICAgICAgIFQuYSBjb21wdXRhdGlvbiAtPiBULmIgY29tcHV0YXRpb24gLT4gVC5jIGNvbXB1dGF0aW9uIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzMuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmluZDQgKFQgOiBUeXBlcmVwLk5hbWVkLlQ0KSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICB1bml0XG4gICAgICAtPiAoVC5hIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5kIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gKFQuYSwgVC5iLCBULmMsIFQuZCkgVC5uYW1lZCBjb21wdXRhdGlvbilcbiAgICAgICAgIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTQgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzQgPSAodmFsIHJlcCA6IFM0KSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fNFxuICAgICAgICAgICAgKFM0KVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdCA9ICgnYSwgJ2IsICdjLCAnZCkgVC5uYW1lZFxuXG4gICAgICAgICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVC50eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPVxuICAgICAgICAgICAgICBULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuYyBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTNC5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kNSAoVCA6IFR5cGVyZXAuTmFtZWQuVDUpIDogc2lnXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogIHVuaXRcbiAgICAgIC0+IChULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmUgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiAoVC5hLCBULmIsIFQuYywgVC5kLCBULmUpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGU1IChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFM1ID0gKHZhbCByZXAgOiBTNSkgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzVcbiAgICAgICAgICAgIChTNSlcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0ID0gKCdhLCAnYiwgJ2MsICdkLCAnZSkgVC5uYW1lZFxuXG4gICAgICAgICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVC50eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPVxuICAgICAgICAgICAgICBULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuYyBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5lIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzUuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgdW5pdCA9IFR5cGVuYW1lLnN0YXRpY1xuXG4gIGxldCByZWdpc3RlcjAgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTID0gKHZhbCBjb21wdXRlIDogUykgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIFMudHlwZW5hbWVfb2ZfdCBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMCB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjEgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTMSA9ICh2YWwgY29tcHV0ZSA6IFMxKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFMxLnR5cGVuYW1lX29mX3QgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTEgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIyIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzIgPSAodmFsIGNvbXB1dGUgOiBTMikgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTMi50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTIgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIzIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzMgPSAodmFsIGNvbXB1dGUgOiBTMykgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTMy50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMyB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjQgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTNCA9ICh2YWwgY29tcHV0ZSA6IFM0KSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFM0LnR5cGVuYW1lX29mX3QgdW5pdCB1bml0IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTQgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXI1IGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzUgPSAodmFsIGNvbXB1dGUgOiBTNSkgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTNS50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCB1bml0IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTUgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIgKHR5cGUgYSkgdHlwZXJlcF9vZl9hIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUyA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gYVxuXG4gICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFR5cGVyZXAudHlwZW5hbWVfb2ZfdCB0eXBlcmVwX29mX2FcbiAgICAgIGxldCB0eXBlcmVwX29mX3QgPSB0eXBlcmVwX29mX2FcbiAgICAgIGxldCBjb21wdXRlID0gY29tcHV0ZVxuICAgIGVuZFxuICAgIGluXG4gICAgcmVnaXN0ZXIwIChtb2R1bGUgUyA6IFMpXG4gIDs7XG5cbiAgKCogSU1QTEVNRU5UQVRJT04gKilcblxuICB0eXBlIGltcGxlbWVudGF0aW9uID0geyBnZW5lcmljIDogJ2EuICdhIFR5cGVyZXAudCAtPiAnYSBjb21wdXRhdGlvbiB9XG5cbiAgbGV0IGZpbmRfZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24gKHR5cGUgYSkgYXV4ID0gZnVuY3Rpb25cbiAgICB8IFR5cGVyZXAuTmFtZWQuVDAgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDAgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMCAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDEgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDEgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMSAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9IChjdXN0b20gKGF1eC5nZW5lcmljIFQuYSkgOiBULmEgVC5uYW1lZCBjb21wdXRhdGlvbikgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQyIHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQyIHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDIgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIDogKFQuYSwgVC5iKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQzIHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQzIHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDMgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIChhdXguZ2VuZXJpYyBULmMpXG4gICAgICAgICAgICAgOiAoVC5hLCBULmIsIFQuYykgVC5uYW1lZCBjb21wdXRhdGlvbilcbiAgICAgICAgIGluXG4gICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID0gVC53aXRuZXNzIGluXG4gICAgICAgICBTb21lIChjdXN0b20gOiBhIGNvbXB1dGF0aW9uKVxuICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIHwgVHlwZXJlcC5OYW1lZC5UNCByZXAgLT5cbiAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVHlwZXJlcC5OYW1lZC5UNCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICBsZXQgbW9kdWxlIEN1c3RvbSA9IEZpbmQ0IChUKSBpblxuICAgICAgKG1hdGNoIEN1c3RvbS5jb21wdXRlICgpIHdpdGhcbiAgICAgICB8IFNvbWUgY3VzdG9tIC0+XG4gICAgICAgICBsZXQgY3VzdG9tID1cbiAgICAgICAgICAgKGN1c3RvbSAoYXV4LmdlbmVyaWMgVC5hKSAoYXV4LmdlbmVyaWMgVC5iKSAoYXV4LmdlbmVyaWMgVC5jKSAoYXV4LmdlbmVyaWMgVC5kKVxuICAgICAgICAgICAgIDogKFQuYSwgVC5iLCBULmMsIFQuZCkgVC5uYW1lZCBjb21wdXRhdGlvbilcbiAgICAgICAgIGluXG4gICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID0gVC53aXRuZXNzIGluXG4gICAgICAgICBTb21lIChjdXN0b20gOiBhIGNvbXB1dGF0aW9uKVxuICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIHwgVHlwZXJlcC5OYW1lZC5UNSByZXAgLT5cbiAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVHlwZXJlcC5OYW1lZC5UNSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICBsZXQgbW9kdWxlIEN1c3RvbSA9IEZpbmQ1IChUKSBpblxuICAgICAgKG1hdGNoIEN1c3RvbS5jb21wdXRlICgpIHdpdGhcbiAgICAgICB8IFNvbWUgY3VzdG9tIC0+XG4gICAgICAgICBsZXQgY3VzdG9tID1cbiAgICAgICAgICAgKGN1c3RvbVxuICAgICAgICAgICAgICAoYXV4LmdlbmVyaWMgVC5hKVxuICAgICAgICAgICAgICAoYXV4LmdlbmVyaWMgVC5iKVxuICAgICAgICAgICAgICAoYXV4LmdlbmVyaWMgVC5jKVxuICAgICAgICAgICAgICAoYXV4LmdlbmVyaWMgVC5kKVxuICAgICAgICAgICAgICAoYXV4LmdlbmVyaWMgVC5lKVxuICAgICAgICAgICAgIDogKFQuYSwgVC5iLCBULmMsIFQuZCwgVC5lKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gIDs7XG5cbiAgZXhjZXB0aW9uIE5vdF9pbXBsZW1lbnRlZCBvZiBzdHJpbmcgKiBzdHJpbmdcblxuICBsZXQgcmFpc2Vfbm90X2ltcGxlbWVudGVkIHN0cmluZyA9IHJhaXNlIChOb3RfaW1wbGVtZW50ZWQgKFgubmFtZSwgc3RyaW5nKSlcblxuICBsZXQgX3VzaW5nX2V4dGVuZGVkX2ltcGxlbWVudGF0aW9uIGF1eCByZXAgY29udGVudCA9XG4gICAgbWF0Y2ggZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiBhdXggcmVwIHdpdGhcbiAgICB8IFNvbWUgY29tcHV0YXRpb24gLT4gY29tcHV0YXRpb25cbiAgICB8IE5vbmUgLT5cbiAgICAgIChtYXRjaCBjb250ZW50IHdpdGhcbiAgICAgICB8IFNvbWUgKGxhenkgY29udGVudCkgLT4gYXV4LmdlbmVyaWMgY29udGVudFxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgbGV0IHR5cGVuYW1lID0gVHlwZXJlcC5OYW1lZC50eXBlbmFtZV9vZl90IHJlcCBpblxuICAgICAgICAgbGV0IG5hbWUgPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkIHR5cGVuYW1lKSBpblxuICAgICAgICAgcmFpc2Vfbm90X2ltcGxlbWVudGVkIG5hbWUpXG4gIDs7XG5lbmRcblxubW9kdWxlIF8gPSBIYXNodGJsLk1ha2UgKFR5cGVuYW1lLktleSlcblxubW9kdWxlIE1ha2UgKFggOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIG5hbWUgOiBzdHJpbmdcbiAgdmFsIHJlcXVpcmVkIDogSWRlbnQudCBsaXN0XG5cbiAgaW5jbHVkZSBDb21wdXRhdGlvbiB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5lbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgQ29tcHV0YXRpb24gPSBYXG4gIGluY2x1ZGUgTWFrZV9TX2ltcGxlbWVudGF0aW9uIChYKVxuXG4gIG1vZHVsZSBNZW1vID0gVHlwZW5hbWUuVGFibGUgKHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIFguTmFtZWQudFxuICBlbmQpXG5cbiAgbW9kdWxlIEhlbHBlciA9IEhlbHBlciAoVHlwZXJlcCkgKENvbXB1dGF0aW9uKVxuXG4gIGxldCBvZl90eXBlcmVwIHJlcCA9XG4gICAgbGV0IGNvbnRleHQgPSBYLk5hbWVkLkNvbnRleHQuY3JlYXRlICgpIGluXG4gICAgbGV0IG1lbW9fdGFibGUgPSBNZW1vLmNyZWF0ZSAzMiBpblxuICAgIGxldCByZWMgb2ZfdHlwZXJlcCA6IHR5cGUgYS4gYSBUeXBlcmVwLnQgLT4gYSB0ID0gZnVuY3Rpb25cbiAgICAgIHwgVHlwZXJlcC5JbnQgLT4gWC5pbnRcbiAgICAgIHwgVHlwZXJlcC5JbnQzMiAtPiBYLmludDMyXG4gICAgICB8IFR5cGVyZXAuSW50NjQgLT4gWC5pbnQ2NFxuICAgICAgfCBUeXBlcmVwLk5hdGl2ZWludCAtPiBYLm5hdGl2ZWludFxuICAgICAgfCBUeXBlcmVwLkNoYXIgLT4gWC5jaGFyXG4gICAgICB8IFR5cGVyZXAuRmxvYXQgLT4gWC5mbG9hdFxuICAgICAgfCBUeXBlcmVwLlN0cmluZyAtPiBYLnN0cmluZ1xuICAgICAgfCBUeXBlcmVwLkJ5dGVzIC0+IFguYnl0ZXNcbiAgICAgIHwgVHlwZXJlcC5Cb29sIC0+IFguYm9vbFxuICAgICAgfCBUeXBlcmVwLlVuaXQgLT4gWC51bml0XG4gICAgICB8IFR5cGVyZXAuT3B0aW9uIHJlcCAtPiBYLm9wdGlvbiAob2ZfdHlwZXJlcCByZXApXG4gICAgICB8IFR5cGVyZXAuTGlzdCByZXAgLT4gWC5saXN0IChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5BcnJheSByZXAgLT4gWC5hcnJheSAob2ZfdHlwZXJlcCByZXApXG4gICAgICB8IFR5cGVyZXAuTGF6eSByZXAgLT4gWC5sYXp5X3QgKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLlJlZiByZXAgLT4gWC5yZWZfIChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5GdW5jdGlvbiAoZG9tLCBybmcpIC0+IFguZnVuY3Rpb25fIChvZl90eXBlcmVwIGRvbSkgKG9mX3R5cGVyZXAgcm5nKVxuICAgICAgfCBUeXBlcmVwLlR1cGxlIHR1cGxlIC0+XG4gICAgICAgICgqIGRvIE5PVCB3cml0ZSBbWC50dXBsZTIgKG9mX3R5cGVyZXAgYSkgKG9mX3R5cGVyZXAgYildXG4gICAgICAgICAgIGJlY2F1c2Ugb2ZfdHlwZXJlcCBjYW4gY29udGFpbiBhIHNpZGUgZWZmZWN0IGFuZCBbYV0gc2hvdWxkIGJlIGV4ZWN1dGVkXG4gICAgICAgICAgIGJlZm9yZSBbYl0gKilcbiAgICAgICAgKG1hdGNoIHR1cGxlIHdpdGhcbiAgICAgICAgIHwgVHlwZXJlcC5UdXBsZS5UMiAoYSwgYikgLT5cbiAgICAgICAgICAgbGV0IHJhID0gb2ZfdHlwZXJlcCBhIGluXG4gICAgICAgICAgIGxldCByYiA9IG9mX3R5cGVyZXAgYiBpblxuICAgICAgICAgICBYLnR1cGxlMiByYSByYlxuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQzIChhLCBiLCBjKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIGxldCByYyA9IG9mX3R5cGVyZXAgYyBpblxuICAgICAgICAgICBYLnR1cGxlMyByYSByYiByY1xuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ0IChhLCBiLCBjLCBkKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIGxldCByYyA9IG9mX3R5cGVyZXAgYyBpblxuICAgICAgICAgICBsZXQgcmQgPSBvZl90eXBlcmVwIGQgaW5cbiAgICAgICAgICAgWC50dXBsZTQgcmEgcmIgcmMgcmRcbiAgICAgICAgIHwgVHlwZXJlcC5UdXBsZS5UNSAoYSwgYiwgYywgZCwgZSkgLT5cbiAgICAgICAgICAgbGV0IHJhID0gb2ZfdHlwZXJlcCBhIGluXG4gICAgICAgICAgIGxldCByYiA9IG9mX3R5cGVyZXAgYiBpblxuICAgICAgICAgICBsZXQgcmMgPSBvZl90eXBlcmVwIGMgaW5cbiAgICAgICAgICAgbGV0IHJkID0gb2ZfdHlwZXJlcCBkIGluXG4gICAgICAgICAgIGxldCByZSA9IG9mX3R5cGVyZXAgZSBpblxuICAgICAgICAgICBYLnR1cGxlNSByYSByYiByYyByZCByZSlcbiAgICAgIHwgVHlwZXJlcC5SZWNvcmQgcmVjb3JkIC0+XG4gICAgICAgIFgucmVjb3JkIChIZWxwZXIubWFwX3JlY29yZCB7IEhlbHBlci5tYXAgPSBvZl90eXBlcmVwIH0gcmVjb3JkKVxuICAgICAgfCBUeXBlcmVwLlZhcmlhbnQgdmFyaWFudCAtPlxuICAgICAgICBYLnZhcmlhbnQgKEhlbHBlci5tYXBfdmFyaWFudCB7IEhlbHBlci5tYXAgPSBvZl90eXBlcmVwIH0gdmFyaWFudClcbiAgICAgIHwgVHlwZXJlcC5OYW1lZCAobmFtZWQsIGNvbnRlbnQpIC0+XG4gICAgICAgIGxldCB0eXBlbmFtZSA9IFR5cGVyZXAuTmFtZWQudHlwZW5hbWVfb2ZfdCBuYW1lZCBpblxuICAgICAgICAobWF0Y2ggTWVtby5maW5kIG1lbW9fdGFibGUgdHlwZW5hbWUgd2l0aFxuICAgICAgICAgfCBTb21lIHNoYXJlZCAtPiBYLk5hbWVkLmdldF93aXBfY29tcHV0YXRpb24gc2hhcmVkXG4gICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgKG1hdGNoIGZpbmRfZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24geyBnZW5lcmljID0gb2ZfdHlwZXJlcCB9IG5hbWVkIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBjb21wdXRhdGlvbiAtPiBjb21wdXRhdGlvblxuICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBjb250ZW50IHdpdGhcbiAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IFR5cGVuYW1lLlVpZC5uYW1lIChUeXBlbmFtZS51aWQgdHlwZW5hbWUpIGluXG4gICAgICAgICAgICAgICAgIHJhaXNlX25vdF9pbXBsZW1lbnRlZCBuYW1lXG4gICAgICAgICAgICAgICB8IFNvbWUgKGxhenkgY29udGVudCkgLT5cbiAgICAgICAgICAgICAgICAgaWYgWC5OYW1lZC5zaGFyZSBjb250ZW50XG4gICAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICAgIGxldCBzaGFyZWQgPSBYLk5hbWVkLmluaXQgY29udGV4dCB0eXBlbmFtZSBpblxuICAgICAgICAgICAgICAgICAgIE1lbW8uc2V0IG1lbW9fdGFibGUgdHlwZW5hbWUgc2hhcmVkO1xuICAgICAgICAgICAgICAgICAgIGxldCBjb21wdXRhdGlvbiA9IG9mX3R5cGVyZXAgY29udGVudCBpblxuICAgICAgICAgICAgICAgICAgIFguTmFtZWQuc2V0X2ZpbmFsX2NvbXB1dGF0aW9uIHNoYXJlZCBjb21wdXRhdGlvbilcbiAgICAgICAgICAgICAgICAgZWxzZSBvZl90eXBlcmVwIGNvbnRlbnQpKSlcbiAgICBpblxuICAgIGxldCBjb21wdXRhdGlvbiA9IG9mX3R5cGVyZXAgcmVwIGluXG4gICAgYGdlbmVyaWMgY29tcHV0YXRpb25cbiAgOztcbmVuZFxuIiwib3BlbiBTdGRfaW50ZXJuYWxcblxubW9kdWxlIE1ha2UwIChYIDogTmFtZWRfaW50Zi5TMCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UwIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgPVxuICAgIFR5cGVyZXAuTmFtZWQuVDBcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgbmFtZWQgPSBYLnRcbiAgICAgICAgdHlwZSB0ID0gWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQwXG4gICAgICAgIHdpdGggdHlwZSB0ID0gWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlMSAoWCA6IE5hbWVkX2ludGYuUzEpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlMSAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxKSBvZl9wMSA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdCAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKSBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDFcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgJ2EgbmFtZWQgPSAnYSBYLnRcbiAgICAgICAgdHlwZSBhID0gcDFcblxuICAgICAgICBsZXQgYSA9IG9mX3AxXG5cbiAgICAgICAgdHlwZSB0ID0gcDEgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQxXG4gICAgICAgIHdpdGggdHlwZSB0ID0gcDEgWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlMiAoWCA6IE5hbWVkX2ludGYuUzIpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlMiAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxIHAyKSBvZl9wMSBvZl9wMiA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPVxuICAgICAgTmFtZV9vZl94LnR5cGVuYW1lX29mX3QgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMSkgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMilcbiAgICBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDJcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgKCdhLCAnYikgbmFtZWQgPSAoJ2EsICdiKSBYLnRcbiAgICAgICAgdHlwZSBhID0gcDFcblxuICAgICAgICBsZXQgYSA9IG9mX3AxXG5cbiAgICAgICAgdHlwZSBiID0gcDJcblxuICAgICAgICBsZXQgYiA9IG9mX3AyXG5cbiAgICAgICAgdHlwZSB0ID0gKHAxLCBwMikgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQyXG4gICAgICAgIHdpdGggdHlwZSB0ID0gKHAxLCBwMikgWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlMyAoWCA6IE5hbWVkX2ludGYuUzMpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlMyAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxIHAyIHAzKSBvZl9wMSBvZl9wMiBvZl9wMyA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPVxuICAgICAgTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMSlcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMilcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMylcbiAgICBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDNcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIG5hbWVkID0gKCdhLCAnYiwgJ2MpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIGMgPSBwM1xuXG4gICAgICAgIGxldCBjID0gb2ZfcDNcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyLCBwMykgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQzXG4gICAgICAgIHdpdGggdHlwZSB0ID0gKHAxLCBwMiwgcDMpIFgudClcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZTQgKFggOiBOYW1lZF9pbnRmLlM0KSA9IHN0cnVjdFxuICBtb2R1bGUgTmFtZV9vZl94ID0gVHlwZW5hbWUuTWFrZTQgKFgpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuXG4gIGxldCBuYW1lZCAodHlwZSBwMSBwMiBwMyBwNCkgb2ZfcDEgb2ZfcDIgb2ZfcDMgb2ZfcDQgPVxuICAgIGxldCB0eXBlbmFtZV9vZl90ID1cbiAgICAgIE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDEpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDIpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDMpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDQpXG4gICAgaW5cbiAgICBUeXBlcmVwLk5hbWVkLlQ0XG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgbmFtZWQgPSAoJ2EsICdiLCAnYywgJ2QpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIGMgPSBwM1xuXG4gICAgICAgIGxldCBjID0gb2ZfcDNcblxuICAgICAgICB0eXBlIGQgPSBwNFxuXG4gICAgICAgIGxldCBkID0gb2ZfcDRcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyLCBwMywgcDQpIFgudFxuXG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl9uYW1lZCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gdHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgd2l0bmVzcyA9IFR5cGVfZXF1YWwucmVmbFxuICAgICAgZW5kIDogVHlwZXJlcC5OYW1lZC5UNFxuICAgICAgICB3aXRoIHR5cGUgdCA9IChwMSwgcDIsIHAzLCBwNCkgWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlNSAoWCA6IE5hbWVkX2ludGYuUzUpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlNSAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxIHAyIHAzIHA0IHA1KSBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCBvZl9wNSA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPVxuICAgICAgTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMSlcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMilcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMylcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wNClcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wNSlcbiAgICBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDVcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWQgPSAoJ2EsICdiLCAnYywgJ2QsICdlKSBYLnRcbiAgICAgICAgdHlwZSBhID0gcDFcblxuICAgICAgICBsZXQgYSA9IG9mX3AxXG5cbiAgICAgICAgdHlwZSBiID0gcDJcblxuICAgICAgICBsZXQgYiA9IG9mX3AyXG5cbiAgICAgICAgdHlwZSBjID0gcDNcblxuICAgICAgICBsZXQgYyA9IG9mX3AzXG5cbiAgICAgICAgdHlwZSBkID0gcDRcblxuICAgICAgICBsZXQgZCA9IG9mX3A0XG5cbiAgICAgICAgdHlwZSBlID0gcDVcblxuICAgICAgICBsZXQgZSA9IG9mX3A1XG5cbiAgICAgICAgdHlwZSB0ID0gKHAxLCBwMiwgcDMsIHA0LCBwNSkgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQ1XG4gICAgICAgIHdpdGggdHlwZSB0ID0gKHAxLCBwMiwgcDMsIHA0LCBwNSkgWC50KVxuICA7O1xuZW5kXG4iLCJvcGVuIFN0ZF9pbnRlcm5hbFxuXG5tb2R1bGUgTWFrZTAgKFggOiBOYW1lZF9pbnRmLlMwKSA6IFR5cGVyZXBhYmxlLlMgd2l0aCB0eXBlIHQgOj0gWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlMCAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90ID0gVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCwgTm9uZSlcbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgTWFrZTEgKFggOiBOYW1lZF9pbnRmLlMxKSA6IFR5cGVyZXBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIFgudCA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTEgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCBvZl9wMSA9IFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQgb2ZfcDEsIE5vbmUpXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIE1ha2UyIChYIDogTmFtZWRfaW50Zi5TMikgOiBUeXBlcmVwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBYLnQgPVxuc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlMiAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxIG9mX3AyID0gVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSBvZl9wMiwgTm9uZSlcbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgTWFrZTMgKFggOiBOYW1lZF9pbnRmLlMzKSA6XG4gIFR5cGVyZXBhYmxlLlMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlMyAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxIG9mX3AyIG9mX3AzID0gVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSBvZl9wMiBvZl9wMywgTm9uZSlcbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgTWFrZTQgKFggOiBOYW1lZF9pbnRmLlM0KSA6XG4gIFR5cGVyZXBhYmxlLlM0IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgOj0gKCdhLCAnYiwgJ2MsICdkKSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2U0IChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgb2ZfcDIgb2ZfcDMgb2ZfcDQgPVxuICAgIFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQgb2ZfcDEgb2ZfcDIgb2ZfcDMgb2ZfcDQsIE5vbmUpXG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgTWFrZTUgKFggOiBOYW1lZF9pbnRmLlM1KSA6XG4gIFR5cGVyZXBhYmxlLlM1IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IDo9ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIFgudCA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTUgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCBvZl9wNSA9XG4gICAgVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCBvZl9wNSwgTm9uZSlcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG4iXX0=
